/*
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.enterprise.connectedapps.processor.containers;

import static com.google.android.enterprise.connectedapps.processor.ProtoParcelableWrapperGenerator.getGeneratedProtoWrapperClassName;
import static java.util.stream.Collectors.toSet;

import com.google.android.enterprise.connectedapps.annotations.CustomParcelableWrapper;
import com.google.android.enterprise.connectedapps.processor.TypeUtils;
import com.google.auto.value.AutoValue;
import com.squareup.javapoet.ClassName;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;

/** Information about a Parcelable Wrapper. */
@AutoValue
public abstract class ParcelableWrapper {

  /** The type of the Wrapper. This controls how supporting code is generated. */
  public enum WrapperType {
    DEFAULT, // Copied from a resource
    PROTO, // Generated by ProtoParcelableWrapperGenerator
    CUSTOM // Included in classpath
  }

  public static final String PARCELABLE_WRAPPER_PACKAGE =
      "com.google.android.enterprise.connectedapps.parcelablewrappers";

  public abstract TypeMirror wrappedType();

  public abstract ClassName defaultWrapperClassName();

  public abstract ClassName wrapperClassName();

  public abstract WrapperType wrapperType();

  private static ParcelableWrapper create(
      TypeMirror wrappedType, ClassName defaultWrapperClassName, WrapperType wrapperType) {
    return create(wrappedType, defaultWrapperClassName, defaultWrapperClassName, wrapperType);
  }

  public static ParcelableWrapper create(
      TypeMirror wrappedType,
      ClassName defaultWrapperClassName,
      ClassName wrapperClassName,
      WrapperType wrapperType) {
    return new AutoValue_ParcelableWrapper(
        wrappedType, defaultWrapperClassName, wrapperClassName, wrapperType);
  }

  public static Collection<ParcelableWrapper> createCustomParcelableWrappers(
      Types types, Elements elements, Collection<TypeElement> customParcelableWrappers) {
    Collection<ParcelableWrapper> wrappers = new ArrayList<>();

    addCustomParcelableWrappers(types, wrappers, customParcelableWrappers);

    return wrappers;
  }

  public static Collection<ParcelableWrapper> createGlobalParcelableWrappers(
      Types types, Elements elements, Collection<ExecutableElement> methods) {
    Collection<ParcelableWrapper> wrappers = new ArrayList<>();

    addDefaultParcelableWrappers(types, elements, wrappers);

    Collection<TypeMirror> usedTypes = extractTypesFromMethods(methods);

    addGeneratedProtoParcelableWrappers(types, elements, wrappers, usedTypes);

    return wrappers;
  }

  private static Collection<TypeMirror> extractTypesFromMethods(
      Collection<ExecutableElement> methods) {
    return methods.stream()
        .flatMap(m -> extractReturnTypeAndParameters(m).stream())
        .flatMap(t -> extractTypeArgumentsIfWrapped(t).stream())
        .collect(toSet());
  }

  private static Collection<TypeMirror> extractReturnTypeAndParameters(ExecutableElement method) {
    Collection<TypeMirror> types = new HashSet<>();
    types.add(method.getReturnType());
    types.addAll(method.getParameters().stream().map(Element::asType).collect(toSet()));
    return types;
  }

  private static Collection<TypeMirror> extractTypeArgumentsIfWrapped(TypeMirror type) {
    if (TypeUtils.isGeneric(type)) {
      return extractTypeArgumentsFromGeneric(type);
    }
    if (TypeUtils.isArray(type)) {
      return extractTypeArgumentsIfWrapped(TypeUtils.extractTypeFromArray(type));
    }

    return Collections.singleton(type);
  }

  private static Collection<TypeMirror> extractTypeArgumentsFromGeneric(TypeMirror type) {
    Collection<TypeMirror> types = new HashSet<>();
    types.add(TypeUtils.removeTypeArguments(type));

    types.addAll(
        TypeUtils.extractTypeArguments(type).stream()
            .flatMap(t -> extractTypeArgumentsIfWrapped(t).stream())
            .collect(toSet()));
    return types;
  }

  private static void addCustomParcelableWrappers(
      Types types,
      Collection<ParcelableWrapper> wrappers,
      Collection<TypeElement> customParcelableWrappers) {
    for (TypeElement parcelableWrapper : customParcelableWrappers) {
      addCustomParcelableWrapper(types, wrappers, parcelableWrapper);
    }
  }

  private static void addCustomParcelableWrapper(
      Types types, Collection<ParcelableWrapper> wrappers, TypeElement parcelableWrapper) {

    CustomParcelableWrapper customParcelableWrapperAnnotation =
        parcelableWrapper.getAnnotation(CustomParcelableWrapper.class);

    if (customParcelableWrapperAnnotation == null) {
      // This will be dealt with as part of early validation
      return;
    }

    ParcelableWrapperAnnotationInfo annotationInfo =
        ParcelableWrapperAnnotationInfo.extractFromParcelableWrapperAnnotation(
            types, customParcelableWrapperAnnotation);
    wrappers.add(
        ParcelableWrapper.create(
            annotationInfo.originalType().asType(),
            ClassName.get(parcelableWrapper),
            WrapperType.CUSTOM));
  }

  private static void addDefaultParcelableWrappers(
      Types types, Elements elements, Collection<ParcelableWrapper> wrappers) {
    tryAddWrapper(
        elements,
        wrappers,
        "java.util.Collection",
        ClassName.get(PARCELABLE_WRAPPER_PACKAGE, "ParcelableCollection"));

    tryAddWrapper(
        elements,
        wrappers,
        "java.util.List",
        ClassName.get(PARCELABLE_WRAPPER_PACKAGE, "ParcelableList"));

    tryAddWrapper(
        elements,
        wrappers,
        "java.util.Map",
        ClassName.get(PARCELABLE_WRAPPER_PACKAGE, "ParcelableMap"));

    tryAddWrapper(
        elements,
        wrappers,
        "java.util.Set",
        ClassName.get(PARCELABLE_WRAPPER_PACKAGE, "ParcelableSet"));

    tryAddWrapper(
        elements,
        wrappers,
        "java.util.Optional",
        ClassName.get(PARCELABLE_WRAPPER_PACKAGE, "ParcelableOptional"));

    tryAddWrapper(
        elements,
        wrappers,
        "com.google.common.base.Optional",
        ClassName.get(PARCELABLE_WRAPPER_PACKAGE, "ParcelableGuavaOptional"));

    tryAddWrapper(
        elements,
        wrappers,
        "com.google.common.collect.ImmutableMap",
        ClassName.get(PARCELABLE_WRAPPER_PACKAGE, "ParcelableImmutableMap"));

    tryAddWrapper(
        elements,
        wrappers,
        "android.util.Pair",
        ClassName.get(PARCELABLE_WRAPPER_PACKAGE, "ParcelablePair"));

    tryAddWrapper(
        elements,
        wrappers,
        "android.graphics.Bitmap",
        ClassName.get(PARCELABLE_WRAPPER_PACKAGE, "ParcelableBitmap"));

    addArrayWrappers(types, elements, wrappers);
  }

  private static void addGeneratedProtoParcelableWrappers(
      Types types,
      Elements elements,
      Collection<ParcelableWrapper> wrappers,
      Collection<TypeMirror> usedTypes) {
    TypeElement protoElement = elements.getTypeElement("com.google.protobuf.MessageLite");
    if (protoElement == null) {
      // Protos are not included at compile-time
      return;
    }
    TypeMirror proto = protoElement.asType();

    Collection<TypeMirror> protoTypes =
        usedTypes.stream()
                // <any> is the value when the compiler encounters a type which isn't accessible
                // or does not exist. This passes the types.isAssignable filter, which makes such
                // bugs hard to debug. This will already fail because the Java compiler won't allow
                // it - so this is just to suppress strange test failures
            .filter(t -> !t.toString().equals("<any>"))
            .filter(t -> types.isAssignable(t, proto))
            .collect(toSet());

    for (TypeMirror protoType : protoTypes) {
      wrappers.add(
          ParcelableWrapper.create(
              protoType, getGeneratedProtoWrapperClassName(protoType), WrapperType.PROTO));
    }
  }

  private static void addArrayWrappers(
      Types types, Elements elements, Collection<ParcelableWrapper> wrappers) {
    TypeElement typeElement = elements.getTypeElement("java.lang.Object");
    TypeMirror typeMirror = types.getArrayType(typeElement.asType());

    ClassName wrapperClassName = ClassName.get(PARCELABLE_WRAPPER_PACKAGE, "ParcelableArray");

    wrappers.add(ParcelableWrapper.create(typeMirror, wrapperClassName, WrapperType.DEFAULT));
  }

  private static void tryAddWrapper(
      Elements elements,
      Collection<ParcelableWrapper> wrappers,
      String typeQualifiedName,
      ClassName wrapperClassName) {
    TypeElement typeElement = elements.getTypeElement(typeQualifiedName);

    if (typeElement == null) {
      // The type isn't supported at compile-time - so won't be included in this app
      return;
    }

    wrappers.add(
        ParcelableWrapper.create(typeElement.asType(), wrapperClassName, WrapperType.DEFAULT));
  }
}
