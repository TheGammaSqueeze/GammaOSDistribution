/* AUTO-GENERATED FILE. DO NOT MODIFY.
 *
 * This class was automatically generated by the
 * aapt tool from the resource data it found. It
 * should not be modified by hand.
 */

package me.phh.treble.overlay.sony.J9110;

public final class R {
  public static final class array {
    /**
     * Array of output values for LCD backlight corresponding to the LUX values
     * in the config_autoBrightnessLevels array.  This array should have size one greater
     * than the size of the config_autoBrightnessLevels array.
     * The brightness values must be between 0 and 255 and be non-decreasing.
     * This must be overridden in platform specific overlays
     */
    public static final int config_autoBrightnessLcdBacklightValues=0x7f010000;
    /**
     * Array of light sensor LUX values to define our levels for auto backlight brightness support.
     * The N entries of this array define N + 1 control points as follows:
     * (1-based arrays)
     * Point 1: (0, value[1]): lux <= 0
     * Point 2: (level[1], value[2]): 0 < lux <= level[1]
     * Point 3: (level[2], value[3]): level[2] < lux <= level[3]
     * ...
     * Point N+1: (level[N], value[N+1]): level[N] < lux
     * The control points must be strictly increasing.  Each control point
     * corresponds to an entry in the brightness backlight values arrays.
     * For example, if LUX == level[1] (first element of the levels array)
     * then the brightness will be determined by value[2] (second element
     * of the brightness values array).
     * Spline interpolation is used to determine the auto-brightness
     * backlight values for LUX levels between these control points.
     * Must be overridden in platform specific overlays
     */
    public static final int config_autoBrightnessLevels=0x7f010001;
    /**
     * Default list of files pinned by the Pinner Service
     */
    public static final int config_defaultPinnerServiceFiles=0x7f010002;
    /**
     * Configure mobile tcp buffer sizes in the form:
     * rat-name:rmem_min,rmem_def,rmem_max,wmem_min,wmem_def,wmem_max
     * If no value is found for the rat-name in use, the system default will be applied.
     */
    public static final int config_mobile_tcp_buffers=0x7f010003;
    /**
     * List of regexpressions describing the interface (if any) that represent tetherable
     * bluetooth interfaces.  If the device doesn't want to support tethering over bluetooth this
     * should be empty.
     */
    public static final int config_tether_bluetooth_regexs=0x7f010004;
    /**
     * List of regexpressions describing the interface (if any) that represent tetherable
     * USB interfaces.  If the device doesn't want to support tething over USB this should
     * be empty.  An example would be "usb.*"
     */
    public static final int config_tether_usb_regexs=0x7f010005;
    /**
     * List of regexpressions describing the interface (if any) that represent tetherable
     * Wifi interfaces.  If the device doesn't want to support tethering over Wifi this
     * should be empty.  An example would be "softap.*"
     */
    public static final int config_tether_wifi_regexs=0x7f010006;
    /**
     * the 6th element indicates boot-time dependency-met value.
     */
    public static final int networkAttributes=0x7f010007;
    /**
     * An Array of "[ConnectivityManager connectionType],
     * [# simultaneous connection types]"
     */
    public static final int radioAttributes=0x7f010008;
  }
  public static final class bool {
    /**
     * Flag indicating whether the we should enable the automatic brightness in Settings.
     * Software implementation will be used if config_hardware_auto_brightness_available is not set
     */
    public static final int config_automatic_brightness_available=0x7f020000;
    /**
     * Boolean indicating if current platform supports BLE peripheral mode
     */
    public static final int config_bluetooth_le_peripheral_mode_supported=0x7f020001;
    /**
     * Flag specifying whether VoLTE is available on device
     */
    public static final int config_device_volte_available=0x7f020002;
    /**
     * Flag specifying whether WFC over IMS is available on device
     */
    public static final int config_device_wfc_ims_available=0x7f020003;
    /**
     * Whether the display blanks itself when transitioning from a doze to a non-doze state
     */
    public static final int config_displayBlanksAfterDoze=0x7f020004;
    /**
     * If true, the doze component is not started until after the screen has been turned off
     * and the screen off animation has been performed.
     */
    public static final int config_dozeAfterScreenOffByDefault=0x7f020005;
    /**
     * Control whether the always on display mode is available. This should only be enabled on
     * devices where the display has been tuned to be power efficient in DOZE and/or DOZE_SUSPEND
     * states.
     */
    public static final int config_dozeAlwaysOnDisplayAvailable=0x7f020006;
    /**
     * Flag specifying whether or not IMS will use the ImsResolver dynamically
     */
    public static final int config_dynamic_bind_ims=0x7f020007;
    /**
     * If true, the display will be shifted around in ambient mode.
     */
    public static final int config_enableBurnInProtection=0x7f020008;
    /**
     * Is the device capable of hot swapping an ICC Card
     */
    public static final int config_hotswapCapable=0x7f020009;
    /**
     * Is the notification LED intrusive? Used to decide if there should be a disable option
     */
    public static final int config_intrusiveNotificationLed=0x7f02000a;
    /**
     * Indicate whether closing the lid causes the device to go to sleep and opening
     * it causes the device to wake up.
     * The default is false.
     */
    public static final int config_lidControlsSleep=0x7f02000b;
    /**
     * Should the pinner service pin the Camera application?
     */
    public static final int config_pinnerCameraApp=0x7f02000c;
    /**
     * Should the pinner service pin the Home application?
     */
    public static final int config_pinnerHomeApp=0x7f02000d;
    /**
     * Power Management: Specifies whether to decouple the auto-suspend state of the
     * device from the display on/off state.
     * When false, autosuspend_disable() will be called before the display is turned on
     * and autosuspend_enable() will be called after the display is turned off.
     * This mode provides best compatibility for devices using legacy power management
     * features such as early suspend / late resume.
     * When true, autosuspend_display() and autosuspend_enable() will be called
     * independently of whether the display is being turned on or off.  This mode
     * enables the power manager to suspend the application processor while the
     * display is on.
     * This resource should be set to "true" when a doze component has been specified
     * to maximize power savings but not all devices support it.
     * Refer to autosuspend.h for details.
     */
    public static final int config_powerDecoupleAutoSuspendModeFromDisplay=0x7f02000e;
    /**
     * Boolean indicating whether the HWC setColorTransform function can be performed efficiently
     * in hardware.
     */
    public static final int config_setColorTransformAccelerated=0x7f02000f;
    /**
     * Whether a software navigation bar should be shown. NOTE: in the future this may be
     * autodetected from the Configuration.
     */
    public static final int config_showNavigationBar=0x7f020010;
    /**
     * Flag indicating if the speed up audio on mt call code should be executed
     */
    public static final int config_speed_up_audio_on_mt_calls=0x7f020011;
    /**
     * Indicate whether to allow the device to suspend when the screen is off
     * due to the proximity sensor.  This resource should only be set to true
     * if the sensor HAL correctly handles the proximity sensor as a wake-up source.
     * Otherwise, the device may fail to wake out of suspend reliably.
     * The default is false.
     */
    public static final int config_suspendWhenScreenOffDueToProximity=0x7f020012;
    /**
     * True if the device supports Sustained Performance Mode
     */
    public static final int config_sustainedPerformanceModeSupported=0x7f020013;
    /**
     * Config determines whether to update phone object when voice registration
     * state changes. Voice radio tech change will always trigger an update of
     * phone object irrespective of this config
     */
    public static final int config_switch_phone_on_voice_reg_state_change=0x7f020014;
    /**
     * When true use the linux /dev/input/event subsystem to detect the switch changes
     * on the headphone/microphone jack. When false use the older uevent framework.
     */
    public static final int config_useDevInputEventForAudioJack=0x7f020015;
    /**
     * Set to true if the wifi display supports compositing content stored
     * in gralloc protected buffers.  For this to be true, there must exist
     * a protected hardware path for surface flinger to composite and send
     * protected buffers to the wifi display video encoder.
     * If this flag is false, we advise applications not to use protected
     * buffers (if possible) when presenting content to a wifi display because
     * the content may be blanked.
     * This flag controls whether the {@link Display#FLAG_SUPPORTS_PROTECTED_BUFFERS}
     * flag is set for wifi displays.
     */
    public static final int config_wifiDisplaySupportsProtectedBuffers=0x7f020016;
    /**
     * The restoring is handled by modem if it is true
     */
    public static final int skip_restoring_network_selection=0x7f020017;
  }
  public static final class integer {
    /**
     * Operating volatage for bluetooth controller. 0 by default
     */
    public static final int config_bluetooth_operating_voltage_mv=0x7f030000;
    /**
     * Minimum allowable screen brightness to use in a very dark room.
     * This value sets the floor for the darkest possible auto-brightness
     * adjustment.  It is expected to be somewhat less than the first entry in
     * config_autoBrightnessLcdBacklightValues so as to allow the user to have
     * some range of adjustment to dim the screen further than usual in very
     * dark rooms. The contents of the screen must still be clearly visible
     * in darkness (although they may not be visible in a bright room).
     */
    public static final int config_screenBrightnessDark=0x7f030001;
    /**
     * Screen brightness used to dim the screen when the user activity
     * timeout expires.  May be less than the minimum allowed brightness setting
     * that can be set by the user.
     */
    public static final int config_screenBrightnessDim=0x7f030002;
    /**
     * Screen brightness used to dim the screen while dozing in a very low power state.
     * May be less than the minimum allowed brightness setting
     * that can be set by the user.
     */
    public static final int config_screenBrightnessDoze=0x7f030003;
    /**
     * Default screen brightness setting.
     * Must be in the range specified by minimum and maximum.
     */
    public static final int config_screenBrightnessSettingDefault=0x7f030004;
    /**
     * Minimum screen brightness setting allowed by the power manager.
     * The user is forbidden from setting the brightness below this level.
     */
    public static final int config_screenBrightnessSettingMinimum=0x7f030005;
    /**
     * Shutdown if the battery temperature exceeds (this value * 0.1) Celsius.
     */
    public static final int config_shutdownBatteryTemperature=0x7f030006;
  }
  public static final class xml {
    public static final int power_profile=0x7f040000;
  }
}