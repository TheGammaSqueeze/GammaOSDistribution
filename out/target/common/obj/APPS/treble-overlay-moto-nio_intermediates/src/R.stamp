/* AUTO-GENERATED FILE. DO NOT MODIFY.
 *
 * This class was automatically generated by the
 * aapt tool from the resource data it found. It
 * should not be modified by hand.
 */

package me.phh.treble.overlay.moto.nio;

public final class R {
  public static final class array {
    /**
     * Array of desired screen brightness in nits corresponding to the lux values
     * in the config_autoBrightnessLevels array. As with config_screenBrightnessMinimumNits and
     * config_screenBrightnessMaximumNits, the display brightness is defined as the measured
     * brightness of an all-white image.
     * If this is defined then:
     * - config_autoBrightnessLcdBacklightValues should not be defined
     * - config_screenBrightnessNits must be defined
     * - config_screenBrightnessBacklight must be defined
     * This array should have size one greater than the size of the config_autoBrightnessLevels
     * array. The brightness values must be non-negative and non-decreasing. This must be
     * overridden in platform specific overlays
     */
    public static final int config_autoBrightnessDisplayValuesNits=0x7f010000;
    /**
     * Array of light sensor LUX values to define our levels for auto backlight brightness support.
     * The N entries of this array define N + 1 control points as follows:
     * (1-based arrays)
     * Point 1:            (0, value[1]):             lux <= 0
     * Point 2:     (level[1], value[2]):  0        < lux <= level[1]
     * Point 3:     (level[2], value[3]):  level[2] < lux <= level[3]
     * ...
     * Point N+1: (level[N], value[N+1]):  level[N] < lux
     * The control points must be strictly increasing.  Each control point
     * corresponds to an entry in the brightness backlight values arrays.
     * For example, if LUX == level[1] (first element of the levels array)
     * then the brightness will be determined by value[2] (second element
     * of the brightness values array).
     * Spline interpolation is used to determine the auto-brightness
     * backlight values for LUX levels between these control points.
     * Must be overridden in platform specific overlays
     */
    public static final int config_autoBrightnessLevels=0x7f010001;
    /**
     * List of biometric sensors on the device, in decreasing strength. Consumed by AuthService
     * when registering authenticators with BiometricService. Format must be ID:Modality:Strength,
     * where: IDs are unique per device, Modality as defined in BiometricAuthenticator.java,
     * and Strength as defined in Authenticators.java
     */
    public static final int config_biometric_sensors=0x7f010002;
    /**
     * Vibrator pattern for a very short but reliable vibration for soft keyboard tap
     */
    public static final int config_keyboardTapVibePattern=0x7f010003;
    /**
     * Vibrator pattern for feedback about a long screen/key press
     */
    public static final int config_longPressVibePattern=0x7f010004;
    /**
     * Vibrator pattern for feedback about booting with safe mode enabled
     */
    public static final int config_safeModeEnabledVibePattern=0x7f010005;
    /**
     * An array describing the screen's backlight values corresponding to the brightness
     * values in the config_screenBrightnessNits array.
     * This array should be equal in size to config_screenBrightnessBacklight.
     */
    public static final int config_screenBrightnessBacklight=0x7f010006;
    /**
     * An array of floats describing the screen brightness in nits corresponding to the backlight
     * values in the config_screenBrightnessBacklight array.  On OLED displays these  values
     * should be measured with an all white image while the display is in the fully on state.
     * Note that this value should *not* reflect the maximum brightness value for any high
     * brightness modes but only the maximum brightness value obtainable in a sustainable manner.
     * This array should be equal in size to config_screenBrightnessBacklight
     */
    public static final int config_screenBrightnessNits=0x7f010007;
    /**
     * Vibrator pattern for feedback about hitting a scroll barrier
     */
    public static final int config_scrollBarrierVibePattern=0x7f010008;
    /**
     * Vibrator pattern for feedback about touching a virtual key
     */
    public static final int config_virtualKeyVibePattern=0x7f010009;
  }
  public static final class bool {
    /**
     * Specify if the fingerprint hardware support gestures
     */
    public static final int config_fingerprintSupportsGestures=0x7f020000;
    /**
     * Is the notification LED intrusive? Used to decide if there should be a disable option
     */
    public static final int config_intrusiveNotificationLed=0x7f020001;
    /**
     * Power Management: Specifies whether to decouple the auto-suspend state of the
     * device from the display on/off state.
     * When false, autosuspend_disable() will be called before the display is turned on
     * and autosuspend_enable() will be called after the display is turned off.
     * This mode provides best compatibility for devices using legacy power management
     * features such as early suspend / late resume.
     * When true, autosuspend_display() and autosuspend_enable() will be called
     * independently of whether the display is being turned on or off.  This mode
     * enables the power manager to suspend the application processor while the
     * display is on.
     * This resource should be set to "true" when a doze component has been specified
     * to maximize power savings but not all devices support it.
     * Refer to autosuspend.h for details.
     */
    public static final int config_powerDecoupleAutoSuspendModeFromDisplay=0x7f020002;
    /**
     * Power Management: Specifies whether to decouple the interactive state of the
     * device from the display on/off state.
     * When false, setInteractive(..., true) will be called before the display is turned on
     * and setInteractive(..., false) will be called after the display is turned off.
     * This mode provides best compatibility for devices that expect the interactive
     * state to be tied to the display state.
     * When true, setInteractive(...) will be called independently of whether the display
     * is being turned on or off.  This mode enables the power manager to reduce
     * clocks and disable the touch controller while the display is on.
     * This resource should be set to "true" when a doze component has been specified
     * to maximize power savings but not all devices support it.
     * Refer to power.h for details.
     */
    public static final int config_powerDecoupleInteractiveModeFromDisplay=0x7f020003;
    /**
     * Whether device supports double tap to wake
     */
    public static final int config_supportDoubleTapWake=0x7f020004;
    /**
     * True if the device supports system navigation keys.
     */
    public static final int config_supportSystemNavigationKeys=0x7f020005;
    /**
     * Indicate whether to allow the device to suspend when the screen is off
     * due to the proximity sensor.  This resource should only be set to true
     * if the sensor HAL correctly handles the proximity sensor as a wake-up source.
     * Otherwise, the device may fail to wake out of suspend reliably.
     * The default is false.
     */
    public static final int config_suspendWhenScreenOffDueToProximity=0x7f020006;
  }
  public static final class dimen {
    /**
     * Default radius of the software rounded corners.
     */
    public static final int rounded_corner_radius=0x7f030000;
    /**
     * Height of the status bar
     */
    public static final int status_bar_height=0x7f030001;
    /**
     * Height of the status bar in landscape. The height should be
     * Max((status bar content height + waterfall top size), top cutout size)
     */
    public static final int status_bar_height_landscape=0x7f030002;
    /**
     * Height of the status bar in portrait. The height should be
     * Max((status bar content height + waterfall top size), top cutout size)
     */
    public static final int status_bar_height_portrait=0x7f030003;
  }
  public static final class integer {
    /**
     * Screen brightness used to dim the screen when the user activity
     * timeout expires.  May be less than the minimum allowed brightness setting
     * that can be set by the user.
     */
    public static final int config_screenBrightnessDim=0x7f040000;
    /**
     * Minimum screen brightness setting allowed by the power manager.
     * The user is forbidden from setting the brightness below this level.
     */
    public static final int config_screenBrightnessSettingMinimum=0x7f040001;
  }
  public static final class string {
    /**
     * The bounding path of the cutout region of the main built-in display.
     * Must either be empty if there is no cutout region, or a string that is parsable by
     * {@link android.util.PathParser}.
     * The path is assumed to be specified in display coordinates with pixel units and in
     * the display's native orientation, with the origin of the coordinate system at the
     * center top of the display. Optionally, you can append either `@left` or `@right` to the
     * end of the path string, in order to change the path origin to either the top left,
     * or top right of the display.
     * To facilitate writing device-independent emulation overlays, the marker `@dp` can be
     * appended after the path string to interpret coordinates in dp instead of px units.
     * Note that a physical cutout should be configured in pixels for the best results.
     * Example for a 10px x 10px square top-center cutout:
     * <string ...>M -5,0 L -5,10 L 5,10 L 5,0 Z</string>
     * Example for a 10dp x 10dp square top-center cutout:
     * <string ...>M -5,0 L -5,10 L 5,10 L 5,0 Z @dp</string>
     * @see https://www.w3.org/TR/SVG/paths.html#PathData
     */
    public static final int config_mainBuiltInDisplayCutout=0x7f050000;
  }
  public static final class xml {
    public static final int power_profile=0x7f060000;
  }
}