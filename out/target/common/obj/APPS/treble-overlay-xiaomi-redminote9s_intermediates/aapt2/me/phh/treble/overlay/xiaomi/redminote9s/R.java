/* AUTO-GENERATED FILE. DO NOT MODIFY.
 *
 * This class was automatically generated by the
 * aapt tool from the resource data it found. It
 * should not be modified by hand.
 */

package me.phh.treble.overlay.xiaomi.redminote9s;

public final class R {
  public static final class array {
    /**
     * Array of ambient lux threshold values. This is used for determining hysteresis constraint
     * values by calculating the index to use for lookup and then setting the constraint value
     * to the corresponding value of the array. The new brightening hysteresis constraint value
     * is the n-th element of config_ambientBrighteningThresholds, and the new darkening
     * hysteresis constraint value is the n-th element of config_ambientDarkeningThresholds.
     * The (zero-based) index is calculated as follows: (MAX is the largest index of the array)
     * condition                       calculated index
     * value < level[0]                0
     * level[n] <= value < level[n+1]  n+1
     * level[MAX] <= value             MAX+1
     */
    public static final int config_ambientThresholdLevels=0x7f010000;
    /**
     * Array of desired screen brightness in nits corresponding to the lux values
     * in the config_autoBrightnessLevels array. As with config_screenBrightnessMinimumNits and
     * config_screenBrightnessMaximumNits, the display brightness is defined as the measured
     * brightness of an all-white image.
     * If this is defined then:
     * - config_autoBrightnessLcdBacklightValues should not be defined
     * - config_screenBrightnessNits must be defined
     * - config_screenBrightnessBacklight must be defined
     * This array should have size one greater than the size of the config_autoBrightnessLevels
     * array. The brightness values must be non-negative and non-decreasing. This must be
     * overridden in platform specific overlays
     */
    public static final int config_autoBrightnessDisplayValuesNits=0x7f010001;
    /**
     * Array of output values for LCD backlight corresponding to the lux values
     * in the config_autoBrightnessLevels array.  This array should have size one greater
     * than the size of the config_autoBrightnessLevels array.
     * The brightness values must be between 0 and 255 and be non-decreasing.
     * This must be overridden in platform specific overlays
     */
    public static final int config_autoBrightnessLcdBacklightValues=0x7f010002;
    /**
     * Array of light sensor lux values to define our levels for auto backlight brightness support.
     * The N entries of this array define N + 1 control points as follows:
     * (1-based arrays)
     * Point 1:            (0, value[1]):             lux <= 0
     * Point 2:     (level[1], value[2]):  0        < lux <= level[1]
     * Point 3:     (level[2], value[3]):  level[2] < lux <= level[3]
     * ...
     * Point N+1: (level[N], value[N+1]):  level[N] < lux
     * The control points must be strictly increasing.  Each control point
     * corresponds to an entry in the brightness backlight values arrays.
     * For example, if lux == level[1] (first element of the levels array)
     * then the brightness will be determined by value[2] (second element
     * of the brightness values array).
     * Spline interpolation is used to determine the auto-brightness
     * backlight values for lux levels between these control points.
     * Must be overridden in platform specific overlays
     */
    public static final int config_autoBrightnessLevels=0x7f010003;
    public static final int config_availableColorModes=0x7f010004;
    public static final int config_defaultPinnerServiceFiles=0x7f010005;
    public static final int config_gpsParameters=0x7f010006;
    public static final int config_lteDbmThresholds=0x7f010007;
    public static final int config_mobile_tcp_buffers=0x7f010008;
    /**
     * Array of hysteresis constraint values for brightening, represented as tenths of a
     * percent. The length of this array is assumed to be one greater than
     * config_screenThresholdLevels. The brightening threshold is calculated as
     * screenBrightness * (1.0f + CONSTRAINT_VALUE). When the new screen brightness is higher
     * than this threshold, it is applied. See the config_screenThresholdLevels description for
     * how the constraint value is chosen.
     */
    public static final int config_screenBrighteningThresholds=0x7f010009;
    /**
     * An array describing the screen's backlight values corresponding to the brightness
     * values in the config_screenBrightnessNits array.
     */
    public static final int config_screenBrightnessBacklight=0x7f01000a;
    /**
     * An array of floats describing the screen brightness in nits corresponding to the backlight
     * values in the config_screenBrightnessBacklight array.  On OLED displays these  values
     * should be measured with an all white image while the display is in the fully on state.
     * Note that this value should *not* reflect the maximum brightness value for any high
     * brightness modes but only the maximum brightness value obtainable in a sustainable manner.
     * This array should be equal in size to config_screenBrightnessBacklight
     */
    public static final int config_screenBrightnessNits=0x7f01000b;
    /**
     * Array of hysteresis constraint values for darkening, represented as tenths of a
     * percent. The length of this array is assumed to be one greater than
     * config_screenThresholdLevels. The darkening threshold is calculated as
     * screenBrightness * (1.0f - CONSTRAINT_VALUE). When the new screen brightness is lower than
     * this threshold, it is applied. See the config_screenThresholdLevels description for how
     * the constraint value is chosen.
     */
    public static final int config_screenDarkeningThresholds=0x7f01000c;
    public static final int config_tether_bluetooth_regexs=0x7f01000d;
    public static final int config_tether_upstream_types=0x7f01000e;
    public static final int config_tether_usb_regexs=0x7f01000f;
    public static final int config_tether_wifi_regexs=0x7f010010;
    public static final int networkAttributes=0x7f010011;
    public static final int radioAttributes=0x7f010012;
  }
  public static final class bool {
    public static final int config_bluetooth_hfp_inband_ringing_support=0x7f020000;
    public static final int config_bluetooth_le_peripheral_mode_supported=0x7f020001;
    public static final int config_carrier_volte_available=0x7f020002;
    public static final int config_device_volte_available=0x7f020003;
    public static final int config_device_vt_available=0x7f020004;
    public static final int config_device_wfc_ims_available=0x7f020005;
    public static final int config_hotswapCapable=0x7f020006;
    public static final int config_powerDecoupleInteractiveModeFromDisplay=0x7f020007;
    public static final int config_setColorTransformAccelerated=0x7f020008;
    public static final int config_showNavigationBar=0x7f020009;
    public static final int config_useDevInputEventForAudioJack=0x7f02000a;
    public static final int config_wifiDisplaySupportsProtectedBuffers=0x7f02000b;
    public static final int config_wifi_background_scan_support=0x7f02000c;
    public static final int config_wifi_batched_scan_supported=0x7f02000d;
    public static final int config_wifi_connected_mac_randomization_supported=0x7f02000e;
    public static final int config_wifi_dual_band_support=0x7f02000f;
    public static final int config_wifi_p2p_mac_randomization_supported=0x7f020010;
    /**
     * The restoring is handled by modem if it is true
     */
    public static final int skip_restoring_network_selection=0x7f020011;
  }
  public static final class dimen {
    public static final int rounded_corner_radius_bottom=0x7f030000;
    public static final int rounded_corner_radius_top=0x7f030001;
    public static final int status_bar_height=0x7f030002;
    public static final int status_bar_height_landscape=0x7f030003;
    public static final int status_bar_height_portrait=0x7f030004;
  }
  public static final class fraction {
    /**
     * The maximum range of gamma adjustment possible using the screen
     * auto-brightness adjustment setting.
     */
    public static final int config_autoBrightnessAdjustmentMaxGamma=0x7f040000;
  }
  public static final class integer {
    /**
     * Stability requirements in milliseconds for accepting a new brightness level.  This is used
     * for debouncing the light sensor.  Different constants are used to debounce the light sensor
     * when adapting to brighter or darker environments.  This parameter controls how quickly
     * brightness changes occur in response to an observed change in light level that exceeds the
     * hysteresis threshold.
     */
    public static final int config_autoBrightnessBrighteningLightDebounce=0x7f050000;
    public static final int config_autoBrightnessDarkeningLightDebounce=0x7f050001;
    /**
     * Idle current for bluetooth controller. 0 by default
     */
    public static final int config_bluetooth_idle_cur_ma=0x7f050002;
    /**
     * Operating voltage for bluetooth controller. 0 by default
     */
    public static final int config_bluetooth_operating_voltage_mv=0x7f050003;
    /**
     * Rx current for bluetooth controller. 0 by default
     */
    public static final int config_bluetooth_rx_cur_ma=0x7f050004;
    /**
     * Tx current for bluetooth controller. 0 by default
     */
    public static final int config_bluetooth_tx_cur_ma=0x7f050005;
    /**
     * Fast brightness animation ramp rate in brightness units per second
     */
    public static final int config_brightness_ramp_rate_fast=0x7f050006;
    /**
     * Slow brightness animation ramp rate in brightness units per second
     */
    public static final int config_brightness_ramp_rate_slow=0x7f050007;
    /**
     * Screen brightness used to dim the screen when the user activity
     * timeout expires.  May be less than the minimum allowed brightness setting
     * that can be set by the user.
     */
    public static final int config_screenBrightnessDim=0x7f050008;
    /**
     * Default screen brightness setting.
     * Must be in the range specified by minimum and maximum.
     */
    public static final int config_screenBrightnessSettingDefault=0x7f050009;
    /**
     * Maximum screen brightness allowed by the power manager.
     * The user is forbidden from setting the brightness above this level.
     */
    public static final int config_screenBrightnessSettingMaximum=0x7f05000a;
    /**
     * Minimum screen brightness setting allowed by the power manager.
     * The user is forbidden from setting the brightness below this level.
     */
    public static final int config_screenBrightnessSettingMinimum=0x7f05000b;
    /**
     * Shutdown if the battery temperature exceeds (this value * 0.1) Celsius.
     */
    public static final int config_shutdownBatteryTemperature=0x7f05000c;
  }
  public static final class xml {
    public static final int power_profile=0x7f060000;
  }
}