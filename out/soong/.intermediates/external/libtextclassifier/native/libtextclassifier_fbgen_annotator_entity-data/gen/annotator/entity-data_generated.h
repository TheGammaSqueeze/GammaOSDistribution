// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ENTITYDATA_LIBTEXTCLASSIFIER3_H_
#define FLATBUFFERS_GENERATED_ENTITYDATA_LIBTEXTCLASSIFIER3_H_

#include "flatbuffers/flatbuffers.h"

namespace libtextclassifier3 {
namespace EntityData_ {
namespace Datetime_ {

struct DatetimeComponent;
struct DatetimeComponentBuilder;
struct DatetimeComponentT;

}  // namespace Datetime_

struct Datetime;
struct DatetimeBuilder;
struct DatetimeT;

struct Contact;
struct ContactBuilder;
struct ContactT;

struct App;
struct AppBuilder;
struct AppT;

struct PaymentCard;
struct PaymentCardBuilder;
struct PaymentCardT;

struct Flight;
struct FlightBuilder;
struct FlightT;

struct Isbn;
struct IsbnBuilder;
struct IsbnT;

struct Iban;
struct IbanBuilder;
struct IbanT;

struct ParcelTracking;
struct ParcelTrackingBuilder;
struct ParcelTrackingT;

struct Money;
struct MoneyBuilder;
struct MoneyT;

namespace Translate_ {

struct LanguagePredictionResult;
struct LanguagePredictionResultBuilder;
struct LanguagePredictionResultT;

}  // namespace Translate_

struct Translate;
struct TranslateBuilder;
struct TranslateT;

}  // namespace EntityData_

struct EntityData;
struct EntityDataBuilder;
struct EntityDataT;

namespace EntityData_ {
namespace Datetime_ {

enum Granularity {
  Granularity_GRANULARITY_UNKNOWN = -1,
  Granularity_GRANULARITY_YEAR = 0,
  Granularity_GRANULARITY_MONTH = 1,
  Granularity_GRANULARITY_WEEK = 2,
  Granularity_GRANULARITY_DAY = 3,
  Granularity_GRANULARITY_HOUR = 4,
  Granularity_GRANULARITY_MINUTE = 5,
  Granularity_GRANULARITY_SECOND = 6,
  Granularity_MIN = Granularity_GRANULARITY_UNKNOWN,
  Granularity_MAX = Granularity_GRANULARITY_SECOND
};

inline const Granularity (&EnumValuesGranularity())[8] {
  static const Granularity values[] = {
    Granularity_GRANULARITY_UNKNOWN,
    Granularity_GRANULARITY_YEAR,
    Granularity_GRANULARITY_MONTH,
    Granularity_GRANULARITY_WEEK,
    Granularity_GRANULARITY_DAY,
    Granularity_GRANULARITY_HOUR,
    Granularity_GRANULARITY_MINUTE,
    Granularity_GRANULARITY_SECOND
  };
  return values;
}

inline const char * const *EnumNamesGranularity() {
  static const char * const names[9] = {
    "GRANULARITY_UNKNOWN",
    "GRANULARITY_YEAR",
    "GRANULARITY_MONTH",
    "GRANULARITY_WEEK",
    "GRANULARITY_DAY",
    "GRANULARITY_HOUR",
    "GRANULARITY_MINUTE",
    "GRANULARITY_SECOND",
    nullptr
  };
  return names;
}

inline const char *EnumNameGranularity(Granularity e) {
  if (flatbuffers::IsOutRange(e, Granularity_GRANULARITY_UNKNOWN, Granularity_GRANULARITY_SECOND)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(Granularity_GRANULARITY_UNKNOWN);
  return EnumNamesGranularity()[index];
}

namespace DatetimeComponent_ {

enum ComponentType {
  ComponentType_UNSPECIFIED = 0,
  ComponentType_YEAR = 1,
  ComponentType_MONTH = 2,
  ComponentType_WEEK = 3,
  ComponentType_DAY_OF_WEEK = 4,
  ComponentType_DAY_OF_MONTH = 5,
  ComponentType_HOUR = 6,
  ComponentType_MINUTE = 7,
  ComponentType_SECOND = 8,
  ComponentType_MERIDIEM = 9,
  ComponentType_ZONE_OFFSET = 10,
  ComponentType_DST_OFFSET = 11,
  ComponentType_MIN = ComponentType_UNSPECIFIED,
  ComponentType_MAX = ComponentType_DST_OFFSET
};

inline const ComponentType (&EnumValuesComponentType())[12] {
  static const ComponentType values[] = {
    ComponentType_UNSPECIFIED,
    ComponentType_YEAR,
    ComponentType_MONTH,
    ComponentType_WEEK,
    ComponentType_DAY_OF_WEEK,
    ComponentType_DAY_OF_MONTH,
    ComponentType_HOUR,
    ComponentType_MINUTE,
    ComponentType_SECOND,
    ComponentType_MERIDIEM,
    ComponentType_ZONE_OFFSET,
    ComponentType_DST_OFFSET
  };
  return values;
}

inline const char * const *EnumNamesComponentType() {
  static const char * const names[13] = {
    "UNSPECIFIED",
    "YEAR",
    "MONTH",
    "WEEK",
    "DAY_OF_WEEK",
    "DAY_OF_MONTH",
    "HOUR",
    "MINUTE",
    "SECOND",
    "MERIDIEM",
    "ZONE_OFFSET",
    "DST_OFFSET",
    nullptr
  };
  return names;
}

inline const char *EnumNameComponentType(ComponentType e) {
  if (flatbuffers::IsOutRange(e, ComponentType_UNSPECIFIED, ComponentType_DST_OFFSET)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesComponentType()[index];
}

enum RelationType {
  RelationType_RELATION_UNSPECIFIED = 0,
  RelationType_ABSOLUTE = 1,
  RelationType_RELATIVE = 2,
  RelationType_MIN = RelationType_RELATION_UNSPECIFIED,
  RelationType_MAX = RelationType_RELATIVE
};

inline const RelationType (&EnumValuesRelationType())[3] {
  static const RelationType values[] = {
    RelationType_RELATION_UNSPECIFIED,
    RelationType_ABSOLUTE,
    RelationType_RELATIVE
  };
  return values;
}

inline const char * const *EnumNamesRelationType() {
  static const char * const names[4] = {
    "RELATION_UNSPECIFIED",
    "ABSOLUTE",
    "RELATIVE",
    nullptr
  };
  return names;
}

inline const char *EnumNameRelationType(RelationType e) {
  if (flatbuffers::IsOutRange(e, RelationType_RELATION_UNSPECIFIED, RelationType_RELATIVE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRelationType()[index];
}

}  // namespace DatetimeComponent_
}  // namespace Datetime_

namespace PaymentCard_ {

enum CardNetwork {
  CardNetwork_UNKNOWN_CARD_NETWORK = 0,
  CardNetwork_AMEX = 1,
  CardNetwork_DINERS_CLUB = 2,
  CardNetwork_DISCOVER = 3,
  CardNetwork_INTER_PAYMENT = 4,
  CardNetwork_JCB = 5,
  CardNetwork_MAESTRO = 6,
  CardNetwork_MASTERCARD = 7,
  CardNetwork_MIR = 8,
  CardNetwork_TROY = 9,
  CardNetwork_UNIONPAY = 10,
  CardNetwork_VISA = 11,
  CardNetwork_MIN = CardNetwork_UNKNOWN_CARD_NETWORK,
  CardNetwork_MAX = CardNetwork_VISA
};

inline const CardNetwork (&EnumValuesCardNetwork())[12] {
  static const CardNetwork values[] = {
    CardNetwork_UNKNOWN_CARD_NETWORK,
    CardNetwork_AMEX,
    CardNetwork_DINERS_CLUB,
    CardNetwork_DISCOVER,
    CardNetwork_INTER_PAYMENT,
    CardNetwork_JCB,
    CardNetwork_MAESTRO,
    CardNetwork_MASTERCARD,
    CardNetwork_MIR,
    CardNetwork_TROY,
    CardNetwork_UNIONPAY,
    CardNetwork_VISA
  };
  return values;
}

inline const char * const *EnumNamesCardNetwork() {
  static const char * const names[13] = {
    "UNKNOWN_CARD_NETWORK",
    "AMEX",
    "DINERS_CLUB",
    "DISCOVER",
    "INTER_PAYMENT",
    "JCB",
    "MAESTRO",
    "MASTERCARD",
    "MIR",
    "TROY",
    "UNIONPAY",
    "VISA",
    nullptr
  };
  return names;
}

inline const char *EnumNameCardNetwork(CardNetwork e) {
  if (flatbuffers::IsOutRange(e, CardNetwork_UNKNOWN_CARD_NETWORK, CardNetwork_VISA)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCardNetwork()[index];
}

}  // namespace PaymentCard_

namespace ParcelTracking_ {

enum Carrier {
  Carrier_UNKNOWN_CARRIER = 0,
  Carrier_FEDEX = 1,
  Carrier_UPS = 2,
  Carrier_DHL = 3,
  Carrier_USPS = 4,
  Carrier_ONTRAC = 5,
  Carrier_LASERSHIP = 6,
  Carrier_ISRAEL_POST = 7,
  Carrier_SWISS_POST = 8,
  Carrier_MSC = 9,
  Carrier_AMAZON = 10,
  Carrier_I_PARCEL = 11,
  Carrier_MIN = Carrier_UNKNOWN_CARRIER,
  Carrier_MAX = Carrier_I_PARCEL
};

inline const Carrier (&EnumValuesCarrier())[12] {
  static const Carrier values[] = {
    Carrier_UNKNOWN_CARRIER,
    Carrier_FEDEX,
    Carrier_UPS,
    Carrier_DHL,
    Carrier_USPS,
    Carrier_ONTRAC,
    Carrier_LASERSHIP,
    Carrier_ISRAEL_POST,
    Carrier_SWISS_POST,
    Carrier_MSC,
    Carrier_AMAZON,
    Carrier_I_PARCEL
  };
  return values;
}

inline const char * const *EnumNamesCarrier() {
  static const char * const names[13] = {
    "UNKNOWN_CARRIER",
    "FEDEX",
    "UPS",
    "DHL",
    "USPS",
    "ONTRAC",
    "LASERSHIP",
    "ISRAEL_POST",
    "SWISS_POST",
    "MSC",
    "AMAZON",
    "I_PARCEL",
    nullptr
  };
  return names;
}

inline const char *EnumNameCarrier(Carrier e) {
  if (flatbuffers::IsOutRange(e, Carrier_UNKNOWN_CARRIER, Carrier_I_PARCEL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCarrier()[index];
}

}  // namespace ParcelTracking_

namespace Datetime_ {

struct DatetimeComponentT : public flatbuffers::NativeTable {
  typedef DatetimeComponent TableType;
  libtextclassifier3::EntityData_::Datetime_::DatetimeComponent_::ComponentType component_type;
  int32_t absolute_value;
  int32_t relative_count;
  libtextclassifier3::EntityData_::Datetime_::DatetimeComponent_::RelationType relation_type;
  DatetimeComponentT()
      : component_type(libtextclassifier3::EntityData_::Datetime_::DatetimeComponent_::ComponentType_UNSPECIFIED),
        absolute_value(0),
        relative_count(0),
        relation_type(libtextclassifier3::EntityData_::Datetime_::DatetimeComponent_::RelationType_RELATION_UNSPECIFIED) {
  }
};

struct DatetimeComponent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DatetimeComponentT NativeTableType;
  typedef DatetimeComponentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMPONENT_TYPE = 4,
    VT_ABSOLUTE_VALUE = 6,
    VT_RELATIVE_COUNT = 8,
    VT_RELATION_TYPE = 10
  };
  libtextclassifier3::EntityData_::Datetime_::DatetimeComponent_::ComponentType component_type() const {
    return static_cast<libtextclassifier3::EntityData_::Datetime_::DatetimeComponent_::ComponentType>(GetField<int32_t>(VT_COMPONENT_TYPE, 0));
  }
  int32_t absolute_value() const {
    return GetField<int32_t>(VT_ABSOLUTE_VALUE, 0);
  }
  int32_t relative_count() const {
    return GetField<int32_t>(VT_RELATIVE_COUNT, 0);
  }
  libtextclassifier3::EntityData_::Datetime_::DatetimeComponent_::RelationType relation_type() const {
    return static_cast<libtextclassifier3::EntityData_::Datetime_::DatetimeComponent_::RelationType>(GetField<int32_t>(VT_RELATION_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COMPONENT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_ABSOLUTE_VALUE) &&
           VerifyField<int32_t>(verifier, VT_RELATIVE_COUNT) &&
           VerifyField<int32_t>(verifier, VT_RELATION_TYPE) &&
           verifier.EndTable();
  }
  DatetimeComponentT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DatetimeComponentT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DatetimeComponent> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DatetimeComponentT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DatetimeComponentBuilder {
  typedef DatetimeComponent Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_component_type(libtextclassifier3::EntityData_::Datetime_::DatetimeComponent_::ComponentType component_type) {
    fbb_.AddElement<int32_t>(DatetimeComponent::VT_COMPONENT_TYPE, static_cast<int32_t>(component_type), 0);
  }
  void add_absolute_value(int32_t absolute_value) {
    fbb_.AddElement<int32_t>(DatetimeComponent::VT_ABSOLUTE_VALUE, absolute_value, 0);
  }
  void add_relative_count(int32_t relative_count) {
    fbb_.AddElement<int32_t>(DatetimeComponent::VT_RELATIVE_COUNT, relative_count, 0);
  }
  void add_relation_type(libtextclassifier3::EntityData_::Datetime_::DatetimeComponent_::RelationType relation_type) {
    fbb_.AddElement<int32_t>(DatetimeComponent::VT_RELATION_TYPE, static_cast<int32_t>(relation_type), 0);
  }
  explicit DatetimeComponentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DatetimeComponentBuilder &operator=(const DatetimeComponentBuilder &);
  flatbuffers::Offset<DatetimeComponent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DatetimeComponent>(end);
    return o;
  }
};

inline flatbuffers::Offset<DatetimeComponent> CreateDatetimeComponent(
    flatbuffers::FlatBufferBuilder &_fbb,
    libtextclassifier3::EntityData_::Datetime_::DatetimeComponent_::ComponentType component_type = libtextclassifier3::EntityData_::Datetime_::DatetimeComponent_::ComponentType_UNSPECIFIED,
    int32_t absolute_value = 0,
    int32_t relative_count = 0,
    libtextclassifier3::EntityData_::Datetime_::DatetimeComponent_::RelationType relation_type = libtextclassifier3::EntityData_::Datetime_::DatetimeComponent_::RelationType_RELATION_UNSPECIFIED) {
  DatetimeComponentBuilder builder_(_fbb);
  builder_.add_relation_type(relation_type);
  builder_.add_relative_count(relative_count);
  builder_.add_absolute_value(absolute_value);
  builder_.add_component_type(component_type);
  return builder_.Finish();
}

flatbuffers::Offset<DatetimeComponent> CreateDatetimeComponent(flatbuffers::FlatBufferBuilder &_fbb, const DatetimeComponentT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace Datetime_

struct DatetimeT : public flatbuffers::NativeTable {
  typedef Datetime TableType;
  int64_t time_ms_utc;
  libtextclassifier3::EntityData_::Datetime_::Granularity granularity;
  std::vector<std::unique_ptr<libtextclassifier3::EntityData_::Datetime_::DatetimeComponentT>> datetime_component;
  DatetimeT()
      : time_ms_utc(0),
        granularity(libtextclassifier3::EntityData_::Datetime_::Granularity_GRANULARITY_UNKNOWN) {
  }
};

struct Datetime FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DatetimeT NativeTableType;
  typedef DatetimeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME_MS_UTC = 4,
    VT_GRANULARITY = 6,
    VT_DATETIME_COMPONENT = 8
  };
  int64_t time_ms_utc() const {
    return GetField<int64_t>(VT_TIME_MS_UTC, 0);
  }
  libtextclassifier3::EntityData_::Datetime_::Granularity granularity() const {
    return static_cast<libtextclassifier3::EntityData_::Datetime_::Granularity>(GetField<int32_t>(VT_GRANULARITY, -1));
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::EntityData_::Datetime_::DatetimeComponent>> *datetime_component() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::EntityData_::Datetime_::DatetimeComponent>> *>(VT_DATETIME_COMPONENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIME_MS_UTC) &&
           VerifyField<int32_t>(verifier, VT_GRANULARITY) &&
           VerifyOffset(verifier, VT_DATETIME_COMPONENT) &&
           verifier.VerifyVector(datetime_component()) &&
           verifier.VerifyVectorOfTables(datetime_component()) &&
           verifier.EndTable();
  }
  DatetimeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DatetimeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Datetime> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DatetimeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DatetimeBuilder {
  typedef Datetime Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time_ms_utc(int64_t time_ms_utc) {
    fbb_.AddElement<int64_t>(Datetime::VT_TIME_MS_UTC, time_ms_utc, 0);
  }
  void add_granularity(libtextclassifier3::EntityData_::Datetime_::Granularity granularity) {
    fbb_.AddElement<int32_t>(Datetime::VT_GRANULARITY, static_cast<int32_t>(granularity), -1);
  }
  void add_datetime_component(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::EntityData_::Datetime_::DatetimeComponent>>> datetime_component) {
    fbb_.AddOffset(Datetime::VT_DATETIME_COMPONENT, datetime_component);
  }
  explicit DatetimeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DatetimeBuilder &operator=(const DatetimeBuilder &);
  flatbuffers::Offset<Datetime> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Datetime>(end);
    return o;
  }
};

inline flatbuffers::Offset<Datetime> CreateDatetime(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t time_ms_utc = 0,
    libtextclassifier3::EntityData_::Datetime_::Granularity granularity = libtextclassifier3::EntityData_::Datetime_::Granularity_GRANULARITY_UNKNOWN,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::EntityData_::Datetime_::DatetimeComponent>>> datetime_component = 0) {
  DatetimeBuilder builder_(_fbb);
  builder_.add_time_ms_utc(time_ms_utc);
  builder_.add_datetime_component(datetime_component);
  builder_.add_granularity(granularity);
  return builder_.Finish();
}

inline flatbuffers::Offset<Datetime> CreateDatetimeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t time_ms_utc = 0,
    libtextclassifier3::EntityData_::Datetime_::Granularity granularity = libtextclassifier3::EntityData_::Datetime_::Granularity_GRANULARITY_UNKNOWN,
    const std::vector<flatbuffers::Offset<libtextclassifier3::EntityData_::Datetime_::DatetimeComponent>> *datetime_component = nullptr) {
  auto datetime_component__ = datetime_component ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::EntityData_::Datetime_::DatetimeComponent>>(*datetime_component) : 0;
  return libtextclassifier3::EntityData_::CreateDatetime(
      _fbb,
      time_ms_utc,
      granularity,
      datetime_component__);
}

flatbuffers::Offset<Datetime> CreateDatetime(flatbuffers::FlatBufferBuilder &_fbb, const DatetimeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ContactT : public flatbuffers::NativeTable {
  typedef Contact TableType;
  std::string name;
  std::string given_name;
  std::string nickname;
  std::string email_address;
  std::string phone_number;
  std::string contact_id;
  ContactT() {
  }
};

struct Contact FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ContactT NativeTableType;
  typedef ContactBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_GIVEN_NAME = 6,
    VT_NICKNAME = 8,
    VT_EMAIL_ADDRESS = 10,
    VT_PHONE_NUMBER = 12,
    VT_CONTACT_ID = 14
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *given_name() const {
    return GetPointer<const flatbuffers::String *>(VT_GIVEN_NAME);
  }
  const flatbuffers::String *nickname() const {
    return GetPointer<const flatbuffers::String *>(VT_NICKNAME);
  }
  const flatbuffers::String *email_address() const {
    return GetPointer<const flatbuffers::String *>(VT_EMAIL_ADDRESS);
  }
  const flatbuffers::String *phone_number() const {
    return GetPointer<const flatbuffers::String *>(VT_PHONE_NUMBER);
  }
  const flatbuffers::String *contact_id() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTACT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_GIVEN_NAME) &&
           verifier.VerifyString(given_name()) &&
           VerifyOffset(verifier, VT_NICKNAME) &&
           verifier.VerifyString(nickname()) &&
           VerifyOffset(verifier, VT_EMAIL_ADDRESS) &&
           verifier.VerifyString(email_address()) &&
           VerifyOffset(verifier, VT_PHONE_NUMBER) &&
           verifier.VerifyString(phone_number()) &&
           VerifyOffset(verifier, VT_CONTACT_ID) &&
           verifier.VerifyString(contact_id()) &&
           verifier.EndTable();
  }
  ContactT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ContactT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Contact> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ContactT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ContactBuilder {
  typedef Contact Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Contact::VT_NAME, name);
  }
  void add_given_name(flatbuffers::Offset<flatbuffers::String> given_name) {
    fbb_.AddOffset(Contact::VT_GIVEN_NAME, given_name);
  }
  void add_nickname(flatbuffers::Offset<flatbuffers::String> nickname) {
    fbb_.AddOffset(Contact::VT_NICKNAME, nickname);
  }
  void add_email_address(flatbuffers::Offset<flatbuffers::String> email_address) {
    fbb_.AddOffset(Contact::VT_EMAIL_ADDRESS, email_address);
  }
  void add_phone_number(flatbuffers::Offset<flatbuffers::String> phone_number) {
    fbb_.AddOffset(Contact::VT_PHONE_NUMBER, phone_number);
  }
  void add_contact_id(flatbuffers::Offset<flatbuffers::String> contact_id) {
    fbb_.AddOffset(Contact::VT_CONTACT_ID, contact_id);
  }
  explicit ContactBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContactBuilder &operator=(const ContactBuilder &);
  flatbuffers::Offset<Contact> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Contact>(end);
    return o;
  }
};

inline flatbuffers::Offset<Contact> CreateContact(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> given_name = 0,
    flatbuffers::Offset<flatbuffers::String> nickname = 0,
    flatbuffers::Offset<flatbuffers::String> email_address = 0,
    flatbuffers::Offset<flatbuffers::String> phone_number = 0,
    flatbuffers::Offset<flatbuffers::String> contact_id = 0) {
  ContactBuilder builder_(_fbb);
  builder_.add_contact_id(contact_id);
  builder_.add_phone_number(phone_number);
  builder_.add_email_address(email_address);
  builder_.add_nickname(nickname);
  builder_.add_given_name(given_name);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Contact> CreateContactDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *given_name = nullptr,
    const char *nickname = nullptr,
    const char *email_address = nullptr,
    const char *phone_number = nullptr,
    const char *contact_id = nullptr) {
  auto name__ = name ? _fbb.CreateSharedString(name) : 0;
  auto given_name__ = given_name ? _fbb.CreateSharedString(given_name) : 0;
  auto nickname__ = nickname ? _fbb.CreateSharedString(nickname) : 0;
  auto email_address__ = email_address ? _fbb.CreateSharedString(email_address) : 0;
  auto phone_number__ = phone_number ? _fbb.CreateSharedString(phone_number) : 0;
  auto contact_id__ = contact_id ? _fbb.CreateSharedString(contact_id) : 0;
  return libtextclassifier3::EntityData_::CreateContact(
      _fbb,
      name__,
      given_name__,
      nickname__,
      email_address__,
      phone_number__,
      contact_id__);
}

flatbuffers::Offset<Contact> CreateContact(flatbuffers::FlatBufferBuilder &_fbb, const ContactT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AppT : public flatbuffers::NativeTable {
  typedef App TableType;
  std::string name;
  std::string package_name;
  AppT() {
  }
};

struct App FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AppT NativeTableType;
  typedef AppBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_PACKAGE_NAME = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *package_name() const {
    return GetPointer<const flatbuffers::String *>(VT_PACKAGE_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_PACKAGE_NAME) &&
           verifier.VerifyString(package_name()) &&
           verifier.EndTable();
  }
  AppT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AppT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<App> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AppT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AppBuilder {
  typedef App Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(App::VT_NAME, name);
  }
  void add_package_name(flatbuffers::Offset<flatbuffers::String> package_name) {
    fbb_.AddOffset(App::VT_PACKAGE_NAME, package_name);
  }
  explicit AppBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AppBuilder &operator=(const AppBuilder &);
  flatbuffers::Offset<App> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<App>(end);
    return o;
  }
};

inline flatbuffers::Offset<App> CreateApp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> package_name = 0) {
  AppBuilder builder_(_fbb);
  builder_.add_package_name(package_name);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<App> CreateAppDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *package_name = nullptr) {
  auto name__ = name ? _fbb.CreateSharedString(name) : 0;
  auto package_name__ = package_name ? _fbb.CreateSharedString(package_name) : 0;
  return libtextclassifier3::EntityData_::CreateApp(
      _fbb,
      name__,
      package_name__);
}

flatbuffers::Offset<App> CreateApp(flatbuffers::FlatBufferBuilder &_fbb, const AppT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PaymentCardT : public flatbuffers::NativeTable {
  typedef PaymentCard TableType;
  libtextclassifier3::EntityData_::PaymentCard_::CardNetwork card_network;
  std::string card_number;
  PaymentCardT()
      : card_network(libtextclassifier3::EntityData_::PaymentCard_::CardNetwork_UNKNOWN_CARD_NETWORK) {
  }
};

struct PaymentCard FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PaymentCardT NativeTableType;
  typedef PaymentCardBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CARD_NETWORK = 4,
    VT_CARD_NUMBER = 6
  };
  libtextclassifier3::EntityData_::PaymentCard_::CardNetwork card_network() const {
    return static_cast<libtextclassifier3::EntityData_::PaymentCard_::CardNetwork>(GetField<int32_t>(VT_CARD_NETWORK, 0));
  }
  const flatbuffers::String *card_number() const {
    return GetPointer<const flatbuffers::String *>(VT_CARD_NUMBER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CARD_NETWORK) &&
           VerifyOffset(verifier, VT_CARD_NUMBER) &&
           verifier.VerifyString(card_number()) &&
           verifier.EndTable();
  }
  PaymentCardT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PaymentCardT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PaymentCard> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PaymentCardT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PaymentCardBuilder {
  typedef PaymentCard Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_card_network(libtextclassifier3::EntityData_::PaymentCard_::CardNetwork card_network) {
    fbb_.AddElement<int32_t>(PaymentCard::VT_CARD_NETWORK, static_cast<int32_t>(card_network), 0);
  }
  void add_card_number(flatbuffers::Offset<flatbuffers::String> card_number) {
    fbb_.AddOffset(PaymentCard::VT_CARD_NUMBER, card_number);
  }
  explicit PaymentCardBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PaymentCardBuilder &operator=(const PaymentCardBuilder &);
  flatbuffers::Offset<PaymentCard> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PaymentCard>(end);
    return o;
  }
};

inline flatbuffers::Offset<PaymentCard> CreatePaymentCard(
    flatbuffers::FlatBufferBuilder &_fbb,
    libtextclassifier3::EntityData_::PaymentCard_::CardNetwork card_network = libtextclassifier3::EntityData_::PaymentCard_::CardNetwork_UNKNOWN_CARD_NETWORK,
    flatbuffers::Offset<flatbuffers::String> card_number = 0) {
  PaymentCardBuilder builder_(_fbb);
  builder_.add_card_number(card_number);
  builder_.add_card_network(card_network);
  return builder_.Finish();
}

inline flatbuffers::Offset<PaymentCard> CreatePaymentCardDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    libtextclassifier3::EntityData_::PaymentCard_::CardNetwork card_network = libtextclassifier3::EntityData_::PaymentCard_::CardNetwork_UNKNOWN_CARD_NETWORK,
    const char *card_number = nullptr) {
  auto card_number__ = card_number ? _fbb.CreateSharedString(card_number) : 0;
  return libtextclassifier3::EntityData_::CreatePaymentCard(
      _fbb,
      card_network,
      card_number__);
}

flatbuffers::Offset<PaymentCard> CreatePaymentCard(flatbuffers::FlatBufferBuilder &_fbb, const PaymentCardT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlightT : public flatbuffers::NativeTable {
  typedef Flight TableType;
  std::string airline_code;
  std::string flight_number;
  FlightT() {
  }
};

struct Flight FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlightT NativeTableType;
  typedef FlightBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AIRLINE_CODE = 4,
    VT_FLIGHT_NUMBER = 6
  };
  const flatbuffers::String *airline_code() const {
    return GetPointer<const flatbuffers::String *>(VT_AIRLINE_CODE);
  }
  const flatbuffers::String *flight_number() const {
    return GetPointer<const flatbuffers::String *>(VT_FLIGHT_NUMBER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AIRLINE_CODE) &&
           verifier.VerifyString(airline_code()) &&
           VerifyOffset(verifier, VT_FLIGHT_NUMBER) &&
           verifier.VerifyString(flight_number()) &&
           verifier.EndTable();
  }
  FlightT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlightT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Flight> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlightT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlightBuilder {
  typedef Flight Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_airline_code(flatbuffers::Offset<flatbuffers::String> airline_code) {
    fbb_.AddOffset(Flight::VT_AIRLINE_CODE, airline_code);
  }
  void add_flight_number(flatbuffers::Offset<flatbuffers::String> flight_number) {
    fbb_.AddOffset(Flight::VT_FLIGHT_NUMBER, flight_number);
  }
  explicit FlightBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FlightBuilder &operator=(const FlightBuilder &);
  flatbuffers::Offset<Flight> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Flight>(end);
    return o;
  }
};

inline flatbuffers::Offset<Flight> CreateFlight(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> airline_code = 0,
    flatbuffers::Offset<flatbuffers::String> flight_number = 0) {
  FlightBuilder builder_(_fbb);
  builder_.add_flight_number(flight_number);
  builder_.add_airline_code(airline_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<Flight> CreateFlightDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *airline_code = nullptr,
    const char *flight_number = nullptr) {
  auto airline_code__ = airline_code ? _fbb.CreateSharedString(airline_code) : 0;
  auto flight_number__ = flight_number ? _fbb.CreateSharedString(flight_number) : 0;
  return libtextclassifier3::EntityData_::CreateFlight(
      _fbb,
      airline_code__,
      flight_number__);
}

flatbuffers::Offset<Flight> CreateFlight(flatbuffers::FlatBufferBuilder &_fbb, const FlightT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IsbnT : public flatbuffers::NativeTable {
  typedef Isbn TableType;
  std::string number;
  IsbnT() {
  }
};

struct Isbn FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IsbnT NativeTableType;
  typedef IsbnBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMBER = 4
  };
  const flatbuffers::String *number() const {
    return GetPointer<const flatbuffers::String *>(VT_NUMBER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NUMBER) &&
           verifier.VerifyString(number()) &&
           verifier.EndTable();
  }
  IsbnT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IsbnT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Isbn> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IsbnT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IsbnBuilder {
  typedef Isbn Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_number(flatbuffers::Offset<flatbuffers::String> number) {
    fbb_.AddOffset(Isbn::VT_NUMBER, number);
  }
  explicit IsbnBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IsbnBuilder &operator=(const IsbnBuilder &);
  flatbuffers::Offset<Isbn> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Isbn>(end);
    return o;
  }
};

inline flatbuffers::Offset<Isbn> CreateIsbn(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> number = 0) {
  IsbnBuilder builder_(_fbb);
  builder_.add_number(number);
  return builder_.Finish();
}

inline flatbuffers::Offset<Isbn> CreateIsbnDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *number = nullptr) {
  auto number__ = number ? _fbb.CreateSharedString(number) : 0;
  return libtextclassifier3::EntityData_::CreateIsbn(
      _fbb,
      number__);
}

flatbuffers::Offset<Isbn> CreateIsbn(flatbuffers::FlatBufferBuilder &_fbb, const IsbnT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IbanT : public flatbuffers::NativeTable {
  typedef Iban TableType;
  std::string number;
  std::string country_code;
  IbanT() {
  }
};

struct Iban FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IbanT NativeTableType;
  typedef IbanBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMBER = 4,
    VT_COUNTRY_CODE = 6
  };
  const flatbuffers::String *number() const {
    return GetPointer<const flatbuffers::String *>(VT_NUMBER);
  }
  const flatbuffers::String *country_code() const {
    return GetPointer<const flatbuffers::String *>(VT_COUNTRY_CODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NUMBER) &&
           verifier.VerifyString(number()) &&
           VerifyOffset(verifier, VT_COUNTRY_CODE) &&
           verifier.VerifyString(country_code()) &&
           verifier.EndTable();
  }
  IbanT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IbanT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Iban> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IbanT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IbanBuilder {
  typedef Iban Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_number(flatbuffers::Offset<flatbuffers::String> number) {
    fbb_.AddOffset(Iban::VT_NUMBER, number);
  }
  void add_country_code(flatbuffers::Offset<flatbuffers::String> country_code) {
    fbb_.AddOffset(Iban::VT_COUNTRY_CODE, country_code);
  }
  explicit IbanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IbanBuilder &operator=(const IbanBuilder &);
  flatbuffers::Offset<Iban> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Iban>(end);
    return o;
  }
};

inline flatbuffers::Offset<Iban> CreateIban(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> number = 0,
    flatbuffers::Offset<flatbuffers::String> country_code = 0) {
  IbanBuilder builder_(_fbb);
  builder_.add_country_code(country_code);
  builder_.add_number(number);
  return builder_.Finish();
}

inline flatbuffers::Offset<Iban> CreateIbanDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *number = nullptr,
    const char *country_code = nullptr) {
  auto number__ = number ? _fbb.CreateSharedString(number) : 0;
  auto country_code__ = country_code ? _fbb.CreateSharedString(country_code) : 0;
  return libtextclassifier3::EntityData_::CreateIban(
      _fbb,
      number__,
      country_code__);
}

flatbuffers::Offset<Iban> CreateIban(flatbuffers::FlatBufferBuilder &_fbb, const IbanT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ParcelTrackingT : public flatbuffers::NativeTable {
  typedef ParcelTracking TableType;
  libtextclassifier3::EntityData_::ParcelTracking_::Carrier carrier;
  std::string tracking_number;
  ParcelTrackingT()
      : carrier(libtextclassifier3::EntityData_::ParcelTracking_::Carrier_UNKNOWN_CARRIER) {
  }
};

struct ParcelTracking FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ParcelTrackingT NativeTableType;
  typedef ParcelTrackingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CARRIER = 4,
    VT_TRACKING_NUMBER = 6
  };
  libtextclassifier3::EntityData_::ParcelTracking_::Carrier carrier() const {
    return static_cast<libtextclassifier3::EntityData_::ParcelTracking_::Carrier>(GetField<int32_t>(VT_CARRIER, 0));
  }
  const flatbuffers::String *tracking_number() const {
    return GetPointer<const flatbuffers::String *>(VT_TRACKING_NUMBER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CARRIER) &&
           VerifyOffset(verifier, VT_TRACKING_NUMBER) &&
           verifier.VerifyString(tracking_number()) &&
           verifier.EndTable();
  }
  ParcelTrackingT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ParcelTrackingT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ParcelTracking> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ParcelTrackingT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ParcelTrackingBuilder {
  typedef ParcelTracking Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_carrier(libtextclassifier3::EntityData_::ParcelTracking_::Carrier carrier) {
    fbb_.AddElement<int32_t>(ParcelTracking::VT_CARRIER, static_cast<int32_t>(carrier), 0);
  }
  void add_tracking_number(flatbuffers::Offset<flatbuffers::String> tracking_number) {
    fbb_.AddOffset(ParcelTracking::VT_TRACKING_NUMBER, tracking_number);
  }
  explicit ParcelTrackingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ParcelTrackingBuilder &operator=(const ParcelTrackingBuilder &);
  flatbuffers::Offset<ParcelTracking> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ParcelTracking>(end);
    return o;
  }
};

inline flatbuffers::Offset<ParcelTracking> CreateParcelTracking(
    flatbuffers::FlatBufferBuilder &_fbb,
    libtextclassifier3::EntityData_::ParcelTracking_::Carrier carrier = libtextclassifier3::EntityData_::ParcelTracking_::Carrier_UNKNOWN_CARRIER,
    flatbuffers::Offset<flatbuffers::String> tracking_number = 0) {
  ParcelTrackingBuilder builder_(_fbb);
  builder_.add_tracking_number(tracking_number);
  builder_.add_carrier(carrier);
  return builder_.Finish();
}

inline flatbuffers::Offset<ParcelTracking> CreateParcelTrackingDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    libtextclassifier3::EntityData_::ParcelTracking_::Carrier carrier = libtextclassifier3::EntityData_::ParcelTracking_::Carrier_UNKNOWN_CARRIER,
    const char *tracking_number = nullptr) {
  auto tracking_number__ = tracking_number ? _fbb.CreateSharedString(tracking_number) : 0;
  return libtextclassifier3::EntityData_::CreateParcelTracking(
      _fbb,
      carrier,
      tracking_number__);
}

flatbuffers::Offset<ParcelTracking> CreateParcelTracking(flatbuffers::FlatBufferBuilder &_fbb, const ParcelTrackingT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MoneyT : public flatbuffers::NativeTable {
  typedef Money TableType;
  std::string unnormalized_currency;
  int32_t amount_whole_part;
  int32_t amount_decimal_part;
  std::string unnormalized_amount;
  int32_t nanos;
  std::string quantity;
  MoneyT()
      : amount_whole_part(0),
        amount_decimal_part(0),
        nanos(0) {
  }
};

struct Money FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MoneyT NativeTableType;
  typedef MoneyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNNORMALIZED_CURRENCY = 4,
    VT_AMOUNT_WHOLE_PART = 6,
    VT_AMOUNT_DECIMAL_PART = 8,
    VT_UNNORMALIZED_AMOUNT = 10,
    VT_NANOS = 12,
    VT_QUANTITY = 14
  };
  const flatbuffers::String *unnormalized_currency() const {
    return GetPointer<const flatbuffers::String *>(VT_UNNORMALIZED_CURRENCY);
  }
  int32_t amount_whole_part() const {
    return GetField<int32_t>(VT_AMOUNT_WHOLE_PART, 0);
  }
  int32_t amount_decimal_part() const {
    return GetField<int32_t>(VT_AMOUNT_DECIMAL_PART, 0);
  }
  const flatbuffers::String *unnormalized_amount() const {
    return GetPointer<const flatbuffers::String *>(VT_UNNORMALIZED_AMOUNT);
  }
  int32_t nanos() const {
    return GetField<int32_t>(VT_NANOS, 0);
  }
  const flatbuffers::String *quantity() const {
    return GetPointer<const flatbuffers::String *>(VT_QUANTITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UNNORMALIZED_CURRENCY) &&
           verifier.VerifyString(unnormalized_currency()) &&
           VerifyField<int32_t>(verifier, VT_AMOUNT_WHOLE_PART) &&
           VerifyField<int32_t>(verifier, VT_AMOUNT_DECIMAL_PART) &&
           VerifyOffset(verifier, VT_UNNORMALIZED_AMOUNT) &&
           verifier.VerifyString(unnormalized_amount()) &&
           VerifyField<int32_t>(verifier, VT_NANOS) &&
           VerifyOffset(verifier, VT_QUANTITY) &&
           verifier.VerifyString(quantity()) &&
           verifier.EndTable();
  }
  MoneyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MoneyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Money> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoneyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MoneyBuilder {
  typedef Money Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_unnormalized_currency(flatbuffers::Offset<flatbuffers::String> unnormalized_currency) {
    fbb_.AddOffset(Money::VT_UNNORMALIZED_CURRENCY, unnormalized_currency);
  }
  void add_amount_whole_part(int32_t amount_whole_part) {
    fbb_.AddElement<int32_t>(Money::VT_AMOUNT_WHOLE_PART, amount_whole_part, 0);
  }
  void add_amount_decimal_part(int32_t amount_decimal_part) {
    fbb_.AddElement<int32_t>(Money::VT_AMOUNT_DECIMAL_PART, amount_decimal_part, 0);
  }
  void add_unnormalized_amount(flatbuffers::Offset<flatbuffers::String> unnormalized_amount) {
    fbb_.AddOffset(Money::VT_UNNORMALIZED_AMOUNT, unnormalized_amount);
  }
  void add_nanos(int32_t nanos) {
    fbb_.AddElement<int32_t>(Money::VT_NANOS, nanos, 0);
  }
  void add_quantity(flatbuffers::Offset<flatbuffers::String> quantity) {
    fbb_.AddOffset(Money::VT_QUANTITY, quantity);
  }
  explicit MoneyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MoneyBuilder &operator=(const MoneyBuilder &);
  flatbuffers::Offset<Money> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Money>(end);
    return o;
  }
};

inline flatbuffers::Offset<Money> CreateMoney(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> unnormalized_currency = 0,
    int32_t amount_whole_part = 0,
    int32_t amount_decimal_part = 0,
    flatbuffers::Offset<flatbuffers::String> unnormalized_amount = 0,
    int32_t nanos = 0,
    flatbuffers::Offset<flatbuffers::String> quantity = 0) {
  MoneyBuilder builder_(_fbb);
  builder_.add_quantity(quantity);
  builder_.add_nanos(nanos);
  builder_.add_unnormalized_amount(unnormalized_amount);
  builder_.add_amount_decimal_part(amount_decimal_part);
  builder_.add_amount_whole_part(amount_whole_part);
  builder_.add_unnormalized_currency(unnormalized_currency);
  return builder_.Finish();
}

inline flatbuffers::Offset<Money> CreateMoneyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *unnormalized_currency = nullptr,
    int32_t amount_whole_part = 0,
    int32_t amount_decimal_part = 0,
    const char *unnormalized_amount = nullptr,
    int32_t nanos = 0,
    const char *quantity = nullptr) {
  auto unnormalized_currency__ = unnormalized_currency ? _fbb.CreateSharedString(unnormalized_currency) : 0;
  auto unnormalized_amount__ = unnormalized_amount ? _fbb.CreateSharedString(unnormalized_amount) : 0;
  auto quantity__ = quantity ? _fbb.CreateSharedString(quantity) : 0;
  return libtextclassifier3::EntityData_::CreateMoney(
      _fbb,
      unnormalized_currency__,
      amount_whole_part,
      amount_decimal_part,
      unnormalized_amount__,
      nanos,
      quantity__);
}

flatbuffers::Offset<Money> CreateMoney(flatbuffers::FlatBufferBuilder &_fbb, const MoneyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace Translate_ {

struct LanguagePredictionResultT : public flatbuffers::NativeTable {
  typedef LanguagePredictionResult TableType;
  std::string language_tag;
  float confidence_score;
  LanguagePredictionResultT()
      : confidence_score(0.0f) {
  }
};

struct LanguagePredictionResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LanguagePredictionResultT NativeTableType;
  typedef LanguagePredictionResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LANGUAGE_TAG = 4,
    VT_CONFIDENCE_SCORE = 6
  };
  const flatbuffers::String *language_tag() const {
    return GetPointer<const flatbuffers::String *>(VT_LANGUAGE_TAG);
  }
  float confidence_score() const {
    return GetField<float>(VT_CONFIDENCE_SCORE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LANGUAGE_TAG) &&
           verifier.VerifyString(language_tag()) &&
           VerifyField<float>(verifier, VT_CONFIDENCE_SCORE) &&
           verifier.EndTable();
  }
  LanguagePredictionResultT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LanguagePredictionResultT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LanguagePredictionResult> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LanguagePredictionResultT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LanguagePredictionResultBuilder {
  typedef LanguagePredictionResult Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_language_tag(flatbuffers::Offset<flatbuffers::String> language_tag) {
    fbb_.AddOffset(LanguagePredictionResult::VT_LANGUAGE_TAG, language_tag);
  }
  void add_confidence_score(float confidence_score) {
    fbb_.AddElement<float>(LanguagePredictionResult::VT_CONFIDENCE_SCORE, confidence_score, 0.0f);
  }
  explicit LanguagePredictionResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LanguagePredictionResultBuilder &operator=(const LanguagePredictionResultBuilder &);
  flatbuffers::Offset<LanguagePredictionResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LanguagePredictionResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<LanguagePredictionResult> CreateLanguagePredictionResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> language_tag = 0,
    float confidence_score = 0.0f) {
  LanguagePredictionResultBuilder builder_(_fbb);
  builder_.add_confidence_score(confidence_score);
  builder_.add_language_tag(language_tag);
  return builder_.Finish();
}

inline flatbuffers::Offset<LanguagePredictionResult> CreateLanguagePredictionResultDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *language_tag = nullptr,
    float confidence_score = 0.0f) {
  auto language_tag__ = language_tag ? _fbb.CreateSharedString(language_tag) : 0;
  return libtextclassifier3::EntityData_::Translate_::CreateLanguagePredictionResult(
      _fbb,
      language_tag__,
      confidence_score);
}

flatbuffers::Offset<LanguagePredictionResult> CreateLanguagePredictionResult(flatbuffers::FlatBufferBuilder &_fbb, const LanguagePredictionResultT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace Translate_

struct TranslateT : public flatbuffers::NativeTable {
  typedef Translate TableType;
  std::vector<std::unique_ptr<libtextclassifier3::EntityData_::Translate_::LanguagePredictionResultT>> language_prediction_results;
  TranslateT() {
  }
};

struct Translate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TranslateT NativeTableType;
  typedef TranslateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LANGUAGE_PREDICTION_RESULTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::EntityData_::Translate_::LanguagePredictionResult>> *language_prediction_results() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::EntityData_::Translate_::LanguagePredictionResult>> *>(VT_LANGUAGE_PREDICTION_RESULTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LANGUAGE_PREDICTION_RESULTS) &&
           verifier.VerifyVector(language_prediction_results()) &&
           verifier.VerifyVectorOfTables(language_prediction_results()) &&
           verifier.EndTable();
  }
  TranslateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TranslateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Translate> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TranslateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TranslateBuilder {
  typedef Translate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_language_prediction_results(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::EntityData_::Translate_::LanguagePredictionResult>>> language_prediction_results) {
    fbb_.AddOffset(Translate::VT_LANGUAGE_PREDICTION_RESULTS, language_prediction_results);
  }
  explicit TranslateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TranslateBuilder &operator=(const TranslateBuilder &);
  flatbuffers::Offset<Translate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Translate>(end);
    return o;
  }
};

inline flatbuffers::Offset<Translate> CreateTranslate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::EntityData_::Translate_::LanguagePredictionResult>>> language_prediction_results = 0) {
  TranslateBuilder builder_(_fbb);
  builder_.add_language_prediction_results(language_prediction_results);
  return builder_.Finish();
}

inline flatbuffers::Offset<Translate> CreateTranslateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<libtextclassifier3::EntityData_::Translate_::LanguagePredictionResult>> *language_prediction_results = nullptr) {
  auto language_prediction_results__ = language_prediction_results ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::EntityData_::Translate_::LanguagePredictionResult>>(*language_prediction_results) : 0;
  return libtextclassifier3::EntityData_::CreateTranslate(
      _fbb,
      language_prediction_results__);
}

flatbuffers::Offset<Translate> CreateTranslate(flatbuffers::FlatBufferBuilder &_fbb, const TranslateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace EntityData_

struct EntityDataT : public flatbuffers::NativeTable {
  typedef EntityData TableType;
  int32_t start;
  int32_t end;
  std::string type;
  std::unique_ptr<libtextclassifier3::EntityData_::DatetimeT> datetime;
  std::unique_ptr<libtextclassifier3::EntityData_::ContactT> contact;
  std::unique_ptr<libtextclassifier3::EntityData_::AppT> app;
  std::unique_ptr<libtextclassifier3::EntityData_::PaymentCardT> payment_card;
  std::unique_ptr<libtextclassifier3::EntityData_::FlightT> flight;
  std::unique_ptr<libtextclassifier3::EntityData_::IsbnT> isbn;
  std::unique_ptr<libtextclassifier3::EntityData_::IbanT> iban;
  std::unique_ptr<libtextclassifier3::EntityData_::ParcelTrackingT> parcel;
  std::unique_ptr<libtextclassifier3::EntityData_::MoneyT> money;
  std::unique_ptr<libtextclassifier3::EntityData_::TranslateT> translate;
  EntityDataT()
      : start(0),
        end(0) {
  }
};

struct EntityData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EntityDataT NativeTableType;
  typedef EntityDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START = 4,
    VT_END = 6,
    VT_TYPE = 8,
    VT_DATETIME = 10,
    VT_CONTACT = 14,
    VT_APP = 16,
    VT_PAYMENT_CARD = 18,
    VT_FLIGHT = 20,
    VT_ISBN = 22,
    VT_IBAN = 24,
    VT_PARCEL = 26,
    VT_MONEY = 28,
    VT_TRANSLATE = 30
  };
  int32_t start() const {
    return GetField<int32_t>(VT_START, 0);
  }
  int32_t end() const {
    return GetField<int32_t>(VT_END, 0);
  }
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const libtextclassifier3::EntityData_::Datetime *datetime() const {
    return GetPointer<const libtextclassifier3::EntityData_::Datetime *>(VT_DATETIME);
  }
  const libtextclassifier3::EntityData_::Contact *contact() const {
    return GetPointer<const libtextclassifier3::EntityData_::Contact *>(VT_CONTACT);
  }
  const libtextclassifier3::EntityData_::App *app() const {
    return GetPointer<const libtextclassifier3::EntityData_::App *>(VT_APP);
  }
  const libtextclassifier3::EntityData_::PaymentCard *payment_card() const {
    return GetPointer<const libtextclassifier3::EntityData_::PaymentCard *>(VT_PAYMENT_CARD);
  }
  const libtextclassifier3::EntityData_::Flight *flight() const {
    return GetPointer<const libtextclassifier3::EntityData_::Flight *>(VT_FLIGHT);
  }
  const libtextclassifier3::EntityData_::Isbn *isbn() const {
    return GetPointer<const libtextclassifier3::EntityData_::Isbn *>(VT_ISBN);
  }
  const libtextclassifier3::EntityData_::Iban *iban() const {
    return GetPointer<const libtextclassifier3::EntityData_::Iban *>(VT_IBAN);
  }
  const libtextclassifier3::EntityData_::ParcelTracking *parcel() const {
    return GetPointer<const libtextclassifier3::EntityData_::ParcelTracking *>(VT_PARCEL);
  }
  const libtextclassifier3::EntityData_::Money *money() const {
    return GetPointer<const libtextclassifier3::EntityData_::Money *>(VT_MONEY);
  }
  const libtextclassifier3::EntityData_::Translate *translate() const {
    return GetPointer<const libtextclassifier3::EntityData_::Translate *>(VT_TRANSLATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_START) &&
           VerifyField<int32_t>(verifier, VT_END) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_DATETIME) &&
           verifier.VerifyTable(datetime()) &&
           VerifyOffset(verifier, VT_CONTACT) &&
           verifier.VerifyTable(contact()) &&
           VerifyOffset(verifier, VT_APP) &&
           verifier.VerifyTable(app()) &&
           VerifyOffset(verifier, VT_PAYMENT_CARD) &&
           verifier.VerifyTable(payment_card()) &&
           VerifyOffset(verifier, VT_FLIGHT) &&
           verifier.VerifyTable(flight()) &&
           VerifyOffset(verifier, VT_ISBN) &&
           verifier.VerifyTable(isbn()) &&
           VerifyOffset(verifier, VT_IBAN) &&
           verifier.VerifyTable(iban()) &&
           VerifyOffset(verifier, VT_PARCEL) &&
           verifier.VerifyTable(parcel()) &&
           VerifyOffset(verifier, VT_MONEY) &&
           verifier.VerifyTable(money()) &&
           VerifyOffset(verifier, VT_TRANSLATE) &&
           verifier.VerifyTable(translate()) &&
           verifier.EndTable();
  }
  EntityDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EntityDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EntityData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EntityDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EntityDataBuilder {
  typedef EntityData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_start(int32_t start) {
    fbb_.AddElement<int32_t>(EntityData::VT_START, start, 0);
  }
  void add_end(int32_t end) {
    fbb_.AddElement<int32_t>(EntityData::VT_END, end, 0);
  }
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(EntityData::VT_TYPE, type);
  }
  void add_datetime(flatbuffers::Offset<libtextclassifier3::EntityData_::Datetime> datetime) {
    fbb_.AddOffset(EntityData::VT_DATETIME, datetime);
  }
  void add_contact(flatbuffers::Offset<libtextclassifier3::EntityData_::Contact> contact) {
    fbb_.AddOffset(EntityData::VT_CONTACT, contact);
  }
  void add_app(flatbuffers::Offset<libtextclassifier3::EntityData_::App> app) {
    fbb_.AddOffset(EntityData::VT_APP, app);
  }
  void add_payment_card(flatbuffers::Offset<libtextclassifier3::EntityData_::PaymentCard> payment_card) {
    fbb_.AddOffset(EntityData::VT_PAYMENT_CARD, payment_card);
  }
  void add_flight(flatbuffers::Offset<libtextclassifier3::EntityData_::Flight> flight) {
    fbb_.AddOffset(EntityData::VT_FLIGHT, flight);
  }
  void add_isbn(flatbuffers::Offset<libtextclassifier3::EntityData_::Isbn> isbn) {
    fbb_.AddOffset(EntityData::VT_ISBN, isbn);
  }
  void add_iban(flatbuffers::Offset<libtextclassifier3::EntityData_::Iban> iban) {
    fbb_.AddOffset(EntityData::VT_IBAN, iban);
  }
  void add_parcel(flatbuffers::Offset<libtextclassifier3::EntityData_::ParcelTracking> parcel) {
    fbb_.AddOffset(EntityData::VT_PARCEL, parcel);
  }
  void add_money(flatbuffers::Offset<libtextclassifier3::EntityData_::Money> money) {
    fbb_.AddOffset(EntityData::VT_MONEY, money);
  }
  void add_translate(flatbuffers::Offset<libtextclassifier3::EntityData_::Translate> translate) {
    fbb_.AddOffset(EntityData::VT_TRANSLATE, translate);
  }
  explicit EntityDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EntityDataBuilder &operator=(const EntityDataBuilder &);
  flatbuffers::Offset<EntityData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EntityData>(end);
    return o;
  }
};

inline flatbuffers::Offset<EntityData> CreateEntityData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t start = 0,
    int32_t end = 0,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<libtextclassifier3::EntityData_::Datetime> datetime = 0,
    flatbuffers::Offset<libtextclassifier3::EntityData_::Contact> contact = 0,
    flatbuffers::Offset<libtextclassifier3::EntityData_::App> app = 0,
    flatbuffers::Offset<libtextclassifier3::EntityData_::PaymentCard> payment_card = 0,
    flatbuffers::Offset<libtextclassifier3::EntityData_::Flight> flight = 0,
    flatbuffers::Offset<libtextclassifier3::EntityData_::Isbn> isbn = 0,
    flatbuffers::Offset<libtextclassifier3::EntityData_::Iban> iban = 0,
    flatbuffers::Offset<libtextclassifier3::EntityData_::ParcelTracking> parcel = 0,
    flatbuffers::Offset<libtextclassifier3::EntityData_::Money> money = 0,
    flatbuffers::Offset<libtextclassifier3::EntityData_::Translate> translate = 0) {
  EntityDataBuilder builder_(_fbb);
  builder_.add_translate(translate);
  builder_.add_money(money);
  builder_.add_parcel(parcel);
  builder_.add_iban(iban);
  builder_.add_isbn(isbn);
  builder_.add_flight(flight);
  builder_.add_payment_card(payment_card);
  builder_.add_app(app);
  builder_.add_contact(contact);
  builder_.add_datetime(datetime);
  builder_.add_type(type);
  builder_.add_end(end);
  builder_.add_start(start);
  return builder_.Finish();
}

inline flatbuffers::Offset<EntityData> CreateEntityDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t start = 0,
    int32_t end = 0,
    const char *type = nullptr,
    flatbuffers::Offset<libtextclassifier3::EntityData_::Datetime> datetime = 0,
    flatbuffers::Offset<libtextclassifier3::EntityData_::Contact> contact = 0,
    flatbuffers::Offset<libtextclassifier3::EntityData_::App> app = 0,
    flatbuffers::Offset<libtextclassifier3::EntityData_::PaymentCard> payment_card = 0,
    flatbuffers::Offset<libtextclassifier3::EntityData_::Flight> flight = 0,
    flatbuffers::Offset<libtextclassifier3::EntityData_::Isbn> isbn = 0,
    flatbuffers::Offset<libtextclassifier3::EntityData_::Iban> iban = 0,
    flatbuffers::Offset<libtextclassifier3::EntityData_::ParcelTracking> parcel = 0,
    flatbuffers::Offset<libtextclassifier3::EntityData_::Money> money = 0,
    flatbuffers::Offset<libtextclassifier3::EntityData_::Translate> translate = 0) {
  auto type__ = type ? _fbb.CreateSharedString(type) : 0;
  return libtextclassifier3::CreateEntityData(
      _fbb,
      start,
      end,
      type__,
      datetime,
      contact,
      app,
      payment_card,
      flight,
      isbn,
      iban,
      parcel,
      money,
      translate);
}

flatbuffers::Offset<EntityData> CreateEntityData(flatbuffers::FlatBufferBuilder &_fbb, const EntityDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace EntityData_ {
namespace Datetime_ {

inline DatetimeComponentT *DatetimeComponent::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::EntityData_::Datetime_::DatetimeComponentT> _o = std::unique_ptr<libtextclassifier3::EntityData_::Datetime_::DatetimeComponentT>(new DatetimeComponentT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DatetimeComponent::UnPackTo(DatetimeComponentT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = component_type(); _o->component_type = _e; }
  { auto _e = absolute_value(); _o->absolute_value = _e; }
  { auto _e = relative_count(); _o->relative_count = _e; }
  { auto _e = relation_type(); _o->relation_type = _e; }
}

inline flatbuffers::Offset<DatetimeComponent> DatetimeComponent::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DatetimeComponentT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDatetimeComponent(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DatetimeComponent> CreateDatetimeComponent(flatbuffers::FlatBufferBuilder &_fbb, const DatetimeComponentT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DatetimeComponentT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _component_type = _o->component_type;
  auto _absolute_value = _o->absolute_value;
  auto _relative_count = _o->relative_count;
  auto _relation_type = _o->relation_type;
  return libtextclassifier3::EntityData_::Datetime_::CreateDatetimeComponent(
      _fbb,
      _component_type,
      _absolute_value,
      _relative_count,
      _relation_type);
}

}  // namespace Datetime_

inline DatetimeT *Datetime::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::EntityData_::DatetimeT> _o = std::unique_ptr<libtextclassifier3::EntityData_::DatetimeT>(new DatetimeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Datetime::UnPackTo(DatetimeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = time_ms_utc(); _o->time_ms_utc = _e; }
  { auto _e = granularity(); _o->granularity = _e; }
  { auto _e = datetime_component(); if (_e) { _o->datetime_component.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->datetime_component[_i] = std::unique_ptr<libtextclassifier3::EntityData_::Datetime_::DatetimeComponentT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<Datetime> Datetime::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DatetimeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDatetime(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Datetime> CreateDatetime(flatbuffers::FlatBufferBuilder &_fbb, const DatetimeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DatetimeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _time_ms_utc = _o->time_ms_utc;
  auto _granularity = _o->granularity;
  auto _datetime_component = _o->datetime_component.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::EntityData_::Datetime_::DatetimeComponent>> (_o->datetime_component.size(), [](size_t i, _VectorArgs *__va) { return CreateDatetimeComponent(*__va->__fbb, __va->__o->datetime_component[i].get(), __va->__rehasher); }, &_va ) : 0;
  return libtextclassifier3::EntityData_::CreateDatetime(
      _fbb,
      _time_ms_utc,
      _granularity,
      _datetime_component);
}

inline ContactT *Contact::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::EntityData_::ContactT> _o = std::unique_ptr<libtextclassifier3::EntityData_::ContactT>(new ContactT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Contact::UnPackTo(ContactT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = given_name(); if (_e) _o->given_name = _e->str(); }
  { auto _e = nickname(); if (_e) _o->nickname = _e->str(); }
  { auto _e = email_address(); if (_e) _o->email_address = _e->str(); }
  { auto _e = phone_number(); if (_e) _o->phone_number = _e->str(); }
  { auto _e = contact_id(); if (_e) _o->contact_id = _e->str(); }
}

inline flatbuffers::Offset<Contact> Contact::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ContactT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateContact(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Contact> CreateContact(flatbuffers::FlatBufferBuilder &_fbb, const ContactT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ContactT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateSharedString(_o->name);
  auto _given_name = _o->given_name.empty() ? 0 : _fbb.CreateSharedString(_o->given_name);
  auto _nickname = _o->nickname.empty() ? 0 : _fbb.CreateSharedString(_o->nickname);
  auto _email_address = _o->email_address.empty() ? 0 : _fbb.CreateSharedString(_o->email_address);
  auto _phone_number = _o->phone_number.empty() ? 0 : _fbb.CreateSharedString(_o->phone_number);
  auto _contact_id = _o->contact_id.empty() ? 0 : _fbb.CreateSharedString(_o->contact_id);
  return libtextclassifier3::EntityData_::CreateContact(
      _fbb,
      _name,
      _given_name,
      _nickname,
      _email_address,
      _phone_number,
      _contact_id);
}

inline AppT *App::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::EntityData_::AppT> _o = std::unique_ptr<libtextclassifier3::EntityData_::AppT>(new AppT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void App::UnPackTo(AppT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = package_name(); if (_e) _o->package_name = _e->str(); }
}

inline flatbuffers::Offset<App> App::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AppT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateApp(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<App> CreateApp(flatbuffers::FlatBufferBuilder &_fbb, const AppT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AppT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateSharedString(_o->name);
  auto _package_name = _o->package_name.empty() ? 0 : _fbb.CreateSharedString(_o->package_name);
  return libtextclassifier3::EntityData_::CreateApp(
      _fbb,
      _name,
      _package_name);
}

inline PaymentCardT *PaymentCard::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::EntityData_::PaymentCardT> _o = std::unique_ptr<libtextclassifier3::EntityData_::PaymentCardT>(new PaymentCardT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PaymentCard::UnPackTo(PaymentCardT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = card_network(); _o->card_network = _e; }
  { auto _e = card_number(); if (_e) _o->card_number = _e->str(); }
}

inline flatbuffers::Offset<PaymentCard> PaymentCard::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PaymentCardT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePaymentCard(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PaymentCard> CreatePaymentCard(flatbuffers::FlatBufferBuilder &_fbb, const PaymentCardT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PaymentCardT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _card_network = _o->card_network;
  auto _card_number = _o->card_number.empty() ? 0 : _fbb.CreateSharedString(_o->card_number);
  return libtextclassifier3::EntityData_::CreatePaymentCard(
      _fbb,
      _card_network,
      _card_number);
}

inline FlightT *Flight::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::EntityData_::FlightT> _o = std::unique_ptr<libtextclassifier3::EntityData_::FlightT>(new FlightT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Flight::UnPackTo(FlightT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = airline_code(); if (_e) _o->airline_code = _e->str(); }
  { auto _e = flight_number(); if (_e) _o->flight_number = _e->str(); }
}

inline flatbuffers::Offset<Flight> Flight::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlightT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlight(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Flight> CreateFlight(flatbuffers::FlatBufferBuilder &_fbb, const FlightT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FlightT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _airline_code = _o->airline_code.empty() ? 0 : _fbb.CreateSharedString(_o->airline_code);
  auto _flight_number = _o->flight_number.empty() ? 0 : _fbb.CreateSharedString(_o->flight_number);
  return libtextclassifier3::EntityData_::CreateFlight(
      _fbb,
      _airline_code,
      _flight_number);
}

inline IsbnT *Isbn::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::EntityData_::IsbnT> _o = std::unique_ptr<libtextclassifier3::EntityData_::IsbnT>(new IsbnT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Isbn::UnPackTo(IsbnT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = number(); if (_e) _o->number = _e->str(); }
}

inline flatbuffers::Offset<Isbn> Isbn::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IsbnT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIsbn(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Isbn> CreateIsbn(flatbuffers::FlatBufferBuilder &_fbb, const IsbnT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IsbnT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _number = _o->number.empty() ? 0 : _fbb.CreateSharedString(_o->number);
  return libtextclassifier3::EntityData_::CreateIsbn(
      _fbb,
      _number);
}

inline IbanT *Iban::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::EntityData_::IbanT> _o = std::unique_ptr<libtextclassifier3::EntityData_::IbanT>(new IbanT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Iban::UnPackTo(IbanT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = number(); if (_e) _o->number = _e->str(); }
  { auto _e = country_code(); if (_e) _o->country_code = _e->str(); }
}

inline flatbuffers::Offset<Iban> Iban::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IbanT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIban(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Iban> CreateIban(flatbuffers::FlatBufferBuilder &_fbb, const IbanT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IbanT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _number = _o->number.empty() ? 0 : _fbb.CreateSharedString(_o->number);
  auto _country_code = _o->country_code.empty() ? 0 : _fbb.CreateSharedString(_o->country_code);
  return libtextclassifier3::EntityData_::CreateIban(
      _fbb,
      _number,
      _country_code);
}

inline ParcelTrackingT *ParcelTracking::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::EntityData_::ParcelTrackingT> _o = std::unique_ptr<libtextclassifier3::EntityData_::ParcelTrackingT>(new ParcelTrackingT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ParcelTracking::UnPackTo(ParcelTrackingT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = carrier(); _o->carrier = _e; }
  { auto _e = tracking_number(); if (_e) _o->tracking_number = _e->str(); }
}

inline flatbuffers::Offset<ParcelTracking> ParcelTracking::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ParcelTrackingT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateParcelTracking(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ParcelTracking> CreateParcelTracking(flatbuffers::FlatBufferBuilder &_fbb, const ParcelTrackingT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ParcelTrackingT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _carrier = _o->carrier;
  auto _tracking_number = _o->tracking_number.empty() ? 0 : _fbb.CreateSharedString(_o->tracking_number);
  return libtextclassifier3::EntityData_::CreateParcelTracking(
      _fbb,
      _carrier,
      _tracking_number);
}

inline MoneyT *Money::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::EntityData_::MoneyT> _o = std::unique_ptr<libtextclassifier3::EntityData_::MoneyT>(new MoneyT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Money::UnPackTo(MoneyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = unnormalized_currency(); if (_e) _o->unnormalized_currency = _e->str(); }
  { auto _e = amount_whole_part(); _o->amount_whole_part = _e; }
  { auto _e = amount_decimal_part(); _o->amount_decimal_part = _e; }
  { auto _e = unnormalized_amount(); if (_e) _o->unnormalized_amount = _e->str(); }
  { auto _e = nanos(); _o->nanos = _e; }
  { auto _e = quantity(); if (_e) _o->quantity = _e->str(); }
}

inline flatbuffers::Offset<Money> Money::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoneyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMoney(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Money> CreateMoney(flatbuffers::FlatBufferBuilder &_fbb, const MoneyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MoneyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _unnormalized_currency = _o->unnormalized_currency.empty() ? 0 : _fbb.CreateSharedString(_o->unnormalized_currency);
  auto _amount_whole_part = _o->amount_whole_part;
  auto _amount_decimal_part = _o->amount_decimal_part;
  auto _unnormalized_amount = _o->unnormalized_amount.empty() ? 0 : _fbb.CreateSharedString(_o->unnormalized_amount);
  auto _nanos = _o->nanos;
  auto _quantity = _o->quantity.empty() ? 0 : _fbb.CreateSharedString(_o->quantity);
  return libtextclassifier3::EntityData_::CreateMoney(
      _fbb,
      _unnormalized_currency,
      _amount_whole_part,
      _amount_decimal_part,
      _unnormalized_amount,
      _nanos,
      _quantity);
}

namespace Translate_ {

inline LanguagePredictionResultT *LanguagePredictionResult::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::EntityData_::Translate_::LanguagePredictionResultT> _o = std::unique_ptr<libtextclassifier3::EntityData_::Translate_::LanguagePredictionResultT>(new LanguagePredictionResultT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LanguagePredictionResult::UnPackTo(LanguagePredictionResultT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = language_tag(); if (_e) _o->language_tag = _e->str(); }
  { auto _e = confidence_score(); _o->confidence_score = _e; }
}

inline flatbuffers::Offset<LanguagePredictionResult> LanguagePredictionResult::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LanguagePredictionResultT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLanguagePredictionResult(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LanguagePredictionResult> CreateLanguagePredictionResult(flatbuffers::FlatBufferBuilder &_fbb, const LanguagePredictionResultT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LanguagePredictionResultT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _language_tag = _o->language_tag.empty() ? 0 : _fbb.CreateSharedString(_o->language_tag);
  auto _confidence_score = _o->confidence_score;
  return libtextclassifier3::EntityData_::Translate_::CreateLanguagePredictionResult(
      _fbb,
      _language_tag,
      _confidence_score);
}

}  // namespace Translate_

inline TranslateT *Translate::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::EntityData_::TranslateT> _o = std::unique_ptr<libtextclassifier3::EntityData_::TranslateT>(new TranslateT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Translate::UnPackTo(TranslateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = language_prediction_results(); if (_e) { _o->language_prediction_results.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->language_prediction_results[_i] = std::unique_ptr<libtextclassifier3::EntityData_::Translate_::LanguagePredictionResultT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<Translate> Translate::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TranslateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTranslate(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Translate> CreateTranslate(flatbuffers::FlatBufferBuilder &_fbb, const TranslateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TranslateT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _language_prediction_results = _o->language_prediction_results.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::EntityData_::Translate_::LanguagePredictionResult>> (_o->language_prediction_results.size(), [](size_t i, _VectorArgs *__va) { return CreateLanguagePredictionResult(*__va->__fbb, __va->__o->language_prediction_results[i].get(), __va->__rehasher); }, &_va ) : 0;
  return libtextclassifier3::EntityData_::CreateTranslate(
      _fbb,
      _language_prediction_results);
}

}  // namespace EntityData_

inline EntityDataT *EntityData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::EntityDataT> _o = std::unique_ptr<libtextclassifier3::EntityDataT>(new EntityDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EntityData::UnPackTo(EntityDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = start(); _o->start = _e; }
  { auto _e = end(); _o->end = _e; }
  { auto _e = type(); if (_e) _o->type = _e->str(); }
  { auto _e = datetime(); if (_e) _o->datetime = std::unique_ptr<libtextclassifier3::EntityData_::DatetimeT>(_e->UnPack(_resolver)); }
  { auto _e = contact(); if (_e) _o->contact = std::unique_ptr<libtextclassifier3::EntityData_::ContactT>(_e->UnPack(_resolver)); }
  { auto _e = app(); if (_e) _o->app = std::unique_ptr<libtextclassifier3::EntityData_::AppT>(_e->UnPack(_resolver)); }
  { auto _e = payment_card(); if (_e) _o->payment_card = std::unique_ptr<libtextclassifier3::EntityData_::PaymentCardT>(_e->UnPack(_resolver)); }
  { auto _e = flight(); if (_e) _o->flight = std::unique_ptr<libtextclassifier3::EntityData_::FlightT>(_e->UnPack(_resolver)); }
  { auto _e = isbn(); if (_e) _o->isbn = std::unique_ptr<libtextclassifier3::EntityData_::IsbnT>(_e->UnPack(_resolver)); }
  { auto _e = iban(); if (_e) _o->iban = std::unique_ptr<libtextclassifier3::EntityData_::IbanT>(_e->UnPack(_resolver)); }
  { auto _e = parcel(); if (_e) _o->parcel = std::unique_ptr<libtextclassifier3::EntityData_::ParcelTrackingT>(_e->UnPack(_resolver)); }
  { auto _e = money(); if (_e) _o->money = std::unique_ptr<libtextclassifier3::EntityData_::MoneyT>(_e->UnPack(_resolver)); }
  { auto _e = translate(); if (_e) _o->translate = std::unique_ptr<libtextclassifier3::EntityData_::TranslateT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<EntityData> EntityData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EntityDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEntityData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EntityData> CreateEntityData(flatbuffers::FlatBufferBuilder &_fbb, const EntityDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EntityDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _start = _o->start;
  auto _end = _o->end;
  auto _type = _o->type.empty() ? 0 : _fbb.CreateSharedString(_o->type);
  auto _datetime = _o->datetime ? CreateDatetime(_fbb, _o->datetime.get(), _rehasher) : 0;
  auto _contact = _o->contact ? CreateContact(_fbb, _o->contact.get(), _rehasher) : 0;
  auto _app = _o->app ? CreateApp(_fbb, _o->app.get(), _rehasher) : 0;
  auto _payment_card = _o->payment_card ? CreatePaymentCard(_fbb, _o->payment_card.get(), _rehasher) : 0;
  auto _flight = _o->flight ? CreateFlight(_fbb, _o->flight.get(), _rehasher) : 0;
  auto _isbn = _o->isbn ? CreateIsbn(_fbb, _o->isbn.get(), _rehasher) : 0;
  auto _iban = _o->iban ? CreateIban(_fbb, _o->iban.get(), _rehasher) : 0;
  auto _parcel = _o->parcel ? CreateParcelTracking(_fbb, _o->parcel.get(), _rehasher) : 0;
  auto _money = _o->money ? CreateMoney(_fbb, _o->money.get(), _rehasher) : 0;
  auto _translate = _o->translate ? CreateTranslate(_fbb, _o->translate.get(), _rehasher) : 0;
  return libtextclassifier3::CreateEntityData(
      _fbb,
      _start,
      _end,
      _type,
      _datetime,
      _contact,
      _app,
      _payment_card,
      _flight,
      _isbn,
      _iban,
      _parcel,
      _money,
      _translate);
}

inline const libtextclassifier3::EntityData *GetEntityData(const void *buf) {
  return flatbuffers::GetRoot<libtextclassifier3::EntityData>(buf);
}

inline const libtextclassifier3::EntityData *GetSizePrefixedEntityData(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<libtextclassifier3::EntityData>(buf);
}

inline bool VerifyEntityDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<libtextclassifier3::EntityData>(nullptr);
}

inline bool VerifySizePrefixedEntityDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<libtextclassifier3::EntityData>(nullptr);
}

inline void FinishEntityDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<libtextclassifier3::EntityData> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedEntityDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<libtextclassifier3::EntityData> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<libtextclassifier3::EntityDataT> UnPackEntityData(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<libtextclassifier3::EntityDataT>(GetEntityData(buf)->UnPack(res));
}

inline std::unique_ptr<libtextclassifier3::EntityDataT> UnPackSizePrefixedEntityData(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<libtextclassifier3::EntityDataT>(GetSizePrefixedEntityData(buf)->UnPack(res));
}

}  // namespace libtextclassifier3

#endif  // FLATBUFFERS_GENERATED_ENTITYDATA_LIBTEXTCLASSIFIER3_H_
