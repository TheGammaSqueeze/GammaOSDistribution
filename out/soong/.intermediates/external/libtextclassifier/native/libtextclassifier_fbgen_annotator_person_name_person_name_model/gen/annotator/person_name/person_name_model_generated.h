// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PERSONNAMEMODEL_LIBTEXTCLASSIFIER3_H_
#define FLATBUFFERS_GENERATED_PERSONNAMEMODEL_LIBTEXTCLASSIFIER3_H_

#include "flatbuffers/flatbuffers.h"

namespace libtextclassifier3 {
namespace PersonNameModel_ {

struct PersonName;
struct PersonNameBuilder;
struct PersonNameT;

}  // namespace PersonNameModel_

struct PersonNameModel;
struct PersonNameModelBuilder;
struct PersonNameModelT;

namespace PersonNameModel_ {

struct PersonNameT : public flatbuffers::NativeTable {
  typedef PersonName TableType;
  std::string person_name;
  PersonNameT() {
  }
};

struct PersonName FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PersonNameT NativeTableType;
  typedef PersonNameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PERSON_NAME = 4
  };
  const flatbuffers::String *person_name() const {
    return GetPointer<const flatbuffers::String *>(VT_PERSON_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PERSON_NAME) &&
           verifier.VerifyString(person_name()) &&
           verifier.EndTable();
  }
  PersonNameT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PersonNameT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PersonName> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PersonNameT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PersonNameBuilder {
  typedef PersonName Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_person_name(flatbuffers::Offset<flatbuffers::String> person_name) {
    fbb_.AddOffset(PersonName::VT_PERSON_NAME, person_name);
  }
  explicit PersonNameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PersonNameBuilder &operator=(const PersonNameBuilder &);
  flatbuffers::Offset<PersonName> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PersonName>(end);
    return o;
  }
};

inline flatbuffers::Offset<PersonName> CreatePersonName(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> person_name = 0) {
  PersonNameBuilder builder_(_fbb);
  builder_.add_person_name(person_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<PersonName> CreatePersonNameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *person_name = nullptr) {
  auto person_name__ = person_name ? _fbb.CreateSharedString(person_name) : 0;
  return libtextclassifier3::PersonNameModel_::CreatePersonName(
      _fbb,
      person_name__);
}

flatbuffers::Offset<PersonName> CreatePersonName(flatbuffers::FlatBufferBuilder &_fbb, const PersonNameT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace PersonNameModel_

struct PersonNameModelT : public flatbuffers::NativeTable {
  typedef PersonNameModel TableType;
  bool enabled;
  std::vector<std::unique_ptr<libtextclassifier3::PersonNameModel_::PersonNameT>> person_names;
  bool strip_english_genitive_ending;
  std::vector<int32_t> end_of_person_name_indicators;
  bool annotate_capitalized_names_only;
  PersonNameModelT()
      : enabled(false),
        strip_english_genitive_ending(false),
        annotate_capitalized_names_only(false) {
  }
};

struct PersonNameModel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PersonNameModelT NativeTableType;
  typedef PersonNameModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLED = 4,
    VT_PERSON_NAMES = 6,
    VT_STRIP_ENGLISH_GENITIVE_ENDING = 8,
    VT_END_OF_PERSON_NAME_INDICATORS = 10,
    VT_ANNOTATE_CAPITALIZED_NAMES_ONLY = 12
  };
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::PersonNameModel_::PersonName>> *person_names() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::PersonNameModel_::PersonName>> *>(VT_PERSON_NAMES);
  }
  bool strip_english_genitive_ending() const {
    return GetField<uint8_t>(VT_STRIP_ENGLISH_GENITIVE_ENDING, 0) != 0;
  }
  const flatbuffers::Vector<int32_t> *end_of_person_name_indicators() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_END_OF_PERSON_NAME_INDICATORS);
  }
  bool annotate_capitalized_names_only() const {
    return GetField<uint8_t>(VT_ANNOTATE_CAPITALIZED_NAMES_ONLY, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED) &&
           VerifyOffset(verifier, VT_PERSON_NAMES) &&
           verifier.VerifyVector(person_names()) &&
           verifier.VerifyVectorOfTables(person_names()) &&
           VerifyField<uint8_t>(verifier, VT_STRIP_ENGLISH_GENITIVE_ENDING) &&
           VerifyOffset(verifier, VT_END_OF_PERSON_NAME_INDICATORS) &&
           verifier.VerifyVector(end_of_person_name_indicators()) &&
           VerifyField<uint8_t>(verifier, VT_ANNOTATE_CAPITALIZED_NAMES_ONLY) &&
           verifier.EndTable();
  }
  PersonNameModelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PersonNameModelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PersonNameModel> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PersonNameModelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PersonNameModelBuilder {
  typedef PersonNameModel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(PersonNameModel::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
  }
  void add_person_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::PersonNameModel_::PersonName>>> person_names) {
    fbb_.AddOffset(PersonNameModel::VT_PERSON_NAMES, person_names);
  }
  void add_strip_english_genitive_ending(bool strip_english_genitive_ending) {
    fbb_.AddElement<uint8_t>(PersonNameModel::VT_STRIP_ENGLISH_GENITIVE_ENDING, static_cast<uint8_t>(strip_english_genitive_ending), 0);
  }
  void add_end_of_person_name_indicators(flatbuffers::Offset<flatbuffers::Vector<int32_t>> end_of_person_name_indicators) {
    fbb_.AddOffset(PersonNameModel::VT_END_OF_PERSON_NAME_INDICATORS, end_of_person_name_indicators);
  }
  void add_annotate_capitalized_names_only(bool annotate_capitalized_names_only) {
    fbb_.AddElement<uint8_t>(PersonNameModel::VT_ANNOTATE_CAPITALIZED_NAMES_ONLY, static_cast<uint8_t>(annotate_capitalized_names_only), 0);
  }
  explicit PersonNameModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PersonNameModelBuilder &operator=(const PersonNameModelBuilder &);
  flatbuffers::Offset<PersonNameModel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PersonNameModel>(end);
    return o;
  }
};

inline flatbuffers::Offset<PersonNameModel> CreatePersonNameModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enabled = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::PersonNameModel_::PersonName>>> person_names = 0,
    bool strip_english_genitive_ending = false,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> end_of_person_name_indicators = 0,
    bool annotate_capitalized_names_only = false) {
  PersonNameModelBuilder builder_(_fbb);
  builder_.add_end_of_person_name_indicators(end_of_person_name_indicators);
  builder_.add_person_names(person_names);
  builder_.add_annotate_capitalized_names_only(annotate_capitalized_names_only);
  builder_.add_strip_english_genitive_ending(strip_english_genitive_ending);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

inline flatbuffers::Offset<PersonNameModel> CreatePersonNameModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enabled = false,
    const std::vector<flatbuffers::Offset<libtextclassifier3::PersonNameModel_::PersonName>> *person_names = nullptr,
    bool strip_english_genitive_ending = false,
    const std::vector<int32_t> *end_of_person_name_indicators = nullptr,
    bool annotate_capitalized_names_only = false) {
  auto person_names__ = person_names ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::PersonNameModel_::PersonName>>(*person_names) : 0;
  auto end_of_person_name_indicators__ = end_of_person_name_indicators ? _fbb.CreateVector<int32_t>(*end_of_person_name_indicators) : 0;
  return libtextclassifier3::CreatePersonNameModel(
      _fbb,
      enabled,
      person_names__,
      strip_english_genitive_ending,
      end_of_person_name_indicators__,
      annotate_capitalized_names_only);
}

flatbuffers::Offset<PersonNameModel> CreatePersonNameModel(flatbuffers::FlatBufferBuilder &_fbb, const PersonNameModelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace PersonNameModel_ {

inline PersonNameT *PersonName::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::PersonNameModel_::PersonNameT> _o = std::unique_ptr<libtextclassifier3::PersonNameModel_::PersonNameT>(new PersonNameT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PersonName::UnPackTo(PersonNameT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = person_name(); if (_e) _o->person_name = _e->str(); }
}

inline flatbuffers::Offset<PersonName> PersonName::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PersonNameT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePersonName(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PersonName> CreatePersonName(flatbuffers::FlatBufferBuilder &_fbb, const PersonNameT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PersonNameT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _person_name = _o->person_name.empty() ? 0 : _fbb.CreateSharedString(_o->person_name);
  return libtextclassifier3::PersonNameModel_::CreatePersonName(
      _fbb,
      _person_name);
}

}  // namespace PersonNameModel_

inline PersonNameModelT *PersonNameModel::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::PersonNameModelT> _o = std::unique_ptr<libtextclassifier3::PersonNameModelT>(new PersonNameModelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PersonNameModel::UnPackTo(PersonNameModelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = enabled(); _o->enabled = _e; }
  { auto _e = person_names(); if (_e) { _o->person_names.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->person_names[_i] = std::unique_ptr<libtextclassifier3::PersonNameModel_::PersonNameT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = strip_english_genitive_ending(); _o->strip_english_genitive_ending = _e; }
  { auto _e = end_of_person_name_indicators(); if (_e) { _o->end_of_person_name_indicators.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->end_of_person_name_indicators[_i] = _e->Get(_i); } } }
  { auto _e = annotate_capitalized_names_only(); _o->annotate_capitalized_names_only = _e; }
}

inline flatbuffers::Offset<PersonNameModel> PersonNameModel::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PersonNameModelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePersonNameModel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PersonNameModel> CreatePersonNameModel(flatbuffers::FlatBufferBuilder &_fbb, const PersonNameModelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PersonNameModelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _enabled = _o->enabled;
  auto _person_names = _o->person_names.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::PersonNameModel_::PersonName>> (_o->person_names.size(), [](size_t i, _VectorArgs *__va) { return CreatePersonName(*__va->__fbb, __va->__o->person_names[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _strip_english_genitive_ending = _o->strip_english_genitive_ending;
  auto _end_of_person_name_indicators = _o->end_of_person_name_indicators.size() ? _fbb.CreateVector(_o->end_of_person_name_indicators) : 0;
  auto _annotate_capitalized_names_only = _o->annotate_capitalized_names_only;
  return libtextclassifier3::CreatePersonNameModel(
      _fbb,
      _enabled,
      _person_names,
      _strip_english_genitive_ending,
      _end_of_person_name_indicators,
      _annotate_capitalized_names_only);
}

inline const libtextclassifier3::PersonNameModel *GetPersonNameModel(const void *buf) {
  return flatbuffers::GetRoot<libtextclassifier3::PersonNameModel>(buf);
}

inline const libtextclassifier3::PersonNameModel *GetSizePrefixedPersonNameModel(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<libtextclassifier3::PersonNameModel>(buf);
}

inline const char *PersonNameModelIdentifier() {
  return "TC2 ";
}

inline bool PersonNameModelBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, PersonNameModelIdentifier());
}

inline bool VerifyPersonNameModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<libtextclassifier3::PersonNameModel>(PersonNameModelIdentifier());
}

inline bool VerifySizePrefixedPersonNameModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<libtextclassifier3::PersonNameModel>(PersonNameModelIdentifier());
}

inline void FinishPersonNameModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<libtextclassifier3::PersonNameModel> root) {
  fbb.Finish(root, PersonNameModelIdentifier());
}

inline void FinishSizePrefixedPersonNameModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<libtextclassifier3::PersonNameModel> root) {
  fbb.FinishSizePrefixed(root, PersonNameModelIdentifier());
}

inline std::unique_ptr<libtextclassifier3::PersonNameModelT> UnPackPersonNameModel(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<libtextclassifier3::PersonNameModelT>(GetPersonNameModel(buf)->UnPack(res));
}

inline std::unique_ptr<libtextclassifier3::PersonNameModelT> UnPackSizePrefixedPersonNameModel(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<libtextclassifier3::PersonNameModelT>(GetSizePrefixedPersonNameModel(buf)->UnPack(res));
}

}  // namespace libtextclassifier3

#endif  // FLATBUFFERS_GENERATED_PERSONNAMEMODEL_LIBTEXTCLASSIFIER3_H_
