// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ACTIONSMODEL_LIBTEXTCLASSIFIER3_H_
#define FLATBUFFERS_GENERATED_ACTIONSMODEL_LIBTEXTCLASSIFIER3_H_

#include "flatbuffers/flatbuffers.h"

#include "actions/actions-entity-data_generated.h"
#include "annotator/entity-data_generated.h"
#include "annotator/experimental/experimental_generated.h"
#include "annotator/model_generated.h"
#include "utils/codepoint-range_generated.h"
#include "utils/container/bit-vector_generated.h"
#include "utils/flatbuffers/flatbuffers_generated.h"
#include "utils/grammar/rules_generated.h"
#include "utils/grammar/semantics/expression_generated.h"
#include "utils/i18n/language-tag_generated.h"
#include "utils/intents/intent-config_generated.h"
#include "utils/normalization_generated.h"
#include "utils/resources_generated.h"
#include "utils/tokenizer_generated.h"
#include "utils/zlib/buffer_generated.h"

namespace libtextclassifier3 {

struct PredictionMetadata;
struct PredictionMetadataBuilder;
struct PredictionMetadataT;

namespace TensorflowLiteModelSpec_ {

struct InputNameIndexEntry;
struct InputNameIndexEntryBuilder;
struct InputNameIndexEntryT;

}  // namespace TensorflowLiteModelSpec_

struct TensorflowLiteModelSpec;
struct TensorflowLiteModelSpecBuilder;
struct TensorflowLiteModelSpecT;

struct ActionsTokenizerOptions;
struct ActionsTokenizerOptionsBuilder;
struct ActionsTokenizerOptionsT;

struct ActionsTokenFeatureProcessorOptions;
struct ActionsTokenFeatureProcessorOptionsBuilder;
struct ActionsTokenFeatureProcessorOptionsT;

struct NGramLinearRegressionModel;
struct NGramLinearRegressionModelBuilder;
struct NGramLinearRegressionModelT;

struct TFLiteSensitiveClassifierConfig;
struct TFLiteSensitiveClassifierConfigBuilder;
struct TFLiteSensitiveClassifierConfigT;

struct TriggeringPreconditions;
struct TriggeringPreconditionsBuilder;
struct TriggeringPreconditionsT;

struct ActionSuggestionSpec;
struct ActionSuggestionSpecBuilder;
struct ActionSuggestionSpecT;

struct ActionTypeOptions;
struct ActionTypeOptionsBuilder;
struct ActionTypeOptionsT;

namespace AnnotationActionsSpec_ {

struct AnnotationMapping;
struct AnnotationMappingBuilder;
struct AnnotationMappingT;

}  // namespace AnnotationActionsSpec_

struct AnnotationActionsSpec;
struct AnnotationActionsSpecBuilder;
struct AnnotationActionsSpecT;

struct RankingOptions;
struct RankingOptionsBuilder;
struct RankingOptionsT;

namespace RulesModel_ {
namespace RuleActionSpec_ {

struct RuleCapturingGroup;
struct RuleCapturingGroupBuilder;
struct RuleCapturingGroupT;

}  // namespace RuleActionSpec_

struct RuleActionSpec;
struct RuleActionSpecBuilder;
struct RuleActionSpecT;

struct RegexRule;
struct RegexRuleBuilder;
struct RegexRuleT;

namespace GrammarRules_ {

struct RuleMatch;
struct RuleMatchBuilder;
struct RuleMatchT;

}  // namespace GrammarRules_

struct GrammarRules;
struct GrammarRulesBuilder;
struct GrammarRulesT;

}  // namespace RulesModel_

struct RulesModel;
struct RulesModelBuilder;
struct RulesModelT;

struct ActionsModel;
struct ActionsModelBuilder;
struct ActionsModelT;

enum PredictionType {
  PredictionType_UNSUPPORTED = 0,
  PredictionType_NEXT_MESSAGE_PREDICTION = 1,
  PredictionType_INTENT_TRIGGERING = 2,
  PredictionType_ENTITY_ANNOTATION = 3,
  PredictionType_MIN = PredictionType_UNSUPPORTED,
  PredictionType_MAX = PredictionType_ENTITY_ANNOTATION
};

inline const PredictionType (&EnumValuesPredictionType())[4] {
  static const PredictionType values[] = {
    PredictionType_UNSUPPORTED,
    PredictionType_NEXT_MESSAGE_PREDICTION,
    PredictionType_INTENT_TRIGGERING,
    PredictionType_ENTITY_ANNOTATION
  };
  return values;
}

inline const char * const *EnumNamesPredictionType() {
  static const char * const names[5] = {
    "UNSUPPORTED",
    "NEXT_MESSAGE_PREDICTION",
    "INTENT_TRIGGERING",
    "ENTITY_ANNOTATION",
    nullptr
  };
  return names;
}

inline const char *EnumNamePredictionType(PredictionType e) {
  if (flatbuffers::IsOutRange(e, PredictionType_UNSUPPORTED, PredictionType_ENTITY_ANNOTATION)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPredictionType()[index];
}

struct PredictionMetadataT : public flatbuffers::NativeTable {
  typedef PredictionMetadata TableType;
  libtextclassifier3::PredictionType prediction_type;
  std::unique_ptr<libtextclassifier3::ActionSuggestionSpecT> task_spec;
  int32_t output_suggestions;
  int32_t output_suggestions_scores;
  int32_t output_suggestions_spans;
  PredictionMetadataT()
      : prediction_type(libtextclassifier3::PredictionType_UNSUPPORTED),
        output_suggestions(0),
        output_suggestions_scores(0),
        output_suggestions_spans(0) {
  }
};

struct PredictionMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PredictionMetadataT NativeTableType;
  typedef PredictionMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PREDICTION_TYPE = 4,
    VT_TASK_SPEC = 6,
    VT_OUTPUT_SUGGESTIONS = 8,
    VT_OUTPUT_SUGGESTIONS_SCORES = 10,
    VT_OUTPUT_SUGGESTIONS_SPANS = 12
  };
  libtextclassifier3::PredictionType prediction_type() const {
    return static_cast<libtextclassifier3::PredictionType>(GetField<int32_t>(VT_PREDICTION_TYPE, 0));
  }
  const libtextclassifier3::ActionSuggestionSpec *task_spec() const {
    return GetPointer<const libtextclassifier3::ActionSuggestionSpec *>(VT_TASK_SPEC);
  }
  int32_t output_suggestions() const {
    return GetField<int32_t>(VT_OUTPUT_SUGGESTIONS, 0);
  }
  int32_t output_suggestions_scores() const {
    return GetField<int32_t>(VT_OUTPUT_SUGGESTIONS_SCORES, 0);
  }
  int32_t output_suggestions_spans() const {
    return GetField<int32_t>(VT_OUTPUT_SUGGESTIONS_SPANS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PREDICTION_TYPE) &&
           VerifyOffset(verifier, VT_TASK_SPEC) &&
           verifier.VerifyTable(task_spec()) &&
           VerifyField<int32_t>(verifier, VT_OUTPUT_SUGGESTIONS) &&
           VerifyField<int32_t>(verifier, VT_OUTPUT_SUGGESTIONS_SCORES) &&
           VerifyField<int32_t>(verifier, VT_OUTPUT_SUGGESTIONS_SPANS) &&
           verifier.EndTable();
  }
  PredictionMetadataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PredictionMetadataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PredictionMetadata> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PredictionMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PredictionMetadataBuilder {
  typedef PredictionMetadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_prediction_type(libtextclassifier3::PredictionType prediction_type) {
    fbb_.AddElement<int32_t>(PredictionMetadata::VT_PREDICTION_TYPE, static_cast<int32_t>(prediction_type), 0);
  }
  void add_task_spec(flatbuffers::Offset<libtextclassifier3::ActionSuggestionSpec> task_spec) {
    fbb_.AddOffset(PredictionMetadata::VT_TASK_SPEC, task_spec);
  }
  void add_output_suggestions(int32_t output_suggestions) {
    fbb_.AddElement<int32_t>(PredictionMetadata::VT_OUTPUT_SUGGESTIONS, output_suggestions, 0);
  }
  void add_output_suggestions_scores(int32_t output_suggestions_scores) {
    fbb_.AddElement<int32_t>(PredictionMetadata::VT_OUTPUT_SUGGESTIONS_SCORES, output_suggestions_scores, 0);
  }
  void add_output_suggestions_spans(int32_t output_suggestions_spans) {
    fbb_.AddElement<int32_t>(PredictionMetadata::VT_OUTPUT_SUGGESTIONS_SPANS, output_suggestions_spans, 0);
  }
  explicit PredictionMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PredictionMetadataBuilder &operator=(const PredictionMetadataBuilder &);
  flatbuffers::Offset<PredictionMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PredictionMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<PredictionMetadata> CreatePredictionMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    libtextclassifier3::PredictionType prediction_type = libtextclassifier3::PredictionType_UNSUPPORTED,
    flatbuffers::Offset<libtextclassifier3::ActionSuggestionSpec> task_spec = 0,
    int32_t output_suggestions = 0,
    int32_t output_suggestions_scores = 0,
    int32_t output_suggestions_spans = 0) {
  PredictionMetadataBuilder builder_(_fbb);
  builder_.add_output_suggestions_spans(output_suggestions_spans);
  builder_.add_output_suggestions_scores(output_suggestions_scores);
  builder_.add_output_suggestions(output_suggestions);
  builder_.add_task_spec(task_spec);
  builder_.add_prediction_type(prediction_type);
  return builder_.Finish();
}

flatbuffers::Offset<PredictionMetadata> CreatePredictionMetadata(flatbuffers::FlatBufferBuilder &_fbb, const PredictionMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TensorflowLiteModelSpec_ {

struct InputNameIndexEntryT : public flatbuffers::NativeTable {
  typedef InputNameIndexEntry TableType;
  std::string key;
  int32_t value;
  InputNameIndexEntryT()
      : value(0) {
  }
};

struct InputNameIndexEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InputNameIndexEntryT NativeTableType;
  typedef InputNameIndexEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  bool KeyCompareLessThan(const InputNameIndexEntry *o) const {
    return *key() < *o->key();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(key()->c_str(), val);
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
  InputNameIndexEntryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InputNameIndexEntryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InputNameIndexEntry> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InputNameIndexEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InputNameIndexEntryBuilder {
  typedef InputNameIndexEntry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(InputNameIndexEntry::VT_KEY, key);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(InputNameIndexEntry::VT_VALUE, value, 0);
  }
  explicit InputNameIndexEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InputNameIndexEntryBuilder &operator=(const InputNameIndexEntryBuilder &);
  flatbuffers::Offset<InputNameIndexEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InputNameIndexEntry>(end);
    fbb_.Required(o, InputNameIndexEntry::VT_KEY);
    return o;
  }
};

inline flatbuffers::Offset<InputNameIndexEntry> CreateInputNameIndexEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    int32_t value = 0) {
  InputNameIndexEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<InputNameIndexEntry> CreateInputNameIndexEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    int32_t value = 0) {
  auto key__ = key ? _fbb.CreateSharedString(key) : 0;
  return libtextclassifier3::TensorflowLiteModelSpec_::CreateInputNameIndexEntry(
      _fbb,
      key__,
      value);
}

flatbuffers::Offset<InputNameIndexEntry> CreateInputNameIndexEntry(flatbuffers::FlatBufferBuilder &_fbb, const InputNameIndexEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace TensorflowLiteModelSpec_

struct TensorflowLiteModelSpecT : public flatbuffers::NativeTable {
  typedef TensorflowLiteModelSpec TableType;
  std::vector<uint8_t> tflite_model;
  int32_t input_user_id;
  int32_t input_context;
  int32_t input_context_length;
  int32_t input_time_diffs;
  int32_t input_num_suggestions;
  int32_t input_token_embeddings;
  int32_t input_num_tokens;
  int32_t output_replies;
  int32_t output_replies_scores;
  int32_t output_sensitive_topic_score;
  int32_t output_triggering_score;
  int32_t output_actions_scores;
  bool resize_inputs;
  int32_t input_flattened_token_embeddings;
  std::vector<std::unique_ptr<libtextclassifier3::PredictionMetadataT>> prediction_metadata;
  std::vector<std::unique_ptr<libtextclassifier3::TensorflowLiteModelSpec_::InputNameIndexEntryT>> input_name_index;
  int32_t input_length_to_pad;
  TensorflowLiteModelSpecT()
      : input_user_id(0),
        input_context(1),
        input_context_length(2),
        input_time_diffs(3),
        input_num_suggestions(4),
        input_token_embeddings(-1),
        input_num_tokens(-1),
        output_replies(0),
        output_replies_scores(1),
        output_sensitive_topic_score(3),
        output_triggering_score(4),
        output_actions_scores(5),
        resize_inputs(false),
        input_flattened_token_embeddings(-1),
        input_length_to_pad(0) {
  }
};

struct TensorflowLiteModelSpec FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorflowLiteModelSpecT NativeTableType;
  typedef TensorflowLiteModelSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TFLITE_MODEL = 4,
    VT_INPUT_USER_ID = 6,
    VT_INPUT_CONTEXT = 8,
    VT_INPUT_CONTEXT_LENGTH = 10,
    VT_INPUT_TIME_DIFFS = 12,
    VT_INPUT_NUM_SUGGESTIONS = 14,
    VT_INPUT_TOKEN_EMBEDDINGS = 22,
    VT_INPUT_NUM_TOKENS = 24,
    VT_OUTPUT_REPLIES = 26,
    VT_OUTPUT_REPLIES_SCORES = 28,
    VT_OUTPUT_SENSITIVE_TOPIC_SCORE = 30,
    VT_OUTPUT_TRIGGERING_SCORE = 32,
    VT_OUTPUT_ACTIONS_SCORES = 34,
    VT_RESIZE_INPUTS = 36,
    VT_INPUT_FLATTENED_TOKEN_EMBEDDINGS = 38,
    VT_PREDICTION_METADATA = 40,
    VT_INPUT_NAME_INDEX = 42,
    VT_INPUT_LENGTH_TO_PAD = 44
  };
  const flatbuffers::Vector<uint8_t> *tflite_model() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_TFLITE_MODEL);
  }
  int32_t input_user_id() const {
    return GetField<int32_t>(VT_INPUT_USER_ID, 0);
  }
  int32_t input_context() const {
    return GetField<int32_t>(VT_INPUT_CONTEXT, 1);
  }
  int32_t input_context_length() const {
    return GetField<int32_t>(VT_INPUT_CONTEXT_LENGTH, 2);
  }
  int32_t input_time_diffs() const {
    return GetField<int32_t>(VT_INPUT_TIME_DIFFS, 3);
  }
  int32_t input_num_suggestions() const {
    return GetField<int32_t>(VT_INPUT_NUM_SUGGESTIONS, 4);
  }
  int32_t input_token_embeddings() const {
    return GetField<int32_t>(VT_INPUT_TOKEN_EMBEDDINGS, -1);
  }
  int32_t input_num_tokens() const {
    return GetField<int32_t>(VT_INPUT_NUM_TOKENS, -1);
  }
  int32_t output_replies() const {
    return GetField<int32_t>(VT_OUTPUT_REPLIES, 0);
  }
  int32_t output_replies_scores() const {
    return GetField<int32_t>(VT_OUTPUT_REPLIES_SCORES, 1);
  }
  int32_t output_sensitive_topic_score() const {
    return GetField<int32_t>(VT_OUTPUT_SENSITIVE_TOPIC_SCORE, 3);
  }
  int32_t output_triggering_score() const {
    return GetField<int32_t>(VT_OUTPUT_TRIGGERING_SCORE, 4);
  }
  int32_t output_actions_scores() const {
    return GetField<int32_t>(VT_OUTPUT_ACTIONS_SCORES, 5);
  }
  bool resize_inputs() const {
    return GetField<uint8_t>(VT_RESIZE_INPUTS, 0) != 0;
  }
  int32_t input_flattened_token_embeddings() const {
    return GetField<int32_t>(VT_INPUT_FLATTENED_TOKEN_EMBEDDINGS, -1);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::PredictionMetadata>> *prediction_metadata() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::PredictionMetadata>> *>(VT_PREDICTION_METADATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::TensorflowLiteModelSpec_::InputNameIndexEntry>> *input_name_index() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::TensorflowLiteModelSpec_::InputNameIndexEntry>> *>(VT_INPUT_NAME_INDEX);
  }
  int32_t input_length_to_pad() const {
    return GetField<int32_t>(VT_INPUT_LENGTH_TO_PAD, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TFLITE_MODEL) &&
           verifier.VerifyVector(tflite_model()) &&
           VerifyField<int32_t>(verifier, VT_INPUT_USER_ID) &&
           VerifyField<int32_t>(verifier, VT_INPUT_CONTEXT) &&
           VerifyField<int32_t>(verifier, VT_INPUT_CONTEXT_LENGTH) &&
           VerifyField<int32_t>(verifier, VT_INPUT_TIME_DIFFS) &&
           VerifyField<int32_t>(verifier, VT_INPUT_NUM_SUGGESTIONS) &&
           VerifyField<int32_t>(verifier, VT_INPUT_TOKEN_EMBEDDINGS) &&
           VerifyField<int32_t>(verifier, VT_INPUT_NUM_TOKENS) &&
           VerifyField<int32_t>(verifier, VT_OUTPUT_REPLIES) &&
           VerifyField<int32_t>(verifier, VT_OUTPUT_REPLIES_SCORES) &&
           VerifyField<int32_t>(verifier, VT_OUTPUT_SENSITIVE_TOPIC_SCORE) &&
           VerifyField<int32_t>(verifier, VT_OUTPUT_TRIGGERING_SCORE) &&
           VerifyField<int32_t>(verifier, VT_OUTPUT_ACTIONS_SCORES) &&
           VerifyField<uint8_t>(verifier, VT_RESIZE_INPUTS) &&
           VerifyField<int32_t>(verifier, VT_INPUT_FLATTENED_TOKEN_EMBEDDINGS) &&
           VerifyOffset(verifier, VT_PREDICTION_METADATA) &&
           verifier.VerifyVector(prediction_metadata()) &&
           verifier.VerifyVectorOfTables(prediction_metadata()) &&
           VerifyOffset(verifier, VT_INPUT_NAME_INDEX) &&
           verifier.VerifyVector(input_name_index()) &&
           verifier.VerifyVectorOfTables(input_name_index()) &&
           VerifyField<int32_t>(verifier, VT_INPUT_LENGTH_TO_PAD) &&
           verifier.EndTable();
  }
  TensorflowLiteModelSpecT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorflowLiteModelSpecT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorflowLiteModelSpec> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorflowLiteModelSpecT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorflowLiteModelSpecBuilder {
  typedef TensorflowLiteModelSpec Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tflite_model(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> tflite_model) {
    fbb_.AddOffset(TensorflowLiteModelSpec::VT_TFLITE_MODEL, tflite_model);
  }
  void add_input_user_id(int32_t input_user_id) {
    fbb_.AddElement<int32_t>(TensorflowLiteModelSpec::VT_INPUT_USER_ID, input_user_id, 0);
  }
  void add_input_context(int32_t input_context) {
    fbb_.AddElement<int32_t>(TensorflowLiteModelSpec::VT_INPUT_CONTEXT, input_context, 1);
  }
  void add_input_context_length(int32_t input_context_length) {
    fbb_.AddElement<int32_t>(TensorflowLiteModelSpec::VT_INPUT_CONTEXT_LENGTH, input_context_length, 2);
  }
  void add_input_time_diffs(int32_t input_time_diffs) {
    fbb_.AddElement<int32_t>(TensorflowLiteModelSpec::VT_INPUT_TIME_DIFFS, input_time_diffs, 3);
  }
  void add_input_num_suggestions(int32_t input_num_suggestions) {
    fbb_.AddElement<int32_t>(TensorflowLiteModelSpec::VT_INPUT_NUM_SUGGESTIONS, input_num_suggestions, 4);
  }
  void add_input_token_embeddings(int32_t input_token_embeddings) {
    fbb_.AddElement<int32_t>(TensorflowLiteModelSpec::VT_INPUT_TOKEN_EMBEDDINGS, input_token_embeddings, -1);
  }
  void add_input_num_tokens(int32_t input_num_tokens) {
    fbb_.AddElement<int32_t>(TensorflowLiteModelSpec::VT_INPUT_NUM_TOKENS, input_num_tokens, -1);
  }
  void add_output_replies(int32_t output_replies) {
    fbb_.AddElement<int32_t>(TensorflowLiteModelSpec::VT_OUTPUT_REPLIES, output_replies, 0);
  }
  void add_output_replies_scores(int32_t output_replies_scores) {
    fbb_.AddElement<int32_t>(TensorflowLiteModelSpec::VT_OUTPUT_REPLIES_SCORES, output_replies_scores, 1);
  }
  void add_output_sensitive_topic_score(int32_t output_sensitive_topic_score) {
    fbb_.AddElement<int32_t>(TensorflowLiteModelSpec::VT_OUTPUT_SENSITIVE_TOPIC_SCORE, output_sensitive_topic_score, 3);
  }
  void add_output_triggering_score(int32_t output_triggering_score) {
    fbb_.AddElement<int32_t>(TensorflowLiteModelSpec::VT_OUTPUT_TRIGGERING_SCORE, output_triggering_score, 4);
  }
  void add_output_actions_scores(int32_t output_actions_scores) {
    fbb_.AddElement<int32_t>(TensorflowLiteModelSpec::VT_OUTPUT_ACTIONS_SCORES, output_actions_scores, 5);
  }
  void add_resize_inputs(bool resize_inputs) {
    fbb_.AddElement<uint8_t>(TensorflowLiteModelSpec::VT_RESIZE_INPUTS, static_cast<uint8_t>(resize_inputs), 0);
  }
  void add_input_flattened_token_embeddings(int32_t input_flattened_token_embeddings) {
    fbb_.AddElement<int32_t>(TensorflowLiteModelSpec::VT_INPUT_FLATTENED_TOKEN_EMBEDDINGS, input_flattened_token_embeddings, -1);
  }
  void add_prediction_metadata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::PredictionMetadata>>> prediction_metadata) {
    fbb_.AddOffset(TensorflowLiteModelSpec::VT_PREDICTION_METADATA, prediction_metadata);
  }
  void add_input_name_index(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::TensorflowLiteModelSpec_::InputNameIndexEntry>>> input_name_index) {
    fbb_.AddOffset(TensorflowLiteModelSpec::VT_INPUT_NAME_INDEX, input_name_index);
  }
  void add_input_length_to_pad(int32_t input_length_to_pad) {
    fbb_.AddElement<int32_t>(TensorflowLiteModelSpec::VT_INPUT_LENGTH_TO_PAD, input_length_to_pad, 0);
  }
  explicit TensorflowLiteModelSpecBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorflowLiteModelSpecBuilder &operator=(const TensorflowLiteModelSpecBuilder &);
  flatbuffers::Offset<TensorflowLiteModelSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorflowLiteModelSpec>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorflowLiteModelSpec> CreateTensorflowLiteModelSpec(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> tflite_model = 0,
    int32_t input_user_id = 0,
    int32_t input_context = 1,
    int32_t input_context_length = 2,
    int32_t input_time_diffs = 3,
    int32_t input_num_suggestions = 4,
    int32_t input_token_embeddings = -1,
    int32_t input_num_tokens = -1,
    int32_t output_replies = 0,
    int32_t output_replies_scores = 1,
    int32_t output_sensitive_topic_score = 3,
    int32_t output_triggering_score = 4,
    int32_t output_actions_scores = 5,
    bool resize_inputs = false,
    int32_t input_flattened_token_embeddings = -1,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::PredictionMetadata>>> prediction_metadata = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::TensorflowLiteModelSpec_::InputNameIndexEntry>>> input_name_index = 0,
    int32_t input_length_to_pad = 0) {
  TensorflowLiteModelSpecBuilder builder_(_fbb);
  builder_.add_input_length_to_pad(input_length_to_pad);
  builder_.add_input_name_index(input_name_index);
  builder_.add_prediction_metadata(prediction_metadata);
  builder_.add_input_flattened_token_embeddings(input_flattened_token_embeddings);
  builder_.add_output_actions_scores(output_actions_scores);
  builder_.add_output_triggering_score(output_triggering_score);
  builder_.add_output_sensitive_topic_score(output_sensitive_topic_score);
  builder_.add_output_replies_scores(output_replies_scores);
  builder_.add_output_replies(output_replies);
  builder_.add_input_num_tokens(input_num_tokens);
  builder_.add_input_token_embeddings(input_token_embeddings);
  builder_.add_input_num_suggestions(input_num_suggestions);
  builder_.add_input_time_diffs(input_time_diffs);
  builder_.add_input_context_length(input_context_length);
  builder_.add_input_context(input_context);
  builder_.add_input_user_id(input_user_id);
  builder_.add_tflite_model(tflite_model);
  builder_.add_resize_inputs(resize_inputs);
  return builder_.Finish();
}

inline flatbuffers::Offset<TensorflowLiteModelSpec> CreateTensorflowLiteModelSpecDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *tflite_model = nullptr,
    int32_t input_user_id = 0,
    int32_t input_context = 1,
    int32_t input_context_length = 2,
    int32_t input_time_diffs = 3,
    int32_t input_num_suggestions = 4,
    int32_t input_token_embeddings = -1,
    int32_t input_num_tokens = -1,
    int32_t output_replies = 0,
    int32_t output_replies_scores = 1,
    int32_t output_sensitive_topic_score = 3,
    int32_t output_triggering_score = 4,
    int32_t output_actions_scores = 5,
    bool resize_inputs = false,
    int32_t input_flattened_token_embeddings = -1,
    const std::vector<flatbuffers::Offset<libtextclassifier3::PredictionMetadata>> *prediction_metadata = nullptr,
    std::vector<flatbuffers::Offset<libtextclassifier3::TensorflowLiteModelSpec_::InputNameIndexEntry>> *input_name_index = nullptr,
    int32_t input_length_to_pad = 0) {
  if (tflite_model) { _fbb.ForceVectorAlignment(tflite_model->size(), sizeof(uint8_t), 16); }
  auto tflite_model__ = tflite_model ? _fbb.CreateVector<uint8_t>(*tflite_model) : 0;
  auto prediction_metadata__ = prediction_metadata ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::PredictionMetadata>>(*prediction_metadata) : 0;
  auto input_name_index__ = input_name_index ? _fbb.CreateVectorOfSortedTables<libtextclassifier3::TensorflowLiteModelSpec_::InputNameIndexEntry>(input_name_index) : 0;
  return libtextclassifier3::CreateTensorflowLiteModelSpec(
      _fbb,
      tflite_model__,
      input_user_id,
      input_context,
      input_context_length,
      input_time_diffs,
      input_num_suggestions,
      input_token_embeddings,
      input_num_tokens,
      output_replies,
      output_replies_scores,
      output_sensitive_topic_score,
      output_triggering_score,
      output_actions_scores,
      resize_inputs,
      input_flattened_token_embeddings,
      prediction_metadata__,
      input_name_index__,
      input_length_to_pad);
}

flatbuffers::Offset<TensorflowLiteModelSpec> CreateTensorflowLiteModelSpec(flatbuffers::FlatBufferBuilder &_fbb, const TensorflowLiteModelSpecT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ActionsTokenizerOptionsT : public flatbuffers::NativeTable {
  typedef ActionsTokenizerOptions TableType;
  libtextclassifier3::TokenizationType type;
  bool icu_preserve_whitespace_tokens;
  std::vector<std::unique_ptr<libtextclassifier3::TokenizationCodepointRangeT>> tokenization_codepoint_config;
  std::vector<std::unique_ptr<libtextclassifier3::CodepointRangeT>> internal_tokenizer_codepoint_ranges;
  bool tokenize_on_script_change;
  ActionsTokenizerOptionsT()
      : type(libtextclassifier3::TokenizationType_INTERNAL_TOKENIZER),
        icu_preserve_whitespace_tokens(false),
        tokenize_on_script_change(false) {
  }
};

struct ActionsTokenizerOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActionsTokenizerOptionsT NativeTableType;
  typedef ActionsTokenizerOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_ICU_PRESERVE_WHITESPACE_TOKENS = 6,
    VT_TOKENIZATION_CODEPOINT_CONFIG = 8,
    VT_INTERNAL_TOKENIZER_CODEPOINT_RANGES = 10,
    VT_TOKENIZE_ON_SCRIPT_CHANGE = 12
  };
  libtextclassifier3::TokenizationType type() const {
    return static_cast<libtextclassifier3::TokenizationType>(GetField<int32_t>(VT_TYPE, 1));
  }
  bool icu_preserve_whitespace_tokens() const {
    return GetField<uint8_t>(VT_ICU_PRESERVE_WHITESPACE_TOKENS, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::TokenizationCodepointRange>> *tokenization_codepoint_config() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::TokenizationCodepointRange>> *>(VT_TOKENIZATION_CODEPOINT_CONFIG);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::CodepointRange>> *internal_tokenizer_codepoint_ranges() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::CodepointRange>> *>(VT_INTERNAL_TOKENIZER_CODEPOINT_RANGES);
  }
  bool tokenize_on_script_change() const {
    return GetField<uint8_t>(VT_TOKENIZE_ON_SCRIPT_CHANGE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_ICU_PRESERVE_WHITESPACE_TOKENS) &&
           VerifyOffset(verifier, VT_TOKENIZATION_CODEPOINT_CONFIG) &&
           verifier.VerifyVector(tokenization_codepoint_config()) &&
           verifier.VerifyVectorOfTables(tokenization_codepoint_config()) &&
           VerifyOffset(verifier, VT_INTERNAL_TOKENIZER_CODEPOINT_RANGES) &&
           verifier.VerifyVector(internal_tokenizer_codepoint_ranges()) &&
           verifier.VerifyVectorOfTables(internal_tokenizer_codepoint_ranges()) &&
           VerifyField<uint8_t>(verifier, VT_TOKENIZE_ON_SCRIPT_CHANGE) &&
           verifier.EndTable();
  }
  ActionsTokenizerOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ActionsTokenizerOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ActionsTokenizerOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActionsTokenizerOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ActionsTokenizerOptionsBuilder {
  typedef ActionsTokenizerOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(libtextclassifier3::TokenizationType type) {
    fbb_.AddElement<int32_t>(ActionsTokenizerOptions::VT_TYPE, static_cast<int32_t>(type), 1);
  }
  void add_icu_preserve_whitespace_tokens(bool icu_preserve_whitespace_tokens) {
    fbb_.AddElement<uint8_t>(ActionsTokenizerOptions::VT_ICU_PRESERVE_WHITESPACE_TOKENS, static_cast<uint8_t>(icu_preserve_whitespace_tokens), 0);
  }
  void add_tokenization_codepoint_config(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::TokenizationCodepointRange>>> tokenization_codepoint_config) {
    fbb_.AddOffset(ActionsTokenizerOptions::VT_TOKENIZATION_CODEPOINT_CONFIG, tokenization_codepoint_config);
  }
  void add_internal_tokenizer_codepoint_ranges(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::CodepointRange>>> internal_tokenizer_codepoint_ranges) {
    fbb_.AddOffset(ActionsTokenizerOptions::VT_INTERNAL_TOKENIZER_CODEPOINT_RANGES, internal_tokenizer_codepoint_ranges);
  }
  void add_tokenize_on_script_change(bool tokenize_on_script_change) {
    fbb_.AddElement<uint8_t>(ActionsTokenizerOptions::VT_TOKENIZE_ON_SCRIPT_CHANGE, static_cast<uint8_t>(tokenize_on_script_change), 0);
  }
  explicit ActionsTokenizerOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ActionsTokenizerOptionsBuilder &operator=(const ActionsTokenizerOptionsBuilder &);
  flatbuffers::Offset<ActionsTokenizerOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ActionsTokenizerOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ActionsTokenizerOptions> CreateActionsTokenizerOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    libtextclassifier3::TokenizationType type = libtextclassifier3::TokenizationType_INTERNAL_TOKENIZER,
    bool icu_preserve_whitespace_tokens = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::TokenizationCodepointRange>>> tokenization_codepoint_config = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::CodepointRange>>> internal_tokenizer_codepoint_ranges = 0,
    bool tokenize_on_script_change = false) {
  ActionsTokenizerOptionsBuilder builder_(_fbb);
  builder_.add_internal_tokenizer_codepoint_ranges(internal_tokenizer_codepoint_ranges);
  builder_.add_tokenization_codepoint_config(tokenization_codepoint_config);
  builder_.add_type(type);
  builder_.add_tokenize_on_script_change(tokenize_on_script_change);
  builder_.add_icu_preserve_whitespace_tokens(icu_preserve_whitespace_tokens);
  return builder_.Finish();
}

inline flatbuffers::Offset<ActionsTokenizerOptions> CreateActionsTokenizerOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    libtextclassifier3::TokenizationType type = libtextclassifier3::TokenizationType_INTERNAL_TOKENIZER,
    bool icu_preserve_whitespace_tokens = false,
    const std::vector<flatbuffers::Offset<libtextclassifier3::TokenizationCodepointRange>> *tokenization_codepoint_config = nullptr,
    const std::vector<flatbuffers::Offset<libtextclassifier3::CodepointRange>> *internal_tokenizer_codepoint_ranges = nullptr,
    bool tokenize_on_script_change = false) {
  auto tokenization_codepoint_config__ = tokenization_codepoint_config ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::TokenizationCodepointRange>>(*tokenization_codepoint_config) : 0;
  auto internal_tokenizer_codepoint_ranges__ = internal_tokenizer_codepoint_ranges ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::CodepointRange>>(*internal_tokenizer_codepoint_ranges) : 0;
  return libtextclassifier3::CreateActionsTokenizerOptions(
      _fbb,
      type,
      icu_preserve_whitespace_tokens,
      tokenization_codepoint_config__,
      internal_tokenizer_codepoint_ranges__,
      tokenize_on_script_change);
}

flatbuffers::Offset<ActionsTokenizerOptions> CreateActionsTokenizerOptions(flatbuffers::FlatBufferBuilder &_fbb, const ActionsTokenizerOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ActionsTokenFeatureProcessorOptionsT : public flatbuffers::NativeTable {
  typedef ActionsTokenFeatureProcessorOptions TableType;
  std::unique_ptr<libtextclassifier3::ActionsTokenizerOptionsT> tokenizer_options;
  std::vector<uint8_t> embedding_model;
  int32_t embedding_size;
  int32_t embedding_quantization_bits;
  int32_t num_buckets;
  std::vector<int32_t> chargram_orders;
  bool extract_case_feature;
  bool unicode_aware_features;
  std::vector<std::string> regexp_features;
  bool remap_digits;
  bool lowercase_tokens;
  int32_t max_token_length;
  int32_t max_num_tokens_per_message;
  int32_t min_num_tokens_per_message;
  int32_t max_num_total_tokens;
  int32_t min_num_total_tokens;
  int32_t padding_token_id;
  int32_t start_token_id;
  int32_t end_token_id;
  ActionsTokenFeatureProcessorOptionsT()
      : embedding_size(-1),
        embedding_quantization_bits(8),
        num_buckets(-1),
        extract_case_feature(false),
        unicode_aware_features(false),
        remap_digits(false),
        lowercase_tokens(false),
        max_token_length(20),
        max_num_tokens_per_message(-1),
        min_num_tokens_per_message(-1),
        max_num_total_tokens(-1),
        min_num_total_tokens(-1),
        padding_token_id(0),
        start_token_id(1),
        end_token_id(2) {
  }
};

struct ActionsTokenFeatureProcessorOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActionsTokenFeatureProcessorOptionsT NativeTableType;
  typedef ActionsTokenFeatureProcessorOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOKENIZER_OPTIONS = 4,
    VT_EMBEDDING_MODEL = 6,
    VT_EMBEDDING_SIZE = 8,
    VT_EMBEDDING_QUANTIZATION_BITS = 10,
    VT_NUM_BUCKETS = 12,
    VT_CHARGRAM_ORDERS = 14,
    VT_EXTRACT_CASE_FEATURE = 16,
    VT_UNICODE_AWARE_FEATURES = 18,
    VT_REGEXP_FEATURES = 20,
    VT_REMAP_DIGITS = 22,
    VT_LOWERCASE_TOKENS = 24,
    VT_MAX_TOKEN_LENGTH = 26,
    VT_MAX_NUM_TOKENS_PER_MESSAGE = 28,
    VT_MIN_NUM_TOKENS_PER_MESSAGE = 30,
    VT_MAX_NUM_TOTAL_TOKENS = 32,
    VT_MIN_NUM_TOTAL_TOKENS = 34,
    VT_PADDING_TOKEN_ID = 36,
    VT_START_TOKEN_ID = 38,
    VT_END_TOKEN_ID = 40
  };
  const libtextclassifier3::ActionsTokenizerOptions *tokenizer_options() const {
    return GetPointer<const libtextclassifier3::ActionsTokenizerOptions *>(VT_TOKENIZER_OPTIONS);
  }
  const flatbuffers::Vector<uint8_t> *embedding_model() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_EMBEDDING_MODEL);
  }
  int32_t embedding_size() const {
    return GetField<int32_t>(VT_EMBEDDING_SIZE, -1);
  }
  int32_t embedding_quantization_bits() const {
    return GetField<int32_t>(VT_EMBEDDING_QUANTIZATION_BITS, 8);
  }
  int32_t num_buckets() const {
    return GetField<int32_t>(VT_NUM_BUCKETS, -1);
  }
  const flatbuffers::Vector<int32_t> *chargram_orders() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CHARGRAM_ORDERS);
  }
  bool extract_case_feature() const {
    return GetField<uint8_t>(VT_EXTRACT_CASE_FEATURE, 0) != 0;
  }
  bool unicode_aware_features() const {
    return GetField<uint8_t>(VT_UNICODE_AWARE_FEATURES, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *regexp_features() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_REGEXP_FEATURES);
  }
  bool remap_digits() const {
    return GetField<uint8_t>(VT_REMAP_DIGITS, 0) != 0;
  }
  bool lowercase_tokens() const {
    return GetField<uint8_t>(VT_LOWERCASE_TOKENS, 0) != 0;
  }
  int32_t max_token_length() const {
    return GetField<int32_t>(VT_MAX_TOKEN_LENGTH, 20);
  }
  int32_t max_num_tokens_per_message() const {
    return GetField<int32_t>(VT_MAX_NUM_TOKENS_PER_MESSAGE, -1);
  }
  int32_t min_num_tokens_per_message() const {
    return GetField<int32_t>(VT_MIN_NUM_TOKENS_PER_MESSAGE, -1);
  }
  int32_t max_num_total_tokens() const {
    return GetField<int32_t>(VT_MAX_NUM_TOTAL_TOKENS, -1);
  }
  int32_t min_num_total_tokens() const {
    return GetField<int32_t>(VT_MIN_NUM_TOTAL_TOKENS, -1);
  }
  int32_t padding_token_id() const {
    return GetField<int32_t>(VT_PADDING_TOKEN_ID, 0);
  }
  int32_t start_token_id() const {
    return GetField<int32_t>(VT_START_TOKEN_ID, 1);
  }
  int32_t end_token_id() const {
    return GetField<int32_t>(VT_END_TOKEN_ID, 2);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOKENIZER_OPTIONS) &&
           verifier.VerifyTable(tokenizer_options()) &&
           VerifyOffset(verifier, VT_EMBEDDING_MODEL) &&
           verifier.VerifyVector(embedding_model()) &&
           VerifyField<int32_t>(verifier, VT_EMBEDDING_SIZE) &&
           VerifyField<int32_t>(verifier, VT_EMBEDDING_QUANTIZATION_BITS) &&
           VerifyField<int32_t>(verifier, VT_NUM_BUCKETS) &&
           VerifyOffset(verifier, VT_CHARGRAM_ORDERS) &&
           verifier.VerifyVector(chargram_orders()) &&
           VerifyField<uint8_t>(verifier, VT_EXTRACT_CASE_FEATURE) &&
           VerifyField<uint8_t>(verifier, VT_UNICODE_AWARE_FEATURES) &&
           VerifyOffset(verifier, VT_REGEXP_FEATURES) &&
           verifier.VerifyVector(regexp_features()) &&
           verifier.VerifyVectorOfStrings(regexp_features()) &&
           VerifyField<uint8_t>(verifier, VT_REMAP_DIGITS) &&
           VerifyField<uint8_t>(verifier, VT_LOWERCASE_TOKENS) &&
           VerifyField<int32_t>(verifier, VT_MAX_TOKEN_LENGTH) &&
           VerifyField<int32_t>(verifier, VT_MAX_NUM_TOKENS_PER_MESSAGE) &&
           VerifyField<int32_t>(verifier, VT_MIN_NUM_TOKENS_PER_MESSAGE) &&
           VerifyField<int32_t>(verifier, VT_MAX_NUM_TOTAL_TOKENS) &&
           VerifyField<int32_t>(verifier, VT_MIN_NUM_TOTAL_TOKENS) &&
           VerifyField<int32_t>(verifier, VT_PADDING_TOKEN_ID) &&
           VerifyField<int32_t>(verifier, VT_START_TOKEN_ID) &&
           VerifyField<int32_t>(verifier, VT_END_TOKEN_ID) &&
           verifier.EndTable();
  }
  ActionsTokenFeatureProcessorOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ActionsTokenFeatureProcessorOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ActionsTokenFeatureProcessorOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActionsTokenFeatureProcessorOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ActionsTokenFeatureProcessorOptionsBuilder {
  typedef ActionsTokenFeatureProcessorOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tokenizer_options(flatbuffers::Offset<libtextclassifier3::ActionsTokenizerOptions> tokenizer_options) {
    fbb_.AddOffset(ActionsTokenFeatureProcessorOptions::VT_TOKENIZER_OPTIONS, tokenizer_options);
  }
  void add_embedding_model(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> embedding_model) {
    fbb_.AddOffset(ActionsTokenFeatureProcessorOptions::VT_EMBEDDING_MODEL, embedding_model);
  }
  void add_embedding_size(int32_t embedding_size) {
    fbb_.AddElement<int32_t>(ActionsTokenFeatureProcessorOptions::VT_EMBEDDING_SIZE, embedding_size, -1);
  }
  void add_embedding_quantization_bits(int32_t embedding_quantization_bits) {
    fbb_.AddElement<int32_t>(ActionsTokenFeatureProcessorOptions::VT_EMBEDDING_QUANTIZATION_BITS, embedding_quantization_bits, 8);
  }
  void add_num_buckets(int32_t num_buckets) {
    fbb_.AddElement<int32_t>(ActionsTokenFeatureProcessorOptions::VT_NUM_BUCKETS, num_buckets, -1);
  }
  void add_chargram_orders(flatbuffers::Offset<flatbuffers::Vector<int32_t>> chargram_orders) {
    fbb_.AddOffset(ActionsTokenFeatureProcessorOptions::VT_CHARGRAM_ORDERS, chargram_orders);
  }
  void add_extract_case_feature(bool extract_case_feature) {
    fbb_.AddElement<uint8_t>(ActionsTokenFeatureProcessorOptions::VT_EXTRACT_CASE_FEATURE, static_cast<uint8_t>(extract_case_feature), 0);
  }
  void add_unicode_aware_features(bool unicode_aware_features) {
    fbb_.AddElement<uint8_t>(ActionsTokenFeatureProcessorOptions::VT_UNICODE_AWARE_FEATURES, static_cast<uint8_t>(unicode_aware_features), 0);
  }
  void add_regexp_features(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> regexp_features) {
    fbb_.AddOffset(ActionsTokenFeatureProcessorOptions::VT_REGEXP_FEATURES, regexp_features);
  }
  void add_remap_digits(bool remap_digits) {
    fbb_.AddElement<uint8_t>(ActionsTokenFeatureProcessorOptions::VT_REMAP_DIGITS, static_cast<uint8_t>(remap_digits), 0);
  }
  void add_lowercase_tokens(bool lowercase_tokens) {
    fbb_.AddElement<uint8_t>(ActionsTokenFeatureProcessorOptions::VT_LOWERCASE_TOKENS, static_cast<uint8_t>(lowercase_tokens), 0);
  }
  void add_max_token_length(int32_t max_token_length) {
    fbb_.AddElement<int32_t>(ActionsTokenFeatureProcessorOptions::VT_MAX_TOKEN_LENGTH, max_token_length, 20);
  }
  void add_max_num_tokens_per_message(int32_t max_num_tokens_per_message) {
    fbb_.AddElement<int32_t>(ActionsTokenFeatureProcessorOptions::VT_MAX_NUM_TOKENS_PER_MESSAGE, max_num_tokens_per_message, -1);
  }
  void add_min_num_tokens_per_message(int32_t min_num_tokens_per_message) {
    fbb_.AddElement<int32_t>(ActionsTokenFeatureProcessorOptions::VT_MIN_NUM_TOKENS_PER_MESSAGE, min_num_tokens_per_message, -1);
  }
  void add_max_num_total_tokens(int32_t max_num_total_tokens) {
    fbb_.AddElement<int32_t>(ActionsTokenFeatureProcessorOptions::VT_MAX_NUM_TOTAL_TOKENS, max_num_total_tokens, -1);
  }
  void add_min_num_total_tokens(int32_t min_num_total_tokens) {
    fbb_.AddElement<int32_t>(ActionsTokenFeatureProcessorOptions::VT_MIN_NUM_TOTAL_TOKENS, min_num_total_tokens, -1);
  }
  void add_padding_token_id(int32_t padding_token_id) {
    fbb_.AddElement<int32_t>(ActionsTokenFeatureProcessorOptions::VT_PADDING_TOKEN_ID, padding_token_id, 0);
  }
  void add_start_token_id(int32_t start_token_id) {
    fbb_.AddElement<int32_t>(ActionsTokenFeatureProcessorOptions::VT_START_TOKEN_ID, start_token_id, 1);
  }
  void add_end_token_id(int32_t end_token_id) {
    fbb_.AddElement<int32_t>(ActionsTokenFeatureProcessorOptions::VT_END_TOKEN_ID, end_token_id, 2);
  }
  explicit ActionsTokenFeatureProcessorOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ActionsTokenFeatureProcessorOptionsBuilder &operator=(const ActionsTokenFeatureProcessorOptionsBuilder &);
  flatbuffers::Offset<ActionsTokenFeatureProcessorOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ActionsTokenFeatureProcessorOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ActionsTokenFeatureProcessorOptions> CreateActionsTokenFeatureProcessorOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<libtextclassifier3::ActionsTokenizerOptions> tokenizer_options = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> embedding_model = 0,
    int32_t embedding_size = -1,
    int32_t embedding_quantization_bits = 8,
    int32_t num_buckets = -1,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> chargram_orders = 0,
    bool extract_case_feature = false,
    bool unicode_aware_features = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> regexp_features = 0,
    bool remap_digits = false,
    bool lowercase_tokens = false,
    int32_t max_token_length = 20,
    int32_t max_num_tokens_per_message = -1,
    int32_t min_num_tokens_per_message = -1,
    int32_t max_num_total_tokens = -1,
    int32_t min_num_total_tokens = -1,
    int32_t padding_token_id = 0,
    int32_t start_token_id = 1,
    int32_t end_token_id = 2) {
  ActionsTokenFeatureProcessorOptionsBuilder builder_(_fbb);
  builder_.add_end_token_id(end_token_id);
  builder_.add_start_token_id(start_token_id);
  builder_.add_padding_token_id(padding_token_id);
  builder_.add_min_num_total_tokens(min_num_total_tokens);
  builder_.add_max_num_total_tokens(max_num_total_tokens);
  builder_.add_min_num_tokens_per_message(min_num_tokens_per_message);
  builder_.add_max_num_tokens_per_message(max_num_tokens_per_message);
  builder_.add_max_token_length(max_token_length);
  builder_.add_regexp_features(regexp_features);
  builder_.add_chargram_orders(chargram_orders);
  builder_.add_num_buckets(num_buckets);
  builder_.add_embedding_quantization_bits(embedding_quantization_bits);
  builder_.add_embedding_size(embedding_size);
  builder_.add_embedding_model(embedding_model);
  builder_.add_tokenizer_options(tokenizer_options);
  builder_.add_lowercase_tokens(lowercase_tokens);
  builder_.add_remap_digits(remap_digits);
  builder_.add_unicode_aware_features(unicode_aware_features);
  builder_.add_extract_case_feature(extract_case_feature);
  return builder_.Finish();
}

inline flatbuffers::Offset<ActionsTokenFeatureProcessorOptions> CreateActionsTokenFeatureProcessorOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<libtextclassifier3::ActionsTokenizerOptions> tokenizer_options = 0,
    const std::vector<uint8_t> *embedding_model = nullptr,
    int32_t embedding_size = -1,
    int32_t embedding_quantization_bits = 8,
    int32_t num_buckets = -1,
    const std::vector<int32_t> *chargram_orders = nullptr,
    bool extract_case_feature = false,
    bool unicode_aware_features = false,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *regexp_features = nullptr,
    bool remap_digits = false,
    bool lowercase_tokens = false,
    int32_t max_token_length = 20,
    int32_t max_num_tokens_per_message = -1,
    int32_t min_num_tokens_per_message = -1,
    int32_t max_num_total_tokens = -1,
    int32_t min_num_total_tokens = -1,
    int32_t padding_token_id = 0,
    int32_t start_token_id = 1,
    int32_t end_token_id = 2) {
  if (embedding_model) { _fbb.ForceVectorAlignment(embedding_model->size(), sizeof(uint8_t), 16); }
  auto embedding_model__ = embedding_model ? _fbb.CreateVector<uint8_t>(*embedding_model) : 0;
  auto chargram_orders__ = chargram_orders ? _fbb.CreateVector<int32_t>(*chargram_orders) : 0;
  auto regexp_features__ = regexp_features ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*regexp_features) : 0;
  return libtextclassifier3::CreateActionsTokenFeatureProcessorOptions(
      _fbb,
      tokenizer_options,
      embedding_model__,
      embedding_size,
      embedding_quantization_bits,
      num_buckets,
      chargram_orders__,
      extract_case_feature,
      unicode_aware_features,
      regexp_features__,
      remap_digits,
      lowercase_tokens,
      max_token_length,
      max_num_tokens_per_message,
      min_num_tokens_per_message,
      max_num_total_tokens,
      min_num_total_tokens,
      padding_token_id,
      start_token_id,
      end_token_id);
}

flatbuffers::Offset<ActionsTokenFeatureProcessorOptions> CreateActionsTokenFeatureProcessorOptions(flatbuffers::FlatBufferBuilder &_fbb, const ActionsTokenFeatureProcessorOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NGramLinearRegressionModelT : public flatbuffers::NativeTable {
  typedef NGramLinearRegressionModel TableType;
  std::vector<uint32_t> hashed_ngram_tokens;
  std::vector<uint16_t> ngram_start_offsets;
  std::vector<float> ngram_weights;
  float default_token_weight;
  int32_t max_denom_ngram_length;
  int32_t max_skips;
  float threshold;
  std::unique_ptr<libtextclassifier3::ActionsTokenizerOptionsT> tokenizer_options;
  NGramLinearRegressionModelT()
      : default_token_weight(0.0f),
        max_denom_ngram_length(0),
        max_skips(0),
        threshold(0.0f) {
  }
};

struct NGramLinearRegressionModel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NGramLinearRegressionModelT NativeTableType;
  typedef NGramLinearRegressionModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HASHED_NGRAM_TOKENS = 4,
    VT_NGRAM_START_OFFSETS = 6,
    VT_NGRAM_WEIGHTS = 8,
    VT_DEFAULT_TOKEN_WEIGHT = 10,
    VT_MAX_DENOM_NGRAM_LENGTH = 12,
    VT_MAX_SKIPS = 14,
    VT_THRESHOLD = 16,
    VT_TOKENIZER_OPTIONS = 18
  };
  const flatbuffers::Vector<uint32_t> *hashed_ngram_tokens() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_HASHED_NGRAM_TOKENS);
  }
  const flatbuffers::Vector<uint16_t> *ngram_start_offsets() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_NGRAM_START_OFFSETS);
  }
  const flatbuffers::Vector<float> *ngram_weights() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_NGRAM_WEIGHTS);
  }
  float default_token_weight() const {
    return GetField<float>(VT_DEFAULT_TOKEN_WEIGHT, 0.0f);
  }
  int32_t max_denom_ngram_length() const {
    return GetField<int32_t>(VT_MAX_DENOM_NGRAM_LENGTH, 0);
  }
  int32_t max_skips() const {
    return GetField<int32_t>(VT_MAX_SKIPS, 0);
  }
  float threshold() const {
    return GetField<float>(VT_THRESHOLD, 0.0f);
  }
  const libtextclassifier3::ActionsTokenizerOptions *tokenizer_options() const {
    return GetPointer<const libtextclassifier3::ActionsTokenizerOptions *>(VT_TOKENIZER_OPTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HASHED_NGRAM_TOKENS) &&
           verifier.VerifyVector(hashed_ngram_tokens()) &&
           VerifyOffset(verifier, VT_NGRAM_START_OFFSETS) &&
           verifier.VerifyVector(ngram_start_offsets()) &&
           VerifyOffset(verifier, VT_NGRAM_WEIGHTS) &&
           verifier.VerifyVector(ngram_weights()) &&
           VerifyField<float>(verifier, VT_DEFAULT_TOKEN_WEIGHT) &&
           VerifyField<int32_t>(verifier, VT_MAX_DENOM_NGRAM_LENGTH) &&
           VerifyField<int32_t>(verifier, VT_MAX_SKIPS) &&
           VerifyField<float>(verifier, VT_THRESHOLD) &&
           VerifyOffset(verifier, VT_TOKENIZER_OPTIONS) &&
           verifier.VerifyTable(tokenizer_options()) &&
           verifier.EndTable();
  }
  NGramLinearRegressionModelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NGramLinearRegressionModelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NGramLinearRegressionModel> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NGramLinearRegressionModelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NGramLinearRegressionModelBuilder {
  typedef NGramLinearRegressionModel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hashed_ngram_tokens(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> hashed_ngram_tokens) {
    fbb_.AddOffset(NGramLinearRegressionModel::VT_HASHED_NGRAM_TOKENS, hashed_ngram_tokens);
  }
  void add_ngram_start_offsets(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> ngram_start_offsets) {
    fbb_.AddOffset(NGramLinearRegressionModel::VT_NGRAM_START_OFFSETS, ngram_start_offsets);
  }
  void add_ngram_weights(flatbuffers::Offset<flatbuffers::Vector<float>> ngram_weights) {
    fbb_.AddOffset(NGramLinearRegressionModel::VT_NGRAM_WEIGHTS, ngram_weights);
  }
  void add_default_token_weight(float default_token_weight) {
    fbb_.AddElement<float>(NGramLinearRegressionModel::VT_DEFAULT_TOKEN_WEIGHT, default_token_weight, 0.0f);
  }
  void add_max_denom_ngram_length(int32_t max_denom_ngram_length) {
    fbb_.AddElement<int32_t>(NGramLinearRegressionModel::VT_MAX_DENOM_NGRAM_LENGTH, max_denom_ngram_length, 0);
  }
  void add_max_skips(int32_t max_skips) {
    fbb_.AddElement<int32_t>(NGramLinearRegressionModel::VT_MAX_SKIPS, max_skips, 0);
  }
  void add_threshold(float threshold) {
    fbb_.AddElement<float>(NGramLinearRegressionModel::VT_THRESHOLD, threshold, 0.0f);
  }
  void add_tokenizer_options(flatbuffers::Offset<libtextclassifier3::ActionsTokenizerOptions> tokenizer_options) {
    fbb_.AddOffset(NGramLinearRegressionModel::VT_TOKENIZER_OPTIONS, tokenizer_options);
  }
  explicit NGramLinearRegressionModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NGramLinearRegressionModelBuilder &operator=(const NGramLinearRegressionModelBuilder &);
  flatbuffers::Offset<NGramLinearRegressionModel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NGramLinearRegressionModel>(end);
    return o;
  }
};

inline flatbuffers::Offset<NGramLinearRegressionModel> CreateNGramLinearRegressionModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> hashed_ngram_tokens = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> ngram_start_offsets = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> ngram_weights = 0,
    float default_token_weight = 0.0f,
    int32_t max_denom_ngram_length = 0,
    int32_t max_skips = 0,
    float threshold = 0.0f,
    flatbuffers::Offset<libtextclassifier3::ActionsTokenizerOptions> tokenizer_options = 0) {
  NGramLinearRegressionModelBuilder builder_(_fbb);
  builder_.add_tokenizer_options(tokenizer_options);
  builder_.add_threshold(threshold);
  builder_.add_max_skips(max_skips);
  builder_.add_max_denom_ngram_length(max_denom_ngram_length);
  builder_.add_default_token_weight(default_token_weight);
  builder_.add_ngram_weights(ngram_weights);
  builder_.add_ngram_start_offsets(ngram_start_offsets);
  builder_.add_hashed_ngram_tokens(hashed_ngram_tokens);
  return builder_.Finish();
}

inline flatbuffers::Offset<NGramLinearRegressionModel> CreateNGramLinearRegressionModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *hashed_ngram_tokens = nullptr,
    const std::vector<uint16_t> *ngram_start_offsets = nullptr,
    const std::vector<float> *ngram_weights = nullptr,
    float default_token_weight = 0.0f,
    int32_t max_denom_ngram_length = 0,
    int32_t max_skips = 0,
    float threshold = 0.0f,
    flatbuffers::Offset<libtextclassifier3::ActionsTokenizerOptions> tokenizer_options = 0) {
  auto hashed_ngram_tokens__ = hashed_ngram_tokens ? _fbb.CreateVector<uint32_t>(*hashed_ngram_tokens) : 0;
  auto ngram_start_offsets__ = ngram_start_offsets ? _fbb.CreateVector<uint16_t>(*ngram_start_offsets) : 0;
  auto ngram_weights__ = ngram_weights ? _fbb.CreateVector<float>(*ngram_weights) : 0;
  return libtextclassifier3::CreateNGramLinearRegressionModel(
      _fbb,
      hashed_ngram_tokens__,
      ngram_start_offsets__,
      ngram_weights__,
      default_token_weight,
      max_denom_ngram_length,
      max_skips,
      threshold,
      tokenizer_options);
}

flatbuffers::Offset<NGramLinearRegressionModel> CreateNGramLinearRegressionModel(flatbuffers::FlatBufferBuilder &_fbb, const NGramLinearRegressionModelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TFLiteSensitiveClassifierConfigT : public flatbuffers::NativeTable {
  typedef TFLiteSensitiveClassifierConfig TableType;
  std::unique_ptr<libtextclassifier3::TensorflowLiteModelSpecT> model_spec;
  float threshold;
  TFLiteSensitiveClassifierConfigT()
      : threshold(0.0f) {
  }
};

struct TFLiteSensitiveClassifierConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TFLiteSensitiveClassifierConfigT NativeTableType;
  typedef TFLiteSensitiveClassifierConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODEL_SPEC = 4,
    VT_THRESHOLD = 6
  };
  const libtextclassifier3::TensorflowLiteModelSpec *model_spec() const {
    return GetPointer<const libtextclassifier3::TensorflowLiteModelSpec *>(VT_MODEL_SPEC);
  }
  float threshold() const {
    return GetField<float>(VT_THRESHOLD, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MODEL_SPEC) &&
           verifier.VerifyTable(model_spec()) &&
           VerifyField<float>(verifier, VT_THRESHOLD) &&
           verifier.EndTable();
  }
  TFLiteSensitiveClassifierConfigT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TFLiteSensitiveClassifierConfigT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TFLiteSensitiveClassifierConfig> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TFLiteSensitiveClassifierConfigT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TFLiteSensitiveClassifierConfigBuilder {
  typedef TFLiteSensitiveClassifierConfig Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_model_spec(flatbuffers::Offset<libtextclassifier3::TensorflowLiteModelSpec> model_spec) {
    fbb_.AddOffset(TFLiteSensitiveClassifierConfig::VT_MODEL_SPEC, model_spec);
  }
  void add_threshold(float threshold) {
    fbb_.AddElement<float>(TFLiteSensitiveClassifierConfig::VT_THRESHOLD, threshold, 0.0f);
  }
  explicit TFLiteSensitiveClassifierConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TFLiteSensitiveClassifierConfigBuilder &operator=(const TFLiteSensitiveClassifierConfigBuilder &);
  flatbuffers::Offset<TFLiteSensitiveClassifierConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TFLiteSensitiveClassifierConfig>(end);
    return o;
  }
};

inline flatbuffers::Offset<TFLiteSensitiveClassifierConfig> CreateTFLiteSensitiveClassifierConfig(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<libtextclassifier3::TensorflowLiteModelSpec> model_spec = 0,
    float threshold = 0.0f) {
  TFLiteSensitiveClassifierConfigBuilder builder_(_fbb);
  builder_.add_threshold(threshold);
  builder_.add_model_spec(model_spec);
  return builder_.Finish();
}

flatbuffers::Offset<TFLiteSensitiveClassifierConfig> CreateTFLiteSensitiveClassifierConfig(flatbuffers::FlatBufferBuilder &_fbb, const TFLiteSensitiveClassifierConfigT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TriggeringPreconditionsT : public flatbuffers::NativeTable {
  typedef TriggeringPreconditions TableType;
  float min_smart_reply_triggering_score;
  float max_sensitive_topic_score;
  bool suppress_on_sensitive_topic;
  int32_t min_input_length;
  int32_t max_input_length;
  float min_locale_match_fraction;
  bool handle_missing_locale_as_supported;
  bool handle_unknown_locale_as_supported;
  bool suppress_on_low_confidence_input;
  std::unique_ptr<libtextclassifier3::RulesModelT> low_confidence_rules;
  float min_reply_score_threshold;
  TriggeringPreconditionsT()
      : min_smart_reply_triggering_score(0.0f),
        max_sensitive_topic_score(1.0f),
        suppress_on_sensitive_topic(true),
        min_input_length(0),
        max_input_length(-1),
        min_locale_match_fraction(0.75f),
        handle_missing_locale_as_supported(false),
        handle_unknown_locale_as_supported(false),
        suppress_on_low_confidence_input(true),
        min_reply_score_threshold(0.0f) {
  }
};

struct TriggeringPreconditions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TriggeringPreconditionsT NativeTableType;
  typedef TriggeringPreconditionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN_SMART_REPLY_TRIGGERING_SCORE = 4,
    VT_MAX_SENSITIVE_TOPIC_SCORE = 6,
    VT_SUPPRESS_ON_SENSITIVE_TOPIC = 8,
    VT_MIN_INPUT_LENGTH = 10,
    VT_MAX_INPUT_LENGTH = 12,
    VT_MIN_LOCALE_MATCH_FRACTION = 14,
    VT_HANDLE_MISSING_LOCALE_AS_SUPPORTED = 16,
    VT_HANDLE_UNKNOWN_LOCALE_AS_SUPPORTED = 18,
    VT_SUPPRESS_ON_LOW_CONFIDENCE_INPUT = 20,
    VT_LOW_CONFIDENCE_RULES = 22,
    VT_MIN_REPLY_SCORE_THRESHOLD = 30
  };
  float min_smart_reply_triggering_score() const {
    return GetField<float>(VT_MIN_SMART_REPLY_TRIGGERING_SCORE, 0.0f);
  }
  float max_sensitive_topic_score() const {
    return GetField<float>(VT_MAX_SENSITIVE_TOPIC_SCORE, 1.0f);
  }
  bool suppress_on_sensitive_topic() const {
    return GetField<uint8_t>(VT_SUPPRESS_ON_SENSITIVE_TOPIC, 1) != 0;
  }
  int32_t min_input_length() const {
    return GetField<int32_t>(VT_MIN_INPUT_LENGTH, 0);
  }
  int32_t max_input_length() const {
    return GetField<int32_t>(VT_MAX_INPUT_LENGTH, -1);
  }
  float min_locale_match_fraction() const {
    return GetField<float>(VT_MIN_LOCALE_MATCH_FRACTION, 0.75f);
  }
  bool handle_missing_locale_as_supported() const {
    return GetField<uint8_t>(VT_HANDLE_MISSING_LOCALE_AS_SUPPORTED, 0) != 0;
  }
  bool handle_unknown_locale_as_supported() const {
    return GetField<uint8_t>(VT_HANDLE_UNKNOWN_LOCALE_AS_SUPPORTED, 0) != 0;
  }
  bool suppress_on_low_confidence_input() const {
    return GetField<uint8_t>(VT_SUPPRESS_ON_LOW_CONFIDENCE_INPUT, 1) != 0;
  }
  const libtextclassifier3::RulesModel *low_confidence_rules() const {
    return GetPointer<const libtextclassifier3::RulesModel *>(VT_LOW_CONFIDENCE_RULES);
  }
  float min_reply_score_threshold() const {
    return GetField<float>(VT_MIN_REPLY_SCORE_THRESHOLD, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MIN_SMART_REPLY_TRIGGERING_SCORE) &&
           VerifyField<float>(verifier, VT_MAX_SENSITIVE_TOPIC_SCORE) &&
           VerifyField<uint8_t>(verifier, VT_SUPPRESS_ON_SENSITIVE_TOPIC) &&
           VerifyField<int32_t>(verifier, VT_MIN_INPUT_LENGTH) &&
           VerifyField<int32_t>(verifier, VT_MAX_INPUT_LENGTH) &&
           VerifyField<float>(verifier, VT_MIN_LOCALE_MATCH_FRACTION) &&
           VerifyField<uint8_t>(verifier, VT_HANDLE_MISSING_LOCALE_AS_SUPPORTED) &&
           VerifyField<uint8_t>(verifier, VT_HANDLE_UNKNOWN_LOCALE_AS_SUPPORTED) &&
           VerifyField<uint8_t>(verifier, VT_SUPPRESS_ON_LOW_CONFIDENCE_INPUT) &&
           VerifyOffset(verifier, VT_LOW_CONFIDENCE_RULES) &&
           verifier.VerifyTable(low_confidence_rules()) &&
           VerifyField<float>(verifier, VT_MIN_REPLY_SCORE_THRESHOLD) &&
           verifier.EndTable();
  }
  TriggeringPreconditionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TriggeringPreconditionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TriggeringPreconditions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TriggeringPreconditionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TriggeringPreconditionsBuilder {
  typedef TriggeringPreconditions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min_smart_reply_triggering_score(float min_smart_reply_triggering_score) {
    fbb_.AddElement<float>(TriggeringPreconditions::VT_MIN_SMART_REPLY_TRIGGERING_SCORE, min_smart_reply_triggering_score, 0.0f);
  }
  void add_max_sensitive_topic_score(float max_sensitive_topic_score) {
    fbb_.AddElement<float>(TriggeringPreconditions::VT_MAX_SENSITIVE_TOPIC_SCORE, max_sensitive_topic_score, 1.0f);
  }
  void add_suppress_on_sensitive_topic(bool suppress_on_sensitive_topic) {
    fbb_.AddElement<uint8_t>(TriggeringPreconditions::VT_SUPPRESS_ON_SENSITIVE_TOPIC, static_cast<uint8_t>(suppress_on_sensitive_topic), 1);
  }
  void add_min_input_length(int32_t min_input_length) {
    fbb_.AddElement<int32_t>(TriggeringPreconditions::VT_MIN_INPUT_LENGTH, min_input_length, 0);
  }
  void add_max_input_length(int32_t max_input_length) {
    fbb_.AddElement<int32_t>(TriggeringPreconditions::VT_MAX_INPUT_LENGTH, max_input_length, -1);
  }
  void add_min_locale_match_fraction(float min_locale_match_fraction) {
    fbb_.AddElement<float>(TriggeringPreconditions::VT_MIN_LOCALE_MATCH_FRACTION, min_locale_match_fraction, 0.75f);
  }
  void add_handle_missing_locale_as_supported(bool handle_missing_locale_as_supported) {
    fbb_.AddElement<uint8_t>(TriggeringPreconditions::VT_HANDLE_MISSING_LOCALE_AS_SUPPORTED, static_cast<uint8_t>(handle_missing_locale_as_supported), 0);
  }
  void add_handle_unknown_locale_as_supported(bool handle_unknown_locale_as_supported) {
    fbb_.AddElement<uint8_t>(TriggeringPreconditions::VT_HANDLE_UNKNOWN_LOCALE_AS_SUPPORTED, static_cast<uint8_t>(handle_unknown_locale_as_supported), 0);
  }
  void add_suppress_on_low_confidence_input(bool suppress_on_low_confidence_input) {
    fbb_.AddElement<uint8_t>(TriggeringPreconditions::VT_SUPPRESS_ON_LOW_CONFIDENCE_INPUT, static_cast<uint8_t>(suppress_on_low_confidence_input), 1);
  }
  void add_low_confidence_rules(flatbuffers::Offset<libtextclassifier3::RulesModel> low_confidence_rules) {
    fbb_.AddOffset(TriggeringPreconditions::VT_LOW_CONFIDENCE_RULES, low_confidence_rules);
  }
  void add_min_reply_score_threshold(float min_reply_score_threshold) {
    fbb_.AddElement<float>(TriggeringPreconditions::VT_MIN_REPLY_SCORE_THRESHOLD, min_reply_score_threshold, 0.0f);
  }
  explicit TriggeringPreconditionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TriggeringPreconditionsBuilder &operator=(const TriggeringPreconditionsBuilder &);
  flatbuffers::Offset<TriggeringPreconditions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TriggeringPreconditions>(end);
    return o;
  }
};

inline flatbuffers::Offset<TriggeringPreconditions> CreateTriggeringPreconditions(
    flatbuffers::FlatBufferBuilder &_fbb,
    float min_smart_reply_triggering_score = 0.0f,
    float max_sensitive_topic_score = 1.0f,
    bool suppress_on_sensitive_topic = true,
    int32_t min_input_length = 0,
    int32_t max_input_length = -1,
    float min_locale_match_fraction = 0.75f,
    bool handle_missing_locale_as_supported = false,
    bool handle_unknown_locale_as_supported = false,
    bool suppress_on_low_confidence_input = true,
    flatbuffers::Offset<libtextclassifier3::RulesModel> low_confidence_rules = 0,
    float min_reply_score_threshold = 0.0f) {
  TriggeringPreconditionsBuilder builder_(_fbb);
  builder_.add_min_reply_score_threshold(min_reply_score_threshold);
  builder_.add_low_confidence_rules(low_confidence_rules);
  builder_.add_min_locale_match_fraction(min_locale_match_fraction);
  builder_.add_max_input_length(max_input_length);
  builder_.add_min_input_length(min_input_length);
  builder_.add_max_sensitive_topic_score(max_sensitive_topic_score);
  builder_.add_min_smart_reply_triggering_score(min_smart_reply_triggering_score);
  builder_.add_suppress_on_low_confidence_input(suppress_on_low_confidence_input);
  builder_.add_handle_unknown_locale_as_supported(handle_unknown_locale_as_supported);
  builder_.add_handle_missing_locale_as_supported(handle_missing_locale_as_supported);
  builder_.add_suppress_on_sensitive_topic(suppress_on_sensitive_topic);
  return builder_.Finish();
}

flatbuffers::Offset<TriggeringPreconditions> CreateTriggeringPreconditions(flatbuffers::FlatBufferBuilder &_fbb, const TriggeringPreconditionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ActionSuggestionSpecT : public flatbuffers::NativeTable {
  typedef ActionSuggestionSpec TableType;
  std::string type;
  std::string response_text;
  float score;
  std::string serialized_entity_data;
  float priority_score;
  std::unique_ptr<libtextclassifier3::ActionsEntityDataT> entity_data;
  ActionSuggestionSpecT()
      : score(0.0f),
        priority_score(0.0f) {
  }
};

struct ActionSuggestionSpec FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActionSuggestionSpecT NativeTableType;
  typedef ActionSuggestionSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_RESPONSE_TEXT = 6,
    VT_SCORE = 8,
    VT_SERIALIZED_ENTITY_DATA = 10,
    VT_PRIORITY_SCORE = 12,
    VT_ENTITY_DATA = 14
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::String *response_text() const {
    return GetPointer<const flatbuffers::String *>(VT_RESPONSE_TEXT);
  }
  float score() const {
    return GetField<float>(VT_SCORE, 0.0f);
  }
  const flatbuffers::String *serialized_entity_data() const {
    return GetPointer<const flatbuffers::String *>(VT_SERIALIZED_ENTITY_DATA);
  }
  float priority_score() const {
    return GetField<float>(VT_PRIORITY_SCORE, 0.0f);
  }
  const libtextclassifier3::ActionsEntityData *entity_data() const {
    return GetPointer<const libtextclassifier3::ActionsEntityData *>(VT_ENTITY_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_RESPONSE_TEXT) &&
           verifier.VerifyString(response_text()) &&
           VerifyField<float>(verifier, VT_SCORE) &&
           VerifyOffset(verifier, VT_SERIALIZED_ENTITY_DATA) &&
           verifier.VerifyString(serialized_entity_data()) &&
           VerifyField<float>(verifier, VT_PRIORITY_SCORE) &&
           VerifyOffset(verifier, VT_ENTITY_DATA) &&
           verifier.VerifyTable(entity_data()) &&
           verifier.EndTable();
  }
  ActionSuggestionSpecT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ActionSuggestionSpecT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ActionSuggestionSpec> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActionSuggestionSpecT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ActionSuggestionSpecBuilder {
  typedef ActionSuggestionSpec Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(ActionSuggestionSpec::VT_TYPE, type);
  }
  void add_response_text(flatbuffers::Offset<flatbuffers::String> response_text) {
    fbb_.AddOffset(ActionSuggestionSpec::VT_RESPONSE_TEXT, response_text);
  }
  void add_score(float score) {
    fbb_.AddElement<float>(ActionSuggestionSpec::VT_SCORE, score, 0.0f);
  }
  void add_serialized_entity_data(flatbuffers::Offset<flatbuffers::String> serialized_entity_data) {
    fbb_.AddOffset(ActionSuggestionSpec::VT_SERIALIZED_ENTITY_DATA, serialized_entity_data);
  }
  void add_priority_score(float priority_score) {
    fbb_.AddElement<float>(ActionSuggestionSpec::VT_PRIORITY_SCORE, priority_score, 0.0f);
  }
  void add_entity_data(flatbuffers::Offset<libtextclassifier3::ActionsEntityData> entity_data) {
    fbb_.AddOffset(ActionSuggestionSpec::VT_ENTITY_DATA, entity_data);
  }
  explicit ActionSuggestionSpecBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ActionSuggestionSpecBuilder &operator=(const ActionSuggestionSpecBuilder &);
  flatbuffers::Offset<ActionSuggestionSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ActionSuggestionSpec>(end);
    return o;
  }
};

inline flatbuffers::Offset<ActionSuggestionSpec> CreateActionSuggestionSpec(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::String> response_text = 0,
    float score = 0.0f,
    flatbuffers::Offset<flatbuffers::String> serialized_entity_data = 0,
    float priority_score = 0.0f,
    flatbuffers::Offset<libtextclassifier3::ActionsEntityData> entity_data = 0) {
  ActionSuggestionSpecBuilder builder_(_fbb);
  builder_.add_entity_data(entity_data);
  builder_.add_priority_score(priority_score);
  builder_.add_serialized_entity_data(serialized_entity_data);
  builder_.add_score(score);
  builder_.add_response_text(response_text);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ActionSuggestionSpec> CreateActionSuggestionSpecDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *response_text = nullptr,
    float score = 0.0f,
    const char *serialized_entity_data = nullptr,
    float priority_score = 0.0f,
    flatbuffers::Offset<libtextclassifier3::ActionsEntityData> entity_data = 0) {
  auto type__ = type ? _fbb.CreateSharedString(type) : 0;
  auto response_text__ = response_text ? _fbb.CreateSharedString(response_text) : 0;
  auto serialized_entity_data__ = serialized_entity_data ? _fbb.CreateSharedString(serialized_entity_data) : 0;
  return libtextclassifier3::CreateActionSuggestionSpec(
      _fbb,
      type__,
      response_text__,
      score,
      serialized_entity_data__,
      priority_score,
      entity_data);
}

flatbuffers::Offset<ActionSuggestionSpec> CreateActionSuggestionSpec(flatbuffers::FlatBufferBuilder &_fbb, const ActionSuggestionSpecT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ActionTypeOptionsT : public flatbuffers::NativeTable {
  typedef ActionTypeOptions TableType;
  std::string name;
  bool enabled;
  float min_triggering_score;
  std::unique_ptr<libtextclassifier3::ActionSuggestionSpecT> action;
  ActionTypeOptionsT()
      : enabled(true),
        min_triggering_score(0.0f) {
  }
};

struct ActionTypeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActionTypeOptionsT NativeTableType;
  typedef ActionTypeOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_ENABLED = 6,
    VT_MIN_TRIGGERING_SCORE = 8,
    VT_ACTION = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 1) != 0;
  }
  float min_triggering_score() const {
    return GetField<float>(VT_MIN_TRIGGERING_SCORE, 0.0f);
  }
  const libtextclassifier3::ActionSuggestionSpec *action() const {
    return GetPointer<const libtextclassifier3::ActionSuggestionSpec *>(VT_ACTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED) &&
           VerifyField<float>(verifier, VT_MIN_TRIGGERING_SCORE) &&
           VerifyOffset(verifier, VT_ACTION) &&
           verifier.VerifyTable(action()) &&
           verifier.EndTable();
  }
  ActionTypeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ActionTypeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ActionTypeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActionTypeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ActionTypeOptionsBuilder {
  typedef ActionTypeOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ActionTypeOptions::VT_NAME, name);
  }
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(ActionTypeOptions::VT_ENABLED, static_cast<uint8_t>(enabled), 1);
  }
  void add_min_triggering_score(float min_triggering_score) {
    fbb_.AddElement<float>(ActionTypeOptions::VT_MIN_TRIGGERING_SCORE, min_triggering_score, 0.0f);
  }
  void add_action(flatbuffers::Offset<libtextclassifier3::ActionSuggestionSpec> action) {
    fbb_.AddOffset(ActionTypeOptions::VT_ACTION, action);
  }
  explicit ActionTypeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ActionTypeOptionsBuilder &operator=(const ActionTypeOptionsBuilder &);
  flatbuffers::Offset<ActionTypeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ActionTypeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ActionTypeOptions> CreateActionTypeOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    bool enabled = true,
    float min_triggering_score = 0.0f,
    flatbuffers::Offset<libtextclassifier3::ActionSuggestionSpec> action = 0) {
  ActionTypeOptionsBuilder builder_(_fbb);
  builder_.add_action(action);
  builder_.add_min_triggering_score(min_triggering_score);
  builder_.add_name(name);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

inline flatbuffers::Offset<ActionTypeOptions> CreateActionTypeOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    bool enabled = true,
    float min_triggering_score = 0.0f,
    flatbuffers::Offset<libtextclassifier3::ActionSuggestionSpec> action = 0) {
  auto name__ = name ? _fbb.CreateSharedString(name) : 0;
  return libtextclassifier3::CreateActionTypeOptions(
      _fbb,
      name__,
      enabled,
      min_triggering_score,
      action);
}

flatbuffers::Offset<ActionTypeOptions> CreateActionTypeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ActionTypeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace AnnotationActionsSpec_ {

struct AnnotationMappingT : public flatbuffers::NativeTable {
  typedef AnnotationMapping TableType;
  std::string annotation_collection;
  std::unique_ptr<libtextclassifier3::ActionSuggestionSpecT> action;
  bool use_annotation_score;
  float min_annotation_score;
  std::unique_ptr<libtextclassifier3::FlatbufferFieldPathT> entity_field;
  std::unique_ptr<libtextclassifier3::NormalizationOptionsT> normalization_options;
  AnnotationMappingT()
      : use_annotation_score(true),
        min_annotation_score(0.0f) {
  }
};

struct AnnotationMapping FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnnotationMappingT NativeTableType;
  typedef AnnotationMappingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANNOTATION_COLLECTION = 4,
    VT_ACTION = 6,
    VT_USE_ANNOTATION_SCORE = 8,
    VT_MIN_ANNOTATION_SCORE = 10,
    VT_ENTITY_FIELD = 12,
    VT_NORMALIZATION_OPTIONS = 14
  };
  const flatbuffers::String *annotation_collection() const {
    return GetPointer<const flatbuffers::String *>(VT_ANNOTATION_COLLECTION);
  }
  const libtextclassifier3::ActionSuggestionSpec *action() const {
    return GetPointer<const libtextclassifier3::ActionSuggestionSpec *>(VT_ACTION);
  }
  bool use_annotation_score() const {
    return GetField<uint8_t>(VT_USE_ANNOTATION_SCORE, 1) != 0;
  }
  float min_annotation_score() const {
    return GetField<float>(VT_MIN_ANNOTATION_SCORE, 0.0f);
  }
  const libtextclassifier3::FlatbufferFieldPath *entity_field() const {
    return GetPointer<const libtextclassifier3::FlatbufferFieldPath *>(VT_ENTITY_FIELD);
  }
  const libtextclassifier3::NormalizationOptions *normalization_options() const {
    return GetPointer<const libtextclassifier3::NormalizationOptions *>(VT_NORMALIZATION_OPTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ANNOTATION_COLLECTION) &&
           verifier.VerifyString(annotation_collection()) &&
           VerifyOffset(verifier, VT_ACTION) &&
           verifier.VerifyTable(action()) &&
           VerifyField<uint8_t>(verifier, VT_USE_ANNOTATION_SCORE) &&
           VerifyField<float>(verifier, VT_MIN_ANNOTATION_SCORE) &&
           VerifyOffset(verifier, VT_ENTITY_FIELD) &&
           verifier.VerifyTable(entity_field()) &&
           VerifyOffset(verifier, VT_NORMALIZATION_OPTIONS) &&
           verifier.VerifyTable(normalization_options()) &&
           verifier.EndTable();
  }
  AnnotationMappingT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AnnotationMappingT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AnnotationMapping> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnnotationMappingT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AnnotationMappingBuilder {
  typedef AnnotationMapping Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_annotation_collection(flatbuffers::Offset<flatbuffers::String> annotation_collection) {
    fbb_.AddOffset(AnnotationMapping::VT_ANNOTATION_COLLECTION, annotation_collection);
  }
  void add_action(flatbuffers::Offset<libtextclassifier3::ActionSuggestionSpec> action) {
    fbb_.AddOffset(AnnotationMapping::VT_ACTION, action);
  }
  void add_use_annotation_score(bool use_annotation_score) {
    fbb_.AddElement<uint8_t>(AnnotationMapping::VT_USE_ANNOTATION_SCORE, static_cast<uint8_t>(use_annotation_score), 1);
  }
  void add_min_annotation_score(float min_annotation_score) {
    fbb_.AddElement<float>(AnnotationMapping::VT_MIN_ANNOTATION_SCORE, min_annotation_score, 0.0f);
  }
  void add_entity_field(flatbuffers::Offset<libtextclassifier3::FlatbufferFieldPath> entity_field) {
    fbb_.AddOffset(AnnotationMapping::VT_ENTITY_FIELD, entity_field);
  }
  void add_normalization_options(flatbuffers::Offset<libtextclassifier3::NormalizationOptions> normalization_options) {
    fbb_.AddOffset(AnnotationMapping::VT_NORMALIZATION_OPTIONS, normalization_options);
  }
  explicit AnnotationMappingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnnotationMappingBuilder &operator=(const AnnotationMappingBuilder &);
  flatbuffers::Offset<AnnotationMapping> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnnotationMapping>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnnotationMapping> CreateAnnotationMapping(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> annotation_collection = 0,
    flatbuffers::Offset<libtextclassifier3::ActionSuggestionSpec> action = 0,
    bool use_annotation_score = true,
    float min_annotation_score = 0.0f,
    flatbuffers::Offset<libtextclassifier3::FlatbufferFieldPath> entity_field = 0,
    flatbuffers::Offset<libtextclassifier3::NormalizationOptions> normalization_options = 0) {
  AnnotationMappingBuilder builder_(_fbb);
  builder_.add_normalization_options(normalization_options);
  builder_.add_entity_field(entity_field);
  builder_.add_min_annotation_score(min_annotation_score);
  builder_.add_action(action);
  builder_.add_annotation_collection(annotation_collection);
  builder_.add_use_annotation_score(use_annotation_score);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnnotationMapping> CreateAnnotationMappingDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *annotation_collection = nullptr,
    flatbuffers::Offset<libtextclassifier3::ActionSuggestionSpec> action = 0,
    bool use_annotation_score = true,
    float min_annotation_score = 0.0f,
    flatbuffers::Offset<libtextclassifier3::FlatbufferFieldPath> entity_field = 0,
    flatbuffers::Offset<libtextclassifier3::NormalizationOptions> normalization_options = 0) {
  auto annotation_collection__ = annotation_collection ? _fbb.CreateSharedString(annotation_collection) : 0;
  return libtextclassifier3::AnnotationActionsSpec_::CreateAnnotationMapping(
      _fbb,
      annotation_collection__,
      action,
      use_annotation_score,
      min_annotation_score,
      entity_field,
      normalization_options);
}

flatbuffers::Offset<AnnotationMapping> CreateAnnotationMapping(flatbuffers::FlatBufferBuilder &_fbb, const AnnotationMappingT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace AnnotationActionsSpec_

struct AnnotationActionsSpecT : public flatbuffers::NativeTable {
  typedef AnnotationActionsSpec TableType;
  std::vector<std::unique_ptr<libtextclassifier3::AnnotationActionsSpec_::AnnotationMappingT>> annotation_mapping;
  bool deduplicate_annotations;
  libtextclassifier3::AnnotationUsecase annotation_usecase;
  int32_t max_history_from_any_person;
  int32_t max_history_from_last_person;
  bool include_local_user_messages;
  bool only_until_last_sent;
  bool is_serialized_entity_data_enabled;
  AnnotationActionsSpecT()
      : deduplicate_annotations(true),
        annotation_usecase(libtextclassifier3::AnnotationUsecase_ANNOTATION_USECASE_SMART),
        max_history_from_any_person(1),
        max_history_from_last_person(1),
        include_local_user_messages(false),
        only_until_last_sent(true),
        is_serialized_entity_data_enabled(true) {
  }
};

struct AnnotationActionsSpec FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnnotationActionsSpecT NativeTableType;
  typedef AnnotationActionsSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANNOTATION_MAPPING = 4,
    VT_DEDUPLICATE_ANNOTATIONS = 6,
    VT_ANNOTATION_USECASE = 8,
    VT_MAX_HISTORY_FROM_ANY_PERSON = 10,
    VT_MAX_HISTORY_FROM_LAST_PERSON = 12,
    VT_INCLUDE_LOCAL_USER_MESSAGES = 14,
    VT_ONLY_UNTIL_LAST_SENT = 16,
    VT_IS_SERIALIZED_ENTITY_DATA_ENABLED = 18
  };
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::AnnotationActionsSpec_::AnnotationMapping>> *annotation_mapping() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::AnnotationActionsSpec_::AnnotationMapping>> *>(VT_ANNOTATION_MAPPING);
  }
  bool deduplicate_annotations() const {
    return GetField<uint8_t>(VT_DEDUPLICATE_ANNOTATIONS, 1) != 0;
  }
  libtextclassifier3::AnnotationUsecase annotation_usecase() const {
    return static_cast<libtextclassifier3::AnnotationUsecase>(GetField<int32_t>(VT_ANNOTATION_USECASE, 0));
  }
  int32_t max_history_from_any_person() const {
    return GetField<int32_t>(VT_MAX_HISTORY_FROM_ANY_PERSON, 1);
  }
  int32_t max_history_from_last_person() const {
    return GetField<int32_t>(VT_MAX_HISTORY_FROM_LAST_PERSON, 1);
  }
  bool include_local_user_messages() const {
    return GetField<uint8_t>(VT_INCLUDE_LOCAL_USER_MESSAGES, 0) != 0;
  }
  bool only_until_last_sent() const {
    return GetField<uint8_t>(VT_ONLY_UNTIL_LAST_SENT, 1) != 0;
  }
  bool is_serialized_entity_data_enabled() const {
    return GetField<uint8_t>(VT_IS_SERIALIZED_ENTITY_DATA_ENABLED, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ANNOTATION_MAPPING) &&
           verifier.VerifyVector(annotation_mapping()) &&
           verifier.VerifyVectorOfTables(annotation_mapping()) &&
           VerifyField<uint8_t>(verifier, VT_DEDUPLICATE_ANNOTATIONS) &&
           VerifyField<int32_t>(verifier, VT_ANNOTATION_USECASE) &&
           VerifyField<int32_t>(verifier, VT_MAX_HISTORY_FROM_ANY_PERSON) &&
           VerifyField<int32_t>(verifier, VT_MAX_HISTORY_FROM_LAST_PERSON) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_LOCAL_USER_MESSAGES) &&
           VerifyField<uint8_t>(verifier, VT_ONLY_UNTIL_LAST_SENT) &&
           VerifyField<uint8_t>(verifier, VT_IS_SERIALIZED_ENTITY_DATA_ENABLED) &&
           verifier.EndTable();
  }
  AnnotationActionsSpecT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AnnotationActionsSpecT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AnnotationActionsSpec> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnnotationActionsSpecT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AnnotationActionsSpecBuilder {
  typedef AnnotationActionsSpec Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_annotation_mapping(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::AnnotationActionsSpec_::AnnotationMapping>>> annotation_mapping) {
    fbb_.AddOffset(AnnotationActionsSpec::VT_ANNOTATION_MAPPING, annotation_mapping);
  }
  void add_deduplicate_annotations(bool deduplicate_annotations) {
    fbb_.AddElement<uint8_t>(AnnotationActionsSpec::VT_DEDUPLICATE_ANNOTATIONS, static_cast<uint8_t>(deduplicate_annotations), 1);
  }
  void add_annotation_usecase(libtextclassifier3::AnnotationUsecase annotation_usecase) {
    fbb_.AddElement<int32_t>(AnnotationActionsSpec::VT_ANNOTATION_USECASE, static_cast<int32_t>(annotation_usecase), 0);
  }
  void add_max_history_from_any_person(int32_t max_history_from_any_person) {
    fbb_.AddElement<int32_t>(AnnotationActionsSpec::VT_MAX_HISTORY_FROM_ANY_PERSON, max_history_from_any_person, 1);
  }
  void add_max_history_from_last_person(int32_t max_history_from_last_person) {
    fbb_.AddElement<int32_t>(AnnotationActionsSpec::VT_MAX_HISTORY_FROM_LAST_PERSON, max_history_from_last_person, 1);
  }
  void add_include_local_user_messages(bool include_local_user_messages) {
    fbb_.AddElement<uint8_t>(AnnotationActionsSpec::VT_INCLUDE_LOCAL_USER_MESSAGES, static_cast<uint8_t>(include_local_user_messages), 0);
  }
  void add_only_until_last_sent(bool only_until_last_sent) {
    fbb_.AddElement<uint8_t>(AnnotationActionsSpec::VT_ONLY_UNTIL_LAST_SENT, static_cast<uint8_t>(only_until_last_sent), 1);
  }
  void add_is_serialized_entity_data_enabled(bool is_serialized_entity_data_enabled) {
    fbb_.AddElement<uint8_t>(AnnotationActionsSpec::VT_IS_SERIALIZED_ENTITY_DATA_ENABLED, static_cast<uint8_t>(is_serialized_entity_data_enabled), 1);
  }
  explicit AnnotationActionsSpecBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnnotationActionsSpecBuilder &operator=(const AnnotationActionsSpecBuilder &);
  flatbuffers::Offset<AnnotationActionsSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnnotationActionsSpec>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnnotationActionsSpec> CreateAnnotationActionsSpec(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::AnnotationActionsSpec_::AnnotationMapping>>> annotation_mapping = 0,
    bool deduplicate_annotations = true,
    libtextclassifier3::AnnotationUsecase annotation_usecase = libtextclassifier3::AnnotationUsecase_ANNOTATION_USECASE_SMART,
    int32_t max_history_from_any_person = 1,
    int32_t max_history_from_last_person = 1,
    bool include_local_user_messages = false,
    bool only_until_last_sent = true,
    bool is_serialized_entity_data_enabled = true) {
  AnnotationActionsSpecBuilder builder_(_fbb);
  builder_.add_max_history_from_last_person(max_history_from_last_person);
  builder_.add_max_history_from_any_person(max_history_from_any_person);
  builder_.add_annotation_usecase(annotation_usecase);
  builder_.add_annotation_mapping(annotation_mapping);
  builder_.add_is_serialized_entity_data_enabled(is_serialized_entity_data_enabled);
  builder_.add_only_until_last_sent(only_until_last_sent);
  builder_.add_include_local_user_messages(include_local_user_messages);
  builder_.add_deduplicate_annotations(deduplicate_annotations);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnnotationActionsSpec> CreateAnnotationActionsSpecDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<libtextclassifier3::AnnotationActionsSpec_::AnnotationMapping>> *annotation_mapping = nullptr,
    bool deduplicate_annotations = true,
    libtextclassifier3::AnnotationUsecase annotation_usecase = libtextclassifier3::AnnotationUsecase_ANNOTATION_USECASE_SMART,
    int32_t max_history_from_any_person = 1,
    int32_t max_history_from_last_person = 1,
    bool include_local_user_messages = false,
    bool only_until_last_sent = true,
    bool is_serialized_entity_data_enabled = true) {
  auto annotation_mapping__ = annotation_mapping ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::AnnotationActionsSpec_::AnnotationMapping>>(*annotation_mapping) : 0;
  return libtextclassifier3::CreateAnnotationActionsSpec(
      _fbb,
      annotation_mapping__,
      deduplicate_annotations,
      annotation_usecase,
      max_history_from_any_person,
      max_history_from_last_person,
      include_local_user_messages,
      only_until_last_sent,
      is_serialized_entity_data_enabled);
}

flatbuffers::Offset<AnnotationActionsSpec> CreateAnnotationActionsSpec(flatbuffers::FlatBufferBuilder &_fbb, const AnnotationActionsSpecT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RankingOptionsT : public flatbuffers::NativeTable {
  typedef RankingOptions TableType;
  bool deduplicate_suggestions;
  bool deduplicate_suggestions_by_span;
  std::string lua_ranking_script;
  std::unique_ptr<libtextclassifier3::CompressedBufferT> compressed_lua_ranking_script;
  bool suppress_smart_replies_with_actions;
  bool group_by_annotations;
  RankingOptionsT()
      : deduplicate_suggestions(true),
        deduplicate_suggestions_by_span(true),
        suppress_smart_replies_with_actions(false),
        group_by_annotations(true) {
  }
};

struct RankingOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RankingOptionsT NativeTableType;
  typedef RankingOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEDUPLICATE_SUGGESTIONS = 4,
    VT_DEDUPLICATE_SUGGESTIONS_BY_SPAN = 6,
    VT_LUA_RANKING_SCRIPT = 8,
    VT_COMPRESSED_LUA_RANKING_SCRIPT = 10,
    VT_SUPPRESS_SMART_REPLIES_WITH_ACTIONS = 12,
    VT_GROUP_BY_ANNOTATIONS = 14
  };
  bool deduplicate_suggestions() const {
    return GetField<uint8_t>(VT_DEDUPLICATE_SUGGESTIONS, 1) != 0;
  }
  bool deduplicate_suggestions_by_span() const {
    return GetField<uint8_t>(VT_DEDUPLICATE_SUGGESTIONS_BY_SPAN, 1) != 0;
  }
  const flatbuffers::String *lua_ranking_script() const {
    return GetPointer<const flatbuffers::String *>(VT_LUA_RANKING_SCRIPT);
  }
  const libtextclassifier3::CompressedBuffer *compressed_lua_ranking_script() const {
    return GetPointer<const libtextclassifier3::CompressedBuffer *>(VT_COMPRESSED_LUA_RANKING_SCRIPT);
  }
  bool suppress_smart_replies_with_actions() const {
    return GetField<uint8_t>(VT_SUPPRESS_SMART_REPLIES_WITH_ACTIONS, 0) != 0;
  }
  bool group_by_annotations() const {
    return GetField<uint8_t>(VT_GROUP_BY_ANNOTATIONS, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DEDUPLICATE_SUGGESTIONS) &&
           VerifyField<uint8_t>(verifier, VT_DEDUPLICATE_SUGGESTIONS_BY_SPAN) &&
           VerifyOffset(verifier, VT_LUA_RANKING_SCRIPT) &&
           verifier.VerifyString(lua_ranking_script()) &&
           VerifyOffset(verifier, VT_COMPRESSED_LUA_RANKING_SCRIPT) &&
           verifier.VerifyTable(compressed_lua_ranking_script()) &&
           VerifyField<uint8_t>(verifier, VT_SUPPRESS_SMART_REPLIES_WITH_ACTIONS) &&
           VerifyField<uint8_t>(verifier, VT_GROUP_BY_ANNOTATIONS) &&
           verifier.EndTable();
  }
  RankingOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RankingOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RankingOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RankingOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RankingOptionsBuilder {
  typedef RankingOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_deduplicate_suggestions(bool deduplicate_suggestions) {
    fbb_.AddElement<uint8_t>(RankingOptions::VT_DEDUPLICATE_SUGGESTIONS, static_cast<uint8_t>(deduplicate_suggestions), 1);
  }
  void add_deduplicate_suggestions_by_span(bool deduplicate_suggestions_by_span) {
    fbb_.AddElement<uint8_t>(RankingOptions::VT_DEDUPLICATE_SUGGESTIONS_BY_SPAN, static_cast<uint8_t>(deduplicate_suggestions_by_span), 1);
  }
  void add_lua_ranking_script(flatbuffers::Offset<flatbuffers::String> lua_ranking_script) {
    fbb_.AddOffset(RankingOptions::VT_LUA_RANKING_SCRIPT, lua_ranking_script);
  }
  void add_compressed_lua_ranking_script(flatbuffers::Offset<libtextclassifier3::CompressedBuffer> compressed_lua_ranking_script) {
    fbb_.AddOffset(RankingOptions::VT_COMPRESSED_LUA_RANKING_SCRIPT, compressed_lua_ranking_script);
  }
  void add_suppress_smart_replies_with_actions(bool suppress_smart_replies_with_actions) {
    fbb_.AddElement<uint8_t>(RankingOptions::VT_SUPPRESS_SMART_REPLIES_WITH_ACTIONS, static_cast<uint8_t>(suppress_smart_replies_with_actions), 0);
  }
  void add_group_by_annotations(bool group_by_annotations) {
    fbb_.AddElement<uint8_t>(RankingOptions::VT_GROUP_BY_ANNOTATIONS, static_cast<uint8_t>(group_by_annotations), 1);
  }
  explicit RankingOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RankingOptionsBuilder &operator=(const RankingOptionsBuilder &);
  flatbuffers::Offset<RankingOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RankingOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RankingOptions> CreateRankingOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool deduplicate_suggestions = true,
    bool deduplicate_suggestions_by_span = true,
    flatbuffers::Offset<flatbuffers::String> lua_ranking_script = 0,
    flatbuffers::Offset<libtextclassifier3::CompressedBuffer> compressed_lua_ranking_script = 0,
    bool suppress_smart_replies_with_actions = false,
    bool group_by_annotations = true) {
  RankingOptionsBuilder builder_(_fbb);
  builder_.add_compressed_lua_ranking_script(compressed_lua_ranking_script);
  builder_.add_lua_ranking_script(lua_ranking_script);
  builder_.add_group_by_annotations(group_by_annotations);
  builder_.add_suppress_smart_replies_with_actions(suppress_smart_replies_with_actions);
  builder_.add_deduplicate_suggestions_by_span(deduplicate_suggestions_by_span);
  builder_.add_deduplicate_suggestions(deduplicate_suggestions);
  return builder_.Finish();
}

inline flatbuffers::Offset<RankingOptions> CreateRankingOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool deduplicate_suggestions = true,
    bool deduplicate_suggestions_by_span = true,
    const char *lua_ranking_script = nullptr,
    flatbuffers::Offset<libtextclassifier3::CompressedBuffer> compressed_lua_ranking_script = 0,
    bool suppress_smart_replies_with_actions = false,
    bool group_by_annotations = true) {
  auto lua_ranking_script__ = lua_ranking_script ? _fbb.CreateSharedString(lua_ranking_script) : 0;
  return libtextclassifier3::CreateRankingOptions(
      _fbb,
      deduplicate_suggestions,
      deduplicate_suggestions_by_span,
      lua_ranking_script__,
      compressed_lua_ranking_script,
      suppress_smart_replies_with_actions,
      group_by_annotations);
}

flatbuffers::Offset<RankingOptions> CreateRankingOptions(flatbuffers::FlatBufferBuilder &_fbb, const RankingOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace RulesModel_ {
namespace RuleActionSpec_ {

struct RuleCapturingGroupT : public flatbuffers::NativeTable {
  typedef RuleCapturingGroup TableType;
  int32_t group_id;
  std::unique_ptr<libtextclassifier3::FlatbufferFieldPathT> entity_field;
  std::string annotation_type;
  std::string annotation_name;
  std::unique_ptr<libtextclassifier3::ActionSuggestionSpecT> text_reply;
  std::unique_ptr<libtextclassifier3::NormalizationOptionsT> normalization_options;
  bool use_annotation_match;
  std::unique_ptr<libtextclassifier3::ActionsEntityDataT> entity_data;
  RuleCapturingGroupT()
      : group_id(0),
        use_annotation_match(false) {
  }
};

struct RuleCapturingGroup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RuleCapturingGroupT NativeTableType;
  typedef RuleCapturingGroupBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GROUP_ID = 4,
    VT_ENTITY_FIELD = 6,
    VT_ANNOTATION_TYPE = 8,
    VT_ANNOTATION_NAME = 10,
    VT_TEXT_REPLY = 12,
    VT_NORMALIZATION_OPTIONS = 14,
    VT_USE_ANNOTATION_MATCH = 16,
    VT_ENTITY_DATA = 18
  };
  int32_t group_id() const {
    return GetField<int32_t>(VT_GROUP_ID, 0);
  }
  const libtextclassifier3::FlatbufferFieldPath *entity_field() const {
    return GetPointer<const libtextclassifier3::FlatbufferFieldPath *>(VT_ENTITY_FIELD);
  }
  const flatbuffers::String *annotation_type() const {
    return GetPointer<const flatbuffers::String *>(VT_ANNOTATION_TYPE);
  }
  const flatbuffers::String *annotation_name() const {
    return GetPointer<const flatbuffers::String *>(VT_ANNOTATION_NAME);
  }
  const libtextclassifier3::ActionSuggestionSpec *text_reply() const {
    return GetPointer<const libtextclassifier3::ActionSuggestionSpec *>(VT_TEXT_REPLY);
  }
  const libtextclassifier3::NormalizationOptions *normalization_options() const {
    return GetPointer<const libtextclassifier3::NormalizationOptions *>(VT_NORMALIZATION_OPTIONS);
  }
  bool use_annotation_match() const {
    return GetField<uint8_t>(VT_USE_ANNOTATION_MATCH, 0) != 0;
  }
  const libtextclassifier3::ActionsEntityData *entity_data() const {
    return GetPointer<const libtextclassifier3::ActionsEntityData *>(VT_ENTITY_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_GROUP_ID) &&
           VerifyOffset(verifier, VT_ENTITY_FIELD) &&
           verifier.VerifyTable(entity_field()) &&
           VerifyOffset(verifier, VT_ANNOTATION_TYPE) &&
           verifier.VerifyString(annotation_type()) &&
           VerifyOffset(verifier, VT_ANNOTATION_NAME) &&
           verifier.VerifyString(annotation_name()) &&
           VerifyOffset(verifier, VT_TEXT_REPLY) &&
           verifier.VerifyTable(text_reply()) &&
           VerifyOffset(verifier, VT_NORMALIZATION_OPTIONS) &&
           verifier.VerifyTable(normalization_options()) &&
           VerifyField<uint8_t>(verifier, VT_USE_ANNOTATION_MATCH) &&
           VerifyOffset(verifier, VT_ENTITY_DATA) &&
           verifier.VerifyTable(entity_data()) &&
           verifier.EndTable();
  }
  RuleCapturingGroupT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RuleCapturingGroupT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RuleCapturingGroup> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RuleCapturingGroupT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RuleCapturingGroupBuilder {
  typedef RuleCapturingGroup Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_group_id(int32_t group_id) {
    fbb_.AddElement<int32_t>(RuleCapturingGroup::VT_GROUP_ID, group_id, 0);
  }
  void add_entity_field(flatbuffers::Offset<libtextclassifier3::FlatbufferFieldPath> entity_field) {
    fbb_.AddOffset(RuleCapturingGroup::VT_ENTITY_FIELD, entity_field);
  }
  void add_annotation_type(flatbuffers::Offset<flatbuffers::String> annotation_type) {
    fbb_.AddOffset(RuleCapturingGroup::VT_ANNOTATION_TYPE, annotation_type);
  }
  void add_annotation_name(flatbuffers::Offset<flatbuffers::String> annotation_name) {
    fbb_.AddOffset(RuleCapturingGroup::VT_ANNOTATION_NAME, annotation_name);
  }
  void add_text_reply(flatbuffers::Offset<libtextclassifier3::ActionSuggestionSpec> text_reply) {
    fbb_.AddOffset(RuleCapturingGroup::VT_TEXT_REPLY, text_reply);
  }
  void add_normalization_options(flatbuffers::Offset<libtextclassifier3::NormalizationOptions> normalization_options) {
    fbb_.AddOffset(RuleCapturingGroup::VT_NORMALIZATION_OPTIONS, normalization_options);
  }
  void add_use_annotation_match(bool use_annotation_match) {
    fbb_.AddElement<uint8_t>(RuleCapturingGroup::VT_USE_ANNOTATION_MATCH, static_cast<uint8_t>(use_annotation_match), 0);
  }
  void add_entity_data(flatbuffers::Offset<libtextclassifier3::ActionsEntityData> entity_data) {
    fbb_.AddOffset(RuleCapturingGroup::VT_ENTITY_DATA, entity_data);
  }
  explicit RuleCapturingGroupBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RuleCapturingGroupBuilder &operator=(const RuleCapturingGroupBuilder &);
  flatbuffers::Offset<RuleCapturingGroup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RuleCapturingGroup>(end);
    return o;
  }
};

inline flatbuffers::Offset<RuleCapturingGroup> CreateRuleCapturingGroup(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t group_id = 0,
    flatbuffers::Offset<libtextclassifier3::FlatbufferFieldPath> entity_field = 0,
    flatbuffers::Offset<flatbuffers::String> annotation_type = 0,
    flatbuffers::Offset<flatbuffers::String> annotation_name = 0,
    flatbuffers::Offset<libtextclassifier3::ActionSuggestionSpec> text_reply = 0,
    flatbuffers::Offset<libtextclassifier3::NormalizationOptions> normalization_options = 0,
    bool use_annotation_match = false,
    flatbuffers::Offset<libtextclassifier3::ActionsEntityData> entity_data = 0) {
  RuleCapturingGroupBuilder builder_(_fbb);
  builder_.add_entity_data(entity_data);
  builder_.add_normalization_options(normalization_options);
  builder_.add_text_reply(text_reply);
  builder_.add_annotation_name(annotation_name);
  builder_.add_annotation_type(annotation_type);
  builder_.add_entity_field(entity_field);
  builder_.add_group_id(group_id);
  builder_.add_use_annotation_match(use_annotation_match);
  return builder_.Finish();
}

inline flatbuffers::Offset<RuleCapturingGroup> CreateRuleCapturingGroupDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t group_id = 0,
    flatbuffers::Offset<libtextclassifier3::FlatbufferFieldPath> entity_field = 0,
    const char *annotation_type = nullptr,
    const char *annotation_name = nullptr,
    flatbuffers::Offset<libtextclassifier3::ActionSuggestionSpec> text_reply = 0,
    flatbuffers::Offset<libtextclassifier3::NormalizationOptions> normalization_options = 0,
    bool use_annotation_match = false,
    flatbuffers::Offset<libtextclassifier3::ActionsEntityData> entity_data = 0) {
  auto annotation_type__ = annotation_type ? _fbb.CreateSharedString(annotation_type) : 0;
  auto annotation_name__ = annotation_name ? _fbb.CreateSharedString(annotation_name) : 0;
  return libtextclassifier3::RulesModel_::RuleActionSpec_::CreateRuleCapturingGroup(
      _fbb,
      group_id,
      entity_field,
      annotation_type__,
      annotation_name__,
      text_reply,
      normalization_options,
      use_annotation_match,
      entity_data);
}

flatbuffers::Offset<RuleCapturingGroup> CreateRuleCapturingGroup(flatbuffers::FlatBufferBuilder &_fbb, const RuleCapturingGroupT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace RuleActionSpec_

struct RuleActionSpecT : public flatbuffers::NativeTable {
  typedef RuleActionSpec TableType;
  std::unique_ptr<libtextclassifier3::ActionSuggestionSpecT> action;
  std::vector<std::unique_ptr<libtextclassifier3::RulesModel_::RuleActionSpec_::RuleCapturingGroupT>> capturing_group;
  RuleActionSpecT() {
  }
};

struct RuleActionSpec FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RuleActionSpecT NativeTableType;
  typedef RuleActionSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTION = 4,
    VT_CAPTURING_GROUP = 6
  };
  const libtextclassifier3::ActionSuggestionSpec *action() const {
    return GetPointer<const libtextclassifier3::ActionSuggestionSpec *>(VT_ACTION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RuleActionSpec_::RuleCapturingGroup>> *capturing_group() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RuleActionSpec_::RuleCapturingGroup>> *>(VT_CAPTURING_GROUP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACTION) &&
           verifier.VerifyTable(action()) &&
           VerifyOffset(verifier, VT_CAPTURING_GROUP) &&
           verifier.VerifyVector(capturing_group()) &&
           verifier.VerifyVectorOfTables(capturing_group()) &&
           verifier.EndTable();
  }
  RuleActionSpecT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RuleActionSpecT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RuleActionSpec> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RuleActionSpecT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RuleActionSpecBuilder {
  typedef RuleActionSpec Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_action(flatbuffers::Offset<libtextclassifier3::ActionSuggestionSpec> action) {
    fbb_.AddOffset(RuleActionSpec::VT_ACTION, action);
  }
  void add_capturing_group(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RuleActionSpec_::RuleCapturingGroup>>> capturing_group) {
    fbb_.AddOffset(RuleActionSpec::VT_CAPTURING_GROUP, capturing_group);
  }
  explicit RuleActionSpecBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RuleActionSpecBuilder &operator=(const RuleActionSpecBuilder &);
  flatbuffers::Offset<RuleActionSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RuleActionSpec>(end);
    return o;
  }
};

inline flatbuffers::Offset<RuleActionSpec> CreateRuleActionSpec(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<libtextclassifier3::ActionSuggestionSpec> action = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RuleActionSpec_::RuleCapturingGroup>>> capturing_group = 0) {
  RuleActionSpecBuilder builder_(_fbb);
  builder_.add_capturing_group(capturing_group);
  builder_.add_action(action);
  return builder_.Finish();
}

inline flatbuffers::Offset<RuleActionSpec> CreateRuleActionSpecDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<libtextclassifier3::ActionSuggestionSpec> action = 0,
    const std::vector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RuleActionSpec_::RuleCapturingGroup>> *capturing_group = nullptr) {
  auto capturing_group__ = capturing_group ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RuleActionSpec_::RuleCapturingGroup>>(*capturing_group) : 0;
  return libtextclassifier3::RulesModel_::CreateRuleActionSpec(
      _fbb,
      action,
      capturing_group__);
}

flatbuffers::Offset<RuleActionSpec> CreateRuleActionSpec(flatbuffers::FlatBufferBuilder &_fbb, const RuleActionSpecT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RegexRuleT : public flatbuffers::NativeTable {
  typedef RegexRule TableType;
  std::string pattern;
  std::unique_ptr<libtextclassifier3::CompressedBufferT> compressed_pattern;
  std::vector<std::unique_ptr<libtextclassifier3::RulesModel_::RuleActionSpecT>> actions;
  std::string output_pattern;
  std::unique_ptr<libtextclassifier3::CompressedBufferT> compressed_output_pattern;
  RegexRuleT() {
  }
};

struct RegexRule FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RegexRuleT NativeTableType;
  typedef RegexRuleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATTERN = 4,
    VT_COMPRESSED_PATTERN = 6,
    VT_ACTIONS = 8,
    VT_OUTPUT_PATTERN = 10,
    VT_COMPRESSED_OUTPUT_PATTERN = 12
  };
  const flatbuffers::String *pattern() const {
    return GetPointer<const flatbuffers::String *>(VT_PATTERN);
  }
  const libtextclassifier3::CompressedBuffer *compressed_pattern() const {
    return GetPointer<const libtextclassifier3::CompressedBuffer *>(VT_COMPRESSED_PATTERN);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RuleActionSpec>> *actions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RuleActionSpec>> *>(VT_ACTIONS);
  }
  const flatbuffers::String *output_pattern() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT_PATTERN);
  }
  const libtextclassifier3::CompressedBuffer *compressed_output_pattern() const {
    return GetPointer<const libtextclassifier3::CompressedBuffer *>(VT_COMPRESSED_OUTPUT_PATTERN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATTERN) &&
           verifier.VerifyString(pattern()) &&
           VerifyOffset(verifier, VT_COMPRESSED_PATTERN) &&
           verifier.VerifyTable(compressed_pattern()) &&
           VerifyOffset(verifier, VT_ACTIONS) &&
           verifier.VerifyVector(actions()) &&
           verifier.VerifyVectorOfTables(actions()) &&
           VerifyOffset(verifier, VT_OUTPUT_PATTERN) &&
           verifier.VerifyString(output_pattern()) &&
           VerifyOffset(verifier, VT_COMPRESSED_OUTPUT_PATTERN) &&
           verifier.VerifyTable(compressed_output_pattern()) &&
           verifier.EndTable();
  }
  RegexRuleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RegexRuleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RegexRule> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegexRuleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RegexRuleBuilder {
  typedef RegexRule Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pattern(flatbuffers::Offset<flatbuffers::String> pattern) {
    fbb_.AddOffset(RegexRule::VT_PATTERN, pattern);
  }
  void add_compressed_pattern(flatbuffers::Offset<libtextclassifier3::CompressedBuffer> compressed_pattern) {
    fbb_.AddOffset(RegexRule::VT_COMPRESSED_PATTERN, compressed_pattern);
  }
  void add_actions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RuleActionSpec>>> actions) {
    fbb_.AddOffset(RegexRule::VT_ACTIONS, actions);
  }
  void add_output_pattern(flatbuffers::Offset<flatbuffers::String> output_pattern) {
    fbb_.AddOffset(RegexRule::VT_OUTPUT_PATTERN, output_pattern);
  }
  void add_compressed_output_pattern(flatbuffers::Offset<libtextclassifier3::CompressedBuffer> compressed_output_pattern) {
    fbb_.AddOffset(RegexRule::VT_COMPRESSED_OUTPUT_PATTERN, compressed_output_pattern);
  }
  explicit RegexRuleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RegexRuleBuilder &operator=(const RegexRuleBuilder &);
  flatbuffers::Offset<RegexRule> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RegexRule>(end);
    return o;
  }
};

inline flatbuffers::Offset<RegexRule> CreateRegexRule(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> pattern = 0,
    flatbuffers::Offset<libtextclassifier3::CompressedBuffer> compressed_pattern = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RuleActionSpec>>> actions = 0,
    flatbuffers::Offset<flatbuffers::String> output_pattern = 0,
    flatbuffers::Offset<libtextclassifier3::CompressedBuffer> compressed_output_pattern = 0) {
  RegexRuleBuilder builder_(_fbb);
  builder_.add_compressed_output_pattern(compressed_output_pattern);
  builder_.add_output_pattern(output_pattern);
  builder_.add_actions(actions);
  builder_.add_compressed_pattern(compressed_pattern);
  builder_.add_pattern(pattern);
  return builder_.Finish();
}

inline flatbuffers::Offset<RegexRule> CreateRegexRuleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *pattern = nullptr,
    flatbuffers::Offset<libtextclassifier3::CompressedBuffer> compressed_pattern = 0,
    const std::vector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RuleActionSpec>> *actions = nullptr,
    const char *output_pattern = nullptr,
    flatbuffers::Offset<libtextclassifier3::CompressedBuffer> compressed_output_pattern = 0) {
  auto pattern__ = pattern ? _fbb.CreateSharedString(pattern) : 0;
  auto actions__ = actions ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RuleActionSpec>>(*actions) : 0;
  auto output_pattern__ = output_pattern ? _fbb.CreateSharedString(output_pattern) : 0;
  return libtextclassifier3::RulesModel_::CreateRegexRule(
      _fbb,
      pattern__,
      compressed_pattern,
      actions__,
      output_pattern__,
      compressed_output_pattern);
}

flatbuffers::Offset<RegexRule> CreateRegexRule(flatbuffers::FlatBufferBuilder &_fbb, const RegexRuleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace GrammarRules_ {

struct RuleMatchT : public flatbuffers::NativeTable {
  typedef RuleMatch TableType;
  std::vector<uint32_t> action_id;
  RuleMatchT() {
  }
};

struct RuleMatch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RuleMatchT NativeTableType;
  typedef RuleMatchBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTION_ID = 4
  };
  const flatbuffers::Vector<uint32_t> *action_id() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_ACTION_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACTION_ID) &&
           verifier.VerifyVector(action_id()) &&
           verifier.EndTable();
  }
  RuleMatchT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RuleMatchT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RuleMatch> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RuleMatchT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RuleMatchBuilder {
  typedef RuleMatch Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_action_id(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> action_id) {
    fbb_.AddOffset(RuleMatch::VT_ACTION_ID, action_id);
  }
  explicit RuleMatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RuleMatchBuilder &operator=(const RuleMatchBuilder &);
  flatbuffers::Offset<RuleMatch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RuleMatch>(end);
    return o;
  }
};

inline flatbuffers::Offset<RuleMatch> CreateRuleMatch(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> action_id = 0) {
  RuleMatchBuilder builder_(_fbb);
  builder_.add_action_id(action_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<RuleMatch> CreateRuleMatchDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *action_id = nullptr) {
  auto action_id__ = action_id ? _fbb.CreateVector<uint32_t>(*action_id) : 0;
  return libtextclassifier3::RulesModel_::GrammarRules_::CreateRuleMatch(
      _fbb,
      action_id__);
}

flatbuffers::Offset<RuleMatch> CreateRuleMatch(flatbuffers::FlatBufferBuilder &_fbb, const RuleMatchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace GrammarRules_

struct GrammarRulesT : public flatbuffers::NativeTable {
  typedef GrammarRules TableType;
  std::unique_ptr<libtextclassifier3::ActionsTokenizerOptionsT> tokenizer_options;
  std::unique_ptr<libtextclassifier3::grammar::RulesSetT> rules;
  std::vector<std::unique_ptr<libtextclassifier3::RulesModel_::GrammarRules_::RuleMatchT>> rule_match;
  std::vector<std::unique_ptr<libtextclassifier3::RulesModel_::RuleActionSpecT>> actions;
  GrammarRulesT() {
  }
};

struct GrammarRules FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GrammarRulesT NativeTableType;
  typedef GrammarRulesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOKENIZER_OPTIONS = 4,
    VT_RULES = 6,
    VT_RULE_MATCH = 8,
    VT_ACTIONS = 10
  };
  const libtextclassifier3::ActionsTokenizerOptions *tokenizer_options() const {
    return GetPointer<const libtextclassifier3::ActionsTokenizerOptions *>(VT_TOKENIZER_OPTIONS);
  }
  const libtextclassifier3::grammar::RulesSet *rules() const {
    return GetPointer<const libtextclassifier3::grammar::RulesSet *>(VT_RULES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::RulesModel_::GrammarRules_::RuleMatch>> *rule_match() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::RulesModel_::GrammarRules_::RuleMatch>> *>(VT_RULE_MATCH);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RuleActionSpec>> *actions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RuleActionSpec>> *>(VT_ACTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOKENIZER_OPTIONS) &&
           verifier.VerifyTable(tokenizer_options()) &&
           VerifyOffset(verifier, VT_RULES) &&
           verifier.VerifyTable(rules()) &&
           VerifyOffset(verifier, VT_RULE_MATCH) &&
           verifier.VerifyVector(rule_match()) &&
           verifier.VerifyVectorOfTables(rule_match()) &&
           VerifyOffset(verifier, VT_ACTIONS) &&
           verifier.VerifyVector(actions()) &&
           verifier.VerifyVectorOfTables(actions()) &&
           verifier.EndTable();
  }
  GrammarRulesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GrammarRulesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GrammarRules> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GrammarRulesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GrammarRulesBuilder {
  typedef GrammarRules Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tokenizer_options(flatbuffers::Offset<libtextclassifier3::ActionsTokenizerOptions> tokenizer_options) {
    fbb_.AddOffset(GrammarRules::VT_TOKENIZER_OPTIONS, tokenizer_options);
  }
  void add_rules(flatbuffers::Offset<libtextclassifier3::grammar::RulesSet> rules) {
    fbb_.AddOffset(GrammarRules::VT_RULES, rules);
  }
  void add_rule_match(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::RulesModel_::GrammarRules_::RuleMatch>>> rule_match) {
    fbb_.AddOffset(GrammarRules::VT_RULE_MATCH, rule_match);
  }
  void add_actions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RuleActionSpec>>> actions) {
    fbb_.AddOffset(GrammarRules::VT_ACTIONS, actions);
  }
  explicit GrammarRulesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GrammarRulesBuilder &operator=(const GrammarRulesBuilder &);
  flatbuffers::Offset<GrammarRules> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GrammarRules>(end);
    return o;
  }
};

inline flatbuffers::Offset<GrammarRules> CreateGrammarRules(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<libtextclassifier3::ActionsTokenizerOptions> tokenizer_options = 0,
    flatbuffers::Offset<libtextclassifier3::grammar::RulesSet> rules = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::RulesModel_::GrammarRules_::RuleMatch>>> rule_match = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RuleActionSpec>>> actions = 0) {
  GrammarRulesBuilder builder_(_fbb);
  builder_.add_actions(actions);
  builder_.add_rule_match(rule_match);
  builder_.add_rules(rules);
  builder_.add_tokenizer_options(tokenizer_options);
  return builder_.Finish();
}

inline flatbuffers::Offset<GrammarRules> CreateGrammarRulesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<libtextclassifier3::ActionsTokenizerOptions> tokenizer_options = 0,
    flatbuffers::Offset<libtextclassifier3::grammar::RulesSet> rules = 0,
    const std::vector<flatbuffers::Offset<libtextclassifier3::RulesModel_::GrammarRules_::RuleMatch>> *rule_match = nullptr,
    const std::vector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RuleActionSpec>> *actions = nullptr) {
  auto rule_match__ = rule_match ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::RulesModel_::GrammarRules_::RuleMatch>>(*rule_match) : 0;
  auto actions__ = actions ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RuleActionSpec>>(*actions) : 0;
  return libtextclassifier3::RulesModel_::CreateGrammarRules(
      _fbb,
      tokenizer_options,
      rules,
      rule_match__,
      actions__);
}

flatbuffers::Offset<GrammarRules> CreateGrammarRules(flatbuffers::FlatBufferBuilder &_fbb, const GrammarRulesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace RulesModel_

struct RulesModelT : public flatbuffers::NativeTable {
  typedef RulesModel TableType;
  std::vector<std::unique_ptr<libtextclassifier3::RulesModel_::RegexRuleT>> regex_rule;
  bool lazy_regex_compilation;
  std::unique_ptr<libtextclassifier3::RulesModel_::GrammarRulesT> grammar_rules;
  RulesModelT()
      : lazy_regex_compilation(true) {
  }
};

struct RulesModel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RulesModelT NativeTableType;
  typedef RulesModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REGEX_RULE = 4,
    VT_LAZY_REGEX_COMPILATION = 6,
    VT_GRAMMAR_RULES = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RegexRule>> *regex_rule() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RegexRule>> *>(VT_REGEX_RULE);
  }
  bool lazy_regex_compilation() const {
    return GetField<uint8_t>(VT_LAZY_REGEX_COMPILATION, 1) != 0;
  }
  const libtextclassifier3::RulesModel_::GrammarRules *grammar_rules() const {
    return GetPointer<const libtextclassifier3::RulesModel_::GrammarRules *>(VT_GRAMMAR_RULES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REGEX_RULE) &&
           verifier.VerifyVector(regex_rule()) &&
           verifier.VerifyVectorOfTables(regex_rule()) &&
           VerifyField<uint8_t>(verifier, VT_LAZY_REGEX_COMPILATION) &&
           VerifyOffset(verifier, VT_GRAMMAR_RULES) &&
           verifier.VerifyTable(grammar_rules()) &&
           verifier.EndTable();
  }
  RulesModelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RulesModelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RulesModel> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RulesModelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RulesModelBuilder {
  typedef RulesModel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_regex_rule(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RegexRule>>> regex_rule) {
    fbb_.AddOffset(RulesModel::VT_REGEX_RULE, regex_rule);
  }
  void add_lazy_regex_compilation(bool lazy_regex_compilation) {
    fbb_.AddElement<uint8_t>(RulesModel::VT_LAZY_REGEX_COMPILATION, static_cast<uint8_t>(lazy_regex_compilation), 1);
  }
  void add_grammar_rules(flatbuffers::Offset<libtextclassifier3::RulesModel_::GrammarRules> grammar_rules) {
    fbb_.AddOffset(RulesModel::VT_GRAMMAR_RULES, grammar_rules);
  }
  explicit RulesModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RulesModelBuilder &operator=(const RulesModelBuilder &);
  flatbuffers::Offset<RulesModel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RulesModel>(end);
    return o;
  }
};

inline flatbuffers::Offset<RulesModel> CreateRulesModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RegexRule>>> regex_rule = 0,
    bool lazy_regex_compilation = true,
    flatbuffers::Offset<libtextclassifier3::RulesModel_::GrammarRules> grammar_rules = 0) {
  RulesModelBuilder builder_(_fbb);
  builder_.add_grammar_rules(grammar_rules);
  builder_.add_regex_rule(regex_rule);
  builder_.add_lazy_regex_compilation(lazy_regex_compilation);
  return builder_.Finish();
}

inline flatbuffers::Offset<RulesModel> CreateRulesModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RegexRule>> *regex_rule = nullptr,
    bool lazy_regex_compilation = true,
    flatbuffers::Offset<libtextclassifier3::RulesModel_::GrammarRules> grammar_rules = 0) {
  auto regex_rule__ = regex_rule ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RegexRule>>(*regex_rule) : 0;
  return libtextclassifier3::CreateRulesModel(
      _fbb,
      regex_rule__,
      lazy_regex_compilation,
      grammar_rules);
}

flatbuffers::Offset<RulesModel> CreateRulesModel(flatbuffers::FlatBufferBuilder &_fbb, const RulesModelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ActionsModelT : public flatbuffers::NativeTable {
  typedef ActionsModel TableType;
  std::string locales;
  int32_t version;
  std::string name;
  std::unique_ptr<libtextclassifier3::TensorflowLiteModelSpecT> tflite_model_spec;
  std::string smart_reply_action_type;
  std::vector<std::unique_ptr<libtextclassifier3::ActionTypeOptionsT>> action_type;
  std::unique_ptr<libtextclassifier3::TriggeringPreconditionsT> preconditions;
  int32_t num_smart_replies;
  int32_t max_conversation_history_length;
  std::unique_ptr<libtextclassifier3::AnnotationActionsSpecT> annotation_actions_spec;
  std::unique_ptr<libtextclassifier3::RulesModelT> rules;
  std::unique_ptr<libtextclassifier3::IntentFactoryModelT> android_intent_options;
  std::unique_ptr<libtextclassifier3::ResourcePoolT> resources;
  std::vector<uint8_t> actions_entity_data_schema;
  std::unique_ptr<libtextclassifier3::RankingOptionsT> ranking_options;
  std::string lua_actions_script;
  std::unique_ptr<libtextclassifier3::CompressedBufferT> compressed_lua_actions_script;
  std::unique_ptr<libtextclassifier3::RulesModelT> low_confidence_rules;
  std::unique_ptr<libtextclassifier3::NGramLinearRegressionModelT> low_confidence_ngram_model;
  std::unique_ptr<libtextclassifier3::ActionsTokenFeatureProcessorOptionsT> feature_processor_options;
  std::unique_ptr<libtextclassifier3::TFLiteSensitiveClassifierConfigT> low_confidence_tflite_model;
  ActionsModelT()
      : version(0),
        num_smart_replies(3),
        max_conversation_history_length(1) {
  }
};

struct ActionsModel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActionsModelT NativeTableType;
  typedef ActionsModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOCALES = 4,
    VT_VERSION = 6,
    VT_NAME = 8,
    VT_TFLITE_MODEL_SPEC = 10,
    VT_SMART_REPLY_ACTION_TYPE = 12,
    VT_ACTION_TYPE = 14,
    VT_PRECONDITIONS = 16,
    VT_NUM_SMART_REPLIES = 18,
    VT_MAX_CONVERSATION_HISTORY_LENGTH = 20,
    VT_ANNOTATION_ACTIONS_SPEC = 22,
    VT_RULES = 24,
    VT_ANDROID_INTENT_OPTIONS = 26,
    VT_RESOURCES = 28,
    VT_ACTIONS_ENTITY_DATA_SCHEMA = 30,
    VT_RANKING_OPTIONS = 32,
    VT_LUA_ACTIONS_SCRIPT = 34,
    VT_COMPRESSED_LUA_ACTIONS_SCRIPT = 36,
    VT_LOW_CONFIDENCE_RULES = 38,
    VT_LOW_CONFIDENCE_NGRAM_MODEL = 40,
    VT_FEATURE_PROCESSOR_OPTIONS = 42,
    VT_LOW_CONFIDENCE_TFLITE_MODEL = 44
  };
  const flatbuffers::String *locales() const {
    return GetPointer<const flatbuffers::String *>(VT_LOCALES);
  }
  int32_t version() const {
    return GetField<int32_t>(VT_VERSION, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const libtextclassifier3::TensorflowLiteModelSpec *tflite_model_spec() const {
    return GetPointer<const libtextclassifier3::TensorflowLiteModelSpec *>(VT_TFLITE_MODEL_SPEC);
  }
  const flatbuffers::String *smart_reply_action_type() const {
    return GetPointer<const flatbuffers::String *>(VT_SMART_REPLY_ACTION_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::ActionTypeOptions>> *action_type() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::ActionTypeOptions>> *>(VT_ACTION_TYPE);
  }
  const libtextclassifier3::TriggeringPreconditions *preconditions() const {
    return GetPointer<const libtextclassifier3::TriggeringPreconditions *>(VT_PRECONDITIONS);
  }
  int32_t num_smart_replies() const {
    return GetField<int32_t>(VT_NUM_SMART_REPLIES, 3);
  }
  int32_t max_conversation_history_length() const {
    return GetField<int32_t>(VT_MAX_CONVERSATION_HISTORY_LENGTH, 1);
  }
  const libtextclassifier3::AnnotationActionsSpec *annotation_actions_spec() const {
    return GetPointer<const libtextclassifier3::AnnotationActionsSpec *>(VT_ANNOTATION_ACTIONS_SPEC);
  }
  const libtextclassifier3::RulesModel *rules() const {
    return GetPointer<const libtextclassifier3::RulesModel *>(VT_RULES);
  }
  const libtextclassifier3::IntentFactoryModel *android_intent_options() const {
    return GetPointer<const libtextclassifier3::IntentFactoryModel *>(VT_ANDROID_INTENT_OPTIONS);
  }
  const libtextclassifier3::ResourcePool *resources() const {
    return GetPointer<const libtextclassifier3::ResourcePool *>(VT_RESOURCES);
  }
  const flatbuffers::Vector<uint8_t> *actions_entity_data_schema() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ACTIONS_ENTITY_DATA_SCHEMA);
  }
  const libtextclassifier3::RankingOptions *ranking_options() const {
    return GetPointer<const libtextclassifier3::RankingOptions *>(VT_RANKING_OPTIONS);
  }
  const flatbuffers::String *lua_actions_script() const {
    return GetPointer<const flatbuffers::String *>(VT_LUA_ACTIONS_SCRIPT);
  }
  const libtextclassifier3::CompressedBuffer *compressed_lua_actions_script() const {
    return GetPointer<const libtextclassifier3::CompressedBuffer *>(VT_COMPRESSED_LUA_ACTIONS_SCRIPT);
  }
  const libtextclassifier3::RulesModel *low_confidence_rules() const {
    return GetPointer<const libtextclassifier3::RulesModel *>(VT_LOW_CONFIDENCE_RULES);
  }
  const libtextclassifier3::NGramLinearRegressionModel *low_confidence_ngram_model() const {
    return GetPointer<const libtextclassifier3::NGramLinearRegressionModel *>(VT_LOW_CONFIDENCE_NGRAM_MODEL);
  }
  const libtextclassifier3::ActionsTokenFeatureProcessorOptions *feature_processor_options() const {
    return GetPointer<const libtextclassifier3::ActionsTokenFeatureProcessorOptions *>(VT_FEATURE_PROCESSOR_OPTIONS);
  }
  const libtextclassifier3::TFLiteSensitiveClassifierConfig *low_confidence_tflite_model() const {
    return GetPointer<const libtextclassifier3::TFLiteSensitiveClassifierConfig *>(VT_LOW_CONFIDENCE_TFLITE_MODEL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOCALES) &&
           verifier.VerifyString(locales()) &&
           VerifyField<int32_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_TFLITE_MODEL_SPEC) &&
           verifier.VerifyTable(tflite_model_spec()) &&
           VerifyOffset(verifier, VT_SMART_REPLY_ACTION_TYPE) &&
           verifier.VerifyString(smart_reply_action_type()) &&
           VerifyOffset(verifier, VT_ACTION_TYPE) &&
           verifier.VerifyVector(action_type()) &&
           verifier.VerifyVectorOfTables(action_type()) &&
           VerifyOffset(verifier, VT_PRECONDITIONS) &&
           verifier.VerifyTable(preconditions()) &&
           VerifyField<int32_t>(verifier, VT_NUM_SMART_REPLIES) &&
           VerifyField<int32_t>(verifier, VT_MAX_CONVERSATION_HISTORY_LENGTH) &&
           VerifyOffset(verifier, VT_ANNOTATION_ACTIONS_SPEC) &&
           verifier.VerifyTable(annotation_actions_spec()) &&
           VerifyOffset(verifier, VT_RULES) &&
           verifier.VerifyTable(rules()) &&
           VerifyOffset(verifier, VT_ANDROID_INTENT_OPTIONS) &&
           verifier.VerifyTable(android_intent_options()) &&
           VerifyOffset(verifier, VT_RESOURCES) &&
           verifier.VerifyTable(resources()) &&
           VerifyOffset(verifier, VT_ACTIONS_ENTITY_DATA_SCHEMA) &&
           verifier.VerifyVector(actions_entity_data_schema()) &&
           VerifyOffset(verifier, VT_RANKING_OPTIONS) &&
           verifier.VerifyTable(ranking_options()) &&
           VerifyOffset(verifier, VT_LUA_ACTIONS_SCRIPT) &&
           verifier.VerifyString(lua_actions_script()) &&
           VerifyOffset(verifier, VT_COMPRESSED_LUA_ACTIONS_SCRIPT) &&
           verifier.VerifyTable(compressed_lua_actions_script()) &&
           VerifyOffset(verifier, VT_LOW_CONFIDENCE_RULES) &&
           verifier.VerifyTable(low_confidence_rules()) &&
           VerifyOffset(verifier, VT_LOW_CONFIDENCE_NGRAM_MODEL) &&
           verifier.VerifyTable(low_confidence_ngram_model()) &&
           VerifyOffset(verifier, VT_FEATURE_PROCESSOR_OPTIONS) &&
           verifier.VerifyTable(feature_processor_options()) &&
           VerifyOffset(verifier, VT_LOW_CONFIDENCE_TFLITE_MODEL) &&
           verifier.VerifyTable(low_confidence_tflite_model()) &&
           verifier.EndTable();
  }
  ActionsModelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ActionsModelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ActionsModel> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActionsModelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ActionsModelBuilder {
  typedef ActionsModel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_locales(flatbuffers::Offset<flatbuffers::String> locales) {
    fbb_.AddOffset(ActionsModel::VT_LOCALES, locales);
  }
  void add_version(int32_t version) {
    fbb_.AddElement<int32_t>(ActionsModel::VT_VERSION, version, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ActionsModel::VT_NAME, name);
  }
  void add_tflite_model_spec(flatbuffers::Offset<libtextclassifier3::TensorflowLiteModelSpec> tflite_model_spec) {
    fbb_.AddOffset(ActionsModel::VT_TFLITE_MODEL_SPEC, tflite_model_spec);
  }
  void add_smart_reply_action_type(flatbuffers::Offset<flatbuffers::String> smart_reply_action_type) {
    fbb_.AddOffset(ActionsModel::VT_SMART_REPLY_ACTION_TYPE, smart_reply_action_type);
  }
  void add_action_type(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::ActionTypeOptions>>> action_type) {
    fbb_.AddOffset(ActionsModel::VT_ACTION_TYPE, action_type);
  }
  void add_preconditions(flatbuffers::Offset<libtextclassifier3::TriggeringPreconditions> preconditions) {
    fbb_.AddOffset(ActionsModel::VT_PRECONDITIONS, preconditions);
  }
  void add_num_smart_replies(int32_t num_smart_replies) {
    fbb_.AddElement<int32_t>(ActionsModel::VT_NUM_SMART_REPLIES, num_smart_replies, 3);
  }
  void add_max_conversation_history_length(int32_t max_conversation_history_length) {
    fbb_.AddElement<int32_t>(ActionsModel::VT_MAX_CONVERSATION_HISTORY_LENGTH, max_conversation_history_length, 1);
  }
  void add_annotation_actions_spec(flatbuffers::Offset<libtextclassifier3::AnnotationActionsSpec> annotation_actions_spec) {
    fbb_.AddOffset(ActionsModel::VT_ANNOTATION_ACTIONS_SPEC, annotation_actions_spec);
  }
  void add_rules(flatbuffers::Offset<libtextclassifier3::RulesModel> rules) {
    fbb_.AddOffset(ActionsModel::VT_RULES, rules);
  }
  void add_android_intent_options(flatbuffers::Offset<libtextclassifier3::IntentFactoryModel> android_intent_options) {
    fbb_.AddOffset(ActionsModel::VT_ANDROID_INTENT_OPTIONS, android_intent_options);
  }
  void add_resources(flatbuffers::Offset<libtextclassifier3::ResourcePool> resources) {
    fbb_.AddOffset(ActionsModel::VT_RESOURCES, resources);
  }
  void add_actions_entity_data_schema(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> actions_entity_data_schema) {
    fbb_.AddOffset(ActionsModel::VT_ACTIONS_ENTITY_DATA_SCHEMA, actions_entity_data_schema);
  }
  void add_ranking_options(flatbuffers::Offset<libtextclassifier3::RankingOptions> ranking_options) {
    fbb_.AddOffset(ActionsModel::VT_RANKING_OPTIONS, ranking_options);
  }
  void add_lua_actions_script(flatbuffers::Offset<flatbuffers::String> lua_actions_script) {
    fbb_.AddOffset(ActionsModel::VT_LUA_ACTIONS_SCRIPT, lua_actions_script);
  }
  void add_compressed_lua_actions_script(flatbuffers::Offset<libtextclassifier3::CompressedBuffer> compressed_lua_actions_script) {
    fbb_.AddOffset(ActionsModel::VT_COMPRESSED_LUA_ACTIONS_SCRIPT, compressed_lua_actions_script);
  }
  void add_low_confidence_rules(flatbuffers::Offset<libtextclassifier3::RulesModel> low_confidence_rules) {
    fbb_.AddOffset(ActionsModel::VT_LOW_CONFIDENCE_RULES, low_confidence_rules);
  }
  void add_low_confidence_ngram_model(flatbuffers::Offset<libtextclassifier3::NGramLinearRegressionModel> low_confidence_ngram_model) {
    fbb_.AddOffset(ActionsModel::VT_LOW_CONFIDENCE_NGRAM_MODEL, low_confidence_ngram_model);
  }
  void add_feature_processor_options(flatbuffers::Offset<libtextclassifier3::ActionsTokenFeatureProcessorOptions> feature_processor_options) {
    fbb_.AddOffset(ActionsModel::VT_FEATURE_PROCESSOR_OPTIONS, feature_processor_options);
  }
  void add_low_confidence_tflite_model(flatbuffers::Offset<libtextclassifier3::TFLiteSensitiveClassifierConfig> low_confidence_tflite_model) {
    fbb_.AddOffset(ActionsModel::VT_LOW_CONFIDENCE_TFLITE_MODEL, low_confidence_tflite_model);
  }
  explicit ActionsModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ActionsModelBuilder &operator=(const ActionsModelBuilder &);
  flatbuffers::Offset<ActionsModel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ActionsModel>(end);
    return o;
  }
};

inline flatbuffers::Offset<ActionsModel> CreateActionsModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> locales = 0,
    int32_t version = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<libtextclassifier3::TensorflowLiteModelSpec> tflite_model_spec = 0,
    flatbuffers::Offset<flatbuffers::String> smart_reply_action_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::ActionTypeOptions>>> action_type = 0,
    flatbuffers::Offset<libtextclassifier3::TriggeringPreconditions> preconditions = 0,
    int32_t num_smart_replies = 3,
    int32_t max_conversation_history_length = 1,
    flatbuffers::Offset<libtextclassifier3::AnnotationActionsSpec> annotation_actions_spec = 0,
    flatbuffers::Offset<libtextclassifier3::RulesModel> rules = 0,
    flatbuffers::Offset<libtextclassifier3::IntentFactoryModel> android_intent_options = 0,
    flatbuffers::Offset<libtextclassifier3::ResourcePool> resources = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> actions_entity_data_schema = 0,
    flatbuffers::Offset<libtextclassifier3::RankingOptions> ranking_options = 0,
    flatbuffers::Offset<flatbuffers::String> lua_actions_script = 0,
    flatbuffers::Offset<libtextclassifier3::CompressedBuffer> compressed_lua_actions_script = 0,
    flatbuffers::Offset<libtextclassifier3::RulesModel> low_confidence_rules = 0,
    flatbuffers::Offset<libtextclassifier3::NGramLinearRegressionModel> low_confidence_ngram_model = 0,
    flatbuffers::Offset<libtextclassifier3::ActionsTokenFeatureProcessorOptions> feature_processor_options = 0,
    flatbuffers::Offset<libtextclassifier3::TFLiteSensitiveClassifierConfig> low_confidence_tflite_model = 0) {
  ActionsModelBuilder builder_(_fbb);
  builder_.add_low_confidence_tflite_model(low_confidence_tflite_model);
  builder_.add_feature_processor_options(feature_processor_options);
  builder_.add_low_confidence_ngram_model(low_confidence_ngram_model);
  builder_.add_low_confidence_rules(low_confidence_rules);
  builder_.add_compressed_lua_actions_script(compressed_lua_actions_script);
  builder_.add_lua_actions_script(lua_actions_script);
  builder_.add_ranking_options(ranking_options);
  builder_.add_actions_entity_data_schema(actions_entity_data_schema);
  builder_.add_resources(resources);
  builder_.add_android_intent_options(android_intent_options);
  builder_.add_rules(rules);
  builder_.add_annotation_actions_spec(annotation_actions_spec);
  builder_.add_max_conversation_history_length(max_conversation_history_length);
  builder_.add_num_smart_replies(num_smart_replies);
  builder_.add_preconditions(preconditions);
  builder_.add_action_type(action_type);
  builder_.add_smart_reply_action_type(smart_reply_action_type);
  builder_.add_tflite_model_spec(tflite_model_spec);
  builder_.add_name(name);
  builder_.add_version(version);
  builder_.add_locales(locales);
  return builder_.Finish();
}

inline flatbuffers::Offset<ActionsModel> CreateActionsModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *locales = nullptr,
    int32_t version = 0,
    const char *name = nullptr,
    flatbuffers::Offset<libtextclassifier3::TensorflowLiteModelSpec> tflite_model_spec = 0,
    const char *smart_reply_action_type = nullptr,
    const std::vector<flatbuffers::Offset<libtextclassifier3::ActionTypeOptions>> *action_type = nullptr,
    flatbuffers::Offset<libtextclassifier3::TriggeringPreconditions> preconditions = 0,
    int32_t num_smart_replies = 3,
    int32_t max_conversation_history_length = 1,
    flatbuffers::Offset<libtextclassifier3::AnnotationActionsSpec> annotation_actions_spec = 0,
    flatbuffers::Offset<libtextclassifier3::RulesModel> rules = 0,
    flatbuffers::Offset<libtextclassifier3::IntentFactoryModel> android_intent_options = 0,
    flatbuffers::Offset<libtextclassifier3::ResourcePool> resources = 0,
    const std::vector<uint8_t> *actions_entity_data_schema = nullptr,
    flatbuffers::Offset<libtextclassifier3::RankingOptions> ranking_options = 0,
    const char *lua_actions_script = nullptr,
    flatbuffers::Offset<libtextclassifier3::CompressedBuffer> compressed_lua_actions_script = 0,
    flatbuffers::Offset<libtextclassifier3::RulesModel> low_confidence_rules = 0,
    flatbuffers::Offset<libtextclassifier3::NGramLinearRegressionModel> low_confidence_ngram_model = 0,
    flatbuffers::Offset<libtextclassifier3::ActionsTokenFeatureProcessorOptions> feature_processor_options = 0,
    flatbuffers::Offset<libtextclassifier3::TFLiteSensitiveClassifierConfig> low_confidence_tflite_model = 0) {
  auto locales__ = locales ? _fbb.CreateSharedString(locales) : 0;
  auto name__ = name ? _fbb.CreateSharedString(name) : 0;
  auto smart_reply_action_type__ = smart_reply_action_type ? _fbb.CreateSharedString(smart_reply_action_type) : 0;
  auto action_type__ = action_type ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::ActionTypeOptions>>(*action_type) : 0;
  auto actions_entity_data_schema__ = actions_entity_data_schema ? _fbb.CreateVector<uint8_t>(*actions_entity_data_schema) : 0;
  auto lua_actions_script__ = lua_actions_script ? _fbb.CreateSharedString(lua_actions_script) : 0;
  return libtextclassifier3::CreateActionsModel(
      _fbb,
      locales__,
      version,
      name__,
      tflite_model_spec,
      smart_reply_action_type__,
      action_type__,
      preconditions,
      num_smart_replies,
      max_conversation_history_length,
      annotation_actions_spec,
      rules,
      android_intent_options,
      resources,
      actions_entity_data_schema__,
      ranking_options,
      lua_actions_script__,
      compressed_lua_actions_script,
      low_confidence_rules,
      low_confidence_ngram_model,
      feature_processor_options,
      low_confidence_tflite_model);
}

flatbuffers::Offset<ActionsModel> CreateActionsModel(flatbuffers::FlatBufferBuilder &_fbb, const ActionsModelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline PredictionMetadataT *PredictionMetadata::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::PredictionMetadataT> _o = std::unique_ptr<libtextclassifier3::PredictionMetadataT>(new PredictionMetadataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PredictionMetadata::UnPackTo(PredictionMetadataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = prediction_type(); _o->prediction_type = _e; }
  { auto _e = task_spec(); if (_e) _o->task_spec = std::unique_ptr<libtextclassifier3::ActionSuggestionSpecT>(_e->UnPack(_resolver)); }
  { auto _e = output_suggestions(); _o->output_suggestions = _e; }
  { auto _e = output_suggestions_scores(); _o->output_suggestions_scores = _e; }
  { auto _e = output_suggestions_spans(); _o->output_suggestions_spans = _e; }
}

inline flatbuffers::Offset<PredictionMetadata> PredictionMetadata::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PredictionMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePredictionMetadata(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PredictionMetadata> CreatePredictionMetadata(flatbuffers::FlatBufferBuilder &_fbb, const PredictionMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PredictionMetadataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _prediction_type = _o->prediction_type;
  auto _task_spec = _o->task_spec ? CreateActionSuggestionSpec(_fbb, _o->task_spec.get(), _rehasher) : 0;
  auto _output_suggestions = _o->output_suggestions;
  auto _output_suggestions_scores = _o->output_suggestions_scores;
  auto _output_suggestions_spans = _o->output_suggestions_spans;
  return libtextclassifier3::CreatePredictionMetadata(
      _fbb,
      _prediction_type,
      _task_spec,
      _output_suggestions,
      _output_suggestions_scores,
      _output_suggestions_spans);
}

namespace TensorflowLiteModelSpec_ {

inline InputNameIndexEntryT *InputNameIndexEntry::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::TensorflowLiteModelSpec_::InputNameIndexEntryT> _o = std::unique_ptr<libtextclassifier3::TensorflowLiteModelSpec_::InputNameIndexEntryT>(new InputNameIndexEntryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InputNameIndexEntry::UnPackTo(InputNameIndexEntryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = key(); if (_e) _o->key = _e->str(); }
  { auto _e = value(); _o->value = _e; }
}

inline flatbuffers::Offset<InputNameIndexEntry> InputNameIndexEntry::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InputNameIndexEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInputNameIndexEntry(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InputNameIndexEntry> CreateInputNameIndexEntry(flatbuffers::FlatBufferBuilder &_fbb, const InputNameIndexEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InputNameIndexEntryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _key = _fbb.CreateSharedString(_o->key);
  auto _value = _o->value;
  return libtextclassifier3::TensorflowLiteModelSpec_::CreateInputNameIndexEntry(
      _fbb,
      _key,
      _value);
}

}  // namespace TensorflowLiteModelSpec_

inline TensorflowLiteModelSpecT *TensorflowLiteModelSpec::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::TensorflowLiteModelSpecT> _o = std::unique_ptr<libtextclassifier3::TensorflowLiteModelSpecT>(new TensorflowLiteModelSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TensorflowLiteModelSpec::UnPackTo(TensorflowLiteModelSpecT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tflite_model(); if (_e) { _o->tflite_model.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tflite_model[_i] = _e->Get(_i); } } }
  { auto _e = input_user_id(); _o->input_user_id = _e; }
  { auto _e = input_context(); _o->input_context = _e; }
  { auto _e = input_context_length(); _o->input_context_length = _e; }
  { auto _e = input_time_diffs(); _o->input_time_diffs = _e; }
  { auto _e = input_num_suggestions(); _o->input_num_suggestions = _e; }
  { auto _e = input_token_embeddings(); _o->input_token_embeddings = _e; }
  { auto _e = input_num_tokens(); _o->input_num_tokens = _e; }
  { auto _e = output_replies(); _o->output_replies = _e; }
  { auto _e = output_replies_scores(); _o->output_replies_scores = _e; }
  { auto _e = output_sensitive_topic_score(); _o->output_sensitive_topic_score = _e; }
  { auto _e = output_triggering_score(); _o->output_triggering_score = _e; }
  { auto _e = output_actions_scores(); _o->output_actions_scores = _e; }
  { auto _e = resize_inputs(); _o->resize_inputs = _e; }
  { auto _e = input_flattened_token_embeddings(); _o->input_flattened_token_embeddings = _e; }
  { auto _e = prediction_metadata(); if (_e) { _o->prediction_metadata.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->prediction_metadata[_i] = std::unique_ptr<libtextclassifier3::PredictionMetadataT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = input_name_index(); if (_e) { _o->input_name_index.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->input_name_index[_i] = std::unique_ptr<libtextclassifier3::TensorflowLiteModelSpec_::InputNameIndexEntryT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = input_length_to_pad(); _o->input_length_to_pad = _e; }
}

inline flatbuffers::Offset<TensorflowLiteModelSpec> TensorflowLiteModelSpec::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorflowLiteModelSpecT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorflowLiteModelSpec(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorflowLiteModelSpec> CreateTensorflowLiteModelSpec(flatbuffers::FlatBufferBuilder &_fbb, const TensorflowLiteModelSpecT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorflowLiteModelSpecT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  _fbb.ForceVectorAlignment(_o->tflite_model.size(), sizeof(uint8_t), 16);
  auto _tflite_model = _o->tflite_model.size() ? _fbb.CreateVector(_o->tflite_model) : 0;
  auto _input_user_id = _o->input_user_id;
  auto _input_context = _o->input_context;
  auto _input_context_length = _o->input_context_length;
  auto _input_time_diffs = _o->input_time_diffs;
  auto _input_num_suggestions = _o->input_num_suggestions;
  auto _input_token_embeddings = _o->input_token_embeddings;
  auto _input_num_tokens = _o->input_num_tokens;
  auto _output_replies = _o->output_replies;
  auto _output_replies_scores = _o->output_replies_scores;
  auto _output_sensitive_topic_score = _o->output_sensitive_topic_score;
  auto _output_triggering_score = _o->output_triggering_score;
  auto _output_actions_scores = _o->output_actions_scores;
  auto _resize_inputs = _o->resize_inputs;
  auto _input_flattened_token_embeddings = _o->input_flattened_token_embeddings;
  auto _prediction_metadata = _o->prediction_metadata.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::PredictionMetadata>> (_o->prediction_metadata.size(), [](size_t i, _VectorArgs *__va) { return CreatePredictionMetadata(*__va->__fbb, __va->__o->prediction_metadata[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _input_name_index = _o->input_name_index.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::TensorflowLiteModelSpec_::InputNameIndexEntry>> (_o->input_name_index.size(), [](size_t i, _VectorArgs *__va) { return CreateInputNameIndexEntry(*__va->__fbb, __va->__o->input_name_index[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _input_length_to_pad = _o->input_length_to_pad;
  return libtextclassifier3::CreateTensorflowLiteModelSpec(
      _fbb,
      _tflite_model,
      _input_user_id,
      _input_context,
      _input_context_length,
      _input_time_diffs,
      _input_num_suggestions,
      _input_token_embeddings,
      _input_num_tokens,
      _output_replies,
      _output_replies_scores,
      _output_sensitive_topic_score,
      _output_triggering_score,
      _output_actions_scores,
      _resize_inputs,
      _input_flattened_token_embeddings,
      _prediction_metadata,
      _input_name_index,
      _input_length_to_pad);
}

inline ActionsTokenizerOptionsT *ActionsTokenizerOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::ActionsTokenizerOptionsT> _o = std::unique_ptr<libtextclassifier3::ActionsTokenizerOptionsT>(new ActionsTokenizerOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ActionsTokenizerOptions::UnPackTo(ActionsTokenizerOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = icu_preserve_whitespace_tokens(); _o->icu_preserve_whitespace_tokens = _e; }
  { auto _e = tokenization_codepoint_config(); if (_e) { _o->tokenization_codepoint_config.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tokenization_codepoint_config[_i] = std::unique_ptr<libtextclassifier3::TokenizationCodepointRangeT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = internal_tokenizer_codepoint_ranges(); if (_e) { _o->internal_tokenizer_codepoint_ranges.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->internal_tokenizer_codepoint_ranges[_i] = std::unique_ptr<libtextclassifier3::CodepointRangeT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = tokenize_on_script_change(); _o->tokenize_on_script_change = _e; }
}

inline flatbuffers::Offset<ActionsTokenizerOptions> ActionsTokenizerOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActionsTokenizerOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateActionsTokenizerOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ActionsTokenizerOptions> CreateActionsTokenizerOptions(flatbuffers::FlatBufferBuilder &_fbb, const ActionsTokenizerOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ActionsTokenizerOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _icu_preserve_whitespace_tokens = _o->icu_preserve_whitespace_tokens;
  auto _tokenization_codepoint_config = _o->tokenization_codepoint_config.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::TokenizationCodepointRange>> (_o->tokenization_codepoint_config.size(), [](size_t i, _VectorArgs *__va) { return CreateTokenizationCodepointRange(*__va->__fbb, __va->__o->tokenization_codepoint_config[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _internal_tokenizer_codepoint_ranges = _o->internal_tokenizer_codepoint_ranges.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::CodepointRange>> (_o->internal_tokenizer_codepoint_ranges.size(), [](size_t i, _VectorArgs *__va) { return CreateCodepointRange(*__va->__fbb, __va->__o->internal_tokenizer_codepoint_ranges[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _tokenize_on_script_change = _o->tokenize_on_script_change;
  return libtextclassifier3::CreateActionsTokenizerOptions(
      _fbb,
      _type,
      _icu_preserve_whitespace_tokens,
      _tokenization_codepoint_config,
      _internal_tokenizer_codepoint_ranges,
      _tokenize_on_script_change);
}

inline ActionsTokenFeatureProcessorOptionsT *ActionsTokenFeatureProcessorOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::ActionsTokenFeatureProcessorOptionsT> _o = std::unique_ptr<libtextclassifier3::ActionsTokenFeatureProcessorOptionsT>(new ActionsTokenFeatureProcessorOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ActionsTokenFeatureProcessorOptions::UnPackTo(ActionsTokenFeatureProcessorOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tokenizer_options(); if (_e) _o->tokenizer_options = std::unique_ptr<libtextclassifier3::ActionsTokenizerOptionsT>(_e->UnPack(_resolver)); }
  { auto _e = embedding_model(); if (_e) { _o->embedding_model.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->embedding_model[_i] = _e->Get(_i); } } }
  { auto _e = embedding_size(); _o->embedding_size = _e; }
  { auto _e = embedding_quantization_bits(); _o->embedding_quantization_bits = _e; }
  { auto _e = num_buckets(); _o->num_buckets = _e; }
  { auto _e = chargram_orders(); if (_e) { _o->chargram_orders.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->chargram_orders[_i] = _e->Get(_i); } } }
  { auto _e = extract_case_feature(); _o->extract_case_feature = _e; }
  { auto _e = unicode_aware_features(); _o->unicode_aware_features = _e; }
  { auto _e = regexp_features(); if (_e) { _o->regexp_features.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->regexp_features[_i] = _e->Get(_i)->str(); } } }
  { auto _e = remap_digits(); _o->remap_digits = _e; }
  { auto _e = lowercase_tokens(); _o->lowercase_tokens = _e; }
  { auto _e = max_token_length(); _o->max_token_length = _e; }
  { auto _e = max_num_tokens_per_message(); _o->max_num_tokens_per_message = _e; }
  { auto _e = min_num_tokens_per_message(); _o->min_num_tokens_per_message = _e; }
  { auto _e = max_num_total_tokens(); _o->max_num_total_tokens = _e; }
  { auto _e = min_num_total_tokens(); _o->min_num_total_tokens = _e; }
  { auto _e = padding_token_id(); _o->padding_token_id = _e; }
  { auto _e = start_token_id(); _o->start_token_id = _e; }
  { auto _e = end_token_id(); _o->end_token_id = _e; }
}

inline flatbuffers::Offset<ActionsTokenFeatureProcessorOptions> ActionsTokenFeatureProcessorOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActionsTokenFeatureProcessorOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateActionsTokenFeatureProcessorOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ActionsTokenFeatureProcessorOptions> CreateActionsTokenFeatureProcessorOptions(flatbuffers::FlatBufferBuilder &_fbb, const ActionsTokenFeatureProcessorOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ActionsTokenFeatureProcessorOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tokenizer_options = _o->tokenizer_options ? CreateActionsTokenizerOptions(_fbb, _o->tokenizer_options.get(), _rehasher) : 0;
  _fbb.ForceVectorAlignment(_o->embedding_model.size(), sizeof(uint8_t), 16);
  auto _embedding_model = _o->embedding_model.size() ? _fbb.CreateVector(_o->embedding_model) : 0;
  auto _embedding_size = _o->embedding_size;
  auto _embedding_quantization_bits = _o->embedding_quantization_bits;
  auto _num_buckets = _o->num_buckets;
  auto _chargram_orders = _o->chargram_orders.size() ? _fbb.CreateVector(_o->chargram_orders) : 0;
  auto _extract_case_feature = _o->extract_case_feature;
  auto _unicode_aware_features = _o->unicode_aware_features;
  auto _regexp_features = _o->regexp_features.size() ? _fbb.CreateVectorOfStrings(_o->regexp_features) : 0;
  auto _remap_digits = _o->remap_digits;
  auto _lowercase_tokens = _o->lowercase_tokens;
  auto _max_token_length = _o->max_token_length;
  auto _max_num_tokens_per_message = _o->max_num_tokens_per_message;
  auto _min_num_tokens_per_message = _o->min_num_tokens_per_message;
  auto _max_num_total_tokens = _o->max_num_total_tokens;
  auto _min_num_total_tokens = _o->min_num_total_tokens;
  auto _padding_token_id = _o->padding_token_id;
  auto _start_token_id = _o->start_token_id;
  auto _end_token_id = _o->end_token_id;
  return libtextclassifier3::CreateActionsTokenFeatureProcessorOptions(
      _fbb,
      _tokenizer_options,
      _embedding_model,
      _embedding_size,
      _embedding_quantization_bits,
      _num_buckets,
      _chargram_orders,
      _extract_case_feature,
      _unicode_aware_features,
      _regexp_features,
      _remap_digits,
      _lowercase_tokens,
      _max_token_length,
      _max_num_tokens_per_message,
      _min_num_tokens_per_message,
      _max_num_total_tokens,
      _min_num_total_tokens,
      _padding_token_id,
      _start_token_id,
      _end_token_id);
}

inline NGramLinearRegressionModelT *NGramLinearRegressionModel::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::NGramLinearRegressionModelT> _o = std::unique_ptr<libtextclassifier3::NGramLinearRegressionModelT>(new NGramLinearRegressionModelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NGramLinearRegressionModel::UnPackTo(NGramLinearRegressionModelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hashed_ngram_tokens(); if (_e) { _o->hashed_ngram_tokens.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->hashed_ngram_tokens[_i] = _e->Get(_i); } } }
  { auto _e = ngram_start_offsets(); if (_e) { _o->ngram_start_offsets.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ngram_start_offsets[_i] = _e->Get(_i); } } }
  { auto _e = ngram_weights(); if (_e) { _o->ngram_weights.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ngram_weights[_i] = _e->Get(_i); } } }
  { auto _e = default_token_weight(); _o->default_token_weight = _e; }
  { auto _e = max_denom_ngram_length(); _o->max_denom_ngram_length = _e; }
  { auto _e = max_skips(); _o->max_skips = _e; }
  { auto _e = threshold(); _o->threshold = _e; }
  { auto _e = tokenizer_options(); if (_e) _o->tokenizer_options = std::unique_ptr<libtextclassifier3::ActionsTokenizerOptionsT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<NGramLinearRegressionModel> NGramLinearRegressionModel::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NGramLinearRegressionModelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNGramLinearRegressionModel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NGramLinearRegressionModel> CreateNGramLinearRegressionModel(flatbuffers::FlatBufferBuilder &_fbb, const NGramLinearRegressionModelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NGramLinearRegressionModelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _hashed_ngram_tokens = _o->hashed_ngram_tokens.size() ? _fbb.CreateVector(_o->hashed_ngram_tokens) : 0;
  auto _ngram_start_offsets = _o->ngram_start_offsets.size() ? _fbb.CreateVector(_o->ngram_start_offsets) : 0;
  auto _ngram_weights = _o->ngram_weights.size() ? _fbb.CreateVector(_o->ngram_weights) : 0;
  auto _default_token_weight = _o->default_token_weight;
  auto _max_denom_ngram_length = _o->max_denom_ngram_length;
  auto _max_skips = _o->max_skips;
  auto _threshold = _o->threshold;
  auto _tokenizer_options = _o->tokenizer_options ? CreateActionsTokenizerOptions(_fbb, _o->tokenizer_options.get(), _rehasher) : 0;
  return libtextclassifier3::CreateNGramLinearRegressionModel(
      _fbb,
      _hashed_ngram_tokens,
      _ngram_start_offsets,
      _ngram_weights,
      _default_token_weight,
      _max_denom_ngram_length,
      _max_skips,
      _threshold,
      _tokenizer_options);
}

inline TFLiteSensitiveClassifierConfigT *TFLiteSensitiveClassifierConfig::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::TFLiteSensitiveClassifierConfigT> _o = std::unique_ptr<libtextclassifier3::TFLiteSensitiveClassifierConfigT>(new TFLiteSensitiveClassifierConfigT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TFLiteSensitiveClassifierConfig::UnPackTo(TFLiteSensitiveClassifierConfigT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = model_spec(); if (_e) _o->model_spec = std::unique_ptr<libtextclassifier3::TensorflowLiteModelSpecT>(_e->UnPack(_resolver)); }
  { auto _e = threshold(); _o->threshold = _e; }
}

inline flatbuffers::Offset<TFLiteSensitiveClassifierConfig> TFLiteSensitiveClassifierConfig::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TFLiteSensitiveClassifierConfigT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTFLiteSensitiveClassifierConfig(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TFLiteSensitiveClassifierConfig> CreateTFLiteSensitiveClassifierConfig(flatbuffers::FlatBufferBuilder &_fbb, const TFLiteSensitiveClassifierConfigT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TFLiteSensitiveClassifierConfigT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _model_spec = _o->model_spec ? CreateTensorflowLiteModelSpec(_fbb, _o->model_spec.get(), _rehasher) : 0;
  auto _threshold = _o->threshold;
  return libtextclassifier3::CreateTFLiteSensitiveClassifierConfig(
      _fbb,
      _model_spec,
      _threshold);
}

inline TriggeringPreconditionsT *TriggeringPreconditions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::TriggeringPreconditionsT> _o = std::unique_ptr<libtextclassifier3::TriggeringPreconditionsT>(new TriggeringPreconditionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TriggeringPreconditions::UnPackTo(TriggeringPreconditionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = min_smart_reply_triggering_score(); _o->min_smart_reply_triggering_score = _e; }
  { auto _e = max_sensitive_topic_score(); _o->max_sensitive_topic_score = _e; }
  { auto _e = suppress_on_sensitive_topic(); _o->suppress_on_sensitive_topic = _e; }
  { auto _e = min_input_length(); _o->min_input_length = _e; }
  { auto _e = max_input_length(); _o->max_input_length = _e; }
  { auto _e = min_locale_match_fraction(); _o->min_locale_match_fraction = _e; }
  { auto _e = handle_missing_locale_as_supported(); _o->handle_missing_locale_as_supported = _e; }
  { auto _e = handle_unknown_locale_as_supported(); _o->handle_unknown_locale_as_supported = _e; }
  { auto _e = suppress_on_low_confidence_input(); _o->suppress_on_low_confidence_input = _e; }
  { auto _e = low_confidence_rules(); if (_e) _o->low_confidence_rules = std::unique_ptr<libtextclassifier3::RulesModelT>(_e->UnPack(_resolver)); }
  { auto _e = min_reply_score_threshold(); _o->min_reply_score_threshold = _e; }
}

inline flatbuffers::Offset<TriggeringPreconditions> TriggeringPreconditions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TriggeringPreconditionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTriggeringPreconditions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TriggeringPreconditions> CreateTriggeringPreconditions(flatbuffers::FlatBufferBuilder &_fbb, const TriggeringPreconditionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TriggeringPreconditionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _min_smart_reply_triggering_score = _o->min_smart_reply_triggering_score;
  auto _max_sensitive_topic_score = _o->max_sensitive_topic_score;
  auto _suppress_on_sensitive_topic = _o->suppress_on_sensitive_topic;
  auto _min_input_length = _o->min_input_length;
  auto _max_input_length = _o->max_input_length;
  auto _min_locale_match_fraction = _o->min_locale_match_fraction;
  auto _handle_missing_locale_as_supported = _o->handle_missing_locale_as_supported;
  auto _handle_unknown_locale_as_supported = _o->handle_unknown_locale_as_supported;
  auto _suppress_on_low_confidence_input = _o->suppress_on_low_confidence_input;
  auto _low_confidence_rules = _o->low_confidence_rules ? CreateRulesModel(_fbb, _o->low_confidence_rules.get(), _rehasher) : 0;
  auto _min_reply_score_threshold = _o->min_reply_score_threshold;
  return libtextclassifier3::CreateTriggeringPreconditions(
      _fbb,
      _min_smart_reply_triggering_score,
      _max_sensitive_topic_score,
      _suppress_on_sensitive_topic,
      _min_input_length,
      _max_input_length,
      _min_locale_match_fraction,
      _handle_missing_locale_as_supported,
      _handle_unknown_locale_as_supported,
      _suppress_on_low_confidence_input,
      _low_confidence_rules,
      _min_reply_score_threshold);
}

inline ActionSuggestionSpecT *ActionSuggestionSpec::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::ActionSuggestionSpecT> _o = std::unique_ptr<libtextclassifier3::ActionSuggestionSpecT>(new ActionSuggestionSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ActionSuggestionSpec::UnPackTo(ActionSuggestionSpecT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); if (_e) _o->type = _e->str(); }
  { auto _e = response_text(); if (_e) _o->response_text = _e->str(); }
  { auto _e = score(); _o->score = _e; }
  { auto _e = serialized_entity_data(); if (_e) _o->serialized_entity_data = _e->str(); }
  { auto _e = priority_score(); _o->priority_score = _e; }
  { auto _e = entity_data(); if (_e) _o->entity_data = std::unique_ptr<libtextclassifier3::ActionsEntityDataT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<ActionSuggestionSpec> ActionSuggestionSpec::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActionSuggestionSpecT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateActionSuggestionSpec(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ActionSuggestionSpec> CreateActionSuggestionSpec(flatbuffers::FlatBufferBuilder &_fbb, const ActionSuggestionSpecT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ActionSuggestionSpecT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type.empty() ? 0 : _fbb.CreateSharedString(_o->type);
  auto _response_text = _o->response_text.empty() ? 0 : _fbb.CreateSharedString(_o->response_text);
  auto _score = _o->score;
  auto _serialized_entity_data = _o->serialized_entity_data.empty() ? 0 : _fbb.CreateSharedString(_o->serialized_entity_data);
  auto _priority_score = _o->priority_score;
  auto _entity_data = _o->entity_data ? CreateActionsEntityData(_fbb, _o->entity_data.get(), _rehasher) : 0;
  return libtextclassifier3::CreateActionSuggestionSpec(
      _fbb,
      _type,
      _response_text,
      _score,
      _serialized_entity_data,
      _priority_score,
      _entity_data);
}

inline ActionTypeOptionsT *ActionTypeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::ActionTypeOptionsT> _o = std::unique_ptr<libtextclassifier3::ActionTypeOptionsT>(new ActionTypeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ActionTypeOptions::UnPackTo(ActionTypeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = enabled(); _o->enabled = _e; }
  { auto _e = min_triggering_score(); _o->min_triggering_score = _e; }
  { auto _e = action(); if (_e) _o->action = std::unique_ptr<libtextclassifier3::ActionSuggestionSpecT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<ActionTypeOptions> ActionTypeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActionTypeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateActionTypeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ActionTypeOptions> CreateActionTypeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ActionTypeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ActionTypeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateSharedString(_o->name);
  auto _enabled = _o->enabled;
  auto _min_triggering_score = _o->min_triggering_score;
  auto _action = _o->action ? CreateActionSuggestionSpec(_fbb, _o->action.get(), _rehasher) : 0;
  return libtextclassifier3::CreateActionTypeOptions(
      _fbb,
      _name,
      _enabled,
      _min_triggering_score,
      _action);
}

namespace AnnotationActionsSpec_ {

inline AnnotationMappingT *AnnotationMapping::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::AnnotationActionsSpec_::AnnotationMappingT> _o = std::unique_ptr<libtextclassifier3::AnnotationActionsSpec_::AnnotationMappingT>(new AnnotationMappingT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AnnotationMapping::UnPackTo(AnnotationMappingT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = annotation_collection(); if (_e) _o->annotation_collection = _e->str(); }
  { auto _e = action(); if (_e) _o->action = std::unique_ptr<libtextclassifier3::ActionSuggestionSpecT>(_e->UnPack(_resolver)); }
  { auto _e = use_annotation_score(); _o->use_annotation_score = _e; }
  { auto _e = min_annotation_score(); _o->min_annotation_score = _e; }
  { auto _e = entity_field(); if (_e) _o->entity_field = std::unique_ptr<libtextclassifier3::FlatbufferFieldPathT>(_e->UnPack(_resolver)); }
  { auto _e = normalization_options(); if (_e) _o->normalization_options = std::unique_ptr<libtextclassifier3::NormalizationOptionsT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<AnnotationMapping> AnnotationMapping::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnnotationMappingT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAnnotationMapping(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AnnotationMapping> CreateAnnotationMapping(flatbuffers::FlatBufferBuilder &_fbb, const AnnotationMappingT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AnnotationMappingT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _annotation_collection = _o->annotation_collection.empty() ? 0 : _fbb.CreateSharedString(_o->annotation_collection);
  auto _action = _o->action ? CreateActionSuggestionSpec(_fbb, _o->action.get(), _rehasher) : 0;
  auto _use_annotation_score = _o->use_annotation_score;
  auto _min_annotation_score = _o->min_annotation_score;
  auto _entity_field = _o->entity_field ? CreateFlatbufferFieldPath(_fbb, _o->entity_field.get(), _rehasher) : 0;
  auto _normalization_options = _o->normalization_options ? CreateNormalizationOptions(_fbb, _o->normalization_options.get(), _rehasher) : 0;
  return libtextclassifier3::AnnotationActionsSpec_::CreateAnnotationMapping(
      _fbb,
      _annotation_collection,
      _action,
      _use_annotation_score,
      _min_annotation_score,
      _entity_field,
      _normalization_options);
}

}  // namespace AnnotationActionsSpec_

inline AnnotationActionsSpecT *AnnotationActionsSpec::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::AnnotationActionsSpecT> _o = std::unique_ptr<libtextclassifier3::AnnotationActionsSpecT>(new AnnotationActionsSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AnnotationActionsSpec::UnPackTo(AnnotationActionsSpecT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = annotation_mapping(); if (_e) { _o->annotation_mapping.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->annotation_mapping[_i] = std::unique_ptr<libtextclassifier3::AnnotationActionsSpec_::AnnotationMappingT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = deduplicate_annotations(); _o->deduplicate_annotations = _e; }
  { auto _e = annotation_usecase(); _o->annotation_usecase = _e; }
  { auto _e = max_history_from_any_person(); _o->max_history_from_any_person = _e; }
  { auto _e = max_history_from_last_person(); _o->max_history_from_last_person = _e; }
  { auto _e = include_local_user_messages(); _o->include_local_user_messages = _e; }
  { auto _e = only_until_last_sent(); _o->only_until_last_sent = _e; }
  { auto _e = is_serialized_entity_data_enabled(); _o->is_serialized_entity_data_enabled = _e; }
}

inline flatbuffers::Offset<AnnotationActionsSpec> AnnotationActionsSpec::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnnotationActionsSpecT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAnnotationActionsSpec(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AnnotationActionsSpec> CreateAnnotationActionsSpec(flatbuffers::FlatBufferBuilder &_fbb, const AnnotationActionsSpecT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AnnotationActionsSpecT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _annotation_mapping = _o->annotation_mapping.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::AnnotationActionsSpec_::AnnotationMapping>> (_o->annotation_mapping.size(), [](size_t i, _VectorArgs *__va) { return CreateAnnotationMapping(*__va->__fbb, __va->__o->annotation_mapping[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _deduplicate_annotations = _o->deduplicate_annotations;
  auto _annotation_usecase = _o->annotation_usecase;
  auto _max_history_from_any_person = _o->max_history_from_any_person;
  auto _max_history_from_last_person = _o->max_history_from_last_person;
  auto _include_local_user_messages = _o->include_local_user_messages;
  auto _only_until_last_sent = _o->only_until_last_sent;
  auto _is_serialized_entity_data_enabled = _o->is_serialized_entity_data_enabled;
  return libtextclassifier3::CreateAnnotationActionsSpec(
      _fbb,
      _annotation_mapping,
      _deduplicate_annotations,
      _annotation_usecase,
      _max_history_from_any_person,
      _max_history_from_last_person,
      _include_local_user_messages,
      _only_until_last_sent,
      _is_serialized_entity_data_enabled);
}

inline RankingOptionsT *RankingOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::RankingOptionsT> _o = std::unique_ptr<libtextclassifier3::RankingOptionsT>(new RankingOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RankingOptions::UnPackTo(RankingOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = deduplicate_suggestions(); _o->deduplicate_suggestions = _e; }
  { auto _e = deduplicate_suggestions_by_span(); _o->deduplicate_suggestions_by_span = _e; }
  { auto _e = lua_ranking_script(); if (_e) _o->lua_ranking_script = _e->str(); }
  { auto _e = compressed_lua_ranking_script(); if (_e) _o->compressed_lua_ranking_script = std::unique_ptr<libtextclassifier3::CompressedBufferT>(_e->UnPack(_resolver)); }
  { auto _e = suppress_smart_replies_with_actions(); _o->suppress_smart_replies_with_actions = _e; }
  { auto _e = group_by_annotations(); _o->group_by_annotations = _e; }
}

inline flatbuffers::Offset<RankingOptions> RankingOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RankingOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRankingOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RankingOptions> CreateRankingOptions(flatbuffers::FlatBufferBuilder &_fbb, const RankingOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RankingOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _deduplicate_suggestions = _o->deduplicate_suggestions;
  auto _deduplicate_suggestions_by_span = _o->deduplicate_suggestions_by_span;
  auto _lua_ranking_script = _o->lua_ranking_script.empty() ? 0 : _fbb.CreateSharedString(_o->lua_ranking_script);
  auto _compressed_lua_ranking_script = _o->compressed_lua_ranking_script ? CreateCompressedBuffer(_fbb, _o->compressed_lua_ranking_script.get(), _rehasher) : 0;
  auto _suppress_smart_replies_with_actions = _o->suppress_smart_replies_with_actions;
  auto _group_by_annotations = _o->group_by_annotations;
  return libtextclassifier3::CreateRankingOptions(
      _fbb,
      _deduplicate_suggestions,
      _deduplicate_suggestions_by_span,
      _lua_ranking_script,
      _compressed_lua_ranking_script,
      _suppress_smart_replies_with_actions,
      _group_by_annotations);
}

namespace RulesModel_ {
namespace RuleActionSpec_ {

inline RuleCapturingGroupT *RuleCapturingGroup::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::RulesModel_::RuleActionSpec_::RuleCapturingGroupT> _o = std::unique_ptr<libtextclassifier3::RulesModel_::RuleActionSpec_::RuleCapturingGroupT>(new RuleCapturingGroupT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RuleCapturingGroup::UnPackTo(RuleCapturingGroupT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = group_id(); _o->group_id = _e; }
  { auto _e = entity_field(); if (_e) _o->entity_field = std::unique_ptr<libtextclassifier3::FlatbufferFieldPathT>(_e->UnPack(_resolver)); }
  { auto _e = annotation_type(); if (_e) _o->annotation_type = _e->str(); }
  { auto _e = annotation_name(); if (_e) _o->annotation_name = _e->str(); }
  { auto _e = text_reply(); if (_e) _o->text_reply = std::unique_ptr<libtextclassifier3::ActionSuggestionSpecT>(_e->UnPack(_resolver)); }
  { auto _e = normalization_options(); if (_e) _o->normalization_options = std::unique_ptr<libtextclassifier3::NormalizationOptionsT>(_e->UnPack(_resolver)); }
  { auto _e = use_annotation_match(); _o->use_annotation_match = _e; }
  { auto _e = entity_data(); if (_e) _o->entity_data = std::unique_ptr<libtextclassifier3::ActionsEntityDataT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<RuleCapturingGroup> RuleCapturingGroup::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RuleCapturingGroupT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRuleCapturingGroup(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RuleCapturingGroup> CreateRuleCapturingGroup(flatbuffers::FlatBufferBuilder &_fbb, const RuleCapturingGroupT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RuleCapturingGroupT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _group_id = _o->group_id;
  auto _entity_field = _o->entity_field ? CreateFlatbufferFieldPath(_fbb, _o->entity_field.get(), _rehasher) : 0;
  auto _annotation_type = _o->annotation_type.empty() ? 0 : _fbb.CreateSharedString(_o->annotation_type);
  auto _annotation_name = _o->annotation_name.empty() ? 0 : _fbb.CreateSharedString(_o->annotation_name);
  auto _text_reply = _o->text_reply ? CreateActionSuggestionSpec(_fbb, _o->text_reply.get(), _rehasher) : 0;
  auto _normalization_options = _o->normalization_options ? CreateNormalizationOptions(_fbb, _o->normalization_options.get(), _rehasher) : 0;
  auto _use_annotation_match = _o->use_annotation_match;
  auto _entity_data = _o->entity_data ? CreateActionsEntityData(_fbb, _o->entity_data.get(), _rehasher) : 0;
  return libtextclassifier3::RulesModel_::RuleActionSpec_::CreateRuleCapturingGroup(
      _fbb,
      _group_id,
      _entity_field,
      _annotation_type,
      _annotation_name,
      _text_reply,
      _normalization_options,
      _use_annotation_match,
      _entity_data);
}

}  // namespace RuleActionSpec_

inline RuleActionSpecT *RuleActionSpec::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::RulesModel_::RuleActionSpecT> _o = std::unique_ptr<libtextclassifier3::RulesModel_::RuleActionSpecT>(new RuleActionSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RuleActionSpec::UnPackTo(RuleActionSpecT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = action(); if (_e) _o->action = std::unique_ptr<libtextclassifier3::ActionSuggestionSpecT>(_e->UnPack(_resolver)); }
  { auto _e = capturing_group(); if (_e) { _o->capturing_group.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->capturing_group[_i] = std::unique_ptr<libtextclassifier3::RulesModel_::RuleActionSpec_::RuleCapturingGroupT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<RuleActionSpec> RuleActionSpec::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RuleActionSpecT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRuleActionSpec(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RuleActionSpec> CreateRuleActionSpec(flatbuffers::FlatBufferBuilder &_fbb, const RuleActionSpecT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RuleActionSpecT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _action = _o->action ? CreateActionSuggestionSpec(_fbb, _o->action.get(), _rehasher) : 0;
  auto _capturing_group = _o->capturing_group.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RuleActionSpec_::RuleCapturingGroup>> (_o->capturing_group.size(), [](size_t i, _VectorArgs *__va) { return CreateRuleCapturingGroup(*__va->__fbb, __va->__o->capturing_group[i].get(), __va->__rehasher); }, &_va ) : 0;
  return libtextclassifier3::RulesModel_::CreateRuleActionSpec(
      _fbb,
      _action,
      _capturing_group);
}

inline RegexRuleT *RegexRule::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::RulesModel_::RegexRuleT> _o = std::unique_ptr<libtextclassifier3::RulesModel_::RegexRuleT>(new RegexRuleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RegexRule::UnPackTo(RegexRuleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pattern(); if (_e) _o->pattern = _e->str(); }
  { auto _e = compressed_pattern(); if (_e) _o->compressed_pattern = std::unique_ptr<libtextclassifier3::CompressedBufferT>(_e->UnPack(_resolver)); }
  { auto _e = actions(); if (_e) { _o->actions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->actions[_i] = std::unique_ptr<libtextclassifier3::RulesModel_::RuleActionSpecT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = output_pattern(); if (_e) _o->output_pattern = _e->str(); }
  { auto _e = compressed_output_pattern(); if (_e) _o->compressed_output_pattern = std::unique_ptr<libtextclassifier3::CompressedBufferT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<RegexRule> RegexRule::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegexRuleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRegexRule(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RegexRule> CreateRegexRule(flatbuffers::FlatBufferBuilder &_fbb, const RegexRuleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RegexRuleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pattern = _o->pattern.empty() ? 0 : _fbb.CreateSharedString(_o->pattern);
  auto _compressed_pattern = _o->compressed_pattern ? CreateCompressedBuffer(_fbb, _o->compressed_pattern.get(), _rehasher) : 0;
  auto _actions = _o->actions.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RuleActionSpec>> (_o->actions.size(), [](size_t i, _VectorArgs *__va) { return CreateRuleActionSpec(*__va->__fbb, __va->__o->actions[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _output_pattern = _o->output_pattern.empty() ? 0 : _fbb.CreateSharedString(_o->output_pattern);
  auto _compressed_output_pattern = _o->compressed_output_pattern ? CreateCompressedBuffer(_fbb, _o->compressed_output_pattern.get(), _rehasher) : 0;
  return libtextclassifier3::RulesModel_::CreateRegexRule(
      _fbb,
      _pattern,
      _compressed_pattern,
      _actions,
      _output_pattern,
      _compressed_output_pattern);
}

namespace GrammarRules_ {

inline RuleMatchT *RuleMatch::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::RulesModel_::GrammarRules_::RuleMatchT> _o = std::unique_ptr<libtextclassifier3::RulesModel_::GrammarRules_::RuleMatchT>(new RuleMatchT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RuleMatch::UnPackTo(RuleMatchT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = action_id(); if (_e) { _o->action_id.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->action_id[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<RuleMatch> RuleMatch::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RuleMatchT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRuleMatch(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RuleMatch> CreateRuleMatch(flatbuffers::FlatBufferBuilder &_fbb, const RuleMatchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RuleMatchT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _action_id = _o->action_id.size() ? _fbb.CreateVector(_o->action_id) : 0;
  return libtextclassifier3::RulesModel_::GrammarRules_::CreateRuleMatch(
      _fbb,
      _action_id);
}

}  // namespace GrammarRules_

inline GrammarRulesT *GrammarRules::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::RulesModel_::GrammarRulesT> _o = std::unique_ptr<libtextclassifier3::RulesModel_::GrammarRulesT>(new GrammarRulesT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GrammarRules::UnPackTo(GrammarRulesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tokenizer_options(); if (_e) _o->tokenizer_options = std::unique_ptr<libtextclassifier3::ActionsTokenizerOptionsT>(_e->UnPack(_resolver)); }
  { auto _e = rules(); if (_e) _o->rules = std::unique_ptr<libtextclassifier3::grammar::RulesSetT>(_e->UnPack(_resolver)); }
  { auto _e = rule_match(); if (_e) { _o->rule_match.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rule_match[_i] = std::unique_ptr<libtextclassifier3::RulesModel_::GrammarRules_::RuleMatchT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = actions(); if (_e) { _o->actions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->actions[_i] = std::unique_ptr<libtextclassifier3::RulesModel_::RuleActionSpecT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<GrammarRules> GrammarRules::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GrammarRulesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGrammarRules(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GrammarRules> CreateGrammarRules(flatbuffers::FlatBufferBuilder &_fbb, const GrammarRulesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GrammarRulesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tokenizer_options = _o->tokenizer_options ? CreateActionsTokenizerOptions(_fbb, _o->tokenizer_options.get(), _rehasher) : 0;
  auto _rules = _o->rules ? CreateRulesSet(_fbb, _o->rules.get(), _rehasher) : 0;
  auto _rule_match = _o->rule_match.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::RulesModel_::GrammarRules_::RuleMatch>> (_o->rule_match.size(), [](size_t i, _VectorArgs *__va) { return CreateRuleMatch(*__va->__fbb, __va->__o->rule_match[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _actions = _o->actions.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RuleActionSpec>> (_o->actions.size(), [](size_t i, _VectorArgs *__va) { return CreateRuleActionSpec(*__va->__fbb, __va->__o->actions[i].get(), __va->__rehasher); }, &_va ) : 0;
  return libtextclassifier3::RulesModel_::CreateGrammarRules(
      _fbb,
      _tokenizer_options,
      _rules,
      _rule_match,
      _actions);
}

}  // namespace RulesModel_

inline RulesModelT *RulesModel::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::RulesModelT> _o = std::unique_ptr<libtextclassifier3::RulesModelT>(new RulesModelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RulesModel::UnPackTo(RulesModelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = regex_rule(); if (_e) { _o->regex_rule.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->regex_rule[_i] = std::unique_ptr<libtextclassifier3::RulesModel_::RegexRuleT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = lazy_regex_compilation(); _o->lazy_regex_compilation = _e; }
  { auto _e = grammar_rules(); if (_e) _o->grammar_rules = std::unique_ptr<libtextclassifier3::RulesModel_::GrammarRulesT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<RulesModel> RulesModel::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RulesModelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRulesModel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RulesModel> CreateRulesModel(flatbuffers::FlatBufferBuilder &_fbb, const RulesModelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RulesModelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _regex_rule = _o->regex_rule.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::RulesModel_::RegexRule>> (_o->regex_rule.size(), [](size_t i, _VectorArgs *__va) { return CreateRegexRule(*__va->__fbb, __va->__o->regex_rule[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _lazy_regex_compilation = _o->lazy_regex_compilation;
  auto _grammar_rules = _o->grammar_rules ? CreateGrammarRules(_fbb, _o->grammar_rules.get(), _rehasher) : 0;
  return libtextclassifier3::CreateRulesModel(
      _fbb,
      _regex_rule,
      _lazy_regex_compilation,
      _grammar_rules);
}

inline ActionsModelT *ActionsModel::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::ActionsModelT> _o = std::unique_ptr<libtextclassifier3::ActionsModelT>(new ActionsModelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ActionsModel::UnPackTo(ActionsModelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = locales(); if (_e) _o->locales = _e->str(); }
  { auto _e = version(); _o->version = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = tflite_model_spec(); if (_e) _o->tflite_model_spec = std::unique_ptr<libtextclassifier3::TensorflowLiteModelSpecT>(_e->UnPack(_resolver)); }
  { auto _e = smart_reply_action_type(); if (_e) _o->smart_reply_action_type = _e->str(); }
  { auto _e = action_type(); if (_e) { _o->action_type.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->action_type[_i] = std::unique_ptr<libtextclassifier3::ActionTypeOptionsT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = preconditions(); if (_e) _o->preconditions = std::unique_ptr<libtextclassifier3::TriggeringPreconditionsT>(_e->UnPack(_resolver)); }
  { auto _e = num_smart_replies(); _o->num_smart_replies = _e; }
  { auto _e = max_conversation_history_length(); _o->max_conversation_history_length = _e; }
  { auto _e = annotation_actions_spec(); if (_e) _o->annotation_actions_spec = std::unique_ptr<libtextclassifier3::AnnotationActionsSpecT>(_e->UnPack(_resolver)); }
  { auto _e = rules(); if (_e) _o->rules = std::unique_ptr<libtextclassifier3::RulesModelT>(_e->UnPack(_resolver)); }
  { auto _e = android_intent_options(); if (_e) _o->android_intent_options = std::unique_ptr<libtextclassifier3::IntentFactoryModelT>(_e->UnPack(_resolver)); }
  { auto _e = resources(); if (_e) _o->resources = std::unique_ptr<libtextclassifier3::ResourcePoolT>(_e->UnPack(_resolver)); }
  { auto _e = actions_entity_data_schema(); if (_e) { _o->actions_entity_data_schema.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->actions_entity_data_schema[_i] = _e->Get(_i); } } }
  { auto _e = ranking_options(); if (_e) _o->ranking_options = std::unique_ptr<libtextclassifier3::RankingOptionsT>(_e->UnPack(_resolver)); }
  { auto _e = lua_actions_script(); if (_e) _o->lua_actions_script = _e->str(); }
  { auto _e = compressed_lua_actions_script(); if (_e) _o->compressed_lua_actions_script = std::unique_ptr<libtextclassifier3::CompressedBufferT>(_e->UnPack(_resolver)); }
  { auto _e = low_confidence_rules(); if (_e) _o->low_confidence_rules = std::unique_ptr<libtextclassifier3::RulesModelT>(_e->UnPack(_resolver)); }
  { auto _e = low_confidence_ngram_model(); if (_e) _o->low_confidence_ngram_model = std::unique_ptr<libtextclassifier3::NGramLinearRegressionModelT>(_e->UnPack(_resolver)); }
  { auto _e = feature_processor_options(); if (_e) _o->feature_processor_options = std::unique_ptr<libtextclassifier3::ActionsTokenFeatureProcessorOptionsT>(_e->UnPack(_resolver)); }
  { auto _e = low_confidence_tflite_model(); if (_e) _o->low_confidence_tflite_model = std::unique_ptr<libtextclassifier3::TFLiteSensitiveClassifierConfigT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<ActionsModel> ActionsModel::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActionsModelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateActionsModel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ActionsModel> CreateActionsModel(flatbuffers::FlatBufferBuilder &_fbb, const ActionsModelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ActionsModelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _locales = _o->locales.empty() ? 0 : _fbb.CreateSharedString(_o->locales);
  auto _version = _o->version;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateSharedString(_o->name);
  auto _tflite_model_spec = _o->tflite_model_spec ? CreateTensorflowLiteModelSpec(_fbb, _o->tflite_model_spec.get(), _rehasher) : 0;
  auto _smart_reply_action_type = _o->smart_reply_action_type.empty() ? 0 : _fbb.CreateSharedString(_o->smart_reply_action_type);
  auto _action_type = _o->action_type.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::ActionTypeOptions>> (_o->action_type.size(), [](size_t i, _VectorArgs *__va) { return CreateActionTypeOptions(*__va->__fbb, __va->__o->action_type[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _preconditions = _o->preconditions ? CreateTriggeringPreconditions(_fbb, _o->preconditions.get(), _rehasher) : 0;
  auto _num_smart_replies = _o->num_smart_replies;
  auto _max_conversation_history_length = _o->max_conversation_history_length;
  auto _annotation_actions_spec = _o->annotation_actions_spec ? CreateAnnotationActionsSpec(_fbb, _o->annotation_actions_spec.get(), _rehasher) : 0;
  auto _rules = _o->rules ? CreateRulesModel(_fbb, _o->rules.get(), _rehasher) : 0;
  auto _android_intent_options = _o->android_intent_options ? CreateIntentFactoryModel(_fbb, _o->android_intent_options.get(), _rehasher) : 0;
  auto _resources = _o->resources ? CreateResourcePool(_fbb, _o->resources.get(), _rehasher) : 0;
  auto _actions_entity_data_schema = _o->actions_entity_data_schema.size() ? _fbb.CreateVector(_o->actions_entity_data_schema) : 0;
  auto _ranking_options = _o->ranking_options ? CreateRankingOptions(_fbb, _o->ranking_options.get(), _rehasher) : 0;
  auto _lua_actions_script = _o->lua_actions_script.empty() ? 0 : _fbb.CreateSharedString(_o->lua_actions_script);
  auto _compressed_lua_actions_script = _o->compressed_lua_actions_script ? CreateCompressedBuffer(_fbb, _o->compressed_lua_actions_script.get(), _rehasher) : 0;
  auto _low_confidence_rules = _o->low_confidence_rules ? CreateRulesModel(_fbb, _o->low_confidence_rules.get(), _rehasher) : 0;
  auto _low_confidence_ngram_model = _o->low_confidence_ngram_model ? CreateNGramLinearRegressionModel(_fbb, _o->low_confidence_ngram_model.get(), _rehasher) : 0;
  auto _feature_processor_options = _o->feature_processor_options ? CreateActionsTokenFeatureProcessorOptions(_fbb, _o->feature_processor_options.get(), _rehasher) : 0;
  auto _low_confidence_tflite_model = _o->low_confidence_tflite_model ? CreateTFLiteSensitiveClassifierConfig(_fbb, _o->low_confidence_tflite_model.get(), _rehasher) : 0;
  return libtextclassifier3::CreateActionsModel(
      _fbb,
      _locales,
      _version,
      _name,
      _tflite_model_spec,
      _smart_reply_action_type,
      _action_type,
      _preconditions,
      _num_smart_replies,
      _max_conversation_history_length,
      _annotation_actions_spec,
      _rules,
      _android_intent_options,
      _resources,
      _actions_entity_data_schema,
      _ranking_options,
      _lua_actions_script,
      _compressed_lua_actions_script,
      _low_confidence_rules,
      _low_confidence_ngram_model,
      _feature_processor_options,
      _low_confidence_tflite_model);
}

inline const libtextclassifier3::ActionsModel *GetActionsModel(const void *buf) {
  return flatbuffers::GetRoot<libtextclassifier3::ActionsModel>(buf);
}

inline const libtextclassifier3::ActionsModel *GetSizePrefixedActionsModel(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<libtextclassifier3::ActionsModel>(buf);
}

inline const char *ActionsModelIdentifier() {
  return "TC3A";
}

inline bool ActionsModelBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ActionsModelIdentifier());
}

inline bool VerifyActionsModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<libtextclassifier3::ActionsModel>(ActionsModelIdentifier());
}

inline bool VerifySizePrefixedActionsModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<libtextclassifier3::ActionsModel>(ActionsModelIdentifier());
}

inline void FinishActionsModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<libtextclassifier3::ActionsModel> root) {
  fbb.Finish(root, ActionsModelIdentifier());
}

inline void FinishSizePrefixedActionsModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<libtextclassifier3::ActionsModel> root) {
  fbb.FinishSizePrefixed(root, ActionsModelIdentifier());
}

inline std::unique_ptr<libtextclassifier3::ActionsModelT> UnPackActionsModel(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<libtextclassifier3::ActionsModelT>(GetActionsModel(buf)->UnPack(res));
}

inline std::unique_ptr<libtextclassifier3::ActionsModelT> UnPackSizePrefixedActionsModel(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<libtextclassifier3::ActionsModelT>(GetSizePrefixedActionsModel(buf)->UnPack(res));
}

}  // namespace libtextclassifier3

#endif  // FLATBUFFERS_GENERATED_ACTIONSMODEL_LIBTEXTCLASSIFIER3_H_
