// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EXPRESSION_LIBTEXTCLASSIFIER3_GRAMMAR_H_
#define FLATBUFFERS_GENERATED_EXPRESSION_LIBTEXTCLASSIFIER3_GRAMMAR_H_

#include "flatbuffers/flatbuffers.h"

#include "utils/flatbuffers/flatbuffers_generated.h"

namespace libtextclassifier3 {
namespace grammar {

struct SemanticExpression;
struct SemanticExpressionBuilder;
struct SemanticExpressionT;

struct ConstValueExpression;
struct ConstValueExpressionBuilder;
struct ConstValueExpressionT;

struct ConstituentExpression;
struct ConstituentExpressionBuilder;
struct ConstituentExpressionT;

namespace ComposeExpression_ {

struct Field;
struct FieldBuilder;
struct FieldT;

}  // namespace ComposeExpression_

struct ComposeExpression;
struct ComposeExpressionBuilder;
struct ComposeExpressionT;

struct SpanAsStringExpression;
struct SpanAsStringExpressionBuilder;
struct SpanAsStringExpressionT;

struct ParseNumberExpression;
struct ParseNumberExpressionBuilder;
struct ParseNumberExpressionT;

struct MergeValueExpression;
struct MergeValueExpressionBuilder;
struct MergeValueExpressionT;

struct ArithmeticExpression;
struct ArithmeticExpressionBuilder;
struct ArithmeticExpressionT;

namespace SemanticExpression_ {

enum Expression {
  Expression_NONE = 0,
  Expression_ConstValueExpression = 1,
  Expression_ConstituentExpression = 2,
  Expression_ComposeExpression = 3,
  Expression_SpanAsStringExpression = 4,
  Expression_ParseNumberExpression = 5,
  Expression_MergeValueExpression = 6,
  Expression_ArithmeticExpression = 7,
  Expression_MIN = Expression_NONE,
  Expression_MAX = Expression_ArithmeticExpression
};

inline const Expression (&EnumValuesExpression())[8] {
  static const Expression values[] = {
    Expression_NONE,
    Expression_ConstValueExpression,
    Expression_ConstituentExpression,
    Expression_ComposeExpression,
    Expression_SpanAsStringExpression,
    Expression_ParseNumberExpression,
    Expression_MergeValueExpression,
    Expression_ArithmeticExpression
  };
  return values;
}

inline const char * const *EnumNamesExpression() {
  static const char * const names[9] = {
    "NONE",
    "ConstValueExpression",
    "ConstituentExpression",
    "ComposeExpression",
    "SpanAsStringExpression",
    "ParseNumberExpression",
    "MergeValueExpression",
    "ArithmeticExpression",
    nullptr
  };
  return names;
}

inline const char *EnumNameExpression(Expression e) {
  if (flatbuffers::IsOutRange(e, Expression_NONE, Expression_ArithmeticExpression)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExpression()[index];
}

template<typename T> struct ExpressionTraits {
  static const Expression enum_value = Expression_NONE;
};

template<> struct ExpressionTraits<libtextclassifier3::grammar::ConstValueExpression> {
  static const Expression enum_value = Expression_ConstValueExpression;
};

template<> struct ExpressionTraits<libtextclassifier3::grammar::ConstituentExpression> {
  static const Expression enum_value = Expression_ConstituentExpression;
};

template<> struct ExpressionTraits<libtextclassifier3::grammar::ComposeExpression> {
  static const Expression enum_value = Expression_ComposeExpression;
};

template<> struct ExpressionTraits<libtextclassifier3::grammar::SpanAsStringExpression> {
  static const Expression enum_value = Expression_SpanAsStringExpression;
};

template<> struct ExpressionTraits<libtextclassifier3::grammar::ParseNumberExpression> {
  static const Expression enum_value = Expression_ParseNumberExpression;
};

template<> struct ExpressionTraits<libtextclassifier3::grammar::MergeValueExpression> {
  static const Expression enum_value = Expression_MergeValueExpression;
};

template<> struct ExpressionTraits<libtextclassifier3::grammar::ArithmeticExpression> {
  static const Expression enum_value = Expression_ArithmeticExpression;
};

struct ExpressionUnion {
  Expression type;
  void *value;

  ExpressionUnion() : type(Expression_NONE), value(nullptr) {}
  ExpressionUnion(ExpressionUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Expression_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ExpressionUnion(const ExpressionUnion &);
  ExpressionUnion &operator=(const ExpressionUnion &u)
    { ExpressionUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ExpressionUnion &operator=(ExpressionUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ExpressionUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = ExpressionTraits<typename RT::TableType>::enum_value;
    if (type != Expression_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, Expression type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  libtextclassifier3::grammar::ConstValueExpressionT *AsConstValueExpression() {
    return type == Expression_ConstValueExpression ?
      reinterpret_cast<libtextclassifier3::grammar::ConstValueExpressionT *>(value) : nullptr;
  }
  const libtextclassifier3::grammar::ConstValueExpressionT *AsConstValueExpression() const {
    return type == Expression_ConstValueExpression ?
      reinterpret_cast<const libtextclassifier3::grammar::ConstValueExpressionT *>(value) : nullptr;
  }
  libtextclassifier3::grammar::ConstituentExpressionT *AsConstituentExpression() {
    return type == Expression_ConstituentExpression ?
      reinterpret_cast<libtextclassifier3::grammar::ConstituentExpressionT *>(value) : nullptr;
  }
  const libtextclassifier3::grammar::ConstituentExpressionT *AsConstituentExpression() const {
    return type == Expression_ConstituentExpression ?
      reinterpret_cast<const libtextclassifier3::grammar::ConstituentExpressionT *>(value) : nullptr;
  }
  libtextclassifier3::grammar::ComposeExpressionT *AsComposeExpression() {
    return type == Expression_ComposeExpression ?
      reinterpret_cast<libtextclassifier3::grammar::ComposeExpressionT *>(value) : nullptr;
  }
  const libtextclassifier3::grammar::ComposeExpressionT *AsComposeExpression() const {
    return type == Expression_ComposeExpression ?
      reinterpret_cast<const libtextclassifier3::grammar::ComposeExpressionT *>(value) : nullptr;
  }
  libtextclassifier3::grammar::SpanAsStringExpressionT *AsSpanAsStringExpression() {
    return type == Expression_SpanAsStringExpression ?
      reinterpret_cast<libtextclassifier3::grammar::SpanAsStringExpressionT *>(value) : nullptr;
  }
  const libtextclassifier3::grammar::SpanAsStringExpressionT *AsSpanAsStringExpression() const {
    return type == Expression_SpanAsStringExpression ?
      reinterpret_cast<const libtextclassifier3::grammar::SpanAsStringExpressionT *>(value) : nullptr;
  }
  libtextclassifier3::grammar::ParseNumberExpressionT *AsParseNumberExpression() {
    return type == Expression_ParseNumberExpression ?
      reinterpret_cast<libtextclassifier3::grammar::ParseNumberExpressionT *>(value) : nullptr;
  }
  const libtextclassifier3::grammar::ParseNumberExpressionT *AsParseNumberExpression() const {
    return type == Expression_ParseNumberExpression ?
      reinterpret_cast<const libtextclassifier3::grammar::ParseNumberExpressionT *>(value) : nullptr;
  }
  libtextclassifier3::grammar::MergeValueExpressionT *AsMergeValueExpression() {
    return type == Expression_MergeValueExpression ?
      reinterpret_cast<libtextclassifier3::grammar::MergeValueExpressionT *>(value) : nullptr;
  }
  const libtextclassifier3::grammar::MergeValueExpressionT *AsMergeValueExpression() const {
    return type == Expression_MergeValueExpression ?
      reinterpret_cast<const libtextclassifier3::grammar::MergeValueExpressionT *>(value) : nullptr;
  }
  libtextclassifier3::grammar::ArithmeticExpressionT *AsArithmeticExpression() {
    return type == Expression_ArithmeticExpression ?
      reinterpret_cast<libtextclassifier3::grammar::ArithmeticExpressionT *>(value) : nullptr;
  }
  const libtextclassifier3::grammar::ArithmeticExpressionT *AsArithmeticExpression() const {
    return type == Expression_ArithmeticExpression ?
      reinterpret_cast<const libtextclassifier3::grammar::ArithmeticExpressionT *>(value) : nullptr;
  }
};

bool VerifyExpression(flatbuffers::Verifier &verifier, const void *obj, Expression type);
bool VerifyExpressionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

}  // namespace SemanticExpression_

namespace ArithmeticExpression_ {

enum Operator {
  Operator_NO_OP = 0,
  Operator_OP_ADD = 1,
  Operator_OP_MUL = 2,
  Operator_OP_MAX = 3,
  Operator_OP_MIN = 4,
  Operator_MIN = Operator_NO_OP,
  Operator_MAX = Operator_OP_MIN
};

inline const Operator (&EnumValuesOperator())[5] {
  static const Operator values[] = {
    Operator_NO_OP,
    Operator_OP_ADD,
    Operator_OP_MUL,
    Operator_OP_MAX,
    Operator_OP_MIN
  };
  return values;
}

inline const char * const *EnumNamesOperator() {
  static const char * const names[6] = {
    "NO_OP",
    "OP_ADD",
    "OP_MUL",
    "OP_MAX",
    "OP_MIN",
    nullptr
  };
  return names;
}

inline const char *EnumNameOperator(Operator e) {
  if (flatbuffers::IsOutRange(e, Operator_NO_OP, Operator_OP_MIN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOperator()[index];
}

}  // namespace ArithmeticExpression_

struct SemanticExpressionT : public flatbuffers::NativeTable {
  typedef SemanticExpression TableType;
  libtextclassifier3::grammar::SemanticExpression_::ExpressionUnion expression;
  SemanticExpressionT() {
  }
};

struct SemanticExpression FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SemanticExpressionT NativeTableType;
  typedef SemanticExpressionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXPRESSION_TYPE = 4,
    VT_EXPRESSION = 6
  };
  libtextclassifier3::grammar::SemanticExpression_::Expression expression_type() const {
    return static_cast<libtextclassifier3::grammar::SemanticExpression_::Expression>(GetField<uint8_t>(VT_EXPRESSION_TYPE, 0));
  }
  const void *expression() const {
    return GetPointer<const void *>(VT_EXPRESSION);
  }
  template<typename T> const T *expression_as() const;
  const libtextclassifier3::grammar::ConstValueExpression *expression_as_ConstValueExpression() const {
    return expression_type() == libtextclassifier3::grammar::SemanticExpression_::Expression_ConstValueExpression ? static_cast<const libtextclassifier3::grammar::ConstValueExpression *>(expression()) : nullptr;
  }
  const libtextclassifier3::grammar::ConstituentExpression *expression_as_ConstituentExpression() const {
    return expression_type() == libtextclassifier3::grammar::SemanticExpression_::Expression_ConstituentExpression ? static_cast<const libtextclassifier3::grammar::ConstituentExpression *>(expression()) : nullptr;
  }
  const libtextclassifier3::grammar::ComposeExpression *expression_as_ComposeExpression() const {
    return expression_type() == libtextclassifier3::grammar::SemanticExpression_::Expression_ComposeExpression ? static_cast<const libtextclassifier3::grammar::ComposeExpression *>(expression()) : nullptr;
  }
  const libtextclassifier3::grammar::SpanAsStringExpression *expression_as_SpanAsStringExpression() const {
    return expression_type() == libtextclassifier3::grammar::SemanticExpression_::Expression_SpanAsStringExpression ? static_cast<const libtextclassifier3::grammar::SpanAsStringExpression *>(expression()) : nullptr;
  }
  const libtextclassifier3::grammar::ParseNumberExpression *expression_as_ParseNumberExpression() const {
    return expression_type() == libtextclassifier3::grammar::SemanticExpression_::Expression_ParseNumberExpression ? static_cast<const libtextclassifier3::grammar::ParseNumberExpression *>(expression()) : nullptr;
  }
  const libtextclassifier3::grammar::MergeValueExpression *expression_as_MergeValueExpression() const {
    return expression_type() == libtextclassifier3::grammar::SemanticExpression_::Expression_MergeValueExpression ? static_cast<const libtextclassifier3::grammar::MergeValueExpression *>(expression()) : nullptr;
  }
  const libtextclassifier3::grammar::ArithmeticExpression *expression_as_ArithmeticExpression() const {
    return expression_type() == libtextclassifier3::grammar::SemanticExpression_::Expression_ArithmeticExpression ? static_cast<const libtextclassifier3::grammar::ArithmeticExpression *>(expression()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EXPRESSION_TYPE) &&
           VerifyOffset(verifier, VT_EXPRESSION) &&
           VerifyExpression(verifier, expression(), expression_type()) &&
           verifier.EndTable();
  }
  SemanticExpressionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SemanticExpressionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SemanticExpression> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SemanticExpressionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const libtextclassifier3::grammar::ConstValueExpression *SemanticExpression::expression_as<libtextclassifier3::grammar::ConstValueExpression>() const {
  return expression_as_ConstValueExpression();
}

template<> inline const libtextclassifier3::grammar::ConstituentExpression *SemanticExpression::expression_as<libtextclassifier3::grammar::ConstituentExpression>() const {
  return expression_as_ConstituentExpression();
}

template<> inline const libtextclassifier3::grammar::ComposeExpression *SemanticExpression::expression_as<libtextclassifier3::grammar::ComposeExpression>() const {
  return expression_as_ComposeExpression();
}

template<> inline const libtextclassifier3::grammar::SpanAsStringExpression *SemanticExpression::expression_as<libtextclassifier3::grammar::SpanAsStringExpression>() const {
  return expression_as_SpanAsStringExpression();
}

template<> inline const libtextclassifier3::grammar::ParseNumberExpression *SemanticExpression::expression_as<libtextclassifier3::grammar::ParseNumberExpression>() const {
  return expression_as_ParseNumberExpression();
}

template<> inline const libtextclassifier3::grammar::MergeValueExpression *SemanticExpression::expression_as<libtextclassifier3::grammar::MergeValueExpression>() const {
  return expression_as_MergeValueExpression();
}

template<> inline const libtextclassifier3::grammar::ArithmeticExpression *SemanticExpression::expression_as<libtextclassifier3::grammar::ArithmeticExpression>() const {
  return expression_as_ArithmeticExpression();
}

struct SemanticExpressionBuilder {
  typedef SemanticExpression Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_expression_type(libtextclassifier3::grammar::SemanticExpression_::Expression expression_type) {
    fbb_.AddElement<uint8_t>(SemanticExpression::VT_EXPRESSION_TYPE, static_cast<uint8_t>(expression_type), 0);
  }
  void add_expression(flatbuffers::Offset<void> expression) {
    fbb_.AddOffset(SemanticExpression::VT_EXPRESSION, expression);
  }
  explicit SemanticExpressionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SemanticExpressionBuilder &operator=(const SemanticExpressionBuilder &);
  flatbuffers::Offset<SemanticExpression> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SemanticExpression>(end);
    return o;
  }
};

inline flatbuffers::Offset<SemanticExpression> CreateSemanticExpression(
    flatbuffers::FlatBufferBuilder &_fbb,
    libtextclassifier3::grammar::SemanticExpression_::Expression expression_type = libtextclassifier3::grammar::SemanticExpression_::Expression_NONE,
    flatbuffers::Offset<void> expression = 0) {
  SemanticExpressionBuilder builder_(_fbb);
  builder_.add_expression(expression);
  builder_.add_expression_type(expression_type);
  return builder_.Finish();
}

flatbuffers::Offset<SemanticExpression> CreateSemanticExpression(flatbuffers::FlatBufferBuilder &_fbb, const SemanticExpressionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConstValueExpressionT : public flatbuffers::NativeTable {
  typedef ConstValueExpression TableType;
  int32_t base_type;
  int32_t type;
  std::vector<uint8_t> value;
  ConstValueExpressionT()
      : base_type(0),
        type(0) {
  }
};

struct ConstValueExpression FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConstValueExpressionT NativeTableType;
  typedef ConstValueExpressionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE_TYPE = 4,
    VT_TYPE = 6,
    VT_VALUE = 8
  };
  int32_t base_type() const {
    return GetField<int32_t>(VT_BASE_TYPE, 0);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BASE_TYPE) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
  ConstValueExpressionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConstValueExpressionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ConstValueExpression> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConstValueExpressionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConstValueExpressionBuilder {
  typedef ConstValueExpression Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base_type(int32_t base_type) {
    fbb_.AddElement<int32_t>(ConstValueExpression::VT_BASE_TYPE, base_type, 0);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ConstValueExpression::VT_TYPE, type, 0);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(ConstValueExpression::VT_VALUE, value);
  }
  explicit ConstValueExpressionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConstValueExpressionBuilder &operator=(const ConstValueExpressionBuilder &);
  flatbuffers::Offset<ConstValueExpression> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConstValueExpression>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConstValueExpression> CreateConstValueExpression(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t base_type = 0,
    int32_t type = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  ConstValueExpressionBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_type(type);
  builder_.add_base_type(base_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConstValueExpression> CreateConstValueExpressionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t base_type = 0,
    int32_t type = 0,
    const std::vector<uint8_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return libtextclassifier3::grammar::CreateConstValueExpression(
      _fbb,
      base_type,
      type,
      value__);
}

flatbuffers::Offset<ConstValueExpression> CreateConstValueExpression(flatbuffers::FlatBufferBuilder &_fbb, const ConstValueExpressionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConstituentExpressionT : public flatbuffers::NativeTable {
  typedef ConstituentExpression TableType;
  uint16_t id;
  ConstituentExpressionT()
      : id(0) {
  }
};

struct ConstituentExpression FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConstituentExpressionT NativeTableType;
  typedef ConstituentExpressionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
  ConstituentExpressionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConstituentExpressionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ConstituentExpression> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConstituentExpressionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConstituentExpressionBuilder {
  typedef ConstituentExpression Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(ConstituentExpression::VT_ID, id, 0);
  }
  explicit ConstituentExpressionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConstituentExpressionBuilder &operator=(const ConstituentExpressionBuilder &);
  flatbuffers::Offset<ConstituentExpression> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConstituentExpression>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConstituentExpression> CreateConstituentExpression(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0) {
  ConstituentExpressionBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

flatbuffers::Offset<ConstituentExpression> CreateConstituentExpression(flatbuffers::FlatBufferBuilder &_fbb, const ConstituentExpressionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace ComposeExpression_ {

struct FieldT : public flatbuffers::NativeTable {
  typedef Field TableType;
  std::unique_ptr<libtextclassifier3::FlatbufferFieldPathT> path;
  std::unique_ptr<libtextclassifier3::grammar::SemanticExpressionT> value;
  FieldT() {
  }
};

struct Field FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FieldT NativeTableType;
  typedef FieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATH = 4,
    VT_VALUE = 6
  };
  const libtextclassifier3::FlatbufferFieldPath *path() const {
    return GetPointer<const libtextclassifier3::FlatbufferFieldPath *>(VT_PATH);
  }
  const libtextclassifier3::grammar::SemanticExpression *value() const {
    return GetPointer<const libtextclassifier3::grammar::SemanticExpression *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyTable(path()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
  FieldT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FieldT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Field> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FieldT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FieldBuilder {
  typedef Field Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_path(flatbuffers::Offset<libtextclassifier3::FlatbufferFieldPath> path) {
    fbb_.AddOffset(Field::VT_PATH, path);
  }
  void add_value(flatbuffers::Offset<libtextclassifier3::grammar::SemanticExpression> value) {
    fbb_.AddOffset(Field::VT_VALUE, value);
  }
  explicit FieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FieldBuilder &operator=(const FieldBuilder &);
  flatbuffers::Offset<Field> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Field>(end);
    return o;
  }
};

inline flatbuffers::Offset<Field> CreateField(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<libtextclassifier3::FlatbufferFieldPath> path = 0,
    flatbuffers::Offset<libtextclassifier3::grammar::SemanticExpression> value = 0) {
  FieldBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_path(path);
  return builder_.Finish();
}

flatbuffers::Offset<Field> CreateField(flatbuffers::FlatBufferBuilder &_fbb, const FieldT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace ComposeExpression_

struct ComposeExpressionT : public flatbuffers::NativeTable {
  typedef ComposeExpression TableType;
  int32_t type;
  std::vector<std::unique_ptr<libtextclassifier3::grammar::ComposeExpression_::FieldT>> fields;
  ComposeExpressionT()
      : type(0) {
  }
};

struct ComposeExpression FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ComposeExpressionT NativeTableType;
  typedef ComposeExpressionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_FIELDS = 6
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::ComposeExpression_::Field>> *fields() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::ComposeExpression_::Field>> *>(VT_FIELDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           verifier.VerifyVectorOfTables(fields()) &&
           verifier.EndTable();
  }
  ComposeExpressionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ComposeExpressionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ComposeExpression> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ComposeExpressionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ComposeExpressionBuilder {
  typedef ComposeExpression Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ComposeExpression::VT_TYPE, type, 0);
  }
  void add_fields(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::ComposeExpression_::Field>>> fields) {
    fbb_.AddOffset(ComposeExpression::VT_FIELDS, fields);
  }
  explicit ComposeExpressionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ComposeExpressionBuilder &operator=(const ComposeExpressionBuilder &);
  flatbuffers::Offset<ComposeExpression> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ComposeExpression>(end);
    return o;
  }
};

inline flatbuffers::Offset<ComposeExpression> CreateComposeExpression(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::ComposeExpression_::Field>>> fields = 0) {
  ComposeExpressionBuilder builder_(_fbb);
  builder_.add_fields(fields);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ComposeExpression> CreateComposeExpressionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    const std::vector<flatbuffers::Offset<libtextclassifier3::grammar::ComposeExpression_::Field>> *fields = nullptr) {
  auto fields__ = fields ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::grammar::ComposeExpression_::Field>>(*fields) : 0;
  return libtextclassifier3::grammar::CreateComposeExpression(
      _fbb,
      type,
      fields__);
}

flatbuffers::Offset<ComposeExpression> CreateComposeExpression(flatbuffers::FlatBufferBuilder &_fbb, const ComposeExpressionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpanAsStringExpressionT : public flatbuffers::NativeTable {
  typedef SpanAsStringExpression TableType;
  SpanAsStringExpressionT() {
  }
};

struct SpanAsStringExpression FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpanAsStringExpressionT NativeTableType;
  typedef SpanAsStringExpressionBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SpanAsStringExpressionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpanAsStringExpressionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SpanAsStringExpression> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpanAsStringExpressionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpanAsStringExpressionBuilder {
  typedef SpanAsStringExpression Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SpanAsStringExpressionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpanAsStringExpressionBuilder &operator=(const SpanAsStringExpressionBuilder &);
  flatbuffers::Offset<SpanAsStringExpression> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpanAsStringExpression>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpanAsStringExpression> CreateSpanAsStringExpression(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SpanAsStringExpressionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SpanAsStringExpression> CreateSpanAsStringExpression(flatbuffers::FlatBufferBuilder &_fbb, const SpanAsStringExpressionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ParseNumberExpressionT : public flatbuffers::NativeTable {
  typedef ParseNumberExpression TableType;
  int32_t base_type;
  std::unique_ptr<libtextclassifier3::grammar::SemanticExpressionT> value;
  ParseNumberExpressionT()
      : base_type(0) {
  }
};

struct ParseNumberExpression FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ParseNumberExpressionT NativeTableType;
  typedef ParseNumberExpressionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE_TYPE = 4,
    VT_VALUE = 6
  };
  int32_t base_type() const {
    return GetField<int32_t>(VT_BASE_TYPE, 0);
  }
  const libtextclassifier3::grammar::SemanticExpression *value() const {
    return GetPointer<const libtextclassifier3::grammar::SemanticExpression *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BASE_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
  ParseNumberExpressionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ParseNumberExpressionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ParseNumberExpression> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ParseNumberExpressionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ParseNumberExpressionBuilder {
  typedef ParseNumberExpression Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base_type(int32_t base_type) {
    fbb_.AddElement<int32_t>(ParseNumberExpression::VT_BASE_TYPE, base_type, 0);
  }
  void add_value(flatbuffers::Offset<libtextclassifier3::grammar::SemanticExpression> value) {
    fbb_.AddOffset(ParseNumberExpression::VT_VALUE, value);
  }
  explicit ParseNumberExpressionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ParseNumberExpressionBuilder &operator=(const ParseNumberExpressionBuilder &);
  flatbuffers::Offset<ParseNumberExpression> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ParseNumberExpression>(end);
    return o;
  }
};

inline flatbuffers::Offset<ParseNumberExpression> CreateParseNumberExpression(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t base_type = 0,
    flatbuffers::Offset<libtextclassifier3::grammar::SemanticExpression> value = 0) {
  ParseNumberExpressionBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_base_type(base_type);
  return builder_.Finish();
}

flatbuffers::Offset<ParseNumberExpression> CreateParseNumberExpression(flatbuffers::FlatBufferBuilder &_fbb, const ParseNumberExpressionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MergeValueExpressionT : public flatbuffers::NativeTable {
  typedef MergeValueExpression TableType;
  int32_t type;
  std::vector<std::unique_ptr<libtextclassifier3::grammar::SemanticExpressionT>> values;
  MergeValueExpressionT()
      : type(0) {
  }
};

struct MergeValueExpression FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MergeValueExpressionT NativeTableType;
  typedef MergeValueExpressionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_VALUES = 6
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::SemanticExpression>> *values() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::SemanticExpression>> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfTables(values()) &&
           verifier.EndTable();
  }
  MergeValueExpressionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MergeValueExpressionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MergeValueExpression> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MergeValueExpressionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MergeValueExpressionBuilder {
  typedef MergeValueExpression Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(MergeValueExpression::VT_TYPE, type, 0);
  }
  void add_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::SemanticExpression>>> values) {
    fbb_.AddOffset(MergeValueExpression::VT_VALUES, values);
  }
  explicit MergeValueExpressionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MergeValueExpressionBuilder &operator=(const MergeValueExpressionBuilder &);
  flatbuffers::Offset<MergeValueExpression> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MergeValueExpression>(end);
    return o;
  }
};

inline flatbuffers::Offset<MergeValueExpression> CreateMergeValueExpression(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::SemanticExpression>>> values = 0) {
  MergeValueExpressionBuilder builder_(_fbb);
  builder_.add_values(values);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<MergeValueExpression> CreateMergeValueExpressionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    const std::vector<flatbuffers::Offset<libtextclassifier3::grammar::SemanticExpression>> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::grammar::SemanticExpression>>(*values) : 0;
  return libtextclassifier3::grammar::CreateMergeValueExpression(
      _fbb,
      type,
      values__);
}

flatbuffers::Offset<MergeValueExpression> CreateMergeValueExpression(flatbuffers::FlatBufferBuilder &_fbb, const MergeValueExpressionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArithmeticExpressionT : public flatbuffers::NativeTable {
  typedef ArithmeticExpression TableType;
  int32_t base_type;
  libtextclassifier3::grammar::ArithmeticExpression_::Operator op;
  std::vector<std::unique_ptr<libtextclassifier3::grammar::SemanticExpressionT>> values;
  ArithmeticExpressionT()
      : base_type(0),
        op(libtextclassifier3::grammar::ArithmeticExpression_::Operator_NO_OP) {
  }
};

struct ArithmeticExpression FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArithmeticExpressionT NativeTableType;
  typedef ArithmeticExpressionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE_TYPE = 4,
    VT_OP = 6,
    VT_VALUES = 8
  };
  int32_t base_type() const {
    return GetField<int32_t>(VT_BASE_TYPE, 0);
  }
  libtextclassifier3::grammar::ArithmeticExpression_::Operator op() const {
    return static_cast<libtextclassifier3::grammar::ArithmeticExpression_::Operator>(GetField<int32_t>(VT_OP, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::SemanticExpression>> *values() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::SemanticExpression>> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BASE_TYPE) &&
           VerifyField<int32_t>(verifier, VT_OP) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfTables(values()) &&
           verifier.EndTable();
  }
  ArithmeticExpressionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArithmeticExpressionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ArithmeticExpression> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArithmeticExpressionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArithmeticExpressionBuilder {
  typedef ArithmeticExpression Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base_type(int32_t base_type) {
    fbb_.AddElement<int32_t>(ArithmeticExpression::VT_BASE_TYPE, base_type, 0);
  }
  void add_op(libtextclassifier3::grammar::ArithmeticExpression_::Operator op) {
    fbb_.AddElement<int32_t>(ArithmeticExpression::VT_OP, static_cast<int32_t>(op), 0);
  }
  void add_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::SemanticExpression>>> values) {
    fbb_.AddOffset(ArithmeticExpression::VT_VALUES, values);
  }
  explicit ArithmeticExpressionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArithmeticExpressionBuilder &operator=(const ArithmeticExpressionBuilder &);
  flatbuffers::Offset<ArithmeticExpression> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArithmeticExpression>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArithmeticExpression> CreateArithmeticExpression(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t base_type = 0,
    libtextclassifier3::grammar::ArithmeticExpression_::Operator op = libtextclassifier3::grammar::ArithmeticExpression_::Operator_NO_OP,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::SemanticExpression>>> values = 0) {
  ArithmeticExpressionBuilder builder_(_fbb);
  builder_.add_values(values);
  builder_.add_op(op);
  builder_.add_base_type(base_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ArithmeticExpression> CreateArithmeticExpressionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t base_type = 0,
    libtextclassifier3::grammar::ArithmeticExpression_::Operator op = libtextclassifier3::grammar::ArithmeticExpression_::Operator_NO_OP,
    const std::vector<flatbuffers::Offset<libtextclassifier3::grammar::SemanticExpression>> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::grammar::SemanticExpression>>(*values) : 0;
  return libtextclassifier3::grammar::CreateArithmeticExpression(
      _fbb,
      base_type,
      op,
      values__);
}

flatbuffers::Offset<ArithmeticExpression> CreateArithmeticExpression(flatbuffers::FlatBufferBuilder &_fbb, const ArithmeticExpressionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline SemanticExpressionT *SemanticExpression::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::grammar::SemanticExpressionT> _o = std::unique_ptr<libtextclassifier3::grammar::SemanticExpressionT>(new SemanticExpressionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SemanticExpression::UnPackTo(SemanticExpressionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = expression_type(); _o->expression.type = _e; }
  { auto _e = expression(); if (_e) _o->expression.value = libtextclassifier3::grammar::SemanticExpression_::ExpressionUnion::UnPack(_e, expression_type(), _resolver); }
}

inline flatbuffers::Offset<SemanticExpression> SemanticExpression::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SemanticExpressionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSemanticExpression(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SemanticExpression> CreateSemanticExpression(flatbuffers::FlatBufferBuilder &_fbb, const SemanticExpressionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SemanticExpressionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _expression_type = _o->expression.type;
  auto _expression = _o->expression.Pack(_fbb);
  return libtextclassifier3::grammar::CreateSemanticExpression(
      _fbb,
      _expression_type,
      _expression);
}

inline ConstValueExpressionT *ConstValueExpression::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::grammar::ConstValueExpressionT> _o = std::unique_ptr<libtextclassifier3::grammar::ConstValueExpressionT>(new ConstValueExpressionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ConstValueExpression::UnPackTo(ConstValueExpressionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = base_type(); _o->base_type = _e; }
  { auto _e = type(); _o->type = _e; }
  { auto _e = value(); if (_e) { _o->value.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->value[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<ConstValueExpression> ConstValueExpression::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConstValueExpressionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConstValueExpression(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConstValueExpression> CreateConstValueExpression(flatbuffers::FlatBufferBuilder &_fbb, const ConstValueExpressionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConstValueExpressionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _base_type = _o->base_type;
  auto _type = _o->type;
  auto _value = _o->value.size() ? _fbb.CreateVector(_o->value) : 0;
  return libtextclassifier3::grammar::CreateConstValueExpression(
      _fbb,
      _base_type,
      _type,
      _value);
}

inline ConstituentExpressionT *ConstituentExpression::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::grammar::ConstituentExpressionT> _o = std::unique_ptr<libtextclassifier3::grammar::ConstituentExpressionT>(new ConstituentExpressionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ConstituentExpression::UnPackTo(ConstituentExpressionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
}

inline flatbuffers::Offset<ConstituentExpression> ConstituentExpression::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConstituentExpressionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConstituentExpression(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConstituentExpression> CreateConstituentExpression(flatbuffers::FlatBufferBuilder &_fbb, const ConstituentExpressionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConstituentExpressionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  return libtextclassifier3::grammar::CreateConstituentExpression(
      _fbb,
      _id);
}

namespace ComposeExpression_ {

inline FieldT *Field::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::grammar::ComposeExpression_::FieldT> _o = std::unique_ptr<libtextclassifier3::grammar::ComposeExpression_::FieldT>(new FieldT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Field::UnPackTo(FieldT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = path(); if (_e) _o->path = std::unique_ptr<libtextclassifier3::FlatbufferFieldPathT>(_e->UnPack(_resolver)); }
  { auto _e = value(); if (_e) _o->value = std::unique_ptr<libtextclassifier3::grammar::SemanticExpressionT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<Field> Field::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FieldT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateField(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Field> CreateField(flatbuffers::FlatBufferBuilder &_fbb, const FieldT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FieldT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _path = _o->path ? CreateFlatbufferFieldPath(_fbb, _o->path.get(), _rehasher) : 0;
  auto _value = _o->value ? CreateSemanticExpression(_fbb, _o->value.get(), _rehasher) : 0;
  return libtextclassifier3::grammar::ComposeExpression_::CreateField(
      _fbb,
      _path,
      _value);
}

}  // namespace ComposeExpression_

inline ComposeExpressionT *ComposeExpression::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::grammar::ComposeExpressionT> _o = std::unique_ptr<libtextclassifier3::grammar::ComposeExpressionT>(new ComposeExpressionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ComposeExpression::UnPackTo(ComposeExpressionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = fields(); if (_e) { _o->fields.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->fields[_i] = std::unique_ptr<libtextclassifier3::grammar::ComposeExpression_::FieldT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<ComposeExpression> ComposeExpression::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ComposeExpressionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateComposeExpression(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ComposeExpression> CreateComposeExpression(flatbuffers::FlatBufferBuilder &_fbb, const ComposeExpressionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ComposeExpressionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _fields = _o->fields.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::grammar::ComposeExpression_::Field>> (_o->fields.size(), [](size_t i, _VectorArgs *__va) { return CreateField(*__va->__fbb, __va->__o->fields[i].get(), __va->__rehasher); }, &_va ) : 0;
  return libtextclassifier3::grammar::CreateComposeExpression(
      _fbb,
      _type,
      _fields);
}

inline SpanAsStringExpressionT *SpanAsStringExpression::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::grammar::SpanAsStringExpressionT> _o = std::unique_ptr<libtextclassifier3::grammar::SpanAsStringExpressionT>(new SpanAsStringExpressionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SpanAsStringExpression::UnPackTo(SpanAsStringExpressionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SpanAsStringExpression> SpanAsStringExpression::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpanAsStringExpressionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpanAsStringExpression(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpanAsStringExpression> CreateSpanAsStringExpression(flatbuffers::FlatBufferBuilder &_fbb, const SpanAsStringExpressionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpanAsStringExpressionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return libtextclassifier3::grammar::CreateSpanAsStringExpression(
      _fbb);
}

inline ParseNumberExpressionT *ParseNumberExpression::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::grammar::ParseNumberExpressionT> _o = std::unique_ptr<libtextclassifier3::grammar::ParseNumberExpressionT>(new ParseNumberExpressionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ParseNumberExpression::UnPackTo(ParseNumberExpressionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = base_type(); _o->base_type = _e; }
  { auto _e = value(); if (_e) _o->value = std::unique_ptr<libtextclassifier3::grammar::SemanticExpressionT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<ParseNumberExpression> ParseNumberExpression::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ParseNumberExpressionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateParseNumberExpression(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ParseNumberExpression> CreateParseNumberExpression(flatbuffers::FlatBufferBuilder &_fbb, const ParseNumberExpressionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ParseNumberExpressionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _base_type = _o->base_type;
  auto _value = _o->value ? CreateSemanticExpression(_fbb, _o->value.get(), _rehasher) : 0;
  return libtextclassifier3::grammar::CreateParseNumberExpression(
      _fbb,
      _base_type,
      _value);
}

inline MergeValueExpressionT *MergeValueExpression::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::grammar::MergeValueExpressionT> _o = std::unique_ptr<libtextclassifier3::grammar::MergeValueExpressionT>(new MergeValueExpressionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MergeValueExpression::UnPackTo(MergeValueExpressionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = std::unique_ptr<libtextclassifier3::grammar::SemanticExpressionT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<MergeValueExpression> MergeValueExpression::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MergeValueExpressionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMergeValueExpression(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MergeValueExpression> CreateMergeValueExpression(flatbuffers::FlatBufferBuilder &_fbb, const MergeValueExpressionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MergeValueExpressionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _values = _o->values.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::grammar::SemanticExpression>> (_o->values.size(), [](size_t i, _VectorArgs *__va) { return CreateSemanticExpression(*__va->__fbb, __va->__o->values[i].get(), __va->__rehasher); }, &_va ) : 0;
  return libtextclassifier3::grammar::CreateMergeValueExpression(
      _fbb,
      _type,
      _values);
}

inline ArithmeticExpressionT *ArithmeticExpression::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::grammar::ArithmeticExpressionT> _o = std::unique_ptr<libtextclassifier3::grammar::ArithmeticExpressionT>(new ArithmeticExpressionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ArithmeticExpression::UnPackTo(ArithmeticExpressionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = base_type(); _o->base_type = _e; }
  { auto _e = op(); _o->op = _e; }
  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = std::unique_ptr<libtextclassifier3::grammar::SemanticExpressionT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<ArithmeticExpression> ArithmeticExpression::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArithmeticExpressionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArithmeticExpression(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArithmeticExpression> CreateArithmeticExpression(flatbuffers::FlatBufferBuilder &_fbb, const ArithmeticExpressionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArithmeticExpressionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _base_type = _o->base_type;
  auto _op = _o->op;
  auto _values = _o->values.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::grammar::SemanticExpression>> (_o->values.size(), [](size_t i, _VectorArgs *__va) { return CreateSemanticExpression(*__va->__fbb, __va->__o->values[i].get(), __va->__rehasher); }, &_va ) : 0;
  return libtextclassifier3::grammar::CreateArithmeticExpression(
      _fbb,
      _base_type,
      _op,
      _values);
}

namespace SemanticExpression_ {

inline bool VerifyExpression(flatbuffers::Verifier &verifier, const void *obj, Expression type) {
  switch (type) {
    case Expression_NONE: {
      return true;
    }
    case Expression_ConstValueExpression: {
      auto ptr = reinterpret_cast<const libtextclassifier3::grammar::ConstValueExpression *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Expression_ConstituentExpression: {
      auto ptr = reinterpret_cast<const libtextclassifier3::grammar::ConstituentExpression *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Expression_ComposeExpression: {
      auto ptr = reinterpret_cast<const libtextclassifier3::grammar::ComposeExpression *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Expression_SpanAsStringExpression: {
      auto ptr = reinterpret_cast<const libtextclassifier3::grammar::SpanAsStringExpression *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Expression_ParseNumberExpression: {
      auto ptr = reinterpret_cast<const libtextclassifier3::grammar::ParseNumberExpression *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Expression_MergeValueExpression: {
      auto ptr = reinterpret_cast<const libtextclassifier3::grammar::MergeValueExpression *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Expression_ArithmeticExpression: {
      auto ptr = reinterpret_cast<const libtextclassifier3::grammar::ArithmeticExpression *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyExpressionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyExpression(
        verifier,  values->Get(i), types->GetEnum<Expression>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ExpressionUnion::UnPack(const void *obj, Expression type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Expression_ConstValueExpression: {
      auto ptr = reinterpret_cast<const libtextclassifier3::grammar::ConstValueExpression *>(obj);
      return ptr->UnPack(resolver);
    }
    case Expression_ConstituentExpression: {
      auto ptr = reinterpret_cast<const libtextclassifier3::grammar::ConstituentExpression *>(obj);
      return ptr->UnPack(resolver);
    }
    case Expression_ComposeExpression: {
      auto ptr = reinterpret_cast<const libtextclassifier3::grammar::ComposeExpression *>(obj);
      return ptr->UnPack(resolver);
    }
    case Expression_SpanAsStringExpression: {
      auto ptr = reinterpret_cast<const libtextclassifier3::grammar::SpanAsStringExpression *>(obj);
      return ptr->UnPack(resolver);
    }
    case Expression_ParseNumberExpression: {
      auto ptr = reinterpret_cast<const libtextclassifier3::grammar::ParseNumberExpression *>(obj);
      return ptr->UnPack(resolver);
    }
    case Expression_MergeValueExpression: {
      auto ptr = reinterpret_cast<const libtextclassifier3::grammar::MergeValueExpression *>(obj);
      return ptr->UnPack(resolver);
    }
    case Expression_ArithmeticExpression: {
      auto ptr = reinterpret_cast<const libtextclassifier3::grammar::ArithmeticExpression *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ExpressionUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Expression_ConstValueExpression: {
      auto ptr = reinterpret_cast<const libtextclassifier3::grammar::ConstValueExpressionT *>(value);
      return CreateConstValueExpression(_fbb, ptr, _rehasher).Union();
    }
    case Expression_ConstituentExpression: {
      auto ptr = reinterpret_cast<const libtextclassifier3::grammar::ConstituentExpressionT *>(value);
      return CreateConstituentExpression(_fbb, ptr, _rehasher).Union();
    }
    case Expression_ComposeExpression: {
      auto ptr = reinterpret_cast<const libtextclassifier3::grammar::ComposeExpressionT *>(value);
      return CreateComposeExpression(_fbb, ptr, _rehasher).Union();
    }
    case Expression_SpanAsStringExpression: {
      auto ptr = reinterpret_cast<const libtextclassifier3::grammar::SpanAsStringExpressionT *>(value);
      return CreateSpanAsStringExpression(_fbb, ptr, _rehasher).Union();
    }
    case Expression_ParseNumberExpression: {
      auto ptr = reinterpret_cast<const libtextclassifier3::grammar::ParseNumberExpressionT *>(value);
      return CreateParseNumberExpression(_fbb, ptr, _rehasher).Union();
    }
    case Expression_MergeValueExpression: {
      auto ptr = reinterpret_cast<const libtextclassifier3::grammar::MergeValueExpressionT *>(value);
      return CreateMergeValueExpression(_fbb, ptr, _rehasher).Union();
    }
    case Expression_ArithmeticExpression: {
      auto ptr = reinterpret_cast<const libtextclassifier3::grammar::ArithmeticExpressionT *>(value);
      return CreateArithmeticExpression(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ExpressionUnion::ExpressionUnion(const ExpressionUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case Expression_ConstValueExpression: {
      value = new libtextclassifier3::grammar::ConstValueExpressionT(*reinterpret_cast<libtextclassifier3::grammar::ConstValueExpressionT *>(u.value));
      break;
    }
    case Expression_ConstituentExpression: {
      value = new libtextclassifier3::grammar::ConstituentExpressionT(*reinterpret_cast<libtextclassifier3::grammar::ConstituentExpressionT *>(u.value));
      break;
    }
    case Expression_ComposeExpression: {
      FLATBUFFERS_ASSERT(false);  // libtextclassifier3::grammar::ComposeExpressionT not copyable.
      break;
    }
    case Expression_SpanAsStringExpression: {
      value = new libtextclassifier3::grammar::SpanAsStringExpressionT(*reinterpret_cast<libtextclassifier3::grammar::SpanAsStringExpressionT *>(u.value));
      break;
    }
    case Expression_ParseNumberExpression: {
      FLATBUFFERS_ASSERT(false);  // libtextclassifier3::grammar::ParseNumberExpressionT not copyable.
      break;
    }
    case Expression_MergeValueExpression: {
      FLATBUFFERS_ASSERT(false);  // libtextclassifier3::grammar::MergeValueExpressionT not copyable.
      break;
    }
    case Expression_ArithmeticExpression: {
      FLATBUFFERS_ASSERT(false);  // libtextclassifier3::grammar::ArithmeticExpressionT not copyable.
      break;
    }
    default:
      break;
  }
}

inline void ExpressionUnion::Reset() {
  switch (type) {
    case Expression_ConstValueExpression: {
      auto ptr = reinterpret_cast<libtextclassifier3::grammar::ConstValueExpressionT *>(value);
      delete ptr;
      break;
    }
    case Expression_ConstituentExpression: {
      auto ptr = reinterpret_cast<libtextclassifier3::grammar::ConstituentExpressionT *>(value);
      delete ptr;
      break;
    }
    case Expression_ComposeExpression: {
      auto ptr = reinterpret_cast<libtextclassifier3::grammar::ComposeExpressionT *>(value);
      delete ptr;
      break;
    }
    case Expression_SpanAsStringExpression: {
      auto ptr = reinterpret_cast<libtextclassifier3::grammar::SpanAsStringExpressionT *>(value);
      delete ptr;
      break;
    }
    case Expression_ParseNumberExpression: {
      auto ptr = reinterpret_cast<libtextclassifier3::grammar::ParseNumberExpressionT *>(value);
      delete ptr;
      break;
    }
    case Expression_MergeValueExpression: {
      auto ptr = reinterpret_cast<libtextclassifier3::grammar::MergeValueExpressionT *>(value);
      delete ptr;
      break;
    }
    case Expression_ArithmeticExpression: {
      auto ptr = reinterpret_cast<libtextclassifier3::grammar::ArithmeticExpressionT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Expression_NONE;
}

}  // namespace SemanticExpression_
}  // namespace grammar
}  // namespace libtextclassifier3

#endif  // FLATBUFFERS_GENERATED_EXPRESSION_LIBTEXTCLASSIFIER3_GRAMMAR_H_
