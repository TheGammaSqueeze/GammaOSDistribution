// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RESOURCES_LIBTEXTCLASSIFIER3_H_
#define FLATBUFFERS_GENERATED_RESOURCES_LIBTEXTCLASSIFIER3_H_

#include "flatbuffers/flatbuffers.h"

#include "utils/i18n/language-tag_generated.h"
#include "utils/zlib/buffer_generated.h"

namespace libtextclassifier3 {

struct Resource;
struct ResourceBuilder;
struct ResourceT;

struct ResourceEntry;
struct ResourceEntryBuilder;
struct ResourceEntryT;

struct ResourcePool;
struct ResourcePoolBuilder;
struct ResourcePoolT;

struct ResourceT : public flatbuffers::NativeTable {
  typedef Resource TableType;
  std::vector<int32_t> locale;
  std::string content;
  ResourceT() {
  }
};

struct Resource FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResourceT NativeTableType;
  typedef ResourceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOCALE = 4,
    VT_CONTENT = 6
  };
  const flatbuffers::Vector<int32_t> *locale() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_LOCALE);
  }
  const flatbuffers::String *content() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOCALE) &&
           verifier.VerifyVector(locale()) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyString(content()) &&
           verifier.EndTable();
  }
  ResourceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResourceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Resource> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResourceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResourceBuilder {
  typedef Resource Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_locale(flatbuffers::Offset<flatbuffers::Vector<int32_t>> locale) {
    fbb_.AddOffset(Resource::VT_LOCALE, locale);
  }
  void add_content(flatbuffers::Offset<flatbuffers::String> content) {
    fbb_.AddOffset(Resource::VT_CONTENT, content);
  }
  explicit ResourceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResourceBuilder &operator=(const ResourceBuilder &);
  flatbuffers::Offset<Resource> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Resource>(end);
    return o;
  }
};

inline flatbuffers::Offset<Resource> CreateResource(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> locale = 0,
    flatbuffers::Offset<flatbuffers::String> content = 0) {
  ResourceBuilder builder_(_fbb);
  builder_.add_content(content);
  builder_.add_locale(locale);
  return builder_.Finish();
}

inline flatbuffers::Offset<Resource> CreateResourceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *locale = nullptr,
    const char *content = nullptr) {
  auto locale__ = locale ? _fbb.CreateVector<int32_t>(*locale) : 0;
  auto content__ = content ? _fbb.CreateSharedString(content) : 0;
  return libtextclassifier3::CreateResource(
      _fbb,
      locale__,
      content__);
}

flatbuffers::Offset<Resource> CreateResource(flatbuffers::FlatBufferBuilder &_fbb, const ResourceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResourceEntryT : public flatbuffers::NativeTable {
  typedef ResourceEntry TableType;
  std::string name;
  std::vector<std::unique_ptr<libtextclassifier3::ResourceT>> resource;
  ResourceEntryT() {
  }
};

struct ResourceEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResourceEntryT NativeTableType;
  typedef ResourceEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_RESOURCE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const ResourceEntry *o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(name()->c_str(), val);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::Resource>> *resource() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::Resource>> *>(VT_RESOURCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_RESOURCE) &&
           verifier.VerifyVector(resource()) &&
           verifier.VerifyVectorOfTables(resource()) &&
           verifier.EndTable();
  }
  ResourceEntryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResourceEntryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ResourceEntry> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResourceEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResourceEntryBuilder {
  typedef ResourceEntry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ResourceEntry::VT_NAME, name);
  }
  void add_resource(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::Resource>>> resource) {
    fbb_.AddOffset(ResourceEntry::VT_RESOURCE, resource);
  }
  explicit ResourceEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResourceEntryBuilder &operator=(const ResourceEntryBuilder &);
  flatbuffers::Offset<ResourceEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResourceEntry>(end);
    fbb_.Required(o, ResourceEntry::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<ResourceEntry> CreateResourceEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::Resource>>> resource = 0) {
  ResourceEntryBuilder builder_(_fbb);
  builder_.add_resource(resource);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<ResourceEntry> CreateResourceEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<libtextclassifier3::Resource>> *resource = nullptr) {
  auto name__ = name ? _fbb.CreateSharedString(name) : 0;
  auto resource__ = resource ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::Resource>>(*resource) : 0;
  return libtextclassifier3::CreateResourceEntry(
      _fbb,
      name__,
      resource__);
}

flatbuffers::Offset<ResourceEntry> CreateResourceEntry(flatbuffers::FlatBufferBuilder &_fbb, const ResourceEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResourcePoolT : public flatbuffers::NativeTable {
  typedef ResourcePool TableType;
  std::vector<std::unique_ptr<libtextclassifier3::LanguageTagT>> locale;
  std::vector<std::unique_ptr<libtextclassifier3::ResourceEntryT>> resource_entry;
  ResourcePoolT() {
  }
};

struct ResourcePool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResourcePoolT NativeTableType;
  typedef ResourcePoolBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOCALE = 4,
    VT_RESOURCE_ENTRY = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::LanguageTag>> *locale() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::LanguageTag>> *>(VT_LOCALE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::ResourceEntry>> *resource_entry() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::ResourceEntry>> *>(VT_RESOURCE_ENTRY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOCALE) &&
           verifier.VerifyVector(locale()) &&
           verifier.VerifyVectorOfTables(locale()) &&
           VerifyOffset(verifier, VT_RESOURCE_ENTRY) &&
           verifier.VerifyVector(resource_entry()) &&
           verifier.VerifyVectorOfTables(resource_entry()) &&
           verifier.EndTable();
  }
  ResourcePoolT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResourcePoolT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ResourcePool> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResourcePoolT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResourcePoolBuilder {
  typedef ResourcePool Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_locale(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::LanguageTag>>> locale) {
    fbb_.AddOffset(ResourcePool::VT_LOCALE, locale);
  }
  void add_resource_entry(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::ResourceEntry>>> resource_entry) {
    fbb_.AddOffset(ResourcePool::VT_RESOURCE_ENTRY, resource_entry);
  }
  explicit ResourcePoolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResourcePoolBuilder &operator=(const ResourcePoolBuilder &);
  flatbuffers::Offset<ResourcePool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResourcePool>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResourcePool> CreateResourcePool(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::LanguageTag>>> locale = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::ResourceEntry>>> resource_entry = 0) {
  ResourcePoolBuilder builder_(_fbb);
  builder_.add_resource_entry(resource_entry);
  builder_.add_locale(locale);
  return builder_.Finish();
}

inline flatbuffers::Offset<ResourcePool> CreateResourcePoolDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<libtextclassifier3::LanguageTag>> *locale = nullptr,
    std::vector<flatbuffers::Offset<libtextclassifier3::ResourceEntry>> *resource_entry = nullptr) {
  auto locale__ = locale ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::LanguageTag>>(*locale) : 0;
  auto resource_entry__ = resource_entry ? _fbb.CreateVectorOfSortedTables<libtextclassifier3::ResourceEntry>(resource_entry) : 0;
  return libtextclassifier3::CreateResourcePool(
      _fbb,
      locale__,
      resource_entry__);
}

flatbuffers::Offset<ResourcePool> CreateResourcePool(flatbuffers::FlatBufferBuilder &_fbb, const ResourcePoolT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ResourceT *Resource::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::ResourceT> _o = std::unique_ptr<libtextclassifier3::ResourceT>(new ResourceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Resource::UnPackTo(ResourceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = locale(); if (_e) { _o->locale.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->locale[_i] = _e->Get(_i); } } }
  { auto _e = content(); if (_e) _o->content = _e->str(); }
}

inline flatbuffers::Offset<Resource> Resource::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResourceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResource(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Resource> CreateResource(flatbuffers::FlatBufferBuilder &_fbb, const ResourceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResourceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _locale = _o->locale.size() ? _fbb.CreateVector(_o->locale) : 0;
  auto _content = _o->content.empty() ? 0 : _fbb.CreateSharedString(_o->content);
  return libtextclassifier3::CreateResource(
      _fbb,
      _locale,
      _content);
}

inline ResourceEntryT *ResourceEntry::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::ResourceEntryT> _o = std::unique_ptr<libtextclassifier3::ResourceEntryT>(new ResourceEntryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ResourceEntry::UnPackTo(ResourceEntryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = resource(); if (_e) { _o->resource.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->resource[_i] = std::unique_ptr<libtextclassifier3::ResourceT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<ResourceEntry> ResourceEntry::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResourceEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResourceEntry(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ResourceEntry> CreateResourceEntry(flatbuffers::FlatBufferBuilder &_fbb, const ResourceEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResourceEntryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _fbb.CreateSharedString(_o->name);
  auto _resource = _o->resource.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::Resource>> (_o->resource.size(), [](size_t i, _VectorArgs *__va) { return CreateResource(*__va->__fbb, __va->__o->resource[i].get(), __va->__rehasher); }, &_va ) : 0;
  return libtextclassifier3::CreateResourceEntry(
      _fbb,
      _name,
      _resource);
}

inline ResourcePoolT *ResourcePool::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::ResourcePoolT> _o = std::unique_ptr<libtextclassifier3::ResourcePoolT>(new ResourcePoolT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ResourcePool::UnPackTo(ResourcePoolT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = locale(); if (_e) { _o->locale.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->locale[_i] = std::unique_ptr<libtextclassifier3::LanguageTagT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = resource_entry(); if (_e) { _o->resource_entry.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->resource_entry[_i] = std::unique_ptr<libtextclassifier3::ResourceEntryT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<ResourcePool> ResourcePool::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResourcePoolT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResourcePool(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ResourcePool> CreateResourcePool(flatbuffers::FlatBufferBuilder &_fbb, const ResourcePoolT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResourcePoolT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _locale = _o->locale.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::LanguageTag>> (_o->locale.size(), [](size_t i, _VectorArgs *__va) { return CreateLanguageTag(*__va->__fbb, __va->__o->locale[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _resource_entry = _o->resource_entry.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::ResourceEntry>> (_o->resource_entry.size(), [](size_t i, _VectorArgs *__va) { return CreateResourceEntry(*__va->__fbb, __va->__o->resource_entry[i].get(), __va->__rehasher); }, &_va ) : 0;
  return libtextclassifier3::CreateResourcePool(
      _fbb,
      _locale,
      _resource_entry);
}

}  // namespace libtextclassifier3

#endif  // FLATBUFFERS_GENERATED_RESOURCES_LIBTEXTCLASSIFIER3_H_
