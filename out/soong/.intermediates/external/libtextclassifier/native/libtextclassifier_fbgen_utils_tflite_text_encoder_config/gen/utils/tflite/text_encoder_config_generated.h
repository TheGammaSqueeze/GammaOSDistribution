// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TEXTENCODERCONFIG_LIBTEXTCLASSIFIER3_H_
#define FLATBUFFERS_GENERATED_TEXTENCODERCONFIG_LIBTEXTCLASSIFIER3_H_

#include "flatbuffers/flatbuffers.h"

namespace libtextclassifier3 {

struct TextEncoderConfig;
struct TextEncoderConfigBuilder;
struct TextEncoderConfigT;

enum SentencePieceMatcherType {
  SentencePieceMatcherType_MAPPED_TRIE = 0,
  SentencePieceMatcherType_SORTED_STRING_TABLE = 1,
  SentencePieceMatcherType_MIN = SentencePieceMatcherType_MAPPED_TRIE,
  SentencePieceMatcherType_MAX = SentencePieceMatcherType_SORTED_STRING_TABLE
};

inline const SentencePieceMatcherType (&EnumValuesSentencePieceMatcherType())[2] {
  static const SentencePieceMatcherType values[] = {
    SentencePieceMatcherType_MAPPED_TRIE,
    SentencePieceMatcherType_SORTED_STRING_TABLE
  };
  return values;
}

inline const char * const *EnumNamesSentencePieceMatcherType() {
  static const char * const names[3] = {
    "MAPPED_TRIE",
    "SORTED_STRING_TABLE",
    nullptr
  };
  return names;
}

inline const char *EnumNameSentencePieceMatcherType(SentencePieceMatcherType e) {
  if (flatbuffers::IsOutRange(e, SentencePieceMatcherType_MAPPED_TRIE, SentencePieceMatcherType_SORTED_STRING_TABLE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSentencePieceMatcherType()[index];
}

struct TextEncoderConfigT : public flatbuffers::NativeTable {
  typedef TextEncoderConfig TableType;
  int32_t start_code;
  int32_t end_code;
  int32_t encoding_offset;
  int32_t unknown_code;
  float unknown_score;
  std::string normalization_charsmap;
  std::string normalization_charsmap_values;
  bool add_dummy_prefix;
  bool remove_extra_whitespaces;
  bool escape_whitespaces;
  std::vector<float> pieces_scores;
  std::string pieces;
  std::vector<uint32_t> pieces_offsets;
  libtextclassifier3::SentencePieceMatcherType matcher_type;
  TextEncoderConfigT()
      : start_code(0),
        end_code(1),
        encoding_offset(2),
        unknown_code(-1),
        unknown_score(0.0f),
        add_dummy_prefix(true),
        remove_extra_whitespaces(true),
        escape_whitespaces(true),
        matcher_type(libtextclassifier3::SentencePieceMatcherType_MAPPED_TRIE) {
  }
};

struct TextEncoderConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextEncoderConfigT NativeTableType;
  typedef TextEncoderConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START_CODE = 4,
    VT_END_CODE = 6,
    VT_ENCODING_OFFSET = 8,
    VT_UNKNOWN_CODE = 10,
    VT_UNKNOWN_SCORE = 12,
    VT_NORMALIZATION_CHARSMAP = 14,
    VT_NORMALIZATION_CHARSMAP_VALUES = 16,
    VT_ADD_DUMMY_PREFIX = 18,
    VT_REMOVE_EXTRA_WHITESPACES = 20,
    VT_ESCAPE_WHITESPACES = 22,
    VT_PIECES_SCORES = 24,
    VT_PIECES = 26,
    VT_PIECES_OFFSETS = 28,
    VT_MATCHER_TYPE = 30
  };
  int32_t start_code() const {
    return GetField<int32_t>(VT_START_CODE, 0);
  }
  int32_t end_code() const {
    return GetField<int32_t>(VT_END_CODE, 1);
  }
  int32_t encoding_offset() const {
    return GetField<int32_t>(VT_ENCODING_OFFSET, 2);
  }
  int32_t unknown_code() const {
    return GetField<int32_t>(VT_UNKNOWN_CODE, -1);
  }
  float unknown_score() const {
    return GetField<float>(VT_UNKNOWN_SCORE, 0.0f);
  }
  const flatbuffers::String *normalization_charsmap() const {
    return GetPointer<const flatbuffers::String *>(VT_NORMALIZATION_CHARSMAP);
  }
  const flatbuffers::String *normalization_charsmap_values() const {
    return GetPointer<const flatbuffers::String *>(VT_NORMALIZATION_CHARSMAP_VALUES);
  }
  bool add_dummy_prefix() const {
    return GetField<uint8_t>(VT_ADD_DUMMY_PREFIX, 1) != 0;
  }
  bool remove_extra_whitespaces() const {
    return GetField<uint8_t>(VT_REMOVE_EXTRA_WHITESPACES, 1) != 0;
  }
  bool escape_whitespaces() const {
    return GetField<uint8_t>(VT_ESCAPE_WHITESPACES, 1) != 0;
  }
  const flatbuffers::Vector<float> *pieces_scores() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_PIECES_SCORES);
  }
  const flatbuffers::String *pieces() const {
    return GetPointer<const flatbuffers::String *>(VT_PIECES);
  }
  const flatbuffers::Vector<uint32_t> *pieces_offsets() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_PIECES_OFFSETS);
  }
  libtextclassifier3::SentencePieceMatcherType matcher_type() const {
    return static_cast<libtextclassifier3::SentencePieceMatcherType>(GetField<int8_t>(VT_MATCHER_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_START_CODE) &&
           VerifyField<int32_t>(verifier, VT_END_CODE) &&
           VerifyField<int32_t>(verifier, VT_ENCODING_OFFSET) &&
           VerifyField<int32_t>(verifier, VT_UNKNOWN_CODE) &&
           VerifyField<float>(verifier, VT_UNKNOWN_SCORE) &&
           VerifyOffset(verifier, VT_NORMALIZATION_CHARSMAP) &&
           verifier.VerifyString(normalization_charsmap()) &&
           VerifyOffset(verifier, VT_NORMALIZATION_CHARSMAP_VALUES) &&
           verifier.VerifyString(normalization_charsmap_values()) &&
           VerifyField<uint8_t>(verifier, VT_ADD_DUMMY_PREFIX) &&
           VerifyField<uint8_t>(verifier, VT_REMOVE_EXTRA_WHITESPACES) &&
           VerifyField<uint8_t>(verifier, VT_ESCAPE_WHITESPACES) &&
           VerifyOffset(verifier, VT_PIECES_SCORES) &&
           verifier.VerifyVector(pieces_scores()) &&
           VerifyOffset(verifier, VT_PIECES) &&
           verifier.VerifyString(pieces()) &&
           VerifyOffset(verifier, VT_PIECES_OFFSETS) &&
           verifier.VerifyVector(pieces_offsets()) &&
           VerifyField<int8_t>(verifier, VT_MATCHER_TYPE) &&
           verifier.EndTable();
  }
  TextEncoderConfigT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TextEncoderConfigT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TextEncoderConfig> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TextEncoderConfigT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TextEncoderConfigBuilder {
  typedef TextEncoderConfig Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_start_code(int32_t start_code) {
    fbb_.AddElement<int32_t>(TextEncoderConfig::VT_START_CODE, start_code, 0);
  }
  void add_end_code(int32_t end_code) {
    fbb_.AddElement<int32_t>(TextEncoderConfig::VT_END_CODE, end_code, 1);
  }
  void add_encoding_offset(int32_t encoding_offset) {
    fbb_.AddElement<int32_t>(TextEncoderConfig::VT_ENCODING_OFFSET, encoding_offset, 2);
  }
  void add_unknown_code(int32_t unknown_code) {
    fbb_.AddElement<int32_t>(TextEncoderConfig::VT_UNKNOWN_CODE, unknown_code, -1);
  }
  void add_unknown_score(float unknown_score) {
    fbb_.AddElement<float>(TextEncoderConfig::VT_UNKNOWN_SCORE, unknown_score, 0.0f);
  }
  void add_normalization_charsmap(flatbuffers::Offset<flatbuffers::String> normalization_charsmap) {
    fbb_.AddOffset(TextEncoderConfig::VT_NORMALIZATION_CHARSMAP, normalization_charsmap);
  }
  void add_normalization_charsmap_values(flatbuffers::Offset<flatbuffers::String> normalization_charsmap_values) {
    fbb_.AddOffset(TextEncoderConfig::VT_NORMALIZATION_CHARSMAP_VALUES, normalization_charsmap_values);
  }
  void add_add_dummy_prefix(bool add_dummy_prefix) {
    fbb_.AddElement<uint8_t>(TextEncoderConfig::VT_ADD_DUMMY_PREFIX, static_cast<uint8_t>(add_dummy_prefix), 1);
  }
  void add_remove_extra_whitespaces(bool remove_extra_whitespaces) {
    fbb_.AddElement<uint8_t>(TextEncoderConfig::VT_REMOVE_EXTRA_WHITESPACES, static_cast<uint8_t>(remove_extra_whitespaces), 1);
  }
  void add_escape_whitespaces(bool escape_whitespaces) {
    fbb_.AddElement<uint8_t>(TextEncoderConfig::VT_ESCAPE_WHITESPACES, static_cast<uint8_t>(escape_whitespaces), 1);
  }
  void add_pieces_scores(flatbuffers::Offset<flatbuffers::Vector<float>> pieces_scores) {
    fbb_.AddOffset(TextEncoderConfig::VT_PIECES_SCORES, pieces_scores);
  }
  void add_pieces(flatbuffers::Offset<flatbuffers::String> pieces) {
    fbb_.AddOffset(TextEncoderConfig::VT_PIECES, pieces);
  }
  void add_pieces_offsets(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> pieces_offsets) {
    fbb_.AddOffset(TextEncoderConfig::VT_PIECES_OFFSETS, pieces_offsets);
  }
  void add_matcher_type(libtextclassifier3::SentencePieceMatcherType matcher_type) {
    fbb_.AddElement<int8_t>(TextEncoderConfig::VT_MATCHER_TYPE, static_cast<int8_t>(matcher_type), 0);
  }
  explicit TextEncoderConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TextEncoderConfigBuilder &operator=(const TextEncoderConfigBuilder &);
  flatbuffers::Offset<TextEncoderConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextEncoderConfig>(end);
    return o;
  }
};

inline flatbuffers::Offset<TextEncoderConfig> CreateTextEncoderConfig(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t start_code = 0,
    int32_t end_code = 1,
    int32_t encoding_offset = 2,
    int32_t unknown_code = -1,
    float unknown_score = 0.0f,
    flatbuffers::Offset<flatbuffers::String> normalization_charsmap = 0,
    flatbuffers::Offset<flatbuffers::String> normalization_charsmap_values = 0,
    bool add_dummy_prefix = true,
    bool remove_extra_whitespaces = true,
    bool escape_whitespaces = true,
    flatbuffers::Offset<flatbuffers::Vector<float>> pieces_scores = 0,
    flatbuffers::Offset<flatbuffers::String> pieces = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> pieces_offsets = 0,
    libtextclassifier3::SentencePieceMatcherType matcher_type = libtextclassifier3::SentencePieceMatcherType_MAPPED_TRIE) {
  TextEncoderConfigBuilder builder_(_fbb);
  builder_.add_pieces_offsets(pieces_offsets);
  builder_.add_pieces(pieces);
  builder_.add_pieces_scores(pieces_scores);
  builder_.add_normalization_charsmap_values(normalization_charsmap_values);
  builder_.add_normalization_charsmap(normalization_charsmap);
  builder_.add_unknown_score(unknown_score);
  builder_.add_unknown_code(unknown_code);
  builder_.add_encoding_offset(encoding_offset);
  builder_.add_end_code(end_code);
  builder_.add_start_code(start_code);
  builder_.add_matcher_type(matcher_type);
  builder_.add_escape_whitespaces(escape_whitespaces);
  builder_.add_remove_extra_whitespaces(remove_extra_whitespaces);
  builder_.add_add_dummy_prefix(add_dummy_prefix);
  return builder_.Finish();
}

inline flatbuffers::Offset<TextEncoderConfig> CreateTextEncoderConfigDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t start_code = 0,
    int32_t end_code = 1,
    int32_t encoding_offset = 2,
    int32_t unknown_code = -1,
    float unknown_score = 0.0f,
    const char *normalization_charsmap = nullptr,
    const char *normalization_charsmap_values = nullptr,
    bool add_dummy_prefix = true,
    bool remove_extra_whitespaces = true,
    bool escape_whitespaces = true,
    const std::vector<float> *pieces_scores = nullptr,
    const char *pieces = nullptr,
    const std::vector<uint32_t> *pieces_offsets = nullptr,
    libtextclassifier3::SentencePieceMatcherType matcher_type = libtextclassifier3::SentencePieceMatcherType_MAPPED_TRIE) {
  auto normalization_charsmap__ = normalization_charsmap ? _fbb.CreateString(normalization_charsmap) : 0;
  auto normalization_charsmap_values__ = normalization_charsmap_values ? _fbb.CreateString(normalization_charsmap_values) : 0;
  auto pieces_scores__ = pieces_scores ? _fbb.CreateVector<float>(*pieces_scores) : 0;
  auto pieces__ = pieces ? _fbb.CreateString(pieces) : 0;
  auto pieces_offsets__ = pieces_offsets ? _fbb.CreateVector<uint32_t>(*pieces_offsets) : 0;
  return libtextclassifier3::CreateTextEncoderConfig(
      _fbb,
      start_code,
      end_code,
      encoding_offset,
      unknown_code,
      unknown_score,
      normalization_charsmap__,
      normalization_charsmap_values__,
      add_dummy_prefix,
      remove_extra_whitespaces,
      escape_whitespaces,
      pieces_scores__,
      pieces__,
      pieces_offsets__,
      matcher_type);
}

flatbuffers::Offset<TextEncoderConfig> CreateTextEncoderConfig(flatbuffers::FlatBufferBuilder &_fbb, const TextEncoderConfigT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TextEncoderConfigT *TextEncoderConfig::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::TextEncoderConfigT> _o = std::unique_ptr<libtextclassifier3::TextEncoderConfigT>(new TextEncoderConfigT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TextEncoderConfig::UnPackTo(TextEncoderConfigT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = start_code(); _o->start_code = _e; }
  { auto _e = end_code(); _o->end_code = _e; }
  { auto _e = encoding_offset(); _o->encoding_offset = _e; }
  { auto _e = unknown_code(); _o->unknown_code = _e; }
  { auto _e = unknown_score(); _o->unknown_score = _e; }
  { auto _e = normalization_charsmap(); if (_e) _o->normalization_charsmap = _e->str(); }
  { auto _e = normalization_charsmap_values(); if (_e) _o->normalization_charsmap_values = _e->str(); }
  { auto _e = add_dummy_prefix(); _o->add_dummy_prefix = _e; }
  { auto _e = remove_extra_whitespaces(); _o->remove_extra_whitespaces = _e; }
  { auto _e = escape_whitespaces(); _o->escape_whitespaces = _e; }
  { auto _e = pieces_scores(); if (_e) { _o->pieces_scores.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pieces_scores[_i] = _e->Get(_i); } } }
  { auto _e = pieces(); if (_e) _o->pieces = _e->str(); }
  { auto _e = pieces_offsets(); if (_e) { _o->pieces_offsets.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pieces_offsets[_i] = _e->Get(_i); } } }
  { auto _e = matcher_type(); _o->matcher_type = _e; }
}

inline flatbuffers::Offset<TextEncoderConfig> TextEncoderConfig::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TextEncoderConfigT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTextEncoderConfig(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TextEncoderConfig> CreateTextEncoderConfig(flatbuffers::FlatBufferBuilder &_fbb, const TextEncoderConfigT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TextEncoderConfigT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _start_code = _o->start_code;
  auto _end_code = _o->end_code;
  auto _encoding_offset = _o->encoding_offset;
  auto _unknown_code = _o->unknown_code;
  auto _unknown_score = _o->unknown_score;
  auto _normalization_charsmap = _o->normalization_charsmap.empty() ? 0 : _fbb.CreateString(_o->normalization_charsmap);
  auto _normalization_charsmap_values = _o->normalization_charsmap_values.empty() ? 0 : _fbb.CreateString(_o->normalization_charsmap_values);
  auto _add_dummy_prefix = _o->add_dummy_prefix;
  auto _remove_extra_whitespaces = _o->remove_extra_whitespaces;
  auto _escape_whitespaces = _o->escape_whitespaces;
  auto _pieces_scores = _o->pieces_scores.size() ? _fbb.CreateVector(_o->pieces_scores) : 0;
  auto _pieces = _o->pieces.empty() ? 0 : _fbb.CreateString(_o->pieces);
  auto _pieces_offsets = _o->pieces_offsets.size() ? _fbb.CreateVector(_o->pieces_offsets) : 0;
  auto _matcher_type = _o->matcher_type;
  return libtextclassifier3::CreateTextEncoderConfig(
      _fbb,
      _start_code,
      _end_code,
      _encoding_offset,
      _unknown_code,
      _unknown_score,
      _normalization_charsmap,
      _normalization_charsmap_values,
      _add_dummy_prefix,
      _remove_extra_whitespaces,
      _escape_whitespaces,
      _pieces_scores,
      _pieces,
      _pieces_offsets,
      _matcher_type);
}

}  // namespace libtextclassifier3

#endif  // FLATBUFFERS_GENERATED_TEXTENCODERCONFIG_LIBTEXTCLASSIFIER3_H_
