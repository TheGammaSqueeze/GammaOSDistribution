// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DATETIME_LIBTEXTCLASSIFIER3_GRAMMAR_DATETIME_H_
#define FLATBUFFERS_GENERATED_DATETIME_LIBTEXTCLASSIFIER3_GRAMMAR_DATETIME_H_

#include "flatbuffers/flatbuffers.h"

namespace libtextclassifier3 {
namespace grammar {
namespace datetime {

struct TimeZone;
struct TimeZoneBuilder;
struct TimeZoneT;

struct RelativeDatetimeComponent;
struct RelativeDatetimeComponentBuilder;
struct RelativeDatetimeComponentT;

struct AbsoluteDateTime;
struct AbsoluteDateTimeBuilder;
struct AbsoluteDateTimeT;

struct RelativeDateTime;
struct RelativeDateTimeBuilder;
struct RelativeDateTimeT;

struct UngroundedDatetime;
struct UngroundedDatetimeBuilder;
struct UngroundedDatetimeT;

enum Meridiem {
  Meridiem_UNKNOWN = 0,
  Meridiem_AM = 1,
  Meridiem_PM = 2,
  Meridiem_MIN = Meridiem_UNKNOWN,
  Meridiem_MAX = Meridiem_PM
};

inline const Meridiem (&EnumValuesMeridiem())[3] {
  static const Meridiem values[] = {
    Meridiem_UNKNOWN,
    Meridiem_AM,
    Meridiem_PM
  };
  return values;
}

inline const char * const *EnumNamesMeridiem() {
  static const char * const names[4] = {
    "UNKNOWN",
    "AM",
    "PM",
    nullptr
  };
  return names;
}

inline const char *EnumNameMeridiem(Meridiem e) {
  if (flatbuffers::IsOutRange(e, Meridiem_UNKNOWN, Meridiem_PM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMeridiem()[index];
}

enum ComponentType {
  ComponentType_UNSPECIFIED = 0,
  ComponentType_YEAR = 1,
  ComponentType_MONTH = 2,
  ComponentType_WEEK = 3,
  ComponentType_DAY_OF_WEEK = 4,
  ComponentType_DAY_OF_MONTH = 5,
  ComponentType_HOUR = 6,
  ComponentType_MINUTE = 7,
  ComponentType_SECOND = 8,
  ComponentType_MERIDIEM = 9,
  ComponentType_MIN = ComponentType_UNSPECIFIED,
  ComponentType_MAX = ComponentType_MERIDIEM
};

inline const ComponentType (&EnumValuesComponentType())[10] {
  static const ComponentType values[] = {
    ComponentType_UNSPECIFIED,
    ComponentType_YEAR,
    ComponentType_MONTH,
    ComponentType_WEEK,
    ComponentType_DAY_OF_WEEK,
    ComponentType_DAY_OF_MONTH,
    ComponentType_HOUR,
    ComponentType_MINUTE,
    ComponentType_SECOND,
    ComponentType_MERIDIEM
  };
  return values;
}

inline const char * const *EnumNamesComponentType() {
  static const char * const names[11] = {
    "UNSPECIFIED",
    "YEAR",
    "MONTH",
    "WEEK",
    "DAY_OF_WEEK",
    "DAY_OF_MONTH",
    "HOUR",
    "MINUTE",
    "SECOND",
    "MERIDIEM",
    nullptr
  };
  return names;
}

inline const char *EnumNameComponentType(ComponentType e) {
  if (flatbuffers::IsOutRange(e, ComponentType_UNSPECIFIED, ComponentType_MERIDIEM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesComponentType()[index];
}

namespace RelativeDatetimeComponent_ {

enum Modifier {
  Modifier_UNSPECIFIED = 0,
  Modifier_NEXT = 1,
  Modifier_THIS = 2,
  Modifier_LAST = 3,
  Modifier_NOW = 4,
  Modifier_TOMORROW = 5,
  Modifier_YESTERDAY = 6,
  Modifier_PAST = 7,
  Modifier_FUTURE = 8,
  Modifier_MIN = Modifier_UNSPECIFIED,
  Modifier_MAX = Modifier_FUTURE
};

inline const Modifier (&EnumValuesModifier())[9] {
  static const Modifier values[] = {
    Modifier_UNSPECIFIED,
    Modifier_NEXT,
    Modifier_THIS,
    Modifier_LAST,
    Modifier_NOW,
    Modifier_TOMORROW,
    Modifier_YESTERDAY,
    Modifier_PAST,
    Modifier_FUTURE
  };
  return values;
}

inline const char * const *EnumNamesModifier() {
  static const char * const names[10] = {
    "UNSPECIFIED",
    "NEXT",
    "THIS",
    "LAST",
    "NOW",
    "TOMORROW",
    "YESTERDAY",
    "PAST",
    "FUTURE",
    nullptr
  };
  return names;
}

inline const char *EnumNameModifier(Modifier e) {
  if (flatbuffers::IsOutRange(e, Modifier_UNSPECIFIED, Modifier_FUTURE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesModifier()[index];
}

}  // namespace RelativeDatetimeComponent_

struct TimeZoneT : public flatbuffers::NativeTable {
  typedef TimeZone TableType;
  int32_t utc_offset_mins;
  TimeZoneT()
      : utc_offset_mins(0) {
  }
};

struct TimeZone FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TimeZoneT NativeTableType;
  typedef TimeZoneBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UTC_OFFSET_MINS = 4
  };
  int32_t utc_offset_mins() const {
    return GetField<int32_t>(VT_UTC_OFFSET_MINS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_UTC_OFFSET_MINS) &&
           verifier.EndTable();
  }
  TimeZoneT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TimeZoneT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TimeZone> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TimeZoneT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TimeZoneBuilder {
  typedef TimeZone Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_utc_offset_mins(int32_t utc_offset_mins) {
    fbb_.AddElement<int32_t>(TimeZone::VT_UTC_OFFSET_MINS, utc_offset_mins, 0);
  }
  explicit TimeZoneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TimeZoneBuilder &operator=(const TimeZoneBuilder &);
  flatbuffers::Offset<TimeZone> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TimeZone>(end);
    return o;
  }
};

inline flatbuffers::Offset<TimeZone> CreateTimeZone(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t utc_offset_mins = 0) {
  TimeZoneBuilder builder_(_fbb);
  builder_.add_utc_offset_mins(utc_offset_mins);
  return builder_.Finish();
}

flatbuffers::Offset<TimeZone> CreateTimeZone(flatbuffers::FlatBufferBuilder &_fbb, const TimeZoneT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RelativeDatetimeComponentT : public flatbuffers::NativeTable {
  typedef RelativeDatetimeComponent TableType;
  libtextclassifier3::grammar::datetime::ComponentType component_type;
  libtextclassifier3::grammar::datetime::RelativeDatetimeComponent_::Modifier modifier;
  int32_t value;
  RelativeDatetimeComponentT()
      : component_type(libtextclassifier3::grammar::datetime::ComponentType_UNSPECIFIED),
        modifier(libtextclassifier3::grammar::datetime::RelativeDatetimeComponent_::Modifier_UNSPECIFIED),
        value(0) {
  }
};

struct RelativeDatetimeComponent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RelativeDatetimeComponentT NativeTableType;
  typedef RelativeDatetimeComponentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMPONENT_TYPE = 4,
    VT_MODIFIER = 6,
    VT_VALUE = 8
  };
  libtextclassifier3::grammar::datetime::ComponentType component_type() const {
    return static_cast<libtextclassifier3::grammar::datetime::ComponentType>(GetField<int32_t>(VT_COMPONENT_TYPE, 0));
  }
  libtextclassifier3::grammar::datetime::RelativeDatetimeComponent_::Modifier modifier() const {
    return static_cast<libtextclassifier3::grammar::datetime::RelativeDatetimeComponent_::Modifier>(GetField<int32_t>(VT_MODIFIER, 0));
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COMPONENT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_MODIFIER) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
  RelativeDatetimeComponentT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RelativeDatetimeComponentT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RelativeDatetimeComponent> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RelativeDatetimeComponentT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RelativeDatetimeComponentBuilder {
  typedef RelativeDatetimeComponent Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_component_type(libtextclassifier3::grammar::datetime::ComponentType component_type) {
    fbb_.AddElement<int32_t>(RelativeDatetimeComponent::VT_COMPONENT_TYPE, static_cast<int32_t>(component_type), 0);
  }
  void add_modifier(libtextclassifier3::grammar::datetime::RelativeDatetimeComponent_::Modifier modifier) {
    fbb_.AddElement<int32_t>(RelativeDatetimeComponent::VT_MODIFIER, static_cast<int32_t>(modifier), 0);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(RelativeDatetimeComponent::VT_VALUE, value, 0);
  }
  explicit RelativeDatetimeComponentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RelativeDatetimeComponentBuilder &operator=(const RelativeDatetimeComponentBuilder &);
  flatbuffers::Offset<RelativeDatetimeComponent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RelativeDatetimeComponent>(end);
    return o;
  }
};

inline flatbuffers::Offset<RelativeDatetimeComponent> CreateRelativeDatetimeComponent(
    flatbuffers::FlatBufferBuilder &_fbb,
    libtextclassifier3::grammar::datetime::ComponentType component_type = libtextclassifier3::grammar::datetime::ComponentType_UNSPECIFIED,
    libtextclassifier3::grammar::datetime::RelativeDatetimeComponent_::Modifier modifier = libtextclassifier3::grammar::datetime::RelativeDatetimeComponent_::Modifier_UNSPECIFIED,
    int32_t value = 0) {
  RelativeDatetimeComponentBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_modifier(modifier);
  builder_.add_component_type(component_type);
  return builder_.Finish();
}

flatbuffers::Offset<RelativeDatetimeComponent> CreateRelativeDatetimeComponent(flatbuffers::FlatBufferBuilder &_fbb, const RelativeDatetimeComponentT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AbsoluteDateTimeT : public flatbuffers::NativeTable {
  typedef AbsoluteDateTime TableType;
  int32_t year;
  int32_t month;
  int32_t day;
  int32_t week_day;
  int32_t hour;
  int32_t minute;
  int32_t second;
  double partial_second;
  libtextclassifier3::grammar::datetime::Meridiem meridiem;
  std::unique_ptr<libtextclassifier3::grammar::datetime::TimeZoneT> time_zone;
  AbsoluteDateTimeT()
      : year(-1),
        month(-1),
        day(-1),
        week_day(-1),
        hour(-1),
        minute(-1),
        second(-1),
        partial_second(-1.0),
        meridiem(libtextclassifier3::grammar::datetime::Meridiem_UNKNOWN) {
  }
};

struct AbsoluteDateTime FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AbsoluteDateTimeT NativeTableType;
  typedef AbsoluteDateTimeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_YEAR = 4,
    VT_MONTH = 6,
    VT_DAY = 8,
    VT_WEEK_DAY = 10,
    VT_HOUR = 12,
    VT_MINUTE = 14,
    VT_SECOND = 16,
    VT_PARTIAL_SECOND = 18,
    VT_MERIDIEM = 20,
    VT_TIME_ZONE = 22
  };
  int32_t year() const {
    return GetField<int32_t>(VT_YEAR, -1);
  }
  int32_t month() const {
    return GetField<int32_t>(VT_MONTH, -1);
  }
  int32_t day() const {
    return GetField<int32_t>(VT_DAY, -1);
  }
  int32_t week_day() const {
    return GetField<int32_t>(VT_WEEK_DAY, -1);
  }
  int32_t hour() const {
    return GetField<int32_t>(VT_HOUR, -1);
  }
  int32_t minute() const {
    return GetField<int32_t>(VT_MINUTE, -1);
  }
  int32_t second() const {
    return GetField<int32_t>(VT_SECOND, -1);
  }
  double partial_second() const {
    return GetField<double>(VT_PARTIAL_SECOND, -1.0);
  }
  libtextclassifier3::grammar::datetime::Meridiem meridiem() const {
    return static_cast<libtextclassifier3::grammar::datetime::Meridiem>(GetField<int32_t>(VT_MERIDIEM, 0));
  }
  const libtextclassifier3::grammar::datetime::TimeZone *time_zone() const {
    return GetPointer<const libtextclassifier3::grammar::datetime::TimeZone *>(VT_TIME_ZONE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_YEAR) &&
           VerifyField<int32_t>(verifier, VT_MONTH) &&
           VerifyField<int32_t>(verifier, VT_DAY) &&
           VerifyField<int32_t>(verifier, VT_WEEK_DAY) &&
           VerifyField<int32_t>(verifier, VT_HOUR) &&
           VerifyField<int32_t>(verifier, VT_MINUTE) &&
           VerifyField<int32_t>(verifier, VT_SECOND) &&
           VerifyField<double>(verifier, VT_PARTIAL_SECOND) &&
           VerifyField<int32_t>(verifier, VT_MERIDIEM) &&
           VerifyOffset(verifier, VT_TIME_ZONE) &&
           verifier.VerifyTable(time_zone()) &&
           verifier.EndTable();
  }
  AbsoluteDateTimeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AbsoluteDateTimeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AbsoluteDateTime> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsoluteDateTimeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AbsoluteDateTimeBuilder {
  typedef AbsoluteDateTime Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_year(int32_t year) {
    fbb_.AddElement<int32_t>(AbsoluteDateTime::VT_YEAR, year, -1);
  }
  void add_month(int32_t month) {
    fbb_.AddElement<int32_t>(AbsoluteDateTime::VT_MONTH, month, -1);
  }
  void add_day(int32_t day) {
    fbb_.AddElement<int32_t>(AbsoluteDateTime::VT_DAY, day, -1);
  }
  void add_week_day(int32_t week_day) {
    fbb_.AddElement<int32_t>(AbsoluteDateTime::VT_WEEK_DAY, week_day, -1);
  }
  void add_hour(int32_t hour) {
    fbb_.AddElement<int32_t>(AbsoluteDateTime::VT_HOUR, hour, -1);
  }
  void add_minute(int32_t minute) {
    fbb_.AddElement<int32_t>(AbsoluteDateTime::VT_MINUTE, minute, -1);
  }
  void add_second(int32_t second) {
    fbb_.AddElement<int32_t>(AbsoluteDateTime::VT_SECOND, second, -1);
  }
  void add_partial_second(double partial_second) {
    fbb_.AddElement<double>(AbsoluteDateTime::VT_PARTIAL_SECOND, partial_second, -1.0);
  }
  void add_meridiem(libtextclassifier3::grammar::datetime::Meridiem meridiem) {
    fbb_.AddElement<int32_t>(AbsoluteDateTime::VT_MERIDIEM, static_cast<int32_t>(meridiem), 0);
  }
  void add_time_zone(flatbuffers::Offset<libtextclassifier3::grammar::datetime::TimeZone> time_zone) {
    fbb_.AddOffset(AbsoluteDateTime::VT_TIME_ZONE, time_zone);
  }
  explicit AbsoluteDateTimeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AbsoluteDateTimeBuilder &operator=(const AbsoluteDateTimeBuilder &);
  flatbuffers::Offset<AbsoluteDateTime> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AbsoluteDateTime>(end);
    return o;
  }
};

inline flatbuffers::Offset<AbsoluteDateTime> CreateAbsoluteDateTime(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t year = -1,
    int32_t month = -1,
    int32_t day = -1,
    int32_t week_day = -1,
    int32_t hour = -1,
    int32_t minute = -1,
    int32_t second = -1,
    double partial_second = -1.0,
    libtextclassifier3::grammar::datetime::Meridiem meridiem = libtextclassifier3::grammar::datetime::Meridiem_UNKNOWN,
    flatbuffers::Offset<libtextclassifier3::grammar::datetime::TimeZone> time_zone = 0) {
  AbsoluteDateTimeBuilder builder_(_fbb);
  builder_.add_partial_second(partial_second);
  builder_.add_time_zone(time_zone);
  builder_.add_meridiem(meridiem);
  builder_.add_second(second);
  builder_.add_minute(minute);
  builder_.add_hour(hour);
  builder_.add_week_day(week_day);
  builder_.add_day(day);
  builder_.add_month(month);
  builder_.add_year(year);
  return builder_.Finish();
}

flatbuffers::Offset<AbsoluteDateTime> CreateAbsoluteDateTime(flatbuffers::FlatBufferBuilder &_fbb, const AbsoluteDateTimeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RelativeDateTimeT : public flatbuffers::NativeTable {
  typedef RelativeDateTime TableType;
  std::vector<std::unique_ptr<libtextclassifier3::grammar::datetime::RelativeDatetimeComponentT>> relative_datetime_component;
  std::unique_ptr<libtextclassifier3::grammar::datetime::AbsoluteDateTimeT> base;
  RelativeDateTimeT() {
  }
};

struct RelativeDateTime FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RelativeDateTimeT NativeTableType;
  typedef RelativeDateTimeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RELATIVE_DATETIME_COMPONENT = 4,
    VT_BASE = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::datetime::RelativeDatetimeComponent>> *relative_datetime_component() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::datetime::RelativeDatetimeComponent>> *>(VT_RELATIVE_DATETIME_COMPONENT);
  }
  const libtextclassifier3::grammar::datetime::AbsoluteDateTime *base() const {
    return GetPointer<const libtextclassifier3::grammar::datetime::AbsoluteDateTime *>(VT_BASE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RELATIVE_DATETIME_COMPONENT) &&
           verifier.VerifyVector(relative_datetime_component()) &&
           verifier.VerifyVectorOfTables(relative_datetime_component()) &&
           VerifyOffset(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           verifier.EndTable();
  }
  RelativeDateTimeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RelativeDateTimeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RelativeDateTime> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RelativeDateTimeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RelativeDateTimeBuilder {
  typedef RelativeDateTime Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_relative_datetime_component(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::datetime::RelativeDatetimeComponent>>> relative_datetime_component) {
    fbb_.AddOffset(RelativeDateTime::VT_RELATIVE_DATETIME_COMPONENT, relative_datetime_component);
  }
  void add_base(flatbuffers::Offset<libtextclassifier3::grammar::datetime::AbsoluteDateTime> base) {
    fbb_.AddOffset(RelativeDateTime::VT_BASE, base);
  }
  explicit RelativeDateTimeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RelativeDateTimeBuilder &operator=(const RelativeDateTimeBuilder &);
  flatbuffers::Offset<RelativeDateTime> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RelativeDateTime>(end);
    return o;
  }
};

inline flatbuffers::Offset<RelativeDateTime> CreateRelativeDateTime(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::datetime::RelativeDatetimeComponent>>> relative_datetime_component = 0,
    flatbuffers::Offset<libtextclassifier3::grammar::datetime::AbsoluteDateTime> base = 0) {
  RelativeDateTimeBuilder builder_(_fbb);
  builder_.add_base(base);
  builder_.add_relative_datetime_component(relative_datetime_component);
  return builder_.Finish();
}

inline flatbuffers::Offset<RelativeDateTime> CreateRelativeDateTimeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<libtextclassifier3::grammar::datetime::RelativeDatetimeComponent>> *relative_datetime_component = nullptr,
    flatbuffers::Offset<libtextclassifier3::grammar::datetime::AbsoluteDateTime> base = 0) {
  auto relative_datetime_component__ = relative_datetime_component ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::grammar::datetime::RelativeDatetimeComponent>>(*relative_datetime_component) : 0;
  return libtextclassifier3::grammar::datetime::CreateRelativeDateTime(
      _fbb,
      relative_datetime_component__,
      base);
}

flatbuffers::Offset<RelativeDateTime> CreateRelativeDateTime(flatbuffers::FlatBufferBuilder &_fbb, const RelativeDateTimeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UngroundedDatetimeT : public flatbuffers::NativeTable {
  typedef UngroundedDatetime TableType;
  std::unique_ptr<libtextclassifier3::grammar::datetime::AbsoluteDateTimeT> absolute_datetime;
  std::unique_ptr<libtextclassifier3::grammar::datetime::RelativeDateTimeT> relative_datetime;
  uint32_t annotation_usecases;
  UngroundedDatetimeT()
      : annotation_usecases(4294967295) {
  }
};

struct UngroundedDatetime FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UngroundedDatetimeT NativeTableType;
  typedef UngroundedDatetimeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ABSOLUTE_DATETIME = 4,
    VT_RELATIVE_DATETIME = 6,
    VT_ANNOTATION_USECASES = 8
  };
  const libtextclassifier3::grammar::datetime::AbsoluteDateTime *absolute_datetime() const {
    return GetPointer<const libtextclassifier3::grammar::datetime::AbsoluteDateTime *>(VT_ABSOLUTE_DATETIME);
  }
  const libtextclassifier3::grammar::datetime::RelativeDateTime *relative_datetime() const {
    return GetPointer<const libtextclassifier3::grammar::datetime::RelativeDateTime *>(VT_RELATIVE_DATETIME);
  }
  uint32_t annotation_usecases() const {
    return GetField<uint32_t>(VT_ANNOTATION_USECASES, 4294967295);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ABSOLUTE_DATETIME) &&
           verifier.VerifyTable(absolute_datetime()) &&
           VerifyOffset(verifier, VT_RELATIVE_DATETIME) &&
           verifier.VerifyTable(relative_datetime()) &&
           VerifyField<uint32_t>(verifier, VT_ANNOTATION_USECASES) &&
           verifier.EndTable();
  }
  UngroundedDatetimeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UngroundedDatetimeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UngroundedDatetime> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UngroundedDatetimeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UngroundedDatetimeBuilder {
  typedef UngroundedDatetime Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_absolute_datetime(flatbuffers::Offset<libtextclassifier3::grammar::datetime::AbsoluteDateTime> absolute_datetime) {
    fbb_.AddOffset(UngroundedDatetime::VT_ABSOLUTE_DATETIME, absolute_datetime);
  }
  void add_relative_datetime(flatbuffers::Offset<libtextclassifier3::grammar::datetime::RelativeDateTime> relative_datetime) {
    fbb_.AddOffset(UngroundedDatetime::VT_RELATIVE_DATETIME, relative_datetime);
  }
  void add_annotation_usecases(uint32_t annotation_usecases) {
    fbb_.AddElement<uint32_t>(UngroundedDatetime::VT_ANNOTATION_USECASES, annotation_usecases, 4294967295);
  }
  explicit UngroundedDatetimeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UngroundedDatetimeBuilder &operator=(const UngroundedDatetimeBuilder &);
  flatbuffers::Offset<UngroundedDatetime> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UngroundedDatetime>(end);
    return o;
  }
};

inline flatbuffers::Offset<UngroundedDatetime> CreateUngroundedDatetime(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<libtextclassifier3::grammar::datetime::AbsoluteDateTime> absolute_datetime = 0,
    flatbuffers::Offset<libtextclassifier3::grammar::datetime::RelativeDateTime> relative_datetime = 0,
    uint32_t annotation_usecases = 4294967295) {
  UngroundedDatetimeBuilder builder_(_fbb);
  builder_.add_annotation_usecases(annotation_usecases);
  builder_.add_relative_datetime(relative_datetime);
  builder_.add_absolute_datetime(absolute_datetime);
  return builder_.Finish();
}

flatbuffers::Offset<UngroundedDatetime> CreateUngroundedDatetime(flatbuffers::FlatBufferBuilder &_fbb, const UngroundedDatetimeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TimeZoneT *TimeZone::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::grammar::datetime::TimeZoneT> _o = std::unique_ptr<libtextclassifier3::grammar::datetime::TimeZoneT>(new TimeZoneT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TimeZone::UnPackTo(TimeZoneT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = utc_offset_mins(); _o->utc_offset_mins = _e; }
}

inline flatbuffers::Offset<TimeZone> TimeZone::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TimeZoneT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTimeZone(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TimeZone> CreateTimeZone(flatbuffers::FlatBufferBuilder &_fbb, const TimeZoneT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TimeZoneT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _utc_offset_mins = _o->utc_offset_mins;
  return libtextclassifier3::grammar::datetime::CreateTimeZone(
      _fbb,
      _utc_offset_mins);
}

inline RelativeDatetimeComponentT *RelativeDatetimeComponent::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::grammar::datetime::RelativeDatetimeComponentT> _o = std::unique_ptr<libtextclassifier3::grammar::datetime::RelativeDatetimeComponentT>(new RelativeDatetimeComponentT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RelativeDatetimeComponent::UnPackTo(RelativeDatetimeComponentT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = component_type(); _o->component_type = _e; }
  { auto _e = modifier(); _o->modifier = _e; }
  { auto _e = value(); _o->value = _e; }
}

inline flatbuffers::Offset<RelativeDatetimeComponent> RelativeDatetimeComponent::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RelativeDatetimeComponentT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRelativeDatetimeComponent(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RelativeDatetimeComponent> CreateRelativeDatetimeComponent(flatbuffers::FlatBufferBuilder &_fbb, const RelativeDatetimeComponentT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RelativeDatetimeComponentT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _component_type = _o->component_type;
  auto _modifier = _o->modifier;
  auto _value = _o->value;
  return libtextclassifier3::grammar::datetime::CreateRelativeDatetimeComponent(
      _fbb,
      _component_type,
      _modifier,
      _value);
}

inline AbsoluteDateTimeT *AbsoluteDateTime::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::grammar::datetime::AbsoluteDateTimeT> _o = std::unique_ptr<libtextclassifier3::grammar::datetime::AbsoluteDateTimeT>(new AbsoluteDateTimeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AbsoluteDateTime::UnPackTo(AbsoluteDateTimeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = year(); _o->year = _e; }
  { auto _e = month(); _o->month = _e; }
  { auto _e = day(); _o->day = _e; }
  { auto _e = week_day(); _o->week_day = _e; }
  { auto _e = hour(); _o->hour = _e; }
  { auto _e = minute(); _o->minute = _e; }
  { auto _e = second(); _o->second = _e; }
  { auto _e = partial_second(); _o->partial_second = _e; }
  { auto _e = meridiem(); _o->meridiem = _e; }
  { auto _e = time_zone(); if (_e) _o->time_zone = std::unique_ptr<libtextclassifier3::grammar::datetime::TimeZoneT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<AbsoluteDateTime> AbsoluteDateTime::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsoluteDateTimeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAbsoluteDateTime(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AbsoluteDateTime> CreateAbsoluteDateTime(flatbuffers::FlatBufferBuilder &_fbb, const AbsoluteDateTimeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AbsoluteDateTimeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _year = _o->year;
  auto _month = _o->month;
  auto _day = _o->day;
  auto _week_day = _o->week_day;
  auto _hour = _o->hour;
  auto _minute = _o->minute;
  auto _second = _o->second;
  auto _partial_second = _o->partial_second;
  auto _meridiem = _o->meridiem;
  auto _time_zone = _o->time_zone ? CreateTimeZone(_fbb, _o->time_zone.get(), _rehasher) : 0;
  return libtextclassifier3::grammar::datetime::CreateAbsoluteDateTime(
      _fbb,
      _year,
      _month,
      _day,
      _week_day,
      _hour,
      _minute,
      _second,
      _partial_second,
      _meridiem,
      _time_zone);
}

inline RelativeDateTimeT *RelativeDateTime::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::grammar::datetime::RelativeDateTimeT> _o = std::unique_ptr<libtextclassifier3::grammar::datetime::RelativeDateTimeT>(new RelativeDateTimeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RelativeDateTime::UnPackTo(RelativeDateTimeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = relative_datetime_component(); if (_e) { _o->relative_datetime_component.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->relative_datetime_component[_i] = std::unique_ptr<libtextclassifier3::grammar::datetime::RelativeDatetimeComponentT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = base(); if (_e) _o->base = std::unique_ptr<libtextclassifier3::grammar::datetime::AbsoluteDateTimeT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<RelativeDateTime> RelativeDateTime::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RelativeDateTimeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRelativeDateTime(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RelativeDateTime> CreateRelativeDateTime(flatbuffers::FlatBufferBuilder &_fbb, const RelativeDateTimeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RelativeDateTimeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _relative_datetime_component = _o->relative_datetime_component.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::grammar::datetime::RelativeDatetimeComponent>> (_o->relative_datetime_component.size(), [](size_t i, _VectorArgs *__va) { return CreateRelativeDatetimeComponent(*__va->__fbb, __va->__o->relative_datetime_component[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _base = _o->base ? CreateAbsoluteDateTime(_fbb, _o->base.get(), _rehasher) : 0;
  return libtextclassifier3::grammar::datetime::CreateRelativeDateTime(
      _fbb,
      _relative_datetime_component,
      _base);
}

inline UngroundedDatetimeT *UngroundedDatetime::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::grammar::datetime::UngroundedDatetimeT> _o = std::unique_ptr<libtextclassifier3::grammar::datetime::UngroundedDatetimeT>(new UngroundedDatetimeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UngroundedDatetime::UnPackTo(UngroundedDatetimeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = absolute_datetime(); if (_e) _o->absolute_datetime = std::unique_ptr<libtextclassifier3::grammar::datetime::AbsoluteDateTimeT>(_e->UnPack(_resolver)); }
  { auto _e = relative_datetime(); if (_e) _o->relative_datetime = std::unique_ptr<libtextclassifier3::grammar::datetime::RelativeDateTimeT>(_e->UnPack(_resolver)); }
  { auto _e = annotation_usecases(); _o->annotation_usecases = _e; }
}

inline flatbuffers::Offset<UngroundedDatetime> UngroundedDatetime::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UngroundedDatetimeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUngroundedDatetime(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UngroundedDatetime> CreateUngroundedDatetime(flatbuffers::FlatBufferBuilder &_fbb, const UngroundedDatetimeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UngroundedDatetimeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _absolute_datetime = _o->absolute_datetime ? CreateAbsoluteDateTime(_fbb, _o->absolute_datetime.get(), _rehasher) : 0;
  auto _relative_datetime = _o->relative_datetime ? CreateRelativeDateTime(_fbb, _o->relative_datetime.get(), _rehasher) : 0;
  auto _annotation_usecases = _o->annotation_usecases;
  return libtextclassifier3::grammar::datetime::CreateUngroundedDatetime(
      _fbb,
      _absolute_datetime,
      _relative_datetime,
      _annotation_usecases);
}

}  // namespace datetime
}  // namespace grammar
}  // namespace libtextclassifier3

#endif  // FLATBUFFERS_GENERATED_DATETIME_LIBTEXTCLASSIFIER3_GRAMMAR_DATETIME_H_
