// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TOKENIZER_LIBTEXTCLASSIFIER3_H_
#define FLATBUFFERS_GENERATED_TOKENIZER_LIBTEXTCLASSIFIER3_H_

#include "flatbuffers/flatbuffers.h"

namespace libtextclassifier3 {

struct TokenizationCodepointRange;
struct TokenizationCodepointRangeBuilder;
struct TokenizationCodepointRangeT;

enum TokenizationType {
  TokenizationType_INVALID_TOKENIZATION_TYPE = 0,
  TokenizationType_INTERNAL_TOKENIZER = 1,
  TokenizationType_ICU = 2,
  TokenizationType_MIXED = 3,
  TokenizationType_LETTER_DIGIT = 4,
  TokenizationType_MIN = TokenizationType_INVALID_TOKENIZATION_TYPE,
  TokenizationType_MAX = TokenizationType_LETTER_DIGIT
};

inline const TokenizationType (&EnumValuesTokenizationType())[5] {
  static const TokenizationType values[] = {
    TokenizationType_INVALID_TOKENIZATION_TYPE,
    TokenizationType_INTERNAL_TOKENIZER,
    TokenizationType_ICU,
    TokenizationType_MIXED,
    TokenizationType_LETTER_DIGIT
  };
  return values;
}

inline const char * const *EnumNamesTokenizationType() {
  static const char * const names[6] = {
    "INVALID_TOKENIZATION_TYPE",
    "INTERNAL_TOKENIZER",
    "ICU",
    "MIXED",
    "LETTER_DIGIT",
    nullptr
  };
  return names;
}

inline const char *EnumNameTokenizationType(TokenizationType e) {
  if (flatbuffers::IsOutRange(e, TokenizationType_INVALID_TOKENIZATION_TYPE, TokenizationType_LETTER_DIGIT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTokenizationType()[index];
}

namespace TokenizationCodepointRange_ {

enum Role {
  Role_DEFAULT_ROLE = 0,
  Role_SPLIT_BEFORE = 1,
  Role_SPLIT_AFTER = 2,
  Role_TOKEN_SEPARATOR = 3,
  Role_DISCARD_CODEPOINT = 4,
  Role_WHITESPACE_SEPARATOR = 7,
  Role_MIN = Role_DEFAULT_ROLE,
  Role_MAX = Role_WHITESPACE_SEPARATOR
};

inline const Role (&EnumValuesRole())[6] {
  static const Role values[] = {
    Role_DEFAULT_ROLE,
    Role_SPLIT_BEFORE,
    Role_SPLIT_AFTER,
    Role_TOKEN_SEPARATOR,
    Role_DISCARD_CODEPOINT,
    Role_WHITESPACE_SEPARATOR
  };
  return values;
}

inline const char * const *EnumNamesRole() {
  static const char * const names[9] = {
    "DEFAULT_ROLE",
    "SPLIT_BEFORE",
    "SPLIT_AFTER",
    "TOKEN_SEPARATOR",
    "DISCARD_CODEPOINT",
    "",
    "",
    "WHITESPACE_SEPARATOR",
    nullptr
  };
  return names;
}

inline const char *EnumNameRole(Role e) {
  if (flatbuffers::IsOutRange(e, Role_DEFAULT_ROLE, Role_WHITESPACE_SEPARATOR)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRole()[index];
}

}  // namespace TokenizationCodepointRange_

struct TokenizationCodepointRangeT : public flatbuffers::NativeTable {
  typedef TokenizationCodepointRange TableType;
  int32_t start;
  int32_t end;
  libtextclassifier3::TokenizationCodepointRange_::Role role;
  int32_t script_id;
  TokenizationCodepointRangeT()
      : start(0),
        end(0),
        role(libtextclassifier3::TokenizationCodepointRange_::Role_DEFAULT_ROLE),
        script_id(0) {
  }
};

struct TokenizationCodepointRange FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TokenizationCodepointRangeT NativeTableType;
  typedef TokenizationCodepointRangeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START = 4,
    VT_END = 6,
    VT_ROLE = 8,
    VT_SCRIPT_ID = 10
  };
  int32_t start() const {
    return GetField<int32_t>(VT_START, 0);
  }
  int32_t end() const {
    return GetField<int32_t>(VT_END, 0);
  }
  libtextclassifier3::TokenizationCodepointRange_::Role role() const {
    return static_cast<libtextclassifier3::TokenizationCodepointRange_::Role>(GetField<int32_t>(VT_ROLE, 0));
  }
  int32_t script_id() const {
    return GetField<int32_t>(VT_SCRIPT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_START) &&
           VerifyField<int32_t>(verifier, VT_END) &&
           VerifyField<int32_t>(verifier, VT_ROLE) &&
           VerifyField<int32_t>(verifier, VT_SCRIPT_ID) &&
           verifier.EndTable();
  }
  TokenizationCodepointRangeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TokenizationCodepointRangeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TokenizationCodepointRange> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TokenizationCodepointRangeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TokenizationCodepointRangeBuilder {
  typedef TokenizationCodepointRange Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_start(int32_t start) {
    fbb_.AddElement<int32_t>(TokenizationCodepointRange::VT_START, start, 0);
  }
  void add_end(int32_t end) {
    fbb_.AddElement<int32_t>(TokenizationCodepointRange::VT_END, end, 0);
  }
  void add_role(libtextclassifier3::TokenizationCodepointRange_::Role role) {
    fbb_.AddElement<int32_t>(TokenizationCodepointRange::VT_ROLE, static_cast<int32_t>(role), 0);
  }
  void add_script_id(int32_t script_id) {
    fbb_.AddElement<int32_t>(TokenizationCodepointRange::VT_SCRIPT_ID, script_id, 0);
  }
  explicit TokenizationCodepointRangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TokenizationCodepointRangeBuilder &operator=(const TokenizationCodepointRangeBuilder &);
  flatbuffers::Offset<TokenizationCodepointRange> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TokenizationCodepointRange>(end);
    return o;
  }
};

inline flatbuffers::Offset<TokenizationCodepointRange> CreateTokenizationCodepointRange(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t start = 0,
    int32_t end = 0,
    libtextclassifier3::TokenizationCodepointRange_::Role role = libtextclassifier3::TokenizationCodepointRange_::Role_DEFAULT_ROLE,
    int32_t script_id = 0) {
  TokenizationCodepointRangeBuilder builder_(_fbb);
  builder_.add_script_id(script_id);
  builder_.add_role(role);
  builder_.add_end(end);
  builder_.add_start(start);
  return builder_.Finish();
}

flatbuffers::Offset<TokenizationCodepointRange> CreateTokenizationCodepointRange(flatbuffers::FlatBufferBuilder &_fbb, const TokenizationCodepointRangeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TokenizationCodepointRangeT *TokenizationCodepointRange::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::TokenizationCodepointRangeT> _o = std::unique_ptr<libtextclassifier3::TokenizationCodepointRangeT>(new TokenizationCodepointRangeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TokenizationCodepointRange::UnPackTo(TokenizationCodepointRangeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = start(); _o->start = _e; }
  { auto _e = end(); _o->end = _e; }
  { auto _e = role(); _o->role = _e; }
  { auto _e = script_id(); _o->script_id = _e; }
}

inline flatbuffers::Offset<TokenizationCodepointRange> TokenizationCodepointRange::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TokenizationCodepointRangeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTokenizationCodepointRange(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TokenizationCodepointRange> CreateTokenizationCodepointRange(flatbuffers::FlatBufferBuilder &_fbb, const TokenizationCodepointRangeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TokenizationCodepointRangeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _start = _o->start;
  auto _end = _o->end;
  auto _role = _o->role;
  auto _script_id = _o->script_id;
  return libtextclassifier3::CreateTokenizationCodepointRange(
      _fbb,
      _start,
      _end,
      _role,
      _script_id);
}

}  // namespace libtextclassifier3

#endif  // FLATBUFFERS_GENERATED_TOKENIZER_LIBTEXTCLASSIFIER3_H_
