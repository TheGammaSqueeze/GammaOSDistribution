// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MODEL_LIBTEXTCLASSIFIER3_H_
#define FLATBUFFERS_GENERATED_MODEL_LIBTEXTCLASSIFIER3_H_

#include "flatbuffers/flatbuffers.h"

#include "annotator/entity-data_generated.h"
#include "annotator/experimental/experimental_generated.h"
#include "utils/codepoint-range_generated.h"
#include "utils/container/bit-vector_generated.h"
#include "utils/flatbuffers/flatbuffers_generated.h"
#include "utils/grammar/rules_generated.h"
#include "utils/grammar/semantics/expression_generated.h"
#include "utils/i18n/language-tag_generated.h"
#include "utils/intents/intent-config_generated.h"
#include "utils/normalization_generated.h"
#include "utils/resources_generated.h"
#include "utils/tokenizer_generated.h"
#include "utils/zlib/buffer_generated.h"

namespace libtextclassifier3 {

struct SelectionModelOptions;
struct SelectionModelOptionsBuilder;
struct SelectionModelOptionsT;

struct ClassificationModelOptions;
struct ClassificationModelOptionsBuilder;
struct ClassificationModelOptionsT;

struct VerificationOptions;
struct VerificationOptionsBuilder;
struct VerificationOptionsT;

struct CapturingGroup;
struct CapturingGroupBuilder;
struct CapturingGroupT;

namespace RegexModel_ {

struct Pattern;
struct PatternBuilder;
struct PatternT;

}  // namespace RegexModel_

struct RegexModel;
struct RegexModelBuilder;
struct RegexModelT;

namespace DatetimeModelPattern_ {

struct Regex;
struct RegexBuilder;
struct RegexT;

}  // namespace DatetimeModelPattern_

struct DatetimeModelPattern;
struct DatetimeModelPatternBuilder;
struct DatetimeModelPatternT;

struct DatetimeModelExtractor;
struct DatetimeModelExtractorBuilder;
struct DatetimeModelExtractorT;

struct DatetimeModel;
struct DatetimeModelBuilder;
struct DatetimeModelT;

struct GrammarTokenizerOptions;
struct GrammarTokenizerOptionsBuilder;
struct GrammarTokenizerOptionsT;

namespace DatetimeModelLibrary_ {

struct Item;
struct ItemBuilder;
struct ItemT;

}  // namespace DatetimeModelLibrary_

struct DatetimeModelLibrary;
struct DatetimeModelLibraryBuilder;
struct DatetimeModelLibraryT;

namespace GrammarModel_ {

struct RuleClassificationResult;
struct RuleClassificationResultBuilder;
struct RuleClassificationResultT;

}  // namespace GrammarModel_

struct GrammarModel;
struct GrammarModelBuilder;
struct GrammarModelT;

namespace MoneyParsingOptions_ {

struct QuantitiesNameToExponentEntry;
struct QuantitiesNameToExponentEntryBuilder;
struct QuantitiesNameToExponentEntryT;

}  // namespace MoneyParsingOptions_

struct MoneyParsingOptions;
struct MoneyParsingOptionsBuilder;
struct MoneyParsingOptionsT;

namespace ModelTriggeringOptions_ {

struct CollectionToPriorityEntry;
struct CollectionToPriorityEntryBuilder;
struct CollectionToPriorityEntryT;

}  // namespace ModelTriggeringOptions_

struct ModelTriggeringOptions;
struct ModelTriggeringOptionsBuilder;
struct ModelTriggeringOptionsT;

struct OutputOptions;
struct OutputOptionsBuilder;
struct OutputOptionsT;

namespace Model_ {

struct EmbeddingPruningMask;
struct EmbeddingPruningMaskBuilder;
struct EmbeddingPruningMaskT;

struct ConflictResolutionOptions;
struct ConflictResolutionOptionsBuilder;
struct ConflictResolutionOptionsT;

}  // namespace Model_

struct Model;
struct ModelBuilder;
struct ModelT;

namespace FeatureProcessorOptions_ {

struct BoundsSensitiveFeatures;
struct BoundsSensitiveFeaturesBuilder;
struct BoundsSensitiveFeaturesT;

}  // namespace FeatureProcessorOptions_

struct FeatureProcessorOptions;
struct FeatureProcessorOptionsBuilder;
struct FeatureProcessorOptionsT;

struct NumberAnnotatorOptions;
struct NumberAnnotatorOptionsBuilder;
struct NumberAnnotatorOptionsT;

struct DurationAnnotatorOptions;
struct DurationAnnotatorOptionsBuilder;
struct DurationAnnotatorOptionsT;

struct ContactAnnotatorOptions;
struct ContactAnnotatorOptionsBuilder;
struct ContactAnnotatorOptionsT;

namespace TranslateAnnotatorOptions_ {

struct BackoffOptions;
struct BackoffOptionsBuilder;
struct BackoffOptionsT;

}  // namespace TranslateAnnotatorOptions_

struct TranslateAnnotatorOptions;
struct TranslateAnnotatorOptionsBuilder;
struct TranslateAnnotatorOptionsT;

namespace PodNerModel_ {

struct Collection;
struct CollectionBuilder;
struct CollectionT;

struct Label;
struct LabelBuilder;
struct LabelT;

}  // namespace PodNerModel_

struct PodNerModel;
struct PodNerModelBuilder;
struct PodNerModelT;

struct VocabModel;
struct VocabModelBuilder;
struct VocabModelT;

enum ModeFlag {
  ModeFlag_NONE = 0,
  ModeFlag_ANNOTATION = 1,
  ModeFlag_CLASSIFICATION = 2,
  ModeFlag_ANNOTATION_AND_CLASSIFICATION = 3,
  ModeFlag_SELECTION = 4,
  ModeFlag_ANNOTATION_AND_SELECTION = 5,
  ModeFlag_CLASSIFICATION_AND_SELECTION = 6,
  ModeFlag_ALL = 7,
  ModeFlag_MIN = ModeFlag_NONE,
  ModeFlag_MAX = ModeFlag_ALL
};

inline const ModeFlag (&EnumValuesModeFlag())[8] {
  static const ModeFlag values[] = {
    ModeFlag_NONE,
    ModeFlag_ANNOTATION,
    ModeFlag_CLASSIFICATION,
    ModeFlag_ANNOTATION_AND_CLASSIFICATION,
    ModeFlag_SELECTION,
    ModeFlag_ANNOTATION_AND_SELECTION,
    ModeFlag_CLASSIFICATION_AND_SELECTION,
    ModeFlag_ALL
  };
  return values;
}

inline const char * const *EnumNamesModeFlag() {
  static const char * const names[9] = {
    "NONE",
    "ANNOTATION",
    "CLASSIFICATION",
    "ANNOTATION_AND_CLASSIFICATION",
    "SELECTION",
    "ANNOTATION_AND_SELECTION",
    "CLASSIFICATION_AND_SELECTION",
    "ALL",
    nullptr
  };
  return names;
}

inline const char *EnumNameModeFlag(ModeFlag e) {
  if (flatbuffers::IsOutRange(e, ModeFlag_NONE, ModeFlag_ALL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesModeFlag()[index];
}

enum AnnotationUsecase {
  AnnotationUsecase_ANNOTATION_USECASE_SMART = 0,
  AnnotationUsecase_ANNOTATION_USECASE_RAW = 1,
  AnnotationUsecase_MIN = AnnotationUsecase_ANNOTATION_USECASE_SMART,
  AnnotationUsecase_MAX = AnnotationUsecase_ANNOTATION_USECASE_RAW
};

inline const AnnotationUsecase (&EnumValuesAnnotationUsecase())[2] {
  static const AnnotationUsecase values[] = {
    AnnotationUsecase_ANNOTATION_USECASE_SMART,
    AnnotationUsecase_ANNOTATION_USECASE_RAW
  };
  return values;
}

inline const char * const *EnumNamesAnnotationUsecase() {
  static const char * const names[3] = {
    "ANNOTATION_USECASE_SMART",
    "ANNOTATION_USECASE_RAW",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnnotationUsecase(AnnotationUsecase e) {
  if (flatbuffers::IsOutRange(e, AnnotationUsecase_ANNOTATION_USECASE_SMART, AnnotationUsecase_ANNOTATION_USECASE_RAW)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnnotationUsecase()[index];
}

enum DatetimeExtractorType {
  DatetimeExtractorType_UNKNOWN_DATETIME_EXTRACTOR_TYPE = 0,
  DatetimeExtractorType_AM = 1,
  DatetimeExtractorType_PM = 2,
  DatetimeExtractorType_JANUARY = 3,
  DatetimeExtractorType_FEBRUARY = 4,
  DatetimeExtractorType_MARCH = 5,
  DatetimeExtractorType_APRIL = 6,
  DatetimeExtractorType_MAY = 7,
  DatetimeExtractorType_JUNE = 8,
  DatetimeExtractorType_JULY = 9,
  DatetimeExtractorType_AUGUST = 10,
  DatetimeExtractorType_SEPTEMBER = 11,
  DatetimeExtractorType_OCTOBER = 12,
  DatetimeExtractorType_NOVEMBER = 13,
  DatetimeExtractorType_DECEMBER = 14,
  DatetimeExtractorType_NEXT = 15,
  DatetimeExtractorType_NEXT_OR_SAME = 16,
  DatetimeExtractorType_LAST = 17,
  DatetimeExtractorType_NOW = 18,
  DatetimeExtractorType_TOMORROW = 19,
  DatetimeExtractorType_YESTERDAY = 20,
  DatetimeExtractorType_PAST = 21,
  DatetimeExtractorType_FUTURE = 22,
  DatetimeExtractorType_DAY = 23,
  DatetimeExtractorType_WEEK = 24,
  DatetimeExtractorType_MONTH = 25,
  DatetimeExtractorType_YEAR = 26,
  DatetimeExtractorType_MONDAY = 27,
  DatetimeExtractorType_TUESDAY = 28,
  DatetimeExtractorType_WEDNESDAY = 29,
  DatetimeExtractorType_THURSDAY = 30,
  DatetimeExtractorType_FRIDAY = 31,
  DatetimeExtractorType_SATURDAY = 32,
  DatetimeExtractorType_SUNDAY = 33,
  DatetimeExtractorType_DAYS = 34,
  DatetimeExtractorType_WEEKS = 35,
  DatetimeExtractorType_MONTHS = 36,
  DatetimeExtractorType_HOURS = 37,
  DatetimeExtractorType_MINUTES = 38,
  DatetimeExtractorType_SECONDS = 39,
  DatetimeExtractorType_YEARS = 40,
  DatetimeExtractorType_DIGITS = 41,
  DatetimeExtractorType_SIGNEDDIGITS = 42,
  DatetimeExtractorType_ZERO = 43,
  DatetimeExtractorType_ONE = 44,
  DatetimeExtractorType_TWO = 45,
  DatetimeExtractorType_THREE = 46,
  DatetimeExtractorType_FOUR = 47,
  DatetimeExtractorType_FIVE = 48,
  DatetimeExtractorType_SIX = 49,
  DatetimeExtractorType_SEVEN = 50,
  DatetimeExtractorType_EIGHT = 51,
  DatetimeExtractorType_NINE = 52,
  DatetimeExtractorType_TEN = 53,
  DatetimeExtractorType_ELEVEN = 54,
  DatetimeExtractorType_TWELVE = 55,
  DatetimeExtractorType_THIRTEEN = 56,
  DatetimeExtractorType_FOURTEEN = 57,
  DatetimeExtractorType_FIFTEEN = 58,
  DatetimeExtractorType_SIXTEEN = 59,
  DatetimeExtractorType_SEVENTEEN = 60,
  DatetimeExtractorType_EIGHTEEN = 61,
  DatetimeExtractorType_NINETEEN = 62,
  DatetimeExtractorType_TWENTY = 63,
  DatetimeExtractorType_THIRTY = 64,
  DatetimeExtractorType_FORTY = 65,
  DatetimeExtractorType_FIFTY = 66,
  DatetimeExtractorType_SIXTY = 67,
  DatetimeExtractorType_SEVENTY = 68,
  DatetimeExtractorType_EIGHTY = 69,
  DatetimeExtractorType_NINETY = 70,
  DatetimeExtractorType_HUNDRED = 71,
  DatetimeExtractorType_THOUSAND = 72,
  DatetimeExtractorType_NOON = 73,
  DatetimeExtractorType_MIDNIGHT = 74,
  DatetimeExtractorType_MIN = DatetimeExtractorType_UNKNOWN_DATETIME_EXTRACTOR_TYPE,
  DatetimeExtractorType_MAX = DatetimeExtractorType_MIDNIGHT
};

inline const DatetimeExtractorType (&EnumValuesDatetimeExtractorType())[75] {
  static const DatetimeExtractorType values[] = {
    DatetimeExtractorType_UNKNOWN_DATETIME_EXTRACTOR_TYPE,
    DatetimeExtractorType_AM,
    DatetimeExtractorType_PM,
    DatetimeExtractorType_JANUARY,
    DatetimeExtractorType_FEBRUARY,
    DatetimeExtractorType_MARCH,
    DatetimeExtractorType_APRIL,
    DatetimeExtractorType_MAY,
    DatetimeExtractorType_JUNE,
    DatetimeExtractorType_JULY,
    DatetimeExtractorType_AUGUST,
    DatetimeExtractorType_SEPTEMBER,
    DatetimeExtractorType_OCTOBER,
    DatetimeExtractorType_NOVEMBER,
    DatetimeExtractorType_DECEMBER,
    DatetimeExtractorType_NEXT,
    DatetimeExtractorType_NEXT_OR_SAME,
    DatetimeExtractorType_LAST,
    DatetimeExtractorType_NOW,
    DatetimeExtractorType_TOMORROW,
    DatetimeExtractorType_YESTERDAY,
    DatetimeExtractorType_PAST,
    DatetimeExtractorType_FUTURE,
    DatetimeExtractorType_DAY,
    DatetimeExtractorType_WEEK,
    DatetimeExtractorType_MONTH,
    DatetimeExtractorType_YEAR,
    DatetimeExtractorType_MONDAY,
    DatetimeExtractorType_TUESDAY,
    DatetimeExtractorType_WEDNESDAY,
    DatetimeExtractorType_THURSDAY,
    DatetimeExtractorType_FRIDAY,
    DatetimeExtractorType_SATURDAY,
    DatetimeExtractorType_SUNDAY,
    DatetimeExtractorType_DAYS,
    DatetimeExtractorType_WEEKS,
    DatetimeExtractorType_MONTHS,
    DatetimeExtractorType_HOURS,
    DatetimeExtractorType_MINUTES,
    DatetimeExtractorType_SECONDS,
    DatetimeExtractorType_YEARS,
    DatetimeExtractorType_DIGITS,
    DatetimeExtractorType_SIGNEDDIGITS,
    DatetimeExtractorType_ZERO,
    DatetimeExtractorType_ONE,
    DatetimeExtractorType_TWO,
    DatetimeExtractorType_THREE,
    DatetimeExtractorType_FOUR,
    DatetimeExtractorType_FIVE,
    DatetimeExtractorType_SIX,
    DatetimeExtractorType_SEVEN,
    DatetimeExtractorType_EIGHT,
    DatetimeExtractorType_NINE,
    DatetimeExtractorType_TEN,
    DatetimeExtractorType_ELEVEN,
    DatetimeExtractorType_TWELVE,
    DatetimeExtractorType_THIRTEEN,
    DatetimeExtractorType_FOURTEEN,
    DatetimeExtractorType_FIFTEEN,
    DatetimeExtractorType_SIXTEEN,
    DatetimeExtractorType_SEVENTEEN,
    DatetimeExtractorType_EIGHTEEN,
    DatetimeExtractorType_NINETEEN,
    DatetimeExtractorType_TWENTY,
    DatetimeExtractorType_THIRTY,
    DatetimeExtractorType_FORTY,
    DatetimeExtractorType_FIFTY,
    DatetimeExtractorType_SIXTY,
    DatetimeExtractorType_SEVENTY,
    DatetimeExtractorType_EIGHTY,
    DatetimeExtractorType_NINETY,
    DatetimeExtractorType_HUNDRED,
    DatetimeExtractorType_THOUSAND,
    DatetimeExtractorType_NOON,
    DatetimeExtractorType_MIDNIGHT
  };
  return values;
}

inline const char * const *EnumNamesDatetimeExtractorType() {
  static const char * const names[76] = {
    "UNKNOWN_DATETIME_EXTRACTOR_TYPE",
    "AM",
    "PM",
    "JANUARY",
    "FEBRUARY",
    "MARCH",
    "APRIL",
    "MAY",
    "JUNE",
    "JULY",
    "AUGUST",
    "SEPTEMBER",
    "OCTOBER",
    "NOVEMBER",
    "DECEMBER",
    "NEXT",
    "NEXT_OR_SAME",
    "LAST",
    "NOW",
    "TOMORROW",
    "YESTERDAY",
    "PAST",
    "FUTURE",
    "DAY",
    "WEEK",
    "MONTH",
    "YEAR",
    "MONDAY",
    "TUESDAY",
    "WEDNESDAY",
    "THURSDAY",
    "FRIDAY",
    "SATURDAY",
    "SUNDAY",
    "DAYS",
    "WEEKS",
    "MONTHS",
    "HOURS",
    "MINUTES",
    "SECONDS",
    "YEARS",
    "DIGITS",
    "SIGNEDDIGITS",
    "ZERO",
    "ONE",
    "TWO",
    "THREE",
    "FOUR",
    "FIVE",
    "SIX",
    "SEVEN",
    "EIGHT",
    "NINE",
    "TEN",
    "ELEVEN",
    "TWELVE",
    "THIRTEEN",
    "FOURTEEN",
    "FIFTEEN",
    "SIXTEEN",
    "SEVENTEEN",
    "EIGHTEEN",
    "NINETEEN",
    "TWENTY",
    "THIRTY",
    "FORTY",
    "FIFTY",
    "SIXTY",
    "SEVENTY",
    "EIGHTY",
    "NINETY",
    "HUNDRED",
    "THOUSAND",
    "NOON",
    "MIDNIGHT",
    nullptr
  };
  return names;
}

inline const char *EnumNameDatetimeExtractorType(DatetimeExtractorType e) {
  if (flatbuffers::IsOutRange(e, DatetimeExtractorType_UNKNOWN_DATETIME_EXTRACTOR_TYPE, DatetimeExtractorType_MIDNIGHT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDatetimeExtractorType()[index];
}

enum DatetimeGroupType {
  DatetimeGroupType_GROUP_UNKNOWN = 0,
  DatetimeGroupType_GROUP_UNUSED = 1,
  DatetimeGroupType_GROUP_YEAR = 2,
  DatetimeGroupType_GROUP_MONTH = 3,
  DatetimeGroupType_GROUP_DAY = 4,
  DatetimeGroupType_GROUP_HOUR = 5,
  DatetimeGroupType_GROUP_MINUTE = 6,
  DatetimeGroupType_GROUP_SECOND = 7,
  DatetimeGroupType_GROUP_AMPM = 8,
  DatetimeGroupType_GROUP_RELATIONDISTANCE = 9,
  DatetimeGroupType_GROUP_RELATION = 10,
  DatetimeGroupType_GROUP_RELATIONTYPE = 11,
  DatetimeGroupType_GROUP_DUMMY1 = 12,
  DatetimeGroupType_GROUP_DUMMY2 = 13,
  DatetimeGroupType_GROUP_ABSOLUTETIME = 14,
  DatetimeGroupType_MIN = DatetimeGroupType_GROUP_UNKNOWN,
  DatetimeGroupType_MAX = DatetimeGroupType_GROUP_ABSOLUTETIME
};

inline const DatetimeGroupType (&EnumValuesDatetimeGroupType())[15] {
  static const DatetimeGroupType values[] = {
    DatetimeGroupType_GROUP_UNKNOWN,
    DatetimeGroupType_GROUP_UNUSED,
    DatetimeGroupType_GROUP_YEAR,
    DatetimeGroupType_GROUP_MONTH,
    DatetimeGroupType_GROUP_DAY,
    DatetimeGroupType_GROUP_HOUR,
    DatetimeGroupType_GROUP_MINUTE,
    DatetimeGroupType_GROUP_SECOND,
    DatetimeGroupType_GROUP_AMPM,
    DatetimeGroupType_GROUP_RELATIONDISTANCE,
    DatetimeGroupType_GROUP_RELATION,
    DatetimeGroupType_GROUP_RELATIONTYPE,
    DatetimeGroupType_GROUP_DUMMY1,
    DatetimeGroupType_GROUP_DUMMY2,
    DatetimeGroupType_GROUP_ABSOLUTETIME
  };
  return values;
}

inline const char * const *EnumNamesDatetimeGroupType() {
  static const char * const names[16] = {
    "GROUP_UNKNOWN",
    "GROUP_UNUSED",
    "GROUP_YEAR",
    "GROUP_MONTH",
    "GROUP_DAY",
    "GROUP_HOUR",
    "GROUP_MINUTE",
    "GROUP_SECOND",
    "GROUP_AMPM",
    "GROUP_RELATIONDISTANCE",
    "GROUP_RELATION",
    "GROUP_RELATIONTYPE",
    "GROUP_DUMMY1",
    "GROUP_DUMMY2",
    "GROUP_ABSOLUTETIME",
    nullptr
  };
  return names;
}

inline const char *EnumNameDatetimeGroupType(DatetimeGroupType e) {
  if (flatbuffers::IsOutRange(e, DatetimeGroupType_GROUP_UNKNOWN, DatetimeGroupType_GROUP_ABSOLUTETIME)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDatetimeGroupType()[index];
}

namespace FeatureProcessorOptions_ {

enum CenterTokenSelectionMethod {
  CenterTokenSelectionMethod_DEFAULT_CENTER_TOKEN_METHOD = 0,
  CenterTokenSelectionMethod_CENTER_TOKEN_FROM_CLICK = 1,
  CenterTokenSelectionMethod_CENTER_TOKEN_MIDDLE_OF_SELECTION = 2,
  CenterTokenSelectionMethod_MIN = CenterTokenSelectionMethod_DEFAULT_CENTER_TOKEN_METHOD,
  CenterTokenSelectionMethod_MAX = CenterTokenSelectionMethod_CENTER_TOKEN_MIDDLE_OF_SELECTION
};

inline const CenterTokenSelectionMethod (&EnumValuesCenterTokenSelectionMethod())[3] {
  static const CenterTokenSelectionMethod values[] = {
    CenterTokenSelectionMethod_DEFAULT_CENTER_TOKEN_METHOD,
    CenterTokenSelectionMethod_CENTER_TOKEN_FROM_CLICK,
    CenterTokenSelectionMethod_CENTER_TOKEN_MIDDLE_OF_SELECTION
  };
  return values;
}

inline const char * const *EnumNamesCenterTokenSelectionMethod() {
  static const char * const names[4] = {
    "DEFAULT_CENTER_TOKEN_METHOD",
    "CENTER_TOKEN_FROM_CLICK",
    "CENTER_TOKEN_MIDDLE_OF_SELECTION",
    nullptr
  };
  return names;
}

inline const char *EnumNameCenterTokenSelectionMethod(CenterTokenSelectionMethod e) {
  if (flatbuffers::IsOutRange(e, CenterTokenSelectionMethod_DEFAULT_CENTER_TOKEN_METHOD, CenterTokenSelectionMethod_CENTER_TOKEN_MIDDLE_OF_SELECTION)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCenterTokenSelectionMethod()[index];
}

}  // namespace FeatureProcessorOptions_

namespace TranslateAnnotatorOptions_ {

enum Algorithm {
  Algorithm_DEFAULT_ALGORITHM = 0,
  Algorithm_BACKOFF = 1,
  Algorithm_MIN = Algorithm_DEFAULT_ALGORITHM,
  Algorithm_MAX = Algorithm_BACKOFF
};

inline const Algorithm (&EnumValuesAlgorithm())[2] {
  static const Algorithm values[] = {
    Algorithm_DEFAULT_ALGORITHM,
    Algorithm_BACKOFF
  };
  return values;
}

inline const char * const *EnumNamesAlgorithm() {
  static const char * const names[3] = {
    "DEFAULT_ALGORITHM",
    "BACKOFF",
    nullptr
  };
  return names;
}

inline const char *EnumNameAlgorithm(Algorithm e) {
  if (flatbuffers::IsOutRange(e, Algorithm_DEFAULT_ALGORITHM, Algorithm_BACKOFF)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAlgorithm()[index];
}

}  // namespace TranslateAnnotatorOptions_

namespace PodNerModel_ {
namespace Label_ {

enum BoiseType {
  BoiseType_NONE = 0,
  BoiseType_BEGIN = 1,
  BoiseType_O = 2,
  BoiseType_INTERMEDIATE = 3,
  BoiseType_SINGLE = 4,
  BoiseType_END = 5,
  BoiseType_MIN = BoiseType_NONE,
  BoiseType_MAX = BoiseType_END
};

inline const BoiseType (&EnumValuesBoiseType())[6] {
  static const BoiseType values[] = {
    BoiseType_NONE,
    BoiseType_BEGIN,
    BoiseType_O,
    BoiseType_INTERMEDIATE,
    BoiseType_SINGLE,
    BoiseType_END
  };
  return values;
}

inline const char * const *EnumNamesBoiseType() {
  static const char * const names[7] = {
    "NONE",
    "BEGIN",
    "O",
    "INTERMEDIATE",
    "SINGLE",
    "END",
    nullptr
  };
  return names;
}

inline const char *EnumNameBoiseType(BoiseType e) {
  if (flatbuffers::IsOutRange(e, BoiseType_NONE, BoiseType_END)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBoiseType()[index];
}

enum MentionType {
  MentionType_UNDEFINED = 0,
  MentionType_NAM = 1,
  MentionType_NOM = 2,
  MentionType_MIN = MentionType_UNDEFINED,
  MentionType_MAX = MentionType_NOM
};

inline const MentionType (&EnumValuesMentionType())[3] {
  static const MentionType values[] = {
    MentionType_UNDEFINED,
    MentionType_NAM,
    MentionType_NOM
  };
  return values;
}

inline const char * const *EnumNamesMentionType() {
  static const char * const names[4] = {
    "UNDEFINED",
    "NAM",
    "NOM",
    nullptr
  };
  return names;
}

inline const char *EnumNameMentionType(MentionType e) {
  if (flatbuffers::IsOutRange(e, MentionType_UNDEFINED, MentionType_NOM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMentionType()[index];
}

}  // namespace Label_
}  // namespace PodNerModel_

struct SelectionModelOptionsT : public flatbuffers::NativeTable {
  typedef SelectionModelOptions TableType;
  bool strip_unpaired_brackets;
  int32_t symmetry_context_size;
  int32_t batch_size;
  bool always_classify_suggested_selection;
  SelectionModelOptionsT()
      : strip_unpaired_brackets(true),
        symmetry_context_size(0),
        batch_size(1024),
        always_classify_suggested_selection(false) {
  }
};

struct SelectionModelOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SelectionModelOptionsT NativeTableType;
  typedef SelectionModelOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STRIP_UNPAIRED_BRACKETS = 4,
    VT_SYMMETRY_CONTEXT_SIZE = 6,
    VT_BATCH_SIZE = 8,
    VT_ALWAYS_CLASSIFY_SUGGESTED_SELECTION = 10
  };
  bool strip_unpaired_brackets() const {
    return GetField<uint8_t>(VT_STRIP_UNPAIRED_BRACKETS, 1) != 0;
  }
  int32_t symmetry_context_size() const {
    return GetField<int32_t>(VT_SYMMETRY_CONTEXT_SIZE, 0);
  }
  int32_t batch_size() const {
    return GetField<int32_t>(VT_BATCH_SIZE, 1024);
  }
  bool always_classify_suggested_selection() const {
    return GetField<uint8_t>(VT_ALWAYS_CLASSIFY_SUGGESTED_SELECTION, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STRIP_UNPAIRED_BRACKETS) &&
           VerifyField<int32_t>(verifier, VT_SYMMETRY_CONTEXT_SIZE) &&
           VerifyField<int32_t>(verifier, VT_BATCH_SIZE) &&
           VerifyField<uint8_t>(verifier, VT_ALWAYS_CLASSIFY_SUGGESTED_SELECTION) &&
           verifier.EndTable();
  }
  SelectionModelOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SelectionModelOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SelectionModelOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectionModelOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SelectionModelOptionsBuilder {
  typedef SelectionModelOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_strip_unpaired_brackets(bool strip_unpaired_brackets) {
    fbb_.AddElement<uint8_t>(SelectionModelOptions::VT_STRIP_UNPAIRED_BRACKETS, static_cast<uint8_t>(strip_unpaired_brackets), 1);
  }
  void add_symmetry_context_size(int32_t symmetry_context_size) {
    fbb_.AddElement<int32_t>(SelectionModelOptions::VT_SYMMETRY_CONTEXT_SIZE, symmetry_context_size, 0);
  }
  void add_batch_size(int32_t batch_size) {
    fbb_.AddElement<int32_t>(SelectionModelOptions::VT_BATCH_SIZE, batch_size, 1024);
  }
  void add_always_classify_suggested_selection(bool always_classify_suggested_selection) {
    fbb_.AddElement<uint8_t>(SelectionModelOptions::VT_ALWAYS_CLASSIFY_SUGGESTED_SELECTION, static_cast<uint8_t>(always_classify_suggested_selection), 0);
  }
  explicit SelectionModelOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectionModelOptionsBuilder &operator=(const SelectionModelOptionsBuilder &);
  flatbuffers::Offset<SelectionModelOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectionModelOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectionModelOptions> CreateSelectionModelOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool strip_unpaired_brackets = true,
    int32_t symmetry_context_size = 0,
    int32_t batch_size = 1024,
    bool always_classify_suggested_selection = false) {
  SelectionModelOptionsBuilder builder_(_fbb);
  builder_.add_batch_size(batch_size);
  builder_.add_symmetry_context_size(symmetry_context_size);
  builder_.add_always_classify_suggested_selection(always_classify_suggested_selection);
  builder_.add_strip_unpaired_brackets(strip_unpaired_brackets);
  return builder_.Finish();
}

flatbuffers::Offset<SelectionModelOptions> CreateSelectionModelOptions(flatbuffers::FlatBufferBuilder &_fbb, const SelectionModelOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ClassificationModelOptionsT : public flatbuffers::NativeTable {
  typedef ClassificationModelOptions TableType;
  int32_t phone_min_num_digits;
  int32_t phone_max_num_digits;
  int32_t address_min_num_tokens;
  int32_t max_num_tokens;
  ClassificationModelOptionsT()
      : phone_min_num_digits(7),
        phone_max_num_digits(15),
        address_min_num_tokens(0),
        max_num_tokens(-1) {
  }
};

struct ClassificationModelOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClassificationModelOptionsT NativeTableType;
  typedef ClassificationModelOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PHONE_MIN_NUM_DIGITS = 4,
    VT_PHONE_MAX_NUM_DIGITS = 6,
    VT_ADDRESS_MIN_NUM_TOKENS = 8,
    VT_MAX_NUM_TOKENS = 10
  };
  int32_t phone_min_num_digits() const {
    return GetField<int32_t>(VT_PHONE_MIN_NUM_DIGITS, 7);
  }
  int32_t phone_max_num_digits() const {
    return GetField<int32_t>(VT_PHONE_MAX_NUM_DIGITS, 15);
  }
  int32_t address_min_num_tokens() const {
    return GetField<int32_t>(VT_ADDRESS_MIN_NUM_TOKENS, 0);
  }
  int32_t max_num_tokens() const {
    return GetField<int32_t>(VT_MAX_NUM_TOKENS, -1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PHONE_MIN_NUM_DIGITS) &&
           VerifyField<int32_t>(verifier, VT_PHONE_MAX_NUM_DIGITS) &&
           VerifyField<int32_t>(verifier, VT_ADDRESS_MIN_NUM_TOKENS) &&
           VerifyField<int32_t>(verifier, VT_MAX_NUM_TOKENS) &&
           verifier.EndTable();
  }
  ClassificationModelOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ClassificationModelOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ClassificationModelOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ClassificationModelOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ClassificationModelOptionsBuilder {
  typedef ClassificationModelOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_phone_min_num_digits(int32_t phone_min_num_digits) {
    fbb_.AddElement<int32_t>(ClassificationModelOptions::VT_PHONE_MIN_NUM_DIGITS, phone_min_num_digits, 7);
  }
  void add_phone_max_num_digits(int32_t phone_max_num_digits) {
    fbb_.AddElement<int32_t>(ClassificationModelOptions::VT_PHONE_MAX_NUM_DIGITS, phone_max_num_digits, 15);
  }
  void add_address_min_num_tokens(int32_t address_min_num_tokens) {
    fbb_.AddElement<int32_t>(ClassificationModelOptions::VT_ADDRESS_MIN_NUM_TOKENS, address_min_num_tokens, 0);
  }
  void add_max_num_tokens(int32_t max_num_tokens) {
    fbb_.AddElement<int32_t>(ClassificationModelOptions::VT_MAX_NUM_TOKENS, max_num_tokens, -1);
  }
  explicit ClassificationModelOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClassificationModelOptionsBuilder &operator=(const ClassificationModelOptionsBuilder &);
  flatbuffers::Offset<ClassificationModelOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClassificationModelOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClassificationModelOptions> CreateClassificationModelOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t phone_min_num_digits = 7,
    int32_t phone_max_num_digits = 15,
    int32_t address_min_num_tokens = 0,
    int32_t max_num_tokens = -1) {
  ClassificationModelOptionsBuilder builder_(_fbb);
  builder_.add_max_num_tokens(max_num_tokens);
  builder_.add_address_min_num_tokens(address_min_num_tokens);
  builder_.add_phone_max_num_digits(phone_max_num_digits);
  builder_.add_phone_min_num_digits(phone_min_num_digits);
  return builder_.Finish();
}

flatbuffers::Offset<ClassificationModelOptions> CreateClassificationModelOptions(flatbuffers::FlatBufferBuilder &_fbb, const ClassificationModelOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VerificationOptionsT : public flatbuffers::NativeTable {
  typedef VerificationOptions TableType;
  bool verify_luhn_checksum;
  int32_t lua_verifier;
  VerificationOptionsT()
      : verify_luhn_checksum(false),
        lua_verifier(-1) {
  }
};

struct VerificationOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VerificationOptionsT NativeTableType;
  typedef VerificationOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERIFY_LUHN_CHECKSUM = 4,
    VT_LUA_VERIFIER = 6
  };
  bool verify_luhn_checksum() const {
    return GetField<uint8_t>(VT_VERIFY_LUHN_CHECKSUM, 0) != 0;
  }
  int32_t lua_verifier() const {
    return GetField<int32_t>(VT_LUA_VERIFIER, -1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VERIFY_LUHN_CHECKSUM) &&
           VerifyField<int32_t>(verifier, VT_LUA_VERIFIER) &&
           verifier.EndTable();
  }
  VerificationOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VerificationOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<VerificationOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VerificationOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VerificationOptionsBuilder {
  typedef VerificationOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_verify_luhn_checksum(bool verify_luhn_checksum) {
    fbb_.AddElement<uint8_t>(VerificationOptions::VT_VERIFY_LUHN_CHECKSUM, static_cast<uint8_t>(verify_luhn_checksum), 0);
  }
  void add_lua_verifier(int32_t lua_verifier) {
    fbb_.AddElement<int32_t>(VerificationOptions::VT_LUA_VERIFIER, lua_verifier, -1);
  }
  explicit VerificationOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VerificationOptionsBuilder &operator=(const VerificationOptionsBuilder &);
  flatbuffers::Offset<VerificationOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VerificationOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<VerificationOptions> CreateVerificationOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool verify_luhn_checksum = false,
    int32_t lua_verifier = -1) {
  VerificationOptionsBuilder builder_(_fbb);
  builder_.add_lua_verifier(lua_verifier);
  builder_.add_verify_luhn_checksum(verify_luhn_checksum);
  return builder_.Finish();
}

flatbuffers::Offset<VerificationOptions> CreateVerificationOptions(flatbuffers::FlatBufferBuilder &_fbb, const VerificationOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CapturingGroupT : public flatbuffers::NativeTable {
  typedef CapturingGroup TableType;
  bool extend_selection;
  std::unique_ptr<libtextclassifier3::FlatbufferFieldPathT> entity_field_path;
  std::string serialized_entity_data;
  std::unique_ptr<libtextclassifier3::NormalizationOptionsT> normalization_options;
  std::unique_ptr<libtextclassifier3::EntityDataT> entity_data;
  CapturingGroupT()
      : extend_selection(true) {
  }
};

struct CapturingGroup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CapturingGroupT NativeTableType;
  typedef CapturingGroupBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXTEND_SELECTION = 4,
    VT_ENTITY_FIELD_PATH = 6,
    VT_SERIALIZED_ENTITY_DATA = 8,
    VT_NORMALIZATION_OPTIONS = 10,
    VT_ENTITY_DATA = 12
  };
  bool extend_selection() const {
    return GetField<uint8_t>(VT_EXTEND_SELECTION, 1) != 0;
  }
  const libtextclassifier3::FlatbufferFieldPath *entity_field_path() const {
    return GetPointer<const libtextclassifier3::FlatbufferFieldPath *>(VT_ENTITY_FIELD_PATH);
  }
  const flatbuffers::String *serialized_entity_data() const {
    return GetPointer<const flatbuffers::String *>(VT_SERIALIZED_ENTITY_DATA);
  }
  const libtextclassifier3::NormalizationOptions *normalization_options() const {
    return GetPointer<const libtextclassifier3::NormalizationOptions *>(VT_NORMALIZATION_OPTIONS);
  }
  const libtextclassifier3::EntityData *entity_data() const {
    return GetPointer<const libtextclassifier3::EntityData *>(VT_ENTITY_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EXTEND_SELECTION) &&
           VerifyOffset(verifier, VT_ENTITY_FIELD_PATH) &&
           verifier.VerifyTable(entity_field_path()) &&
           VerifyOffset(verifier, VT_SERIALIZED_ENTITY_DATA) &&
           verifier.VerifyString(serialized_entity_data()) &&
           VerifyOffset(verifier, VT_NORMALIZATION_OPTIONS) &&
           verifier.VerifyTable(normalization_options()) &&
           VerifyOffset(verifier, VT_ENTITY_DATA) &&
           verifier.VerifyTable(entity_data()) &&
           verifier.EndTable();
  }
  CapturingGroupT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CapturingGroupT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CapturingGroup> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CapturingGroupT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CapturingGroupBuilder {
  typedef CapturingGroup Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_extend_selection(bool extend_selection) {
    fbb_.AddElement<uint8_t>(CapturingGroup::VT_EXTEND_SELECTION, static_cast<uint8_t>(extend_selection), 1);
  }
  void add_entity_field_path(flatbuffers::Offset<libtextclassifier3::FlatbufferFieldPath> entity_field_path) {
    fbb_.AddOffset(CapturingGroup::VT_ENTITY_FIELD_PATH, entity_field_path);
  }
  void add_serialized_entity_data(flatbuffers::Offset<flatbuffers::String> serialized_entity_data) {
    fbb_.AddOffset(CapturingGroup::VT_SERIALIZED_ENTITY_DATA, serialized_entity_data);
  }
  void add_normalization_options(flatbuffers::Offset<libtextclassifier3::NormalizationOptions> normalization_options) {
    fbb_.AddOffset(CapturingGroup::VT_NORMALIZATION_OPTIONS, normalization_options);
  }
  void add_entity_data(flatbuffers::Offset<libtextclassifier3::EntityData> entity_data) {
    fbb_.AddOffset(CapturingGroup::VT_ENTITY_DATA, entity_data);
  }
  explicit CapturingGroupBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CapturingGroupBuilder &operator=(const CapturingGroupBuilder &);
  flatbuffers::Offset<CapturingGroup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CapturingGroup>(end);
    return o;
  }
};

inline flatbuffers::Offset<CapturingGroup> CreateCapturingGroup(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool extend_selection = true,
    flatbuffers::Offset<libtextclassifier3::FlatbufferFieldPath> entity_field_path = 0,
    flatbuffers::Offset<flatbuffers::String> serialized_entity_data = 0,
    flatbuffers::Offset<libtextclassifier3::NormalizationOptions> normalization_options = 0,
    flatbuffers::Offset<libtextclassifier3::EntityData> entity_data = 0) {
  CapturingGroupBuilder builder_(_fbb);
  builder_.add_entity_data(entity_data);
  builder_.add_normalization_options(normalization_options);
  builder_.add_serialized_entity_data(serialized_entity_data);
  builder_.add_entity_field_path(entity_field_path);
  builder_.add_extend_selection(extend_selection);
  return builder_.Finish();
}

inline flatbuffers::Offset<CapturingGroup> CreateCapturingGroupDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool extend_selection = true,
    flatbuffers::Offset<libtextclassifier3::FlatbufferFieldPath> entity_field_path = 0,
    const char *serialized_entity_data = nullptr,
    flatbuffers::Offset<libtextclassifier3::NormalizationOptions> normalization_options = 0,
    flatbuffers::Offset<libtextclassifier3::EntityData> entity_data = 0) {
  auto serialized_entity_data__ = serialized_entity_data ? _fbb.CreateSharedString(serialized_entity_data) : 0;
  return libtextclassifier3::CreateCapturingGroup(
      _fbb,
      extend_selection,
      entity_field_path,
      serialized_entity_data__,
      normalization_options,
      entity_data);
}

flatbuffers::Offset<CapturingGroup> CreateCapturingGroup(flatbuffers::FlatBufferBuilder &_fbb, const CapturingGroupT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace RegexModel_ {

struct PatternT : public flatbuffers::NativeTable {
  typedef Pattern TableType;
  std::string collection_name;
  std::string pattern;
  libtextclassifier3::ModeFlag enabled_modes;
  float target_classification_score;
  float priority_score;
  bool use_approximate_matching;
  std::unique_ptr<libtextclassifier3::CompressedBufferT> compressed_pattern;
  std::unique_ptr<libtextclassifier3::VerificationOptionsT> verification_options;
  std::vector<std::unique_ptr<libtextclassifier3::CapturingGroupT>> capturing_group;
  std::string serialized_entity_data;
  std::unique_ptr<libtextclassifier3::EntityDataT> entity_data;
  PatternT()
      : enabled_modes(libtextclassifier3::ModeFlag_ALL),
        target_classification_score(1.0f),
        priority_score(0.0f),
        use_approximate_matching(false) {
  }
};

struct Pattern FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PatternT NativeTableType;
  typedef PatternBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLLECTION_NAME = 4,
    VT_PATTERN = 6,
    VT_ENABLED_MODES = 8,
    VT_TARGET_CLASSIFICATION_SCORE = 10,
    VT_PRIORITY_SCORE = 12,
    VT_USE_APPROXIMATE_MATCHING = 14,
    VT_COMPRESSED_PATTERN = 16,
    VT_VERIFICATION_OPTIONS = 18,
    VT_CAPTURING_GROUP = 20,
    VT_SERIALIZED_ENTITY_DATA = 22,
    VT_ENTITY_DATA = 24
  };
  const flatbuffers::String *collection_name() const {
    return GetPointer<const flatbuffers::String *>(VT_COLLECTION_NAME);
  }
  const flatbuffers::String *pattern() const {
    return GetPointer<const flatbuffers::String *>(VT_PATTERN);
  }
  libtextclassifier3::ModeFlag enabled_modes() const {
    return static_cast<libtextclassifier3::ModeFlag>(GetField<int32_t>(VT_ENABLED_MODES, 7));
  }
  float target_classification_score() const {
    return GetField<float>(VT_TARGET_CLASSIFICATION_SCORE, 1.0f);
  }
  float priority_score() const {
    return GetField<float>(VT_PRIORITY_SCORE, 0.0f);
  }
  bool use_approximate_matching() const {
    return GetField<uint8_t>(VT_USE_APPROXIMATE_MATCHING, 0) != 0;
  }
  const libtextclassifier3::CompressedBuffer *compressed_pattern() const {
    return GetPointer<const libtextclassifier3::CompressedBuffer *>(VT_COMPRESSED_PATTERN);
  }
  const libtextclassifier3::VerificationOptions *verification_options() const {
    return GetPointer<const libtextclassifier3::VerificationOptions *>(VT_VERIFICATION_OPTIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::CapturingGroup>> *capturing_group() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::CapturingGroup>> *>(VT_CAPTURING_GROUP);
  }
  const flatbuffers::String *serialized_entity_data() const {
    return GetPointer<const flatbuffers::String *>(VT_SERIALIZED_ENTITY_DATA);
  }
  const libtextclassifier3::EntityData *entity_data() const {
    return GetPointer<const libtextclassifier3::EntityData *>(VT_ENTITY_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLLECTION_NAME) &&
           verifier.VerifyString(collection_name()) &&
           VerifyOffset(verifier, VT_PATTERN) &&
           verifier.VerifyString(pattern()) &&
           VerifyField<int32_t>(verifier, VT_ENABLED_MODES) &&
           VerifyField<float>(verifier, VT_TARGET_CLASSIFICATION_SCORE) &&
           VerifyField<float>(verifier, VT_PRIORITY_SCORE) &&
           VerifyField<uint8_t>(verifier, VT_USE_APPROXIMATE_MATCHING) &&
           VerifyOffset(verifier, VT_COMPRESSED_PATTERN) &&
           verifier.VerifyTable(compressed_pattern()) &&
           VerifyOffset(verifier, VT_VERIFICATION_OPTIONS) &&
           verifier.VerifyTable(verification_options()) &&
           VerifyOffset(verifier, VT_CAPTURING_GROUP) &&
           verifier.VerifyVector(capturing_group()) &&
           verifier.VerifyVectorOfTables(capturing_group()) &&
           VerifyOffset(verifier, VT_SERIALIZED_ENTITY_DATA) &&
           verifier.VerifyString(serialized_entity_data()) &&
           VerifyOffset(verifier, VT_ENTITY_DATA) &&
           verifier.VerifyTable(entity_data()) &&
           verifier.EndTable();
  }
  PatternT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PatternT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pattern> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PatternT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PatternBuilder {
  typedef Pattern Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_collection_name(flatbuffers::Offset<flatbuffers::String> collection_name) {
    fbb_.AddOffset(Pattern::VT_COLLECTION_NAME, collection_name);
  }
  void add_pattern(flatbuffers::Offset<flatbuffers::String> pattern) {
    fbb_.AddOffset(Pattern::VT_PATTERN, pattern);
  }
  void add_enabled_modes(libtextclassifier3::ModeFlag enabled_modes) {
    fbb_.AddElement<int32_t>(Pattern::VT_ENABLED_MODES, static_cast<int32_t>(enabled_modes), 7);
  }
  void add_target_classification_score(float target_classification_score) {
    fbb_.AddElement<float>(Pattern::VT_TARGET_CLASSIFICATION_SCORE, target_classification_score, 1.0f);
  }
  void add_priority_score(float priority_score) {
    fbb_.AddElement<float>(Pattern::VT_PRIORITY_SCORE, priority_score, 0.0f);
  }
  void add_use_approximate_matching(bool use_approximate_matching) {
    fbb_.AddElement<uint8_t>(Pattern::VT_USE_APPROXIMATE_MATCHING, static_cast<uint8_t>(use_approximate_matching), 0);
  }
  void add_compressed_pattern(flatbuffers::Offset<libtextclassifier3::CompressedBuffer> compressed_pattern) {
    fbb_.AddOffset(Pattern::VT_COMPRESSED_PATTERN, compressed_pattern);
  }
  void add_verification_options(flatbuffers::Offset<libtextclassifier3::VerificationOptions> verification_options) {
    fbb_.AddOffset(Pattern::VT_VERIFICATION_OPTIONS, verification_options);
  }
  void add_capturing_group(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::CapturingGroup>>> capturing_group) {
    fbb_.AddOffset(Pattern::VT_CAPTURING_GROUP, capturing_group);
  }
  void add_serialized_entity_data(flatbuffers::Offset<flatbuffers::String> serialized_entity_data) {
    fbb_.AddOffset(Pattern::VT_SERIALIZED_ENTITY_DATA, serialized_entity_data);
  }
  void add_entity_data(flatbuffers::Offset<libtextclassifier3::EntityData> entity_data) {
    fbb_.AddOffset(Pattern::VT_ENTITY_DATA, entity_data);
  }
  explicit PatternBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PatternBuilder &operator=(const PatternBuilder &);
  flatbuffers::Offset<Pattern> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pattern>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pattern> CreatePattern(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> collection_name = 0,
    flatbuffers::Offset<flatbuffers::String> pattern = 0,
    libtextclassifier3::ModeFlag enabled_modes = libtextclassifier3::ModeFlag_ALL,
    float target_classification_score = 1.0f,
    float priority_score = 0.0f,
    bool use_approximate_matching = false,
    flatbuffers::Offset<libtextclassifier3::CompressedBuffer> compressed_pattern = 0,
    flatbuffers::Offset<libtextclassifier3::VerificationOptions> verification_options = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::CapturingGroup>>> capturing_group = 0,
    flatbuffers::Offset<flatbuffers::String> serialized_entity_data = 0,
    flatbuffers::Offset<libtextclassifier3::EntityData> entity_data = 0) {
  PatternBuilder builder_(_fbb);
  builder_.add_entity_data(entity_data);
  builder_.add_serialized_entity_data(serialized_entity_data);
  builder_.add_capturing_group(capturing_group);
  builder_.add_verification_options(verification_options);
  builder_.add_compressed_pattern(compressed_pattern);
  builder_.add_priority_score(priority_score);
  builder_.add_target_classification_score(target_classification_score);
  builder_.add_enabled_modes(enabled_modes);
  builder_.add_pattern(pattern);
  builder_.add_collection_name(collection_name);
  builder_.add_use_approximate_matching(use_approximate_matching);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pattern> CreatePatternDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *collection_name = nullptr,
    const char *pattern = nullptr,
    libtextclassifier3::ModeFlag enabled_modes = libtextclassifier3::ModeFlag_ALL,
    float target_classification_score = 1.0f,
    float priority_score = 0.0f,
    bool use_approximate_matching = false,
    flatbuffers::Offset<libtextclassifier3::CompressedBuffer> compressed_pattern = 0,
    flatbuffers::Offset<libtextclassifier3::VerificationOptions> verification_options = 0,
    const std::vector<flatbuffers::Offset<libtextclassifier3::CapturingGroup>> *capturing_group = nullptr,
    const char *serialized_entity_data = nullptr,
    flatbuffers::Offset<libtextclassifier3::EntityData> entity_data = 0) {
  auto collection_name__ = collection_name ? _fbb.CreateSharedString(collection_name) : 0;
  auto pattern__ = pattern ? _fbb.CreateSharedString(pattern) : 0;
  auto capturing_group__ = capturing_group ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::CapturingGroup>>(*capturing_group) : 0;
  auto serialized_entity_data__ = serialized_entity_data ? _fbb.CreateSharedString(serialized_entity_data) : 0;
  return libtextclassifier3::RegexModel_::CreatePattern(
      _fbb,
      collection_name__,
      pattern__,
      enabled_modes,
      target_classification_score,
      priority_score,
      use_approximate_matching,
      compressed_pattern,
      verification_options,
      capturing_group__,
      serialized_entity_data__,
      entity_data);
}

flatbuffers::Offset<Pattern> CreatePattern(flatbuffers::FlatBufferBuilder &_fbb, const PatternT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace RegexModel_

struct RegexModelT : public flatbuffers::NativeTable {
  typedef RegexModel TableType;
  std::vector<std::unique_ptr<libtextclassifier3::RegexModel_::PatternT>> patterns;
  bool lazy_regex_compilation;
  std::vector<std::string> lua_verifier;
  RegexModelT()
      : lazy_regex_compilation(true) {
  }
};

struct RegexModel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RegexModelT NativeTableType;
  typedef RegexModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATTERNS = 4,
    VT_LAZY_REGEX_COMPILATION = 6,
    VT_LUA_VERIFIER = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::RegexModel_::Pattern>> *patterns() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::RegexModel_::Pattern>> *>(VT_PATTERNS);
  }
  bool lazy_regex_compilation() const {
    return GetField<uint8_t>(VT_LAZY_REGEX_COMPILATION, 1) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *lua_verifier() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_LUA_VERIFIER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATTERNS) &&
           verifier.VerifyVector(patterns()) &&
           verifier.VerifyVectorOfTables(patterns()) &&
           VerifyField<uint8_t>(verifier, VT_LAZY_REGEX_COMPILATION) &&
           VerifyOffset(verifier, VT_LUA_VERIFIER) &&
           verifier.VerifyVector(lua_verifier()) &&
           verifier.VerifyVectorOfStrings(lua_verifier()) &&
           verifier.EndTable();
  }
  RegexModelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RegexModelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RegexModel> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegexModelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RegexModelBuilder {
  typedef RegexModel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_patterns(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::RegexModel_::Pattern>>> patterns) {
    fbb_.AddOffset(RegexModel::VT_PATTERNS, patterns);
  }
  void add_lazy_regex_compilation(bool lazy_regex_compilation) {
    fbb_.AddElement<uint8_t>(RegexModel::VT_LAZY_REGEX_COMPILATION, static_cast<uint8_t>(lazy_regex_compilation), 1);
  }
  void add_lua_verifier(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> lua_verifier) {
    fbb_.AddOffset(RegexModel::VT_LUA_VERIFIER, lua_verifier);
  }
  explicit RegexModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RegexModelBuilder &operator=(const RegexModelBuilder &);
  flatbuffers::Offset<RegexModel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RegexModel>(end);
    return o;
  }
};

inline flatbuffers::Offset<RegexModel> CreateRegexModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::RegexModel_::Pattern>>> patterns = 0,
    bool lazy_regex_compilation = true,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> lua_verifier = 0) {
  RegexModelBuilder builder_(_fbb);
  builder_.add_lua_verifier(lua_verifier);
  builder_.add_patterns(patterns);
  builder_.add_lazy_regex_compilation(lazy_regex_compilation);
  return builder_.Finish();
}

inline flatbuffers::Offset<RegexModel> CreateRegexModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<libtextclassifier3::RegexModel_::Pattern>> *patterns = nullptr,
    bool lazy_regex_compilation = true,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *lua_verifier = nullptr) {
  auto patterns__ = patterns ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::RegexModel_::Pattern>>(*patterns) : 0;
  auto lua_verifier__ = lua_verifier ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*lua_verifier) : 0;
  return libtextclassifier3::CreateRegexModel(
      _fbb,
      patterns__,
      lazy_regex_compilation,
      lua_verifier__);
}

flatbuffers::Offset<RegexModel> CreateRegexModel(flatbuffers::FlatBufferBuilder &_fbb, const RegexModelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace DatetimeModelPattern_ {

struct RegexT : public flatbuffers::NativeTable {
  typedef Regex TableType;
  std::string pattern;
  std::vector<libtextclassifier3::DatetimeGroupType> groups;
  std::unique_ptr<libtextclassifier3::CompressedBufferT> compressed_pattern;
  RegexT() {
  }
};

struct Regex FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RegexT NativeTableType;
  typedef RegexBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATTERN = 4,
    VT_GROUPS = 6,
    VT_COMPRESSED_PATTERN = 8
  };
  const flatbuffers::String *pattern() const {
    return GetPointer<const flatbuffers::String *>(VT_PATTERN);
  }
  const flatbuffers::Vector<int32_t> *groups() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_GROUPS);
  }
  const libtextclassifier3::CompressedBuffer *compressed_pattern() const {
    return GetPointer<const libtextclassifier3::CompressedBuffer *>(VT_COMPRESSED_PATTERN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATTERN) &&
           verifier.VerifyString(pattern()) &&
           VerifyOffset(verifier, VT_GROUPS) &&
           verifier.VerifyVector(groups()) &&
           VerifyOffset(verifier, VT_COMPRESSED_PATTERN) &&
           verifier.VerifyTable(compressed_pattern()) &&
           verifier.EndTable();
  }
  RegexT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RegexT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Regex> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegexT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RegexBuilder {
  typedef Regex Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pattern(flatbuffers::Offset<flatbuffers::String> pattern) {
    fbb_.AddOffset(Regex::VT_PATTERN, pattern);
  }
  void add_groups(flatbuffers::Offset<flatbuffers::Vector<int32_t>> groups) {
    fbb_.AddOffset(Regex::VT_GROUPS, groups);
  }
  void add_compressed_pattern(flatbuffers::Offset<libtextclassifier3::CompressedBuffer> compressed_pattern) {
    fbb_.AddOffset(Regex::VT_COMPRESSED_PATTERN, compressed_pattern);
  }
  explicit RegexBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RegexBuilder &operator=(const RegexBuilder &);
  flatbuffers::Offset<Regex> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Regex>(end);
    return o;
  }
};

inline flatbuffers::Offset<Regex> CreateRegex(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> pattern = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> groups = 0,
    flatbuffers::Offset<libtextclassifier3::CompressedBuffer> compressed_pattern = 0) {
  RegexBuilder builder_(_fbb);
  builder_.add_compressed_pattern(compressed_pattern);
  builder_.add_groups(groups);
  builder_.add_pattern(pattern);
  return builder_.Finish();
}

inline flatbuffers::Offset<Regex> CreateRegexDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *pattern = nullptr,
    const std::vector<int32_t> *groups = nullptr,
    flatbuffers::Offset<libtextclassifier3::CompressedBuffer> compressed_pattern = 0) {
  auto pattern__ = pattern ? _fbb.CreateSharedString(pattern) : 0;
  auto groups__ = groups ? _fbb.CreateVector<int32_t>(*groups) : 0;
  return libtextclassifier3::DatetimeModelPattern_::CreateRegex(
      _fbb,
      pattern__,
      groups__,
      compressed_pattern);
}

flatbuffers::Offset<Regex> CreateRegex(flatbuffers::FlatBufferBuilder &_fbb, const RegexT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace DatetimeModelPattern_

struct DatetimeModelPatternT : public flatbuffers::NativeTable {
  typedef DatetimeModelPattern TableType;
  std::vector<std::unique_ptr<libtextclassifier3::DatetimeModelPattern_::RegexT>> regexes;
  std::vector<int32_t> locales;
  float target_classification_score;
  float priority_score;
  libtextclassifier3::ModeFlag enabled_modes;
  uint32_t enabled_annotation_usecases;
  DatetimeModelPatternT()
      : target_classification_score(1.0f),
        priority_score(0.0f),
        enabled_modes(libtextclassifier3::ModeFlag_ALL),
        enabled_annotation_usecases(4294967295) {
  }
};

struct DatetimeModelPattern FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DatetimeModelPatternT NativeTableType;
  typedef DatetimeModelPatternBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REGEXES = 4,
    VT_LOCALES = 6,
    VT_TARGET_CLASSIFICATION_SCORE = 8,
    VT_PRIORITY_SCORE = 10,
    VT_ENABLED_MODES = 12,
    VT_ENABLED_ANNOTATION_USECASES = 14
  };
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::DatetimeModelPattern_::Regex>> *regexes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::DatetimeModelPattern_::Regex>> *>(VT_REGEXES);
  }
  const flatbuffers::Vector<int32_t> *locales() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_LOCALES);
  }
  float target_classification_score() const {
    return GetField<float>(VT_TARGET_CLASSIFICATION_SCORE, 1.0f);
  }
  float priority_score() const {
    return GetField<float>(VT_PRIORITY_SCORE, 0.0f);
  }
  libtextclassifier3::ModeFlag enabled_modes() const {
    return static_cast<libtextclassifier3::ModeFlag>(GetField<int32_t>(VT_ENABLED_MODES, 7));
  }
  uint32_t enabled_annotation_usecases() const {
    return GetField<uint32_t>(VT_ENABLED_ANNOTATION_USECASES, 4294967295);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REGEXES) &&
           verifier.VerifyVector(regexes()) &&
           verifier.VerifyVectorOfTables(regexes()) &&
           VerifyOffset(verifier, VT_LOCALES) &&
           verifier.VerifyVector(locales()) &&
           VerifyField<float>(verifier, VT_TARGET_CLASSIFICATION_SCORE) &&
           VerifyField<float>(verifier, VT_PRIORITY_SCORE) &&
           VerifyField<int32_t>(verifier, VT_ENABLED_MODES) &&
           VerifyField<uint32_t>(verifier, VT_ENABLED_ANNOTATION_USECASES) &&
           verifier.EndTable();
  }
  DatetimeModelPatternT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DatetimeModelPatternT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DatetimeModelPattern> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DatetimeModelPatternT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DatetimeModelPatternBuilder {
  typedef DatetimeModelPattern Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_regexes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::DatetimeModelPattern_::Regex>>> regexes) {
    fbb_.AddOffset(DatetimeModelPattern::VT_REGEXES, regexes);
  }
  void add_locales(flatbuffers::Offset<flatbuffers::Vector<int32_t>> locales) {
    fbb_.AddOffset(DatetimeModelPattern::VT_LOCALES, locales);
  }
  void add_target_classification_score(float target_classification_score) {
    fbb_.AddElement<float>(DatetimeModelPattern::VT_TARGET_CLASSIFICATION_SCORE, target_classification_score, 1.0f);
  }
  void add_priority_score(float priority_score) {
    fbb_.AddElement<float>(DatetimeModelPattern::VT_PRIORITY_SCORE, priority_score, 0.0f);
  }
  void add_enabled_modes(libtextclassifier3::ModeFlag enabled_modes) {
    fbb_.AddElement<int32_t>(DatetimeModelPattern::VT_ENABLED_MODES, static_cast<int32_t>(enabled_modes), 7);
  }
  void add_enabled_annotation_usecases(uint32_t enabled_annotation_usecases) {
    fbb_.AddElement<uint32_t>(DatetimeModelPattern::VT_ENABLED_ANNOTATION_USECASES, enabled_annotation_usecases, 4294967295);
  }
  explicit DatetimeModelPatternBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DatetimeModelPatternBuilder &operator=(const DatetimeModelPatternBuilder &);
  flatbuffers::Offset<DatetimeModelPattern> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DatetimeModelPattern>(end);
    return o;
  }
};

inline flatbuffers::Offset<DatetimeModelPattern> CreateDatetimeModelPattern(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::DatetimeModelPattern_::Regex>>> regexes = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> locales = 0,
    float target_classification_score = 1.0f,
    float priority_score = 0.0f,
    libtextclassifier3::ModeFlag enabled_modes = libtextclassifier3::ModeFlag_ALL,
    uint32_t enabled_annotation_usecases = 4294967295) {
  DatetimeModelPatternBuilder builder_(_fbb);
  builder_.add_enabled_annotation_usecases(enabled_annotation_usecases);
  builder_.add_enabled_modes(enabled_modes);
  builder_.add_priority_score(priority_score);
  builder_.add_target_classification_score(target_classification_score);
  builder_.add_locales(locales);
  builder_.add_regexes(regexes);
  return builder_.Finish();
}

inline flatbuffers::Offset<DatetimeModelPattern> CreateDatetimeModelPatternDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<libtextclassifier3::DatetimeModelPattern_::Regex>> *regexes = nullptr,
    const std::vector<int32_t> *locales = nullptr,
    float target_classification_score = 1.0f,
    float priority_score = 0.0f,
    libtextclassifier3::ModeFlag enabled_modes = libtextclassifier3::ModeFlag_ALL,
    uint32_t enabled_annotation_usecases = 4294967295) {
  auto regexes__ = regexes ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::DatetimeModelPattern_::Regex>>(*regexes) : 0;
  auto locales__ = locales ? _fbb.CreateVector<int32_t>(*locales) : 0;
  return libtextclassifier3::CreateDatetimeModelPattern(
      _fbb,
      regexes__,
      locales__,
      target_classification_score,
      priority_score,
      enabled_modes,
      enabled_annotation_usecases);
}

flatbuffers::Offset<DatetimeModelPattern> CreateDatetimeModelPattern(flatbuffers::FlatBufferBuilder &_fbb, const DatetimeModelPatternT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DatetimeModelExtractorT : public flatbuffers::NativeTable {
  typedef DatetimeModelExtractor TableType;
  libtextclassifier3::DatetimeExtractorType extractor;
  std::string pattern;
  std::vector<int32_t> locales;
  std::unique_ptr<libtextclassifier3::CompressedBufferT> compressed_pattern;
  DatetimeModelExtractorT()
      : extractor(libtextclassifier3::DatetimeExtractorType_UNKNOWN_DATETIME_EXTRACTOR_TYPE) {
  }
};

struct DatetimeModelExtractor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DatetimeModelExtractorT NativeTableType;
  typedef DatetimeModelExtractorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXTRACTOR = 4,
    VT_PATTERN = 6,
    VT_LOCALES = 8,
    VT_COMPRESSED_PATTERN = 10
  };
  libtextclassifier3::DatetimeExtractorType extractor() const {
    return static_cast<libtextclassifier3::DatetimeExtractorType>(GetField<int32_t>(VT_EXTRACTOR, 0));
  }
  const flatbuffers::String *pattern() const {
    return GetPointer<const flatbuffers::String *>(VT_PATTERN);
  }
  const flatbuffers::Vector<int32_t> *locales() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_LOCALES);
  }
  const libtextclassifier3::CompressedBuffer *compressed_pattern() const {
    return GetPointer<const libtextclassifier3::CompressedBuffer *>(VT_COMPRESSED_PATTERN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EXTRACTOR) &&
           VerifyOffset(verifier, VT_PATTERN) &&
           verifier.VerifyString(pattern()) &&
           VerifyOffset(verifier, VT_LOCALES) &&
           verifier.VerifyVector(locales()) &&
           VerifyOffset(verifier, VT_COMPRESSED_PATTERN) &&
           verifier.VerifyTable(compressed_pattern()) &&
           verifier.EndTable();
  }
  DatetimeModelExtractorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DatetimeModelExtractorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DatetimeModelExtractor> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DatetimeModelExtractorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DatetimeModelExtractorBuilder {
  typedef DatetimeModelExtractor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_extractor(libtextclassifier3::DatetimeExtractorType extractor) {
    fbb_.AddElement<int32_t>(DatetimeModelExtractor::VT_EXTRACTOR, static_cast<int32_t>(extractor), 0);
  }
  void add_pattern(flatbuffers::Offset<flatbuffers::String> pattern) {
    fbb_.AddOffset(DatetimeModelExtractor::VT_PATTERN, pattern);
  }
  void add_locales(flatbuffers::Offset<flatbuffers::Vector<int32_t>> locales) {
    fbb_.AddOffset(DatetimeModelExtractor::VT_LOCALES, locales);
  }
  void add_compressed_pattern(flatbuffers::Offset<libtextclassifier3::CompressedBuffer> compressed_pattern) {
    fbb_.AddOffset(DatetimeModelExtractor::VT_COMPRESSED_PATTERN, compressed_pattern);
  }
  explicit DatetimeModelExtractorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DatetimeModelExtractorBuilder &operator=(const DatetimeModelExtractorBuilder &);
  flatbuffers::Offset<DatetimeModelExtractor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DatetimeModelExtractor>(end);
    return o;
  }
};

inline flatbuffers::Offset<DatetimeModelExtractor> CreateDatetimeModelExtractor(
    flatbuffers::FlatBufferBuilder &_fbb,
    libtextclassifier3::DatetimeExtractorType extractor = libtextclassifier3::DatetimeExtractorType_UNKNOWN_DATETIME_EXTRACTOR_TYPE,
    flatbuffers::Offset<flatbuffers::String> pattern = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> locales = 0,
    flatbuffers::Offset<libtextclassifier3::CompressedBuffer> compressed_pattern = 0) {
  DatetimeModelExtractorBuilder builder_(_fbb);
  builder_.add_compressed_pattern(compressed_pattern);
  builder_.add_locales(locales);
  builder_.add_pattern(pattern);
  builder_.add_extractor(extractor);
  return builder_.Finish();
}

inline flatbuffers::Offset<DatetimeModelExtractor> CreateDatetimeModelExtractorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    libtextclassifier3::DatetimeExtractorType extractor = libtextclassifier3::DatetimeExtractorType_UNKNOWN_DATETIME_EXTRACTOR_TYPE,
    const char *pattern = nullptr,
    const std::vector<int32_t> *locales = nullptr,
    flatbuffers::Offset<libtextclassifier3::CompressedBuffer> compressed_pattern = 0) {
  auto pattern__ = pattern ? _fbb.CreateSharedString(pattern) : 0;
  auto locales__ = locales ? _fbb.CreateVector<int32_t>(*locales) : 0;
  return libtextclassifier3::CreateDatetimeModelExtractor(
      _fbb,
      extractor,
      pattern__,
      locales__,
      compressed_pattern);
}

flatbuffers::Offset<DatetimeModelExtractor> CreateDatetimeModelExtractor(flatbuffers::FlatBufferBuilder &_fbb, const DatetimeModelExtractorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DatetimeModelT : public flatbuffers::NativeTable {
  typedef DatetimeModel TableType;
  std::vector<std::string> locales;
  std::vector<std::unique_ptr<libtextclassifier3::DatetimeModelPatternT>> patterns;
  std::vector<std::unique_ptr<libtextclassifier3::DatetimeModelExtractorT>> extractors;
  bool use_extractors_for_locating;
  std::vector<int32_t> default_locales;
  bool generate_alternative_interpretations_when_ambiguous;
  bool lazy_regex_compilation;
  bool prefer_future_for_unspecified_date;
  DatetimeModelT()
      : use_extractors_for_locating(true),
        generate_alternative_interpretations_when_ambiguous(false),
        lazy_regex_compilation(true),
        prefer_future_for_unspecified_date(false) {
  }
};

struct DatetimeModel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DatetimeModelT NativeTableType;
  typedef DatetimeModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOCALES = 4,
    VT_PATTERNS = 6,
    VT_EXTRACTORS = 8,
    VT_USE_EXTRACTORS_FOR_LOCATING = 10,
    VT_DEFAULT_LOCALES = 12,
    VT_GENERATE_ALTERNATIVE_INTERPRETATIONS_WHEN_AMBIGUOUS = 14,
    VT_LAZY_REGEX_COMPILATION = 16,
    VT_PREFER_FUTURE_FOR_UNSPECIFIED_DATE = 18
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *locales() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_LOCALES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::DatetimeModelPattern>> *patterns() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::DatetimeModelPattern>> *>(VT_PATTERNS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::DatetimeModelExtractor>> *extractors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::DatetimeModelExtractor>> *>(VT_EXTRACTORS);
  }
  bool use_extractors_for_locating() const {
    return GetField<uint8_t>(VT_USE_EXTRACTORS_FOR_LOCATING, 1) != 0;
  }
  const flatbuffers::Vector<int32_t> *default_locales() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DEFAULT_LOCALES);
  }
  bool generate_alternative_interpretations_when_ambiguous() const {
    return GetField<uint8_t>(VT_GENERATE_ALTERNATIVE_INTERPRETATIONS_WHEN_AMBIGUOUS, 0) != 0;
  }
  bool lazy_regex_compilation() const {
    return GetField<uint8_t>(VT_LAZY_REGEX_COMPILATION, 1) != 0;
  }
  bool prefer_future_for_unspecified_date() const {
    return GetField<uint8_t>(VT_PREFER_FUTURE_FOR_UNSPECIFIED_DATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOCALES) &&
           verifier.VerifyVector(locales()) &&
           verifier.VerifyVectorOfStrings(locales()) &&
           VerifyOffset(verifier, VT_PATTERNS) &&
           verifier.VerifyVector(patterns()) &&
           verifier.VerifyVectorOfTables(patterns()) &&
           VerifyOffset(verifier, VT_EXTRACTORS) &&
           verifier.VerifyVector(extractors()) &&
           verifier.VerifyVectorOfTables(extractors()) &&
           VerifyField<uint8_t>(verifier, VT_USE_EXTRACTORS_FOR_LOCATING) &&
           VerifyOffset(verifier, VT_DEFAULT_LOCALES) &&
           verifier.VerifyVector(default_locales()) &&
           VerifyField<uint8_t>(verifier, VT_GENERATE_ALTERNATIVE_INTERPRETATIONS_WHEN_AMBIGUOUS) &&
           VerifyField<uint8_t>(verifier, VT_LAZY_REGEX_COMPILATION) &&
           VerifyField<uint8_t>(verifier, VT_PREFER_FUTURE_FOR_UNSPECIFIED_DATE) &&
           verifier.EndTable();
  }
  DatetimeModelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DatetimeModelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DatetimeModel> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DatetimeModelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DatetimeModelBuilder {
  typedef DatetimeModel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_locales(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> locales) {
    fbb_.AddOffset(DatetimeModel::VT_LOCALES, locales);
  }
  void add_patterns(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::DatetimeModelPattern>>> patterns) {
    fbb_.AddOffset(DatetimeModel::VT_PATTERNS, patterns);
  }
  void add_extractors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::DatetimeModelExtractor>>> extractors) {
    fbb_.AddOffset(DatetimeModel::VT_EXTRACTORS, extractors);
  }
  void add_use_extractors_for_locating(bool use_extractors_for_locating) {
    fbb_.AddElement<uint8_t>(DatetimeModel::VT_USE_EXTRACTORS_FOR_LOCATING, static_cast<uint8_t>(use_extractors_for_locating), 1);
  }
  void add_default_locales(flatbuffers::Offset<flatbuffers::Vector<int32_t>> default_locales) {
    fbb_.AddOffset(DatetimeModel::VT_DEFAULT_LOCALES, default_locales);
  }
  void add_generate_alternative_interpretations_when_ambiguous(bool generate_alternative_interpretations_when_ambiguous) {
    fbb_.AddElement<uint8_t>(DatetimeModel::VT_GENERATE_ALTERNATIVE_INTERPRETATIONS_WHEN_AMBIGUOUS, static_cast<uint8_t>(generate_alternative_interpretations_when_ambiguous), 0);
  }
  void add_lazy_regex_compilation(bool lazy_regex_compilation) {
    fbb_.AddElement<uint8_t>(DatetimeModel::VT_LAZY_REGEX_COMPILATION, static_cast<uint8_t>(lazy_regex_compilation), 1);
  }
  void add_prefer_future_for_unspecified_date(bool prefer_future_for_unspecified_date) {
    fbb_.AddElement<uint8_t>(DatetimeModel::VT_PREFER_FUTURE_FOR_UNSPECIFIED_DATE, static_cast<uint8_t>(prefer_future_for_unspecified_date), 0);
  }
  explicit DatetimeModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DatetimeModelBuilder &operator=(const DatetimeModelBuilder &);
  flatbuffers::Offset<DatetimeModel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DatetimeModel>(end);
    return o;
  }
};

inline flatbuffers::Offset<DatetimeModel> CreateDatetimeModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> locales = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::DatetimeModelPattern>>> patterns = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::DatetimeModelExtractor>>> extractors = 0,
    bool use_extractors_for_locating = true,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> default_locales = 0,
    bool generate_alternative_interpretations_when_ambiguous = false,
    bool lazy_regex_compilation = true,
    bool prefer_future_for_unspecified_date = false) {
  DatetimeModelBuilder builder_(_fbb);
  builder_.add_default_locales(default_locales);
  builder_.add_extractors(extractors);
  builder_.add_patterns(patterns);
  builder_.add_locales(locales);
  builder_.add_prefer_future_for_unspecified_date(prefer_future_for_unspecified_date);
  builder_.add_lazy_regex_compilation(lazy_regex_compilation);
  builder_.add_generate_alternative_interpretations_when_ambiguous(generate_alternative_interpretations_when_ambiguous);
  builder_.add_use_extractors_for_locating(use_extractors_for_locating);
  return builder_.Finish();
}

inline flatbuffers::Offset<DatetimeModel> CreateDatetimeModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *locales = nullptr,
    const std::vector<flatbuffers::Offset<libtextclassifier3::DatetimeModelPattern>> *patterns = nullptr,
    const std::vector<flatbuffers::Offset<libtextclassifier3::DatetimeModelExtractor>> *extractors = nullptr,
    bool use_extractors_for_locating = true,
    const std::vector<int32_t> *default_locales = nullptr,
    bool generate_alternative_interpretations_when_ambiguous = false,
    bool lazy_regex_compilation = true,
    bool prefer_future_for_unspecified_date = false) {
  auto locales__ = locales ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*locales) : 0;
  auto patterns__ = patterns ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::DatetimeModelPattern>>(*patterns) : 0;
  auto extractors__ = extractors ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::DatetimeModelExtractor>>(*extractors) : 0;
  auto default_locales__ = default_locales ? _fbb.CreateVector<int32_t>(*default_locales) : 0;
  return libtextclassifier3::CreateDatetimeModel(
      _fbb,
      locales__,
      patterns__,
      extractors__,
      use_extractors_for_locating,
      default_locales__,
      generate_alternative_interpretations_when_ambiguous,
      lazy_regex_compilation,
      prefer_future_for_unspecified_date);
}

flatbuffers::Offset<DatetimeModel> CreateDatetimeModel(flatbuffers::FlatBufferBuilder &_fbb, const DatetimeModelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GrammarTokenizerOptionsT : public flatbuffers::NativeTable {
  typedef GrammarTokenizerOptions TableType;
  libtextclassifier3::TokenizationType tokenization_type;
  bool icu_preserve_whitespace_tokens;
  std::vector<std::unique_ptr<libtextclassifier3::TokenizationCodepointRangeT>> tokenization_codepoint_config;
  std::vector<std::unique_ptr<libtextclassifier3::CodepointRangeT>> internal_tokenizer_codepoint_ranges;
  bool tokenize_on_script_change;
  GrammarTokenizerOptionsT()
      : tokenization_type(libtextclassifier3::TokenizationType_ICU),
        icu_preserve_whitespace_tokens(false),
        tokenize_on_script_change(false) {
  }
};

struct GrammarTokenizerOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GrammarTokenizerOptionsT NativeTableType;
  typedef GrammarTokenizerOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOKENIZATION_TYPE = 4,
    VT_ICU_PRESERVE_WHITESPACE_TOKENS = 6,
    VT_TOKENIZATION_CODEPOINT_CONFIG = 8,
    VT_INTERNAL_TOKENIZER_CODEPOINT_RANGES = 10,
    VT_TOKENIZE_ON_SCRIPT_CHANGE = 12
  };
  libtextclassifier3::TokenizationType tokenization_type() const {
    return static_cast<libtextclassifier3::TokenizationType>(GetField<int32_t>(VT_TOKENIZATION_TYPE, 2));
  }
  bool icu_preserve_whitespace_tokens() const {
    return GetField<uint8_t>(VT_ICU_PRESERVE_WHITESPACE_TOKENS, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::TokenizationCodepointRange>> *tokenization_codepoint_config() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::TokenizationCodepointRange>> *>(VT_TOKENIZATION_CODEPOINT_CONFIG);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::CodepointRange>> *internal_tokenizer_codepoint_ranges() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::CodepointRange>> *>(VT_INTERNAL_TOKENIZER_CODEPOINT_RANGES);
  }
  bool tokenize_on_script_change() const {
    return GetField<uint8_t>(VT_TOKENIZE_ON_SCRIPT_CHANGE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TOKENIZATION_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_ICU_PRESERVE_WHITESPACE_TOKENS) &&
           VerifyOffset(verifier, VT_TOKENIZATION_CODEPOINT_CONFIG) &&
           verifier.VerifyVector(tokenization_codepoint_config()) &&
           verifier.VerifyVectorOfTables(tokenization_codepoint_config()) &&
           VerifyOffset(verifier, VT_INTERNAL_TOKENIZER_CODEPOINT_RANGES) &&
           verifier.VerifyVector(internal_tokenizer_codepoint_ranges()) &&
           verifier.VerifyVectorOfTables(internal_tokenizer_codepoint_ranges()) &&
           VerifyField<uint8_t>(verifier, VT_TOKENIZE_ON_SCRIPT_CHANGE) &&
           verifier.EndTable();
  }
  GrammarTokenizerOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GrammarTokenizerOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GrammarTokenizerOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GrammarTokenizerOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GrammarTokenizerOptionsBuilder {
  typedef GrammarTokenizerOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tokenization_type(libtextclassifier3::TokenizationType tokenization_type) {
    fbb_.AddElement<int32_t>(GrammarTokenizerOptions::VT_TOKENIZATION_TYPE, static_cast<int32_t>(tokenization_type), 2);
  }
  void add_icu_preserve_whitespace_tokens(bool icu_preserve_whitespace_tokens) {
    fbb_.AddElement<uint8_t>(GrammarTokenizerOptions::VT_ICU_PRESERVE_WHITESPACE_TOKENS, static_cast<uint8_t>(icu_preserve_whitespace_tokens), 0);
  }
  void add_tokenization_codepoint_config(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::TokenizationCodepointRange>>> tokenization_codepoint_config) {
    fbb_.AddOffset(GrammarTokenizerOptions::VT_TOKENIZATION_CODEPOINT_CONFIG, tokenization_codepoint_config);
  }
  void add_internal_tokenizer_codepoint_ranges(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::CodepointRange>>> internal_tokenizer_codepoint_ranges) {
    fbb_.AddOffset(GrammarTokenizerOptions::VT_INTERNAL_TOKENIZER_CODEPOINT_RANGES, internal_tokenizer_codepoint_ranges);
  }
  void add_tokenize_on_script_change(bool tokenize_on_script_change) {
    fbb_.AddElement<uint8_t>(GrammarTokenizerOptions::VT_TOKENIZE_ON_SCRIPT_CHANGE, static_cast<uint8_t>(tokenize_on_script_change), 0);
  }
  explicit GrammarTokenizerOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GrammarTokenizerOptionsBuilder &operator=(const GrammarTokenizerOptionsBuilder &);
  flatbuffers::Offset<GrammarTokenizerOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GrammarTokenizerOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GrammarTokenizerOptions> CreateGrammarTokenizerOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    libtextclassifier3::TokenizationType tokenization_type = libtextclassifier3::TokenizationType_ICU,
    bool icu_preserve_whitespace_tokens = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::TokenizationCodepointRange>>> tokenization_codepoint_config = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::CodepointRange>>> internal_tokenizer_codepoint_ranges = 0,
    bool tokenize_on_script_change = false) {
  GrammarTokenizerOptionsBuilder builder_(_fbb);
  builder_.add_internal_tokenizer_codepoint_ranges(internal_tokenizer_codepoint_ranges);
  builder_.add_tokenization_codepoint_config(tokenization_codepoint_config);
  builder_.add_tokenization_type(tokenization_type);
  builder_.add_tokenize_on_script_change(tokenize_on_script_change);
  builder_.add_icu_preserve_whitespace_tokens(icu_preserve_whitespace_tokens);
  return builder_.Finish();
}

inline flatbuffers::Offset<GrammarTokenizerOptions> CreateGrammarTokenizerOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    libtextclassifier3::TokenizationType tokenization_type = libtextclassifier3::TokenizationType_ICU,
    bool icu_preserve_whitespace_tokens = false,
    const std::vector<flatbuffers::Offset<libtextclassifier3::TokenizationCodepointRange>> *tokenization_codepoint_config = nullptr,
    const std::vector<flatbuffers::Offset<libtextclassifier3::CodepointRange>> *internal_tokenizer_codepoint_ranges = nullptr,
    bool tokenize_on_script_change = false) {
  auto tokenization_codepoint_config__ = tokenization_codepoint_config ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::TokenizationCodepointRange>>(*tokenization_codepoint_config) : 0;
  auto internal_tokenizer_codepoint_ranges__ = internal_tokenizer_codepoint_ranges ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::CodepointRange>>(*internal_tokenizer_codepoint_ranges) : 0;
  return libtextclassifier3::CreateGrammarTokenizerOptions(
      _fbb,
      tokenization_type,
      icu_preserve_whitespace_tokens,
      tokenization_codepoint_config__,
      internal_tokenizer_codepoint_ranges__,
      tokenize_on_script_change);
}

flatbuffers::Offset<GrammarTokenizerOptions> CreateGrammarTokenizerOptions(flatbuffers::FlatBufferBuilder &_fbb, const GrammarTokenizerOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace DatetimeModelLibrary_ {

struct ItemT : public flatbuffers::NativeTable {
  typedef Item TableType;
  std::string key;
  std::unique_ptr<libtextclassifier3::DatetimeModelT> value;
  ItemT() {
  }
};

struct Item FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ItemT NativeTableType;
  typedef ItemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  const libtextclassifier3::DatetimeModel *value() const {
    return GetPointer<const libtextclassifier3::DatetimeModel *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
  ItemT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ItemT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Item> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ItemT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ItemBuilder {
  typedef Item Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(Item::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<libtextclassifier3::DatetimeModel> value) {
    fbb_.AddOffset(Item::VT_VALUE, value);
  }
  explicit ItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ItemBuilder &operator=(const ItemBuilder &);
  flatbuffers::Offset<Item> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Item>(end);
    return o;
  }
};

inline flatbuffers::Offset<Item> CreateItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<libtextclassifier3::DatetimeModel> value = 0) {
  ItemBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<Item> CreateItemDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    flatbuffers::Offset<libtextclassifier3::DatetimeModel> value = 0) {
  auto key__ = key ? _fbb.CreateSharedString(key) : 0;
  return libtextclassifier3::DatetimeModelLibrary_::CreateItem(
      _fbb,
      key__,
      value);
}

flatbuffers::Offset<Item> CreateItem(flatbuffers::FlatBufferBuilder &_fbb, const ItemT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace DatetimeModelLibrary_

struct DatetimeModelLibraryT : public flatbuffers::NativeTable {
  typedef DatetimeModelLibrary TableType;
  std::vector<std::unique_ptr<libtextclassifier3::DatetimeModelLibrary_::ItemT>> models;
  DatetimeModelLibraryT() {
  }
};

struct DatetimeModelLibrary FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DatetimeModelLibraryT NativeTableType;
  typedef DatetimeModelLibraryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODELS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::DatetimeModelLibrary_::Item>> *models() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::DatetimeModelLibrary_::Item>> *>(VT_MODELS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MODELS) &&
           verifier.VerifyVector(models()) &&
           verifier.VerifyVectorOfTables(models()) &&
           verifier.EndTable();
  }
  DatetimeModelLibraryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DatetimeModelLibraryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DatetimeModelLibrary> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DatetimeModelLibraryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DatetimeModelLibraryBuilder {
  typedef DatetimeModelLibrary Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_models(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::DatetimeModelLibrary_::Item>>> models) {
    fbb_.AddOffset(DatetimeModelLibrary::VT_MODELS, models);
  }
  explicit DatetimeModelLibraryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DatetimeModelLibraryBuilder &operator=(const DatetimeModelLibraryBuilder &);
  flatbuffers::Offset<DatetimeModelLibrary> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DatetimeModelLibrary>(end);
    return o;
  }
};

inline flatbuffers::Offset<DatetimeModelLibrary> CreateDatetimeModelLibrary(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::DatetimeModelLibrary_::Item>>> models = 0) {
  DatetimeModelLibraryBuilder builder_(_fbb);
  builder_.add_models(models);
  return builder_.Finish();
}

inline flatbuffers::Offset<DatetimeModelLibrary> CreateDatetimeModelLibraryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<libtextclassifier3::DatetimeModelLibrary_::Item>> *models = nullptr) {
  auto models__ = models ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::DatetimeModelLibrary_::Item>>(*models) : 0;
  return libtextclassifier3::CreateDatetimeModelLibrary(
      _fbb,
      models__);
}

flatbuffers::Offset<DatetimeModelLibrary> CreateDatetimeModelLibrary(flatbuffers::FlatBufferBuilder &_fbb, const DatetimeModelLibraryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace GrammarModel_ {

struct RuleClassificationResultT : public flatbuffers::NativeTable {
  typedef RuleClassificationResult TableType;
  std::string collection_name;
  float target_classification_score;
  float priority_score;
  std::vector<std::unique_ptr<libtextclassifier3::CapturingGroupT>> capturing_group;
  std::string serialized_entity_data;
  libtextclassifier3::ModeFlag enabled_modes;
  std::unique_ptr<libtextclassifier3::EntityDataT> entity_data;
  RuleClassificationResultT()
      : target_classification_score(1.0f),
        priority_score(0.0f),
        enabled_modes(libtextclassifier3::ModeFlag_ALL) {
  }
};

struct RuleClassificationResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RuleClassificationResultT NativeTableType;
  typedef RuleClassificationResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLLECTION_NAME = 4,
    VT_TARGET_CLASSIFICATION_SCORE = 6,
    VT_PRIORITY_SCORE = 8,
    VT_CAPTURING_GROUP = 10,
    VT_SERIALIZED_ENTITY_DATA = 12,
    VT_ENABLED_MODES = 14,
    VT_ENTITY_DATA = 16
  };
  const flatbuffers::String *collection_name() const {
    return GetPointer<const flatbuffers::String *>(VT_COLLECTION_NAME);
  }
  float target_classification_score() const {
    return GetField<float>(VT_TARGET_CLASSIFICATION_SCORE, 1.0f);
  }
  float priority_score() const {
    return GetField<float>(VT_PRIORITY_SCORE, 0.0f);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::CapturingGroup>> *capturing_group() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::CapturingGroup>> *>(VT_CAPTURING_GROUP);
  }
  const flatbuffers::String *serialized_entity_data() const {
    return GetPointer<const flatbuffers::String *>(VT_SERIALIZED_ENTITY_DATA);
  }
  libtextclassifier3::ModeFlag enabled_modes() const {
    return static_cast<libtextclassifier3::ModeFlag>(GetField<int32_t>(VT_ENABLED_MODES, 7));
  }
  const libtextclassifier3::EntityData *entity_data() const {
    return GetPointer<const libtextclassifier3::EntityData *>(VT_ENTITY_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLLECTION_NAME) &&
           verifier.VerifyString(collection_name()) &&
           VerifyField<float>(verifier, VT_TARGET_CLASSIFICATION_SCORE) &&
           VerifyField<float>(verifier, VT_PRIORITY_SCORE) &&
           VerifyOffset(verifier, VT_CAPTURING_GROUP) &&
           verifier.VerifyVector(capturing_group()) &&
           verifier.VerifyVectorOfTables(capturing_group()) &&
           VerifyOffset(verifier, VT_SERIALIZED_ENTITY_DATA) &&
           verifier.VerifyString(serialized_entity_data()) &&
           VerifyField<int32_t>(verifier, VT_ENABLED_MODES) &&
           VerifyOffset(verifier, VT_ENTITY_DATA) &&
           verifier.VerifyTable(entity_data()) &&
           verifier.EndTable();
  }
  RuleClassificationResultT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RuleClassificationResultT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RuleClassificationResult> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RuleClassificationResultT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RuleClassificationResultBuilder {
  typedef RuleClassificationResult Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_collection_name(flatbuffers::Offset<flatbuffers::String> collection_name) {
    fbb_.AddOffset(RuleClassificationResult::VT_COLLECTION_NAME, collection_name);
  }
  void add_target_classification_score(float target_classification_score) {
    fbb_.AddElement<float>(RuleClassificationResult::VT_TARGET_CLASSIFICATION_SCORE, target_classification_score, 1.0f);
  }
  void add_priority_score(float priority_score) {
    fbb_.AddElement<float>(RuleClassificationResult::VT_PRIORITY_SCORE, priority_score, 0.0f);
  }
  void add_capturing_group(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::CapturingGroup>>> capturing_group) {
    fbb_.AddOffset(RuleClassificationResult::VT_CAPTURING_GROUP, capturing_group);
  }
  void add_serialized_entity_data(flatbuffers::Offset<flatbuffers::String> serialized_entity_data) {
    fbb_.AddOffset(RuleClassificationResult::VT_SERIALIZED_ENTITY_DATA, serialized_entity_data);
  }
  void add_enabled_modes(libtextclassifier3::ModeFlag enabled_modes) {
    fbb_.AddElement<int32_t>(RuleClassificationResult::VT_ENABLED_MODES, static_cast<int32_t>(enabled_modes), 7);
  }
  void add_entity_data(flatbuffers::Offset<libtextclassifier3::EntityData> entity_data) {
    fbb_.AddOffset(RuleClassificationResult::VT_ENTITY_DATA, entity_data);
  }
  explicit RuleClassificationResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RuleClassificationResultBuilder &operator=(const RuleClassificationResultBuilder &);
  flatbuffers::Offset<RuleClassificationResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RuleClassificationResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<RuleClassificationResult> CreateRuleClassificationResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> collection_name = 0,
    float target_classification_score = 1.0f,
    float priority_score = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::CapturingGroup>>> capturing_group = 0,
    flatbuffers::Offset<flatbuffers::String> serialized_entity_data = 0,
    libtextclassifier3::ModeFlag enabled_modes = libtextclassifier3::ModeFlag_ALL,
    flatbuffers::Offset<libtextclassifier3::EntityData> entity_data = 0) {
  RuleClassificationResultBuilder builder_(_fbb);
  builder_.add_entity_data(entity_data);
  builder_.add_enabled_modes(enabled_modes);
  builder_.add_serialized_entity_data(serialized_entity_data);
  builder_.add_capturing_group(capturing_group);
  builder_.add_priority_score(priority_score);
  builder_.add_target_classification_score(target_classification_score);
  builder_.add_collection_name(collection_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<RuleClassificationResult> CreateRuleClassificationResultDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *collection_name = nullptr,
    float target_classification_score = 1.0f,
    float priority_score = 0.0f,
    const std::vector<flatbuffers::Offset<libtextclassifier3::CapturingGroup>> *capturing_group = nullptr,
    const char *serialized_entity_data = nullptr,
    libtextclassifier3::ModeFlag enabled_modes = libtextclassifier3::ModeFlag_ALL,
    flatbuffers::Offset<libtextclassifier3::EntityData> entity_data = 0) {
  auto collection_name__ = collection_name ? _fbb.CreateSharedString(collection_name) : 0;
  auto capturing_group__ = capturing_group ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::CapturingGroup>>(*capturing_group) : 0;
  auto serialized_entity_data__ = serialized_entity_data ? _fbb.CreateSharedString(serialized_entity_data) : 0;
  return libtextclassifier3::GrammarModel_::CreateRuleClassificationResult(
      _fbb,
      collection_name__,
      target_classification_score,
      priority_score,
      capturing_group__,
      serialized_entity_data__,
      enabled_modes,
      entity_data);
}

flatbuffers::Offset<RuleClassificationResult> CreateRuleClassificationResult(flatbuffers::FlatBufferBuilder &_fbb, const RuleClassificationResultT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace GrammarModel_

struct GrammarModelT : public flatbuffers::NativeTable {
  typedef GrammarModel TableType;
  std::unique_ptr<libtextclassifier3::grammar::RulesSetT> rules;
  std::vector<std::unique_ptr<libtextclassifier3::GrammarModel_::RuleClassificationResultT>> rule_classification_result;
  int32_t context_left_num_tokens;
  int32_t context_right_num_tokens;
  std::unique_ptr<libtextclassifier3::GrammarTokenizerOptionsT> tokenizer_options;
  float target_classification_score;
  float priority_score;
  GrammarModelT()
      : context_left_num_tokens(0),
        context_right_num_tokens(0),
        target_classification_score(1.0f),
        priority_score(1.0f) {
  }
};

struct GrammarModel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GrammarModelT NativeTableType;
  typedef GrammarModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RULES = 4,
    VT_RULE_CLASSIFICATION_RESULT = 6,
    VT_CONTEXT_LEFT_NUM_TOKENS = 8,
    VT_CONTEXT_RIGHT_NUM_TOKENS = 10,
    VT_TOKENIZER_OPTIONS = 12,
    VT_TARGET_CLASSIFICATION_SCORE = 14,
    VT_PRIORITY_SCORE = 16
  };
  const libtextclassifier3::grammar::RulesSet *rules() const {
    return GetPointer<const libtextclassifier3::grammar::RulesSet *>(VT_RULES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::GrammarModel_::RuleClassificationResult>> *rule_classification_result() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::GrammarModel_::RuleClassificationResult>> *>(VT_RULE_CLASSIFICATION_RESULT);
  }
  int32_t context_left_num_tokens() const {
    return GetField<int32_t>(VT_CONTEXT_LEFT_NUM_TOKENS, 0);
  }
  int32_t context_right_num_tokens() const {
    return GetField<int32_t>(VT_CONTEXT_RIGHT_NUM_TOKENS, 0);
  }
  const libtextclassifier3::GrammarTokenizerOptions *tokenizer_options() const {
    return GetPointer<const libtextclassifier3::GrammarTokenizerOptions *>(VT_TOKENIZER_OPTIONS);
  }
  float target_classification_score() const {
    return GetField<float>(VT_TARGET_CLASSIFICATION_SCORE, 1.0f);
  }
  float priority_score() const {
    return GetField<float>(VT_PRIORITY_SCORE, 1.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RULES) &&
           verifier.VerifyTable(rules()) &&
           VerifyOffset(verifier, VT_RULE_CLASSIFICATION_RESULT) &&
           verifier.VerifyVector(rule_classification_result()) &&
           verifier.VerifyVectorOfTables(rule_classification_result()) &&
           VerifyField<int32_t>(verifier, VT_CONTEXT_LEFT_NUM_TOKENS) &&
           VerifyField<int32_t>(verifier, VT_CONTEXT_RIGHT_NUM_TOKENS) &&
           VerifyOffset(verifier, VT_TOKENIZER_OPTIONS) &&
           verifier.VerifyTable(tokenizer_options()) &&
           VerifyField<float>(verifier, VT_TARGET_CLASSIFICATION_SCORE) &&
           VerifyField<float>(verifier, VT_PRIORITY_SCORE) &&
           verifier.EndTable();
  }
  GrammarModelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GrammarModelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GrammarModel> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GrammarModelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GrammarModelBuilder {
  typedef GrammarModel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rules(flatbuffers::Offset<libtextclassifier3::grammar::RulesSet> rules) {
    fbb_.AddOffset(GrammarModel::VT_RULES, rules);
  }
  void add_rule_classification_result(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::GrammarModel_::RuleClassificationResult>>> rule_classification_result) {
    fbb_.AddOffset(GrammarModel::VT_RULE_CLASSIFICATION_RESULT, rule_classification_result);
  }
  void add_context_left_num_tokens(int32_t context_left_num_tokens) {
    fbb_.AddElement<int32_t>(GrammarModel::VT_CONTEXT_LEFT_NUM_TOKENS, context_left_num_tokens, 0);
  }
  void add_context_right_num_tokens(int32_t context_right_num_tokens) {
    fbb_.AddElement<int32_t>(GrammarModel::VT_CONTEXT_RIGHT_NUM_TOKENS, context_right_num_tokens, 0);
  }
  void add_tokenizer_options(flatbuffers::Offset<libtextclassifier3::GrammarTokenizerOptions> tokenizer_options) {
    fbb_.AddOffset(GrammarModel::VT_TOKENIZER_OPTIONS, tokenizer_options);
  }
  void add_target_classification_score(float target_classification_score) {
    fbb_.AddElement<float>(GrammarModel::VT_TARGET_CLASSIFICATION_SCORE, target_classification_score, 1.0f);
  }
  void add_priority_score(float priority_score) {
    fbb_.AddElement<float>(GrammarModel::VT_PRIORITY_SCORE, priority_score, 1.0f);
  }
  explicit GrammarModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GrammarModelBuilder &operator=(const GrammarModelBuilder &);
  flatbuffers::Offset<GrammarModel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GrammarModel>(end);
    return o;
  }
};

inline flatbuffers::Offset<GrammarModel> CreateGrammarModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<libtextclassifier3::grammar::RulesSet> rules = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::GrammarModel_::RuleClassificationResult>>> rule_classification_result = 0,
    int32_t context_left_num_tokens = 0,
    int32_t context_right_num_tokens = 0,
    flatbuffers::Offset<libtextclassifier3::GrammarTokenizerOptions> tokenizer_options = 0,
    float target_classification_score = 1.0f,
    float priority_score = 1.0f) {
  GrammarModelBuilder builder_(_fbb);
  builder_.add_priority_score(priority_score);
  builder_.add_target_classification_score(target_classification_score);
  builder_.add_tokenizer_options(tokenizer_options);
  builder_.add_context_right_num_tokens(context_right_num_tokens);
  builder_.add_context_left_num_tokens(context_left_num_tokens);
  builder_.add_rule_classification_result(rule_classification_result);
  builder_.add_rules(rules);
  return builder_.Finish();
}

inline flatbuffers::Offset<GrammarModel> CreateGrammarModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<libtextclassifier3::grammar::RulesSet> rules = 0,
    const std::vector<flatbuffers::Offset<libtextclassifier3::GrammarModel_::RuleClassificationResult>> *rule_classification_result = nullptr,
    int32_t context_left_num_tokens = 0,
    int32_t context_right_num_tokens = 0,
    flatbuffers::Offset<libtextclassifier3::GrammarTokenizerOptions> tokenizer_options = 0,
    float target_classification_score = 1.0f,
    float priority_score = 1.0f) {
  auto rule_classification_result__ = rule_classification_result ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::GrammarModel_::RuleClassificationResult>>(*rule_classification_result) : 0;
  return libtextclassifier3::CreateGrammarModel(
      _fbb,
      rules,
      rule_classification_result__,
      context_left_num_tokens,
      context_right_num_tokens,
      tokenizer_options,
      target_classification_score,
      priority_score);
}

flatbuffers::Offset<GrammarModel> CreateGrammarModel(flatbuffers::FlatBufferBuilder &_fbb, const GrammarModelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace MoneyParsingOptions_ {

struct QuantitiesNameToExponentEntryT : public flatbuffers::NativeTable {
  typedef QuantitiesNameToExponentEntry TableType;
  std::string key;
  int32_t value;
  QuantitiesNameToExponentEntryT()
      : value(0) {
  }
};

struct QuantitiesNameToExponentEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuantitiesNameToExponentEntryT NativeTableType;
  typedef QuantitiesNameToExponentEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  bool KeyCompareLessThan(const QuantitiesNameToExponentEntry *o) const {
    return *key() < *o->key();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(key()->c_str(), val);
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
  QuantitiesNameToExponentEntryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuantitiesNameToExponentEntryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<QuantitiesNameToExponentEntry> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantitiesNameToExponentEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QuantitiesNameToExponentEntryBuilder {
  typedef QuantitiesNameToExponentEntry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(QuantitiesNameToExponentEntry::VT_KEY, key);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(QuantitiesNameToExponentEntry::VT_VALUE, value, 0);
  }
  explicit QuantitiesNameToExponentEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuantitiesNameToExponentEntryBuilder &operator=(const QuantitiesNameToExponentEntryBuilder &);
  flatbuffers::Offset<QuantitiesNameToExponentEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantitiesNameToExponentEntry>(end);
    fbb_.Required(o, QuantitiesNameToExponentEntry::VT_KEY);
    return o;
  }
};

inline flatbuffers::Offset<QuantitiesNameToExponentEntry> CreateQuantitiesNameToExponentEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    int32_t value = 0) {
  QuantitiesNameToExponentEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<QuantitiesNameToExponentEntry> CreateQuantitiesNameToExponentEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    int32_t value = 0) {
  auto key__ = key ? _fbb.CreateSharedString(key) : 0;
  return libtextclassifier3::MoneyParsingOptions_::CreateQuantitiesNameToExponentEntry(
      _fbb,
      key__,
      value);
}

flatbuffers::Offset<QuantitiesNameToExponentEntry> CreateQuantitiesNameToExponentEntry(flatbuffers::FlatBufferBuilder &_fbb, const QuantitiesNameToExponentEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace MoneyParsingOptions_

struct MoneyParsingOptionsT : public flatbuffers::NativeTable {
  typedef MoneyParsingOptions TableType;
  std::vector<int32_t> separators;
  std::vector<std::unique_ptr<libtextclassifier3::MoneyParsingOptions_::QuantitiesNameToExponentEntryT>> quantities_name_to_exponent;
  MoneyParsingOptionsT() {
  }
};

struct MoneyParsingOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MoneyParsingOptionsT NativeTableType;
  typedef MoneyParsingOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEPARATORS = 4,
    VT_QUANTITIES_NAME_TO_EXPONENT = 6
  };
  const flatbuffers::Vector<int32_t> *separators() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SEPARATORS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::MoneyParsingOptions_::QuantitiesNameToExponentEntry>> *quantities_name_to_exponent() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::MoneyParsingOptions_::QuantitiesNameToExponentEntry>> *>(VT_QUANTITIES_NAME_TO_EXPONENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SEPARATORS) &&
           verifier.VerifyVector(separators()) &&
           VerifyOffset(verifier, VT_QUANTITIES_NAME_TO_EXPONENT) &&
           verifier.VerifyVector(quantities_name_to_exponent()) &&
           verifier.VerifyVectorOfTables(quantities_name_to_exponent()) &&
           verifier.EndTable();
  }
  MoneyParsingOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MoneyParsingOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MoneyParsingOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoneyParsingOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MoneyParsingOptionsBuilder {
  typedef MoneyParsingOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_separators(flatbuffers::Offset<flatbuffers::Vector<int32_t>> separators) {
    fbb_.AddOffset(MoneyParsingOptions::VT_SEPARATORS, separators);
  }
  void add_quantities_name_to_exponent(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::MoneyParsingOptions_::QuantitiesNameToExponentEntry>>> quantities_name_to_exponent) {
    fbb_.AddOffset(MoneyParsingOptions::VT_QUANTITIES_NAME_TO_EXPONENT, quantities_name_to_exponent);
  }
  explicit MoneyParsingOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MoneyParsingOptionsBuilder &operator=(const MoneyParsingOptionsBuilder &);
  flatbuffers::Offset<MoneyParsingOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MoneyParsingOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MoneyParsingOptions> CreateMoneyParsingOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> separators = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::MoneyParsingOptions_::QuantitiesNameToExponentEntry>>> quantities_name_to_exponent = 0) {
  MoneyParsingOptionsBuilder builder_(_fbb);
  builder_.add_quantities_name_to_exponent(quantities_name_to_exponent);
  builder_.add_separators(separators);
  return builder_.Finish();
}

inline flatbuffers::Offset<MoneyParsingOptions> CreateMoneyParsingOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *separators = nullptr,
    std::vector<flatbuffers::Offset<libtextclassifier3::MoneyParsingOptions_::QuantitiesNameToExponentEntry>> *quantities_name_to_exponent = nullptr) {
  auto separators__ = separators ? _fbb.CreateVector<int32_t>(*separators) : 0;
  auto quantities_name_to_exponent__ = quantities_name_to_exponent ? _fbb.CreateVectorOfSortedTables<libtextclassifier3::MoneyParsingOptions_::QuantitiesNameToExponentEntry>(quantities_name_to_exponent) : 0;
  return libtextclassifier3::CreateMoneyParsingOptions(
      _fbb,
      separators__,
      quantities_name_to_exponent__);
}

flatbuffers::Offset<MoneyParsingOptions> CreateMoneyParsingOptions(flatbuffers::FlatBufferBuilder &_fbb, const MoneyParsingOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace ModelTriggeringOptions_ {

struct CollectionToPriorityEntryT : public flatbuffers::NativeTable {
  typedef CollectionToPriorityEntry TableType;
  std::string key;
  float value;
  CollectionToPriorityEntryT()
      : value(0.0f) {
  }
};

struct CollectionToPriorityEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CollectionToPriorityEntryT NativeTableType;
  typedef CollectionToPriorityEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  bool KeyCompareLessThan(const CollectionToPriorityEntry *o) const {
    return *key() < *o->key();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(key()->c_str(), val);
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
  CollectionToPriorityEntryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CollectionToPriorityEntryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CollectionToPriorityEntry> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CollectionToPriorityEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CollectionToPriorityEntryBuilder {
  typedef CollectionToPriorityEntry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(CollectionToPriorityEntry::VT_KEY, key);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(CollectionToPriorityEntry::VT_VALUE, value, 0.0f);
  }
  explicit CollectionToPriorityEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CollectionToPriorityEntryBuilder &operator=(const CollectionToPriorityEntryBuilder &);
  flatbuffers::Offset<CollectionToPriorityEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CollectionToPriorityEntry>(end);
    fbb_.Required(o, CollectionToPriorityEntry::VT_KEY);
    return o;
  }
};

inline flatbuffers::Offset<CollectionToPriorityEntry> CreateCollectionToPriorityEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    float value = 0.0f) {
  CollectionToPriorityEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<CollectionToPriorityEntry> CreateCollectionToPriorityEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    float value = 0.0f) {
  auto key__ = key ? _fbb.CreateSharedString(key) : 0;
  return libtextclassifier3::ModelTriggeringOptions_::CreateCollectionToPriorityEntry(
      _fbb,
      key__,
      value);
}

flatbuffers::Offset<CollectionToPriorityEntry> CreateCollectionToPriorityEntry(flatbuffers::FlatBufferBuilder &_fbb, const CollectionToPriorityEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace ModelTriggeringOptions_

struct ModelTriggeringOptionsT : public flatbuffers::NativeTable {
  typedef ModelTriggeringOptions TableType;
  float min_annotate_confidence;
  libtextclassifier3::ModeFlag enabled_modes;
  std::string dictionary_locales;
  std::string locales;
  float other_collection_priority_score;
  float knowledge_priority_score;
  std::vector<std::unique_ptr<libtextclassifier3::ModelTriggeringOptions_::CollectionToPriorityEntryT>> collection_to_priority;
  ModelTriggeringOptionsT()
      : min_annotate_confidence(0.0f),
        enabled_modes(libtextclassifier3::ModeFlag_ALL),
        other_collection_priority_score(-1000.0f),
        knowledge_priority_score(0.0f) {
  }
};

struct ModelTriggeringOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModelTriggeringOptionsT NativeTableType;
  typedef ModelTriggeringOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN_ANNOTATE_CONFIDENCE = 4,
    VT_ENABLED_MODES = 6,
    VT_DICTIONARY_LOCALES = 8,
    VT_LOCALES = 10,
    VT_OTHER_COLLECTION_PRIORITY_SCORE = 12,
    VT_KNOWLEDGE_PRIORITY_SCORE = 14,
    VT_COLLECTION_TO_PRIORITY = 18
  };
  float min_annotate_confidence() const {
    return GetField<float>(VT_MIN_ANNOTATE_CONFIDENCE, 0.0f);
  }
  libtextclassifier3::ModeFlag enabled_modes() const {
    return static_cast<libtextclassifier3::ModeFlag>(GetField<int32_t>(VT_ENABLED_MODES, 7));
  }
  const flatbuffers::String *dictionary_locales() const {
    return GetPointer<const flatbuffers::String *>(VT_DICTIONARY_LOCALES);
  }
  const flatbuffers::String *locales() const {
    return GetPointer<const flatbuffers::String *>(VT_LOCALES);
  }
  float other_collection_priority_score() const {
    return GetField<float>(VT_OTHER_COLLECTION_PRIORITY_SCORE, -1000.0f);
  }
  float knowledge_priority_score() const {
    return GetField<float>(VT_KNOWLEDGE_PRIORITY_SCORE, 0.0f);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::ModelTriggeringOptions_::CollectionToPriorityEntry>> *collection_to_priority() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::ModelTriggeringOptions_::CollectionToPriorityEntry>> *>(VT_COLLECTION_TO_PRIORITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MIN_ANNOTATE_CONFIDENCE) &&
           VerifyField<int32_t>(verifier, VT_ENABLED_MODES) &&
           VerifyOffset(verifier, VT_DICTIONARY_LOCALES) &&
           verifier.VerifyString(dictionary_locales()) &&
           VerifyOffset(verifier, VT_LOCALES) &&
           verifier.VerifyString(locales()) &&
           VerifyField<float>(verifier, VT_OTHER_COLLECTION_PRIORITY_SCORE) &&
           VerifyField<float>(verifier, VT_KNOWLEDGE_PRIORITY_SCORE) &&
           VerifyOffset(verifier, VT_COLLECTION_TO_PRIORITY) &&
           verifier.VerifyVector(collection_to_priority()) &&
           verifier.VerifyVectorOfTables(collection_to_priority()) &&
           verifier.EndTable();
  }
  ModelTriggeringOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ModelTriggeringOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ModelTriggeringOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelTriggeringOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ModelTriggeringOptionsBuilder {
  typedef ModelTriggeringOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min_annotate_confidence(float min_annotate_confidence) {
    fbb_.AddElement<float>(ModelTriggeringOptions::VT_MIN_ANNOTATE_CONFIDENCE, min_annotate_confidence, 0.0f);
  }
  void add_enabled_modes(libtextclassifier3::ModeFlag enabled_modes) {
    fbb_.AddElement<int32_t>(ModelTriggeringOptions::VT_ENABLED_MODES, static_cast<int32_t>(enabled_modes), 7);
  }
  void add_dictionary_locales(flatbuffers::Offset<flatbuffers::String> dictionary_locales) {
    fbb_.AddOffset(ModelTriggeringOptions::VT_DICTIONARY_LOCALES, dictionary_locales);
  }
  void add_locales(flatbuffers::Offset<flatbuffers::String> locales) {
    fbb_.AddOffset(ModelTriggeringOptions::VT_LOCALES, locales);
  }
  void add_other_collection_priority_score(float other_collection_priority_score) {
    fbb_.AddElement<float>(ModelTriggeringOptions::VT_OTHER_COLLECTION_PRIORITY_SCORE, other_collection_priority_score, -1000.0f);
  }
  void add_knowledge_priority_score(float knowledge_priority_score) {
    fbb_.AddElement<float>(ModelTriggeringOptions::VT_KNOWLEDGE_PRIORITY_SCORE, knowledge_priority_score, 0.0f);
  }
  void add_collection_to_priority(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::ModelTriggeringOptions_::CollectionToPriorityEntry>>> collection_to_priority) {
    fbb_.AddOffset(ModelTriggeringOptions::VT_COLLECTION_TO_PRIORITY, collection_to_priority);
  }
  explicit ModelTriggeringOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModelTriggeringOptionsBuilder &operator=(const ModelTriggeringOptionsBuilder &);
  flatbuffers::Offset<ModelTriggeringOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ModelTriggeringOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ModelTriggeringOptions> CreateModelTriggeringOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    float min_annotate_confidence = 0.0f,
    libtextclassifier3::ModeFlag enabled_modes = libtextclassifier3::ModeFlag_ALL,
    flatbuffers::Offset<flatbuffers::String> dictionary_locales = 0,
    flatbuffers::Offset<flatbuffers::String> locales = 0,
    float other_collection_priority_score = -1000.0f,
    float knowledge_priority_score = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::ModelTriggeringOptions_::CollectionToPriorityEntry>>> collection_to_priority = 0) {
  ModelTriggeringOptionsBuilder builder_(_fbb);
  builder_.add_collection_to_priority(collection_to_priority);
  builder_.add_knowledge_priority_score(knowledge_priority_score);
  builder_.add_other_collection_priority_score(other_collection_priority_score);
  builder_.add_locales(locales);
  builder_.add_dictionary_locales(dictionary_locales);
  builder_.add_enabled_modes(enabled_modes);
  builder_.add_min_annotate_confidence(min_annotate_confidence);
  return builder_.Finish();
}

inline flatbuffers::Offset<ModelTriggeringOptions> CreateModelTriggeringOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float min_annotate_confidence = 0.0f,
    libtextclassifier3::ModeFlag enabled_modes = libtextclassifier3::ModeFlag_ALL,
    const char *dictionary_locales = nullptr,
    const char *locales = nullptr,
    float other_collection_priority_score = -1000.0f,
    float knowledge_priority_score = 0.0f,
    std::vector<flatbuffers::Offset<libtextclassifier3::ModelTriggeringOptions_::CollectionToPriorityEntry>> *collection_to_priority = nullptr) {
  auto dictionary_locales__ = dictionary_locales ? _fbb.CreateSharedString(dictionary_locales) : 0;
  auto locales__ = locales ? _fbb.CreateSharedString(locales) : 0;
  auto collection_to_priority__ = collection_to_priority ? _fbb.CreateVectorOfSortedTables<libtextclassifier3::ModelTriggeringOptions_::CollectionToPriorityEntry>(collection_to_priority) : 0;
  return libtextclassifier3::CreateModelTriggeringOptions(
      _fbb,
      min_annotate_confidence,
      enabled_modes,
      dictionary_locales__,
      locales__,
      other_collection_priority_score,
      knowledge_priority_score,
      collection_to_priority__);
}

flatbuffers::Offset<ModelTriggeringOptions> CreateModelTriggeringOptions(flatbuffers::FlatBufferBuilder &_fbb, const ModelTriggeringOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OutputOptionsT : public flatbuffers::NativeTable {
  typedef OutputOptions TableType;
  std::vector<std::string> filtered_collections_annotation;
  std::vector<std::string> filtered_collections_classification;
  std::vector<std::string> filtered_collections_selection;
  OutputOptionsT() {
  }
};

struct OutputOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OutputOptionsT NativeTableType;
  typedef OutputOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILTERED_COLLECTIONS_ANNOTATION = 4,
    VT_FILTERED_COLLECTIONS_CLASSIFICATION = 6,
    VT_FILTERED_COLLECTIONS_SELECTION = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *filtered_collections_annotation() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_FILTERED_COLLECTIONS_ANNOTATION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *filtered_collections_classification() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_FILTERED_COLLECTIONS_CLASSIFICATION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *filtered_collections_selection() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_FILTERED_COLLECTIONS_SELECTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILTERED_COLLECTIONS_ANNOTATION) &&
           verifier.VerifyVector(filtered_collections_annotation()) &&
           verifier.VerifyVectorOfStrings(filtered_collections_annotation()) &&
           VerifyOffset(verifier, VT_FILTERED_COLLECTIONS_CLASSIFICATION) &&
           verifier.VerifyVector(filtered_collections_classification()) &&
           verifier.VerifyVectorOfStrings(filtered_collections_classification()) &&
           VerifyOffset(verifier, VT_FILTERED_COLLECTIONS_SELECTION) &&
           verifier.VerifyVector(filtered_collections_selection()) &&
           verifier.VerifyVectorOfStrings(filtered_collections_selection()) &&
           verifier.EndTable();
  }
  OutputOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OutputOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OutputOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OutputOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OutputOptionsBuilder {
  typedef OutputOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_filtered_collections_annotation(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> filtered_collections_annotation) {
    fbb_.AddOffset(OutputOptions::VT_FILTERED_COLLECTIONS_ANNOTATION, filtered_collections_annotation);
  }
  void add_filtered_collections_classification(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> filtered_collections_classification) {
    fbb_.AddOffset(OutputOptions::VT_FILTERED_COLLECTIONS_CLASSIFICATION, filtered_collections_classification);
  }
  void add_filtered_collections_selection(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> filtered_collections_selection) {
    fbb_.AddOffset(OutputOptions::VT_FILTERED_COLLECTIONS_SELECTION, filtered_collections_selection);
  }
  explicit OutputOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OutputOptionsBuilder &operator=(const OutputOptionsBuilder &);
  flatbuffers::Offset<OutputOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OutputOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<OutputOptions> CreateOutputOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> filtered_collections_annotation = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> filtered_collections_classification = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> filtered_collections_selection = 0) {
  OutputOptionsBuilder builder_(_fbb);
  builder_.add_filtered_collections_selection(filtered_collections_selection);
  builder_.add_filtered_collections_classification(filtered_collections_classification);
  builder_.add_filtered_collections_annotation(filtered_collections_annotation);
  return builder_.Finish();
}

inline flatbuffers::Offset<OutputOptions> CreateOutputOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *filtered_collections_annotation = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *filtered_collections_classification = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *filtered_collections_selection = nullptr) {
  auto filtered_collections_annotation__ = filtered_collections_annotation ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*filtered_collections_annotation) : 0;
  auto filtered_collections_classification__ = filtered_collections_classification ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*filtered_collections_classification) : 0;
  auto filtered_collections_selection__ = filtered_collections_selection ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*filtered_collections_selection) : 0;
  return libtextclassifier3::CreateOutputOptions(
      _fbb,
      filtered_collections_annotation__,
      filtered_collections_classification__,
      filtered_collections_selection__);
}

flatbuffers::Offset<OutputOptions> CreateOutputOptions(flatbuffers::FlatBufferBuilder &_fbb, const OutputOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace Model_ {

struct EmbeddingPruningMaskT : public flatbuffers::NativeTable {
  typedef EmbeddingPruningMask TableType;
  bool enabled;
  std::vector<uint64_t> pruning_mask;
  int32_t full_num_buckets;
  int32_t pruned_row_bucket_id;
  EmbeddingPruningMaskT()
      : enabled(false),
        full_num_buckets(0),
        pruned_row_bucket_id(0) {
  }
};

struct EmbeddingPruningMask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EmbeddingPruningMaskT NativeTableType;
  typedef EmbeddingPruningMaskBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLED = 4,
    VT_PRUNING_MASK = 6,
    VT_FULL_NUM_BUCKETS = 8,
    VT_PRUNED_ROW_BUCKET_ID = 10
  };
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 0) != 0;
  }
  const flatbuffers::Vector<uint64_t> *pruning_mask() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_PRUNING_MASK);
  }
  int32_t full_num_buckets() const {
    return GetField<int32_t>(VT_FULL_NUM_BUCKETS, 0);
  }
  int32_t pruned_row_bucket_id() const {
    return GetField<int32_t>(VT_PRUNED_ROW_BUCKET_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED) &&
           VerifyOffset(verifier, VT_PRUNING_MASK) &&
           verifier.VerifyVector(pruning_mask()) &&
           VerifyField<int32_t>(verifier, VT_FULL_NUM_BUCKETS) &&
           VerifyField<int32_t>(verifier, VT_PRUNED_ROW_BUCKET_ID) &&
           verifier.EndTable();
  }
  EmbeddingPruningMaskT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EmbeddingPruningMaskT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EmbeddingPruningMask> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingPruningMaskT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EmbeddingPruningMaskBuilder {
  typedef EmbeddingPruningMask Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(EmbeddingPruningMask::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
  }
  void add_pruning_mask(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> pruning_mask) {
    fbb_.AddOffset(EmbeddingPruningMask::VT_PRUNING_MASK, pruning_mask);
  }
  void add_full_num_buckets(int32_t full_num_buckets) {
    fbb_.AddElement<int32_t>(EmbeddingPruningMask::VT_FULL_NUM_BUCKETS, full_num_buckets, 0);
  }
  void add_pruned_row_bucket_id(int32_t pruned_row_bucket_id) {
    fbb_.AddElement<int32_t>(EmbeddingPruningMask::VT_PRUNED_ROW_BUCKET_ID, pruned_row_bucket_id, 0);
  }
  explicit EmbeddingPruningMaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EmbeddingPruningMaskBuilder &operator=(const EmbeddingPruningMaskBuilder &);
  flatbuffers::Offset<EmbeddingPruningMask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EmbeddingPruningMask>(end);
    return o;
  }
};

inline flatbuffers::Offset<EmbeddingPruningMask> CreateEmbeddingPruningMask(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enabled = false,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> pruning_mask = 0,
    int32_t full_num_buckets = 0,
    int32_t pruned_row_bucket_id = 0) {
  EmbeddingPruningMaskBuilder builder_(_fbb);
  builder_.add_pruned_row_bucket_id(pruned_row_bucket_id);
  builder_.add_full_num_buckets(full_num_buckets);
  builder_.add_pruning_mask(pruning_mask);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

inline flatbuffers::Offset<EmbeddingPruningMask> CreateEmbeddingPruningMaskDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enabled = false,
    const std::vector<uint64_t> *pruning_mask = nullptr,
    int32_t full_num_buckets = 0,
    int32_t pruned_row_bucket_id = 0) {
  if (pruning_mask) { _fbb.ForceVectorAlignment(pruning_mask->size(), sizeof(uint64_t), 16); }
  auto pruning_mask__ = pruning_mask ? _fbb.CreateVector<uint64_t>(*pruning_mask) : 0;
  return libtextclassifier3::Model_::CreateEmbeddingPruningMask(
      _fbb,
      enabled,
      pruning_mask__,
      full_num_buckets,
      pruned_row_bucket_id);
}

flatbuffers::Offset<EmbeddingPruningMask> CreateEmbeddingPruningMask(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingPruningMaskT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConflictResolutionOptionsT : public flatbuffers::NativeTable {
  typedef ConflictResolutionOptions TableType;
  bool prioritize_longest_annotation;
  bool do_conflict_resolution_in_raw_mode;
  ConflictResolutionOptionsT()
      : prioritize_longest_annotation(false),
        do_conflict_resolution_in_raw_mode(true) {
  }
};

struct ConflictResolutionOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConflictResolutionOptionsT NativeTableType;
  typedef ConflictResolutionOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRIORITIZE_LONGEST_ANNOTATION = 4,
    VT_DO_CONFLICT_RESOLUTION_IN_RAW_MODE = 6
  };
  bool prioritize_longest_annotation() const {
    return GetField<uint8_t>(VT_PRIORITIZE_LONGEST_ANNOTATION, 0) != 0;
  }
  bool do_conflict_resolution_in_raw_mode() const {
    return GetField<uint8_t>(VT_DO_CONFLICT_RESOLUTION_IN_RAW_MODE, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PRIORITIZE_LONGEST_ANNOTATION) &&
           VerifyField<uint8_t>(verifier, VT_DO_CONFLICT_RESOLUTION_IN_RAW_MODE) &&
           verifier.EndTable();
  }
  ConflictResolutionOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConflictResolutionOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ConflictResolutionOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConflictResolutionOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConflictResolutionOptionsBuilder {
  typedef ConflictResolutionOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_prioritize_longest_annotation(bool prioritize_longest_annotation) {
    fbb_.AddElement<uint8_t>(ConflictResolutionOptions::VT_PRIORITIZE_LONGEST_ANNOTATION, static_cast<uint8_t>(prioritize_longest_annotation), 0);
  }
  void add_do_conflict_resolution_in_raw_mode(bool do_conflict_resolution_in_raw_mode) {
    fbb_.AddElement<uint8_t>(ConflictResolutionOptions::VT_DO_CONFLICT_RESOLUTION_IN_RAW_MODE, static_cast<uint8_t>(do_conflict_resolution_in_raw_mode), 1);
  }
  explicit ConflictResolutionOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConflictResolutionOptionsBuilder &operator=(const ConflictResolutionOptionsBuilder &);
  flatbuffers::Offset<ConflictResolutionOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConflictResolutionOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConflictResolutionOptions> CreateConflictResolutionOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool prioritize_longest_annotation = false,
    bool do_conflict_resolution_in_raw_mode = true) {
  ConflictResolutionOptionsBuilder builder_(_fbb);
  builder_.add_do_conflict_resolution_in_raw_mode(do_conflict_resolution_in_raw_mode);
  builder_.add_prioritize_longest_annotation(prioritize_longest_annotation);
  return builder_.Finish();
}

flatbuffers::Offset<ConflictResolutionOptions> CreateConflictResolutionOptions(flatbuffers::FlatBufferBuilder &_fbb, const ConflictResolutionOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace Model_

struct ModelT : public flatbuffers::NativeTable {
  typedef Model TableType;
  std::string locales;
  int32_t version;
  std::string name;
  std::unique_ptr<libtextclassifier3::FeatureProcessorOptionsT> selection_feature_options;
  std::unique_ptr<libtextclassifier3::FeatureProcessorOptionsT> classification_feature_options;
  std::vector<uint8_t> selection_model;
  std::vector<uint8_t> classification_model;
  std::vector<uint8_t> embedding_model;
  std::unique_ptr<libtextclassifier3::SelectionModelOptionsT> selection_options;
  std::unique_ptr<libtextclassifier3::ClassificationModelOptionsT> classification_options;
  std::unique_ptr<libtextclassifier3::RegexModelT> regex_model;
  std::unique_ptr<libtextclassifier3::DatetimeModelT> datetime_model;
  std::unique_ptr<libtextclassifier3::ModelTriggeringOptionsT> triggering_options;
  libtextclassifier3::ModeFlag enabled_modes;
  bool snap_whitespace_selections;
  std::unique_ptr<libtextclassifier3::OutputOptionsT> output_options;
  std::unique_ptr<libtextclassifier3::AndroidIntentFactoryOptionsT> android_intent_options;
  std::unique_ptr<libtextclassifier3::IntentFactoryModelT> intent_options;
  std::unique_ptr<libtextclassifier3::ResourcePoolT> resources;
  std::vector<uint8_t> entity_data_schema;
  std::unique_ptr<libtextclassifier3::NumberAnnotatorOptionsT> number_annotator_options;
  std::unique_ptr<libtextclassifier3::DurationAnnotatorOptionsT> duration_annotator_options;
  std::string triggering_locales;
  std::unique_ptr<libtextclassifier3::Model_::EmbeddingPruningMaskT> embedding_pruning_mask;
  std::unique_ptr<libtextclassifier3::ContactAnnotatorOptionsT> contact_annotator_options;
  std::unique_ptr<libtextclassifier3::MoneyParsingOptionsT> money_parsing_options;
  std::unique_ptr<libtextclassifier3::TranslateAnnotatorOptionsT> translate_annotator_options;
  std::unique_ptr<libtextclassifier3::GrammarModelT> grammar_model;
  std::unique_ptr<libtextclassifier3::Model_::ConflictResolutionOptionsT> conflict_resolution_options;
  std::unique_ptr<libtextclassifier3::ExperimentalModelT> experimental_model;
  std::unique_ptr<libtextclassifier3::PodNerModelT> pod_ner_model;
  std::unique_ptr<libtextclassifier3::VocabModelT> vocab_model;
  std::unique_ptr<libtextclassifier3::GrammarModelT> datetime_grammar_model;
  ModelT()
      : version(0),
        enabled_modes(libtextclassifier3::ModeFlag_ALL),
        snap_whitespace_selections(true) {
  }
};

struct Model FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModelT NativeTableType;
  typedef ModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOCALES = 4,
    VT_VERSION = 6,
    VT_NAME = 8,
    VT_SELECTION_FEATURE_OPTIONS = 10,
    VT_CLASSIFICATION_FEATURE_OPTIONS = 12,
    VT_SELECTION_MODEL = 14,
    VT_CLASSIFICATION_MODEL = 16,
    VT_EMBEDDING_MODEL = 18,
    VT_SELECTION_OPTIONS = 20,
    VT_CLASSIFICATION_OPTIONS = 22,
    VT_REGEX_MODEL = 24,
    VT_DATETIME_MODEL = 26,
    VT_TRIGGERING_OPTIONS = 28,
    VT_ENABLED_MODES = 30,
    VT_SNAP_WHITESPACE_SELECTIONS = 32,
    VT_OUTPUT_OPTIONS = 34,
    VT_ANDROID_INTENT_OPTIONS = 36,
    VT_INTENT_OPTIONS = 38,
    VT_RESOURCES = 40,
    VT_ENTITY_DATA_SCHEMA = 42,
    VT_NUMBER_ANNOTATOR_OPTIONS = 44,
    VT_DURATION_ANNOTATOR_OPTIONS = 46,
    VT_TRIGGERING_LOCALES = 48,
    VT_EMBEDDING_PRUNING_MASK = 50,
    VT_CONTACT_ANNOTATOR_OPTIONS = 54,
    VT_MONEY_PARSING_OPTIONS = 56,
    VT_TRANSLATE_ANNOTATOR_OPTIONS = 58,
    VT_GRAMMAR_MODEL = 60,
    VT_CONFLICT_RESOLUTION_OPTIONS = 62,
    VT_EXPERIMENTAL_MODEL = 64,
    VT_POD_NER_MODEL = 66,
    VT_VOCAB_MODEL = 68,
    VT_DATETIME_GRAMMAR_MODEL = 70
  };
  const flatbuffers::String *locales() const {
    return GetPointer<const flatbuffers::String *>(VT_LOCALES);
  }
  int32_t version() const {
    return GetField<int32_t>(VT_VERSION, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const libtextclassifier3::FeatureProcessorOptions *selection_feature_options() const {
    return GetPointer<const libtextclassifier3::FeatureProcessorOptions *>(VT_SELECTION_FEATURE_OPTIONS);
  }
  const libtextclassifier3::FeatureProcessorOptions *classification_feature_options() const {
    return GetPointer<const libtextclassifier3::FeatureProcessorOptions *>(VT_CLASSIFICATION_FEATURE_OPTIONS);
  }
  const flatbuffers::Vector<uint8_t> *selection_model() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SELECTION_MODEL);
  }
  const flatbuffers::Vector<uint8_t> *classification_model() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CLASSIFICATION_MODEL);
  }
  const flatbuffers::Vector<uint8_t> *embedding_model() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_EMBEDDING_MODEL);
  }
  const libtextclassifier3::SelectionModelOptions *selection_options() const {
    return GetPointer<const libtextclassifier3::SelectionModelOptions *>(VT_SELECTION_OPTIONS);
  }
  const libtextclassifier3::ClassificationModelOptions *classification_options() const {
    return GetPointer<const libtextclassifier3::ClassificationModelOptions *>(VT_CLASSIFICATION_OPTIONS);
  }
  const libtextclassifier3::RegexModel *regex_model() const {
    return GetPointer<const libtextclassifier3::RegexModel *>(VT_REGEX_MODEL);
  }
  const libtextclassifier3::DatetimeModel *datetime_model() const {
    return GetPointer<const libtextclassifier3::DatetimeModel *>(VT_DATETIME_MODEL);
  }
  const libtextclassifier3::ModelTriggeringOptions *triggering_options() const {
    return GetPointer<const libtextclassifier3::ModelTriggeringOptions *>(VT_TRIGGERING_OPTIONS);
  }
  libtextclassifier3::ModeFlag enabled_modes() const {
    return static_cast<libtextclassifier3::ModeFlag>(GetField<int32_t>(VT_ENABLED_MODES, 7));
  }
  bool snap_whitespace_selections() const {
    return GetField<uint8_t>(VT_SNAP_WHITESPACE_SELECTIONS, 1) != 0;
  }
  const libtextclassifier3::OutputOptions *output_options() const {
    return GetPointer<const libtextclassifier3::OutputOptions *>(VT_OUTPUT_OPTIONS);
  }
  const libtextclassifier3::AndroidIntentFactoryOptions *android_intent_options() const {
    return GetPointer<const libtextclassifier3::AndroidIntentFactoryOptions *>(VT_ANDROID_INTENT_OPTIONS);
  }
  const libtextclassifier3::IntentFactoryModel *intent_options() const {
    return GetPointer<const libtextclassifier3::IntentFactoryModel *>(VT_INTENT_OPTIONS);
  }
  const libtextclassifier3::ResourcePool *resources() const {
    return GetPointer<const libtextclassifier3::ResourcePool *>(VT_RESOURCES);
  }
  const flatbuffers::Vector<uint8_t> *entity_data_schema() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ENTITY_DATA_SCHEMA);
  }
  const libtextclassifier3::NumberAnnotatorOptions *number_annotator_options() const {
    return GetPointer<const libtextclassifier3::NumberAnnotatorOptions *>(VT_NUMBER_ANNOTATOR_OPTIONS);
  }
  const libtextclassifier3::DurationAnnotatorOptions *duration_annotator_options() const {
    return GetPointer<const libtextclassifier3::DurationAnnotatorOptions *>(VT_DURATION_ANNOTATOR_OPTIONS);
  }
  const flatbuffers::String *triggering_locales() const {
    return GetPointer<const flatbuffers::String *>(VT_TRIGGERING_LOCALES);
  }
  const libtextclassifier3::Model_::EmbeddingPruningMask *embedding_pruning_mask() const {
    return GetPointer<const libtextclassifier3::Model_::EmbeddingPruningMask *>(VT_EMBEDDING_PRUNING_MASK);
  }
  const libtextclassifier3::ContactAnnotatorOptions *contact_annotator_options() const {
    return GetPointer<const libtextclassifier3::ContactAnnotatorOptions *>(VT_CONTACT_ANNOTATOR_OPTIONS);
  }
  const libtextclassifier3::MoneyParsingOptions *money_parsing_options() const {
    return GetPointer<const libtextclassifier3::MoneyParsingOptions *>(VT_MONEY_PARSING_OPTIONS);
  }
  const libtextclassifier3::TranslateAnnotatorOptions *translate_annotator_options() const {
    return GetPointer<const libtextclassifier3::TranslateAnnotatorOptions *>(VT_TRANSLATE_ANNOTATOR_OPTIONS);
  }
  const libtextclassifier3::GrammarModel *grammar_model() const {
    return GetPointer<const libtextclassifier3::GrammarModel *>(VT_GRAMMAR_MODEL);
  }
  const libtextclassifier3::Model_::ConflictResolutionOptions *conflict_resolution_options() const {
    return GetPointer<const libtextclassifier3::Model_::ConflictResolutionOptions *>(VT_CONFLICT_RESOLUTION_OPTIONS);
  }
  const libtextclassifier3::ExperimentalModel *experimental_model() const {
    return GetPointer<const libtextclassifier3::ExperimentalModel *>(VT_EXPERIMENTAL_MODEL);
  }
  const libtextclassifier3::PodNerModel *pod_ner_model() const {
    return GetPointer<const libtextclassifier3::PodNerModel *>(VT_POD_NER_MODEL);
  }
  const libtextclassifier3::VocabModel *vocab_model() const {
    return GetPointer<const libtextclassifier3::VocabModel *>(VT_VOCAB_MODEL);
  }
  const libtextclassifier3::GrammarModel *datetime_grammar_model() const {
    return GetPointer<const libtextclassifier3::GrammarModel *>(VT_DATETIME_GRAMMAR_MODEL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOCALES) &&
           verifier.VerifyString(locales()) &&
           VerifyField<int32_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SELECTION_FEATURE_OPTIONS) &&
           verifier.VerifyTable(selection_feature_options()) &&
           VerifyOffset(verifier, VT_CLASSIFICATION_FEATURE_OPTIONS) &&
           verifier.VerifyTable(classification_feature_options()) &&
           VerifyOffset(verifier, VT_SELECTION_MODEL) &&
           verifier.VerifyVector(selection_model()) &&
           VerifyOffset(verifier, VT_CLASSIFICATION_MODEL) &&
           verifier.VerifyVector(classification_model()) &&
           VerifyOffset(verifier, VT_EMBEDDING_MODEL) &&
           verifier.VerifyVector(embedding_model()) &&
           VerifyOffset(verifier, VT_SELECTION_OPTIONS) &&
           verifier.VerifyTable(selection_options()) &&
           VerifyOffset(verifier, VT_CLASSIFICATION_OPTIONS) &&
           verifier.VerifyTable(classification_options()) &&
           VerifyOffset(verifier, VT_REGEX_MODEL) &&
           verifier.VerifyTable(regex_model()) &&
           VerifyOffset(verifier, VT_DATETIME_MODEL) &&
           verifier.VerifyTable(datetime_model()) &&
           VerifyOffset(verifier, VT_TRIGGERING_OPTIONS) &&
           verifier.VerifyTable(triggering_options()) &&
           VerifyField<int32_t>(verifier, VT_ENABLED_MODES) &&
           VerifyField<uint8_t>(verifier, VT_SNAP_WHITESPACE_SELECTIONS) &&
           VerifyOffset(verifier, VT_OUTPUT_OPTIONS) &&
           verifier.VerifyTable(output_options()) &&
           VerifyOffset(verifier, VT_ANDROID_INTENT_OPTIONS) &&
           verifier.VerifyTable(android_intent_options()) &&
           VerifyOffset(verifier, VT_INTENT_OPTIONS) &&
           verifier.VerifyTable(intent_options()) &&
           VerifyOffset(verifier, VT_RESOURCES) &&
           verifier.VerifyTable(resources()) &&
           VerifyOffset(verifier, VT_ENTITY_DATA_SCHEMA) &&
           verifier.VerifyVector(entity_data_schema()) &&
           VerifyOffset(verifier, VT_NUMBER_ANNOTATOR_OPTIONS) &&
           verifier.VerifyTable(number_annotator_options()) &&
           VerifyOffset(verifier, VT_DURATION_ANNOTATOR_OPTIONS) &&
           verifier.VerifyTable(duration_annotator_options()) &&
           VerifyOffset(verifier, VT_TRIGGERING_LOCALES) &&
           verifier.VerifyString(triggering_locales()) &&
           VerifyOffset(verifier, VT_EMBEDDING_PRUNING_MASK) &&
           verifier.VerifyTable(embedding_pruning_mask()) &&
           VerifyOffset(verifier, VT_CONTACT_ANNOTATOR_OPTIONS) &&
           verifier.VerifyTable(contact_annotator_options()) &&
           VerifyOffset(verifier, VT_MONEY_PARSING_OPTIONS) &&
           verifier.VerifyTable(money_parsing_options()) &&
           VerifyOffset(verifier, VT_TRANSLATE_ANNOTATOR_OPTIONS) &&
           verifier.VerifyTable(translate_annotator_options()) &&
           VerifyOffset(verifier, VT_GRAMMAR_MODEL) &&
           verifier.VerifyTable(grammar_model()) &&
           VerifyOffset(verifier, VT_CONFLICT_RESOLUTION_OPTIONS) &&
           verifier.VerifyTable(conflict_resolution_options()) &&
           VerifyOffset(verifier, VT_EXPERIMENTAL_MODEL) &&
           verifier.VerifyTable(experimental_model()) &&
           VerifyOffset(verifier, VT_POD_NER_MODEL) &&
           verifier.VerifyTable(pod_ner_model()) &&
           VerifyOffset(verifier, VT_VOCAB_MODEL) &&
           verifier.VerifyTable(vocab_model()) &&
           VerifyOffset(verifier, VT_DATETIME_GRAMMAR_MODEL) &&
           verifier.VerifyTable(datetime_grammar_model()) &&
           verifier.EndTable();
  }
  ModelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ModelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Model> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ModelBuilder {
  typedef Model Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_locales(flatbuffers::Offset<flatbuffers::String> locales) {
    fbb_.AddOffset(Model::VT_LOCALES, locales);
  }
  void add_version(int32_t version) {
    fbb_.AddElement<int32_t>(Model::VT_VERSION, version, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Model::VT_NAME, name);
  }
  void add_selection_feature_options(flatbuffers::Offset<libtextclassifier3::FeatureProcessorOptions> selection_feature_options) {
    fbb_.AddOffset(Model::VT_SELECTION_FEATURE_OPTIONS, selection_feature_options);
  }
  void add_classification_feature_options(flatbuffers::Offset<libtextclassifier3::FeatureProcessorOptions> classification_feature_options) {
    fbb_.AddOffset(Model::VT_CLASSIFICATION_FEATURE_OPTIONS, classification_feature_options);
  }
  void add_selection_model(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> selection_model) {
    fbb_.AddOffset(Model::VT_SELECTION_MODEL, selection_model);
  }
  void add_classification_model(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> classification_model) {
    fbb_.AddOffset(Model::VT_CLASSIFICATION_MODEL, classification_model);
  }
  void add_embedding_model(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> embedding_model) {
    fbb_.AddOffset(Model::VT_EMBEDDING_MODEL, embedding_model);
  }
  void add_selection_options(flatbuffers::Offset<libtextclassifier3::SelectionModelOptions> selection_options) {
    fbb_.AddOffset(Model::VT_SELECTION_OPTIONS, selection_options);
  }
  void add_classification_options(flatbuffers::Offset<libtextclassifier3::ClassificationModelOptions> classification_options) {
    fbb_.AddOffset(Model::VT_CLASSIFICATION_OPTIONS, classification_options);
  }
  void add_regex_model(flatbuffers::Offset<libtextclassifier3::RegexModel> regex_model) {
    fbb_.AddOffset(Model::VT_REGEX_MODEL, regex_model);
  }
  void add_datetime_model(flatbuffers::Offset<libtextclassifier3::DatetimeModel> datetime_model) {
    fbb_.AddOffset(Model::VT_DATETIME_MODEL, datetime_model);
  }
  void add_triggering_options(flatbuffers::Offset<libtextclassifier3::ModelTriggeringOptions> triggering_options) {
    fbb_.AddOffset(Model::VT_TRIGGERING_OPTIONS, triggering_options);
  }
  void add_enabled_modes(libtextclassifier3::ModeFlag enabled_modes) {
    fbb_.AddElement<int32_t>(Model::VT_ENABLED_MODES, static_cast<int32_t>(enabled_modes), 7);
  }
  void add_snap_whitespace_selections(bool snap_whitespace_selections) {
    fbb_.AddElement<uint8_t>(Model::VT_SNAP_WHITESPACE_SELECTIONS, static_cast<uint8_t>(snap_whitespace_selections), 1);
  }
  void add_output_options(flatbuffers::Offset<libtextclassifier3::OutputOptions> output_options) {
    fbb_.AddOffset(Model::VT_OUTPUT_OPTIONS, output_options);
  }
  void add_android_intent_options(flatbuffers::Offset<libtextclassifier3::AndroidIntentFactoryOptions> android_intent_options) {
    fbb_.AddOffset(Model::VT_ANDROID_INTENT_OPTIONS, android_intent_options);
  }
  void add_intent_options(flatbuffers::Offset<libtextclassifier3::IntentFactoryModel> intent_options) {
    fbb_.AddOffset(Model::VT_INTENT_OPTIONS, intent_options);
  }
  void add_resources(flatbuffers::Offset<libtextclassifier3::ResourcePool> resources) {
    fbb_.AddOffset(Model::VT_RESOURCES, resources);
  }
  void add_entity_data_schema(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> entity_data_schema) {
    fbb_.AddOffset(Model::VT_ENTITY_DATA_SCHEMA, entity_data_schema);
  }
  void add_number_annotator_options(flatbuffers::Offset<libtextclassifier3::NumberAnnotatorOptions> number_annotator_options) {
    fbb_.AddOffset(Model::VT_NUMBER_ANNOTATOR_OPTIONS, number_annotator_options);
  }
  void add_duration_annotator_options(flatbuffers::Offset<libtextclassifier3::DurationAnnotatorOptions> duration_annotator_options) {
    fbb_.AddOffset(Model::VT_DURATION_ANNOTATOR_OPTIONS, duration_annotator_options);
  }
  void add_triggering_locales(flatbuffers::Offset<flatbuffers::String> triggering_locales) {
    fbb_.AddOffset(Model::VT_TRIGGERING_LOCALES, triggering_locales);
  }
  void add_embedding_pruning_mask(flatbuffers::Offset<libtextclassifier3::Model_::EmbeddingPruningMask> embedding_pruning_mask) {
    fbb_.AddOffset(Model::VT_EMBEDDING_PRUNING_MASK, embedding_pruning_mask);
  }
  void add_contact_annotator_options(flatbuffers::Offset<libtextclassifier3::ContactAnnotatorOptions> contact_annotator_options) {
    fbb_.AddOffset(Model::VT_CONTACT_ANNOTATOR_OPTIONS, contact_annotator_options);
  }
  void add_money_parsing_options(flatbuffers::Offset<libtextclassifier3::MoneyParsingOptions> money_parsing_options) {
    fbb_.AddOffset(Model::VT_MONEY_PARSING_OPTIONS, money_parsing_options);
  }
  void add_translate_annotator_options(flatbuffers::Offset<libtextclassifier3::TranslateAnnotatorOptions> translate_annotator_options) {
    fbb_.AddOffset(Model::VT_TRANSLATE_ANNOTATOR_OPTIONS, translate_annotator_options);
  }
  void add_grammar_model(flatbuffers::Offset<libtextclassifier3::GrammarModel> grammar_model) {
    fbb_.AddOffset(Model::VT_GRAMMAR_MODEL, grammar_model);
  }
  void add_conflict_resolution_options(flatbuffers::Offset<libtextclassifier3::Model_::ConflictResolutionOptions> conflict_resolution_options) {
    fbb_.AddOffset(Model::VT_CONFLICT_RESOLUTION_OPTIONS, conflict_resolution_options);
  }
  void add_experimental_model(flatbuffers::Offset<libtextclassifier3::ExperimentalModel> experimental_model) {
    fbb_.AddOffset(Model::VT_EXPERIMENTAL_MODEL, experimental_model);
  }
  void add_pod_ner_model(flatbuffers::Offset<libtextclassifier3::PodNerModel> pod_ner_model) {
    fbb_.AddOffset(Model::VT_POD_NER_MODEL, pod_ner_model);
  }
  void add_vocab_model(flatbuffers::Offset<libtextclassifier3::VocabModel> vocab_model) {
    fbb_.AddOffset(Model::VT_VOCAB_MODEL, vocab_model);
  }
  void add_datetime_grammar_model(flatbuffers::Offset<libtextclassifier3::GrammarModel> datetime_grammar_model) {
    fbb_.AddOffset(Model::VT_DATETIME_GRAMMAR_MODEL, datetime_grammar_model);
  }
  explicit ModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModelBuilder &operator=(const ModelBuilder &);
  flatbuffers::Offset<Model> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Model>(end);
    return o;
  }
};

inline flatbuffers::Offset<Model> CreateModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> locales = 0,
    int32_t version = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<libtextclassifier3::FeatureProcessorOptions> selection_feature_options = 0,
    flatbuffers::Offset<libtextclassifier3::FeatureProcessorOptions> classification_feature_options = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> selection_model = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> classification_model = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> embedding_model = 0,
    flatbuffers::Offset<libtextclassifier3::SelectionModelOptions> selection_options = 0,
    flatbuffers::Offset<libtextclassifier3::ClassificationModelOptions> classification_options = 0,
    flatbuffers::Offset<libtextclassifier3::RegexModel> regex_model = 0,
    flatbuffers::Offset<libtextclassifier3::DatetimeModel> datetime_model = 0,
    flatbuffers::Offset<libtextclassifier3::ModelTriggeringOptions> triggering_options = 0,
    libtextclassifier3::ModeFlag enabled_modes = libtextclassifier3::ModeFlag_ALL,
    bool snap_whitespace_selections = true,
    flatbuffers::Offset<libtextclassifier3::OutputOptions> output_options = 0,
    flatbuffers::Offset<libtextclassifier3::AndroidIntentFactoryOptions> android_intent_options = 0,
    flatbuffers::Offset<libtextclassifier3::IntentFactoryModel> intent_options = 0,
    flatbuffers::Offset<libtextclassifier3::ResourcePool> resources = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> entity_data_schema = 0,
    flatbuffers::Offset<libtextclassifier3::NumberAnnotatorOptions> number_annotator_options = 0,
    flatbuffers::Offset<libtextclassifier3::DurationAnnotatorOptions> duration_annotator_options = 0,
    flatbuffers::Offset<flatbuffers::String> triggering_locales = 0,
    flatbuffers::Offset<libtextclassifier3::Model_::EmbeddingPruningMask> embedding_pruning_mask = 0,
    flatbuffers::Offset<libtextclassifier3::ContactAnnotatorOptions> contact_annotator_options = 0,
    flatbuffers::Offset<libtextclassifier3::MoneyParsingOptions> money_parsing_options = 0,
    flatbuffers::Offset<libtextclassifier3::TranslateAnnotatorOptions> translate_annotator_options = 0,
    flatbuffers::Offset<libtextclassifier3::GrammarModel> grammar_model = 0,
    flatbuffers::Offset<libtextclassifier3::Model_::ConflictResolutionOptions> conflict_resolution_options = 0,
    flatbuffers::Offset<libtextclassifier3::ExperimentalModel> experimental_model = 0,
    flatbuffers::Offset<libtextclassifier3::PodNerModel> pod_ner_model = 0,
    flatbuffers::Offset<libtextclassifier3::VocabModel> vocab_model = 0,
    flatbuffers::Offset<libtextclassifier3::GrammarModel> datetime_grammar_model = 0) {
  ModelBuilder builder_(_fbb);
  builder_.add_datetime_grammar_model(datetime_grammar_model);
  builder_.add_vocab_model(vocab_model);
  builder_.add_pod_ner_model(pod_ner_model);
  builder_.add_experimental_model(experimental_model);
  builder_.add_conflict_resolution_options(conflict_resolution_options);
  builder_.add_grammar_model(grammar_model);
  builder_.add_translate_annotator_options(translate_annotator_options);
  builder_.add_money_parsing_options(money_parsing_options);
  builder_.add_contact_annotator_options(contact_annotator_options);
  builder_.add_embedding_pruning_mask(embedding_pruning_mask);
  builder_.add_triggering_locales(triggering_locales);
  builder_.add_duration_annotator_options(duration_annotator_options);
  builder_.add_number_annotator_options(number_annotator_options);
  builder_.add_entity_data_schema(entity_data_schema);
  builder_.add_resources(resources);
  builder_.add_intent_options(intent_options);
  builder_.add_android_intent_options(android_intent_options);
  builder_.add_output_options(output_options);
  builder_.add_enabled_modes(enabled_modes);
  builder_.add_triggering_options(triggering_options);
  builder_.add_datetime_model(datetime_model);
  builder_.add_regex_model(regex_model);
  builder_.add_classification_options(classification_options);
  builder_.add_selection_options(selection_options);
  builder_.add_embedding_model(embedding_model);
  builder_.add_classification_model(classification_model);
  builder_.add_selection_model(selection_model);
  builder_.add_classification_feature_options(classification_feature_options);
  builder_.add_selection_feature_options(selection_feature_options);
  builder_.add_name(name);
  builder_.add_version(version);
  builder_.add_locales(locales);
  builder_.add_snap_whitespace_selections(snap_whitespace_selections);
  return builder_.Finish();
}

inline flatbuffers::Offset<Model> CreateModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *locales = nullptr,
    int32_t version = 0,
    const char *name = nullptr,
    flatbuffers::Offset<libtextclassifier3::FeatureProcessorOptions> selection_feature_options = 0,
    flatbuffers::Offset<libtextclassifier3::FeatureProcessorOptions> classification_feature_options = 0,
    const std::vector<uint8_t> *selection_model = nullptr,
    const std::vector<uint8_t> *classification_model = nullptr,
    const std::vector<uint8_t> *embedding_model = nullptr,
    flatbuffers::Offset<libtextclassifier3::SelectionModelOptions> selection_options = 0,
    flatbuffers::Offset<libtextclassifier3::ClassificationModelOptions> classification_options = 0,
    flatbuffers::Offset<libtextclassifier3::RegexModel> regex_model = 0,
    flatbuffers::Offset<libtextclassifier3::DatetimeModel> datetime_model = 0,
    flatbuffers::Offset<libtextclassifier3::ModelTriggeringOptions> triggering_options = 0,
    libtextclassifier3::ModeFlag enabled_modes = libtextclassifier3::ModeFlag_ALL,
    bool snap_whitespace_selections = true,
    flatbuffers::Offset<libtextclassifier3::OutputOptions> output_options = 0,
    flatbuffers::Offset<libtextclassifier3::AndroidIntentFactoryOptions> android_intent_options = 0,
    flatbuffers::Offset<libtextclassifier3::IntentFactoryModel> intent_options = 0,
    flatbuffers::Offset<libtextclassifier3::ResourcePool> resources = 0,
    const std::vector<uint8_t> *entity_data_schema = nullptr,
    flatbuffers::Offset<libtextclassifier3::NumberAnnotatorOptions> number_annotator_options = 0,
    flatbuffers::Offset<libtextclassifier3::DurationAnnotatorOptions> duration_annotator_options = 0,
    const char *triggering_locales = nullptr,
    flatbuffers::Offset<libtextclassifier3::Model_::EmbeddingPruningMask> embedding_pruning_mask = 0,
    flatbuffers::Offset<libtextclassifier3::ContactAnnotatorOptions> contact_annotator_options = 0,
    flatbuffers::Offset<libtextclassifier3::MoneyParsingOptions> money_parsing_options = 0,
    flatbuffers::Offset<libtextclassifier3::TranslateAnnotatorOptions> translate_annotator_options = 0,
    flatbuffers::Offset<libtextclassifier3::GrammarModel> grammar_model = 0,
    flatbuffers::Offset<libtextclassifier3::Model_::ConflictResolutionOptions> conflict_resolution_options = 0,
    flatbuffers::Offset<libtextclassifier3::ExperimentalModel> experimental_model = 0,
    flatbuffers::Offset<libtextclassifier3::PodNerModel> pod_ner_model = 0,
    flatbuffers::Offset<libtextclassifier3::VocabModel> vocab_model = 0,
    flatbuffers::Offset<libtextclassifier3::GrammarModel> datetime_grammar_model = 0) {
  auto locales__ = locales ? _fbb.CreateSharedString(locales) : 0;
  auto name__ = name ? _fbb.CreateSharedString(name) : 0;
  if (selection_model) { _fbb.ForceVectorAlignment(selection_model->size(), sizeof(uint8_t), 16); }
  auto selection_model__ = selection_model ? _fbb.CreateVector<uint8_t>(*selection_model) : 0;
  if (classification_model) { _fbb.ForceVectorAlignment(classification_model->size(), sizeof(uint8_t), 16); }
  auto classification_model__ = classification_model ? _fbb.CreateVector<uint8_t>(*classification_model) : 0;
  if (embedding_model) { _fbb.ForceVectorAlignment(embedding_model->size(), sizeof(uint8_t), 16); }
  auto embedding_model__ = embedding_model ? _fbb.CreateVector<uint8_t>(*embedding_model) : 0;
  auto entity_data_schema__ = entity_data_schema ? _fbb.CreateVector<uint8_t>(*entity_data_schema) : 0;
  auto triggering_locales__ = triggering_locales ? _fbb.CreateSharedString(triggering_locales) : 0;
  return libtextclassifier3::CreateModel(
      _fbb,
      locales__,
      version,
      name__,
      selection_feature_options,
      classification_feature_options,
      selection_model__,
      classification_model__,
      embedding_model__,
      selection_options,
      classification_options,
      regex_model,
      datetime_model,
      triggering_options,
      enabled_modes,
      snap_whitespace_selections,
      output_options,
      android_intent_options,
      intent_options,
      resources,
      entity_data_schema__,
      number_annotator_options,
      duration_annotator_options,
      triggering_locales__,
      embedding_pruning_mask,
      contact_annotator_options,
      money_parsing_options,
      translate_annotator_options,
      grammar_model,
      conflict_resolution_options,
      experimental_model,
      pod_ner_model,
      vocab_model,
      datetime_grammar_model);
}

flatbuffers::Offset<Model> CreateModel(flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace FeatureProcessorOptions_ {

struct BoundsSensitiveFeaturesT : public flatbuffers::NativeTable {
  typedef BoundsSensitiveFeatures TableType;
  bool enabled;
  int32_t num_tokens_before;
  int32_t num_tokens_inside_left;
  int32_t num_tokens_inside_right;
  int32_t num_tokens_after;
  bool include_inside_bag;
  bool include_inside_length;
  bool score_single_token_spans_as_zero;
  BoundsSensitiveFeaturesT()
      : enabled(false),
        num_tokens_before(0),
        num_tokens_inside_left(0),
        num_tokens_inside_right(0),
        num_tokens_after(0),
        include_inside_bag(false),
        include_inside_length(false),
        score_single_token_spans_as_zero(false) {
  }
};

struct BoundsSensitiveFeatures FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BoundsSensitiveFeaturesT NativeTableType;
  typedef BoundsSensitiveFeaturesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLED = 4,
    VT_NUM_TOKENS_BEFORE = 6,
    VT_NUM_TOKENS_INSIDE_LEFT = 8,
    VT_NUM_TOKENS_INSIDE_RIGHT = 10,
    VT_NUM_TOKENS_AFTER = 12,
    VT_INCLUDE_INSIDE_BAG = 14,
    VT_INCLUDE_INSIDE_LENGTH = 16,
    VT_SCORE_SINGLE_TOKEN_SPANS_AS_ZERO = 18
  };
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 0) != 0;
  }
  int32_t num_tokens_before() const {
    return GetField<int32_t>(VT_NUM_TOKENS_BEFORE, 0);
  }
  int32_t num_tokens_inside_left() const {
    return GetField<int32_t>(VT_NUM_TOKENS_INSIDE_LEFT, 0);
  }
  int32_t num_tokens_inside_right() const {
    return GetField<int32_t>(VT_NUM_TOKENS_INSIDE_RIGHT, 0);
  }
  int32_t num_tokens_after() const {
    return GetField<int32_t>(VT_NUM_TOKENS_AFTER, 0);
  }
  bool include_inside_bag() const {
    return GetField<uint8_t>(VT_INCLUDE_INSIDE_BAG, 0) != 0;
  }
  bool include_inside_length() const {
    return GetField<uint8_t>(VT_INCLUDE_INSIDE_LENGTH, 0) != 0;
  }
  bool score_single_token_spans_as_zero() const {
    return GetField<uint8_t>(VT_SCORE_SINGLE_TOKEN_SPANS_AS_ZERO, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED) &&
           VerifyField<int32_t>(verifier, VT_NUM_TOKENS_BEFORE) &&
           VerifyField<int32_t>(verifier, VT_NUM_TOKENS_INSIDE_LEFT) &&
           VerifyField<int32_t>(verifier, VT_NUM_TOKENS_INSIDE_RIGHT) &&
           VerifyField<int32_t>(verifier, VT_NUM_TOKENS_AFTER) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_INSIDE_BAG) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_INSIDE_LENGTH) &&
           VerifyField<uint8_t>(verifier, VT_SCORE_SINGLE_TOKEN_SPANS_AS_ZERO) &&
           verifier.EndTable();
  }
  BoundsSensitiveFeaturesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BoundsSensitiveFeaturesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BoundsSensitiveFeatures> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BoundsSensitiveFeaturesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BoundsSensitiveFeaturesBuilder {
  typedef BoundsSensitiveFeatures Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(BoundsSensitiveFeatures::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
  }
  void add_num_tokens_before(int32_t num_tokens_before) {
    fbb_.AddElement<int32_t>(BoundsSensitiveFeatures::VT_NUM_TOKENS_BEFORE, num_tokens_before, 0);
  }
  void add_num_tokens_inside_left(int32_t num_tokens_inside_left) {
    fbb_.AddElement<int32_t>(BoundsSensitiveFeatures::VT_NUM_TOKENS_INSIDE_LEFT, num_tokens_inside_left, 0);
  }
  void add_num_tokens_inside_right(int32_t num_tokens_inside_right) {
    fbb_.AddElement<int32_t>(BoundsSensitiveFeatures::VT_NUM_TOKENS_INSIDE_RIGHT, num_tokens_inside_right, 0);
  }
  void add_num_tokens_after(int32_t num_tokens_after) {
    fbb_.AddElement<int32_t>(BoundsSensitiveFeatures::VT_NUM_TOKENS_AFTER, num_tokens_after, 0);
  }
  void add_include_inside_bag(bool include_inside_bag) {
    fbb_.AddElement<uint8_t>(BoundsSensitiveFeatures::VT_INCLUDE_INSIDE_BAG, static_cast<uint8_t>(include_inside_bag), 0);
  }
  void add_include_inside_length(bool include_inside_length) {
    fbb_.AddElement<uint8_t>(BoundsSensitiveFeatures::VT_INCLUDE_INSIDE_LENGTH, static_cast<uint8_t>(include_inside_length), 0);
  }
  void add_score_single_token_spans_as_zero(bool score_single_token_spans_as_zero) {
    fbb_.AddElement<uint8_t>(BoundsSensitiveFeatures::VT_SCORE_SINGLE_TOKEN_SPANS_AS_ZERO, static_cast<uint8_t>(score_single_token_spans_as_zero), 0);
  }
  explicit BoundsSensitiveFeaturesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BoundsSensitiveFeaturesBuilder &operator=(const BoundsSensitiveFeaturesBuilder &);
  flatbuffers::Offset<BoundsSensitiveFeatures> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BoundsSensitiveFeatures>(end);
    return o;
  }
};

inline flatbuffers::Offset<BoundsSensitiveFeatures> CreateBoundsSensitiveFeatures(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enabled = false,
    int32_t num_tokens_before = 0,
    int32_t num_tokens_inside_left = 0,
    int32_t num_tokens_inside_right = 0,
    int32_t num_tokens_after = 0,
    bool include_inside_bag = false,
    bool include_inside_length = false,
    bool score_single_token_spans_as_zero = false) {
  BoundsSensitiveFeaturesBuilder builder_(_fbb);
  builder_.add_num_tokens_after(num_tokens_after);
  builder_.add_num_tokens_inside_right(num_tokens_inside_right);
  builder_.add_num_tokens_inside_left(num_tokens_inside_left);
  builder_.add_num_tokens_before(num_tokens_before);
  builder_.add_score_single_token_spans_as_zero(score_single_token_spans_as_zero);
  builder_.add_include_inside_length(include_inside_length);
  builder_.add_include_inside_bag(include_inside_bag);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

flatbuffers::Offset<BoundsSensitiveFeatures> CreateBoundsSensitiveFeatures(flatbuffers::FlatBufferBuilder &_fbb, const BoundsSensitiveFeaturesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace FeatureProcessorOptions_

struct FeatureProcessorOptionsT : public flatbuffers::NativeTable {
  typedef FeatureProcessorOptions TableType;
  int32_t num_buckets;
  int32_t embedding_size;
  int32_t embedding_quantization_bits;
  int32_t context_size;
  int32_t max_selection_span;
  std::vector<int32_t> chargram_orders;
  int32_t max_word_length;
  bool unicode_aware_features;
  bool extract_case_feature;
  bool extract_selection_mask_feature;
  std::vector<std::string> regexp_feature;
  bool remap_digits;
  bool lowercase_tokens;
  bool selection_reduced_output_space;
  std::vector<std::string> collections;
  int32_t default_collection;
  bool only_use_line_with_click;
  bool split_tokens_on_selection_boundaries;
  std::vector<std::unique_ptr<libtextclassifier3::TokenizationCodepointRangeT>> tokenization_codepoint_config;
  libtextclassifier3::FeatureProcessorOptions_::CenterTokenSelectionMethod center_token_selection_method;
  bool snap_label_span_boundaries_to_containing_tokens;
  std::vector<std::unique_ptr<libtextclassifier3::CodepointRangeT>> supported_codepoint_ranges;
  std::vector<std::unique_ptr<libtextclassifier3::CodepointRangeT>> internal_tokenizer_codepoint_ranges;
  float min_supported_codepoint_ratio;
  int32_t feature_version;
  libtextclassifier3::TokenizationType tokenization_type;
  bool icu_preserve_whitespace_tokens;
  std::vector<int32_t> ignored_span_boundary_codepoints;
  std::unique_ptr<libtextclassifier3::FeatureProcessorOptions_::BoundsSensitiveFeaturesT> bounds_sensitive_features;
  std::vector<std::string> allowed_chargrams;
  bool tokenize_on_script_change;
  bool use_pipe_character_for_newline;
  FeatureProcessorOptionsT()
      : num_buckets(-1),
        embedding_size(-1),
        embedding_quantization_bits(8),
        context_size(-1),
        max_selection_span(-1),
        max_word_length(20),
        unicode_aware_features(false),
        extract_case_feature(false),
        extract_selection_mask_feature(false),
        remap_digits(false),
        lowercase_tokens(false),
        selection_reduced_output_space(true),
        default_collection(-1),
        only_use_line_with_click(false),
        split_tokens_on_selection_boundaries(false),
        center_token_selection_method(libtextclassifier3::FeatureProcessorOptions_::CenterTokenSelectionMethod_DEFAULT_CENTER_TOKEN_METHOD),
        snap_label_span_boundaries_to_containing_tokens(false),
        min_supported_codepoint_ratio(0.0f),
        feature_version(0),
        tokenization_type(libtextclassifier3::TokenizationType_INTERNAL_TOKENIZER),
        icu_preserve_whitespace_tokens(false),
        tokenize_on_script_change(false),
        use_pipe_character_for_newline(true) {
  }
};

struct FeatureProcessorOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FeatureProcessorOptionsT NativeTableType;
  typedef FeatureProcessorOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_BUCKETS = 4,
    VT_EMBEDDING_SIZE = 6,
    VT_EMBEDDING_QUANTIZATION_BITS = 8,
    VT_CONTEXT_SIZE = 10,
    VT_MAX_SELECTION_SPAN = 12,
    VT_CHARGRAM_ORDERS = 14,
    VT_MAX_WORD_LENGTH = 16,
    VT_UNICODE_AWARE_FEATURES = 18,
    VT_EXTRACT_CASE_FEATURE = 20,
    VT_EXTRACT_SELECTION_MASK_FEATURE = 22,
    VT_REGEXP_FEATURE = 24,
    VT_REMAP_DIGITS = 26,
    VT_LOWERCASE_TOKENS = 28,
    VT_SELECTION_REDUCED_OUTPUT_SPACE = 30,
    VT_COLLECTIONS = 32,
    VT_DEFAULT_COLLECTION = 34,
    VT_ONLY_USE_LINE_WITH_CLICK = 36,
    VT_SPLIT_TOKENS_ON_SELECTION_BOUNDARIES = 38,
    VT_TOKENIZATION_CODEPOINT_CONFIG = 40,
    VT_CENTER_TOKEN_SELECTION_METHOD = 42,
    VT_SNAP_LABEL_SPAN_BOUNDARIES_TO_CONTAINING_TOKENS = 44,
    VT_SUPPORTED_CODEPOINT_RANGES = 46,
    VT_INTERNAL_TOKENIZER_CODEPOINT_RANGES = 48,
    VT_MIN_SUPPORTED_CODEPOINT_RATIO = 50,
    VT_FEATURE_VERSION = 52,
    VT_TOKENIZATION_TYPE = 54,
    VT_ICU_PRESERVE_WHITESPACE_TOKENS = 56,
    VT_IGNORED_SPAN_BOUNDARY_CODEPOINTS = 58,
    VT_BOUNDS_SENSITIVE_FEATURES = 60,
    VT_ALLOWED_CHARGRAMS = 62,
    VT_TOKENIZE_ON_SCRIPT_CHANGE = 64,
    VT_USE_PIPE_CHARACTER_FOR_NEWLINE = 66
  };
  int32_t num_buckets() const {
    return GetField<int32_t>(VT_NUM_BUCKETS, -1);
  }
  int32_t embedding_size() const {
    return GetField<int32_t>(VT_EMBEDDING_SIZE, -1);
  }
  int32_t embedding_quantization_bits() const {
    return GetField<int32_t>(VT_EMBEDDING_QUANTIZATION_BITS, 8);
  }
  int32_t context_size() const {
    return GetField<int32_t>(VT_CONTEXT_SIZE, -1);
  }
  int32_t max_selection_span() const {
    return GetField<int32_t>(VT_MAX_SELECTION_SPAN, -1);
  }
  const flatbuffers::Vector<int32_t> *chargram_orders() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CHARGRAM_ORDERS);
  }
  int32_t max_word_length() const {
    return GetField<int32_t>(VT_MAX_WORD_LENGTH, 20);
  }
  bool unicode_aware_features() const {
    return GetField<uint8_t>(VT_UNICODE_AWARE_FEATURES, 0) != 0;
  }
  bool extract_case_feature() const {
    return GetField<uint8_t>(VT_EXTRACT_CASE_FEATURE, 0) != 0;
  }
  bool extract_selection_mask_feature() const {
    return GetField<uint8_t>(VT_EXTRACT_SELECTION_MASK_FEATURE, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *regexp_feature() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_REGEXP_FEATURE);
  }
  bool remap_digits() const {
    return GetField<uint8_t>(VT_REMAP_DIGITS, 0) != 0;
  }
  bool lowercase_tokens() const {
    return GetField<uint8_t>(VT_LOWERCASE_TOKENS, 0) != 0;
  }
  bool selection_reduced_output_space() const {
    return GetField<uint8_t>(VT_SELECTION_REDUCED_OUTPUT_SPACE, 1) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *collections() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_COLLECTIONS);
  }
  int32_t default_collection() const {
    return GetField<int32_t>(VT_DEFAULT_COLLECTION, -1);
  }
  bool only_use_line_with_click() const {
    return GetField<uint8_t>(VT_ONLY_USE_LINE_WITH_CLICK, 0) != 0;
  }
  bool split_tokens_on_selection_boundaries() const {
    return GetField<uint8_t>(VT_SPLIT_TOKENS_ON_SELECTION_BOUNDARIES, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::TokenizationCodepointRange>> *tokenization_codepoint_config() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::TokenizationCodepointRange>> *>(VT_TOKENIZATION_CODEPOINT_CONFIG);
  }
  libtextclassifier3::FeatureProcessorOptions_::CenterTokenSelectionMethod center_token_selection_method() const {
    return static_cast<libtextclassifier3::FeatureProcessorOptions_::CenterTokenSelectionMethod>(GetField<int32_t>(VT_CENTER_TOKEN_SELECTION_METHOD, 0));
  }
  bool snap_label_span_boundaries_to_containing_tokens() const {
    return GetField<uint8_t>(VT_SNAP_LABEL_SPAN_BOUNDARIES_TO_CONTAINING_TOKENS, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::CodepointRange>> *supported_codepoint_ranges() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::CodepointRange>> *>(VT_SUPPORTED_CODEPOINT_RANGES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::CodepointRange>> *internal_tokenizer_codepoint_ranges() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::CodepointRange>> *>(VT_INTERNAL_TOKENIZER_CODEPOINT_RANGES);
  }
  float min_supported_codepoint_ratio() const {
    return GetField<float>(VT_MIN_SUPPORTED_CODEPOINT_RATIO, 0.0f);
  }
  int32_t feature_version() const {
    return GetField<int32_t>(VT_FEATURE_VERSION, 0);
  }
  libtextclassifier3::TokenizationType tokenization_type() const {
    return static_cast<libtextclassifier3::TokenizationType>(GetField<int32_t>(VT_TOKENIZATION_TYPE, 1));
  }
  bool icu_preserve_whitespace_tokens() const {
    return GetField<uint8_t>(VT_ICU_PRESERVE_WHITESPACE_TOKENS, 0) != 0;
  }
  const flatbuffers::Vector<int32_t> *ignored_span_boundary_codepoints() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_IGNORED_SPAN_BOUNDARY_CODEPOINTS);
  }
  const libtextclassifier3::FeatureProcessorOptions_::BoundsSensitiveFeatures *bounds_sensitive_features() const {
    return GetPointer<const libtextclassifier3::FeatureProcessorOptions_::BoundsSensitiveFeatures *>(VT_BOUNDS_SENSITIVE_FEATURES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *allowed_chargrams() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ALLOWED_CHARGRAMS);
  }
  bool tokenize_on_script_change() const {
    return GetField<uint8_t>(VT_TOKENIZE_ON_SCRIPT_CHANGE, 0) != 0;
  }
  bool use_pipe_character_for_newline() const {
    return GetField<uint8_t>(VT_USE_PIPE_CHARACTER_FOR_NEWLINE, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_BUCKETS) &&
           VerifyField<int32_t>(verifier, VT_EMBEDDING_SIZE) &&
           VerifyField<int32_t>(verifier, VT_EMBEDDING_QUANTIZATION_BITS) &&
           VerifyField<int32_t>(verifier, VT_CONTEXT_SIZE) &&
           VerifyField<int32_t>(verifier, VT_MAX_SELECTION_SPAN) &&
           VerifyOffset(verifier, VT_CHARGRAM_ORDERS) &&
           verifier.VerifyVector(chargram_orders()) &&
           VerifyField<int32_t>(verifier, VT_MAX_WORD_LENGTH) &&
           VerifyField<uint8_t>(verifier, VT_UNICODE_AWARE_FEATURES) &&
           VerifyField<uint8_t>(verifier, VT_EXTRACT_CASE_FEATURE) &&
           VerifyField<uint8_t>(verifier, VT_EXTRACT_SELECTION_MASK_FEATURE) &&
           VerifyOffset(verifier, VT_REGEXP_FEATURE) &&
           verifier.VerifyVector(regexp_feature()) &&
           verifier.VerifyVectorOfStrings(regexp_feature()) &&
           VerifyField<uint8_t>(verifier, VT_REMAP_DIGITS) &&
           VerifyField<uint8_t>(verifier, VT_LOWERCASE_TOKENS) &&
           VerifyField<uint8_t>(verifier, VT_SELECTION_REDUCED_OUTPUT_SPACE) &&
           VerifyOffset(verifier, VT_COLLECTIONS) &&
           verifier.VerifyVector(collections()) &&
           verifier.VerifyVectorOfStrings(collections()) &&
           VerifyField<int32_t>(verifier, VT_DEFAULT_COLLECTION) &&
           VerifyField<uint8_t>(verifier, VT_ONLY_USE_LINE_WITH_CLICK) &&
           VerifyField<uint8_t>(verifier, VT_SPLIT_TOKENS_ON_SELECTION_BOUNDARIES) &&
           VerifyOffset(verifier, VT_TOKENIZATION_CODEPOINT_CONFIG) &&
           verifier.VerifyVector(tokenization_codepoint_config()) &&
           verifier.VerifyVectorOfTables(tokenization_codepoint_config()) &&
           VerifyField<int32_t>(verifier, VT_CENTER_TOKEN_SELECTION_METHOD) &&
           VerifyField<uint8_t>(verifier, VT_SNAP_LABEL_SPAN_BOUNDARIES_TO_CONTAINING_TOKENS) &&
           VerifyOffset(verifier, VT_SUPPORTED_CODEPOINT_RANGES) &&
           verifier.VerifyVector(supported_codepoint_ranges()) &&
           verifier.VerifyVectorOfTables(supported_codepoint_ranges()) &&
           VerifyOffset(verifier, VT_INTERNAL_TOKENIZER_CODEPOINT_RANGES) &&
           verifier.VerifyVector(internal_tokenizer_codepoint_ranges()) &&
           verifier.VerifyVectorOfTables(internal_tokenizer_codepoint_ranges()) &&
           VerifyField<float>(verifier, VT_MIN_SUPPORTED_CODEPOINT_RATIO) &&
           VerifyField<int32_t>(verifier, VT_FEATURE_VERSION) &&
           VerifyField<int32_t>(verifier, VT_TOKENIZATION_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_ICU_PRESERVE_WHITESPACE_TOKENS) &&
           VerifyOffset(verifier, VT_IGNORED_SPAN_BOUNDARY_CODEPOINTS) &&
           verifier.VerifyVector(ignored_span_boundary_codepoints()) &&
           VerifyOffset(verifier, VT_BOUNDS_SENSITIVE_FEATURES) &&
           verifier.VerifyTable(bounds_sensitive_features()) &&
           VerifyOffset(verifier, VT_ALLOWED_CHARGRAMS) &&
           verifier.VerifyVector(allowed_chargrams()) &&
           verifier.VerifyVectorOfStrings(allowed_chargrams()) &&
           VerifyField<uint8_t>(verifier, VT_TOKENIZE_ON_SCRIPT_CHANGE) &&
           VerifyField<uint8_t>(verifier, VT_USE_PIPE_CHARACTER_FOR_NEWLINE) &&
           verifier.EndTable();
  }
  FeatureProcessorOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FeatureProcessorOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FeatureProcessorOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FeatureProcessorOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FeatureProcessorOptionsBuilder {
  typedef FeatureProcessorOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_buckets(int32_t num_buckets) {
    fbb_.AddElement<int32_t>(FeatureProcessorOptions::VT_NUM_BUCKETS, num_buckets, -1);
  }
  void add_embedding_size(int32_t embedding_size) {
    fbb_.AddElement<int32_t>(FeatureProcessorOptions::VT_EMBEDDING_SIZE, embedding_size, -1);
  }
  void add_embedding_quantization_bits(int32_t embedding_quantization_bits) {
    fbb_.AddElement<int32_t>(FeatureProcessorOptions::VT_EMBEDDING_QUANTIZATION_BITS, embedding_quantization_bits, 8);
  }
  void add_context_size(int32_t context_size) {
    fbb_.AddElement<int32_t>(FeatureProcessorOptions::VT_CONTEXT_SIZE, context_size, -1);
  }
  void add_max_selection_span(int32_t max_selection_span) {
    fbb_.AddElement<int32_t>(FeatureProcessorOptions::VT_MAX_SELECTION_SPAN, max_selection_span, -1);
  }
  void add_chargram_orders(flatbuffers::Offset<flatbuffers::Vector<int32_t>> chargram_orders) {
    fbb_.AddOffset(FeatureProcessorOptions::VT_CHARGRAM_ORDERS, chargram_orders);
  }
  void add_max_word_length(int32_t max_word_length) {
    fbb_.AddElement<int32_t>(FeatureProcessorOptions::VT_MAX_WORD_LENGTH, max_word_length, 20);
  }
  void add_unicode_aware_features(bool unicode_aware_features) {
    fbb_.AddElement<uint8_t>(FeatureProcessorOptions::VT_UNICODE_AWARE_FEATURES, static_cast<uint8_t>(unicode_aware_features), 0);
  }
  void add_extract_case_feature(bool extract_case_feature) {
    fbb_.AddElement<uint8_t>(FeatureProcessorOptions::VT_EXTRACT_CASE_FEATURE, static_cast<uint8_t>(extract_case_feature), 0);
  }
  void add_extract_selection_mask_feature(bool extract_selection_mask_feature) {
    fbb_.AddElement<uint8_t>(FeatureProcessorOptions::VT_EXTRACT_SELECTION_MASK_FEATURE, static_cast<uint8_t>(extract_selection_mask_feature), 0);
  }
  void add_regexp_feature(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> regexp_feature) {
    fbb_.AddOffset(FeatureProcessorOptions::VT_REGEXP_FEATURE, regexp_feature);
  }
  void add_remap_digits(bool remap_digits) {
    fbb_.AddElement<uint8_t>(FeatureProcessorOptions::VT_REMAP_DIGITS, static_cast<uint8_t>(remap_digits), 0);
  }
  void add_lowercase_tokens(bool lowercase_tokens) {
    fbb_.AddElement<uint8_t>(FeatureProcessorOptions::VT_LOWERCASE_TOKENS, static_cast<uint8_t>(lowercase_tokens), 0);
  }
  void add_selection_reduced_output_space(bool selection_reduced_output_space) {
    fbb_.AddElement<uint8_t>(FeatureProcessorOptions::VT_SELECTION_REDUCED_OUTPUT_SPACE, static_cast<uint8_t>(selection_reduced_output_space), 1);
  }
  void add_collections(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> collections) {
    fbb_.AddOffset(FeatureProcessorOptions::VT_COLLECTIONS, collections);
  }
  void add_default_collection(int32_t default_collection) {
    fbb_.AddElement<int32_t>(FeatureProcessorOptions::VT_DEFAULT_COLLECTION, default_collection, -1);
  }
  void add_only_use_line_with_click(bool only_use_line_with_click) {
    fbb_.AddElement<uint8_t>(FeatureProcessorOptions::VT_ONLY_USE_LINE_WITH_CLICK, static_cast<uint8_t>(only_use_line_with_click), 0);
  }
  void add_split_tokens_on_selection_boundaries(bool split_tokens_on_selection_boundaries) {
    fbb_.AddElement<uint8_t>(FeatureProcessorOptions::VT_SPLIT_TOKENS_ON_SELECTION_BOUNDARIES, static_cast<uint8_t>(split_tokens_on_selection_boundaries), 0);
  }
  void add_tokenization_codepoint_config(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::TokenizationCodepointRange>>> tokenization_codepoint_config) {
    fbb_.AddOffset(FeatureProcessorOptions::VT_TOKENIZATION_CODEPOINT_CONFIG, tokenization_codepoint_config);
  }
  void add_center_token_selection_method(libtextclassifier3::FeatureProcessorOptions_::CenterTokenSelectionMethod center_token_selection_method) {
    fbb_.AddElement<int32_t>(FeatureProcessorOptions::VT_CENTER_TOKEN_SELECTION_METHOD, static_cast<int32_t>(center_token_selection_method), 0);
  }
  void add_snap_label_span_boundaries_to_containing_tokens(bool snap_label_span_boundaries_to_containing_tokens) {
    fbb_.AddElement<uint8_t>(FeatureProcessorOptions::VT_SNAP_LABEL_SPAN_BOUNDARIES_TO_CONTAINING_TOKENS, static_cast<uint8_t>(snap_label_span_boundaries_to_containing_tokens), 0);
  }
  void add_supported_codepoint_ranges(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::CodepointRange>>> supported_codepoint_ranges) {
    fbb_.AddOffset(FeatureProcessorOptions::VT_SUPPORTED_CODEPOINT_RANGES, supported_codepoint_ranges);
  }
  void add_internal_tokenizer_codepoint_ranges(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::CodepointRange>>> internal_tokenizer_codepoint_ranges) {
    fbb_.AddOffset(FeatureProcessorOptions::VT_INTERNAL_TOKENIZER_CODEPOINT_RANGES, internal_tokenizer_codepoint_ranges);
  }
  void add_min_supported_codepoint_ratio(float min_supported_codepoint_ratio) {
    fbb_.AddElement<float>(FeatureProcessorOptions::VT_MIN_SUPPORTED_CODEPOINT_RATIO, min_supported_codepoint_ratio, 0.0f);
  }
  void add_feature_version(int32_t feature_version) {
    fbb_.AddElement<int32_t>(FeatureProcessorOptions::VT_FEATURE_VERSION, feature_version, 0);
  }
  void add_tokenization_type(libtextclassifier3::TokenizationType tokenization_type) {
    fbb_.AddElement<int32_t>(FeatureProcessorOptions::VT_TOKENIZATION_TYPE, static_cast<int32_t>(tokenization_type), 1);
  }
  void add_icu_preserve_whitespace_tokens(bool icu_preserve_whitespace_tokens) {
    fbb_.AddElement<uint8_t>(FeatureProcessorOptions::VT_ICU_PRESERVE_WHITESPACE_TOKENS, static_cast<uint8_t>(icu_preserve_whitespace_tokens), 0);
  }
  void add_ignored_span_boundary_codepoints(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ignored_span_boundary_codepoints) {
    fbb_.AddOffset(FeatureProcessorOptions::VT_IGNORED_SPAN_BOUNDARY_CODEPOINTS, ignored_span_boundary_codepoints);
  }
  void add_bounds_sensitive_features(flatbuffers::Offset<libtextclassifier3::FeatureProcessorOptions_::BoundsSensitiveFeatures> bounds_sensitive_features) {
    fbb_.AddOffset(FeatureProcessorOptions::VT_BOUNDS_SENSITIVE_FEATURES, bounds_sensitive_features);
  }
  void add_allowed_chargrams(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> allowed_chargrams) {
    fbb_.AddOffset(FeatureProcessorOptions::VT_ALLOWED_CHARGRAMS, allowed_chargrams);
  }
  void add_tokenize_on_script_change(bool tokenize_on_script_change) {
    fbb_.AddElement<uint8_t>(FeatureProcessorOptions::VT_TOKENIZE_ON_SCRIPT_CHANGE, static_cast<uint8_t>(tokenize_on_script_change), 0);
  }
  void add_use_pipe_character_for_newline(bool use_pipe_character_for_newline) {
    fbb_.AddElement<uint8_t>(FeatureProcessorOptions::VT_USE_PIPE_CHARACTER_FOR_NEWLINE, static_cast<uint8_t>(use_pipe_character_for_newline), 1);
  }
  explicit FeatureProcessorOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FeatureProcessorOptionsBuilder &operator=(const FeatureProcessorOptionsBuilder &);
  flatbuffers::Offset<FeatureProcessorOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FeatureProcessorOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FeatureProcessorOptions> CreateFeatureProcessorOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_buckets = -1,
    int32_t embedding_size = -1,
    int32_t embedding_quantization_bits = 8,
    int32_t context_size = -1,
    int32_t max_selection_span = -1,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> chargram_orders = 0,
    int32_t max_word_length = 20,
    bool unicode_aware_features = false,
    bool extract_case_feature = false,
    bool extract_selection_mask_feature = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> regexp_feature = 0,
    bool remap_digits = false,
    bool lowercase_tokens = false,
    bool selection_reduced_output_space = true,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> collections = 0,
    int32_t default_collection = -1,
    bool only_use_line_with_click = false,
    bool split_tokens_on_selection_boundaries = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::TokenizationCodepointRange>>> tokenization_codepoint_config = 0,
    libtextclassifier3::FeatureProcessorOptions_::CenterTokenSelectionMethod center_token_selection_method = libtextclassifier3::FeatureProcessorOptions_::CenterTokenSelectionMethod_DEFAULT_CENTER_TOKEN_METHOD,
    bool snap_label_span_boundaries_to_containing_tokens = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::CodepointRange>>> supported_codepoint_ranges = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::CodepointRange>>> internal_tokenizer_codepoint_ranges = 0,
    float min_supported_codepoint_ratio = 0.0f,
    int32_t feature_version = 0,
    libtextclassifier3::TokenizationType tokenization_type = libtextclassifier3::TokenizationType_INTERNAL_TOKENIZER,
    bool icu_preserve_whitespace_tokens = false,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ignored_span_boundary_codepoints = 0,
    flatbuffers::Offset<libtextclassifier3::FeatureProcessorOptions_::BoundsSensitiveFeatures> bounds_sensitive_features = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> allowed_chargrams = 0,
    bool tokenize_on_script_change = false,
    bool use_pipe_character_for_newline = true) {
  FeatureProcessorOptionsBuilder builder_(_fbb);
  builder_.add_allowed_chargrams(allowed_chargrams);
  builder_.add_bounds_sensitive_features(bounds_sensitive_features);
  builder_.add_ignored_span_boundary_codepoints(ignored_span_boundary_codepoints);
  builder_.add_tokenization_type(tokenization_type);
  builder_.add_feature_version(feature_version);
  builder_.add_min_supported_codepoint_ratio(min_supported_codepoint_ratio);
  builder_.add_internal_tokenizer_codepoint_ranges(internal_tokenizer_codepoint_ranges);
  builder_.add_supported_codepoint_ranges(supported_codepoint_ranges);
  builder_.add_center_token_selection_method(center_token_selection_method);
  builder_.add_tokenization_codepoint_config(tokenization_codepoint_config);
  builder_.add_default_collection(default_collection);
  builder_.add_collections(collections);
  builder_.add_regexp_feature(regexp_feature);
  builder_.add_max_word_length(max_word_length);
  builder_.add_chargram_orders(chargram_orders);
  builder_.add_max_selection_span(max_selection_span);
  builder_.add_context_size(context_size);
  builder_.add_embedding_quantization_bits(embedding_quantization_bits);
  builder_.add_embedding_size(embedding_size);
  builder_.add_num_buckets(num_buckets);
  builder_.add_use_pipe_character_for_newline(use_pipe_character_for_newline);
  builder_.add_tokenize_on_script_change(tokenize_on_script_change);
  builder_.add_icu_preserve_whitespace_tokens(icu_preserve_whitespace_tokens);
  builder_.add_snap_label_span_boundaries_to_containing_tokens(snap_label_span_boundaries_to_containing_tokens);
  builder_.add_split_tokens_on_selection_boundaries(split_tokens_on_selection_boundaries);
  builder_.add_only_use_line_with_click(only_use_line_with_click);
  builder_.add_selection_reduced_output_space(selection_reduced_output_space);
  builder_.add_lowercase_tokens(lowercase_tokens);
  builder_.add_remap_digits(remap_digits);
  builder_.add_extract_selection_mask_feature(extract_selection_mask_feature);
  builder_.add_extract_case_feature(extract_case_feature);
  builder_.add_unicode_aware_features(unicode_aware_features);
  return builder_.Finish();
}

inline flatbuffers::Offset<FeatureProcessorOptions> CreateFeatureProcessorOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_buckets = -1,
    int32_t embedding_size = -1,
    int32_t embedding_quantization_bits = 8,
    int32_t context_size = -1,
    int32_t max_selection_span = -1,
    const std::vector<int32_t> *chargram_orders = nullptr,
    int32_t max_word_length = 20,
    bool unicode_aware_features = false,
    bool extract_case_feature = false,
    bool extract_selection_mask_feature = false,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *regexp_feature = nullptr,
    bool remap_digits = false,
    bool lowercase_tokens = false,
    bool selection_reduced_output_space = true,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *collections = nullptr,
    int32_t default_collection = -1,
    bool only_use_line_with_click = false,
    bool split_tokens_on_selection_boundaries = false,
    const std::vector<flatbuffers::Offset<libtextclassifier3::TokenizationCodepointRange>> *tokenization_codepoint_config = nullptr,
    libtextclassifier3::FeatureProcessorOptions_::CenterTokenSelectionMethod center_token_selection_method = libtextclassifier3::FeatureProcessorOptions_::CenterTokenSelectionMethod_DEFAULT_CENTER_TOKEN_METHOD,
    bool snap_label_span_boundaries_to_containing_tokens = false,
    const std::vector<flatbuffers::Offset<libtextclassifier3::CodepointRange>> *supported_codepoint_ranges = nullptr,
    const std::vector<flatbuffers::Offset<libtextclassifier3::CodepointRange>> *internal_tokenizer_codepoint_ranges = nullptr,
    float min_supported_codepoint_ratio = 0.0f,
    int32_t feature_version = 0,
    libtextclassifier3::TokenizationType tokenization_type = libtextclassifier3::TokenizationType_INTERNAL_TOKENIZER,
    bool icu_preserve_whitespace_tokens = false,
    const std::vector<int32_t> *ignored_span_boundary_codepoints = nullptr,
    flatbuffers::Offset<libtextclassifier3::FeatureProcessorOptions_::BoundsSensitiveFeatures> bounds_sensitive_features = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *allowed_chargrams = nullptr,
    bool tokenize_on_script_change = false,
    bool use_pipe_character_for_newline = true) {
  auto chargram_orders__ = chargram_orders ? _fbb.CreateVector<int32_t>(*chargram_orders) : 0;
  auto regexp_feature__ = regexp_feature ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*regexp_feature) : 0;
  auto collections__ = collections ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*collections) : 0;
  auto tokenization_codepoint_config__ = tokenization_codepoint_config ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::TokenizationCodepointRange>>(*tokenization_codepoint_config) : 0;
  auto supported_codepoint_ranges__ = supported_codepoint_ranges ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::CodepointRange>>(*supported_codepoint_ranges) : 0;
  auto internal_tokenizer_codepoint_ranges__ = internal_tokenizer_codepoint_ranges ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::CodepointRange>>(*internal_tokenizer_codepoint_ranges) : 0;
  auto ignored_span_boundary_codepoints__ = ignored_span_boundary_codepoints ? _fbb.CreateVector<int32_t>(*ignored_span_boundary_codepoints) : 0;
  auto allowed_chargrams__ = allowed_chargrams ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*allowed_chargrams) : 0;
  return libtextclassifier3::CreateFeatureProcessorOptions(
      _fbb,
      num_buckets,
      embedding_size,
      embedding_quantization_bits,
      context_size,
      max_selection_span,
      chargram_orders__,
      max_word_length,
      unicode_aware_features,
      extract_case_feature,
      extract_selection_mask_feature,
      regexp_feature__,
      remap_digits,
      lowercase_tokens,
      selection_reduced_output_space,
      collections__,
      default_collection,
      only_use_line_with_click,
      split_tokens_on_selection_boundaries,
      tokenization_codepoint_config__,
      center_token_selection_method,
      snap_label_span_boundaries_to_containing_tokens,
      supported_codepoint_ranges__,
      internal_tokenizer_codepoint_ranges__,
      min_supported_codepoint_ratio,
      feature_version,
      tokenization_type,
      icu_preserve_whitespace_tokens,
      ignored_span_boundary_codepoints__,
      bounds_sensitive_features,
      allowed_chargrams__,
      tokenize_on_script_change,
      use_pipe_character_for_newline);
}

flatbuffers::Offset<FeatureProcessorOptions> CreateFeatureProcessorOptions(flatbuffers::FlatBufferBuilder &_fbb, const FeatureProcessorOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NumberAnnotatorOptionsT : public flatbuffers::NativeTable {
  typedef NumberAnnotatorOptions TableType;
  bool enabled;
  float score;
  float priority_score;
  libtextclassifier3::ModeFlag enabled_modes;
  uint32_t enabled_annotation_usecases;
  std::vector<int32_t> allowed_prefix_codepoints;
  std::vector<int32_t> allowed_suffix_codepoints;
  std::vector<int32_t> ignored_prefix_span_boundary_codepoints;
  std::vector<int32_t> ignored_suffix_span_boundary_codepoints;
  bool enable_percentage;
  std::string percentage_pieces_string;
  std::vector<int32_t> percentage_pieces_offsets;
  float percentage_priority_score;
  float float_number_priority_score;
  int32_t max_number_of_digits;
  uint32_t percentage_annotation_usecases;
  NumberAnnotatorOptionsT()
      : enabled(false),
        score(1.0f),
        priority_score(0.0f),
        enabled_modes(libtextclassifier3::ModeFlag_ALL),
        enabled_annotation_usecases(4294967295),
        enable_percentage(false),
        percentage_priority_score(1.0f),
        float_number_priority_score(0.0f),
        max_number_of_digits(20),
        percentage_annotation_usecases(2) {
  }
};

struct NumberAnnotatorOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NumberAnnotatorOptionsT NativeTableType;
  typedef NumberAnnotatorOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLED = 4,
    VT_SCORE = 6,
    VT_PRIORITY_SCORE = 8,
    VT_ENABLED_MODES = 10,
    VT_ENABLED_ANNOTATION_USECASES = 12,
    VT_ALLOWED_PREFIX_CODEPOINTS = 14,
    VT_ALLOWED_SUFFIX_CODEPOINTS = 16,
    VT_IGNORED_PREFIX_SPAN_BOUNDARY_CODEPOINTS = 18,
    VT_IGNORED_SUFFIX_SPAN_BOUNDARY_CODEPOINTS = 20,
    VT_ENABLE_PERCENTAGE = 22,
    VT_PERCENTAGE_PIECES_STRING = 24,
    VT_PERCENTAGE_PIECES_OFFSETS = 26,
    VT_PERCENTAGE_PRIORITY_SCORE = 28,
    VT_FLOAT_NUMBER_PRIORITY_SCORE = 30,
    VT_MAX_NUMBER_OF_DIGITS = 32,
    VT_PERCENTAGE_ANNOTATION_USECASES = 34
  };
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 0) != 0;
  }
  float score() const {
    return GetField<float>(VT_SCORE, 1.0f);
  }
  float priority_score() const {
    return GetField<float>(VT_PRIORITY_SCORE, 0.0f);
  }
  libtextclassifier3::ModeFlag enabled_modes() const {
    return static_cast<libtextclassifier3::ModeFlag>(GetField<int32_t>(VT_ENABLED_MODES, 7));
  }
  uint32_t enabled_annotation_usecases() const {
    return GetField<uint32_t>(VT_ENABLED_ANNOTATION_USECASES, 4294967295);
  }
  const flatbuffers::Vector<int32_t> *allowed_prefix_codepoints() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ALLOWED_PREFIX_CODEPOINTS);
  }
  const flatbuffers::Vector<int32_t> *allowed_suffix_codepoints() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ALLOWED_SUFFIX_CODEPOINTS);
  }
  const flatbuffers::Vector<int32_t> *ignored_prefix_span_boundary_codepoints() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_IGNORED_PREFIX_SPAN_BOUNDARY_CODEPOINTS);
  }
  const flatbuffers::Vector<int32_t> *ignored_suffix_span_boundary_codepoints() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_IGNORED_SUFFIX_SPAN_BOUNDARY_CODEPOINTS);
  }
  bool enable_percentage() const {
    return GetField<uint8_t>(VT_ENABLE_PERCENTAGE, 0) != 0;
  }
  const flatbuffers::String *percentage_pieces_string() const {
    return GetPointer<const flatbuffers::String *>(VT_PERCENTAGE_PIECES_STRING);
  }
  const flatbuffers::Vector<int32_t> *percentage_pieces_offsets() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PERCENTAGE_PIECES_OFFSETS);
  }
  float percentage_priority_score() const {
    return GetField<float>(VT_PERCENTAGE_PRIORITY_SCORE, 1.0f);
  }
  float float_number_priority_score() const {
    return GetField<float>(VT_FLOAT_NUMBER_PRIORITY_SCORE, 0.0f);
  }
  int32_t max_number_of_digits() const {
    return GetField<int32_t>(VT_MAX_NUMBER_OF_DIGITS, 20);
  }
  uint32_t percentage_annotation_usecases() const {
    return GetField<uint32_t>(VT_PERCENTAGE_ANNOTATION_USECASES, 2);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED) &&
           VerifyField<float>(verifier, VT_SCORE) &&
           VerifyField<float>(verifier, VT_PRIORITY_SCORE) &&
           VerifyField<int32_t>(verifier, VT_ENABLED_MODES) &&
           VerifyField<uint32_t>(verifier, VT_ENABLED_ANNOTATION_USECASES) &&
           VerifyOffset(verifier, VT_ALLOWED_PREFIX_CODEPOINTS) &&
           verifier.VerifyVector(allowed_prefix_codepoints()) &&
           VerifyOffset(verifier, VT_ALLOWED_SUFFIX_CODEPOINTS) &&
           verifier.VerifyVector(allowed_suffix_codepoints()) &&
           VerifyOffset(verifier, VT_IGNORED_PREFIX_SPAN_BOUNDARY_CODEPOINTS) &&
           verifier.VerifyVector(ignored_prefix_span_boundary_codepoints()) &&
           VerifyOffset(verifier, VT_IGNORED_SUFFIX_SPAN_BOUNDARY_CODEPOINTS) &&
           verifier.VerifyVector(ignored_suffix_span_boundary_codepoints()) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE_PERCENTAGE) &&
           VerifyOffset(verifier, VT_PERCENTAGE_PIECES_STRING) &&
           verifier.VerifyString(percentage_pieces_string()) &&
           VerifyOffset(verifier, VT_PERCENTAGE_PIECES_OFFSETS) &&
           verifier.VerifyVector(percentage_pieces_offsets()) &&
           VerifyField<float>(verifier, VT_PERCENTAGE_PRIORITY_SCORE) &&
           VerifyField<float>(verifier, VT_FLOAT_NUMBER_PRIORITY_SCORE) &&
           VerifyField<int32_t>(verifier, VT_MAX_NUMBER_OF_DIGITS) &&
           VerifyField<uint32_t>(verifier, VT_PERCENTAGE_ANNOTATION_USECASES) &&
           verifier.EndTable();
  }
  NumberAnnotatorOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NumberAnnotatorOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NumberAnnotatorOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NumberAnnotatorOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NumberAnnotatorOptionsBuilder {
  typedef NumberAnnotatorOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(NumberAnnotatorOptions::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
  }
  void add_score(float score) {
    fbb_.AddElement<float>(NumberAnnotatorOptions::VT_SCORE, score, 1.0f);
  }
  void add_priority_score(float priority_score) {
    fbb_.AddElement<float>(NumberAnnotatorOptions::VT_PRIORITY_SCORE, priority_score, 0.0f);
  }
  void add_enabled_modes(libtextclassifier3::ModeFlag enabled_modes) {
    fbb_.AddElement<int32_t>(NumberAnnotatorOptions::VT_ENABLED_MODES, static_cast<int32_t>(enabled_modes), 7);
  }
  void add_enabled_annotation_usecases(uint32_t enabled_annotation_usecases) {
    fbb_.AddElement<uint32_t>(NumberAnnotatorOptions::VT_ENABLED_ANNOTATION_USECASES, enabled_annotation_usecases, 4294967295);
  }
  void add_allowed_prefix_codepoints(flatbuffers::Offset<flatbuffers::Vector<int32_t>> allowed_prefix_codepoints) {
    fbb_.AddOffset(NumberAnnotatorOptions::VT_ALLOWED_PREFIX_CODEPOINTS, allowed_prefix_codepoints);
  }
  void add_allowed_suffix_codepoints(flatbuffers::Offset<flatbuffers::Vector<int32_t>> allowed_suffix_codepoints) {
    fbb_.AddOffset(NumberAnnotatorOptions::VT_ALLOWED_SUFFIX_CODEPOINTS, allowed_suffix_codepoints);
  }
  void add_ignored_prefix_span_boundary_codepoints(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ignored_prefix_span_boundary_codepoints) {
    fbb_.AddOffset(NumberAnnotatorOptions::VT_IGNORED_PREFIX_SPAN_BOUNDARY_CODEPOINTS, ignored_prefix_span_boundary_codepoints);
  }
  void add_ignored_suffix_span_boundary_codepoints(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ignored_suffix_span_boundary_codepoints) {
    fbb_.AddOffset(NumberAnnotatorOptions::VT_IGNORED_SUFFIX_SPAN_BOUNDARY_CODEPOINTS, ignored_suffix_span_boundary_codepoints);
  }
  void add_enable_percentage(bool enable_percentage) {
    fbb_.AddElement<uint8_t>(NumberAnnotatorOptions::VT_ENABLE_PERCENTAGE, static_cast<uint8_t>(enable_percentage), 0);
  }
  void add_percentage_pieces_string(flatbuffers::Offset<flatbuffers::String> percentage_pieces_string) {
    fbb_.AddOffset(NumberAnnotatorOptions::VT_PERCENTAGE_PIECES_STRING, percentage_pieces_string);
  }
  void add_percentage_pieces_offsets(flatbuffers::Offset<flatbuffers::Vector<int32_t>> percentage_pieces_offsets) {
    fbb_.AddOffset(NumberAnnotatorOptions::VT_PERCENTAGE_PIECES_OFFSETS, percentage_pieces_offsets);
  }
  void add_percentage_priority_score(float percentage_priority_score) {
    fbb_.AddElement<float>(NumberAnnotatorOptions::VT_PERCENTAGE_PRIORITY_SCORE, percentage_priority_score, 1.0f);
  }
  void add_float_number_priority_score(float float_number_priority_score) {
    fbb_.AddElement<float>(NumberAnnotatorOptions::VT_FLOAT_NUMBER_PRIORITY_SCORE, float_number_priority_score, 0.0f);
  }
  void add_max_number_of_digits(int32_t max_number_of_digits) {
    fbb_.AddElement<int32_t>(NumberAnnotatorOptions::VT_MAX_NUMBER_OF_DIGITS, max_number_of_digits, 20);
  }
  void add_percentage_annotation_usecases(uint32_t percentage_annotation_usecases) {
    fbb_.AddElement<uint32_t>(NumberAnnotatorOptions::VT_PERCENTAGE_ANNOTATION_USECASES, percentage_annotation_usecases, 2);
  }
  explicit NumberAnnotatorOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NumberAnnotatorOptionsBuilder &operator=(const NumberAnnotatorOptionsBuilder &);
  flatbuffers::Offset<NumberAnnotatorOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NumberAnnotatorOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<NumberAnnotatorOptions> CreateNumberAnnotatorOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enabled = false,
    float score = 1.0f,
    float priority_score = 0.0f,
    libtextclassifier3::ModeFlag enabled_modes = libtextclassifier3::ModeFlag_ALL,
    uint32_t enabled_annotation_usecases = 4294967295,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> allowed_prefix_codepoints = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> allowed_suffix_codepoints = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ignored_prefix_span_boundary_codepoints = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ignored_suffix_span_boundary_codepoints = 0,
    bool enable_percentage = false,
    flatbuffers::Offset<flatbuffers::String> percentage_pieces_string = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> percentage_pieces_offsets = 0,
    float percentage_priority_score = 1.0f,
    float float_number_priority_score = 0.0f,
    int32_t max_number_of_digits = 20,
    uint32_t percentage_annotation_usecases = 2) {
  NumberAnnotatorOptionsBuilder builder_(_fbb);
  builder_.add_percentage_annotation_usecases(percentage_annotation_usecases);
  builder_.add_max_number_of_digits(max_number_of_digits);
  builder_.add_float_number_priority_score(float_number_priority_score);
  builder_.add_percentage_priority_score(percentage_priority_score);
  builder_.add_percentage_pieces_offsets(percentage_pieces_offsets);
  builder_.add_percentage_pieces_string(percentage_pieces_string);
  builder_.add_ignored_suffix_span_boundary_codepoints(ignored_suffix_span_boundary_codepoints);
  builder_.add_ignored_prefix_span_boundary_codepoints(ignored_prefix_span_boundary_codepoints);
  builder_.add_allowed_suffix_codepoints(allowed_suffix_codepoints);
  builder_.add_allowed_prefix_codepoints(allowed_prefix_codepoints);
  builder_.add_enabled_annotation_usecases(enabled_annotation_usecases);
  builder_.add_enabled_modes(enabled_modes);
  builder_.add_priority_score(priority_score);
  builder_.add_score(score);
  builder_.add_enable_percentage(enable_percentage);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

inline flatbuffers::Offset<NumberAnnotatorOptions> CreateNumberAnnotatorOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enabled = false,
    float score = 1.0f,
    float priority_score = 0.0f,
    libtextclassifier3::ModeFlag enabled_modes = libtextclassifier3::ModeFlag_ALL,
    uint32_t enabled_annotation_usecases = 4294967295,
    const std::vector<int32_t> *allowed_prefix_codepoints = nullptr,
    const std::vector<int32_t> *allowed_suffix_codepoints = nullptr,
    const std::vector<int32_t> *ignored_prefix_span_boundary_codepoints = nullptr,
    const std::vector<int32_t> *ignored_suffix_span_boundary_codepoints = nullptr,
    bool enable_percentage = false,
    const char *percentage_pieces_string = nullptr,
    const std::vector<int32_t> *percentage_pieces_offsets = nullptr,
    float percentage_priority_score = 1.0f,
    float float_number_priority_score = 0.0f,
    int32_t max_number_of_digits = 20,
    uint32_t percentage_annotation_usecases = 2) {
  auto allowed_prefix_codepoints__ = allowed_prefix_codepoints ? _fbb.CreateVector<int32_t>(*allowed_prefix_codepoints) : 0;
  auto allowed_suffix_codepoints__ = allowed_suffix_codepoints ? _fbb.CreateVector<int32_t>(*allowed_suffix_codepoints) : 0;
  auto ignored_prefix_span_boundary_codepoints__ = ignored_prefix_span_boundary_codepoints ? _fbb.CreateVector<int32_t>(*ignored_prefix_span_boundary_codepoints) : 0;
  auto ignored_suffix_span_boundary_codepoints__ = ignored_suffix_span_boundary_codepoints ? _fbb.CreateVector<int32_t>(*ignored_suffix_span_boundary_codepoints) : 0;
  auto percentage_pieces_string__ = percentage_pieces_string ? _fbb.CreateSharedString(percentage_pieces_string) : 0;
  auto percentage_pieces_offsets__ = percentage_pieces_offsets ? _fbb.CreateVector<int32_t>(*percentage_pieces_offsets) : 0;
  return libtextclassifier3::CreateNumberAnnotatorOptions(
      _fbb,
      enabled,
      score,
      priority_score,
      enabled_modes,
      enabled_annotation_usecases,
      allowed_prefix_codepoints__,
      allowed_suffix_codepoints__,
      ignored_prefix_span_boundary_codepoints__,
      ignored_suffix_span_boundary_codepoints__,
      enable_percentage,
      percentage_pieces_string__,
      percentage_pieces_offsets__,
      percentage_priority_score,
      float_number_priority_score,
      max_number_of_digits,
      percentage_annotation_usecases);
}

flatbuffers::Offset<NumberAnnotatorOptions> CreateNumberAnnotatorOptions(flatbuffers::FlatBufferBuilder &_fbb, const NumberAnnotatorOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DurationAnnotatorOptionsT : public flatbuffers::NativeTable {
  typedef DurationAnnotatorOptions TableType;
  bool enabled;
  float score;
  float priority_score;
  libtextclassifier3::ModeFlag enabled_modes;
  uint32_t enabled_annotation_usecases;
  std::vector<std::string> week_expressions;
  std::vector<std::string> day_expressions;
  std::vector<std::string> hour_expressions;
  std::vector<std::string> minute_expressions;
  std::vector<std::string> second_expressions;
  std::vector<std::string> filler_expressions;
  std::vector<std::string> half_expressions;
  std::vector<int32_t> sub_token_separator_codepoints;
  bool require_quantity;
  bool enable_dangling_quantity_interpretation;
  DurationAnnotatorOptionsT()
      : enabled(false),
        score(1.0f),
        priority_score(0.0f),
        enabled_modes(libtextclassifier3::ModeFlag_ALL),
        enabled_annotation_usecases(4294967295),
        require_quantity(false),
        enable_dangling_quantity_interpretation(true) {
  }
};

struct DurationAnnotatorOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DurationAnnotatorOptionsT NativeTableType;
  typedef DurationAnnotatorOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLED = 4,
    VT_SCORE = 6,
    VT_PRIORITY_SCORE = 8,
    VT_ENABLED_MODES = 10,
    VT_ENABLED_ANNOTATION_USECASES = 12,
    VT_WEEK_EXPRESSIONS = 14,
    VT_DAY_EXPRESSIONS = 16,
    VT_HOUR_EXPRESSIONS = 18,
    VT_MINUTE_EXPRESSIONS = 20,
    VT_SECOND_EXPRESSIONS = 22,
    VT_FILLER_EXPRESSIONS = 24,
    VT_HALF_EXPRESSIONS = 26,
    VT_SUB_TOKEN_SEPARATOR_CODEPOINTS = 28,
    VT_REQUIRE_QUANTITY = 30,
    VT_ENABLE_DANGLING_QUANTITY_INTERPRETATION = 32
  };
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 0) != 0;
  }
  float score() const {
    return GetField<float>(VT_SCORE, 1.0f);
  }
  float priority_score() const {
    return GetField<float>(VT_PRIORITY_SCORE, 0.0f);
  }
  libtextclassifier3::ModeFlag enabled_modes() const {
    return static_cast<libtextclassifier3::ModeFlag>(GetField<int32_t>(VT_ENABLED_MODES, 7));
  }
  uint32_t enabled_annotation_usecases() const {
    return GetField<uint32_t>(VT_ENABLED_ANNOTATION_USECASES, 4294967295);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *week_expressions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_WEEK_EXPRESSIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *day_expressions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DAY_EXPRESSIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *hour_expressions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_HOUR_EXPRESSIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *minute_expressions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_MINUTE_EXPRESSIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *second_expressions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_SECOND_EXPRESSIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *filler_expressions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_FILLER_EXPRESSIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *half_expressions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_HALF_EXPRESSIONS);
  }
  const flatbuffers::Vector<int32_t> *sub_token_separator_codepoints() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SUB_TOKEN_SEPARATOR_CODEPOINTS);
  }
  bool require_quantity() const {
    return GetField<uint8_t>(VT_REQUIRE_QUANTITY, 0) != 0;
  }
  bool enable_dangling_quantity_interpretation() const {
    return GetField<uint8_t>(VT_ENABLE_DANGLING_QUANTITY_INTERPRETATION, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED) &&
           VerifyField<float>(verifier, VT_SCORE) &&
           VerifyField<float>(verifier, VT_PRIORITY_SCORE) &&
           VerifyField<int32_t>(verifier, VT_ENABLED_MODES) &&
           VerifyField<uint32_t>(verifier, VT_ENABLED_ANNOTATION_USECASES) &&
           VerifyOffset(verifier, VT_WEEK_EXPRESSIONS) &&
           verifier.VerifyVector(week_expressions()) &&
           verifier.VerifyVectorOfStrings(week_expressions()) &&
           VerifyOffset(verifier, VT_DAY_EXPRESSIONS) &&
           verifier.VerifyVector(day_expressions()) &&
           verifier.VerifyVectorOfStrings(day_expressions()) &&
           VerifyOffset(verifier, VT_HOUR_EXPRESSIONS) &&
           verifier.VerifyVector(hour_expressions()) &&
           verifier.VerifyVectorOfStrings(hour_expressions()) &&
           VerifyOffset(verifier, VT_MINUTE_EXPRESSIONS) &&
           verifier.VerifyVector(minute_expressions()) &&
           verifier.VerifyVectorOfStrings(minute_expressions()) &&
           VerifyOffset(verifier, VT_SECOND_EXPRESSIONS) &&
           verifier.VerifyVector(second_expressions()) &&
           verifier.VerifyVectorOfStrings(second_expressions()) &&
           VerifyOffset(verifier, VT_FILLER_EXPRESSIONS) &&
           verifier.VerifyVector(filler_expressions()) &&
           verifier.VerifyVectorOfStrings(filler_expressions()) &&
           VerifyOffset(verifier, VT_HALF_EXPRESSIONS) &&
           verifier.VerifyVector(half_expressions()) &&
           verifier.VerifyVectorOfStrings(half_expressions()) &&
           VerifyOffset(verifier, VT_SUB_TOKEN_SEPARATOR_CODEPOINTS) &&
           verifier.VerifyVector(sub_token_separator_codepoints()) &&
           VerifyField<uint8_t>(verifier, VT_REQUIRE_QUANTITY) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE_DANGLING_QUANTITY_INTERPRETATION) &&
           verifier.EndTable();
  }
  DurationAnnotatorOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DurationAnnotatorOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DurationAnnotatorOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DurationAnnotatorOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DurationAnnotatorOptionsBuilder {
  typedef DurationAnnotatorOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(DurationAnnotatorOptions::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
  }
  void add_score(float score) {
    fbb_.AddElement<float>(DurationAnnotatorOptions::VT_SCORE, score, 1.0f);
  }
  void add_priority_score(float priority_score) {
    fbb_.AddElement<float>(DurationAnnotatorOptions::VT_PRIORITY_SCORE, priority_score, 0.0f);
  }
  void add_enabled_modes(libtextclassifier3::ModeFlag enabled_modes) {
    fbb_.AddElement<int32_t>(DurationAnnotatorOptions::VT_ENABLED_MODES, static_cast<int32_t>(enabled_modes), 7);
  }
  void add_enabled_annotation_usecases(uint32_t enabled_annotation_usecases) {
    fbb_.AddElement<uint32_t>(DurationAnnotatorOptions::VT_ENABLED_ANNOTATION_USECASES, enabled_annotation_usecases, 4294967295);
  }
  void add_week_expressions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> week_expressions) {
    fbb_.AddOffset(DurationAnnotatorOptions::VT_WEEK_EXPRESSIONS, week_expressions);
  }
  void add_day_expressions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> day_expressions) {
    fbb_.AddOffset(DurationAnnotatorOptions::VT_DAY_EXPRESSIONS, day_expressions);
  }
  void add_hour_expressions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> hour_expressions) {
    fbb_.AddOffset(DurationAnnotatorOptions::VT_HOUR_EXPRESSIONS, hour_expressions);
  }
  void add_minute_expressions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> minute_expressions) {
    fbb_.AddOffset(DurationAnnotatorOptions::VT_MINUTE_EXPRESSIONS, minute_expressions);
  }
  void add_second_expressions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> second_expressions) {
    fbb_.AddOffset(DurationAnnotatorOptions::VT_SECOND_EXPRESSIONS, second_expressions);
  }
  void add_filler_expressions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> filler_expressions) {
    fbb_.AddOffset(DurationAnnotatorOptions::VT_FILLER_EXPRESSIONS, filler_expressions);
  }
  void add_half_expressions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> half_expressions) {
    fbb_.AddOffset(DurationAnnotatorOptions::VT_HALF_EXPRESSIONS, half_expressions);
  }
  void add_sub_token_separator_codepoints(flatbuffers::Offset<flatbuffers::Vector<int32_t>> sub_token_separator_codepoints) {
    fbb_.AddOffset(DurationAnnotatorOptions::VT_SUB_TOKEN_SEPARATOR_CODEPOINTS, sub_token_separator_codepoints);
  }
  void add_require_quantity(bool require_quantity) {
    fbb_.AddElement<uint8_t>(DurationAnnotatorOptions::VT_REQUIRE_QUANTITY, static_cast<uint8_t>(require_quantity), 0);
  }
  void add_enable_dangling_quantity_interpretation(bool enable_dangling_quantity_interpretation) {
    fbb_.AddElement<uint8_t>(DurationAnnotatorOptions::VT_ENABLE_DANGLING_QUANTITY_INTERPRETATION, static_cast<uint8_t>(enable_dangling_quantity_interpretation), 1);
  }
  explicit DurationAnnotatorOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DurationAnnotatorOptionsBuilder &operator=(const DurationAnnotatorOptionsBuilder &);
  flatbuffers::Offset<DurationAnnotatorOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DurationAnnotatorOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DurationAnnotatorOptions> CreateDurationAnnotatorOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enabled = false,
    float score = 1.0f,
    float priority_score = 0.0f,
    libtextclassifier3::ModeFlag enabled_modes = libtextclassifier3::ModeFlag_ALL,
    uint32_t enabled_annotation_usecases = 4294967295,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> week_expressions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> day_expressions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> hour_expressions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> minute_expressions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> second_expressions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> filler_expressions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> half_expressions = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> sub_token_separator_codepoints = 0,
    bool require_quantity = false,
    bool enable_dangling_quantity_interpretation = true) {
  DurationAnnotatorOptionsBuilder builder_(_fbb);
  builder_.add_sub_token_separator_codepoints(sub_token_separator_codepoints);
  builder_.add_half_expressions(half_expressions);
  builder_.add_filler_expressions(filler_expressions);
  builder_.add_second_expressions(second_expressions);
  builder_.add_minute_expressions(minute_expressions);
  builder_.add_hour_expressions(hour_expressions);
  builder_.add_day_expressions(day_expressions);
  builder_.add_week_expressions(week_expressions);
  builder_.add_enabled_annotation_usecases(enabled_annotation_usecases);
  builder_.add_enabled_modes(enabled_modes);
  builder_.add_priority_score(priority_score);
  builder_.add_score(score);
  builder_.add_enable_dangling_quantity_interpretation(enable_dangling_quantity_interpretation);
  builder_.add_require_quantity(require_quantity);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

inline flatbuffers::Offset<DurationAnnotatorOptions> CreateDurationAnnotatorOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enabled = false,
    float score = 1.0f,
    float priority_score = 0.0f,
    libtextclassifier3::ModeFlag enabled_modes = libtextclassifier3::ModeFlag_ALL,
    uint32_t enabled_annotation_usecases = 4294967295,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *week_expressions = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *day_expressions = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *hour_expressions = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *minute_expressions = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *second_expressions = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *filler_expressions = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *half_expressions = nullptr,
    const std::vector<int32_t> *sub_token_separator_codepoints = nullptr,
    bool require_quantity = false,
    bool enable_dangling_quantity_interpretation = true) {
  auto week_expressions__ = week_expressions ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*week_expressions) : 0;
  auto day_expressions__ = day_expressions ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*day_expressions) : 0;
  auto hour_expressions__ = hour_expressions ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*hour_expressions) : 0;
  auto minute_expressions__ = minute_expressions ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*minute_expressions) : 0;
  auto second_expressions__ = second_expressions ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*second_expressions) : 0;
  auto filler_expressions__ = filler_expressions ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*filler_expressions) : 0;
  auto half_expressions__ = half_expressions ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*half_expressions) : 0;
  auto sub_token_separator_codepoints__ = sub_token_separator_codepoints ? _fbb.CreateVector<int32_t>(*sub_token_separator_codepoints) : 0;
  return libtextclassifier3::CreateDurationAnnotatorOptions(
      _fbb,
      enabled,
      score,
      priority_score,
      enabled_modes,
      enabled_annotation_usecases,
      week_expressions__,
      day_expressions__,
      hour_expressions__,
      minute_expressions__,
      second_expressions__,
      filler_expressions__,
      half_expressions__,
      sub_token_separator_codepoints__,
      require_quantity,
      enable_dangling_quantity_interpretation);
}

flatbuffers::Offset<DurationAnnotatorOptions> CreateDurationAnnotatorOptions(flatbuffers::FlatBufferBuilder &_fbb, const DurationAnnotatorOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ContactAnnotatorOptionsT : public flatbuffers::NativeTable {
  typedef ContactAnnotatorOptions TableType;
  bool enable_declension;
  std::string language;
  ContactAnnotatorOptionsT()
      : enable_declension(false) {
  }
};

struct ContactAnnotatorOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ContactAnnotatorOptionsT NativeTableType;
  typedef ContactAnnotatorOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLE_DECLENSION = 4,
    VT_LANGUAGE = 6
  };
  bool enable_declension() const {
    return GetField<uint8_t>(VT_ENABLE_DECLENSION, 0) != 0;
  }
  const flatbuffers::String *language() const {
    return GetPointer<const flatbuffers::String *>(VT_LANGUAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE_DECLENSION) &&
           VerifyOffset(verifier, VT_LANGUAGE) &&
           verifier.VerifyString(language()) &&
           verifier.EndTable();
  }
  ContactAnnotatorOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ContactAnnotatorOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ContactAnnotatorOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ContactAnnotatorOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ContactAnnotatorOptionsBuilder {
  typedef ContactAnnotatorOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable_declension(bool enable_declension) {
    fbb_.AddElement<uint8_t>(ContactAnnotatorOptions::VT_ENABLE_DECLENSION, static_cast<uint8_t>(enable_declension), 0);
  }
  void add_language(flatbuffers::Offset<flatbuffers::String> language) {
    fbb_.AddOffset(ContactAnnotatorOptions::VT_LANGUAGE, language);
  }
  explicit ContactAnnotatorOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContactAnnotatorOptionsBuilder &operator=(const ContactAnnotatorOptionsBuilder &);
  flatbuffers::Offset<ContactAnnotatorOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ContactAnnotatorOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ContactAnnotatorOptions> CreateContactAnnotatorOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable_declension = false,
    flatbuffers::Offset<flatbuffers::String> language = 0) {
  ContactAnnotatorOptionsBuilder builder_(_fbb);
  builder_.add_language(language);
  builder_.add_enable_declension(enable_declension);
  return builder_.Finish();
}

inline flatbuffers::Offset<ContactAnnotatorOptions> CreateContactAnnotatorOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable_declension = false,
    const char *language = nullptr) {
  auto language__ = language ? _fbb.CreateSharedString(language) : 0;
  return libtextclassifier3::CreateContactAnnotatorOptions(
      _fbb,
      enable_declension,
      language__);
}

flatbuffers::Offset<ContactAnnotatorOptions> CreateContactAnnotatorOptions(flatbuffers::FlatBufferBuilder &_fbb, const ContactAnnotatorOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TranslateAnnotatorOptions_ {

struct BackoffOptionsT : public flatbuffers::NativeTable {
  typedef BackoffOptions TableType;
  int32_t min_text_size;
  float penalize_ratio;
  float subject_text_score_ratio;
  BackoffOptionsT()
      : min_text_size(20),
        penalize_ratio(1.0f),
        subject_text_score_ratio(0.4f) {
  }
};

struct BackoffOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BackoffOptionsT NativeTableType;
  typedef BackoffOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN_TEXT_SIZE = 4,
    VT_PENALIZE_RATIO = 6,
    VT_SUBJECT_TEXT_SCORE_RATIO = 8
  };
  int32_t min_text_size() const {
    return GetField<int32_t>(VT_MIN_TEXT_SIZE, 20);
  }
  float penalize_ratio() const {
    return GetField<float>(VT_PENALIZE_RATIO, 1.0f);
  }
  float subject_text_score_ratio() const {
    return GetField<float>(VT_SUBJECT_TEXT_SCORE_RATIO, 0.4f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MIN_TEXT_SIZE) &&
           VerifyField<float>(verifier, VT_PENALIZE_RATIO) &&
           VerifyField<float>(verifier, VT_SUBJECT_TEXT_SCORE_RATIO) &&
           verifier.EndTable();
  }
  BackoffOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BackoffOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BackoffOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BackoffOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BackoffOptionsBuilder {
  typedef BackoffOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min_text_size(int32_t min_text_size) {
    fbb_.AddElement<int32_t>(BackoffOptions::VT_MIN_TEXT_SIZE, min_text_size, 20);
  }
  void add_penalize_ratio(float penalize_ratio) {
    fbb_.AddElement<float>(BackoffOptions::VT_PENALIZE_RATIO, penalize_ratio, 1.0f);
  }
  void add_subject_text_score_ratio(float subject_text_score_ratio) {
    fbb_.AddElement<float>(BackoffOptions::VT_SUBJECT_TEXT_SCORE_RATIO, subject_text_score_ratio, 0.4f);
  }
  explicit BackoffOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BackoffOptionsBuilder &operator=(const BackoffOptionsBuilder &);
  flatbuffers::Offset<BackoffOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BackoffOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BackoffOptions> CreateBackoffOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t min_text_size = 20,
    float penalize_ratio = 1.0f,
    float subject_text_score_ratio = 0.4f) {
  BackoffOptionsBuilder builder_(_fbb);
  builder_.add_subject_text_score_ratio(subject_text_score_ratio);
  builder_.add_penalize_ratio(penalize_ratio);
  builder_.add_min_text_size(min_text_size);
  return builder_.Finish();
}

flatbuffers::Offset<BackoffOptions> CreateBackoffOptions(flatbuffers::FlatBufferBuilder &_fbb, const BackoffOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace TranslateAnnotatorOptions_

struct TranslateAnnotatorOptionsT : public flatbuffers::NativeTable {
  typedef TranslateAnnotatorOptions TableType;
  bool enabled;
  float score;
  float priority_score;
  libtextclassifier3::TranslateAnnotatorOptions_::Algorithm algorithm;
  std::unique_ptr<libtextclassifier3::TranslateAnnotatorOptions_::BackoffOptionsT> backoff_options;
  TranslateAnnotatorOptionsT()
      : enabled(false),
        score(1.0f),
        priority_score(0.0f),
        algorithm(libtextclassifier3::TranslateAnnotatorOptions_::Algorithm_DEFAULT_ALGORITHM) {
  }
};

struct TranslateAnnotatorOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TranslateAnnotatorOptionsT NativeTableType;
  typedef TranslateAnnotatorOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLED = 4,
    VT_SCORE = 6,
    VT_PRIORITY_SCORE = 8,
    VT_ALGORITHM = 10,
    VT_BACKOFF_OPTIONS = 12
  };
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 0) != 0;
  }
  float score() const {
    return GetField<float>(VT_SCORE, 1.0f);
  }
  float priority_score() const {
    return GetField<float>(VT_PRIORITY_SCORE, 0.0f);
  }
  libtextclassifier3::TranslateAnnotatorOptions_::Algorithm algorithm() const {
    return static_cast<libtextclassifier3::TranslateAnnotatorOptions_::Algorithm>(GetField<int32_t>(VT_ALGORITHM, 0));
  }
  const libtextclassifier3::TranslateAnnotatorOptions_::BackoffOptions *backoff_options() const {
    return GetPointer<const libtextclassifier3::TranslateAnnotatorOptions_::BackoffOptions *>(VT_BACKOFF_OPTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED) &&
           VerifyField<float>(verifier, VT_SCORE) &&
           VerifyField<float>(verifier, VT_PRIORITY_SCORE) &&
           VerifyField<int32_t>(verifier, VT_ALGORITHM) &&
           VerifyOffset(verifier, VT_BACKOFF_OPTIONS) &&
           verifier.VerifyTable(backoff_options()) &&
           verifier.EndTable();
  }
  TranslateAnnotatorOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TranslateAnnotatorOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TranslateAnnotatorOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TranslateAnnotatorOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TranslateAnnotatorOptionsBuilder {
  typedef TranslateAnnotatorOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(TranslateAnnotatorOptions::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
  }
  void add_score(float score) {
    fbb_.AddElement<float>(TranslateAnnotatorOptions::VT_SCORE, score, 1.0f);
  }
  void add_priority_score(float priority_score) {
    fbb_.AddElement<float>(TranslateAnnotatorOptions::VT_PRIORITY_SCORE, priority_score, 0.0f);
  }
  void add_algorithm(libtextclassifier3::TranslateAnnotatorOptions_::Algorithm algorithm) {
    fbb_.AddElement<int32_t>(TranslateAnnotatorOptions::VT_ALGORITHM, static_cast<int32_t>(algorithm), 0);
  }
  void add_backoff_options(flatbuffers::Offset<libtextclassifier3::TranslateAnnotatorOptions_::BackoffOptions> backoff_options) {
    fbb_.AddOffset(TranslateAnnotatorOptions::VT_BACKOFF_OPTIONS, backoff_options);
  }
  explicit TranslateAnnotatorOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TranslateAnnotatorOptionsBuilder &operator=(const TranslateAnnotatorOptionsBuilder &);
  flatbuffers::Offset<TranslateAnnotatorOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TranslateAnnotatorOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<TranslateAnnotatorOptions> CreateTranslateAnnotatorOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enabled = false,
    float score = 1.0f,
    float priority_score = 0.0f,
    libtextclassifier3::TranslateAnnotatorOptions_::Algorithm algorithm = libtextclassifier3::TranslateAnnotatorOptions_::Algorithm_DEFAULT_ALGORITHM,
    flatbuffers::Offset<libtextclassifier3::TranslateAnnotatorOptions_::BackoffOptions> backoff_options = 0) {
  TranslateAnnotatorOptionsBuilder builder_(_fbb);
  builder_.add_backoff_options(backoff_options);
  builder_.add_algorithm(algorithm);
  builder_.add_priority_score(priority_score);
  builder_.add_score(score);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

flatbuffers::Offset<TranslateAnnotatorOptions> CreateTranslateAnnotatorOptions(flatbuffers::FlatBufferBuilder &_fbb, const TranslateAnnotatorOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace PodNerModel_ {

struct CollectionT : public flatbuffers::NativeTable {
  typedef Collection TableType;
  std::string name;
  float single_token_priority_score;
  float multi_token_priority_score;
  CollectionT()
      : single_token_priority_score(0.0f),
        multi_token_priority_score(0.0f) {
  }
};

struct Collection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CollectionT NativeTableType;
  typedef CollectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SINGLE_TOKEN_PRIORITY_SCORE = 6,
    VT_MULTI_TOKEN_PRIORITY_SCORE = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  float single_token_priority_score() const {
    return GetField<float>(VT_SINGLE_TOKEN_PRIORITY_SCORE, 0.0f);
  }
  float multi_token_priority_score() const {
    return GetField<float>(VT_MULTI_TOKEN_PRIORITY_SCORE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<float>(verifier, VT_SINGLE_TOKEN_PRIORITY_SCORE) &&
           VerifyField<float>(verifier, VT_MULTI_TOKEN_PRIORITY_SCORE) &&
           verifier.EndTable();
  }
  CollectionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CollectionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Collection> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CollectionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CollectionBuilder {
  typedef Collection Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Collection::VT_NAME, name);
  }
  void add_single_token_priority_score(float single_token_priority_score) {
    fbb_.AddElement<float>(Collection::VT_SINGLE_TOKEN_PRIORITY_SCORE, single_token_priority_score, 0.0f);
  }
  void add_multi_token_priority_score(float multi_token_priority_score) {
    fbb_.AddElement<float>(Collection::VT_MULTI_TOKEN_PRIORITY_SCORE, multi_token_priority_score, 0.0f);
  }
  explicit CollectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CollectionBuilder &operator=(const CollectionBuilder &);
  flatbuffers::Offset<Collection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Collection>(end);
    return o;
  }
};

inline flatbuffers::Offset<Collection> CreateCollection(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    float single_token_priority_score = 0.0f,
    float multi_token_priority_score = 0.0f) {
  CollectionBuilder builder_(_fbb);
  builder_.add_multi_token_priority_score(multi_token_priority_score);
  builder_.add_single_token_priority_score(single_token_priority_score);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Collection> CreateCollectionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    float single_token_priority_score = 0.0f,
    float multi_token_priority_score = 0.0f) {
  auto name__ = name ? _fbb.CreateSharedString(name) : 0;
  return libtextclassifier3::PodNerModel_::CreateCollection(
      _fbb,
      name__,
      single_token_priority_score,
      multi_token_priority_score);
}

flatbuffers::Offset<Collection> CreateCollection(flatbuffers::FlatBufferBuilder &_fbb, const CollectionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LabelT : public flatbuffers::NativeTable {
  typedef Label TableType;
  libtextclassifier3::PodNerModel_::Label_::BoiseType boise_type;
  libtextclassifier3::PodNerModel_::Label_::MentionType mention_type;
  int32_t collection_id;
  LabelT()
      : boise_type(libtextclassifier3::PodNerModel_::Label_::BoiseType_NONE),
        mention_type(libtextclassifier3::PodNerModel_::Label_::MentionType_UNDEFINED),
        collection_id(0) {
  }
};

struct Label FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LabelT NativeTableType;
  typedef LabelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BOISE_TYPE = 4,
    VT_MENTION_TYPE = 6,
    VT_COLLECTION_ID = 8
  };
  libtextclassifier3::PodNerModel_::Label_::BoiseType boise_type() const {
    return static_cast<libtextclassifier3::PodNerModel_::Label_::BoiseType>(GetField<int32_t>(VT_BOISE_TYPE, 0));
  }
  libtextclassifier3::PodNerModel_::Label_::MentionType mention_type() const {
    return static_cast<libtextclassifier3::PodNerModel_::Label_::MentionType>(GetField<int32_t>(VT_MENTION_TYPE, 0));
  }
  int32_t collection_id() const {
    return GetField<int32_t>(VT_COLLECTION_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BOISE_TYPE) &&
           VerifyField<int32_t>(verifier, VT_MENTION_TYPE) &&
           VerifyField<int32_t>(verifier, VT_COLLECTION_ID) &&
           verifier.EndTable();
  }
  LabelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LabelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Label> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LabelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LabelBuilder {
  typedef Label Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_boise_type(libtextclassifier3::PodNerModel_::Label_::BoiseType boise_type) {
    fbb_.AddElement<int32_t>(Label::VT_BOISE_TYPE, static_cast<int32_t>(boise_type), 0);
  }
  void add_mention_type(libtextclassifier3::PodNerModel_::Label_::MentionType mention_type) {
    fbb_.AddElement<int32_t>(Label::VT_MENTION_TYPE, static_cast<int32_t>(mention_type), 0);
  }
  void add_collection_id(int32_t collection_id) {
    fbb_.AddElement<int32_t>(Label::VT_COLLECTION_ID, collection_id, 0);
  }
  explicit LabelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LabelBuilder &operator=(const LabelBuilder &);
  flatbuffers::Offset<Label> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Label>(end);
    return o;
  }
};

inline flatbuffers::Offset<Label> CreateLabel(
    flatbuffers::FlatBufferBuilder &_fbb,
    libtextclassifier3::PodNerModel_::Label_::BoiseType boise_type = libtextclassifier3::PodNerModel_::Label_::BoiseType_NONE,
    libtextclassifier3::PodNerModel_::Label_::MentionType mention_type = libtextclassifier3::PodNerModel_::Label_::MentionType_UNDEFINED,
    int32_t collection_id = 0) {
  LabelBuilder builder_(_fbb);
  builder_.add_collection_id(collection_id);
  builder_.add_mention_type(mention_type);
  builder_.add_boise_type(boise_type);
  return builder_.Finish();
}

flatbuffers::Offset<Label> CreateLabel(flatbuffers::FlatBufferBuilder &_fbb, const LabelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace PodNerModel_

struct PodNerModelT : public flatbuffers::NativeTable {
  typedef PodNerModel TableType;
  std::vector<uint8_t> tflite_model;
  std::vector<uint8_t> word_piece_vocab;
  bool lowercase_input;
  int32_t logits_index_in_output_tensor;
  bool append_final_period;
  float priority_score;
  int32_t max_num_wordpieces;
  int32_t sliding_window_num_wordpieces_overlap;
  std::vector<std::unique_ptr<libtextclassifier3::PodNerModel_::LabelT>> labels;
  float max_ratio_unknown_wordpieces;
  std::vector<std::unique_ptr<libtextclassifier3::PodNerModel_::CollectionT>> collections;
  int32_t min_number_of_tokens;
  int32_t min_number_of_wordpieces;
  PodNerModelT()
      : lowercase_input(true),
        logits_index_in_output_tensor(0),
        append_final_period(false),
        priority_score(0.0f),
        max_num_wordpieces(128),
        sliding_window_num_wordpieces_overlap(20),
        max_ratio_unknown_wordpieces(0.1f),
        min_number_of_tokens(1),
        min_number_of_wordpieces(1) {
  }
};

struct PodNerModel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PodNerModelT NativeTableType;
  typedef PodNerModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TFLITE_MODEL = 4,
    VT_WORD_PIECE_VOCAB = 6,
    VT_LOWERCASE_INPUT = 8,
    VT_LOGITS_INDEX_IN_OUTPUT_TENSOR = 10,
    VT_APPEND_FINAL_PERIOD = 12,
    VT_PRIORITY_SCORE = 14,
    VT_MAX_NUM_WORDPIECES = 16,
    VT_SLIDING_WINDOW_NUM_WORDPIECES_OVERLAP = 18,
    VT_LABELS = 22,
    VT_MAX_RATIO_UNKNOWN_WORDPIECES = 24,
    VT_COLLECTIONS = 26,
    VT_MIN_NUMBER_OF_TOKENS = 28,
    VT_MIN_NUMBER_OF_WORDPIECES = 30
  };
  const flatbuffers::Vector<uint8_t> *tflite_model() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_TFLITE_MODEL);
  }
  const flatbuffers::Vector<uint8_t> *word_piece_vocab() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_WORD_PIECE_VOCAB);
  }
  bool lowercase_input() const {
    return GetField<uint8_t>(VT_LOWERCASE_INPUT, 1) != 0;
  }
  int32_t logits_index_in_output_tensor() const {
    return GetField<int32_t>(VT_LOGITS_INDEX_IN_OUTPUT_TENSOR, 0);
  }
  bool append_final_period() const {
    return GetField<uint8_t>(VT_APPEND_FINAL_PERIOD, 0) != 0;
  }
  float priority_score() const {
    return GetField<float>(VT_PRIORITY_SCORE, 0.0f);
  }
  int32_t max_num_wordpieces() const {
    return GetField<int32_t>(VT_MAX_NUM_WORDPIECES, 128);
  }
  int32_t sliding_window_num_wordpieces_overlap() const {
    return GetField<int32_t>(VT_SLIDING_WINDOW_NUM_WORDPIECES_OVERLAP, 20);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::PodNerModel_::Label>> *labels() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::PodNerModel_::Label>> *>(VT_LABELS);
  }
  float max_ratio_unknown_wordpieces() const {
    return GetField<float>(VT_MAX_RATIO_UNKNOWN_WORDPIECES, 0.1f);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::PodNerModel_::Collection>> *collections() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::PodNerModel_::Collection>> *>(VT_COLLECTIONS);
  }
  int32_t min_number_of_tokens() const {
    return GetField<int32_t>(VT_MIN_NUMBER_OF_TOKENS, 1);
  }
  int32_t min_number_of_wordpieces() const {
    return GetField<int32_t>(VT_MIN_NUMBER_OF_WORDPIECES, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TFLITE_MODEL) &&
           verifier.VerifyVector(tflite_model()) &&
           VerifyOffset(verifier, VT_WORD_PIECE_VOCAB) &&
           verifier.VerifyVector(word_piece_vocab()) &&
           VerifyField<uint8_t>(verifier, VT_LOWERCASE_INPUT) &&
           VerifyField<int32_t>(verifier, VT_LOGITS_INDEX_IN_OUTPUT_TENSOR) &&
           VerifyField<uint8_t>(verifier, VT_APPEND_FINAL_PERIOD) &&
           VerifyField<float>(verifier, VT_PRIORITY_SCORE) &&
           VerifyField<int32_t>(verifier, VT_MAX_NUM_WORDPIECES) &&
           VerifyField<int32_t>(verifier, VT_SLIDING_WINDOW_NUM_WORDPIECES_OVERLAP) &&
           VerifyOffset(verifier, VT_LABELS) &&
           verifier.VerifyVector(labels()) &&
           verifier.VerifyVectorOfTables(labels()) &&
           VerifyField<float>(verifier, VT_MAX_RATIO_UNKNOWN_WORDPIECES) &&
           VerifyOffset(verifier, VT_COLLECTIONS) &&
           verifier.VerifyVector(collections()) &&
           verifier.VerifyVectorOfTables(collections()) &&
           VerifyField<int32_t>(verifier, VT_MIN_NUMBER_OF_TOKENS) &&
           VerifyField<int32_t>(verifier, VT_MIN_NUMBER_OF_WORDPIECES) &&
           verifier.EndTable();
  }
  PodNerModelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PodNerModelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PodNerModel> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PodNerModelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PodNerModelBuilder {
  typedef PodNerModel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tflite_model(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> tflite_model) {
    fbb_.AddOffset(PodNerModel::VT_TFLITE_MODEL, tflite_model);
  }
  void add_word_piece_vocab(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> word_piece_vocab) {
    fbb_.AddOffset(PodNerModel::VT_WORD_PIECE_VOCAB, word_piece_vocab);
  }
  void add_lowercase_input(bool lowercase_input) {
    fbb_.AddElement<uint8_t>(PodNerModel::VT_LOWERCASE_INPUT, static_cast<uint8_t>(lowercase_input), 1);
  }
  void add_logits_index_in_output_tensor(int32_t logits_index_in_output_tensor) {
    fbb_.AddElement<int32_t>(PodNerModel::VT_LOGITS_INDEX_IN_OUTPUT_TENSOR, logits_index_in_output_tensor, 0);
  }
  void add_append_final_period(bool append_final_period) {
    fbb_.AddElement<uint8_t>(PodNerModel::VT_APPEND_FINAL_PERIOD, static_cast<uint8_t>(append_final_period), 0);
  }
  void add_priority_score(float priority_score) {
    fbb_.AddElement<float>(PodNerModel::VT_PRIORITY_SCORE, priority_score, 0.0f);
  }
  void add_max_num_wordpieces(int32_t max_num_wordpieces) {
    fbb_.AddElement<int32_t>(PodNerModel::VT_MAX_NUM_WORDPIECES, max_num_wordpieces, 128);
  }
  void add_sliding_window_num_wordpieces_overlap(int32_t sliding_window_num_wordpieces_overlap) {
    fbb_.AddElement<int32_t>(PodNerModel::VT_SLIDING_WINDOW_NUM_WORDPIECES_OVERLAP, sliding_window_num_wordpieces_overlap, 20);
  }
  void add_labels(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::PodNerModel_::Label>>> labels) {
    fbb_.AddOffset(PodNerModel::VT_LABELS, labels);
  }
  void add_max_ratio_unknown_wordpieces(float max_ratio_unknown_wordpieces) {
    fbb_.AddElement<float>(PodNerModel::VT_MAX_RATIO_UNKNOWN_WORDPIECES, max_ratio_unknown_wordpieces, 0.1f);
  }
  void add_collections(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::PodNerModel_::Collection>>> collections) {
    fbb_.AddOffset(PodNerModel::VT_COLLECTIONS, collections);
  }
  void add_min_number_of_tokens(int32_t min_number_of_tokens) {
    fbb_.AddElement<int32_t>(PodNerModel::VT_MIN_NUMBER_OF_TOKENS, min_number_of_tokens, 1);
  }
  void add_min_number_of_wordpieces(int32_t min_number_of_wordpieces) {
    fbb_.AddElement<int32_t>(PodNerModel::VT_MIN_NUMBER_OF_WORDPIECES, min_number_of_wordpieces, 1);
  }
  explicit PodNerModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PodNerModelBuilder &operator=(const PodNerModelBuilder &);
  flatbuffers::Offset<PodNerModel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PodNerModel>(end);
    return o;
  }
};

inline flatbuffers::Offset<PodNerModel> CreatePodNerModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> tflite_model = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> word_piece_vocab = 0,
    bool lowercase_input = true,
    int32_t logits_index_in_output_tensor = 0,
    bool append_final_period = false,
    float priority_score = 0.0f,
    int32_t max_num_wordpieces = 128,
    int32_t sliding_window_num_wordpieces_overlap = 20,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::PodNerModel_::Label>>> labels = 0,
    float max_ratio_unknown_wordpieces = 0.1f,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::PodNerModel_::Collection>>> collections = 0,
    int32_t min_number_of_tokens = 1,
    int32_t min_number_of_wordpieces = 1) {
  PodNerModelBuilder builder_(_fbb);
  builder_.add_min_number_of_wordpieces(min_number_of_wordpieces);
  builder_.add_min_number_of_tokens(min_number_of_tokens);
  builder_.add_collections(collections);
  builder_.add_max_ratio_unknown_wordpieces(max_ratio_unknown_wordpieces);
  builder_.add_labels(labels);
  builder_.add_sliding_window_num_wordpieces_overlap(sliding_window_num_wordpieces_overlap);
  builder_.add_max_num_wordpieces(max_num_wordpieces);
  builder_.add_priority_score(priority_score);
  builder_.add_logits_index_in_output_tensor(logits_index_in_output_tensor);
  builder_.add_word_piece_vocab(word_piece_vocab);
  builder_.add_tflite_model(tflite_model);
  builder_.add_append_final_period(append_final_period);
  builder_.add_lowercase_input(lowercase_input);
  return builder_.Finish();
}

inline flatbuffers::Offset<PodNerModel> CreatePodNerModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *tflite_model = nullptr,
    const std::vector<uint8_t> *word_piece_vocab = nullptr,
    bool lowercase_input = true,
    int32_t logits_index_in_output_tensor = 0,
    bool append_final_period = false,
    float priority_score = 0.0f,
    int32_t max_num_wordpieces = 128,
    int32_t sliding_window_num_wordpieces_overlap = 20,
    const std::vector<flatbuffers::Offset<libtextclassifier3::PodNerModel_::Label>> *labels = nullptr,
    float max_ratio_unknown_wordpieces = 0.1f,
    const std::vector<flatbuffers::Offset<libtextclassifier3::PodNerModel_::Collection>> *collections = nullptr,
    int32_t min_number_of_tokens = 1,
    int32_t min_number_of_wordpieces = 1) {
  auto tflite_model__ = tflite_model ? _fbb.CreateVector<uint8_t>(*tflite_model) : 0;
  auto word_piece_vocab__ = word_piece_vocab ? _fbb.CreateVector<uint8_t>(*word_piece_vocab) : 0;
  auto labels__ = labels ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::PodNerModel_::Label>>(*labels) : 0;
  auto collections__ = collections ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::PodNerModel_::Collection>>(*collections) : 0;
  return libtextclassifier3::CreatePodNerModel(
      _fbb,
      tflite_model__,
      word_piece_vocab__,
      lowercase_input,
      logits_index_in_output_tensor,
      append_final_period,
      priority_score,
      max_num_wordpieces,
      sliding_window_num_wordpieces_overlap,
      labels__,
      max_ratio_unknown_wordpieces,
      collections__,
      min_number_of_tokens,
      min_number_of_wordpieces);
}

flatbuffers::Offset<PodNerModel> CreatePodNerModel(flatbuffers::FlatBufferBuilder &_fbb, const PodNerModelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VocabModelT : public flatbuffers::NativeTable {
  typedef VocabModel TableType;
  std::vector<uint8_t> vocab_trie;
  std::unique_ptr<libtextclassifier3::BitVectorDataT> beginner_level;
  std::unique_ptr<libtextclassifier3::BitVectorDataT> do_not_trigger_in_upper_case;
  std::string triggering_locales;
  float target_classification_score;
  float priority_score;
  VocabModelT()
      : target_classification_score(1.0f),
        priority_score(0.0f) {
  }
};

struct VocabModel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VocabModelT NativeTableType;
  typedef VocabModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VOCAB_TRIE = 4,
    VT_BEGINNER_LEVEL = 6,
    VT_DO_NOT_TRIGGER_IN_UPPER_CASE = 8,
    VT_TRIGGERING_LOCALES = 10,
    VT_TARGET_CLASSIFICATION_SCORE = 12,
    VT_PRIORITY_SCORE = 14
  };
  const flatbuffers::Vector<uint8_t> *vocab_trie() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VOCAB_TRIE);
  }
  const libtextclassifier3::BitVectorData *beginner_level() const {
    return GetPointer<const libtextclassifier3::BitVectorData *>(VT_BEGINNER_LEVEL);
  }
  const libtextclassifier3::BitVectorData *do_not_trigger_in_upper_case() const {
    return GetPointer<const libtextclassifier3::BitVectorData *>(VT_DO_NOT_TRIGGER_IN_UPPER_CASE);
  }
  const flatbuffers::String *triggering_locales() const {
    return GetPointer<const flatbuffers::String *>(VT_TRIGGERING_LOCALES);
  }
  float target_classification_score() const {
    return GetField<float>(VT_TARGET_CLASSIFICATION_SCORE, 1.0f);
  }
  float priority_score() const {
    return GetField<float>(VT_PRIORITY_SCORE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VOCAB_TRIE) &&
           verifier.VerifyVector(vocab_trie()) &&
           VerifyOffset(verifier, VT_BEGINNER_LEVEL) &&
           verifier.VerifyTable(beginner_level()) &&
           VerifyOffset(verifier, VT_DO_NOT_TRIGGER_IN_UPPER_CASE) &&
           verifier.VerifyTable(do_not_trigger_in_upper_case()) &&
           VerifyOffset(verifier, VT_TRIGGERING_LOCALES) &&
           verifier.VerifyString(triggering_locales()) &&
           VerifyField<float>(verifier, VT_TARGET_CLASSIFICATION_SCORE) &&
           VerifyField<float>(verifier, VT_PRIORITY_SCORE) &&
           verifier.EndTable();
  }
  VocabModelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VocabModelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<VocabModel> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VocabModelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VocabModelBuilder {
  typedef VocabModel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_vocab_trie(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> vocab_trie) {
    fbb_.AddOffset(VocabModel::VT_VOCAB_TRIE, vocab_trie);
  }
  void add_beginner_level(flatbuffers::Offset<libtextclassifier3::BitVectorData> beginner_level) {
    fbb_.AddOffset(VocabModel::VT_BEGINNER_LEVEL, beginner_level);
  }
  void add_do_not_trigger_in_upper_case(flatbuffers::Offset<libtextclassifier3::BitVectorData> do_not_trigger_in_upper_case) {
    fbb_.AddOffset(VocabModel::VT_DO_NOT_TRIGGER_IN_UPPER_CASE, do_not_trigger_in_upper_case);
  }
  void add_triggering_locales(flatbuffers::Offset<flatbuffers::String> triggering_locales) {
    fbb_.AddOffset(VocabModel::VT_TRIGGERING_LOCALES, triggering_locales);
  }
  void add_target_classification_score(float target_classification_score) {
    fbb_.AddElement<float>(VocabModel::VT_TARGET_CLASSIFICATION_SCORE, target_classification_score, 1.0f);
  }
  void add_priority_score(float priority_score) {
    fbb_.AddElement<float>(VocabModel::VT_PRIORITY_SCORE, priority_score, 0.0f);
  }
  explicit VocabModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VocabModelBuilder &operator=(const VocabModelBuilder &);
  flatbuffers::Offset<VocabModel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VocabModel>(end);
    return o;
  }
};

inline flatbuffers::Offset<VocabModel> CreateVocabModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> vocab_trie = 0,
    flatbuffers::Offset<libtextclassifier3::BitVectorData> beginner_level = 0,
    flatbuffers::Offset<libtextclassifier3::BitVectorData> do_not_trigger_in_upper_case = 0,
    flatbuffers::Offset<flatbuffers::String> triggering_locales = 0,
    float target_classification_score = 1.0f,
    float priority_score = 0.0f) {
  VocabModelBuilder builder_(_fbb);
  builder_.add_priority_score(priority_score);
  builder_.add_target_classification_score(target_classification_score);
  builder_.add_triggering_locales(triggering_locales);
  builder_.add_do_not_trigger_in_upper_case(do_not_trigger_in_upper_case);
  builder_.add_beginner_level(beginner_level);
  builder_.add_vocab_trie(vocab_trie);
  return builder_.Finish();
}

inline flatbuffers::Offset<VocabModel> CreateVocabModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *vocab_trie = nullptr,
    flatbuffers::Offset<libtextclassifier3::BitVectorData> beginner_level = 0,
    flatbuffers::Offset<libtextclassifier3::BitVectorData> do_not_trigger_in_upper_case = 0,
    const char *triggering_locales = nullptr,
    float target_classification_score = 1.0f,
    float priority_score = 0.0f) {
  if (vocab_trie) { _fbb.ForceVectorAlignment(vocab_trie->size(), sizeof(uint8_t), 8); }
  auto vocab_trie__ = vocab_trie ? _fbb.CreateVector<uint8_t>(*vocab_trie) : 0;
  auto triggering_locales__ = triggering_locales ? _fbb.CreateSharedString(triggering_locales) : 0;
  return libtextclassifier3::CreateVocabModel(
      _fbb,
      vocab_trie__,
      beginner_level,
      do_not_trigger_in_upper_case,
      triggering_locales__,
      target_classification_score,
      priority_score);
}

flatbuffers::Offset<VocabModel> CreateVocabModel(flatbuffers::FlatBufferBuilder &_fbb, const VocabModelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline SelectionModelOptionsT *SelectionModelOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::SelectionModelOptionsT> _o = std::unique_ptr<libtextclassifier3::SelectionModelOptionsT>(new SelectionModelOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SelectionModelOptions::UnPackTo(SelectionModelOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = strip_unpaired_brackets(); _o->strip_unpaired_brackets = _e; }
  { auto _e = symmetry_context_size(); _o->symmetry_context_size = _e; }
  { auto _e = batch_size(); _o->batch_size = _e; }
  { auto _e = always_classify_suggested_selection(); _o->always_classify_suggested_selection = _e; }
}

inline flatbuffers::Offset<SelectionModelOptions> SelectionModelOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectionModelOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSelectionModelOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SelectionModelOptions> CreateSelectionModelOptions(flatbuffers::FlatBufferBuilder &_fbb, const SelectionModelOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SelectionModelOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _strip_unpaired_brackets = _o->strip_unpaired_brackets;
  auto _symmetry_context_size = _o->symmetry_context_size;
  auto _batch_size = _o->batch_size;
  auto _always_classify_suggested_selection = _o->always_classify_suggested_selection;
  return libtextclassifier3::CreateSelectionModelOptions(
      _fbb,
      _strip_unpaired_brackets,
      _symmetry_context_size,
      _batch_size,
      _always_classify_suggested_selection);
}

inline ClassificationModelOptionsT *ClassificationModelOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::ClassificationModelOptionsT> _o = std::unique_ptr<libtextclassifier3::ClassificationModelOptionsT>(new ClassificationModelOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ClassificationModelOptions::UnPackTo(ClassificationModelOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = phone_min_num_digits(); _o->phone_min_num_digits = _e; }
  { auto _e = phone_max_num_digits(); _o->phone_max_num_digits = _e; }
  { auto _e = address_min_num_tokens(); _o->address_min_num_tokens = _e; }
  { auto _e = max_num_tokens(); _o->max_num_tokens = _e; }
}

inline flatbuffers::Offset<ClassificationModelOptions> ClassificationModelOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ClassificationModelOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateClassificationModelOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ClassificationModelOptions> CreateClassificationModelOptions(flatbuffers::FlatBufferBuilder &_fbb, const ClassificationModelOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ClassificationModelOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _phone_min_num_digits = _o->phone_min_num_digits;
  auto _phone_max_num_digits = _o->phone_max_num_digits;
  auto _address_min_num_tokens = _o->address_min_num_tokens;
  auto _max_num_tokens = _o->max_num_tokens;
  return libtextclassifier3::CreateClassificationModelOptions(
      _fbb,
      _phone_min_num_digits,
      _phone_max_num_digits,
      _address_min_num_tokens,
      _max_num_tokens);
}

inline VerificationOptionsT *VerificationOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::VerificationOptionsT> _o = std::unique_ptr<libtextclassifier3::VerificationOptionsT>(new VerificationOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void VerificationOptions::UnPackTo(VerificationOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = verify_luhn_checksum(); _o->verify_luhn_checksum = _e; }
  { auto _e = lua_verifier(); _o->lua_verifier = _e; }
}

inline flatbuffers::Offset<VerificationOptions> VerificationOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VerificationOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVerificationOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<VerificationOptions> CreateVerificationOptions(flatbuffers::FlatBufferBuilder &_fbb, const VerificationOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VerificationOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _verify_luhn_checksum = _o->verify_luhn_checksum;
  auto _lua_verifier = _o->lua_verifier;
  return libtextclassifier3::CreateVerificationOptions(
      _fbb,
      _verify_luhn_checksum,
      _lua_verifier);
}

inline CapturingGroupT *CapturingGroup::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::CapturingGroupT> _o = std::unique_ptr<libtextclassifier3::CapturingGroupT>(new CapturingGroupT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CapturingGroup::UnPackTo(CapturingGroupT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = extend_selection(); _o->extend_selection = _e; }
  { auto _e = entity_field_path(); if (_e) _o->entity_field_path = std::unique_ptr<libtextclassifier3::FlatbufferFieldPathT>(_e->UnPack(_resolver)); }
  { auto _e = serialized_entity_data(); if (_e) _o->serialized_entity_data = _e->str(); }
  { auto _e = normalization_options(); if (_e) _o->normalization_options = std::unique_ptr<libtextclassifier3::NormalizationOptionsT>(_e->UnPack(_resolver)); }
  { auto _e = entity_data(); if (_e) _o->entity_data = std::unique_ptr<libtextclassifier3::EntityDataT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<CapturingGroup> CapturingGroup::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CapturingGroupT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCapturingGroup(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CapturingGroup> CreateCapturingGroup(flatbuffers::FlatBufferBuilder &_fbb, const CapturingGroupT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CapturingGroupT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _extend_selection = _o->extend_selection;
  auto _entity_field_path = _o->entity_field_path ? CreateFlatbufferFieldPath(_fbb, _o->entity_field_path.get(), _rehasher) : 0;
  auto _serialized_entity_data = _o->serialized_entity_data.empty() ? 0 : _fbb.CreateSharedString(_o->serialized_entity_data);
  auto _normalization_options = _o->normalization_options ? CreateNormalizationOptions(_fbb, _o->normalization_options.get(), _rehasher) : 0;
  auto _entity_data = _o->entity_data ? CreateEntityData(_fbb, _o->entity_data.get(), _rehasher) : 0;
  return libtextclassifier3::CreateCapturingGroup(
      _fbb,
      _extend_selection,
      _entity_field_path,
      _serialized_entity_data,
      _normalization_options,
      _entity_data);
}

namespace RegexModel_ {

inline PatternT *Pattern::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::RegexModel_::PatternT> _o = std::unique_ptr<libtextclassifier3::RegexModel_::PatternT>(new PatternT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pattern::UnPackTo(PatternT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = collection_name(); if (_e) _o->collection_name = _e->str(); }
  { auto _e = pattern(); if (_e) _o->pattern = _e->str(); }
  { auto _e = enabled_modes(); _o->enabled_modes = _e; }
  { auto _e = target_classification_score(); _o->target_classification_score = _e; }
  { auto _e = priority_score(); _o->priority_score = _e; }
  { auto _e = use_approximate_matching(); _o->use_approximate_matching = _e; }
  { auto _e = compressed_pattern(); if (_e) _o->compressed_pattern = std::unique_ptr<libtextclassifier3::CompressedBufferT>(_e->UnPack(_resolver)); }
  { auto _e = verification_options(); if (_e) _o->verification_options = std::unique_ptr<libtextclassifier3::VerificationOptionsT>(_e->UnPack(_resolver)); }
  { auto _e = capturing_group(); if (_e) { _o->capturing_group.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->capturing_group[_i] = std::unique_ptr<libtextclassifier3::CapturingGroupT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = serialized_entity_data(); if (_e) _o->serialized_entity_data = _e->str(); }
  { auto _e = entity_data(); if (_e) _o->entity_data = std::unique_ptr<libtextclassifier3::EntityDataT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<Pattern> Pattern::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PatternT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePattern(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pattern> CreatePattern(flatbuffers::FlatBufferBuilder &_fbb, const PatternT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PatternT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _collection_name = _o->collection_name.empty() ? 0 : _fbb.CreateSharedString(_o->collection_name);
  auto _pattern = _o->pattern.empty() ? 0 : _fbb.CreateSharedString(_o->pattern);
  auto _enabled_modes = _o->enabled_modes;
  auto _target_classification_score = _o->target_classification_score;
  auto _priority_score = _o->priority_score;
  auto _use_approximate_matching = _o->use_approximate_matching;
  auto _compressed_pattern = _o->compressed_pattern ? CreateCompressedBuffer(_fbb, _o->compressed_pattern.get(), _rehasher) : 0;
  auto _verification_options = _o->verification_options ? CreateVerificationOptions(_fbb, _o->verification_options.get(), _rehasher) : 0;
  auto _capturing_group = _o->capturing_group.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::CapturingGroup>> (_o->capturing_group.size(), [](size_t i, _VectorArgs *__va) { return CreateCapturingGroup(*__va->__fbb, __va->__o->capturing_group[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _serialized_entity_data = _o->serialized_entity_data.empty() ? 0 : _fbb.CreateSharedString(_o->serialized_entity_data);
  auto _entity_data = _o->entity_data ? CreateEntityData(_fbb, _o->entity_data.get(), _rehasher) : 0;
  return libtextclassifier3::RegexModel_::CreatePattern(
      _fbb,
      _collection_name,
      _pattern,
      _enabled_modes,
      _target_classification_score,
      _priority_score,
      _use_approximate_matching,
      _compressed_pattern,
      _verification_options,
      _capturing_group,
      _serialized_entity_data,
      _entity_data);
}

}  // namespace RegexModel_

inline RegexModelT *RegexModel::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::RegexModelT> _o = std::unique_ptr<libtextclassifier3::RegexModelT>(new RegexModelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RegexModel::UnPackTo(RegexModelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = patterns(); if (_e) { _o->patterns.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->patterns[_i] = std::unique_ptr<libtextclassifier3::RegexModel_::PatternT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = lazy_regex_compilation(); _o->lazy_regex_compilation = _e; }
  { auto _e = lua_verifier(); if (_e) { _o->lua_verifier.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->lua_verifier[_i] = _e->Get(_i)->str(); } } }
}

inline flatbuffers::Offset<RegexModel> RegexModel::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegexModelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRegexModel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RegexModel> CreateRegexModel(flatbuffers::FlatBufferBuilder &_fbb, const RegexModelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RegexModelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _patterns = _o->patterns.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::RegexModel_::Pattern>> (_o->patterns.size(), [](size_t i, _VectorArgs *__va) { return CreatePattern(*__va->__fbb, __va->__o->patterns[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _lazy_regex_compilation = _o->lazy_regex_compilation;
  auto _lua_verifier = _o->lua_verifier.size() ? _fbb.CreateVectorOfStrings(_o->lua_verifier) : 0;
  return libtextclassifier3::CreateRegexModel(
      _fbb,
      _patterns,
      _lazy_regex_compilation,
      _lua_verifier);
}

namespace DatetimeModelPattern_ {

inline RegexT *Regex::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::DatetimeModelPattern_::RegexT> _o = std::unique_ptr<libtextclassifier3::DatetimeModelPattern_::RegexT>(new RegexT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Regex::UnPackTo(RegexT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pattern(); if (_e) _o->pattern = _e->str(); }
  { auto _e = groups(); if (_e) { _o->groups.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->groups[_i] = static_cast<libtextclassifier3::DatetimeGroupType>(_e->Get(_i)); } } }
  { auto _e = compressed_pattern(); if (_e) _o->compressed_pattern = std::unique_ptr<libtextclassifier3::CompressedBufferT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<Regex> Regex::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegexT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRegex(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Regex> CreateRegex(flatbuffers::FlatBufferBuilder &_fbb, const RegexT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RegexT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pattern = _o->pattern.empty() ? 0 : _fbb.CreateSharedString(_o->pattern);
  auto _groups = _o->groups.size() ? _fbb.CreateVectorScalarCast<int32_t>(flatbuffers::data(_o->groups), _o->groups.size()) : 0;
  auto _compressed_pattern = _o->compressed_pattern ? CreateCompressedBuffer(_fbb, _o->compressed_pattern.get(), _rehasher) : 0;
  return libtextclassifier3::DatetimeModelPattern_::CreateRegex(
      _fbb,
      _pattern,
      _groups,
      _compressed_pattern);
}

}  // namespace DatetimeModelPattern_

inline DatetimeModelPatternT *DatetimeModelPattern::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::DatetimeModelPatternT> _o = std::unique_ptr<libtextclassifier3::DatetimeModelPatternT>(new DatetimeModelPatternT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DatetimeModelPattern::UnPackTo(DatetimeModelPatternT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = regexes(); if (_e) { _o->regexes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->regexes[_i] = std::unique_ptr<libtextclassifier3::DatetimeModelPattern_::RegexT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = locales(); if (_e) { _o->locales.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->locales[_i] = _e->Get(_i); } } }
  { auto _e = target_classification_score(); _o->target_classification_score = _e; }
  { auto _e = priority_score(); _o->priority_score = _e; }
  { auto _e = enabled_modes(); _o->enabled_modes = _e; }
  { auto _e = enabled_annotation_usecases(); _o->enabled_annotation_usecases = _e; }
}

inline flatbuffers::Offset<DatetimeModelPattern> DatetimeModelPattern::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DatetimeModelPatternT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDatetimeModelPattern(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DatetimeModelPattern> CreateDatetimeModelPattern(flatbuffers::FlatBufferBuilder &_fbb, const DatetimeModelPatternT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DatetimeModelPatternT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _regexes = _o->regexes.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::DatetimeModelPattern_::Regex>> (_o->regexes.size(), [](size_t i, _VectorArgs *__va) { return CreateRegex(*__va->__fbb, __va->__o->regexes[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _locales = _o->locales.size() ? _fbb.CreateVector(_o->locales) : 0;
  auto _target_classification_score = _o->target_classification_score;
  auto _priority_score = _o->priority_score;
  auto _enabled_modes = _o->enabled_modes;
  auto _enabled_annotation_usecases = _o->enabled_annotation_usecases;
  return libtextclassifier3::CreateDatetimeModelPattern(
      _fbb,
      _regexes,
      _locales,
      _target_classification_score,
      _priority_score,
      _enabled_modes,
      _enabled_annotation_usecases);
}

inline DatetimeModelExtractorT *DatetimeModelExtractor::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::DatetimeModelExtractorT> _o = std::unique_ptr<libtextclassifier3::DatetimeModelExtractorT>(new DatetimeModelExtractorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DatetimeModelExtractor::UnPackTo(DatetimeModelExtractorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = extractor(); _o->extractor = _e; }
  { auto _e = pattern(); if (_e) _o->pattern = _e->str(); }
  { auto _e = locales(); if (_e) { _o->locales.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->locales[_i] = _e->Get(_i); } } }
  { auto _e = compressed_pattern(); if (_e) _o->compressed_pattern = std::unique_ptr<libtextclassifier3::CompressedBufferT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<DatetimeModelExtractor> DatetimeModelExtractor::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DatetimeModelExtractorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDatetimeModelExtractor(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DatetimeModelExtractor> CreateDatetimeModelExtractor(flatbuffers::FlatBufferBuilder &_fbb, const DatetimeModelExtractorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DatetimeModelExtractorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _extractor = _o->extractor;
  auto _pattern = _o->pattern.empty() ? 0 : _fbb.CreateSharedString(_o->pattern);
  auto _locales = _o->locales.size() ? _fbb.CreateVector(_o->locales) : 0;
  auto _compressed_pattern = _o->compressed_pattern ? CreateCompressedBuffer(_fbb, _o->compressed_pattern.get(), _rehasher) : 0;
  return libtextclassifier3::CreateDatetimeModelExtractor(
      _fbb,
      _extractor,
      _pattern,
      _locales,
      _compressed_pattern);
}

inline DatetimeModelT *DatetimeModel::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::DatetimeModelT> _o = std::unique_ptr<libtextclassifier3::DatetimeModelT>(new DatetimeModelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DatetimeModel::UnPackTo(DatetimeModelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = locales(); if (_e) { _o->locales.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->locales[_i] = _e->Get(_i)->str(); } } }
  { auto _e = patterns(); if (_e) { _o->patterns.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->patterns[_i] = std::unique_ptr<libtextclassifier3::DatetimeModelPatternT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = extractors(); if (_e) { _o->extractors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->extractors[_i] = std::unique_ptr<libtextclassifier3::DatetimeModelExtractorT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = use_extractors_for_locating(); _o->use_extractors_for_locating = _e; }
  { auto _e = default_locales(); if (_e) { _o->default_locales.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->default_locales[_i] = _e->Get(_i); } } }
  { auto _e = generate_alternative_interpretations_when_ambiguous(); _o->generate_alternative_interpretations_when_ambiguous = _e; }
  { auto _e = lazy_regex_compilation(); _o->lazy_regex_compilation = _e; }
  { auto _e = prefer_future_for_unspecified_date(); _o->prefer_future_for_unspecified_date = _e; }
}

inline flatbuffers::Offset<DatetimeModel> DatetimeModel::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DatetimeModelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDatetimeModel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DatetimeModel> CreateDatetimeModel(flatbuffers::FlatBufferBuilder &_fbb, const DatetimeModelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DatetimeModelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _locales = _o->locales.size() ? _fbb.CreateVectorOfStrings(_o->locales) : 0;
  auto _patterns = _o->patterns.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::DatetimeModelPattern>> (_o->patterns.size(), [](size_t i, _VectorArgs *__va) { return CreateDatetimeModelPattern(*__va->__fbb, __va->__o->patterns[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _extractors = _o->extractors.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::DatetimeModelExtractor>> (_o->extractors.size(), [](size_t i, _VectorArgs *__va) { return CreateDatetimeModelExtractor(*__va->__fbb, __va->__o->extractors[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _use_extractors_for_locating = _o->use_extractors_for_locating;
  auto _default_locales = _o->default_locales.size() ? _fbb.CreateVector(_o->default_locales) : 0;
  auto _generate_alternative_interpretations_when_ambiguous = _o->generate_alternative_interpretations_when_ambiguous;
  auto _lazy_regex_compilation = _o->lazy_regex_compilation;
  auto _prefer_future_for_unspecified_date = _o->prefer_future_for_unspecified_date;
  return libtextclassifier3::CreateDatetimeModel(
      _fbb,
      _locales,
      _patterns,
      _extractors,
      _use_extractors_for_locating,
      _default_locales,
      _generate_alternative_interpretations_when_ambiguous,
      _lazy_regex_compilation,
      _prefer_future_for_unspecified_date);
}

inline GrammarTokenizerOptionsT *GrammarTokenizerOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::GrammarTokenizerOptionsT> _o = std::unique_ptr<libtextclassifier3::GrammarTokenizerOptionsT>(new GrammarTokenizerOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GrammarTokenizerOptions::UnPackTo(GrammarTokenizerOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tokenization_type(); _o->tokenization_type = _e; }
  { auto _e = icu_preserve_whitespace_tokens(); _o->icu_preserve_whitespace_tokens = _e; }
  { auto _e = tokenization_codepoint_config(); if (_e) { _o->tokenization_codepoint_config.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tokenization_codepoint_config[_i] = std::unique_ptr<libtextclassifier3::TokenizationCodepointRangeT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = internal_tokenizer_codepoint_ranges(); if (_e) { _o->internal_tokenizer_codepoint_ranges.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->internal_tokenizer_codepoint_ranges[_i] = std::unique_ptr<libtextclassifier3::CodepointRangeT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = tokenize_on_script_change(); _o->tokenize_on_script_change = _e; }
}

inline flatbuffers::Offset<GrammarTokenizerOptions> GrammarTokenizerOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GrammarTokenizerOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGrammarTokenizerOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GrammarTokenizerOptions> CreateGrammarTokenizerOptions(flatbuffers::FlatBufferBuilder &_fbb, const GrammarTokenizerOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GrammarTokenizerOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tokenization_type = _o->tokenization_type;
  auto _icu_preserve_whitespace_tokens = _o->icu_preserve_whitespace_tokens;
  auto _tokenization_codepoint_config = _o->tokenization_codepoint_config.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::TokenizationCodepointRange>> (_o->tokenization_codepoint_config.size(), [](size_t i, _VectorArgs *__va) { return CreateTokenizationCodepointRange(*__va->__fbb, __va->__o->tokenization_codepoint_config[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _internal_tokenizer_codepoint_ranges = _o->internal_tokenizer_codepoint_ranges.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::CodepointRange>> (_o->internal_tokenizer_codepoint_ranges.size(), [](size_t i, _VectorArgs *__va) { return CreateCodepointRange(*__va->__fbb, __va->__o->internal_tokenizer_codepoint_ranges[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _tokenize_on_script_change = _o->tokenize_on_script_change;
  return libtextclassifier3::CreateGrammarTokenizerOptions(
      _fbb,
      _tokenization_type,
      _icu_preserve_whitespace_tokens,
      _tokenization_codepoint_config,
      _internal_tokenizer_codepoint_ranges,
      _tokenize_on_script_change);
}

namespace DatetimeModelLibrary_ {

inline ItemT *Item::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::DatetimeModelLibrary_::ItemT> _o = std::unique_ptr<libtextclassifier3::DatetimeModelLibrary_::ItemT>(new ItemT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Item::UnPackTo(ItemT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = key(); if (_e) _o->key = _e->str(); }
  { auto _e = value(); if (_e) _o->value = std::unique_ptr<libtextclassifier3::DatetimeModelT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<Item> Item::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ItemT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateItem(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Item> CreateItem(flatbuffers::FlatBufferBuilder &_fbb, const ItemT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ItemT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _key = _o->key.empty() ? 0 : _fbb.CreateSharedString(_o->key);
  auto _value = _o->value ? CreateDatetimeModel(_fbb, _o->value.get(), _rehasher) : 0;
  return libtextclassifier3::DatetimeModelLibrary_::CreateItem(
      _fbb,
      _key,
      _value);
}

}  // namespace DatetimeModelLibrary_

inline DatetimeModelLibraryT *DatetimeModelLibrary::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::DatetimeModelLibraryT> _o = std::unique_ptr<libtextclassifier3::DatetimeModelLibraryT>(new DatetimeModelLibraryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DatetimeModelLibrary::UnPackTo(DatetimeModelLibraryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = models(); if (_e) { _o->models.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->models[_i] = std::unique_ptr<libtextclassifier3::DatetimeModelLibrary_::ItemT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<DatetimeModelLibrary> DatetimeModelLibrary::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DatetimeModelLibraryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDatetimeModelLibrary(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DatetimeModelLibrary> CreateDatetimeModelLibrary(flatbuffers::FlatBufferBuilder &_fbb, const DatetimeModelLibraryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DatetimeModelLibraryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _models = _o->models.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::DatetimeModelLibrary_::Item>> (_o->models.size(), [](size_t i, _VectorArgs *__va) { return CreateItem(*__va->__fbb, __va->__o->models[i].get(), __va->__rehasher); }, &_va ) : 0;
  return libtextclassifier3::CreateDatetimeModelLibrary(
      _fbb,
      _models);
}

namespace GrammarModel_ {

inline RuleClassificationResultT *RuleClassificationResult::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::GrammarModel_::RuleClassificationResultT> _o = std::unique_ptr<libtextclassifier3::GrammarModel_::RuleClassificationResultT>(new RuleClassificationResultT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RuleClassificationResult::UnPackTo(RuleClassificationResultT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = collection_name(); if (_e) _o->collection_name = _e->str(); }
  { auto _e = target_classification_score(); _o->target_classification_score = _e; }
  { auto _e = priority_score(); _o->priority_score = _e; }
  { auto _e = capturing_group(); if (_e) { _o->capturing_group.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->capturing_group[_i] = std::unique_ptr<libtextclassifier3::CapturingGroupT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = serialized_entity_data(); if (_e) _o->serialized_entity_data = _e->str(); }
  { auto _e = enabled_modes(); _o->enabled_modes = _e; }
  { auto _e = entity_data(); if (_e) _o->entity_data = std::unique_ptr<libtextclassifier3::EntityDataT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<RuleClassificationResult> RuleClassificationResult::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RuleClassificationResultT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRuleClassificationResult(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RuleClassificationResult> CreateRuleClassificationResult(flatbuffers::FlatBufferBuilder &_fbb, const RuleClassificationResultT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RuleClassificationResultT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _collection_name = _o->collection_name.empty() ? 0 : _fbb.CreateSharedString(_o->collection_name);
  auto _target_classification_score = _o->target_classification_score;
  auto _priority_score = _o->priority_score;
  auto _capturing_group = _o->capturing_group.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::CapturingGroup>> (_o->capturing_group.size(), [](size_t i, _VectorArgs *__va) { return CreateCapturingGroup(*__va->__fbb, __va->__o->capturing_group[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _serialized_entity_data = _o->serialized_entity_data.empty() ? 0 : _fbb.CreateSharedString(_o->serialized_entity_data);
  auto _enabled_modes = _o->enabled_modes;
  auto _entity_data = _o->entity_data ? CreateEntityData(_fbb, _o->entity_data.get(), _rehasher) : 0;
  return libtextclassifier3::GrammarModel_::CreateRuleClassificationResult(
      _fbb,
      _collection_name,
      _target_classification_score,
      _priority_score,
      _capturing_group,
      _serialized_entity_data,
      _enabled_modes,
      _entity_data);
}

}  // namespace GrammarModel_

inline GrammarModelT *GrammarModel::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::GrammarModelT> _o = std::unique_ptr<libtextclassifier3::GrammarModelT>(new GrammarModelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GrammarModel::UnPackTo(GrammarModelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rules(); if (_e) _o->rules = std::unique_ptr<libtextclassifier3::grammar::RulesSetT>(_e->UnPack(_resolver)); }
  { auto _e = rule_classification_result(); if (_e) { _o->rule_classification_result.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rule_classification_result[_i] = std::unique_ptr<libtextclassifier3::GrammarModel_::RuleClassificationResultT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = context_left_num_tokens(); _o->context_left_num_tokens = _e; }
  { auto _e = context_right_num_tokens(); _o->context_right_num_tokens = _e; }
  { auto _e = tokenizer_options(); if (_e) _o->tokenizer_options = std::unique_ptr<libtextclassifier3::GrammarTokenizerOptionsT>(_e->UnPack(_resolver)); }
  { auto _e = target_classification_score(); _o->target_classification_score = _e; }
  { auto _e = priority_score(); _o->priority_score = _e; }
}

inline flatbuffers::Offset<GrammarModel> GrammarModel::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GrammarModelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGrammarModel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GrammarModel> CreateGrammarModel(flatbuffers::FlatBufferBuilder &_fbb, const GrammarModelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GrammarModelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rules = _o->rules ? CreateRulesSet(_fbb, _o->rules.get(), _rehasher) : 0;
  auto _rule_classification_result = _o->rule_classification_result.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::GrammarModel_::RuleClassificationResult>> (_o->rule_classification_result.size(), [](size_t i, _VectorArgs *__va) { return CreateRuleClassificationResult(*__va->__fbb, __va->__o->rule_classification_result[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _context_left_num_tokens = _o->context_left_num_tokens;
  auto _context_right_num_tokens = _o->context_right_num_tokens;
  auto _tokenizer_options = _o->tokenizer_options ? CreateGrammarTokenizerOptions(_fbb, _o->tokenizer_options.get(), _rehasher) : 0;
  auto _target_classification_score = _o->target_classification_score;
  auto _priority_score = _o->priority_score;
  return libtextclassifier3::CreateGrammarModel(
      _fbb,
      _rules,
      _rule_classification_result,
      _context_left_num_tokens,
      _context_right_num_tokens,
      _tokenizer_options,
      _target_classification_score,
      _priority_score);
}

namespace MoneyParsingOptions_ {

inline QuantitiesNameToExponentEntryT *QuantitiesNameToExponentEntry::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::MoneyParsingOptions_::QuantitiesNameToExponentEntryT> _o = std::unique_ptr<libtextclassifier3::MoneyParsingOptions_::QuantitiesNameToExponentEntryT>(new QuantitiesNameToExponentEntryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void QuantitiesNameToExponentEntry::UnPackTo(QuantitiesNameToExponentEntryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = key(); if (_e) _o->key = _e->str(); }
  { auto _e = value(); _o->value = _e; }
}

inline flatbuffers::Offset<QuantitiesNameToExponentEntry> QuantitiesNameToExponentEntry::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantitiesNameToExponentEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuantitiesNameToExponentEntry(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QuantitiesNameToExponentEntry> CreateQuantitiesNameToExponentEntry(flatbuffers::FlatBufferBuilder &_fbb, const QuantitiesNameToExponentEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuantitiesNameToExponentEntryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _key = _fbb.CreateSharedString(_o->key);
  auto _value = _o->value;
  return libtextclassifier3::MoneyParsingOptions_::CreateQuantitiesNameToExponentEntry(
      _fbb,
      _key,
      _value);
}

}  // namespace MoneyParsingOptions_

inline MoneyParsingOptionsT *MoneyParsingOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::MoneyParsingOptionsT> _o = std::unique_ptr<libtextclassifier3::MoneyParsingOptionsT>(new MoneyParsingOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MoneyParsingOptions::UnPackTo(MoneyParsingOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = separators(); if (_e) { _o->separators.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->separators[_i] = _e->Get(_i); } } }
  { auto _e = quantities_name_to_exponent(); if (_e) { _o->quantities_name_to_exponent.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->quantities_name_to_exponent[_i] = std::unique_ptr<libtextclassifier3::MoneyParsingOptions_::QuantitiesNameToExponentEntryT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<MoneyParsingOptions> MoneyParsingOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoneyParsingOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMoneyParsingOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MoneyParsingOptions> CreateMoneyParsingOptions(flatbuffers::FlatBufferBuilder &_fbb, const MoneyParsingOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MoneyParsingOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _separators = _o->separators.size() ? _fbb.CreateVector(_o->separators) : 0;
  auto _quantities_name_to_exponent = _o->quantities_name_to_exponent.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::MoneyParsingOptions_::QuantitiesNameToExponentEntry>> (_o->quantities_name_to_exponent.size(), [](size_t i, _VectorArgs *__va) { return CreateQuantitiesNameToExponentEntry(*__va->__fbb, __va->__o->quantities_name_to_exponent[i].get(), __va->__rehasher); }, &_va ) : 0;
  return libtextclassifier3::CreateMoneyParsingOptions(
      _fbb,
      _separators,
      _quantities_name_to_exponent);
}

namespace ModelTriggeringOptions_ {

inline CollectionToPriorityEntryT *CollectionToPriorityEntry::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::ModelTriggeringOptions_::CollectionToPriorityEntryT> _o = std::unique_ptr<libtextclassifier3::ModelTriggeringOptions_::CollectionToPriorityEntryT>(new CollectionToPriorityEntryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CollectionToPriorityEntry::UnPackTo(CollectionToPriorityEntryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = key(); if (_e) _o->key = _e->str(); }
  { auto _e = value(); _o->value = _e; }
}

inline flatbuffers::Offset<CollectionToPriorityEntry> CollectionToPriorityEntry::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CollectionToPriorityEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCollectionToPriorityEntry(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CollectionToPriorityEntry> CreateCollectionToPriorityEntry(flatbuffers::FlatBufferBuilder &_fbb, const CollectionToPriorityEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CollectionToPriorityEntryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _key = _fbb.CreateSharedString(_o->key);
  auto _value = _o->value;
  return libtextclassifier3::ModelTriggeringOptions_::CreateCollectionToPriorityEntry(
      _fbb,
      _key,
      _value);
}

}  // namespace ModelTriggeringOptions_

inline ModelTriggeringOptionsT *ModelTriggeringOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::ModelTriggeringOptionsT> _o = std::unique_ptr<libtextclassifier3::ModelTriggeringOptionsT>(new ModelTriggeringOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ModelTriggeringOptions::UnPackTo(ModelTriggeringOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = min_annotate_confidence(); _o->min_annotate_confidence = _e; }
  { auto _e = enabled_modes(); _o->enabled_modes = _e; }
  { auto _e = dictionary_locales(); if (_e) _o->dictionary_locales = _e->str(); }
  { auto _e = locales(); if (_e) _o->locales = _e->str(); }
  { auto _e = other_collection_priority_score(); _o->other_collection_priority_score = _e; }
  { auto _e = knowledge_priority_score(); _o->knowledge_priority_score = _e; }
  { auto _e = collection_to_priority(); if (_e) { _o->collection_to_priority.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->collection_to_priority[_i] = std::unique_ptr<libtextclassifier3::ModelTriggeringOptions_::CollectionToPriorityEntryT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<ModelTriggeringOptions> ModelTriggeringOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelTriggeringOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateModelTriggeringOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ModelTriggeringOptions> CreateModelTriggeringOptions(flatbuffers::FlatBufferBuilder &_fbb, const ModelTriggeringOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ModelTriggeringOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _min_annotate_confidence = _o->min_annotate_confidence;
  auto _enabled_modes = _o->enabled_modes;
  auto _dictionary_locales = _o->dictionary_locales.empty() ? 0 : _fbb.CreateSharedString(_o->dictionary_locales);
  auto _locales = _o->locales.empty() ? 0 : _fbb.CreateSharedString(_o->locales);
  auto _other_collection_priority_score = _o->other_collection_priority_score;
  auto _knowledge_priority_score = _o->knowledge_priority_score;
  auto _collection_to_priority = _o->collection_to_priority.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::ModelTriggeringOptions_::CollectionToPriorityEntry>> (_o->collection_to_priority.size(), [](size_t i, _VectorArgs *__va) { return CreateCollectionToPriorityEntry(*__va->__fbb, __va->__o->collection_to_priority[i].get(), __va->__rehasher); }, &_va ) : 0;
  return libtextclassifier3::CreateModelTriggeringOptions(
      _fbb,
      _min_annotate_confidence,
      _enabled_modes,
      _dictionary_locales,
      _locales,
      _other_collection_priority_score,
      _knowledge_priority_score,
      _collection_to_priority);
}

inline OutputOptionsT *OutputOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::OutputOptionsT> _o = std::unique_ptr<libtextclassifier3::OutputOptionsT>(new OutputOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OutputOptions::UnPackTo(OutputOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = filtered_collections_annotation(); if (_e) { _o->filtered_collections_annotation.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->filtered_collections_annotation[_i] = _e->Get(_i)->str(); } } }
  { auto _e = filtered_collections_classification(); if (_e) { _o->filtered_collections_classification.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->filtered_collections_classification[_i] = _e->Get(_i)->str(); } } }
  { auto _e = filtered_collections_selection(); if (_e) { _o->filtered_collections_selection.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->filtered_collections_selection[_i] = _e->Get(_i)->str(); } } }
}

inline flatbuffers::Offset<OutputOptions> OutputOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OutputOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOutputOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OutputOptions> CreateOutputOptions(flatbuffers::FlatBufferBuilder &_fbb, const OutputOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OutputOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _filtered_collections_annotation = _o->filtered_collections_annotation.size() ? _fbb.CreateVectorOfStrings(_o->filtered_collections_annotation) : 0;
  auto _filtered_collections_classification = _o->filtered_collections_classification.size() ? _fbb.CreateVectorOfStrings(_o->filtered_collections_classification) : 0;
  auto _filtered_collections_selection = _o->filtered_collections_selection.size() ? _fbb.CreateVectorOfStrings(_o->filtered_collections_selection) : 0;
  return libtextclassifier3::CreateOutputOptions(
      _fbb,
      _filtered_collections_annotation,
      _filtered_collections_classification,
      _filtered_collections_selection);
}

namespace Model_ {

inline EmbeddingPruningMaskT *EmbeddingPruningMask::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::Model_::EmbeddingPruningMaskT> _o = std::unique_ptr<libtextclassifier3::Model_::EmbeddingPruningMaskT>(new EmbeddingPruningMaskT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EmbeddingPruningMask::UnPackTo(EmbeddingPruningMaskT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = enabled(); _o->enabled = _e; }
  { auto _e = pruning_mask(); if (_e) { _o->pruning_mask.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pruning_mask[_i] = _e->Get(_i); } } }
  { auto _e = full_num_buckets(); _o->full_num_buckets = _e; }
  { auto _e = pruned_row_bucket_id(); _o->pruned_row_bucket_id = _e; }
}

inline flatbuffers::Offset<EmbeddingPruningMask> EmbeddingPruningMask::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingPruningMaskT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEmbeddingPruningMask(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EmbeddingPruningMask> CreateEmbeddingPruningMask(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingPruningMaskT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EmbeddingPruningMaskT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _enabled = _o->enabled;
  _fbb.ForceVectorAlignment(_o->pruning_mask.size(), sizeof(uint64_t), 16);
  auto _pruning_mask = _o->pruning_mask.size() ? _fbb.CreateVector(_o->pruning_mask) : 0;
  auto _full_num_buckets = _o->full_num_buckets;
  auto _pruned_row_bucket_id = _o->pruned_row_bucket_id;
  return libtextclassifier3::Model_::CreateEmbeddingPruningMask(
      _fbb,
      _enabled,
      _pruning_mask,
      _full_num_buckets,
      _pruned_row_bucket_id);
}

inline ConflictResolutionOptionsT *ConflictResolutionOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::Model_::ConflictResolutionOptionsT> _o = std::unique_ptr<libtextclassifier3::Model_::ConflictResolutionOptionsT>(new ConflictResolutionOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ConflictResolutionOptions::UnPackTo(ConflictResolutionOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = prioritize_longest_annotation(); _o->prioritize_longest_annotation = _e; }
  { auto _e = do_conflict_resolution_in_raw_mode(); _o->do_conflict_resolution_in_raw_mode = _e; }
}

inline flatbuffers::Offset<ConflictResolutionOptions> ConflictResolutionOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConflictResolutionOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConflictResolutionOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConflictResolutionOptions> CreateConflictResolutionOptions(flatbuffers::FlatBufferBuilder &_fbb, const ConflictResolutionOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConflictResolutionOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _prioritize_longest_annotation = _o->prioritize_longest_annotation;
  auto _do_conflict_resolution_in_raw_mode = _o->do_conflict_resolution_in_raw_mode;
  return libtextclassifier3::Model_::CreateConflictResolutionOptions(
      _fbb,
      _prioritize_longest_annotation,
      _do_conflict_resolution_in_raw_mode);
}

}  // namespace Model_

inline ModelT *Model::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::ModelT> _o = std::unique_ptr<libtextclassifier3::ModelT>(new ModelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Model::UnPackTo(ModelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = locales(); if (_e) _o->locales = _e->str(); }
  { auto _e = version(); _o->version = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = selection_feature_options(); if (_e) _o->selection_feature_options = std::unique_ptr<libtextclassifier3::FeatureProcessorOptionsT>(_e->UnPack(_resolver)); }
  { auto _e = classification_feature_options(); if (_e) _o->classification_feature_options = std::unique_ptr<libtextclassifier3::FeatureProcessorOptionsT>(_e->UnPack(_resolver)); }
  { auto _e = selection_model(); if (_e) { _o->selection_model.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->selection_model[_i] = _e->Get(_i); } } }
  { auto _e = classification_model(); if (_e) { _o->classification_model.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->classification_model[_i] = _e->Get(_i); } } }
  { auto _e = embedding_model(); if (_e) { _o->embedding_model.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->embedding_model[_i] = _e->Get(_i); } } }
  { auto _e = selection_options(); if (_e) _o->selection_options = std::unique_ptr<libtextclassifier3::SelectionModelOptionsT>(_e->UnPack(_resolver)); }
  { auto _e = classification_options(); if (_e) _o->classification_options = std::unique_ptr<libtextclassifier3::ClassificationModelOptionsT>(_e->UnPack(_resolver)); }
  { auto _e = regex_model(); if (_e) _o->regex_model = std::unique_ptr<libtextclassifier3::RegexModelT>(_e->UnPack(_resolver)); }
  { auto _e = datetime_model(); if (_e) _o->datetime_model = std::unique_ptr<libtextclassifier3::DatetimeModelT>(_e->UnPack(_resolver)); }
  { auto _e = triggering_options(); if (_e) _o->triggering_options = std::unique_ptr<libtextclassifier3::ModelTriggeringOptionsT>(_e->UnPack(_resolver)); }
  { auto _e = enabled_modes(); _o->enabled_modes = _e; }
  { auto _e = snap_whitespace_selections(); _o->snap_whitespace_selections = _e; }
  { auto _e = output_options(); if (_e) _o->output_options = std::unique_ptr<libtextclassifier3::OutputOptionsT>(_e->UnPack(_resolver)); }
  { auto _e = android_intent_options(); if (_e) _o->android_intent_options = std::unique_ptr<libtextclassifier3::AndroidIntentFactoryOptionsT>(_e->UnPack(_resolver)); }
  { auto _e = intent_options(); if (_e) _o->intent_options = std::unique_ptr<libtextclassifier3::IntentFactoryModelT>(_e->UnPack(_resolver)); }
  { auto _e = resources(); if (_e) _o->resources = std::unique_ptr<libtextclassifier3::ResourcePoolT>(_e->UnPack(_resolver)); }
  { auto _e = entity_data_schema(); if (_e) { _o->entity_data_schema.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->entity_data_schema[_i] = _e->Get(_i); } } }
  { auto _e = number_annotator_options(); if (_e) _o->number_annotator_options = std::unique_ptr<libtextclassifier3::NumberAnnotatorOptionsT>(_e->UnPack(_resolver)); }
  { auto _e = duration_annotator_options(); if (_e) _o->duration_annotator_options = std::unique_ptr<libtextclassifier3::DurationAnnotatorOptionsT>(_e->UnPack(_resolver)); }
  { auto _e = triggering_locales(); if (_e) _o->triggering_locales = _e->str(); }
  { auto _e = embedding_pruning_mask(); if (_e) _o->embedding_pruning_mask = std::unique_ptr<libtextclassifier3::Model_::EmbeddingPruningMaskT>(_e->UnPack(_resolver)); }
  { auto _e = contact_annotator_options(); if (_e) _o->contact_annotator_options = std::unique_ptr<libtextclassifier3::ContactAnnotatorOptionsT>(_e->UnPack(_resolver)); }
  { auto _e = money_parsing_options(); if (_e) _o->money_parsing_options = std::unique_ptr<libtextclassifier3::MoneyParsingOptionsT>(_e->UnPack(_resolver)); }
  { auto _e = translate_annotator_options(); if (_e) _o->translate_annotator_options = std::unique_ptr<libtextclassifier3::TranslateAnnotatorOptionsT>(_e->UnPack(_resolver)); }
  { auto _e = grammar_model(); if (_e) _o->grammar_model = std::unique_ptr<libtextclassifier3::GrammarModelT>(_e->UnPack(_resolver)); }
  { auto _e = conflict_resolution_options(); if (_e) _o->conflict_resolution_options = std::unique_ptr<libtextclassifier3::Model_::ConflictResolutionOptionsT>(_e->UnPack(_resolver)); }
  { auto _e = experimental_model(); if (_e) _o->experimental_model = std::unique_ptr<libtextclassifier3::ExperimentalModelT>(_e->UnPack(_resolver)); }
  { auto _e = pod_ner_model(); if (_e) _o->pod_ner_model = std::unique_ptr<libtextclassifier3::PodNerModelT>(_e->UnPack(_resolver)); }
  { auto _e = vocab_model(); if (_e) _o->vocab_model = std::unique_ptr<libtextclassifier3::VocabModelT>(_e->UnPack(_resolver)); }
  { auto _e = datetime_grammar_model(); if (_e) _o->datetime_grammar_model = std::unique_ptr<libtextclassifier3::GrammarModelT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<Model> Model::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateModel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Model> CreateModel(flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ModelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _locales = _o->locales.empty() ? 0 : _fbb.CreateSharedString(_o->locales);
  auto _version = _o->version;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateSharedString(_o->name);
  auto _selection_feature_options = _o->selection_feature_options ? CreateFeatureProcessorOptions(_fbb, _o->selection_feature_options.get(), _rehasher) : 0;
  auto _classification_feature_options = _o->classification_feature_options ? CreateFeatureProcessorOptions(_fbb, _o->classification_feature_options.get(), _rehasher) : 0;
  _fbb.ForceVectorAlignment(_o->selection_model.size(), sizeof(uint8_t), 16);
  auto _selection_model = _o->selection_model.size() ? _fbb.CreateVector(_o->selection_model) : 0;
  _fbb.ForceVectorAlignment(_o->classification_model.size(), sizeof(uint8_t), 16);
  auto _classification_model = _o->classification_model.size() ? _fbb.CreateVector(_o->classification_model) : 0;
  _fbb.ForceVectorAlignment(_o->embedding_model.size(), sizeof(uint8_t), 16);
  auto _embedding_model = _o->embedding_model.size() ? _fbb.CreateVector(_o->embedding_model) : 0;
  auto _selection_options = _o->selection_options ? CreateSelectionModelOptions(_fbb, _o->selection_options.get(), _rehasher) : 0;
  auto _classification_options = _o->classification_options ? CreateClassificationModelOptions(_fbb, _o->classification_options.get(), _rehasher) : 0;
  auto _regex_model = _o->regex_model ? CreateRegexModel(_fbb, _o->regex_model.get(), _rehasher) : 0;
  auto _datetime_model = _o->datetime_model ? CreateDatetimeModel(_fbb, _o->datetime_model.get(), _rehasher) : 0;
  auto _triggering_options = _o->triggering_options ? CreateModelTriggeringOptions(_fbb, _o->triggering_options.get(), _rehasher) : 0;
  auto _enabled_modes = _o->enabled_modes;
  auto _snap_whitespace_selections = _o->snap_whitespace_selections;
  auto _output_options = _o->output_options ? CreateOutputOptions(_fbb, _o->output_options.get(), _rehasher) : 0;
  auto _android_intent_options = _o->android_intent_options ? CreateAndroidIntentFactoryOptions(_fbb, _o->android_intent_options.get(), _rehasher) : 0;
  auto _intent_options = _o->intent_options ? CreateIntentFactoryModel(_fbb, _o->intent_options.get(), _rehasher) : 0;
  auto _resources = _o->resources ? CreateResourcePool(_fbb, _o->resources.get(), _rehasher) : 0;
  auto _entity_data_schema = _o->entity_data_schema.size() ? _fbb.CreateVector(_o->entity_data_schema) : 0;
  auto _number_annotator_options = _o->number_annotator_options ? CreateNumberAnnotatorOptions(_fbb, _o->number_annotator_options.get(), _rehasher) : 0;
  auto _duration_annotator_options = _o->duration_annotator_options ? CreateDurationAnnotatorOptions(_fbb, _o->duration_annotator_options.get(), _rehasher) : 0;
  auto _triggering_locales = _o->triggering_locales.empty() ? 0 : _fbb.CreateSharedString(_o->triggering_locales);
  auto _embedding_pruning_mask = _o->embedding_pruning_mask ? CreateEmbeddingPruningMask(_fbb, _o->embedding_pruning_mask.get(), _rehasher) : 0;
  auto _contact_annotator_options = _o->contact_annotator_options ? CreateContactAnnotatorOptions(_fbb, _o->contact_annotator_options.get(), _rehasher) : 0;
  auto _money_parsing_options = _o->money_parsing_options ? CreateMoneyParsingOptions(_fbb, _o->money_parsing_options.get(), _rehasher) : 0;
  auto _translate_annotator_options = _o->translate_annotator_options ? CreateTranslateAnnotatorOptions(_fbb, _o->translate_annotator_options.get(), _rehasher) : 0;
  auto _grammar_model = _o->grammar_model ? CreateGrammarModel(_fbb, _o->grammar_model.get(), _rehasher) : 0;
  auto _conflict_resolution_options = _o->conflict_resolution_options ? CreateConflictResolutionOptions(_fbb, _o->conflict_resolution_options.get(), _rehasher) : 0;
  auto _experimental_model = _o->experimental_model ? CreateExperimentalModel(_fbb, _o->experimental_model.get(), _rehasher) : 0;
  auto _pod_ner_model = _o->pod_ner_model ? CreatePodNerModel(_fbb, _o->pod_ner_model.get(), _rehasher) : 0;
  auto _vocab_model = _o->vocab_model ? CreateVocabModel(_fbb, _o->vocab_model.get(), _rehasher) : 0;
  auto _datetime_grammar_model = _o->datetime_grammar_model ? CreateGrammarModel(_fbb, _o->datetime_grammar_model.get(), _rehasher) : 0;
  return libtextclassifier3::CreateModel(
      _fbb,
      _locales,
      _version,
      _name,
      _selection_feature_options,
      _classification_feature_options,
      _selection_model,
      _classification_model,
      _embedding_model,
      _selection_options,
      _classification_options,
      _regex_model,
      _datetime_model,
      _triggering_options,
      _enabled_modes,
      _snap_whitespace_selections,
      _output_options,
      _android_intent_options,
      _intent_options,
      _resources,
      _entity_data_schema,
      _number_annotator_options,
      _duration_annotator_options,
      _triggering_locales,
      _embedding_pruning_mask,
      _contact_annotator_options,
      _money_parsing_options,
      _translate_annotator_options,
      _grammar_model,
      _conflict_resolution_options,
      _experimental_model,
      _pod_ner_model,
      _vocab_model,
      _datetime_grammar_model);
}

namespace FeatureProcessorOptions_ {

inline BoundsSensitiveFeaturesT *BoundsSensitiveFeatures::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::FeatureProcessorOptions_::BoundsSensitiveFeaturesT> _o = std::unique_ptr<libtextclassifier3::FeatureProcessorOptions_::BoundsSensitiveFeaturesT>(new BoundsSensitiveFeaturesT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BoundsSensitiveFeatures::UnPackTo(BoundsSensitiveFeaturesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = enabled(); _o->enabled = _e; }
  { auto _e = num_tokens_before(); _o->num_tokens_before = _e; }
  { auto _e = num_tokens_inside_left(); _o->num_tokens_inside_left = _e; }
  { auto _e = num_tokens_inside_right(); _o->num_tokens_inside_right = _e; }
  { auto _e = num_tokens_after(); _o->num_tokens_after = _e; }
  { auto _e = include_inside_bag(); _o->include_inside_bag = _e; }
  { auto _e = include_inside_length(); _o->include_inside_length = _e; }
  { auto _e = score_single_token_spans_as_zero(); _o->score_single_token_spans_as_zero = _e; }
}

inline flatbuffers::Offset<BoundsSensitiveFeatures> BoundsSensitiveFeatures::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BoundsSensitiveFeaturesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBoundsSensitiveFeatures(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BoundsSensitiveFeatures> CreateBoundsSensitiveFeatures(flatbuffers::FlatBufferBuilder &_fbb, const BoundsSensitiveFeaturesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BoundsSensitiveFeaturesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _enabled = _o->enabled;
  auto _num_tokens_before = _o->num_tokens_before;
  auto _num_tokens_inside_left = _o->num_tokens_inside_left;
  auto _num_tokens_inside_right = _o->num_tokens_inside_right;
  auto _num_tokens_after = _o->num_tokens_after;
  auto _include_inside_bag = _o->include_inside_bag;
  auto _include_inside_length = _o->include_inside_length;
  auto _score_single_token_spans_as_zero = _o->score_single_token_spans_as_zero;
  return libtextclassifier3::FeatureProcessorOptions_::CreateBoundsSensitiveFeatures(
      _fbb,
      _enabled,
      _num_tokens_before,
      _num_tokens_inside_left,
      _num_tokens_inside_right,
      _num_tokens_after,
      _include_inside_bag,
      _include_inside_length,
      _score_single_token_spans_as_zero);
}

}  // namespace FeatureProcessorOptions_

inline FeatureProcessorOptionsT *FeatureProcessorOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::FeatureProcessorOptionsT> _o = std::unique_ptr<libtextclassifier3::FeatureProcessorOptionsT>(new FeatureProcessorOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FeatureProcessorOptions::UnPackTo(FeatureProcessorOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num_buckets(); _o->num_buckets = _e; }
  { auto _e = embedding_size(); _o->embedding_size = _e; }
  { auto _e = embedding_quantization_bits(); _o->embedding_quantization_bits = _e; }
  { auto _e = context_size(); _o->context_size = _e; }
  { auto _e = max_selection_span(); _o->max_selection_span = _e; }
  { auto _e = chargram_orders(); if (_e) { _o->chargram_orders.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->chargram_orders[_i] = _e->Get(_i); } } }
  { auto _e = max_word_length(); _o->max_word_length = _e; }
  { auto _e = unicode_aware_features(); _o->unicode_aware_features = _e; }
  { auto _e = extract_case_feature(); _o->extract_case_feature = _e; }
  { auto _e = extract_selection_mask_feature(); _o->extract_selection_mask_feature = _e; }
  { auto _e = regexp_feature(); if (_e) { _o->regexp_feature.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->regexp_feature[_i] = _e->Get(_i)->str(); } } }
  { auto _e = remap_digits(); _o->remap_digits = _e; }
  { auto _e = lowercase_tokens(); _o->lowercase_tokens = _e; }
  { auto _e = selection_reduced_output_space(); _o->selection_reduced_output_space = _e; }
  { auto _e = collections(); if (_e) { _o->collections.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->collections[_i] = _e->Get(_i)->str(); } } }
  { auto _e = default_collection(); _o->default_collection = _e; }
  { auto _e = only_use_line_with_click(); _o->only_use_line_with_click = _e; }
  { auto _e = split_tokens_on_selection_boundaries(); _o->split_tokens_on_selection_boundaries = _e; }
  { auto _e = tokenization_codepoint_config(); if (_e) { _o->tokenization_codepoint_config.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tokenization_codepoint_config[_i] = std::unique_ptr<libtextclassifier3::TokenizationCodepointRangeT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = center_token_selection_method(); _o->center_token_selection_method = _e; }
  { auto _e = snap_label_span_boundaries_to_containing_tokens(); _o->snap_label_span_boundaries_to_containing_tokens = _e; }
  { auto _e = supported_codepoint_ranges(); if (_e) { _o->supported_codepoint_ranges.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->supported_codepoint_ranges[_i] = std::unique_ptr<libtextclassifier3::CodepointRangeT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = internal_tokenizer_codepoint_ranges(); if (_e) { _o->internal_tokenizer_codepoint_ranges.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->internal_tokenizer_codepoint_ranges[_i] = std::unique_ptr<libtextclassifier3::CodepointRangeT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = min_supported_codepoint_ratio(); _o->min_supported_codepoint_ratio = _e; }
  { auto _e = feature_version(); _o->feature_version = _e; }
  { auto _e = tokenization_type(); _o->tokenization_type = _e; }
  { auto _e = icu_preserve_whitespace_tokens(); _o->icu_preserve_whitespace_tokens = _e; }
  { auto _e = ignored_span_boundary_codepoints(); if (_e) { _o->ignored_span_boundary_codepoints.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ignored_span_boundary_codepoints[_i] = _e->Get(_i); } } }
  { auto _e = bounds_sensitive_features(); if (_e) _o->bounds_sensitive_features = std::unique_ptr<libtextclassifier3::FeatureProcessorOptions_::BoundsSensitiveFeaturesT>(_e->UnPack(_resolver)); }
  { auto _e = allowed_chargrams(); if (_e) { _o->allowed_chargrams.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->allowed_chargrams[_i] = _e->Get(_i)->str(); } } }
  { auto _e = tokenize_on_script_change(); _o->tokenize_on_script_change = _e; }
  { auto _e = use_pipe_character_for_newline(); _o->use_pipe_character_for_newline = _e; }
}

inline flatbuffers::Offset<FeatureProcessorOptions> FeatureProcessorOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FeatureProcessorOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFeatureProcessorOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FeatureProcessorOptions> CreateFeatureProcessorOptions(flatbuffers::FlatBufferBuilder &_fbb, const FeatureProcessorOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FeatureProcessorOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num_buckets = _o->num_buckets;
  auto _embedding_size = _o->embedding_size;
  auto _embedding_quantization_bits = _o->embedding_quantization_bits;
  auto _context_size = _o->context_size;
  auto _max_selection_span = _o->max_selection_span;
  auto _chargram_orders = _o->chargram_orders.size() ? _fbb.CreateVector(_o->chargram_orders) : 0;
  auto _max_word_length = _o->max_word_length;
  auto _unicode_aware_features = _o->unicode_aware_features;
  auto _extract_case_feature = _o->extract_case_feature;
  auto _extract_selection_mask_feature = _o->extract_selection_mask_feature;
  auto _regexp_feature = _o->regexp_feature.size() ? _fbb.CreateVectorOfStrings(_o->regexp_feature) : 0;
  auto _remap_digits = _o->remap_digits;
  auto _lowercase_tokens = _o->lowercase_tokens;
  auto _selection_reduced_output_space = _o->selection_reduced_output_space;
  auto _collections = _o->collections.size() ? _fbb.CreateVectorOfStrings(_o->collections) : 0;
  auto _default_collection = _o->default_collection;
  auto _only_use_line_with_click = _o->only_use_line_with_click;
  auto _split_tokens_on_selection_boundaries = _o->split_tokens_on_selection_boundaries;
  auto _tokenization_codepoint_config = _o->tokenization_codepoint_config.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::TokenizationCodepointRange>> (_o->tokenization_codepoint_config.size(), [](size_t i, _VectorArgs *__va) { return CreateTokenizationCodepointRange(*__va->__fbb, __va->__o->tokenization_codepoint_config[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _center_token_selection_method = _o->center_token_selection_method;
  auto _snap_label_span_boundaries_to_containing_tokens = _o->snap_label_span_boundaries_to_containing_tokens;
  auto _supported_codepoint_ranges = _o->supported_codepoint_ranges.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::CodepointRange>> (_o->supported_codepoint_ranges.size(), [](size_t i, _VectorArgs *__va) { return CreateCodepointRange(*__va->__fbb, __va->__o->supported_codepoint_ranges[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _internal_tokenizer_codepoint_ranges = _o->internal_tokenizer_codepoint_ranges.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::CodepointRange>> (_o->internal_tokenizer_codepoint_ranges.size(), [](size_t i, _VectorArgs *__va) { return CreateCodepointRange(*__va->__fbb, __va->__o->internal_tokenizer_codepoint_ranges[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _min_supported_codepoint_ratio = _o->min_supported_codepoint_ratio;
  auto _feature_version = _o->feature_version;
  auto _tokenization_type = _o->tokenization_type;
  auto _icu_preserve_whitespace_tokens = _o->icu_preserve_whitespace_tokens;
  auto _ignored_span_boundary_codepoints = _o->ignored_span_boundary_codepoints.size() ? _fbb.CreateVector(_o->ignored_span_boundary_codepoints) : 0;
  auto _bounds_sensitive_features = _o->bounds_sensitive_features ? CreateBoundsSensitiveFeatures(_fbb, _o->bounds_sensitive_features.get(), _rehasher) : 0;
  auto _allowed_chargrams = _o->allowed_chargrams.size() ? _fbb.CreateVectorOfStrings(_o->allowed_chargrams) : 0;
  auto _tokenize_on_script_change = _o->tokenize_on_script_change;
  auto _use_pipe_character_for_newline = _o->use_pipe_character_for_newline;
  return libtextclassifier3::CreateFeatureProcessorOptions(
      _fbb,
      _num_buckets,
      _embedding_size,
      _embedding_quantization_bits,
      _context_size,
      _max_selection_span,
      _chargram_orders,
      _max_word_length,
      _unicode_aware_features,
      _extract_case_feature,
      _extract_selection_mask_feature,
      _regexp_feature,
      _remap_digits,
      _lowercase_tokens,
      _selection_reduced_output_space,
      _collections,
      _default_collection,
      _only_use_line_with_click,
      _split_tokens_on_selection_boundaries,
      _tokenization_codepoint_config,
      _center_token_selection_method,
      _snap_label_span_boundaries_to_containing_tokens,
      _supported_codepoint_ranges,
      _internal_tokenizer_codepoint_ranges,
      _min_supported_codepoint_ratio,
      _feature_version,
      _tokenization_type,
      _icu_preserve_whitespace_tokens,
      _ignored_span_boundary_codepoints,
      _bounds_sensitive_features,
      _allowed_chargrams,
      _tokenize_on_script_change,
      _use_pipe_character_for_newline);
}

inline NumberAnnotatorOptionsT *NumberAnnotatorOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::NumberAnnotatorOptionsT> _o = std::unique_ptr<libtextclassifier3::NumberAnnotatorOptionsT>(new NumberAnnotatorOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NumberAnnotatorOptions::UnPackTo(NumberAnnotatorOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = enabled(); _o->enabled = _e; }
  { auto _e = score(); _o->score = _e; }
  { auto _e = priority_score(); _o->priority_score = _e; }
  { auto _e = enabled_modes(); _o->enabled_modes = _e; }
  { auto _e = enabled_annotation_usecases(); _o->enabled_annotation_usecases = _e; }
  { auto _e = allowed_prefix_codepoints(); if (_e) { _o->allowed_prefix_codepoints.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->allowed_prefix_codepoints[_i] = _e->Get(_i); } } }
  { auto _e = allowed_suffix_codepoints(); if (_e) { _o->allowed_suffix_codepoints.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->allowed_suffix_codepoints[_i] = _e->Get(_i); } } }
  { auto _e = ignored_prefix_span_boundary_codepoints(); if (_e) { _o->ignored_prefix_span_boundary_codepoints.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ignored_prefix_span_boundary_codepoints[_i] = _e->Get(_i); } } }
  { auto _e = ignored_suffix_span_boundary_codepoints(); if (_e) { _o->ignored_suffix_span_boundary_codepoints.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ignored_suffix_span_boundary_codepoints[_i] = _e->Get(_i); } } }
  { auto _e = enable_percentage(); _o->enable_percentage = _e; }
  { auto _e = percentage_pieces_string(); if (_e) _o->percentage_pieces_string = _e->str(); }
  { auto _e = percentage_pieces_offsets(); if (_e) { _o->percentage_pieces_offsets.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->percentage_pieces_offsets[_i] = _e->Get(_i); } } }
  { auto _e = percentage_priority_score(); _o->percentage_priority_score = _e; }
  { auto _e = float_number_priority_score(); _o->float_number_priority_score = _e; }
  { auto _e = max_number_of_digits(); _o->max_number_of_digits = _e; }
  { auto _e = percentage_annotation_usecases(); _o->percentage_annotation_usecases = _e; }
}

inline flatbuffers::Offset<NumberAnnotatorOptions> NumberAnnotatorOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NumberAnnotatorOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNumberAnnotatorOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NumberAnnotatorOptions> CreateNumberAnnotatorOptions(flatbuffers::FlatBufferBuilder &_fbb, const NumberAnnotatorOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NumberAnnotatorOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _enabled = _o->enabled;
  auto _score = _o->score;
  auto _priority_score = _o->priority_score;
  auto _enabled_modes = _o->enabled_modes;
  auto _enabled_annotation_usecases = _o->enabled_annotation_usecases;
  auto _allowed_prefix_codepoints = _o->allowed_prefix_codepoints.size() ? _fbb.CreateVector(_o->allowed_prefix_codepoints) : 0;
  auto _allowed_suffix_codepoints = _o->allowed_suffix_codepoints.size() ? _fbb.CreateVector(_o->allowed_suffix_codepoints) : 0;
  auto _ignored_prefix_span_boundary_codepoints = _o->ignored_prefix_span_boundary_codepoints.size() ? _fbb.CreateVector(_o->ignored_prefix_span_boundary_codepoints) : 0;
  auto _ignored_suffix_span_boundary_codepoints = _o->ignored_suffix_span_boundary_codepoints.size() ? _fbb.CreateVector(_o->ignored_suffix_span_boundary_codepoints) : 0;
  auto _enable_percentage = _o->enable_percentage;
  auto _percentage_pieces_string = _o->percentage_pieces_string.empty() ? 0 : _fbb.CreateSharedString(_o->percentage_pieces_string);
  auto _percentage_pieces_offsets = _o->percentage_pieces_offsets.size() ? _fbb.CreateVector(_o->percentage_pieces_offsets) : 0;
  auto _percentage_priority_score = _o->percentage_priority_score;
  auto _float_number_priority_score = _o->float_number_priority_score;
  auto _max_number_of_digits = _o->max_number_of_digits;
  auto _percentage_annotation_usecases = _o->percentage_annotation_usecases;
  return libtextclassifier3::CreateNumberAnnotatorOptions(
      _fbb,
      _enabled,
      _score,
      _priority_score,
      _enabled_modes,
      _enabled_annotation_usecases,
      _allowed_prefix_codepoints,
      _allowed_suffix_codepoints,
      _ignored_prefix_span_boundary_codepoints,
      _ignored_suffix_span_boundary_codepoints,
      _enable_percentage,
      _percentage_pieces_string,
      _percentage_pieces_offsets,
      _percentage_priority_score,
      _float_number_priority_score,
      _max_number_of_digits,
      _percentage_annotation_usecases);
}

inline DurationAnnotatorOptionsT *DurationAnnotatorOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::DurationAnnotatorOptionsT> _o = std::unique_ptr<libtextclassifier3::DurationAnnotatorOptionsT>(new DurationAnnotatorOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DurationAnnotatorOptions::UnPackTo(DurationAnnotatorOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = enabled(); _o->enabled = _e; }
  { auto _e = score(); _o->score = _e; }
  { auto _e = priority_score(); _o->priority_score = _e; }
  { auto _e = enabled_modes(); _o->enabled_modes = _e; }
  { auto _e = enabled_annotation_usecases(); _o->enabled_annotation_usecases = _e; }
  { auto _e = week_expressions(); if (_e) { _o->week_expressions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->week_expressions[_i] = _e->Get(_i)->str(); } } }
  { auto _e = day_expressions(); if (_e) { _o->day_expressions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->day_expressions[_i] = _e->Get(_i)->str(); } } }
  { auto _e = hour_expressions(); if (_e) { _o->hour_expressions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->hour_expressions[_i] = _e->Get(_i)->str(); } } }
  { auto _e = minute_expressions(); if (_e) { _o->minute_expressions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->minute_expressions[_i] = _e->Get(_i)->str(); } } }
  { auto _e = second_expressions(); if (_e) { _o->second_expressions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->second_expressions[_i] = _e->Get(_i)->str(); } } }
  { auto _e = filler_expressions(); if (_e) { _o->filler_expressions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->filler_expressions[_i] = _e->Get(_i)->str(); } } }
  { auto _e = half_expressions(); if (_e) { _o->half_expressions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->half_expressions[_i] = _e->Get(_i)->str(); } } }
  { auto _e = sub_token_separator_codepoints(); if (_e) { _o->sub_token_separator_codepoints.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->sub_token_separator_codepoints[_i] = _e->Get(_i); } } }
  { auto _e = require_quantity(); _o->require_quantity = _e; }
  { auto _e = enable_dangling_quantity_interpretation(); _o->enable_dangling_quantity_interpretation = _e; }
}

inline flatbuffers::Offset<DurationAnnotatorOptions> DurationAnnotatorOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DurationAnnotatorOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDurationAnnotatorOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DurationAnnotatorOptions> CreateDurationAnnotatorOptions(flatbuffers::FlatBufferBuilder &_fbb, const DurationAnnotatorOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DurationAnnotatorOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _enabled = _o->enabled;
  auto _score = _o->score;
  auto _priority_score = _o->priority_score;
  auto _enabled_modes = _o->enabled_modes;
  auto _enabled_annotation_usecases = _o->enabled_annotation_usecases;
  auto _week_expressions = _o->week_expressions.size() ? _fbb.CreateVectorOfStrings(_o->week_expressions) : 0;
  auto _day_expressions = _o->day_expressions.size() ? _fbb.CreateVectorOfStrings(_o->day_expressions) : 0;
  auto _hour_expressions = _o->hour_expressions.size() ? _fbb.CreateVectorOfStrings(_o->hour_expressions) : 0;
  auto _minute_expressions = _o->minute_expressions.size() ? _fbb.CreateVectorOfStrings(_o->minute_expressions) : 0;
  auto _second_expressions = _o->second_expressions.size() ? _fbb.CreateVectorOfStrings(_o->second_expressions) : 0;
  auto _filler_expressions = _o->filler_expressions.size() ? _fbb.CreateVectorOfStrings(_o->filler_expressions) : 0;
  auto _half_expressions = _o->half_expressions.size() ? _fbb.CreateVectorOfStrings(_o->half_expressions) : 0;
  auto _sub_token_separator_codepoints = _o->sub_token_separator_codepoints.size() ? _fbb.CreateVector(_o->sub_token_separator_codepoints) : 0;
  auto _require_quantity = _o->require_quantity;
  auto _enable_dangling_quantity_interpretation = _o->enable_dangling_quantity_interpretation;
  return libtextclassifier3::CreateDurationAnnotatorOptions(
      _fbb,
      _enabled,
      _score,
      _priority_score,
      _enabled_modes,
      _enabled_annotation_usecases,
      _week_expressions,
      _day_expressions,
      _hour_expressions,
      _minute_expressions,
      _second_expressions,
      _filler_expressions,
      _half_expressions,
      _sub_token_separator_codepoints,
      _require_quantity,
      _enable_dangling_quantity_interpretation);
}

inline ContactAnnotatorOptionsT *ContactAnnotatorOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::ContactAnnotatorOptionsT> _o = std::unique_ptr<libtextclassifier3::ContactAnnotatorOptionsT>(new ContactAnnotatorOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ContactAnnotatorOptions::UnPackTo(ContactAnnotatorOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = enable_declension(); _o->enable_declension = _e; }
  { auto _e = language(); if (_e) _o->language = _e->str(); }
}

inline flatbuffers::Offset<ContactAnnotatorOptions> ContactAnnotatorOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ContactAnnotatorOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateContactAnnotatorOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ContactAnnotatorOptions> CreateContactAnnotatorOptions(flatbuffers::FlatBufferBuilder &_fbb, const ContactAnnotatorOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ContactAnnotatorOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _enable_declension = _o->enable_declension;
  auto _language = _o->language.empty() ? 0 : _fbb.CreateSharedString(_o->language);
  return libtextclassifier3::CreateContactAnnotatorOptions(
      _fbb,
      _enable_declension,
      _language);
}

namespace TranslateAnnotatorOptions_ {

inline BackoffOptionsT *BackoffOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::TranslateAnnotatorOptions_::BackoffOptionsT> _o = std::unique_ptr<libtextclassifier3::TranslateAnnotatorOptions_::BackoffOptionsT>(new BackoffOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BackoffOptions::UnPackTo(BackoffOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = min_text_size(); _o->min_text_size = _e; }
  { auto _e = penalize_ratio(); _o->penalize_ratio = _e; }
  { auto _e = subject_text_score_ratio(); _o->subject_text_score_ratio = _e; }
}

inline flatbuffers::Offset<BackoffOptions> BackoffOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BackoffOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBackoffOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BackoffOptions> CreateBackoffOptions(flatbuffers::FlatBufferBuilder &_fbb, const BackoffOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BackoffOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _min_text_size = _o->min_text_size;
  auto _penalize_ratio = _o->penalize_ratio;
  auto _subject_text_score_ratio = _o->subject_text_score_ratio;
  return libtextclassifier3::TranslateAnnotatorOptions_::CreateBackoffOptions(
      _fbb,
      _min_text_size,
      _penalize_ratio,
      _subject_text_score_ratio);
}

}  // namespace TranslateAnnotatorOptions_

inline TranslateAnnotatorOptionsT *TranslateAnnotatorOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::TranslateAnnotatorOptionsT> _o = std::unique_ptr<libtextclassifier3::TranslateAnnotatorOptionsT>(new TranslateAnnotatorOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TranslateAnnotatorOptions::UnPackTo(TranslateAnnotatorOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = enabled(); _o->enabled = _e; }
  { auto _e = score(); _o->score = _e; }
  { auto _e = priority_score(); _o->priority_score = _e; }
  { auto _e = algorithm(); _o->algorithm = _e; }
  { auto _e = backoff_options(); if (_e) _o->backoff_options = std::unique_ptr<libtextclassifier3::TranslateAnnotatorOptions_::BackoffOptionsT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<TranslateAnnotatorOptions> TranslateAnnotatorOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TranslateAnnotatorOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTranslateAnnotatorOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TranslateAnnotatorOptions> CreateTranslateAnnotatorOptions(flatbuffers::FlatBufferBuilder &_fbb, const TranslateAnnotatorOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TranslateAnnotatorOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _enabled = _o->enabled;
  auto _score = _o->score;
  auto _priority_score = _o->priority_score;
  auto _algorithm = _o->algorithm;
  auto _backoff_options = _o->backoff_options ? CreateBackoffOptions(_fbb, _o->backoff_options.get(), _rehasher) : 0;
  return libtextclassifier3::CreateTranslateAnnotatorOptions(
      _fbb,
      _enabled,
      _score,
      _priority_score,
      _algorithm,
      _backoff_options);
}

namespace PodNerModel_ {

inline CollectionT *Collection::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::PodNerModel_::CollectionT> _o = std::unique_ptr<libtextclassifier3::PodNerModel_::CollectionT>(new CollectionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Collection::UnPackTo(CollectionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = single_token_priority_score(); _o->single_token_priority_score = _e; }
  { auto _e = multi_token_priority_score(); _o->multi_token_priority_score = _e; }
}

inline flatbuffers::Offset<Collection> Collection::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CollectionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCollection(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Collection> CreateCollection(flatbuffers::FlatBufferBuilder &_fbb, const CollectionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CollectionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateSharedString(_o->name);
  auto _single_token_priority_score = _o->single_token_priority_score;
  auto _multi_token_priority_score = _o->multi_token_priority_score;
  return libtextclassifier3::PodNerModel_::CreateCollection(
      _fbb,
      _name,
      _single_token_priority_score,
      _multi_token_priority_score);
}

inline LabelT *Label::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::PodNerModel_::LabelT> _o = std::unique_ptr<libtextclassifier3::PodNerModel_::LabelT>(new LabelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Label::UnPackTo(LabelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = boise_type(); _o->boise_type = _e; }
  { auto _e = mention_type(); _o->mention_type = _e; }
  { auto _e = collection_id(); _o->collection_id = _e; }
}

inline flatbuffers::Offset<Label> Label::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LabelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLabel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Label> CreateLabel(flatbuffers::FlatBufferBuilder &_fbb, const LabelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LabelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _boise_type = _o->boise_type;
  auto _mention_type = _o->mention_type;
  auto _collection_id = _o->collection_id;
  return libtextclassifier3::PodNerModel_::CreateLabel(
      _fbb,
      _boise_type,
      _mention_type,
      _collection_id);
}

}  // namespace PodNerModel_

inline PodNerModelT *PodNerModel::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::PodNerModelT> _o = std::unique_ptr<libtextclassifier3::PodNerModelT>(new PodNerModelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PodNerModel::UnPackTo(PodNerModelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tflite_model(); if (_e) { _o->tflite_model.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tflite_model[_i] = _e->Get(_i); } } }
  { auto _e = word_piece_vocab(); if (_e) { _o->word_piece_vocab.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->word_piece_vocab[_i] = _e->Get(_i); } } }
  { auto _e = lowercase_input(); _o->lowercase_input = _e; }
  { auto _e = logits_index_in_output_tensor(); _o->logits_index_in_output_tensor = _e; }
  { auto _e = append_final_period(); _o->append_final_period = _e; }
  { auto _e = priority_score(); _o->priority_score = _e; }
  { auto _e = max_num_wordpieces(); _o->max_num_wordpieces = _e; }
  { auto _e = sliding_window_num_wordpieces_overlap(); _o->sliding_window_num_wordpieces_overlap = _e; }
  { auto _e = labels(); if (_e) { _o->labels.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->labels[_i] = std::unique_ptr<libtextclassifier3::PodNerModel_::LabelT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = max_ratio_unknown_wordpieces(); _o->max_ratio_unknown_wordpieces = _e; }
  { auto _e = collections(); if (_e) { _o->collections.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->collections[_i] = std::unique_ptr<libtextclassifier3::PodNerModel_::CollectionT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = min_number_of_tokens(); _o->min_number_of_tokens = _e; }
  { auto _e = min_number_of_wordpieces(); _o->min_number_of_wordpieces = _e; }
}

inline flatbuffers::Offset<PodNerModel> PodNerModel::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PodNerModelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePodNerModel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PodNerModel> CreatePodNerModel(flatbuffers::FlatBufferBuilder &_fbb, const PodNerModelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PodNerModelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tflite_model = _o->tflite_model.size() ? _fbb.CreateVector(_o->tflite_model) : 0;
  auto _word_piece_vocab = _o->word_piece_vocab.size() ? _fbb.CreateVector(_o->word_piece_vocab) : 0;
  auto _lowercase_input = _o->lowercase_input;
  auto _logits_index_in_output_tensor = _o->logits_index_in_output_tensor;
  auto _append_final_period = _o->append_final_period;
  auto _priority_score = _o->priority_score;
  auto _max_num_wordpieces = _o->max_num_wordpieces;
  auto _sliding_window_num_wordpieces_overlap = _o->sliding_window_num_wordpieces_overlap;
  auto _labels = _o->labels.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::PodNerModel_::Label>> (_o->labels.size(), [](size_t i, _VectorArgs *__va) { return CreateLabel(*__va->__fbb, __va->__o->labels[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _max_ratio_unknown_wordpieces = _o->max_ratio_unknown_wordpieces;
  auto _collections = _o->collections.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::PodNerModel_::Collection>> (_o->collections.size(), [](size_t i, _VectorArgs *__va) { return CreateCollection(*__va->__fbb, __va->__o->collections[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _min_number_of_tokens = _o->min_number_of_tokens;
  auto _min_number_of_wordpieces = _o->min_number_of_wordpieces;
  return libtextclassifier3::CreatePodNerModel(
      _fbb,
      _tflite_model,
      _word_piece_vocab,
      _lowercase_input,
      _logits_index_in_output_tensor,
      _append_final_period,
      _priority_score,
      _max_num_wordpieces,
      _sliding_window_num_wordpieces_overlap,
      _labels,
      _max_ratio_unknown_wordpieces,
      _collections,
      _min_number_of_tokens,
      _min_number_of_wordpieces);
}

inline VocabModelT *VocabModel::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::VocabModelT> _o = std::unique_ptr<libtextclassifier3::VocabModelT>(new VocabModelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void VocabModel::UnPackTo(VocabModelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = vocab_trie(); if (_e) { _o->vocab_trie.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vocab_trie[_i] = _e->Get(_i); } } }
  { auto _e = beginner_level(); if (_e) _o->beginner_level = std::unique_ptr<libtextclassifier3::BitVectorDataT>(_e->UnPack(_resolver)); }
  { auto _e = do_not_trigger_in_upper_case(); if (_e) _o->do_not_trigger_in_upper_case = std::unique_ptr<libtextclassifier3::BitVectorDataT>(_e->UnPack(_resolver)); }
  { auto _e = triggering_locales(); if (_e) _o->triggering_locales = _e->str(); }
  { auto _e = target_classification_score(); _o->target_classification_score = _e; }
  { auto _e = priority_score(); _o->priority_score = _e; }
}

inline flatbuffers::Offset<VocabModel> VocabModel::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VocabModelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVocabModel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<VocabModel> CreateVocabModel(flatbuffers::FlatBufferBuilder &_fbb, const VocabModelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VocabModelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  _fbb.ForceVectorAlignment(_o->vocab_trie.size(), sizeof(uint8_t), 8);
  auto _vocab_trie = _o->vocab_trie.size() ? _fbb.CreateVector(_o->vocab_trie) : 0;
  auto _beginner_level = _o->beginner_level ? CreateBitVectorData(_fbb, _o->beginner_level.get(), _rehasher) : 0;
  auto _do_not_trigger_in_upper_case = _o->do_not_trigger_in_upper_case ? CreateBitVectorData(_fbb, _o->do_not_trigger_in_upper_case.get(), _rehasher) : 0;
  auto _triggering_locales = _o->triggering_locales.empty() ? 0 : _fbb.CreateSharedString(_o->triggering_locales);
  auto _target_classification_score = _o->target_classification_score;
  auto _priority_score = _o->priority_score;
  return libtextclassifier3::CreateVocabModel(
      _fbb,
      _vocab_trie,
      _beginner_level,
      _do_not_trigger_in_upper_case,
      _triggering_locales,
      _target_classification_score,
      _priority_score);
}

inline const libtextclassifier3::Model *GetModel(const void *buf) {
  return flatbuffers::GetRoot<libtextclassifier3::Model>(buf);
}

inline const libtextclassifier3::Model *GetSizePrefixedModel(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<libtextclassifier3::Model>(buf);
}

inline const char *ModelIdentifier() {
  return "TC2 ";
}

inline bool ModelBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ModelIdentifier());
}

inline bool VerifyModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<libtextclassifier3::Model>(ModelIdentifier());
}

inline bool VerifySizePrefixedModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<libtextclassifier3::Model>(ModelIdentifier());
}

inline void FinishModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<libtextclassifier3::Model> root) {
  fbb.Finish(root, ModelIdentifier());
}

inline void FinishSizePrefixedModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<libtextclassifier3::Model> root) {
  fbb.FinishSizePrefixed(root, ModelIdentifier());
}

inline std::unique_ptr<libtextclassifier3::ModelT> UnPackModel(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<libtextclassifier3::ModelT>(GetModel(buf)->UnPack(res));
}

inline std::unique_ptr<libtextclassifier3::ModelT> UnPackSizePrefixedModel(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<libtextclassifier3::ModelT>(GetSizePrefixedModel(buf)->UnPack(res));
}

}  // namespace libtextclassifier3

#endif  // FLATBUFFERS_GENERATED_MODEL_LIBTEXTCLASSIFIER3_H_
