// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RULES_LIBTEXTCLASSIFIER3_GRAMMAR_H_
#define FLATBUFFERS_GENERATED_RULES_LIBTEXTCLASSIFIER3_GRAMMAR_H_

#include "flatbuffers/flatbuffers.h"

#include "utils/flatbuffers/flatbuffers_generated.h"
#include "utils/grammar/semantics/expression_generated.h"
#include "utils/i18n/language-tag_generated.h"
#include "utils/zlib/buffer_generated.h"

namespace libtextclassifier3 {
namespace grammar {
namespace RulesSet_ {
namespace Rules_ {

struct TerminalRulesMap;
struct TerminalRulesMapBuilder;
struct TerminalRulesMapT;

struct UnaryRulesEntry;

struct BinaryRule;

struct BinaryRuleTableBucket;
struct BinaryRuleTableBucketBuilder;
struct BinaryRuleTableBucketT;

}  // namespace Rules_

struct Rules;
struct RulesBuilder;
struct RulesT;

struct LhsSet;
struct LhsSetBuilder;
struct LhsSetT;

struct Lhs;

namespace Nonterminals_ {

struct AnnotationNtEntry;
struct AnnotationNtEntryBuilder;
struct AnnotationNtEntryT;

}  // namespace Nonterminals_

struct Nonterminals;
struct NonterminalsBuilder;
struct NonterminalsT;

namespace DebugInformation_ {

struct NonterminalNamesEntry;
struct NonterminalNamesEntryBuilder;
struct NonterminalNamesEntryT;

}  // namespace DebugInformation_

struct DebugInformation;
struct DebugInformationBuilder;
struct DebugInformationT;

struct RegexAnnotator;
struct RegexAnnotatorBuilder;
struct RegexAnnotatorT;

}  // namespace RulesSet_

struct RulesSet;
struct RulesSetBuilder;
struct RulesSetT;

namespace RulesSet_ {
namespace Rules_ {

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) UnaryRulesEntry FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t key_;
  uint32_t value_;

 public:
  UnaryRulesEntry() {
    memset(static_cast<void *>(this), 0, sizeof(UnaryRulesEntry));
  }
  UnaryRulesEntry(uint32_t _key, uint32_t _value)
      : key_(flatbuffers::EndianScalar(_key)),
        value_(flatbuffers::EndianScalar(_value)) {
  }
  uint32_t key() const {
    return flatbuffers::EndianScalar(key_);
  }
  bool KeyCompareLessThan(const UnaryRulesEntry *o) const {
    return key() < o->key();
  }
  int KeyCompareWithValue(uint32_t val) const {
    return static_cast<int>(key() > val) - static_cast<int>(key() < val);
  }
  uint32_t value() const {
    return flatbuffers::EndianScalar(value_);
  }
};
FLATBUFFERS_STRUCT_END(UnaryRulesEntry, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) BinaryRule FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t rhs_first_;
  uint32_t rhs_second_;
  uint32_t lhs_set_index_;

 public:
  BinaryRule() {
    memset(static_cast<void *>(this), 0, sizeof(BinaryRule));
  }
  BinaryRule(uint32_t _rhs_first, uint32_t _rhs_second, uint32_t _lhs_set_index)
      : rhs_first_(flatbuffers::EndianScalar(_rhs_first)),
        rhs_second_(flatbuffers::EndianScalar(_rhs_second)),
        lhs_set_index_(flatbuffers::EndianScalar(_lhs_set_index)) {
  }
  uint32_t rhs_first() const {
    return flatbuffers::EndianScalar(rhs_first_);
  }
  uint32_t rhs_second() const {
    return flatbuffers::EndianScalar(rhs_second_);
  }
  uint32_t lhs_set_index() const {
    return flatbuffers::EndianScalar(lhs_set_index_);
  }
};
FLATBUFFERS_STRUCT_END(BinaryRule, 12);

}  // namespace Rules_

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Lhs FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t nonterminal_;
  uint32_t callback_id_;
  uint64_t callback_param_;
  int8_t max_whitespace_gap_;
  int8_t padding0__;  int16_t padding1__;  int32_t padding2__;

 public:
  Lhs() {
    memset(static_cast<void *>(this), 0, sizeof(Lhs));
  }
  Lhs(uint32_t _nonterminal, uint32_t _callback_id, uint64_t _callback_param, int8_t _max_whitespace_gap)
      : nonterminal_(flatbuffers::EndianScalar(_nonterminal)),
        callback_id_(flatbuffers::EndianScalar(_callback_id)),
        callback_param_(flatbuffers::EndianScalar(_callback_param)),
        max_whitespace_gap_(flatbuffers::EndianScalar(_max_whitespace_gap)),
        padding0__(0),
        padding1__(0),
        padding2__(0) {
    (void)padding0__;    (void)padding1__;    (void)padding2__;
  }
  uint32_t nonterminal() const {
    return flatbuffers::EndianScalar(nonterminal_);
  }
  uint32_t callback_id() const {
    return flatbuffers::EndianScalar(callback_id_);
  }
  uint64_t callback_param() const {
    return flatbuffers::EndianScalar(callback_param_);
  }
  int8_t max_whitespace_gap() const {
    return flatbuffers::EndianScalar(max_whitespace_gap_);
  }
};
FLATBUFFERS_STRUCT_END(Lhs, 24);

namespace Rules_ {

struct TerminalRulesMapT : public flatbuffers::NativeTable {
  typedef TerminalRulesMap TableType;
  std::vector<uint32_t> terminal_offsets;
  std::vector<uint32_t> lhs_set_index;
  int32_t min_terminal_length;
  int32_t max_terminal_length;
  TerminalRulesMapT()
      : min_terminal_length(0),
        max_terminal_length(0) {
  }
};

struct TerminalRulesMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TerminalRulesMapT NativeTableType;
  typedef TerminalRulesMapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TERMINAL_OFFSETS = 4,
    VT_LHS_SET_INDEX = 6,
    VT_MIN_TERMINAL_LENGTH = 8,
    VT_MAX_TERMINAL_LENGTH = 10
  };
  const flatbuffers::Vector<uint32_t> *terminal_offsets() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_TERMINAL_OFFSETS);
  }
  const flatbuffers::Vector<uint32_t> *lhs_set_index() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_LHS_SET_INDEX);
  }
  int32_t min_terminal_length() const {
    return GetField<int32_t>(VT_MIN_TERMINAL_LENGTH, 0);
  }
  int32_t max_terminal_length() const {
    return GetField<int32_t>(VT_MAX_TERMINAL_LENGTH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TERMINAL_OFFSETS) &&
           verifier.VerifyVector(terminal_offsets()) &&
           VerifyOffset(verifier, VT_LHS_SET_INDEX) &&
           verifier.VerifyVector(lhs_set_index()) &&
           VerifyField<int32_t>(verifier, VT_MIN_TERMINAL_LENGTH) &&
           VerifyField<int32_t>(verifier, VT_MAX_TERMINAL_LENGTH) &&
           verifier.EndTable();
  }
  TerminalRulesMapT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TerminalRulesMapT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TerminalRulesMap> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TerminalRulesMapT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TerminalRulesMapBuilder {
  typedef TerminalRulesMap Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_terminal_offsets(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> terminal_offsets) {
    fbb_.AddOffset(TerminalRulesMap::VT_TERMINAL_OFFSETS, terminal_offsets);
  }
  void add_lhs_set_index(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> lhs_set_index) {
    fbb_.AddOffset(TerminalRulesMap::VT_LHS_SET_INDEX, lhs_set_index);
  }
  void add_min_terminal_length(int32_t min_terminal_length) {
    fbb_.AddElement<int32_t>(TerminalRulesMap::VT_MIN_TERMINAL_LENGTH, min_terminal_length, 0);
  }
  void add_max_terminal_length(int32_t max_terminal_length) {
    fbb_.AddElement<int32_t>(TerminalRulesMap::VT_MAX_TERMINAL_LENGTH, max_terminal_length, 0);
  }
  explicit TerminalRulesMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TerminalRulesMapBuilder &operator=(const TerminalRulesMapBuilder &);
  flatbuffers::Offset<TerminalRulesMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TerminalRulesMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<TerminalRulesMap> CreateTerminalRulesMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> terminal_offsets = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> lhs_set_index = 0,
    int32_t min_terminal_length = 0,
    int32_t max_terminal_length = 0) {
  TerminalRulesMapBuilder builder_(_fbb);
  builder_.add_max_terminal_length(max_terminal_length);
  builder_.add_min_terminal_length(min_terminal_length);
  builder_.add_lhs_set_index(lhs_set_index);
  builder_.add_terminal_offsets(terminal_offsets);
  return builder_.Finish();
}

inline flatbuffers::Offset<TerminalRulesMap> CreateTerminalRulesMapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *terminal_offsets = nullptr,
    const std::vector<uint32_t> *lhs_set_index = nullptr,
    int32_t min_terminal_length = 0,
    int32_t max_terminal_length = 0) {
  auto terminal_offsets__ = terminal_offsets ? _fbb.CreateVector<uint32_t>(*terminal_offsets) : 0;
  auto lhs_set_index__ = lhs_set_index ? _fbb.CreateVector<uint32_t>(*lhs_set_index) : 0;
  return libtextclassifier3::grammar::RulesSet_::Rules_::CreateTerminalRulesMap(
      _fbb,
      terminal_offsets__,
      lhs_set_index__,
      min_terminal_length,
      max_terminal_length);
}

flatbuffers::Offset<TerminalRulesMap> CreateTerminalRulesMap(flatbuffers::FlatBufferBuilder &_fbb, const TerminalRulesMapT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BinaryRuleTableBucketT : public flatbuffers::NativeTable {
  typedef BinaryRuleTableBucket TableType;
  std::vector<libtextclassifier3::grammar::RulesSet_::Rules_::BinaryRule> rules;
  BinaryRuleTableBucketT() {
  }
};

struct BinaryRuleTableBucket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BinaryRuleTableBucketT NativeTableType;
  typedef BinaryRuleTableBucketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RULES = 4
  };
  const flatbuffers::Vector<const libtextclassifier3::grammar::RulesSet_::Rules_::BinaryRule *> *rules() const {
    return GetPointer<const flatbuffers::Vector<const libtextclassifier3::grammar::RulesSet_::Rules_::BinaryRule *> *>(VT_RULES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RULES) &&
           verifier.VerifyVector(rules()) &&
           verifier.EndTable();
  }
  BinaryRuleTableBucketT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BinaryRuleTableBucketT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BinaryRuleTableBucket> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BinaryRuleTableBucketT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BinaryRuleTableBucketBuilder {
  typedef BinaryRuleTableBucket Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rules(flatbuffers::Offset<flatbuffers::Vector<const libtextclassifier3::grammar::RulesSet_::Rules_::BinaryRule *>> rules) {
    fbb_.AddOffset(BinaryRuleTableBucket::VT_RULES, rules);
  }
  explicit BinaryRuleTableBucketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BinaryRuleTableBucketBuilder &operator=(const BinaryRuleTableBucketBuilder &);
  flatbuffers::Offset<BinaryRuleTableBucket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BinaryRuleTableBucket>(end);
    return o;
  }
};

inline flatbuffers::Offset<BinaryRuleTableBucket> CreateBinaryRuleTableBucket(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const libtextclassifier3::grammar::RulesSet_::Rules_::BinaryRule *>> rules = 0) {
  BinaryRuleTableBucketBuilder builder_(_fbb);
  builder_.add_rules(rules);
  return builder_.Finish();
}

inline flatbuffers::Offset<BinaryRuleTableBucket> CreateBinaryRuleTableBucketDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<libtextclassifier3::grammar::RulesSet_::Rules_::BinaryRule> *rules = nullptr) {
  auto rules__ = rules ? _fbb.CreateVectorOfStructs<libtextclassifier3::grammar::RulesSet_::Rules_::BinaryRule>(*rules) : 0;
  return libtextclassifier3::grammar::RulesSet_::Rules_::CreateBinaryRuleTableBucket(
      _fbb,
      rules__);
}

flatbuffers::Offset<BinaryRuleTableBucket> CreateBinaryRuleTableBucket(flatbuffers::FlatBufferBuilder &_fbb, const BinaryRuleTableBucketT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace Rules_

struct RulesT : public flatbuffers::NativeTable {
  typedef Rules TableType;
  std::vector<std::unique_ptr<libtextclassifier3::LanguageTagT>> locale;
  std::unique_ptr<libtextclassifier3::grammar::RulesSet_::Rules_::TerminalRulesMapT> terminal_rules;
  std::unique_ptr<libtextclassifier3::grammar::RulesSet_::Rules_::TerminalRulesMapT> lowercase_terminal_rules;
  std::vector<libtextclassifier3::grammar::RulesSet_::Rules_::UnaryRulesEntry> unary_rules;
  std::vector<std::unique_ptr<libtextclassifier3::grammar::RulesSet_::Rules_::BinaryRuleTableBucketT>> binary_rules;
  RulesT() {
  }
};

struct Rules FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RulesT NativeTableType;
  typedef RulesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOCALE = 4,
    VT_TERMINAL_RULES = 6,
    VT_LOWERCASE_TERMINAL_RULES = 8,
    VT_UNARY_RULES = 10,
    VT_BINARY_RULES = 12
  };
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::LanguageTag>> *locale() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::LanguageTag>> *>(VT_LOCALE);
  }
  const libtextclassifier3::grammar::RulesSet_::Rules_::TerminalRulesMap *terminal_rules() const {
    return GetPointer<const libtextclassifier3::grammar::RulesSet_::Rules_::TerminalRulesMap *>(VT_TERMINAL_RULES);
  }
  const libtextclassifier3::grammar::RulesSet_::Rules_::TerminalRulesMap *lowercase_terminal_rules() const {
    return GetPointer<const libtextclassifier3::grammar::RulesSet_::Rules_::TerminalRulesMap *>(VT_LOWERCASE_TERMINAL_RULES);
  }
  const flatbuffers::Vector<const libtextclassifier3::grammar::RulesSet_::Rules_::UnaryRulesEntry *> *unary_rules() const {
    return GetPointer<const flatbuffers::Vector<const libtextclassifier3::grammar::RulesSet_::Rules_::UnaryRulesEntry *> *>(VT_UNARY_RULES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Rules_::BinaryRuleTableBucket>> *binary_rules() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Rules_::BinaryRuleTableBucket>> *>(VT_BINARY_RULES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOCALE) &&
           verifier.VerifyVector(locale()) &&
           verifier.VerifyVectorOfTables(locale()) &&
           VerifyOffset(verifier, VT_TERMINAL_RULES) &&
           verifier.VerifyTable(terminal_rules()) &&
           VerifyOffset(verifier, VT_LOWERCASE_TERMINAL_RULES) &&
           verifier.VerifyTable(lowercase_terminal_rules()) &&
           VerifyOffset(verifier, VT_UNARY_RULES) &&
           verifier.VerifyVector(unary_rules()) &&
           VerifyOffset(verifier, VT_BINARY_RULES) &&
           verifier.VerifyVector(binary_rules()) &&
           verifier.VerifyVectorOfTables(binary_rules()) &&
           verifier.EndTable();
  }
  RulesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RulesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Rules> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RulesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RulesBuilder {
  typedef Rules Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_locale(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::LanguageTag>>> locale) {
    fbb_.AddOffset(Rules::VT_LOCALE, locale);
  }
  void add_terminal_rules(flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Rules_::TerminalRulesMap> terminal_rules) {
    fbb_.AddOffset(Rules::VT_TERMINAL_RULES, terminal_rules);
  }
  void add_lowercase_terminal_rules(flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Rules_::TerminalRulesMap> lowercase_terminal_rules) {
    fbb_.AddOffset(Rules::VT_LOWERCASE_TERMINAL_RULES, lowercase_terminal_rules);
  }
  void add_unary_rules(flatbuffers::Offset<flatbuffers::Vector<const libtextclassifier3::grammar::RulesSet_::Rules_::UnaryRulesEntry *>> unary_rules) {
    fbb_.AddOffset(Rules::VT_UNARY_RULES, unary_rules);
  }
  void add_binary_rules(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Rules_::BinaryRuleTableBucket>>> binary_rules) {
    fbb_.AddOffset(Rules::VT_BINARY_RULES, binary_rules);
  }
  explicit RulesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RulesBuilder &operator=(const RulesBuilder &);
  flatbuffers::Offset<Rules> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rules>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rules> CreateRules(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::LanguageTag>>> locale = 0,
    flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Rules_::TerminalRulesMap> terminal_rules = 0,
    flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Rules_::TerminalRulesMap> lowercase_terminal_rules = 0,
    flatbuffers::Offset<flatbuffers::Vector<const libtextclassifier3::grammar::RulesSet_::Rules_::UnaryRulesEntry *>> unary_rules = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Rules_::BinaryRuleTableBucket>>> binary_rules = 0) {
  RulesBuilder builder_(_fbb);
  builder_.add_binary_rules(binary_rules);
  builder_.add_unary_rules(unary_rules);
  builder_.add_lowercase_terminal_rules(lowercase_terminal_rules);
  builder_.add_terminal_rules(terminal_rules);
  builder_.add_locale(locale);
  return builder_.Finish();
}

inline flatbuffers::Offset<Rules> CreateRulesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<libtextclassifier3::LanguageTag>> *locale = nullptr,
    flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Rules_::TerminalRulesMap> terminal_rules = 0,
    flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Rules_::TerminalRulesMap> lowercase_terminal_rules = 0,
    std::vector<libtextclassifier3::grammar::RulesSet_::Rules_::UnaryRulesEntry> *unary_rules = nullptr,
    const std::vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Rules_::BinaryRuleTableBucket>> *binary_rules = nullptr) {
  auto locale__ = locale ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::LanguageTag>>(*locale) : 0;
  auto unary_rules__ = unary_rules ? _fbb.CreateVectorOfSortedStructs<libtextclassifier3::grammar::RulesSet_::Rules_::UnaryRulesEntry>(unary_rules) : 0;
  auto binary_rules__ = binary_rules ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Rules_::BinaryRuleTableBucket>>(*binary_rules) : 0;
  return libtextclassifier3::grammar::RulesSet_::CreateRules(
      _fbb,
      locale__,
      terminal_rules,
      lowercase_terminal_rules,
      unary_rules__,
      binary_rules__);
}

flatbuffers::Offset<Rules> CreateRules(flatbuffers::FlatBufferBuilder &_fbb, const RulesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LhsSetT : public flatbuffers::NativeTable {
  typedef LhsSet TableType;
  std::vector<int32_t> lhs;
  LhsSetT() {
  }
};

struct LhsSet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LhsSetT NativeTableType;
  typedef LhsSetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LHS = 4
  };
  const flatbuffers::Vector<int32_t> *lhs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_LHS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LHS) &&
           verifier.VerifyVector(lhs()) &&
           verifier.EndTable();
  }
  LhsSetT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LhsSetT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LhsSet> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LhsSetT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LhsSetBuilder {
  typedef LhsSet Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lhs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> lhs) {
    fbb_.AddOffset(LhsSet::VT_LHS, lhs);
  }
  explicit LhsSetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LhsSetBuilder &operator=(const LhsSetBuilder &);
  flatbuffers::Offset<LhsSet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LhsSet>(end);
    return o;
  }
};

inline flatbuffers::Offset<LhsSet> CreateLhsSet(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> lhs = 0) {
  LhsSetBuilder builder_(_fbb);
  builder_.add_lhs(lhs);
  return builder_.Finish();
}

inline flatbuffers::Offset<LhsSet> CreateLhsSetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *lhs = nullptr) {
  auto lhs__ = lhs ? _fbb.CreateVector<int32_t>(*lhs) : 0;
  return libtextclassifier3::grammar::RulesSet_::CreateLhsSet(
      _fbb,
      lhs__);
}

flatbuffers::Offset<LhsSet> CreateLhsSet(flatbuffers::FlatBufferBuilder &_fbb, const LhsSetT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace Nonterminals_ {

struct AnnotationNtEntryT : public flatbuffers::NativeTable {
  typedef AnnotationNtEntry TableType;
  std::string key;
  int32_t value;
  AnnotationNtEntryT()
      : value(0) {
  }
};

struct AnnotationNtEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnnotationNtEntryT NativeTableType;
  typedef AnnotationNtEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  bool KeyCompareLessThan(const AnnotationNtEntry *o) const {
    return *key() < *o->key();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(key()->c_str(), val);
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
  AnnotationNtEntryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AnnotationNtEntryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AnnotationNtEntry> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnnotationNtEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AnnotationNtEntryBuilder {
  typedef AnnotationNtEntry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(AnnotationNtEntry::VT_KEY, key);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(AnnotationNtEntry::VT_VALUE, value, 0);
  }
  explicit AnnotationNtEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnnotationNtEntryBuilder &operator=(const AnnotationNtEntryBuilder &);
  flatbuffers::Offset<AnnotationNtEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnnotationNtEntry>(end);
    fbb_.Required(o, AnnotationNtEntry::VT_KEY);
    return o;
  }
};

inline flatbuffers::Offset<AnnotationNtEntry> CreateAnnotationNtEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    int32_t value = 0) {
  AnnotationNtEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnnotationNtEntry> CreateAnnotationNtEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    int32_t value = 0) {
  auto key__ = key ? _fbb.CreateSharedString(key) : 0;
  return libtextclassifier3::grammar::RulesSet_::Nonterminals_::CreateAnnotationNtEntry(
      _fbb,
      key__,
      value);
}

flatbuffers::Offset<AnnotationNtEntry> CreateAnnotationNtEntry(flatbuffers::FlatBufferBuilder &_fbb, const AnnotationNtEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace Nonterminals_

struct NonterminalsT : public flatbuffers::NativeTable {
  typedef Nonterminals TableType;
  int32_t start_nt;
  int32_t end_nt;
  int32_t token_nt;
  int32_t digits_nt;
  std::vector<int32_t> n_digits_nt;
  int32_t wordbreak_nt;
  int32_t uppercase_token_nt;
  std::vector<std::unique_ptr<libtextclassifier3::grammar::RulesSet_::Nonterminals_::AnnotationNtEntryT>> annotation_nt;
  NonterminalsT()
      : start_nt(0),
        end_nt(0),
        token_nt(0),
        digits_nt(0),
        wordbreak_nt(0),
        uppercase_token_nt(0) {
  }
};

struct Nonterminals FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NonterminalsT NativeTableType;
  typedef NonterminalsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START_NT = 4,
    VT_END_NT = 6,
    VT_TOKEN_NT = 8,
    VT_DIGITS_NT = 10,
    VT_N_DIGITS_NT = 12,
    VT_WORDBREAK_NT = 14,
    VT_UPPERCASE_TOKEN_NT = 16,
    VT_ANNOTATION_NT = 18
  };
  int32_t start_nt() const {
    return GetField<int32_t>(VT_START_NT, 0);
  }
  int32_t end_nt() const {
    return GetField<int32_t>(VT_END_NT, 0);
  }
  int32_t token_nt() const {
    return GetField<int32_t>(VT_TOKEN_NT, 0);
  }
  int32_t digits_nt() const {
    return GetField<int32_t>(VT_DIGITS_NT, 0);
  }
  const flatbuffers::Vector<int32_t> *n_digits_nt() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_N_DIGITS_NT);
  }
  int32_t wordbreak_nt() const {
    return GetField<int32_t>(VT_WORDBREAK_NT, 0);
  }
  int32_t uppercase_token_nt() const {
    return GetField<int32_t>(VT_UPPERCASE_TOKEN_NT, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Nonterminals_::AnnotationNtEntry>> *annotation_nt() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Nonterminals_::AnnotationNtEntry>> *>(VT_ANNOTATION_NT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_START_NT) &&
           VerifyField<int32_t>(verifier, VT_END_NT) &&
           VerifyField<int32_t>(verifier, VT_TOKEN_NT) &&
           VerifyField<int32_t>(verifier, VT_DIGITS_NT) &&
           VerifyOffset(verifier, VT_N_DIGITS_NT) &&
           verifier.VerifyVector(n_digits_nt()) &&
           VerifyField<int32_t>(verifier, VT_WORDBREAK_NT) &&
           VerifyField<int32_t>(verifier, VT_UPPERCASE_TOKEN_NT) &&
           VerifyOffset(verifier, VT_ANNOTATION_NT) &&
           verifier.VerifyVector(annotation_nt()) &&
           verifier.VerifyVectorOfTables(annotation_nt()) &&
           verifier.EndTable();
  }
  NonterminalsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NonterminalsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Nonterminals> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonterminalsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NonterminalsBuilder {
  typedef Nonterminals Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_start_nt(int32_t start_nt) {
    fbb_.AddElement<int32_t>(Nonterminals::VT_START_NT, start_nt, 0);
  }
  void add_end_nt(int32_t end_nt) {
    fbb_.AddElement<int32_t>(Nonterminals::VT_END_NT, end_nt, 0);
  }
  void add_token_nt(int32_t token_nt) {
    fbb_.AddElement<int32_t>(Nonterminals::VT_TOKEN_NT, token_nt, 0);
  }
  void add_digits_nt(int32_t digits_nt) {
    fbb_.AddElement<int32_t>(Nonterminals::VT_DIGITS_NT, digits_nt, 0);
  }
  void add_n_digits_nt(flatbuffers::Offset<flatbuffers::Vector<int32_t>> n_digits_nt) {
    fbb_.AddOffset(Nonterminals::VT_N_DIGITS_NT, n_digits_nt);
  }
  void add_wordbreak_nt(int32_t wordbreak_nt) {
    fbb_.AddElement<int32_t>(Nonterminals::VT_WORDBREAK_NT, wordbreak_nt, 0);
  }
  void add_uppercase_token_nt(int32_t uppercase_token_nt) {
    fbb_.AddElement<int32_t>(Nonterminals::VT_UPPERCASE_TOKEN_NT, uppercase_token_nt, 0);
  }
  void add_annotation_nt(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Nonterminals_::AnnotationNtEntry>>> annotation_nt) {
    fbb_.AddOffset(Nonterminals::VT_ANNOTATION_NT, annotation_nt);
  }
  explicit NonterminalsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonterminalsBuilder &operator=(const NonterminalsBuilder &);
  flatbuffers::Offset<Nonterminals> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Nonterminals>(end);
    return o;
  }
};

inline flatbuffers::Offset<Nonterminals> CreateNonterminals(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t start_nt = 0,
    int32_t end_nt = 0,
    int32_t token_nt = 0,
    int32_t digits_nt = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> n_digits_nt = 0,
    int32_t wordbreak_nt = 0,
    int32_t uppercase_token_nt = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Nonterminals_::AnnotationNtEntry>>> annotation_nt = 0) {
  NonterminalsBuilder builder_(_fbb);
  builder_.add_annotation_nt(annotation_nt);
  builder_.add_uppercase_token_nt(uppercase_token_nt);
  builder_.add_wordbreak_nt(wordbreak_nt);
  builder_.add_n_digits_nt(n_digits_nt);
  builder_.add_digits_nt(digits_nt);
  builder_.add_token_nt(token_nt);
  builder_.add_end_nt(end_nt);
  builder_.add_start_nt(start_nt);
  return builder_.Finish();
}

inline flatbuffers::Offset<Nonterminals> CreateNonterminalsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t start_nt = 0,
    int32_t end_nt = 0,
    int32_t token_nt = 0,
    int32_t digits_nt = 0,
    const std::vector<int32_t> *n_digits_nt = nullptr,
    int32_t wordbreak_nt = 0,
    int32_t uppercase_token_nt = 0,
    std::vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Nonterminals_::AnnotationNtEntry>> *annotation_nt = nullptr) {
  auto n_digits_nt__ = n_digits_nt ? _fbb.CreateVector<int32_t>(*n_digits_nt) : 0;
  auto annotation_nt__ = annotation_nt ? _fbb.CreateVectorOfSortedTables<libtextclassifier3::grammar::RulesSet_::Nonterminals_::AnnotationNtEntry>(annotation_nt) : 0;
  return libtextclassifier3::grammar::RulesSet_::CreateNonterminals(
      _fbb,
      start_nt,
      end_nt,
      token_nt,
      digits_nt,
      n_digits_nt__,
      wordbreak_nt,
      uppercase_token_nt,
      annotation_nt__);
}

flatbuffers::Offset<Nonterminals> CreateNonterminals(flatbuffers::FlatBufferBuilder &_fbb, const NonterminalsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace DebugInformation_ {

struct NonterminalNamesEntryT : public flatbuffers::NativeTable {
  typedef NonterminalNamesEntry TableType;
  int32_t key;
  std::string value;
  NonterminalNamesEntryT()
      : key(0) {
  }
};

struct NonterminalNamesEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NonterminalNamesEntryT NativeTableType;
  typedef NonterminalNamesEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  int32_t key() const {
    return GetField<int32_t>(VT_KEY, 0);
  }
  bool KeyCompareLessThan(const NonterminalNamesEntry *o) const {
    return key() < o->key();
  }
  int KeyCompareWithValue(int32_t val) const {
    return static_cast<int>(key() > val) - static_cast<int>(key() < val);
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KEY) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
  NonterminalNamesEntryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NonterminalNamesEntryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NonterminalNamesEntry> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonterminalNamesEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NonterminalNamesEntryBuilder {
  typedef NonterminalNamesEntry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(int32_t key) {
    fbb_.AddElement<int32_t>(NonterminalNamesEntry::VT_KEY, key, 0);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(NonterminalNamesEntry::VT_VALUE, value);
  }
  explicit NonterminalNamesEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonterminalNamesEntryBuilder &operator=(const NonterminalNamesEntryBuilder &);
  flatbuffers::Offset<NonterminalNamesEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonterminalNamesEntry>(end);
    return o;
  }
};

inline flatbuffers::Offset<NonterminalNamesEntry> CreateNonterminalNamesEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t key = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  NonterminalNamesEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<NonterminalNamesEntry> CreateNonterminalNamesEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t key = 0,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateSharedString(value) : 0;
  return libtextclassifier3::grammar::RulesSet_::DebugInformation_::CreateNonterminalNamesEntry(
      _fbb,
      key,
      value__);
}

flatbuffers::Offset<NonterminalNamesEntry> CreateNonterminalNamesEntry(flatbuffers::FlatBufferBuilder &_fbb, const NonterminalNamesEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace DebugInformation_

struct DebugInformationT : public flatbuffers::NativeTable {
  typedef DebugInformation TableType;
  std::vector<std::unique_ptr<libtextclassifier3::grammar::RulesSet_::DebugInformation_::NonterminalNamesEntryT>> nonterminal_names;
  DebugInformationT() {
  }
};

struct DebugInformation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DebugInformationT NativeTableType;
  typedef DebugInformationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NONTERMINAL_NAMES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::DebugInformation_::NonterminalNamesEntry>> *nonterminal_names() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::DebugInformation_::NonterminalNamesEntry>> *>(VT_NONTERMINAL_NAMES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NONTERMINAL_NAMES) &&
           verifier.VerifyVector(nonterminal_names()) &&
           verifier.VerifyVectorOfTables(nonterminal_names()) &&
           verifier.EndTable();
  }
  DebugInformationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DebugInformationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DebugInformation> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DebugInformationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DebugInformationBuilder {
  typedef DebugInformation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nonterminal_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::DebugInformation_::NonterminalNamesEntry>>> nonterminal_names) {
    fbb_.AddOffset(DebugInformation::VT_NONTERMINAL_NAMES, nonterminal_names);
  }
  explicit DebugInformationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DebugInformationBuilder &operator=(const DebugInformationBuilder &);
  flatbuffers::Offset<DebugInformation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DebugInformation>(end);
    return o;
  }
};

inline flatbuffers::Offset<DebugInformation> CreateDebugInformation(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::DebugInformation_::NonterminalNamesEntry>>> nonterminal_names = 0) {
  DebugInformationBuilder builder_(_fbb);
  builder_.add_nonterminal_names(nonterminal_names);
  return builder_.Finish();
}

inline flatbuffers::Offset<DebugInformation> CreateDebugInformationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    std::vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::DebugInformation_::NonterminalNamesEntry>> *nonterminal_names = nullptr) {
  auto nonterminal_names__ = nonterminal_names ? _fbb.CreateVectorOfSortedTables<libtextclassifier3::grammar::RulesSet_::DebugInformation_::NonterminalNamesEntry>(nonterminal_names) : 0;
  return libtextclassifier3::grammar::RulesSet_::CreateDebugInformation(
      _fbb,
      nonterminal_names__);
}

flatbuffers::Offset<DebugInformation> CreateDebugInformation(flatbuffers::FlatBufferBuilder &_fbb, const DebugInformationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RegexAnnotatorT : public flatbuffers::NativeTable {
  typedef RegexAnnotator TableType;
  std::string pattern;
  std::unique_ptr<libtextclassifier3::CompressedBufferT> compressed_pattern;
  uint32_t nonterminal;
  RegexAnnotatorT()
      : nonterminal(0) {
  }
};

struct RegexAnnotator FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RegexAnnotatorT NativeTableType;
  typedef RegexAnnotatorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATTERN = 4,
    VT_COMPRESSED_PATTERN = 6,
    VT_NONTERMINAL = 8
  };
  const flatbuffers::String *pattern() const {
    return GetPointer<const flatbuffers::String *>(VT_PATTERN);
  }
  const libtextclassifier3::CompressedBuffer *compressed_pattern() const {
    return GetPointer<const libtextclassifier3::CompressedBuffer *>(VT_COMPRESSED_PATTERN);
  }
  uint32_t nonterminal() const {
    return GetField<uint32_t>(VT_NONTERMINAL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATTERN) &&
           verifier.VerifyString(pattern()) &&
           VerifyOffset(verifier, VT_COMPRESSED_PATTERN) &&
           verifier.VerifyTable(compressed_pattern()) &&
           VerifyField<uint32_t>(verifier, VT_NONTERMINAL) &&
           verifier.EndTable();
  }
  RegexAnnotatorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RegexAnnotatorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RegexAnnotator> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegexAnnotatorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RegexAnnotatorBuilder {
  typedef RegexAnnotator Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pattern(flatbuffers::Offset<flatbuffers::String> pattern) {
    fbb_.AddOffset(RegexAnnotator::VT_PATTERN, pattern);
  }
  void add_compressed_pattern(flatbuffers::Offset<libtextclassifier3::CompressedBuffer> compressed_pattern) {
    fbb_.AddOffset(RegexAnnotator::VT_COMPRESSED_PATTERN, compressed_pattern);
  }
  void add_nonterminal(uint32_t nonterminal) {
    fbb_.AddElement<uint32_t>(RegexAnnotator::VT_NONTERMINAL, nonterminal, 0);
  }
  explicit RegexAnnotatorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RegexAnnotatorBuilder &operator=(const RegexAnnotatorBuilder &);
  flatbuffers::Offset<RegexAnnotator> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RegexAnnotator>(end);
    return o;
  }
};

inline flatbuffers::Offset<RegexAnnotator> CreateRegexAnnotator(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> pattern = 0,
    flatbuffers::Offset<libtextclassifier3::CompressedBuffer> compressed_pattern = 0,
    uint32_t nonterminal = 0) {
  RegexAnnotatorBuilder builder_(_fbb);
  builder_.add_nonterminal(nonterminal);
  builder_.add_compressed_pattern(compressed_pattern);
  builder_.add_pattern(pattern);
  return builder_.Finish();
}

inline flatbuffers::Offset<RegexAnnotator> CreateRegexAnnotatorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *pattern = nullptr,
    flatbuffers::Offset<libtextclassifier3::CompressedBuffer> compressed_pattern = 0,
    uint32_t nonterminal = 0) {
  auto pattern__ = pattern ? _fbb.CreateSharedString(pattern) : 0;
  return libtextclassifier3::grammar::RulesSet_::CreateRegexAnnotator(
      _fbb,
      pattern__,
      compressed_pattern,
      nonterminal);
}

flatbuffers::Offset<RegexAnnotator> CreateRegexAnnotator(flatbuffers::FlatBufferBuilder &_fbb, const RegexAnnotatorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace RulesSet_

struct RulesSetT : public flatbuffers::NativeTable {
  typedef RulesSet TableType;
  std::vector<std::unique_ptr<libtextclassifier3::grammar::RulesSet_::RulesT>> rules;
  std::vector<std::unique_ptr<libtextclassifier3::grammar::RulesSet_::LhsSetT>> lhs_set;
  std::vector<libtextclassifier3::grammar::RulesSet_::Lhs> lhs;
  std::string terminals;
  std::unique_ptr<libtextclassifier3::grammar::RulesSet_::NonterminalsT> nonterminals;
  std::unique_ptr<libtextclassifier3::grammar::RulesSet_::DebugInformationT> debug_information;
  std::vector<std::unique_ptr<libtextclassifier3::grammar::RulesSet_::RegexAnnotatorT>> regex_annotator;
  bool lazy_regex_compilation;
  std::vector<std::unique_ptr<libtextclassifier3::grammar::SemanticExpressionT>> semantic_expression;
  std::vector<uint8_t> semantic_values_schema;
  RulesSetT()
      : lazy_regex_compilation(false) {
  }
};

struct RulesSet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RulesSetT NativeTableType;
  typedef RulesSetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RULES = 4,
    VT_LHS_SET = 6,
    VT_LHS = 8,
    VT_TERMINALS = 10,
    VT_NONTERMINALS = 12,
    VT_DEBUG_INFORMATION = 16,
    VT_REGEX_ANNOTATOR = 18,
    VT_LAZY_REGEX_COMPILATION = 20,
    VT_SEMANTIC_EXPRESSION = 22,
    VT_SEMANTIC_VALUES_SCHEMA = 24
  };
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Rules>> *rules() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Rules>> *>(VT_RULES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::LhsSet>> *lhs_set() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::LhsSet>> *>(VT_LHS_SET);
  }
  const flatbuffers::Vector<const libtextclassifier3::grammar::RulesSet_::Lhs *> *lhs() const {
    return GetPointer<const flatbuffers::Vector<const libtextclassifier3::grammar::RulesSet_::Lhs *> *>(VT_LHS);
  }
  const flatbuffers::String *terminals() const {
    return GetPointer<const flatbuffers::String *>(VT_TERMINALS);
  }
  const libtextclassifier3::grammar::RulesSet_::Nonterminals *nonterminals() const {
    return GetPointer<const libtextclassifier3::grammar::RulesSet_::Nonterminals *>(VT_NONTERMINALS);
  }
  const libtextclassifier3::grammar::RulesSet_::DebugInformation *debug_information() const {
    return GetPointer<const libtextclassifier3::grammar::RulesSet_::DebugInformation *>(VT_DEBUG_INFORMATION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::RegexAnnotator>> *regex_annotator() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::RegexAnnotator>> *>(VT_REGEX_ANNOTATOR);
  }
  bool lazy_regex_compilation() const {
    return GetField<uint8_t>(VT_LAZY_REGEX_COMPILATION, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::SemanticExpression>> *semantic_expression() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::SemanticExpression>> *>(VT_SEMANTIC_EXPRESSION);
  }
  const flatbuffers::Vector<uint8_t> *semantic_values_schema() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SEMANTIC_VALUES_SCHEMA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RULES) &&
           verifier.VerifyVector(rules()) &&
           verifier.VerifyVectorOfTables(rules()) &&
           VerifyOffset(verifier, VT_LHS_SET) &&
           verifier.VerifyVector(lhs_set()) &&
           verifier.VerifyVectorOfTables(lhs_set()) &&
           VerifyOffset(verifier, VT_LHS) &&
           verifier.VerifyVector(lhs()) &&
           VerifyOffset(verifier, VT_TERMINALS) &&
           verifier.VerifyString(terminals()) &&
           VerifyOffset(verifier, VT_NONTERMINALS) &&
           verifier.VerifyTable(nonterminals()) &&
           VerifyOffset(verifier, VT_DEBUG_INFORMATION) &&
           verifier.VerifyTable(debug_information()) &&
           VerifyOffset(verifier, VT_REGEX_ANNOTATOR) &&
           verifier.VerifyVector(regex_annotator()) &&
           verifier.VerifyVectorOfTables(regex_annotator()) &&
           VerifyField<uint8_t>(verifier, VT_LAZY_REGEX_COMPILATION) &&
           VerifyOffset(verifier, VT_SEMANTIC_EXPRESSION) &&
           verifier.VerifyVector(semantic_expression()) &&
           verifier.VerifyVectorOfTables(semantic_expression()) &&
           VerifyOffset(verifier, VT_SEMANTIC_VALUES_SCHEMA) &&
           verifier.VerifyVector(semantic_values_schema()) &&
           verifier.EndTable();
  }
  RulesSetT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RulesSetT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RulesSet> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RulesSetT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RulesSetBuilder {
  typedef RulesSet Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rules(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Rules>>> rules) {
    fbb_.AddOffset(RulesSet::VT_RULES, rules);
  }
  void add_lhs_set(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::LhsSet>>> lhs_set) {
    fbb_.AddOffset(RulesSet::VT_LHS_SET, lhs_set);
  }
  void add_lhs(flatbuffers::Offset<flatbuffers::Vector<const libtextclassifier3::grammar::RulesSet_::Lhs *>> lhs) {
    fbb_.AddOffset(RulesSet::VT_LHS, lhs);
  }
  void add_terminals(flatbuffers::Offset<flatbuffers::String> terminals) {
    fbb_.AddOffset(RulesSet::VT_TERMINALS, terminals);
  }
  void add_nonterminals(flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Nonterminals> nonterminals) {
    fbb_.AddOffset(RulesSet::VT_NONTERMINALS, nonterminals);
  }
  void add_debug_information(flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::DebugInformation> debug_information) {
    fbb_.AddOffset(RulesSet::VT_DEBUG_INFORMATION, debug_information);
  }
  void add_regex_annotator(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::RegexAnnotator>>> regex_annotator) {
    fbb_.AddOffset(RulesSet::VT_REGEX_ANNOTATOR, regex_annotator);
  }
  void add_lazy_regex_compilation(bool lazy_regex_compilation) {
    fbb_.AddElement<uint8_t>(RulesSet::VT_LAZY_REGEX_COMPILATION, static_cast<uint8_t>(lazy_regex_compilation), 0);
  }
  void add_semantic_expression(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::SemanticExpression>>> semantic_expression) {
    fbb_.AddOffset(RulesSet::VT_SEMANTIC_EXPRESSION, semantic_expression);
  }
  void add_semantic_values_schema(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> semantic_values_schema) {
    fbb_.AddOffset(RulesSet::VT_SEMANTIC_VALUES_SCHEMA, semantic_values_schema);
  }
  explicit RulesSetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RulesSetBuilder &operator=(const RulesSetBuilder &);
  flatbuffers::Offset<RulesSet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RulesSet>(end);
    return o;
  }
};

inline flatbuffers::Offset<RulesSet> CreateRulesSet(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Rules>>> rules = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::LhsSet>>> lhs_set = 0,
    flatbuffers::Offset<flatbuffers::Vector<const libtextclassifier3::grammar::RulesSet_::Lhs *>> lhs = 0,
    flatbuffers::Offset<flatbuffers::String> terminals = 0,
    flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Nonterminals> nonterminals = 0,
    flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::DebugInformation> debug_information = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::RegexAnnotator>>> regex_annotator = 0,
    bool lazy_regex_compilation = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<libtextclassifier3::grammar::SemanticExpression>>> semantic_expression = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> semantic_values_schema = 0) {
  RulesSetBuilder builder_(_fbb);
  builder_.add_semantic_values_schema(semantic_values_schema);
  builder_.add_semantic_expression(semantic_expression);
  builder_.add_regex_annotator(regex_annotator);
  builder_.add_debug_information(debug_information);
  builder_.add_nonterminals(nonterminals);
  builder_.add_terminals(terminals);
  builder_.add_lhs(lhs);
  builder_.add_lhs_set(lhs_set);
  builder_.add_rules(rules);
  builder_.add_lazy_regex_compilation(lazy_regex_compilation);
  return builder_.Finish();
}

inline flatbuffers::Offset<RulesSet> CreateRulesSetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Rules>> *rules = nullptr,
    const std::vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::LhsSet>> *lhs_set = nullptr,
    const std::vector<libtextclassifier3::grammar::RulesSet_::Lhs> *lhs = nullptr,
    const char *terminals = nullptr,
    flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Nonterminals> nonterminals = 0,
    flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::DebugInformation> debug_information = 0,
    const std::vector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::RegexAnnotator>> *regex_annotator = nullptr,
    bool lazy_regex_compilation = false,
    const std::vector<flatbuffers::Offset<libtextclassifier3::grammar::SemanticExpression>> *semantic_expression = nullptr,
    const std::vector<uint8_t> *semantic_values_schema = nullptr) {
  auto rules__ = rules ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Rules>>(*rules) : 0;
  auto lhs_set__ = lhs_set ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::LhsSet>>(*lhs_set) : 0;
  auto lhs__ = lhs ? _fbb.CreateVectorOfStructs<libtextclassifier3::grammar::RulesSet_::Lhs>(*lhs) : 0;
  auto terminals__ = terminals ? _fbb.CreateSharedString(terminals) : 0;
  auto regex_annotator__ = regex_annotator ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::RegexAnnotator>>(*regex_annotator) : 0;
  auto semantic_expression__ = semantic_expression ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::grammar::SemanticExpression>>(*semantic_expression) : 0;
  auto semantic_values_schema__ = semantic_values_schema ? _fbb.CreateVector<uint8_t>(*semantic_values_schema) : 0;
  return libtextclassifier3::grammar::CreateRulesSet(
      _fbb,
      rules__,
      lhs_set__,
      lhs__,
      terminals__,
      nonterminals,
      debug_information,
      regex_annotator__,
      lazy_regex_compilation,
      semantic_expression__,
      semantic_values_schema__);
}

flatbuffers::Offset<RulesSet> CreateRulesSet(flatbuffers::FlatBufferBuilder &_fbb, const RulesSetT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace RulesSet_ {
namespace Rules_ {

inline TerminalRulesMapT *TerminalRulesMap::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::grammar::RulesSet_::Rules_::TerminalRulesMapT> _o = std::unique_ptr<libtextclassifier3::grammar::RulesSet_::Rules_::TerminalRulesMapT>(new TerminalRulesMapT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TerminalRulesMap::UnPackTo(TerminalRulesMapT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = terminal_offsets(); if (_e) { _o->terminal_offsets.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->terminal_offsets[_i] = _e->Get(_i); } } }
  { auto _e = lhs_set_index(); if (_e) { _o->lhs_set_index.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->lhs_set_index[_i] = _e->Get(_i); } } }
  { auto _e = min_terminal_length(); _o->min_terminal_length = _e; }
  { auto _e = max_terminal_length(); _o->max_terminal_length = _e; }
}

inline flatbuffers::Offset<TerminalRulesMap> TerminalRulesMap::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TerminalRulesMapT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTerminalRulesMap(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TerminalRulesMap> CreateTerminalRulesMap(flatbuffers::FlatBufferBuilder &_fbb, const TerminalRulesMapT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TerminalRulesMapT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _terminal_offsets = _o->terminal_offsets.size() ? _fbb.CreateVector(_o->terminal_offsets) : 0;
  auto _lhs_set_index = _o->lhs_set_index.size() ? _fbb.CreateVector(_o->lhs_set_index) : 0;
  auto _min_terminal_length = _o->min_terminal_length;
  auto _max_terminal_length = _o->max_terminal_length;
  return libtextclassifier3::grammar::RulesSet_::Rules_::CreateTerminalRulesMap(
      _fbb,
      _terminal_offsets,
      _lhs_set_index,
      _min_terminal_length,
      _max_terminal_length);
}

inline BinaryRuleTableBucketT *BinaryRuleTableBucket::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::grammar::RulesSet_::Rules_::BinaryRuleTableBucketT> _o = std::unique_ptr<libtextclassifier3::grammar::RulesSet_::Rules_::BinaryRuleTableBucketT>(new BinaryRuleTableBucketT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BinaryRuleTableBucket::UnPackTo(BinaryRuleTableBucketT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rules(); if (_e) { _o->rules.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rules[_i] = *_e->Get(_i); } } }
}

inline flatbuffers::Offset<BinaryRuleTableBucket> BinaryRuleTableBucket::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BinaryRuleTableBucketT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBinaryRuleTableBucket(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BinaryRuleTableBucket> CreateBinaryRuleTableBucket(flatbuffers::FlatBufferBuilder &_fbb, const BinaryRuleTableBucketT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BinaryRuleTableBucketT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rules = _o->rules.size() ? _fbb.CreateVectorOfStructs(_o->rules) : 0;
  return libtextclassifier3::grammar::RulesSet_::Rules_::CreateBinaryRuleTableBucket(
      _fbb,
      _rules);
}

}  // namespace Rules_

inline RulesT *Rules::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::grammar::RulesSet_::RulesT> _o = std::unique_ptr<libtextclassifier3::grammar::RulesSet_::RulesT>(new RulesT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Rules::UnPackTo(RulesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = locale(); if (_e) { _o->locale.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->locale[_i] = std::unique_ptr<libtextclassifier3::LanguageTagT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = terminal_rules(); if (_e) _o->terminal_rules = std::unique_ptr<libtextclassifier3::grammar::RulesSet_::Rules_::TerminalRulesMapT>(_e->UnPack(_resolver)); }
  { auto _e = lowercase_terminal_rules(); if (_e) _o->lowercase_terminal_rules = std::unique_ptr<libtextclassifier3::grammar::RulesSet_::Rules_::TerminalRulesMapT>(_e->UnPack(_resolver)); }
  { auto _e = unary_rules(); if (_e) { _o->unary_rules.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->unary_rules[_i] = *_e->Get(_i); } } }
  { auto _e = binary_rules(); if (_e) { _o->binary_rules.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->binary_rules[_i] = std::unique_ptr<libtextclassifier3::grammar::RulesSet_::Rules_::BinaryRuleTableBucketT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<Rules> Rules::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RulesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRules(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Rules> CreateRules(flatbuffers::FlatBufferBuilder &_fbb, const RulesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RulesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _locale = _o->locale.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::LanguageTag>> (_o->locale.size(), [](size_t i, _VectorArgs *__va) { return CreateLanguageTag(*__va->__fbb, __va->__o->locale[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _terminal_rules = _o->terminal_rules ? CreateTerminalRulesMap(_fbb, _o->terminal_rules.get(), _rehasher) : 0;
  auto _lowercase_terminal_rules = _o->lowercase_terminal_rules ? CreateTerminalRulesMap(_fbb, _o->lowercase_terminal_rules.get(), _rehasher) : 0;
  auto _unary_rules = _o->unary_rules.size() ? _fbb.CreateVectorOfStructs(_o->unary_rules) : 0;
  auto _binary_rules = _o->binary_rules.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Rules_::BinaryRuleTableBucket>> (_o->binary_rules.size(), [](size_t i, _VectorArgs *__va) { return CreateBinaryRuleTableBucket(*__va->__fbb, __va->__o->binary_rules[i].get(), __va->__rehasher); }, &_va ) : 0;
  return libtextclassifier3::grammar::RulesSet_::CreateRules(
      _fbb,
      _locale,
      _terminal_rules,
      _lowercase_terminal_rules,
      _unary_rules,
      _binary_rules);
}

inline LhsSetT *LhsSet::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::grammar::RulesSet_::LhsSetT> _o = std::unique_ptr<libtextclassifier3::grammar::RulesSet_::LhsSetT>(new LhsSetT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LhsSet::UnPackTo(LhsSetT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = lhs(); if (_e) { _o->lhs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->lhs[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<LhsSet> LhsSet::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LhsSetT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLhsSet(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LhsSet> CreateLhsSet(flatbuffers::FlatBufferBuilder &_fbb, const LhsSetT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LhsSetT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _lhs = _o->lhs.size() ? _fbb.CreateVector(_o->lhs) : 0;
  return libtextclassifier3::grammar::RulesSet_::CreateLhsSet(
      _fbb,
      _lhs);
}

namespace Nonterminals_ {

inline AnnotationNtEntryT *AnnotationNtEntry::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::grammar::RulesSet_::Nonterminals_::AnnotationNtEntryT> _o = std::unique_ptr<libtextclassifier3::grammar::RulesSet_::Nonterminals_::AnnotationNtEntryT>(new AnnotationNtEntryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AnnotationNtEntry::UnPackTo(AnnotationNtEntryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = key(); if (_e) _o->key = _e->str(); }
  { auto _e = value(); _o->value = _e; }
}

inline flatbuffers::Offset<AnnotationNtEntry> AnnotationNtEntry::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnnotationNtEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAnnotationNtEntry(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AnnotationNtEntry> CreateAnnotationNtEntry(flatbuffers::FlatBufferBuilder &_fbb, const AnnotationNtEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AnnotationNtEntryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _key = _fbb.CreateSharedString(_o->key);
  auto _value = _o->value;
  return libtextclassifier3::grammar::RulesSet_::Nonterminals_::CreateAnnotationNtEntry(
      _fbb,
      _key,
      _value);
}

}  // namespace Nonterminals_

inline NonterminalsT *Nonterminals::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::grammar::RulesSet_::NonterminalsT> _o = std::unique_ptr<libtextclassifier3::grammar::RulesSet_::NonterminalsT>(new NonterminalsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Nonterminals::UnPackTo(NonterminalsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = start_nt(); _o->start_nt = _e; }
  { auto _e = end_nt(); _o->end_nt = _e; }
  { auto _e = token_nt(); _o->token_nt = _e; }
  { auto _e = digits_nt(); _o->digits_nt = _e; }
  { auto _e = n_digits_nt(); if (_e) { _o->n_digits_nt.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->n_digits_nt[_i] = _e->Get(_i); } } }
  { auto _e = wordbreak_nt(); _o->wordbreak_nt = _e; }
  { auto _e = uppercase_token_nt(); _o->uppercase_token_nt = _e; }
  { auto _e = annotation_nt(); if (_e) { _o->annotation_nt.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->annotation_nt[_i] = std::unique_ptr<libtextclassifier3::grammar::RulesSet_::Nonterminals_::AnnotationNtEntryT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<Nonterminals> Nonterminals::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonterminalsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNonterminals(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Nonterminals> CreateNonterminals(flatbuffers::FlatBufferBuilder &_fbb, const NonterminalsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NonterminalsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _start_nt = _o->start_nt;
  auto _end_nt = _o->end_nt;
  auto _token_nt = _o->token_nt;
  auto _digits_nt = _o->digits_nt;
  auto _n_digits_nt = _o->n_digits_nt.size() ? _fbb.CreateVector(_o->n_digits_nt) : 0;
  auto _wordbreak_nt = _o->wordbreak_nt;
  auto _uppercase_token_nt = _o->uppercase_token_nt;
  auto _annotation_nt = _o->annotation_nt.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Nonterminals_::AnnotationNtEntry>> (_o->annotation_nt.size(), [](size_t i, _VectorArgs *__va) { return CreateAnnotationNtEntry(*__va->__fbb, __va->__o->annotation_nt[i].get(), __va->__rehasher); }, &_va ) : 0;
  return libtextclassifier3::grammar::RulesSet_::CreateNonterminals(
      _fbb,
      _start_nt,
      _end_nt,
      _token_nt,
      _digits_nt,
      _n_digits_nt,
      _wordbreak_nt,
      _uppercase_token_nt,
      _annotation_nt);
}

namespace DebugInformation_ {

inline NonterminalNamesEntryT *NonterminalNamesEntry::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::grammar::RulesSet_::DebugInformation_::NonterminalNamesEntryT> _o = std::unique_ptr<libtextclassifier3::grammar::RulesSet_::DebugInformation_::NonterminalNamesEntryT>(new NonterminalNamesEntryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NonterminalNamesEntry::UnPackTo(NonterminalNamesEntryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = key(); _o->key = _e; }
  { auto _e = value(); if (_e) _o->value = _e->str(); }
}

inline flatbuffers::Offset<NonterminalNamesEntry> NonterminalNamesEntry::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonterminalNamesEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNonterminalNamesEntry(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NonterminalNamesEntry> CreateNonterminalNamesEntry(flatbuffers::FlatBufferBuilder &_fbb, const NonterminalNamesEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NonterminalNamesEntryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _key = _o->key;
  auto _value = _o->value.empty() ? 0 : _fbb.CreateSharedString(_o->value);
  return libtextclassifier3::grammar::RulesSet_::DebugInformation_::CreateNonterminalNamesEntry(
      _fbb,
      _key,
      _value);
}

}  // namespace DebugInformation_

inline DebugInformationT *DebugInformation::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::grammar::RulesSet_::DebugInformationT> _o = std::unique_ptr<libtextclassifier3::grammar::RulesSet_::DebugInformationT>(new DebugInformationT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DebugInformation::UnPackTo(DebugInformationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = nonterminal_names(); if (_e) { _o->nonterminal_names.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->nonterminal_names[_i] = std::unique_ptr<libtextclassifier3::grammar::RulesSet_::DebugInformation_::NonterminalNamesEntryT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<DebugInformation> DebugInformation::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DebugInformationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDebugInformation(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DebugInformation> CreateDebugInformation(flatbuffers::FlatBufferBuilder &_fbb, const DebugInformationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DebugInformationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _nonterminal_names = _o->nonterminal_names.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::DebugInformation_::NonterminalNamesEntry>> (_o->nonterminal_names.size(), [](size_t i, _VectorArgs *__va) { return CreateNonterminalNamesEntry(*__va->__fbb, __va->__o->nonterminal_names[i].get(), __va->__rehasher); }, &_va ) : 0;
  return libtextclassifier3::grammar::RulesSet_::CreateDebugInformation(
      _fbb,
      _nonterminal_names);
}

inline RegexAnnotatorT *RegexAnnotator::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::grammar::RulesSet_::RegexAnnotatorT> _o = std::unique_ptr<libtextclassifier3::grammar::RulesSet_::RegexAnnotatorT>(new RegexAnnotatorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RegexAnnotator::UnPackTo(RegexAnnotatorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pattern(); if (_e) _o->pattern = _e->str(); }
  { auto _e = compressed_pattern(); if (_e) _o->compressed_pattern = std::unique_ptr<libtextclassifier3::CompressedBufferT>(_e->UnPack(_resolver)); }
  { auto _e = nonterminal(); _o->nonterminal = _e; }
}

inline flatbuffers::Offset<RegexAnnotator> RegexAnnotator::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegexAnnotatorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRegexAnnotator(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RegexAnnotator> CreateRegexAnnotator(flatbuffers::FlatBufferBuilder &_fbb, const RegexAnnotatorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RegexAnnotatorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pattern = _o->pattern.empty() ? 0 : _fbb.CreateSharedString(_o->pattern);
  auto _compressed_pattern = _o->compressed_pattern ? CreateCompressedBuffer(_fbb, _o->compressed_pattern.get(), _rehasher) : 0;
  auto _nonterminal = _o->nonterminal;
  return libtextclassifier3::grammar::RulesSet_::CreateRegexAnnotator(
      _fbb,
      _pattern,
      _compressed_pattern,
      _nonterminal);
}

}  // namespace RulesSet_

inline RulesSetT *RulesSet::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<libtextclassifier3::grammar::RulesSetT> _o = std::unique_ptr<libtextclassifier3::grammar::RulesSetT>(new RulesSetT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RulesSet::UnPackTo(RulesSetT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rules(); if (_e) { _o->rules.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rules[_i] = std::unique_ptr<libtextclassifier3::grammar::RulesSet_::RulesT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = lhs_set(); if (_e) { _o->lhs_set.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->lhs_set[_i] = std::unique_ptr<libtextclassifier3::grammar::RulesSet_::LhsSetT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = lhs(); if (_e) { _o->lhs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->lhs[_i] = *_e->Get(_i); } } }
  { auto _e = terminals(); if (_e) _o->terminals = _e->str(); }
  { auto _e = nonterminals(); if (_e) _o->nonterminals = std::unique_ptr<libtextclassifier3::grammar::RulesSet_::NonterminalsT>(_e->UnPack(_resolver)); }
  { auto _e = debug_information(); if (_e) _o->debug_information = std::unique_ptr<libtextclassifier3::grammar::RulesSet_::DebugInformationT>(_e->UnPack(_resolver)); }
  { auto _e = regex_annotator(); if (_e) { _o->regex_annotator.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->regex_annotator[_i] = std::unique_ptr<libtextclassifier3::grammar::RulesSet_::RegexAnnotatorT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = lazy_regex_compilation(); _o->lazy_regex_compilation = _e; }
  { auto _e = semantic_expression(); if (_e) { _o->semantic_expression.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->semantic_expression[_i] = std::unique_ptr<libtextclassifier3::grammar::SemanticExpressionT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = semantic_values_schema(); if (_e) { _o->semantic_values_schema.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->semantic_values_schema[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<RulesSet> RulesSet::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RulesSetT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRulesSet(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RulesSet> CreateRulesSet(flatbuffers::FlatBufferBuilder &_fbb, const RulesSetT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RulesSetT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rules = _o->rules.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::Rules>> (_o->rules.size(), [](size_t i, _VectorArgs *__va) { return CreateRules(*__va->__fbb, __va->__o->rules[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _lhs_set = _o->lhs_set.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::LhsSet>> (_o->lhs_set.size(), [](size_t i, _VectorArgs *__va) { return CreateLhsSet(*__va->__fbb, __va->__o->lhs_set[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _lhs = _o->lhs.size() ? _fbb.CreateVectorOfStructs(_o->lhs) : 0;
  auto _terminals = _o->terminals.empty() ? 0 : _fbb.CreateSharedString(_o->terminals);
  auto _nonterminals = _o->nonterminals ? CreateNonterminals(_fbb, _o->nonterminals.get(), _rehasher) : 0;
  auto _debug_information = _o->debug_information ? CreateDebugInformation(_fbb, _o->debug_information.get(), _rehasher) : 0;
  auto _regex_annotator = _o->regex_annotator.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::grammar::RulesSet_::RegexAnnotator>> (_o->regex_annotator.size(), [](size_t i, _VectorArgs *__va) { return CreateRegexAnnotator(*__va->__fbb, __va->__o->regex_annotator[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _lazy_regex_compilation = _o->lazy_regex_compilation;
  auto _semantic_expression = _o->semantic_expression.size() ? _fbb.CreateVector<flatbuffers::Offset<libtextclassifier3::grammar::SemanticExpression>> (_o->semantic_expression.size(), [](size_t i, _VectorArgs *__va) { return CreateSemanticExpression(*__va->__fbb, __va->__o->semantic_expression[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _semantic_values_schema = _o->semantic_values_schema.size() ? _fbb.CreateVector(_o->semantic_values_schema) : 0;
  return libtextclassifier3::grammar::CreateRulesSet(
      _fbb,
      _rules,
      _lhs_set,
      _lhs,
      _terminals,
      _nonterminals,
      _debug_information,
      _regex_annotator,
      _lazy_regex_compilation,
      _semantic_expression,
      _semantic_values_schema);
}

}  // namespace grammar
}  // namespace libtextclassifier3

#endif  // FLATBUFFERS_GENERATED_RULES_LIBTEXTCLASSIFIER3_GRAMMAR_H_
