/* automatically generated by rust-bindgen 0.58.1 */

pub const SELINUX_AVD_FLAGS_PERMISSIVE: u32 = 1;
pub const SELINUX_CB_LOG: u32 = 0;
pub const SELINUX_CB_AUDIT: u32 = 1;
pub const SELINUX_CB_VALIDATE: u32 = 2;
pub const SELINUX_CB_SETENFORCE: u32 = 3;
pub const SELINUX_CB_POLICYLOAD: u32 = 4;
pub const SELINUX_ERROR: u32 = 0;
pub const SELINUX_WARNING: u32 = 1;
pub const SELINUX_INFO: u32 = 2;
pub const SELINUX_AVC: u32 = 3;
pub const SELINUX_TRANS_DIR: &'static [u8; 17usize] = b"/var/run/setrans\0";
pub const SELABEL_CTX_FILE: u32 = 0;
pub const SELABEL_CTX_MEDIA: u32 = 1;
pub const SELABEL_CTX_X: u32 = 2;
pub const SELABEL_CTX_DB: u32 = 3;
pub const SELABEL_CTX_ANDROID_PROP: u32 = 4;
pub const SELABEL_CTX_ANDROID_SERVICE: u32 = 5;
pub const SELABEL_CTX_ANDROID_KEYSTORE2_KEY: u32 = 6;
pub const SELABEL_OPT_UNUSED: u32 = 0;
pub const SELABEL_OPT_VALIDATE: u32 = 1;
pub const SELABEL_OPT_BASEONLY: u32 = 2;
pub const SELABEL_OPT_PATH: u32 = 3;
pub const SELABEL_OPT_SUBSET: u32 = 4;
pub const SELABEL_OPT_DIGEST: u32 = 5;
pub const SELABEL_NOPT: u32 = 6;
pub const SELABEL_X_PROP: u32 = 1;
pub const SELABEL_X_EXT: u32 = 2;
pub const SELABEL_X_CLIENT: u32 = 3;
pub const SELABEL_X_EVENT: u32 = 4;
pub const SELABEL_X_SELN: u32 = 5;
pub const SELABEL_X_POLYPROP: u32 = 6;
pub const SELABEL_X_POLYSELN: u32 = 7;
pub const SELABEL_DB_DATABASE: u32 = 1;
pub const SELABEL_DB_SCHEMA: u32 = 2;
pub const SELABEL_DB_TABLE: u32 = 3;
pub const SELABEL_DB_COLUMN: u32 = 4;
pub const SELABEL_DB_SEQUENCE: u32 = 5;
pub const SELABEL_DB_VIEW: u32 = 6;
pub const SELABEL_DB_PROCEDURE: u32 = 7;
pub const SELABEL_DB_BLOB: u32 = 8;
pub const SELABEL_DB_TUPLE: u32 = 9;
pub const SELABEL_DB_LANGUAGE: u32 = 10;
pub const SELABEL_DB_EXCEPTION: u32 = 11;
pub const SELABEL_DB_DATATYPE: u32 = 12;
pub const SELINUX_ANDROID_RESTORECON_NOCHANGE: u32 = 1;
pub const SELINUX_ANDROID_RESTORECON_VERBOSE: u32 = 2;
pub const SELINUX_ANDROID_RESTORECON_RECURSE: u32 = 4;
pub const SELINUX_ANDROID_RESTORECON_FORCE: u32 = 8;
pub const SELINUX_ANDROID_RESTORECON_DATADATA: u32 = 16;
pub const SELINUX_ANDROID_RESTORECON_SKIPCE: u32 = 32;
pub const SELINUX_ANDROID_RESTORECON_CROSS_FILESYSTEMS: u32 = 64;
pub const SELINUX_ANDROID_RESTORECON_SKIP_SEHASH: u32 = 128;
pub type size_t = ::std::os::raw::c_ulong;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __uid_t = __kernel_uid32_t;
pub type uid_t = __uid_t;
pub type __pid_t = __kernel_pid_t;
pub type pid_t = __pid_t;
extern "C" {
    pub fn is_selinux_enabled() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn freecon(con: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn getcon(con: *mut *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setcon(con: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpidcon(pid: pid_t, con: *mut *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setexeccon(con: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setfscreatecon(context: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsockcreatecon(context: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsockcreatecon_raw(context: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getfilecon(
        path: *const ::std::os::raw::c_char,
        con: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lgetfilecon(
        path: *const ::std::os::raw::c_char,
        con: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetfilecon(
        fd: ::std::os::raw::c_int,
        con: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetfilecon_raw(
        fd: ::std::os::raw::c_int,
        con: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setfilecon(
        path: *const ::std::os::raw::c_char,
        con: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lsetfilecon(
        path: *const ::std::os::raw::c_char,
        con: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetfilecon(
        fd: ::std::os::raw::c_int,
        con: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeercon(
        fd: ::std::os::raw::c_int,
        con: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub type security_class_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct selinux_opt {
    pub type_: ::std::os::raw::c_int,
    pub value: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_selinux_opt() {
    assert_eq!(
        ::std::mem::size_of::<selinux_opt>(),
        16usize,
        concat!("Size of: ", stringify!(selinux_opt))
    );
    assert_eq!(
        ::std::mem::align_of::<selinux_opt>(),
        8usize,
        concat!("Alignment of ", stringify!(selinux_opt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<selinux_opt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(selinux_opt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<selinux_opt>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(selinux_opt),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union selinux_callback {
    pub func_log: ::std::option::Option<
        unsafe extern "C" fn(
            type_: ::std::os::raw::c_int,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> ::std::os::raw::c_int,
    >,
    pub func_audit: ::std::option::Option<
        unsafe extern "C" fn(
            auditdata: *mut ::std::os::raw::c_void,
            cls: security_class_t,
            msgbuf: *mut ::std::os::raw::c_char,
            msgbufsize: size_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub func_validate: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int,
    >,
    pub func_setenforce: ::std::option::Option<
        unsafe extern "C" fn(enforcing: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >,
    pub func_policyload: ::std::option::Option<
        unsafe extern "C" fn(seqno: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_selinux_callback() {
    assert_eq!(
        ::std::mem::size_of::<selinux_callback>(),
        8usize,
        concat!("Size of: ", stringify!(selinux_callback))
    );
    assert_eq!(
        ::std::mem::align_of::<selinux_callback>(),
        8usize,
        concat!("Alignment of ", stringify!(selinux_callback))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<selinux_callback>())).func_log as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(selinux_callback),
            "::",
            stringify!(func_log)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<selinux_callback>())).func_audit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(selinux_callback),
            "::",
            stringify!(func_audit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<selinux_callback>())).func_validate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(selinux_callback),
            "::",
            stringify!(func_validate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<selinux_callback>())).func_setenforce as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(selinux_callback),
            "::",
            stringify!(func_setenforce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<selinux_callback>())).func_policyload as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(selinux_callback),
            "::",
            stringify!(func_policyload)
        )
    );
}
extern "C" {
    pub fn selinux_set_callback(type_: ::std::os::raw::c_int, cb: selinux_callback);
}
extern "C" {
    pub fn security_compute_create(
        scon: *const ::std::os::raw::c_char,
        tcon: *const ::std::os::raw::c_char,
        tclass: security_class_t,
        newcon: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn security_load_policy(
        data: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn security_get_initial_context(
        name: *const ::std::os::raw::c_char,
        con: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn security_getenforce() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn security_setenforce(value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn security_policyvers() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn string_to_security_class(name: *const ::std::os::raw::c_char) -> security_class_t;
}
extern "C" {
    #[doc = " selinux_check_access - Check permissions and perform appropriate auditing."]
    #[doc = " @scon: source security context"]
    #[doc = " @tcon: target security context"]
    #[doc = " @tclass: target security class string"]
    #[doc = " @perm: requested permissions string, interpreted based on @tclass"]
    #[doc = " @auditdata: auxiliary audit data"]
    #[doc = ""]
    #[doc = " Check the AVC to determine whether the @perm permissions are granted"]
    #[doc = " for the SID pair (@scon, @tcon), interpreting the permissions"]
    #[doc = " based on @tclass."]
    #[doc = " Return %0 if all @perm permissions are granted, -%1 with"]
    #[doc = " @errno set to %EACCES if any permissions are denied or to another"]
    #[doc = " value upon other errors."]
    #[doc = " If auditing or logging is configured the appropriate callbacks will be called"]
    #[doc = " and passed the auditdata field"]
    pub fn selinux_check_access(
        scon: *const ::std::os::raw::c_char,
        tcon: *const ::std::os::raw::c_char,
        tclass: *const ::std::os::raw::c_char,
        perm: *const ::std::os::raw::c_char,
        auditdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_selinuxmnt(mnt: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct selabel_handle {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " selabel_open - Create a labeling handle."]
    #[doc = " @backend: one of the constants specifying a supported labeling backend."]
    #[doc = " @opts: array of selabel_opt structures specifying label options or NULL."]
    #[doc = " @nopts: number of elements in opts array or zero for no options."]
    #[doc = ""]
    #[doc = " Open a labeling backend for use.  The available backend identifiers are"]
    #[doc = " listed above.  Options may be provided via the opts parameter; available"]
    #[doc = " options are listed above.  Not all options may be supported by every"]
    #[doc = " backend.  Return value is the created handle on success or NULL with"]
    #[doc = " @errno set on failure."]
    pub fn selabel_open(
        backend: ::std::os::raw::c_uint,
        opts: *const selinux_opt,
        nopts: ::std::os::raw::c_uint,
    ) -> *mut selabel_handle;
}
extern "C" {
    #[doc = " selabel_close - Close a labeling handle."]
    #[doc = " @handle: specifies handle to close"]
    #[doc = ""]
    #[doc = " Destroy the specified handle, closing files, freeing allocated memory,"]
    #[doc = " etc.  The handle may not be further used after it has been closed."]
    pub fn selabel_close(handle: *mut selabel_handle);
}
extern "C" {
    #[doc = " selabel_lookup - Perform labeling lookup operation."]
    #[doc = " @handle: specifies backend instance to query"]
    #[doc = " @con: returns the appropriate context with which to label the object"]
    #[doc = " @key: string input to lookup operation"]
    #[doc = " @type: numeric input to the lookup operation"]
    #[doc = ""]
    #[doc = " Perform a labeling lookup operation.  Return %0 on success, -%1 with"]
    #[doc = " @errno set on failure.  The key and type arguments are the inputs to the"]
    #[doc = " lookup operation; appropriate values are dictated by the backend in use."]
    #[doc = " The result is returned in the memory pointed to by @con and must be freed"]
    #[doc = " by the user with freecon()."]
    pub fn selabel_lookup(
        handle: *mut selabel_handle,
        con: *mut *mut ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn selabel_lookup_best_match(
        rec: *mut selabel_handle,
        con: *mut *mut ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
        aliases: *mut *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn selinux_android_file_context_handle() -> *mut selabel_handle;
}
extern "C" {
    pub fn selinux_android_service_context_handle() -> *mut selabel_handle;
}
extern "C" {
    pub fn selinux_android_hw_service_context_handle() -> *mut selabel_handle;
}
extern "C" {
    pub fn selinux_android_vendor_service_context_handle() -> *mut selabel_handle;
}
extern "C" {
    pub fn selinux_android_keystore2_key_context_handle() -> *mut selabel_handle;
}
extern "C" {
    pub fn selinux_android_set_sehandle(hndl: *const selabel_handle);
}
extern "C" {
    pub fn selinux_android_load_policy() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn selinux_android_load_policy_from_fd(
        fd: ::std::os::raw::c_int,
        description: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn selinux_android_setcon(con: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn selinux_android_setcontext(
        uid: uid_t,
        isSystemServer: bool,
        seinfo: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn selinux_android_context_with_level(
        context: *const ::std::os::raw::c_char,
        newContext: *mut *mut ::std::os::raw::c_char,
        userid: uid_t,
        appid: uid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn selinux_log_callback(
        type_: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn selinux_vendor_log_callback(
        type_: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn selinux_android_restorecon(
        file: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn selinux_android_restorecon_pkgdir(
        pkgdir: *const ::std::os::raw::c_char,
        seinfo: *const ::std::os::raw::c_char,
        uid: uid_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn selinux_android_seapp_context_init();
}
extern "C" {
    #[doc = " selinux_status_open - Open and map SELinux kernel status page"]
    #[doc = ""]
    pub fn selinux_status_open(fallback: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " selinux_status_updated - Inform us whether the kernel status has been updated"]
    #[doc = ""]
    pub fn selinux_status_updated() -> ::std::os::raw::c_int;
}
