// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: icing/proto/storage.proto

#include "icing/proto/storage.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_icing_2fproto_2fstorage_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_DocumentStorageInfoProto_icing_2fproto_2fstorage_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_icing_2fproto_2fstorage_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IndexStorageInfoProto_icing_2fproto_2fstorage_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_icing_2fproto_2fstorage_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_NamespaceStorageInfoProto_icing_2fproto_2fstorage_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_icing_2fproto_2fstorage_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SchemaStoreStorageInfoProto_icing_2fproto_2fstorage_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_icing_2fproto_2fstatus_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StatusProto_icing_2fproto_2fstatus_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_icing_2fproto_2fstorage_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_StorageInfoProto_icing_2fproto_2fstorage_2eproto;
namespace icing {
namespace lib {
class NamespaceStorageInfoProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<NamespaceStorageInfoProto> _instance;
} _NamespaceStorageInfoProto_default_instance_;
class DocumentStorageInfoProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DocumentStorageInfoProto> _instance;
} _DocumentStorageInfoProto_default_instance_;
class SchemaStoreStorageInfoProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SchemaStoreStorageInfoProto> _instance;
} _SchemaStoreStorageInfoProto_default_instance_;
class IndexStorageInfoProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IndexStorageInfoProto> _instance;
} _IndexStorageInfoProto_default_instance_;
class StorageInfoProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StorageInfoProto> _instance;
} _StorageInfoProto_default_instance_;
class StorageInfoResultProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StorageInfoResultProto> _instance;
} _StorageInfoResultProto_default_instance_;
}  // namespace lib
}  // namespace icing
static void InitDefaultsscc_info_DocumentStorageInfoProto_icing_2fproto_2fstorage_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::icing::lib::_DocumentStorageInfoProto_default_instance_;
    new (ptr) ::icing::lib::DocumentStorageInfoProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::icing::lib::DocumentStorageInfoProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_DocumentStorageInfoProto_icing_2fproto_2fstorage_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_DocumentStorageInfoProto_icing_2fproto_2fstorage_2eproto}, {
      &scc_info_NamespaceStorageInfoProto_icing_2fproto_2fstorage_2eproto.base,}};

static void InitDefaultsscc_info_IndexStorageInfoProto_icing_2fproto_2fstorage_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::icing::lib::_IndexStorageInfoProto_default_instance_;
    new (ptr) ::icing::lib::IndexStorageInfoProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::icing::lib::IndexStorageInfoProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IndexStorageInfoProto_icing_2fproto_2fstorage_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_IndexStorageInfoProto_icing_2fproto_2fstorage_2eproto}, {}};

static void InitDefaultsscc_info_NamespaceStorageInfoProto_icing_2fproto_2fstorage_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::icing::lib::_NamespaceStorageInfoProto_default_instance_;
    new (ptr) ::icing::lib::NamespaceStorageInfoProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::icing::lib::NamespaceStorageInfoProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_NamespaceStorageInfoProto_icing_2fproto_2fstorage_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_NamespaceStorageInfoProto_icing_2fproto_2fstorage_2eproto}, {}};

static void InitDefaultsscc_info_SchemaStoreStorageInfoProto_icing_2fproto_2fstorage_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::icing::lib::_SchemaStoreStorageInfoProto_default_instance_;
    new (ptr) ::icing::lib::SchemaStoreStorageInfoProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::icing::lib::SchemaStoreStorageInfoProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SchemaStoreStorageInfoProto_icing_2fproto_2fstorage_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_SchemaStoreStorageInfoProto_icing_2fproto_2fstorage_2eproto}, {}};

static void InitDefaultsscc_info_StorageInfoProto_icing_2fproto_2fstorage_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::icing::lib::_StorageInfoProto_default_instance_;
    new (ptr) ::icing::lib::StorageInfoProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::icing::lib::StorageInfoProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_StorageInfoProto_icing_2fproto_2fstorage_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, InitDefaultsscc_info_StorageInfoProto_icing_2fproto_2fstorage_2eproto}, {
      &scc_info_DocumentStorageInfoProto_icing_2fproto_2fstorage_2eproto.base,
      &scc_info_SchemaStoreStorageInfoProto_icing_2fproto_2fstorage_2eproto.base,
      &scc_info_IndexStorageInfoProto_icing_2fproto_2fstorage_2eproto.base,}};

static void InitDefaultsscc_info_StorageInfoResultProto_icing_2fproto_2fstorage_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::icing::lib::_StorageInfoResultProto_default_instance_;
    new (ptr) ::icing::lib::StorageInfoResultProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::icing::lib::StorageInfoResultProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_StorageInfoResultProto_icing_2fproto_2fstorage_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_StorageInfoResultProto_icing_2fproto_2fstorage_2eproto}, {
      &scc_info_StatusProto_icing_2fproto_2fstatus_2eproto.base,
      &scc_info_StorageInfoProto_icing_2fproto_2fstorage_2eproto.base,}};

namespace icing {
namespace lib {

// ===================================================================

void NamespaceStorageInfoProto::InitAsDefaultInstance() {
}
class NamespaceStorageInfoProto::_Internal {
 public:
  using HasBits = decltype(std::declval<NamespaceStorageInfoProto>()._has_bits_);
  static void set_has_namespace_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_alive_documents(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_expired_documents(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_num_alive_documents_usage_type1(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_num_alive_documents_usage_type2(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_num_alive_documents_usage_type3(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_num_expired_documents_usage_type1(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_num_expired_documents_usage_type2(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_num_expired_documents_usage_type3(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

NamespaceStorageInfoProto::NamespaceStorageInfoProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:icing.lib.NamespaceStorageInfoProto)
}
NamespaceStorageInfoProto::NamespaceStorageInfoProto(const NamespaceStorageInfoProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  namespace__.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_namespace_()) {
    namespace__.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.namespace__);
  }
  ::memcpy(&num_alive_documents_, &from.num_alive_documents_,
    static_cast<size_t>(reinterpret_cast<char*>(&num_expired_documents_usage_type3_) -
    reinterpret_cast<char*>(&num_alive_documents_)) + sizeof(num_expired_documents_usage_type3_));
  // @@protoc_insertion_point(copy_constructor:icing.lib.NamespaceStorageInfoProto)
}

void NamespaceStorageInfoProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_NamespaceStorageInfoProto_icing_2fproto_2fstorage_2eproto.base);
  namespace__.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&num_alive_documents_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&num_expired_documents_usage_type3_) -
      reinterpret_cast<char*>(&num_alive_documents_)) + sizeof(num_expired_documents_usage_type3_));
}

NamespaceStorageInfoProto::~NamespaceStorageInfoProto() {
  // @@protoc_insertion_point(destructor:icing.lib.NamespaceStorageInfoProto)
  SharedDtor();
}

void NamespaceStorageInfoProto::SharedDtor() {
  namespace__.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void NamespaceStorageInfoProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NamespaceStorageInfoProto& NamespaceStorageInfoProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_NamespaceStorageInfoProto_icing_2fproto_2fstorage_2eproto.base);
  return *internal_default_instance();
}


void NamespaceStorageInfoProto::Clear() {
// @@protoc_insertion_point(message_clear_start:icing.lib.NamespaceStorageInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    namespace__.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&num_alive_documents_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&num_expired_documents_usage_type2_) -
        reinterpret_cast<char*>(&num_alive_documents_)) + sizeof(num_expired_documents_usage_type2_));
  }
  num_expired_documents_usage_type3_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* NamespaceStorageInfoProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string namespace = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_namespace_(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_alive_documents = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_num_alive_documents(&has_bits);
          num_alive_documents_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_expired_documents = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_num_expired_documents(&has_bits);
          num_expired_documents_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_alive_documents_usage_type1 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_num_alive_documents_usage_type1(&has_bits);
          num_alive_documents_usage_type1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_alive_documents_usage_type2 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_num_alive_documents_usage_type2(&has_bits);
          num_alive_documents_usage_type2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_alive_documents_usage_type3 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_num_alive_documents_usage_type3(&has_bits);
          num_alive_documents_usage_type3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_expired_documents_usage_type1 = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_num_expired_documents_usage_type1(&has_bits);
          num_expired_documents_usage_type1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_expired_documents_usage_type2 = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_num_expired_documents_usage_type2(&has_bits);
          num_expired_documents_usage_type2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_expired_documents_usage_type3 = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_num_expired_documents_usage_type3(&has_bits);
          num_expired_documents_usage_type3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool NamespaceStorageInfoProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:icing.lib.NamespaceStorageInfoProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string namespace = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_namespace_()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_alive_documents = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_num_alive_documents(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_alive_documents_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_expired_documents = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_num_expired_documents(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_expired_documents_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_alive_documents_usage_type1 = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_num_alive_documents_usage_type1(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_alive_documents_usage_type1_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_alive_documents_usage_type2 = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_num_alive_documents_usage_type2(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_alive_documents_usage_type2_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_alive_documents_usage_type3 = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_num_alive_documents_usage_type3(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_alive_documents_usage_type3_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_expired_documents_usage_type1 = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_num_expired_documents_usage_type1(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_expired_documents_usage_type1_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_expired_documents_usage_type2 = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          _Internal::set_has_num_expired_documents_usage_type2(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_expired_documents_usage_type2_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_expired_documents_usage_type3 = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          _Internal::set_has_num_expired_documents_usage_type3(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_expired_documents_usage_type3_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:icing.lib.NamespaceStorageInfoProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:icing.lib.NamespaceStorageInfoProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void NamespaceStorageInfoProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:icing.lib.NamespaceStorageInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string namespace = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->namespace_(), output);
  }

  // optional int32 num_alive_documents = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->num_alive_documents(), output);
  }

  // optional int32 num_expired_documents = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->num_expired_documents(), output);
  }

  // optional int32 num_alive_documents_usage_type1 = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->num_alive_documents_usage_type1(), output);
  }

  // optional int32 num_alive_documents_usage_type2 = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->num_alive_documents_usage_type2(), output);
  }

  // optional int32 num_alive_documents_usage_type3 = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(6, this->num_alive_documents_usage_type3(), output);
  }

  // optional int32 num_expired_documents_usage_type1 = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(7, this->num_expired_documents_usage_type1(), output);
  }

  // optional int32 num_expired_documents_usage_type2 = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(8, this->num_expired_documents_usage_type2(), output);
  }

  // optional int32 num_expired_documents_usage_type3 = 9;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(9, this->num_expired_documents_usage_type3(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:icing.lib.NamespaceStorageInfoProto)
}

size_t NamespaceStorageInfoProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:icing.lib.NamespaceStorageInfoProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string namespace = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->namespace_());
    }

    // optional int32 num_alive_documents = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_alive_documents());
    }

    // optional int32 num_expired_documents = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_expired_documents());
    }

    // optional int32 num_alive_documents_usage_type1 = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_alive_documents_usage_type1());
    }

    // optional int32 num_alive_documents_usage_type2 = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_alive_documents_usage_type2());
    }

    // optional int32 num_alive_documents_usage_type3 = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_alive_documents_usage_type3());
    }

    // optional int32 num_expired_documents_usage_type1 = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_expired_documents_usage_type1());
    }

    // optional int32 num_expired_documents_usage_type2 = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_expired_documents_usage_type2());
    }

  }
  // optional int32 num_expired_documents_usage_type3 = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->num_expired_documents_usage_type3());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NamespaceStorageInfoProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const NamespaceStorageInfoProto*>(
      &from));
}

void NamespaceStorageInfoProto::MergeFrom(const NamespaceStorageInfoProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:icing.lib.NamespaceStorageInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      namespace__.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.namespace__);
    }
    if (cached_has_bits & 0x00000002u) {
      num_alive_documents_ = from.num_alive_documents_;
    }
    if (cached_has_bits & 0x00000004u) {
      num_expired_documents_ = from.num_expired_documents_;
    }
    if (cached_has_bits & 0x00000008u) {
      num_alive_documents_usage_type1_ = from.num_alive_documents_usage_type1_;
    }
    if (cached_has_bits & 0x00000010u) {
      num_alive_documents_usage_type2_ = from.num_alive_documents_usage_type2_;
    }
    if (cached_has_bits & 0x00000020u) {
      num_alive_documents_usage_type3_ = from.num_alive_documents_usage_type3_;
    }
    if (cached_has_bits & 0x00000040u) {
      num_expired_documents_usage_type1_ = from.num_expired_documents_usage_type1_;
    }
    if (cached_has_bits & 0x00000080u) {
      num_expired_documents_usage_type2_ = from.num_expired_documents_usage_type2_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    set_num_expired_documents_usage_type3(from.num_expired_documents_usage_type3());
  }
}

void NamespaceStorageInfoProto::CopyFrom(const NamespaceStorageInfoProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:icing.lib.NamespaceStorageInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamespaceStorageInfoProto::IsInitialized() const {
  return true;
}

void NamespaceStorageInfoProto::InternalSwap(NamespaceStorageInfoProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  namespace__.Swap(&other->namespace__, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(num_alive_documents_, other->num_alive_documents_);
  swap(num_expired_documents_, other->num_expired_documents_);
  swap(num_alive_documents_usage_type1_, other->num_alive_documents_usage_type1_);
  swap(num_alive_documents_usage_type2_, other->num_alive_documents_usage_type2_);
  swap(num_alive_documents_usage_type3_, other->num_alive_documents_usage_type3_);
  swap(num_expired_documents_usage_type1_, other->num_expired_documents_usage_type1_);
  swap(num_expired_documents_usage_type2_, other->num_expired_documents_usage_type2_);
  swap(num_expired_documents_usage_type3_, other->num_expired_documents_usage_type3_);
}

std::string NamespaceStorageInfoProto::GetTypeName() const {
  return "icing.lib.NamespaceStorageInfoProto";
}


// ===================================================================

void DocumentStorageInfoProto::InitAsDefaultInstance() {
}
class DocumentStorageInfoProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DocumentStorageInfoProto>()._has_bits_);
  static void set_has_num_alive_documents(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_deleted_documents(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_expired_documents(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_document_store_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_document_log_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_key_mapper_size(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_document_id_mapper_size(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_score_cache_size(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_filter_cache_size(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_corpus_mapper_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_corpus_score_cache_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_namespace_id_mapper_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_num_namespaces(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

DocumentStorageInfoProto::DocumentStorageInfoProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:icing.lib.DocumentStorageInfoProto)
}
DocumentStorageInfoProto::DocumentStorageInfoProto(const DocumentStorageInfoProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      namespace_storage_info_(from.namespace_storage_info_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&num_alive_documents_, &from.num_alive_documents_,
    static_cast<size_t>(reinterpret_cast<char*>(&namespace_id_mapper_size_) -
    reinterpret_cast<char*>(&num_alive_documents_)) + sizeof(namespace_id_mapper_size_));
  // @@protoc_insertion_point(copy_constructor:icing.lib.DocumentStorageInfoProto)
}

void DocumentStorageInfoProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_DocumentStorageInfoProto_icing_2fproto_2fstorage_2eproto.base);
  ::memset(&num_alive_documents_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&namespace_id_mapper_size_) -
      reinterpret_cast<char*>(&num_alive_documents_)) + sizeof(namespace_id_mapper_size_));
}

DocumentStorageInfoProto::~DocumentStorageInfoProto() {
  // @@protoc_insertion_point(destructor:icing.lib.DocumentStorageInfoProto)
  SharedDtor();
}

void DocumentStorageInfoProto::SharedDtor() {
}

void DocumentStorageInfoProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DocumentStorageInfoProto& DocumentStorageInfoProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_DocumentStorageInfoProto_icing_2fproto_2fstorage_2eproto.base);
  return *internal_default_instance();
}


void DocumentStorageInfoProto::Clear() {
// @@protoc_insertion_point(message_clear_start:icing.lib.DocumentStorageInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  namespace_storage_info_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&num_alive_documents_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&num_expired_documents_) -
        reinterpret_cast<char*>(&num_alive_documents_)) + sizeof(num_expired_documents_));
  }
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&num_namespaces_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&namespace_id_mapper_size_) -
        reinterpret_cast<char*>(&num_namespaces_)) + sizeof(namespace_id_mapper_size_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* DocumentStorageInfoProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 num_alive_documents = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_num_alive_documents(&has_bits);
          num_alive_documents_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_deleted_documents = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_num_deleted_documents(&has_bits);
          num_deleted_documents_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_expired_documents = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_num_expired_documents(&has_bits);
          num_expired_documents_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 document_store_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_document_store_size(&has_bits);
          document_store_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 document_log_size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_document_log_size(&has_bits);
          document_log_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 key_mapper_size = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_key_mapper_size(&has_bits);
          key_mapper_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 document_id_mapper_size = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_document_id_mapper_size(&has_bits);
          document_id_mapper_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 score_cache_size = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_score_cache_size(&has_bits);
          score_cache_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 filter_cache_size = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_filter_cache_size(&has_bits);
          filter_cache_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 corpus_mapper_size = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_corpus_mapper_size(&has_bits);
          corpus_mapper_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 corpus_score_cache_size = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_corpus_score_cache_size(&has_bits);
          corpus_score_cache_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 namespace_id_mapper_size = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_namespace_id_mapper_size(&has_bits);
          namespace_id_mapper_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_namespaces = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_num_namespaces(&has_bits);
          num_namespaces_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .icing.lib.NamespaceStorageInfoProto namespace_storage_info = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_namespace_storage_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 114);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool DocumentStorageInfoProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:icing.lib.DocumentStorageInfoProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 num_alive_documents = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_num_alive_documents(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_alive_documents_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_deleted_documents = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_num_deleted_documents(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_deleted_documents_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_expired_documents = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_num_expired_documents(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_expired_documents_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 document_store_size = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_document_store_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &document_store_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 document_log_size = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_document_log_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &document_log_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 key_mapper_size = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_key_mapper_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &key_mapper_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 document_id_mapper_size = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_document_id_mapper_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &document_id_mapper_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 score_cache_size = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          _Internal::set_has_score_cache_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &score_cache_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 filter_cache_size = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          _Internal::set_has_filter_cache_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &filter_cache_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 corpus_mapper_size = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (80 & 0xFF)) {
          _Internal::set_has_corpus_mapper_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &corpus_mapper_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 corpus_score_cache_size = 11;
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (88 & 0xFF)) {
          _Internal::set_has_corpus_score_cache_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &corpus_score_cache_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 namespace_id_mapper_size = 12;
      case 12: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (96 & 0xFF)) {
          _Internal::set_has_namespace_id_mapper_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &namespace_id_mapper_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_namespaces = 13;
      case 13: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (104 & 0xFF)) {
          _Internal::set_has_num_namespaces(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_namespaces_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .icing.lib.NamespaceStorageInfoProto namespace_storage_info = 14;
      case 14: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (114 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_namespace_storage_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:icing.lib.DocumentStorageInfoProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:icing.lib.DocumentStorageInfoProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void DocumentStorageInfoProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:icing.lib.DocumentStorageInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 num_alive_documents = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->num_alive_documents(), output);
  }

  // optional int32 num_deleted_documents = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->num_deleted_documents(), output);
  }

  // optional int32 num_expired_documents = 3;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->num_expired_documents(), output);
  }

  // optional int64 document_store_size = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(4, this->document_store_size(), output);
  }

  // optional int64 document_log_size = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(5, this->document_log_size(), output);
  }

  // optional int64 key_mapper_size = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(6, this->key_mapper_size(), output);
  }

  // optional int64 document_id_mapper_size = 7;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(7, this->document_id_mapper_size(), output);
  }

  // optional int64 score_cache_size = 8;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(8, this->score_cache_size(), output);
  }

  // optional int64 filter_cache_size = 9;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(9, this->filter_cache_size(), output);
  }

  // optional int64 corpus_mapper_size = 10;
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(10, this->corpus_mapper_size(), output);
  }

  // optional int64 corpus_score_cache_size = 11;
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(11, this->corpus_score_cache_size(), output);
  }

  // optional int64 namespace_id_mapper_size = 12;
  if (cached_has_bits & 0x00001000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(12, this->namespace_id_mapper_size(), output);
  }

  // optional int32 num_namespaces = 13;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(13, this->num_namespaces(), output);
  }

  // repeated .icing.lib.NamespaceStorageInfoProto namespace_storage_info = 14;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->namespace_storage_info_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      14,
      this->namespace_storage_info(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:icing.lib.DocumentStorageInfoProto)
}

size_t DocumentStorageInfoProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:icing.lib.DocumentStorageInfoProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .icing.lib.NamespaceStorageInfoProto namespace_storage_info = 14;
  {
    unsigned int count = static_cast<unsigned int>(this->namespace_storage_info_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->namespace_storage_info(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional int32 num_alive_documents = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_alive_documents());
    }

    // optional int32 num_deleted_documents = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_deleted_documents());
    }

    // optional int64 document_store_size = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->document_store_size());
    }

    // optional int64 document_log_size = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->document_log_size());
    }

    // optional int64 key_mapper_size = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->key_mapper_size());
    }

    // optional int64 document_id_mapper_size = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->document_id_mapper_size());
    }

    // optional int64 score_cache_size = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->score_cache_size());
    }

    // optional int32 num_expired_documents = 3;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_expired_documents());
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional int32 num_namespaces = 13;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_namespaces());
    }

    // optional int64 filter_cache_size = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->filter_cache_size());
    }

    // optional int64 corpus_mapper_size = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->corpus_mapper_size());
    }

    // optional int64 corpus_score_cache_size = 11;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->corpus_score_cache_size());
    }

    // optional int64 namespace_id_mapper_size = 12;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->namespace_id_mapper_size());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DocumentStorageInfoProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DocumentStorageInfoProto*>(
      &from));
}

void DocumentStorageInfoProto::MergeFrom(const DocumentStorageInfoProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:icing.lib.DocumentStorageInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  namespace_storage_info_.MergeFrom(from.namespace_storage_info_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      num_alive_documents_ = from.num_alive_documents_;
    }
    if (cached_has_bits & 0x00000002u) {
      num_deleted_documents_ = from.num_deleted_documents_;
    }
    if (cached_has_bits & 0x00000004u) {
      document_store_size_ = from.document_store_size_;
    }
    if (cached_has_bits & 0x00000008u) {
      document_log_size_ = from.document_log_size_;
    }
    if (cached_has_bits & 0x00000010u) {
      key_mapper_size_ = from.key_mapper_size_;
    }
    if (cached_has_bits & 0x00000020u) {
      document_id_mapper_size_ = from.document_id_mapper_size_;
    }
    if (cached_has_bits & 0x00000040u) {
      score_cache_size_ = from.score_cache_size_;
    }
    if (cached_has_bits & 0x00000080u) {
      num_expired_documents_ = from.num_expired_documents_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      num_namespaces_ = from.num_namespaces_;
    }
    if (cached_has_bits & 0x00000200u) {
      filter_cache_size_ = from.filter_cache_size_;
    }
    if (cached_has_bits & 0x00000400u) {
      corpus_mapper_size_ = from.corpus_mapper_size_;
    }
    if (cached_has_bits & 0x00000800u) {
      corpus_score_cache_size_ = from.corpus_score_cache_size_;
    }
    if (cached_has_bits & 0x00001000u) {
      namespace_id_mapper_size_ = from.namespace_id_mapper_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DocumentStorageInfoProto::CopyFrom(const DocumentStorageInfoProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:icing.lib.DocumentStorageInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DocumentStorageInfoProto::IsInitialized() const {
  return true;
}

void DocumentStorageInfoProto::InternalSwap(DocumentStorageInfoProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&namespace_storage_info_)->InternalSwap(CastToBase(&other->namespace_storage_info_));
  swap(num_alive_documents_, other->num_alive_documents_);
  swap(num_deleted_documents_, other->num_deleted_documents_);
  swap(document_store_size_, other->document_store_size_);
  swap(document_log_size_, other->document_log_size_);
  swap(key_mapper_size_, other->key_mapper_size_);
  swap(document_id_mapper_size_, other->document_id_mapper_size_);
  swap(score_cache_size_, other->score_cache_size_);
  swap(num_expired_documents_, other->num_expired_documents_);
  swap(num_namespaces_, other->num_namespaces_);
  swap(filter_cache_size_, other->filter_cache_size_);
  swap(corpus_mapper_size_, other->corpus_mapper_size_);
  swap(corpus_score_cache_size_, other->corpus_score_cache_size_);
  swap(namespace_id_mapper_size_, other->namespace_id_mapper_size_);
}

std::string DocumentStorageInfoProto::GetTypeName() const {
  return "icing.lib.DocumentStorageInfoProto";
}


// ===================================================================

void SchemaStoreStorageInfoProto::InitAsDefaultInstance() {
}
class SchemaStoreStorageInfoProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SchemaStoreStorageInfoProto>()._has_bits_);
  static void set_has_schema_store_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_schema_types(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_total_sections(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_num_schema_types_sections_exhausted(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

SchemaStoreStorageInfoProto::SchemaStoreStorageInfoProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:icing.lib.SchemaStoreStorageInfoProto)
}
SchemaStoreStorageInfoProto::SchemaStoreStorageInfoProto(const SchemaStoreStorageInfoProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&schema_store_size_, &from.schema_store_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&num_schema_types_sections_exhausted_) -
    reinterpret_cast<char*>(&schema_store_size_)) + sizeof(num_schema_types_sections_exhausted_));
  // @@protoc_insertion_point(copy_constructor:icing.lib.SchemaStoreStorageInfoProto)
}

void SchemaStoreStorageInfoProto::SharedCtor() {
  ::memset(&schema_store_size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&num_schema_types_sections_exhausted_) -
      reinterpret_cast<char*>(&schema_store_size_)) + sizeof(num_schema_types_sections_exhausted_));
}

SchemaStoreStorageInfoProto::~SchemaStoreStorageInfoProto() {
  // @@protoc_insertion_point(destructor:icing.lib.SchemaStoreStorageInfoProto)
  SharedDtor();
}

void SchemaStoreStorageInfoProto::SharedDtor() {
}

void SchemaStoreStorageInfoProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SchemaStoreStorageInfoProto& SchemaStoreStorageInfoProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SchemaStoreStorageInfoProto_icing_2fproto_2fstorage_2eproto.base);
  return *internal_default_instance();
}


void SchemaStoreStorageInfoProto::Clear() {
// @@protoc_insertion_point(message_clear_start:icing.lib.SchemaStoreStorageInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&schema_store_size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&num_schema_types_sections_exhausted_) -
        reinterpret_cast<char*>(&schema_store_size_)) + sizeof(num_schema_types_sections_exhausted_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SchemaStoreStorageInfoProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int64 schema_store_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_schema_store_size(&has_bits);
          schema_store_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_schema_types = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_num_schema_types(&has_bits);
          num_schema_types_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_total_sections = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_num_total_sections(&has_bits);
          num_total_sections_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_schema_types_sections_exhausted = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_num_schema_types_sections_exhausted(&has_bits);
          num_schema_types_sections_exhausted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SchemaStoreStorageInfoProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:icing.lib.SchemaStoreStorageInfoProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 schema_store_size = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_schema_store_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &schema_store_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_schema_types = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_num_schema_types(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_schema_types_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_total_sections = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_num_total_sections(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_total_sections_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_schema_types_sections_exhausted = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_num_schema_types_sections_exhausted(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_schema_types_sections_exhausted_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:icing.lib.SchemaStoreStorageInfoProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:icing.lib.SchemaStoreStorageInfoProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SchemaStoreStorageInfoProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:icing.lib.SchemaStoreStorageInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 schema_store_size = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(1, this->schema_store_size(), output);
  }

  // optional int32 num_schema_types = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->num_schema_types(), output);
  }

  // optional int32 num_total_sections = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->num_total_sections(), output);
  }

  // optional int32 num_schema_types_sections_exhausted = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->num_schema_types_sections_exhausted(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:icing.lib.SchemaStoreStorageInfoProto)
}

size_t SchemaStoreStorageInfoProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:icing.lib.SchemaStoreStorageInfoProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int64 schema_store_size = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->schema_store_size());
    }

    // optional int32 num_schema_types = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_schema_types());
    }

    // optional int32 num_total_sections = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_total_sections());
    }

    // optional int32 num_schema_types_sections_exhausted = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_schema_types_sections_exhausted());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchemaStoreStorageInfoProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SchemaStoreStorageInfoProto*>(
      &from));
}

void SchemaStoreStorageInfoProto::MergeFrom(const SchemaStoreStorageInfoProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:icing.lib.SchemaStoreStorageInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      schema_store_size_ = from.schema_store_size_;
    }
    if (cached_has_bits & 0x00000002u) {
      num_schema_types_ = from.num_schema_types_;
    }
    if (cached_has_bits & 0x00000004u) {
      num_total_sections_ = from.num_total_sections_;
    }
    if (cached_has_bits & 0x00000008u) {
      num_schema_types_sections_exhausted_ = from.num_schema_types_sections_exhausted_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SchemaStoreStorageInfoProto::CopyFrom(const SchemaStoreStorageInfoProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:icing.lib.SchemaStoreStorageInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchemaStoreStorageInfoProto::IsInitialized() const {
  return true;
}

void SchemaStoreStorageInfoProto::InternalSwap(SchemaStoreStorageInfoProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(schema_store_size_, other->schema_store_size_);
  swap(num_schema_types_, other->num_schema_types_);
  swap(num_total_sections_, other->num_total_sections_);
  swap(num_schema_types_sections_exhausted_, other->num_schema_types_sections_exhausted_);
}

std::string SchemaStoreStorageInfoProto::GetTypeName() const {
  return "icing.lib.SchemaStoreStorageInfoProto";
}


// ===================================================================

void IndexStorageInfoProto::InitAsDefaultInstance() {
}
class IndexStorageInfoProto::_Internal {
 public:
  using HasBits = decltype(std::declval<IndexStorageInfoProto>()._has_bits_);
  static void set_has_index_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lite_index_lexicon_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lite_index_hit_buffer_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_main_index_lexicon_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_main_index_storage_size(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_main_index_block_size(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_num_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_min_free_fraction(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

IndexStorageInfoProto::IndexStorageInfoProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:icing.lib.IndexStorageInfoProto)
}
IndexStorageInfoProto::IndexStorageInfoProto(const IndexStorageInfoProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&index_size_, &from.index_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&min_free_fraction_) -
    reinterpret_cast<char*>(&index_size_)) + sizeof(min_free_fraction_));
  // @@protoc_insertion_point(copy_constructor:icing.lib.IndexStorageInfoProto)
}

void IndexStorageInfoProto::SharedCtor() {
  ::memset(&index_size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&min_free_fraction_) -
      reinterpret_cast<char*>(&index_size_)) + sizeof(min_free_fraction_));
}

IndexStorageInfoProto::~IndexStorageInfoProto() {
  // @@protoc_insertion_point(destructor:icing.lib.IndexStorageInfoProto)
  SharedDtor();
}

void IndexStorageInfoProto::SharedDtor() {
}

void IndexStorageInfoProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IndexStorageInfoProto& IndexStorageInfoProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IndexStorageInfoProto_icing_2fproto_2fstorage_2eproto.base);
  return *internal_default_instance();
}


void IndexStorageInfoProto::Clear() {
// @@protoc_insertion_point(message_clear_start:icing.lib.IndexStorageInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&index_size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&min_free_fraction_) -
        reinterpret_cast<char*>(&index_size_)) + sizeof(min_free_fraction_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IndexStorageInfoProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int64 index_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_index_size(&has_bits);
          index_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 lite_index_lexicon_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_lite_index_lexicon_size(&has_bits);
          lite_index_lexicon_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 lite_index_hit_buffer_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_lite_index_hit_buffer_size(&has_bits);
          lite_index_hit_buffer_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 main_index_lexicon_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_main_index_lexicon_size(&has_bits);
          main_index_lexicon_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 main_index_storage_size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_main_index_storage_size(&has_bits);
          main_index_storage_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 main_index_block_size = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_main_index_block_size(&has_bits);
          main_index_block_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_blocks = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_num_blocks(&has_bits);
          num_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float min_free_fraction = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          _Internal::set_has_min_free_fraction(&has_bits);
          min_free_fraction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IndexStorageInfoProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:icing.lib.IndexStorageInfoProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 index_size = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_index_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &index_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 lite_index_lexicon_size = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_lite_index_lexicon_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &lite_index_lexicon_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 lite_index_hit_buffer_size = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_lite_index_hit_buffer_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &lite_index_hit_buffer_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 main_index_lexicon_size = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_main_index_lexicon_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &main_index_lexicon_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 main_index_storage_size = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_main_index_storage_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &main_index_storage_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 main_index_block_size = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_main_index_block_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &main_index_block_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_blocks = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_num_blocks(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_blocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float min_free_fraction = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (69 & 0xFF)) {
          _Internal::set_has_min_free_fraction(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &min_free_fraction_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:icing.lib.IndexStorageInfoProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:icing.lib.IndexStorageInfoProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IndexStorageInfoProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:icing.lib.IndexStorageInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 index_size = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(1, this->index_size(), output);
  }

  // optional int64 lite_index_lexicon_size = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(2, this->lite_index_lexicon_size(), output);
  }

  // optional int64 lite_index_hit_buffer_size = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(3, this->lite_index_hit_buffer_size(), output);
  }

  // optional int64 main_index_lexicon_size = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(4, this->main_index_lexicon_size(), output);
  }

  // optional int64 main_index_storage_size = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(5, this->main_index_storage_size(), output);
  }

  // optional int64 main_index_block_size = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(6, this->main_index_block_size(), output);
  }

  // optional int32 num_blocks = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(7, this->num_blocks(), output);
  }

  // optional float min_free_fraction = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(8, this->min_free_fraction(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:icing.lib.IndexStorageInfoProto)
}

size_t IndexStorageInfoProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:icing.lib.IndexStorageInfoProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional int64 index_size = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->index_size());
    }

    // optional int64 lite_index_lexicon_size = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->lite_index_lexicon_size());
    }

    // optional int64 lite_index_hit_buffer_size = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->lite_index_hit_buffer_size());
    }

    // optional int64 main_index_lexicon_size = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->main_index_lexicon_size());
    }

    // optional int64 main_index_storage_size = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->main_index_storage_size());
    }

    // optional int64 main_index_block_size = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->main_index_block_size());
    }

    // optional int32 num_blocks = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_blocks());
    }

    // optional float min_free_fraction = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IndexStorageInfoProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IndexStorageInfoProto*>(
      &from));
}

void IndexStorageInfoProto::MergeFrom(const IndexStorageInfoProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:icing.lib.IndexStorageInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      index_size_ = from.index_size_;
    }
    if (cached_has_bits & 0x00000002u) {
      lite_index_lexicon_size_ = from.lite_index_lexicon_size_;
    }
    if (cached_has_bits & 0x00000004u) {
      lite_index_hit_buffer_size_ = from.lite_index_hit_buffer_size_;
    }
    if (cached_has_bits & 0x00000008u) {
      main_index_lexicon_size_ = from.main_index_lexicon_size_;
    }
    if (cached_has_bits & 0x00000010u) {
      main_index_storage_size_ = from.main_index_storage_size_;
    }
    if (cached_has_bits & 0x00000020u) {
      main_index_block_size_ = from.main_index_block_size_;
    }
    if (cached_has_bits & 0x00000040u) {
      num_blocks_ = from.num_blocks_;
    }
    if (cached_has_bits & 0x00000080u) {
      min_free_fraction_ = from.min_free_fraction_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IndexStorageInfoProto::CopyFrom(const IndexStorageInfoProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:icing.lib.IndexStorageInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IndexStorageInfoProto::IsInitialized() const {
  return true;
}

void IndexStorageInfoProto::InternalSwap(IndexStorageInfoProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(index_size_, other->index_size_);
  swap(lite_index_lexicon_size_, other->lite_index_lexicon_size_);
  swap(lite_index_hit_buffer_size_, other->lite_index_hit_buffer_size_);
  swap(main_index_lexicon_size_, other->main_index_lexicon_size_);
  swap(main_index_storage_size_, other->main_index_storage_size_);
  swap(main_index_block_size_, other->main_index_block_size_);
  swap(num_blocks_, other->num_blocks_);
  swap(min_free_fraction_, other->min_free_fraction_);
}

std::string IndexStorageInfoProto::GetTypeName() const {
  return "icing.lib.IndexStorageInfoProto";
}


// ===================================================================

void StorageInfoProto::InitAsDefaultInstance() {
  ::icing::lib::_StorageInfoProto_default_instance_._instance.get_mutable()->document_storage_info_ = const_cast< ::icing::lib::DocumentStorageInfoProto*>(
      ::icing::lib::DocumentStorageInfoProto::internal_default_instance());
  ::icing::lib::_StorageInfoProto_default_instance_._instance.get_mutable()->schema_store_storage_info_ = const_cast< ::icing::lib::SchemaStoreStorageInfoProto*>(
      ::icing::lib::SchemaStoreStorageInfoProto::internal_default_instance());
  ::icing::lib::_StorageInfoProto_default_instance_._instance.get_mutable()->index_storage_info_ = const_cast< ::icing::lib::IndexStorageInfoProto*>(
      ::icing::lib::IndexStorageInfoProto::internal_default_instance());
}
class StorageInfoProto::_Internal {
 public:
  using HasBits = decltype(std::declval<StorageInfoProto>()._has_bits_);
  static void set_has_total_storage_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::icing::lib::DocumentStorageInfoProto& document_storage_info(const StorageInfoProto* msg);
  static void set_has_document_storage_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::icing::lib::SchemaStoreStorageInfoProto& schema_store_storage_info(const StorageInfoProto* msg);
  static void set_has_schema_store_storage_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::icing::lib::IndexStorageInfoProto& index_storage_info(const StorageInfoProto* msg);
  static void set_has_index_storage_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::icing::lib::DocumentStorageInfoProto&
StorageInfoProto::_Internal::document_storage_info(const StorageInfoProto* msg) {
  return *msg->document_storage_info_;
}
const ::icing::lib::SchemaStoreStorageInfoProto&
StorageInfoProto::_Internal::schema_store_storage_info(const StorageInfoProto* msg) {
  return *msg->schema_store_storage_info_;
}
const ::icing::lib::IndexStorageInfoProto&
StorageInfoProto::_Internal::index_storage_info(const StorageInfoProto* msg) {
  return *msg->index_storage_info_;
}
StorageInfoProto::StorageInfoProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:icing.lib.StorageInfoProto)
}
StorageInfoProto::StorageInfoProto(const StorageInfoProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_document_storage_info()) {
    document_storage_info_ = new ::icing::lib::DocumentStorageInfoProto(*from.document_storage_info_);
  } else {
    document_storage_info_ = nullptr;
  }
  if (from.has_schema_store_storage_info()) {
    schema_store_storage_info_ = new ::icing::lib::SchemaStoreStorageInfoProto(*from.schema_store_storage_info_);
  } else {
    schema_store_storage_info_ = nullptr;
  }
  if (from.has_index_storage_info()) {
    index_storage_info_ = new ::icing::lib::IndexStorageInfoProto(*from.index_storage_info_);
  } else {
    index_storage_info_ = nullptr;
  }
  total_storage_size_ = from.total_storage_size_;
  // @@protoc_insertion_point(copy_constructor:icing.lib.StorageInfoProto)
}

void StorageInfoProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_StorageInfoProto_icing_2fproto_2fstorage_2eproto.base);
  ::memset(&document_storage_info_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&total_storage_size_) -
      reinterpret_cast<char*>(&document_storage_info_)) + sizeof(total_storage_size_));
}

StorageInfoProto::~StorageInfoProto() {
  // @@protoc_insertion_point(destructor:icing.lib.StorageInfoProto)
  SharedDtor();
}

void StorageInfoProto::SharedDtor() {
  if (this != internal_default_instance()) delete document_storage_info_;
  if (this != internal_default_instance()) delete schema_store_storage_info_;
  if (this != internal_default_instance()) delete index_storage_info_;
}

void StorageInfoProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StorageInfoProto& StorageInfoProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StorageInfoProto_icing_2fproto_2fstorage_2eproto.base);
  return *internal_default_instance();
}


void StorageInfoProto::Clear() {
// @@protoc_insertion_point(message_clear_start:icing.lib.StorageInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(document_storage_info_ != nullptr);
      document_storage_info_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(schema_store_storage_info_ != nullptr);
      schema_store_storage_info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(index_storage_info_ != nullptr);
      index_storage_info_->Clear();
    }
  }
  total_storage_size_ = PROTOBUF_LONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* StorageInfoProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int64 total_storage_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_total_storage_size(&has_bits);
          total_storage_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .icing.lib.DocumentStorageInfoProto document_storage_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_document_storage_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .icing.lib.SchemaStoreStorageInfoProto schema_store_storage_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_schema_store_storage_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .icing.lib.IndexStorageInfoProto index_storage_info = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(mutable_index_storage_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool StorageInfoProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:icing.lib.StorageInfoProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 total_storage_size = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_total_storage_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &total_storage_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .icing.lib.DocumentStorageInfoProto document_storage_info = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_document_storage_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .icing.lib.SchemaStoreStorageInfoProto schema_store_storage_info = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_schema_store_storage_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .icing.lib.IndexStorageInfoProto index_storage_info = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_index_storage_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:icing.lib.StorageInfoProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:icing.lib.StorageInfoProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void StorageInfoProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:icing.lib.StorageInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 total_storage_size = 1;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(1, this->total_storage_size(), output);
  }

  // optional .icing.lib.DocumentStorageInfoProto document_storage_info = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2, _Internal::document_storage_info(this), output);
  }

  // optional .icing.lib.SchemaStoreStorageInfoProto schema_store_storage_info = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      3, _Internal::schema_store_storage_info(this), output);
  }

  // optional .icing.lib.IndexStorageInfoProto index_storage_info = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      4, _Internal::index_storage_info(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:icing.lib.StorageInfoProto)
}

size_t StorageInfoProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:icing.lib.StorageInfoProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .icing.lib.DocumentStorageInfoProto document_storage_info = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *document_storage_info_);
    }

    // optional .icing.lib.SchemaStoreStorageInfoProto schema_store_storage_info = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *schema_store_storage_info_);
    }

    // optional .icing.lib.IndexStorageInfoProto index_storage_info = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *index_storage_info_);
    }

    // optional int64 total_storage_size = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->total_storage_size());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StorageInfoProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const StorageInfoProto*>(
      &from));
}

void StorageInfoProto::MergeFrom(const StorageInfoProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:icing.lib.StorageInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_document_storage_info()->::icing::lib::DocumentStorageInfoProto::MergeFrom(from.document_storage_info());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_schema_store_storage_info()->::icing::lib::SchemaStoreStorageInfoProto::MergeFrom(from.schema_store_storage_info());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_index_storage_info()->::icing::lib::IndexStorageInfoProto::MergeFrom(from.index_storage_info());
    }
    if (cached_has_bits & 0x00000008u) {
      total_storage_size_ = from.total_storage_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void StorageInfoProto::CopyFrom(const StorageInfoProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:icing.lib.StorageInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StorageInfoProto::IsInitialized() const {
  return true;
}

void StorageInfoProto::InternalSwap(StorageInfoProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(document_storage_info_, other->document_storage_info_);
  swap(schema_store_storage_info_, other->schema_store_storage_info_);
  swap(index_storage_info_, other->index_storage_info_);
  swap(total_storage_size_, other->total_storage_size_);
}

std::string StorageInfoProto::GetTypeName() const {
  return "icing.lib.StorageInfoProto";
}


// ===================================================================

void StorageInfoResultProto::InitAsDefaultInstance() {
  ::icing::lib::_StorageInfoResultProto_default_instance_._instance.get_mutable()->status_ = const_cast< ::icing::lib::StatusProto*>(
      ::icing::lib::StatusProto::internal_default_instance());
  ::icing::lib::_StorageInfoResultProto_default_instance_._instance.get_mutable()->storage_info_ = const_cast< ::icing::lib::StorageInfoProto*>(
      ::icing::lib::StorageInfoProto::internal_default_instance());
}
class StorageInfoResultProto::_Internal {
 public:
  using HasBits = decltype(std::declval<StorageInfoResultProto>()._has_bits_);
  static const ::icing::lib::StatusProto& status(const StorageInfoResultProto* msg);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::icing::lib::StorageInfoProto& storage_info(const StorageInfoResultProto* msg);
  static void set_has_storage_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::icing::lib::StatusProto&
StorageInfoResultProto::_Internal::status(const StorageInfoResultProto* msg) {
  return *msg->status_;
}
const ::icing::lib::StorageInfoProto&
StorageInfoResultProto::_Internal::storage_info(const StorageInfoResultProto* msg) {
  return *msg->storage_info_;
}
void StorageInfoResultProto::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
StorageInfoResultProto::StorageInfoResultProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:icing.lib.StorageInfoResultProto)
}
StorageInfoResultProto::StorageInfoResultProto(const StorageInfoResultProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_status()) {
    status_ = new ::icing::lib::StatusProto(*from.status_);
  } else {
    status_ = nullptr;
  }
  if (from.has_storage_info()) {
    storage_info_ = new ::icing::lib::StorageInfoProto(*from.storage_info_);
  } else {
    storage_info_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:icing.lib.StorageInfoResultProto)
}

void StorageInfoResultProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_StorageInfoResultProto_icing_2fproto_2fstorage_2eproto.base);
  ::memset(&status_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&storage_info_) -
      reinterpret_cast<char*>(&status_)) + sizeof(storage_info_));
}

StorageInfoResultProto::~StorageInfoResultProto() {
  // @@protoc_insertion_point(destructor:icing.lib.StorageInfoResultProto)
  SharedDtor();
}

void StorageInfoResultProto::SharedDtor() {
  if (this != internal_default_instance()) delete status_;
  if (this != internal_default_instance()) delete storage_info_;
}

void StorageInfoResultProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StorageInfoResultProto& StorageInfoResultProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StorageInfoResultProto_icing_2fproto_2fstorage_2eproto.base);
  return *internal_default_instance();
}


void StorageInfoResultProto::Clear() {
// @@protoc_insertion_point(message_clear_start:icing.lib.StorageInfoResultProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(status_ != nullptr);
      status_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(storage_info_ != nullptr);
      storage_info_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* StorageInfoResultProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .icing.lib.StatusProto status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_status(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .icing.lib.StorageInfoProto storage_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_storage_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool StorageInfoResultProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:icing.lib.StorageInfoResultProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .icing.lib.StatusProto status = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_status()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .icing.lib.StorageInfoProto storage_info = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_storage_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:icing.lib.StorageInfoResultProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:icing.lib.StorageInfoResultProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void StorageInfoResultProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:icing.lib.StorageInfoResultProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .icing.lib.StatusProto status = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1, _Internal::status(this), output);
  }

  // optional .icing.lib.StorageInfoProto storage_info = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2, _Internal::storage_info(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:icing.lib.StorageInfoResultProto)
}

size_t StorageInfoResultProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:icing.lib.StorageInfoResultProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .icing.lib.StatusProto status = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *status_);
    }

    // optional .icing.lib.StorageInfoProto storage_info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *storage_info_);
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StorageInfoResultProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const StorageInfoResultProto*>(
      &from));
}

void StorageInfoResultProto::MergeFrom(const StorageInfoResultProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:icing.lib.StorageInfoResultProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_status()->::icing::lib::StatusProto::MergeFrom(from.status());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_storage_info()->::icing::lib::StorageInfoProto::MergeFrom(from.storage_info());
    }
  }
}

void StorageInfoResultProto::CopyFrom(const StorageInfoResultProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:icing.lib.StorageInfoResultProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StorageInfoResultProto::IsInitialized() const {
  return true;
}

void StorageInfoResultProto::InternalSwap(StorageInfoResultProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(status_, other->status_);
  swap(storage_info_, other->storage_info_);
}

std::string StorageInfoResultProto::GetTypeName() const {
  return "icing.lib.StorageInfoResultProto";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace lib
}  // namespace icing
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::icing::lib::NamespaceStorageInfoProto* Arena::CreateMaybeMessage< ::icing::lib::NamespaceStorageInfoProto >(Arena* arena) {
  return Arena::CreateInternal< ::icing::lib::NamespaceStorageInfoProto >(arena);
}
template<> PROTOBUF_NOINLINE ::icing::lib::DocumentStorageInfoProto* Arena::CreateMaybeMessage< ::icing::lib::DocumentStorageInfoProto >(Arena* arena) {
  return Arena::CreateInternal< ::icing::lib::DocumentStorageInfoProto >(arena);
}
template<> PROTOBUF_NOINLINE ::icing::lib::SchemaStoreStorageInfoProto* Arena::CreateMaybeMessage< ::icing::lib::SchemaStoreStorageInfoProto >(Arena* arena) {
  return Arena::CreateInternal< ::icing::lib::SchemaStoreStorageInfoProto >(arena);
}
template<> PROTOBUF_NOINLINE ::icing::lib::IndexStorageInfoProto* Arena::CreateMaybeMessage< ::icing::lib::IndexStorageInfoProto >(Arena* arena) {
  return Arena::CreateInternal< ::icing::lib::IndexStorageInfoProto >(arena);
}
template<> PROTOBUF_NOINLINE ::icing::lib::StorageInfoProto* Arena::CreateMaybeMessage< ::icing::lib::StorageInfoProto >(Arena* arena) {
  return Arena::CreateInternal< ::icing::lib::StorageInfoProto >(arena);
}
template<> PROTOBUF_NOINLINE ::icing::lib::StorageInfoResultProto* Arena::CreateMaybeMessage< ::icing::lib::StorageInfoResultProto >(Arena* arena) {
  return Arena::CreateInternal< ::icing::lib::StorageInfoResultProto >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
