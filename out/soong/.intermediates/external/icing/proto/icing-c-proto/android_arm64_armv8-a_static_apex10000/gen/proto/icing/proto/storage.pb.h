// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: icing/proto/storage.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_icing_2fproto_2fstorage_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_icing_2fproto_2fstorage_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "icing/proto/status.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_icing_2fproto_2fstorage_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_icing_2fproto_2fstorage_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace icing {
namespace lib {
class DocumentStorageInfoProto;
class DocumentStorageInfoProtoDefaultTypeInternal;
extern DocumentStorageInfoProtoDefaultTypeInternal _DocumentStorageInfoProto_default_instance_;
class IndexStorageInfoProto;
class IndexStorageInfoProtoDefaultTypeInternal;
extern IndexStorageInfoProtoDefaultTypeInternal _IndexStorageInfoProto_default_instance_;
class NamespaceStorageInfoProto;
class NamespaceStorageInfoProtoDefaultTypeInternal;
extern NamespaceStorageInfoProtoDefaultTypeInternal _NamespaceStorageInfoProto_default_instance_;
class SchemaStoreStorageInfoProto;
class SchemaStoreStorageInfoProtoDefaultTypeInternal;
extern SchemaStoreStorageInfoProtoDefaultTypeInternal _SchemaStoreStorageInfoProto_default_instance_;
class StorageInfoProto;
class StorageInfoProtoDefaultTypeInternal;
extern StorageInfoProtoDefaultTypeInternal _StorageInfoProto_default_instance_;
class StorageInfoResultProto;
class StorageInfoResultProtoDefaultTypeInternal;
extern StorageInfoResultProtoDefaultTypeInternal _StorageInfoResultProto_default_instance_;
}  // namespace lib
}  // namespace icing
PROTOBUF_NAMESPACE_OPEN
template<> ::icing::lib::DocumentStorageInfoProto* Arena::CreateMaybeMessage<::icing::lib::DocumentStorageInfoProto>(Arena*);
template<> ::icing::lib::IndexStorageInfoProto* Arena::CreateMaybeMessage<::icing::lib::IndexStorageInfoProto>(Arena*);
template<> ::icing::lib::NamespaceStorageInfoProto* Arena::CreateMaybeMessage<::icing::lib::NamespaceStorageInfoProto>(Arena*);
template<> ::icing::lib::SchemaStoreStorageInfoProto* Arena::CreateMaybeMessage<::icing::lib::SchemaStoreStorageInfoProto>(Arena*);
template<> ::icing::lib::StorageInfoProto* Arena::CreateMaybeMessage<::icing::lib::StorageInfoProto>(Arena*);
template<> ::icing::lib::StorageInfoResultProto* Arena::CreateMaybeMessage<::icing::lib::StorageInfoResultProto>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace icing {
namespace lib {

// ===================================================================

class NamespaceStorageInfoProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.NamespaceStorageInfoProto) */ {
 public:
  NamespaceStorageInfoProto();
  virtual ~NamespaceStorageInfoProto();

  NamespaceStorageInfoProto(const NamespaceStorageInfoProto& from);
  NamespaceStorageInfoProto(NamespaceStorageInfoProto&& from) noexcept
    : NamespaceStorageInfoProto() {
    *this = ::std::move(from);
  }

  inline NamespaceStorageInfoProto& operator=(const NamespaceStorageInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamespaceStorageInfoProto& operator=(NamespaceStorageInfoProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const NamespaceStorageInfoProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NamespaceStorageInfoProto* internal_default_instance() {
    return reinterpret_cast<const NamespaceStorageInfoProto*>(
               &_NamespaceStorageInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NamespaceStorageInfoProto& a, NamespaceStorageInfoProto& b) {
    a.Swap(&b);
  }
  inline void Swap(NamespaceStorageInfoProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NamespaceStorageInfoProto* New() const final {
    return CreateMaybeMessage<NamespaceStorageInfoProto>(nullptr);
  }

  NamespaceStorageInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NamespaceStorageInfoProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const NamespaceStorageInfoProto& from);
  void MergeFrom(const NamespaceStorageInfoProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NamespaceStorageInfoProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.NamespaceStorageInfoProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceFieldNumber = 1,
    kNumAliveDocumentsFieldNumber = 2,
    kNumExpiredDocumentsFieldNumber = 3,
    kNumAliveDocumentsUsageType1FieldNumber = 4,
    kNumAliveDocumentsUsageType2FieldNumber = 5,
    kNumAliveDocumentsUsageType3FieldNumber = 6,
    kNumExpiredDocumentsUsageType1FieldNumber = 7,
    kNumExpiredDocumentsUsageType2FieldNumber = 8,
    kNumExpiredDocumentsUsageType3FieldNumber = 9,
  };
  // optional string namespace = 1;
  bool has_namespace_() const;
  void clear_namespace_();
  const std::string& namespace_() const;
  void set_namespace_(const std::string& value);
  void set_namespace_(std::string&& value);
  void set_namespace_(const char* value);
  void set_namespace_(const char* value, size_t size);
  std::string* mutable_namespace_();
  std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);

  // optional int32 num_alive_documents = 2;
  bool has_num_alive_documents() const;
  void clear_num_alive_documents();
  ::PROTOBUF_NAMESPACE_ID::int32 num_alive_documents() const;
  void set_num_alive_documents(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_expired_documents = 3;
  bool has_num_expired_documents() const;
  void clear_num_expired_documents();
  ::PROTOBUF_NAMESPACE_ID::int32 num_expired_documents() const;
  void set_num_expired_documents(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_alive_documents_usage_type1 = 4;
  bool has_num_alive_documents_usage_type1() const;
  void clear_num_alive_documents_usage_type1();
  ::PROTOBUF_NAMESPACE_ID::int32 num_alive_documents_usage_type1() const;
  void set_num_alive_documents_usage_type1(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_alive_documents_usage_type2 = 5;
  bool has_num_alive_documents_usage_type2() const;
  void clear_num_alive_documents_usage_type2();
  ::PROTOBUF_NAMESPACE_ID::int32 num_alive_documents_usage_type2() const;
  void set_num_alive_documents_usage_type2(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_alive_documents_usage_type3 = 6;
  bool has_num_alive_documents_usage_type3() const;
  void clear_num_alive_documents_usage_type3();
  ::PROTOBUF_NAMESPACE_ID::int32 num_alive_documents_usage_type3() const;
  void set_num_alive_documents_usage_type3(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_expired_documents_usage_type1 = 7;
  bool has_num_expired_documents_usage_type1() const;
  void clear_num_expired_documents_usage_type1();
  ::PROTOBUF_NAMESPACE_ID::int32 num_expired_documents_usage_type1() const;
  void set_num_expired_documents_usage_type1(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_expired_documents_usage_type2 = 8;
  bool has_num_expired_documents_usage_type2() const;
  void clear_num_expired_documents_usage_type2();
  ::PROTOBUF_NAMESPACE_ID::int32 num_expired_documents_usage_type2() const;
  void set_num_expired_documents_usage_type2(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_expired_documents_usage_type3 = 9;
  bool has_num_expired_documents_usage_type3() const;
  void clear_num_expired_documents_usage_type3();
  ::PROTOBUF_NAMESPACE_ID::int32 num_expired_documents_usage_type3() const;
  void set_num_expired_documents_usage_type3(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:icing.lib.NamespaceStorageInfoProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
  ::PROTOBUF_NAMESPACE_ID::int32 num_alive_documents_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_expired_documents_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_alive_documents_usage_type1_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_alive_documents_usage_type2_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_alive_documents_usage_type3_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_expired_documents_usage_type1_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_expired_documents_usage_type2_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_expired_documents_usage_type3_;
  friend struct ::TableStruct_icing_2fproto_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class DocumentStorageInfoProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.DocumentStorageInfoProto) */ {
 public:
  DocumentStorageInfoProto();
  virtual ~DocumentStorageInfoProto();

  DocumentStorageInfoProto(const DocumentStorageInfoProto& from);
  DocumentStorageInfoProto(DocumentStorageInfoProto&& from) noexcept
    : DocumentStorageInfoProto() {
    *this = ::std::move(from);
  }

  inline DocumentStorageInfoProto& operator=(const DocumentStorageInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentStorageInfoProto& operator=(DocumentStorageInfoProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DocumentStorageInfoProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DocumentStorageInfoProto* internal_default_instance() {
    return reinterpret_cast<const DocumentStorageInfoProto*>(
               &_DocumentStorageInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DocumentStorageInfoProto& a, DocumentStorageInfoProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentStorageInfoProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DocumentStorageInfoProto* New() const final {
    return CreateMaybeMessage<DocumentStorageInfoProto>(nullptr);
  }

  DocumentStorageInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DocumentStorageInfoProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DocumentStorageInfoProto& from);
  void MergeFrom(const DocumentStorageInfoProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DocumentStorageInfoProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.DocumentStorageInfoProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceStorageInfoFieldNumber = 14,
    kNumAliveDocumentsFieldNumber = 1,
    kNumDeletedDocumentsFieldNumber = 2,
    kDocumentStoreSizeFieldNumber = 4,
    kDocumentLogSizeFieldNumber = 5,
    kKeyMapperSizeFieldNumber = 6,
    kDocumentIdMapperSizeFieldNumber = 7,
    kScoreCacheSizeFieldNumber = 8,
    kNumExpiredDocumentsFieldNumber = 3,
    kNumNamespacesFieldNumber = 13,
    kFilterCacheSizeFieldNumber = 9,
    kCorpusMapperSizeFieldNumber = 10,
    kCorpusScoreCacheSizeFieldNumber = 11,
    kNamespaceIdMapperSizeFieldNumber = 12,
  };
  // repeated .icing.lib.NamespaceStorageInfoProto namespace_storage_info = 14;
  int namespace_storage_info_size() const;
  void clear_namespace_storage_info();
  ::icing::lib::NamespaceStorageInfoProto* mutable_namespace_storage_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::NamespaceStorageInfoProto >*
      mutable_namespace_storage_info();
  const ::icing::lib::NamespaceStorageInfoProto& namespace_storage_info(int index) const;
  ::icing::lib::NamespaceStorageInfoProto* add_namespace_storage_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::NamespaceStorageInfoProto >&
      namespace_storage_info() const;

  // optional int32 num_alive_documents = 1;
  bool has_num_alive_documents() const;
  void clear_num_alive_documents();
  ::PROTOBUF_NAMESPACE_ID::int32 num_alive_documents() const;
  void set_num_alive_documents(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_deleted_documents = 2;
  bool has_num_deleted_documents() const;
  void clear_num_deleted_documents();
  ::PROTOBUF_NAMESPACE_ID::int32 num_deleted_documents() const;
  void set_num_deleted_documents(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int64 document_store_size = 4;
  bool has_document_store_size() const;
  void clear_document_store_size();
  ::PROTOBUF_NAMESPACE_ID::int64 document_store_size() const;
  void set_document_store_size(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 document_log_size = 5;
  bool has_document_log_size() const;
  void clear_document_log_size();
  ::PROTOBUF_NAMESPACE_ID::int64 document_log_size() const;
  void set_document_log_size(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 key_mapper_size = 6;
  bool has_key_mapper_size() const;
  void clear_key_mapper_size();
  ::PROTOBUF_NAMESPACE_ID::int64 key_mapper_size() const;
  void set_key_mapper_size(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 document_id_mapper_size = 7;
  bool has_document_id_mapper_size() const;
  void clear_document_id_mapper_size();
  ::PROTOBUF_NAMESPACE_ID::int64 document_id_mapper_size() const;
  void set_document_id_mapper_size(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 score_cache_size = 8;
  bool has_score_cache_size() const;
  void clear_score_cache_size();
  ::PROTOBUF_NAMESPACE_ID::int64 score_cache_size() const;
  void set_score_cache_size(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int32 num_expired_documents = 3;
  bool has_num_expired_documents() const;
  void clear_num_expired_documents();
  ::PROTOBUF_NAMESPACE_ID::int32 num_expired_documents() const;
  void set_num_expired_documents(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_namespaces = 13;
  bool has_num_namespaces() const;
  void clear_num_namespaces();
  ::PROTOBUF_NAMESPACE_ID::int32 num_namespaces() const;
  void set_num_namespaces(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int64 filter_cache_size = 9;
  bool has_filter_cache_size() const;
  void clear_filter_cache_size();
  ::PROTOBUF_NAMESPACE_ID::int64 filter_cache_size() const;
  void set_filter_cache_size(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 corpus_mapper_size = 10;
  bool has_corpus_mapper_size() const;
  void clear_corpus_mapper_size();
  ::PROTOBUF_NAMESPACE_ID::int64 corpus_mapper_size() const;
  void set_corpus_mapper_size(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 corpus_score_cache_size = 11;
  bool has_corpus_score_cache_size() const;
  void clear_corpus_score_cache_size();
  ::PROTOBUF_NAMESPACE_ID::int64 corpus_score_cache_size() const;
  void set_corpus_score_cache_size(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 namespace_id_mapper_size = 12;
  bool has_namespace_id_mapper_size() const;
  void clear_namespace_id_mapper_size();
  ::PROTOBUF_NAMESPACE_ID::int64 namespace_id_mapper_size() const;
  void set_namespace_id_mapper_size(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:icing.lib.DocumentStorageInfoProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::NamespaceStorageInfoProto > namespace_storage_info_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_alive_documents_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_deleted_documents_;
  ::PROTOBUF_NAMESPACE_ID::int64 document_store_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 document_log_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 key_mapper_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 document_id_mapper_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 score_cache_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_expired_documents_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_namespaces_;
  ::PROTOBUF_NAMESPACE_ID::int64 filter_cache_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 corpus_mapper_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 corpus_score_cache_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 namespace_id_mapper_size_;
  friend struct ::TableStruct_icing_2fproto_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class SchemaStoreStorageInfoProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.SchemaStoreStorageInfoProto) */ {
 public:
  SchemaStoreStorageInfoProto();
  virtual ~SchemaStoreStorageInfoProto();

  SchemaStoreStorageInfoProto(const SchemaStoreStorageInfoProto& from);
  SchemaStoreStorageInfoProto(SchemaStoreStorageInfoProto&& from) noexcept
    : SchemaStoreStorageInfoProto() {
    *this = ::std::move(from);
  }

  inline SchemaStoreStorageInfoProto& operator=(const SchemaStoreStorageInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaStoreStorageInfoProto& operator=(SchemaStoreStorageInfoProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SchemaStoreStorageInfoProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SchemaStoreStorageInfoProto* internal_default_instance() {
    return reinterpret_cast<const SchemaStoreStorageInfoProto*>(
               &_SchemaStoreStorageInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SchemaStoreStorageInfoProto& a, SchemaStoreStorageInfoProto& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaStoreStorageInfoProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SchemaStoreStorageInfoProto* New() const final {
    return CreateMaybeMessage<SchemaStoreStorageInfoProto>(nullptr);
  }

  SchemaStoreStorageInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SchemaStoreStorageInfoProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SchemaStoreStorageInfoProto& from);
  void MergeFrom(const SchemaStoreStorageInfoProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchemaStoreStorageInfoProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.SchemaStoreStorageInfoProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaStoreSizeFieldNumber = 1,
    kNumSchemaTypesFieldNumber = 2,
    kNumTotalSectionsFieldNumber = 3,
    kNumSchemaTypesSectionsExhaustedFieldNumber = 4,
  };
  // optional int64 schema_store_size = 1;
  bool has_schema_store_size() const;
  void clear_schema_store_size();
  ::PROTOBUF_NAMESPACE_ID::int64 schema_store_size() const;
  void set_schema_store_size(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int32 num_schema_types = 2;
  bool has_num_schema_types() const;
  void clear_num_schema_types();
  ::PROTOBUF_NAMESPACE_ID::int32 num_schema_types() const;
  void set_num_schema_types(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_total_sections = 3;
  bool has_num_total_sections() const;
  void clear_num_total_sections();
  ::PROTOBUF_NAMESPACE_ID::int32 num_total_sections() const;
  void set_num_total_sections(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_schema_types_sections_exhausted = 4;
  bool has_num_schema_types_sections_exhausted() const;
  void clear_num_schema_types_sections_exhausted();
  ::PROTOBUF_NAMESPACE_ID::int32 num_schema_types_sections_exhausted() const;
  void set_num_schema_types_sections_exhausted(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:icing.lib.SchemaStoreStorageInfoProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 schema_store_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_schema_types_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_total_sections_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_schema_types_sections_exhausted_;
  friend struct ::TableStruct_icing_2fproto_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class IndexStorageInfoProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.IndexStorageInfoProto) */ {
 public:
  IndexStorageInfoProto();
  virtual ~IndexStorageInfoProto();

  IndexStorageInfoProto(const IndexStorageInfoProto& from);
  IndexStorageInfoProto(IndexStorageInfoProto&& from) noexcept
    : IndexStorageInfoProto() {
    *this = ::std::move(from);
  }

  inline IndexStorageInfoProto& operator=(const IndexStorageInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexStorageInfoProto& operator=(IndexStorageInfoProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IndexStorageInfoProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IndexStorageInfoProto* internal_default_instance() {
    return reinterpret_cast<const IndexStorageInfoProto*>(
               &_IndexStorageInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(IndexStorageInfoProto& a, IndexStorageInfoProto& b) {
    a.Swap(&b);
  }
  inline void Swap(IndexStorageInfoProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IndexStorageInfoProto* New() const final {
    return CreateMaybeMessage<IndexStorageInfoProto>(nullptr);
  }

  IndexStorageInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IndexStorageInfoProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IndexStorageInfoProto& from);
  void MergeFrom(const IndexStorageInfoProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IndexStorageInfoProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.IndexStorageInfoProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexSizeFieldNumber = 1,
    kLiteIndexLexiconSizeFieldNumber = 2,
    kLiteIndexHitBufferSizeFieldNumber = 3,
    kMainIndexLexiconSizeFieldNumber = 4,
    kMainIndexStorageSizeFieldNumber = 5,
    kMainIndexBlockSizeFieldNumber = 6,
    kNumBlocksFieldNumber = 7,
    kMinFreeFractionFieldNumber = 8,
  };
  // optional int64 index_size = 1;
  bool has_index_size() const;
  void clear_index_size();
  ::PROTOBUF_NAMESPACE_ID::int64 index_size() const;
  void set_index_size(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 lite_index_lexicon_size = 2;
  bool has_lite_index_lexicon_size() const;
  void clear_lite_index_lexicon_size();
  ::PROTOBUF_NAMESPACE_ID::int64 lite_index_lexicon_size() const;
  void set_lite_index_lexicon_size(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 lite_index_hit_buffer_size = 3;
  bool has_lite_index_hit_buffer_size() const;
  void clear_lite_index_hit_buffer_size();
  ::PROTOBUF_NAMESPACE_ID::int64 lite_index_hit_buffer_size() const;
  void set_lite_index_hit_buffer_size(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 main_index_lexicon_size = 4;
  bool has_main_index_lexicon_size() const;
  void clear_main_index_lexicon_size();
  ::PROTOBUF_NAMESPACE_ID::int64 main_index_lexicon_size() const;
  void set_main_index_lexicon_size(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 main_index_storage_size = 5;
  bool has_main_index_storage_size() const;
  void clear_main_index_storage_size();
  ::PROTOBUF_NAMESPACE_ID::int64 main_index_storage_size() const;
  void set_main_index_storage_size(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 main_index_block_size = 6;
  bool has_main_index_block_size() const;
  void clear_main_index_block_size();
  ::PROTOBUF_NAMESPACE_ID::int64 main_index_block_size() const;
  void set_main_index_block_size(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int32 num_blocks = 7;
  bool has_num_blocks() const;
  void clear_num_blocks();
  ::PROTOBUF_NAMESPACE_ID::int32 num_blocks() const;
  void set_num_blocks(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional float min_free_fraction = 8;
  bool has_min_free_fraction() const;
  void clear_min_free_fraction();
  float min_free_fraction() const;
  void set_min_free_fraction(float value);

  // @@protoc_insertion_point(class_scope:icing.lib.IndexStorageInfoProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 index_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 lite_index_lexicon_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 lite_index_hit_buffer_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 main_index_lexicon_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 main_index_storage_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 main_index_block_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_blocks_;
  float min_free_fraction_;
  friend struct ::TableStruct_icing_2fproto_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class StorageInfoProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.StorageInfoProto) */ {
 public:
  StorageInfoProto();
  virtual ~StorageInfoProto();

  StorageInfoProto(const StorageInfoProto& from);
  StorageInfoProto(StorageInfoProto&& from) noexcept
    : StorageInfoProto() {
    *this = ::std::move(from);
  }

  inline StorageInfoProto& operator=(const StorageInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline StorageInfoProto& operator=(StorageInfoProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const StorageInfoProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StorageInfoProto* internal_default_instance() {
    return reinterpret_cast<const StorageInfoProto*>(
               &_StorageInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StorageInfoProto& a, StorageInfoProto& b) {
    a.Swap(&b);
  }
  inline void Swap(StorageInfoProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StorageInfoProto* New() const final {
    return CreateMaybeMessage<StorageInfoProto>(nullptr);
  }

  StorageInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StorageInfoProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const StorageInfoProto& from);
  void MergeFrom(const StorageInfoProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StorageInfoProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.StorageInfoProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentStorageInfoFieldNumber = 2,
    kSchemaStoreStorageInfoFieldNumber = 3,
    kIndexStorageInfoFieldNumber = 4,
    kTotalStorageSizeFieldNumber = 1,
  };
  // optional .icing.lib.DocumentStorageInfoProto document_storage_info = 2;
  bool has_document_storage_info() const;
  void clear_document_storage_info();
  const ::icing::lib::DocumentStorageInfoProto& document_storage_info() const;
  ::icing::lib::DocumentStorageInfoProto* release_document_storage_info();
  ::icing::lib::DocumentStorageInfoProto* mutable_document_storage_info();
  void set_allocated_document_storage_info(::icing::lib::DocumentStorageInfoProto* document_storage_info);

  // optional .icing.lib.SchemaStoreStorageInfoProto schema_store_storage_info = 3;
  bool has_schema_store_storage_info() const;
  void clear_schema_store_storage_info();
  const ::icing::lib::SchemaStoreStorageInfoProto& schema_store_storage_info() const;
  ::icing::lib::SchemaStoreStorageInfoProto* release_schema_store_storage_info();
  ::icing::lib::SchemaStoreStorageInfoProto* mutable_schema_store_storage_info();
  void set_allocated_schema_store_storage_info(::icing::lib::SchemaStoreStorageInfoProto* schema_store_storage_info);

  // optional .icing.lib.IndexStorageInfoProto index_storage_info = 4;
  bool has_index_storage_info() const;
  void clear_index_storage_info();
  const ::icing::lib::IndexStorageInfoProto& index_storage_info() const;
  ::icing::lib::IndexStorageInfoProto* release_index_storage_info();
  ::icing::lib::IndexStorageInfoProto* mutable_index_storage_info();
  void set_allocated_index_storage_info(::icing::lib::IndexStorageInfoProto* index_storage_info);

  // optional int64 total_storage_size = 1;
  bool has_total_storage_size() const;
  void clear_total_storage_size();
  ::PROTOBUF_NAMESPACE_ID::int64 total_storage_size() const;
  void set_total_storage_size(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:icing.lib.StorageInfoProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::icing::lib::DocumentStorageInfoProto* document_storage_info_;
  ::icing::lib::SchemaStoreStorageInfoProto* schema_store_storage_info_;
  ::icing::lib::IndexStorageInfoProto* index_storage_info_;
  ::PROTOBUF_NAMESPACE_ID::int64 total_storage_size_;
  friend struct ::TableStruct_icing_2fproto_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class StorageInfoResultProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.StorageInfoResultProto) */ {
 public:
  StorageInfoResultProto();
  virtual ~StorageInfoResultProto();

  StorageInfoResultProto(const StorageInfoResultProto& from);
  StorageInfoResultProto(StorageInfoResultProto&& from) noexcept
    : StorageInfoResultProto() {
    *this = ::std::move(from);
  }

  inline StorageInfoResultProto& operator=(const StorageInfoResultProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline StorageInfoResultProto& operator=(StorageInfoResultProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const StorageInfoResultProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StorageInfoResultProto* internal_default_instance() {
    return reinterpret_cast<const StorageInfoResultProto*>(
               &_StorageInfoResultProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StorageInfoResultProto& a, StorageInfoResultProto& b) {
    a.Swap(&b);
  }
  inline void Swap(StorageInfoResultProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StorageInfoResultProto* New() const final {
    return CreateMaybeMessage<StorageInfoResultProto>(nullptr);
  }

  StorageInfoResultProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StorageInfoResultProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const StorageInfoResultProto& from);
  void MergeFrom(const StorageInfoResultProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StorageInfoResultProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.StorageInfoResultProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kStorageInfoFieldNumber = 2,
  };
  // optional .icing.lib.StatusProto status = 1;
  bool has_status() const;
  void clear_status();
  const ::icing::lib::StatusProto& status() const;
  ::icing::lib::StatusProto* release_status();
  ::icing::lib::StatusProto* mutable_status();
  void set_allocated_status(::icing::lib::StatusProto* status);

  // optional .icing.lib.StorageInfoProto storage_info = 2;
  bool has_storage_info() const;
  void clear_storage_info();
  const ::icing::lib::StorageInfoProto& storage_info() const;
  ::icing::lib::StorageInfoProto* release_storage_info();
  ::icing::lib::StorageInfoProto* mutable_storage_info();
  void set_allocated_storage_info(::icing::lib::StorageInfoProto* storage_info);

  // @@protoc_insertion_point(class_scope:icing.lib.StorageInfoResultProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::icing::lib::StatusProto* status_;
  ::icing::lib::StorageInfoProto* storage_info_;
  friend struct ::TableStruct_icing_2fproto_2fstorage_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NamespaceStorageInfoProto

// optional string namespace = 1;
inline bool NamespaceStorageInfoProto::has_namespace_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NamespaceStorageInfoProto::clear_namespace_() {
  namespace__.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NamespaceStorageInfoProto::namespace_() const {
  // @@protoc_insertion_point(field_get:icing.lib.NamespaceStorageInfoProto.namespace)
  return namespace__.GetNoArena();
}
inline void NamespaceStorageInfoProto::set_namespace_(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  namespace__.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:icing.lib.NamespaceStorageInfoProto.namespace)
}
inline void NamespaceStorageInfoProto::set_namespace_(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  namespace__.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:icing.lib.NamespaceStorageInfoProto.namespace)
}
inline void NamespaceStorageInfoProto::set_namespace_(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  namespace__.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:icing.lib.NamespaceStorageInfoProto.namespace)
}
inline void NamespaceStorageInfoProto::set_namespace_(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  namespace__.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:icing.lib.NamespaceStorageInfoProto.namespace)
}
inline std::string* NamespaceStorageInfoProto::mutable_namespace_() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:icing.lib.NamespaceStorageInfoProto.namespace)
  return namespace__.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NamespaceStorageInfoProto::release_namespace_() {
  // @@protoc_insertion_point(field_release:icing.lib.NamespaceStorageInfoProto.namespace)
  if (!has_namespace_()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return namespace__.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NamespaceStorageInfoProto::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  namespace__.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_);
  // @@protoc_insertion_point(field_set_allocated:icing.lib.NamespaceStorageInfoProto.namespace)
}

// optional int32 num_alive_documents = 2;
inline bool NamespaceStorageInfoProto::has_num_alive_documents() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NamespaceStorageInfoProto::clear_num_alive_documents() {
  num_alive_documents_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NamespaceStorageInfoProto::num_alive_documents() const {
  // @@protoc_insertion_point(field_get:icing.lib.NamespaceStorageInfoProto.num_alive_documents)
  return num_alive_documents_;
}
inline void NamespaceStorageInfoProto::set_num_alive_documents(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  num_alive_documents_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.NamespaceStorageInfoProto.num_alive_documents)
}

// optional int32 num_expired_documents = 3;
inline bool NamespaceStorageInfoProto::has_num_expired_documents() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NamespaceStorageInfoProto::clear_num_expired_documents() {
  num_expired_documents_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NamespaceStorageInfoProto::num_expired_documents() const {
  // @@protoc_insertion_point(field_get:icing.lib.NamespaceStorageInfoProto.num_expired_documents)
  return num_expired_documents_;
}
inline void NamespaceStorageInfoProto::set_num_expired_documents(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  num_expired_documents_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.NamespaceStorageInfoProto.num_expired_documents)
}

// optional int32 num_alive_documents_usage_type1 = 4;
inline bool NamespaceStorageInfoProto::has_num_alive_documents_usage_type1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NamespaceStorageInfoProto::clear_num_alive_documents_usage_type1() {
  num_alive_documents_usage_type1_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NamespaceStorageInfoProto::num_alive_documents_usage_type1() const {
  // @@protoc_insertion_point(field_get:icing.lib.NamespaceStorageInfoProto.num_alive_documents_usage_type1)
  return num_alive_documents_usage_type1_;
}
inline void NamespaceStorageInfoProto::set_num_alive_documents_usage_type1(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  num_alive_documents_usage_type1_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.NamespaceStorageInfoProto.num_alive_documents_usage_type1)
}

// optional int32 num_alive_documents_usage_type2 = 5;
inline bool NamespaceStorageInfoProto::has_num_alive_documents_usage_type2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NamespaceStorageInfoProto::clear_num_alive_documents_usage_type2() {
  num_alive_documents_usage_type2_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NamespaceStorageInfoProto::num_alive_documents_usage_type2() const {
  // @@protoc_insertion_point(field_get:icing.lib.NamespaceStorageInfoProto.num_alive_documents_usage_type2)
  return num_alive_documents_usage_type2_;
}
inline void NamespaceStorageInfoProto::set_num_alive_documents_usage_type2(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  num_alive_documents_usage_type2_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.NamespaceStorageInfoProto.num_alive_documents_usage_type2)
}

// optional int32 num_alive_documents_usage_type3 = 6;
inline bool NamespaceStorageInfoProto::has_num_alive_documents_usage_type3() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NamespaceStorageInfoProto::clear_num_alive_documents_usage_type3() {
  num_alive_documents_usage_type3_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NamespaceStorageInfoProto::num_alive_documents_usage_type3() const {
  // @@protoc_insertion_point(field_get:icing.lib.NamespaceStorageInfoProto.num_alive_documents_usage_type3)
  return num_alive_documents_usage_type3_;
}
inline void NamespaceStorageInfoProto::set_num_alive_documents_usage_type3(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  num_alive_documents_usage_type3_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.NamespaceStorageInfoProto.num_alive_documents_usage_type3)
}

// optional int32 num_expired_documents_usage_type1 = 7;
inline bool NamespaceStorageInfoProto::has_num_expired_documents_usage_type1() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NamespaceStorageInfoProto::clear_num_expired_documents_usage_type1() {
  num_expired_documents_usage_type1_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NamespaceStorageInfoProto::num_expired_documents_usage_type1() const {
  // @@protoc_insertion_point(field_get:icing.lib.NamespaceStorageInfoProto.num_expired_documents_usage_type1)
  return num_expired_documents_usage_type1_;
}
inline void NamespaceStorageInfoProto::set_num_expired_documents_usage_type1(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  num_expired_documents_usage_type1_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.NamespaceStorageInfoProto.num_expired_documents_usage_type1)
}

// optional int32 num_expired_documents_usage_type2 = 8;
inline bool NamespaceStorageInfoProto::has_num_expired_documents_usage_type2() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NamespaceStorageInfoProto::clear_num_expired_documents_usage_type2() {
  num_expired_documents_usage_type2_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NamespaceStorageInfoProto::num_expired_documents_usage_type2() const {
  // @@protoc_insertion_point(field_get:icing.lib.NamespaceStorageInfoProto.num_expired_documents_usage_type2)
  return num_expired_documents_usage_type2_;
}
inline void NamespaceStorageInfoProto::set_num_expired_documents_usage_type2(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  num_expired_documents_usage_type2_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.NamespaceStorageInfoProto.num_expired_documents_usage_type2)
}

// optional int32 num_expired_documents_usage_type3 = 9;
inline bool NamespaceStorageInfoProto::has_num_expired_documents_usage_type3() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NamespaceStorageInfoProto::clear_num_expired_documents_usage_type3() {
  num_expired_documents_usage_type3_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NamespaceStorageInfoProto::num_expired_documents_usage_type3() const {
  // @@protoc_insertion_point(field_get:icing.lib.NamespaceStorageInfoProto.num_expired_documents_usage_type3)
  return num_expired_documents_usage_type3_;
}
inline void NamespaceStorageInfoProto::set_num_expired_documents_usage_type3(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  num_expired_documents_usage_type3_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.NamespaceStorageInfoProto.num_expired_documents_usage_type3)
}

// -------------------------------------------------------------------

// DocumentStorageInfoProto

// optional int32 num_alive_documents = 1;
inline bool DocumentStorageInfoProto::has_num_alive_documents() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentStorageInfoProto::clear_num_alive_documents() {
  num_alive_documents_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DocumentStorageInfoProto::num_alive_documents() const {
  // @@protoc_insertion_point(field_get:icing.lib.DocumentStorageInfoProto.num_alive_documents)
  return num_alive_documents_;
}
inline void DocumentStorageInfoProto::set_num_alive_documents(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  num_alive_documents_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.DocumentStorageInfoProto.num_alive_documents)
}

// optional int32 num_deleted_documents = 2;
inline bool DocumentStorageInfoProto::has_num_deleted_documents() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DocumentStorageInfoProto::clear_num_deleted_documents() {
  num_deleted_documents_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DocumentStorageInfoProto::num_deleted_documents() const {
  // @@protoc_insertion_point(field_get:icing.lib.DocumentStorageInfoProto.num_deleted_documents)
  return num_deleted_documents_;
}
inline void DocumentStorageInfoProto::set_num_deleted_documents(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  num_deleted_documents_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.DocumentStorageInfoProto.num_deleted_documents)
}

// optional int32 num_expired_documents = 3;
inline bool DocumentStorageInfoProto::has_num_expired_documents() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DocumentStorageInfoProto::clear_num_expired_documents() {
  num_expired_documents_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DocumentStorageInfoProto::num_expired_documents() const {
  // @@protoc_insertion_point(field_get:icing.lib.DocumentStorageInfoProto.num_expired_documents)
  return num_expired_documents_;
}
inline void DocumentStorageInfoProto::set_num_expired_documents(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  num_expired_documents_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.DocumentStorageInfoProto.num_expired_documents)
}

// optional int64 document_store_size = 4;
inline bool DocumentStorageInfoProto::has_document_store_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DocumentStorageInfoProto::clear_document_store_size() {
  document_store_size_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DocumentStorageInfoProto::document_store_size() const {
  // @@protoc_insertion_point(field_get:icing.lib.DocumentStorageInfoProto.document_store_size)
  return document_store_size_;
}
inline void DocumentStorageInfoProto::set_document_store_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  document_store_size_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.DocumentStorageInfoProto.document_store_size)
}

// optional int64 document_log_size = 5;
inline bool DocumentStorageInfoProto::has_document_log_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DocumentStorageInfoProto::clear_document_log_size() {
  document_log_size_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DocumentStorageInfoProto::document_log_size() const {
  // @@protoc_insertion_point(field_get:icing.lib.DocumentStorageInfoProto.document_log_size)
  return document_log_size_;
}
inline void DocumentStorageInfoProto::set_document_log_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  document_log_size_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.DocumentStorageInfoProto.document_log_size)
}

// optional int64 key_mapper_size = 6;
inline bool DocumentStorageInfoProto::has_key_mapper_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DocumentStorageInfoProto::clear_key_mapper_size() {
  key_mapper_size_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DocumentStorageInfoProto::key_mapper_size() const {
  // @@protoc_insertion_point(field_get:icing.lib.DocumentStorageInfoProto.key_mapper_size)
  return key_mapper_size_;
}
inline void DocumentStorageInfoProto::set_key_mapper_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  key_mapper_size_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.DocumentStorageInfoProto.key_mapper_size)
}

// optional int64 document_id_mapper_size = 7;
inline bool DocumentStorageInfoProto::has_document_id_mapper_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DocumentStorageInfoProto::clear_document_id_mapper_size() {
  document_id_mapper_size_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DocumentStorageInfoProto::document_id_mapper_size() const {
  // @@protoc_insertion_point(field_get:icing.lib.DocumentStorageInfoProto.document_id_mapper_size)
  return document_id_mapper_size_;
}
inline void DocumentStorageInfoProto::set_document_id_mapper_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  document_id_mapper_size_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.DocumentStorageInfoProto.document_id_mapper_size)
}

// optional int64 score_cache_size = 8;
inline bool DocumentStorageInfoProto::has_score_cache_size() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DocumentStorageInfoProto::clear_score_cache_size() {
  score_cache_size_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DocumentStorageInfoProto::score_cache_size() const {
  // @@protoc_insertion_point(field_get:icing.lib.DocumentStorageInfoProto.score_cache_size)
  return score_cache_size_;
}
inline void DocumentStorageInfoProto::set_score_cache_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  score_cache_size_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.DocumentStorageInfoProto.score_cache_size)
}

// optional int64 filter_cache_size = 9;
inline bool DocumentStorageInfoProto::has_filter_cache_size() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DocumentStorageInfoProto::clear_filter_cache_size() {
  filter_cache_size_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DocumentStorageInfoProto::filter_cache_size() const {
  // @@protoc_insertion_point(field_get:icing.lib.DocumentStorageInfoProto.filter_cache_size)
  return filter_cache_size_;
}
inline void DocumentStorageInfoProto::set_filter_cache_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000200u;
  filter_cache_size_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.DocumentStorageInfoProto.filter_cache_size)
}

// optional int64 corpus_mapper_size = 10;
inline bool DocumentStorageInfoProto::has_corpus_mapper_size() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DocumentStorageInfoProto::clear_corpus_mapper_size() {
  corpus_mapper_size_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DocumentStorageInfoProto::corpus_mapper_size() const {
  // @@protoc_insertion_point(field_get:icing.lib.DocumentStorageInfoProto.corpus_mapper_size)
  return corpus_mapper_size_;
}
inline void DocumentStorageInfoProto::set_corpus_mapper_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000400u;
  corpus_mapper_size_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.DocumentStorageInfoProto.corpus_mapper_size)
}

// optional int64 corpus_score_cache_size = 11;
inline bool DocumentStorageInfoProto::has_corpus_score_cache_size() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DocumentStorageInfoProto::clear_corpus_score_cache_size() {
  corpus_score_cache_size_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DocumentStorageInfoProto::corpus_score_cache_size() const {
  // @@protoc_insertion_point(field_get:icing.lib.DocumentStorageInfoProto.corpus_score_cache_size)
  return corpus_score_cache_size_;
}
inline void DocumentStorageInfoProto::set_corpus_score_cache_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000800u;
  corpus_score_cache_size_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.DocumentStorageInfoProto.corpus_score_cache_size)
}

// optional int64 namespace_id_mapper_size = 12;
inline bool DocumentStorageInfoProto::has_namespace_id_mapper_size() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DocumentStorageInfoProto::clear_namespace_id_mapper_size() {
  namespace_id_mapper_size_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DocumentStorageInfoProto::namespace_id_mapper_size() const {
  // @@protoc_insertion_point(field_get:icing.lib.DocumentStorageInfoProto.namespace_id_mapper_size)
  return namespace_id_mapper_size_;
}
inline void DocumentStorageInfoProto::set_namespace_id_mapper_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00001000u;
  namespace_id_mapper_size_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.DocumentStorageInfoProto.namespace_id_mapper_size)
}

// optional int32 num_namespaces = 13;
inline bool DocumentStorageInfoProto::has_num_namespaces() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DocumentStorageInfoProto::clear_num_namespaces() {
  num_namespaces_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DocumentStorageInfoProto::num_namespaces() const {
  // @@protoc_insertion_point(field_get:icing.lib.DocumentStorageInfoProto.num_namespaces)
  return num_namespaces_;
}
inline void DocumentStorageInfoProto::set_num_namespaces(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  num_namespaces_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.DocumentStorageInfoProto.num_namespaces)
}

// repeated .icing.lib.NamespaceStorageInfoProto namespace_storage_info = 14;
inline int DocumentStorageInfoProto::namespace_storage_info_size() const {
  return namespace_storage_info_.size();
}
inline void DocumentStorageInfoProto::clear_namespace_storage_info() {
  namespace_storage_info_.Clear();
}
inline ::icing::lib::NamespaceStorageInfoProto* DocumentStorageInfoProto::mutable_namespace_storage_info(int index) {
  // @@protoc_insertion_point(field_mutable:icing.lib.DocumentStorageInfoProto.namespace_storage_info)
  return namespace_storage_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::NamespaceStorageInfoProto >*
DocumentStorageInfoProto::mutable_namespace_storage_info() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.DocumentStorageInfoProto.namespace_storage_info)
  return &namespace_storage_info_;
}
inline const ::icing::lib::NamespaceStorageInfoProto& DocumentStorageInfoProto::namespace_storage_info(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.DocumentStorageInfoProto.namespace_storage_info)
  return namespace_storage_info_.Get(index);
}
inline ::icing::lib::NamespaceStorageInfoProto* DocumentStorageInfoProto::add_namespace_storage_info() {
  // @@protoc_insertion_point(field_add:icing.lib.DocumentStorageInfoProto.namespace_storage_info)
  return namespace_storage_info_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::NamespaceStorageInfoProto >&
DocumentStorageInfoProto::namespace_storage_info() const {
  // @@protoc_insertion_point(field_list:icing.lib.DocumentStorageInfoProto.namespace_storage_info)
  return namespace_storage_info_;
}

// -------------------------------------------------------------------

// SchemaStoreStorageInfoProto

// optional int64 schema_store_size = 1;
inline bool SchemaStoreStorageInfoProto::has_schema_store_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaStoreStorageInfoProto::clear_schema_store_size() {
  schema_store_size_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaStoreStorageInfoProto::schema_store_size() const {
  // @@protoc_insertion_point(field_get:icing.lib.SchemaStoreStorageInfoProto.schema_store_size)
  return schema_store_size_;
}
inline void SchemaStoreStorageInfoProto::set_schema_store_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  schema_store_size_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.SchemaStoreStorageInfoProto.schema_store_size)
}

// optional int32 num_schema_types = 2;
inline bool SchemaStoreStorageInfoProto::has_num_schema_types() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaStoreStorageInfoProto::clear_num_schema_types() {
  num_schema_types_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchemaStoreStorageInfoProto::num_schema_types() const {
  // @@protoc_insertion_point(field_get:icing.lib.SchemaStoreStorageInfoProto.num_schema_types)
  return num_schema_types_;
}
inline void SchemaStoreStorageInfoProto::set_num_schema_types(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  num_schema_types_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.SchemaStoreStorageInfoProto.num_schema_types)
}

// optional int32 num_total_sections = 3;
inline bool SchemaStoreStorageInfoProto::has_num_total_sections() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemaStoreStorageInfoProto::clear_num_total_sections() {
  num_total_sections_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchemaStoreStorageInfoProto::num_total_sections() const {
  // @@protoc_insertion_point(field_get:icing.lib.SchemaStoreStorageInfoProto.num_total_sections)
  return num_total_sections_;
}
inline void SchemaStoreStorageInfoProto::set_num_total_sections(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  num_total_sections_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.SchemaStoreStorageInfoProto.num_total_sections)
}

// optional int32 num_schema_types_sections_exhausted = 4;
inline bool SchemaStoreStorageInfoProto::has_num_schema_types_sections_exhausted() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchemaStoreStorageInfoProto::clear_num_schema_types_sections_exhausted() {
  num_schema_types_sections_exhausted_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchemaStoreStorageInfoProto::num_schema_types_sections_exhausted() const {
  // @@protoc_insertion_point(field_get:icing.lib.SchemaStoreStorageInfoProto.num_schema_types_sections_exhausted)
  return num_schema_types_sections_exhausted_;
}
inline void SchemaStoreStorageInfoProto::set_num_schema_types_sections_exhausted(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  num_schema_types_sections_exhausted_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.SchemaStoreStorageInfoProto.num_schema_types_sections_exhausted)
}

// -------------------------------------------------------------------

// IndexStorageInfoProto

// optional int64 index_size = 1;
inline bool IndexStorageInfoProto::has_index_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IndexStorageInfoProto::clear_index_size() {
  index_size_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IndexStorageInfoProto::index_size() const {
  // @@protoc_insertion_point(field_get:icing.lib.IndexStorageInfoProto.index_size)
  return index_size_;
}
inline void IndexStorageInfoProto::set_index_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  index_size_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.IndexStorageInfoProto.index_size)
}

// optional int64 lite_index_lexicon_size = 2;
inline bool IndexStorageInfoProto::has_lite_index_lexicon_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IndexStorageInfoProto::clear_lite_index_lexicon_size() {
  lite_index_lexicon_size_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IndexStorageInfoProto::lite_index_lexicon_size() const {
  // @@protoc_insertion_point(field_get:icing.lib.IndexStorageInfoProto.lite_index_lexicon_size)
  return lite_index_lexicon_size_;
}
inline void IndexStorageInfoProto::set_lite_index_lexicon_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  lite_index_lexicon_size_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.IndexStorageInfoProto.lite_index_lexicon_size)
}

// optional int64 lite_index_hit_buffer_size = 3;
inline bool IndexStorageInfoProto::has_lite_index_hit_buffer_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IndexStorageInfoProto::clear_lite_index_hit_buffer_size() {
  lite_index_hit_buffer_size_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IndexStorageInfoProto::lite_index_hit_buffer_size() const {
  // @@protoc_insertion_point(field_get:icing.lib.IndexStorageInfoProto.lite_index_hit_buffer_size)
  return lite_index_hit_buffer_size_;
}
inline void IndexStorageInfoProto::set_lite_index_hit_buffer_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  lite_index_hit_buffer_size_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.IndexStorageInfoProto.lite_index_hit_buffer_size)
}

// optional int64 main_index_lexicon_size = 4;
inline bool IndexStorageInfoProto::has_main_index_lexicon_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IndexStorageInfoProto::clear_main_index_lexicon_size() {
  main_index_lexicon_size_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IndexStorageInfoProto::main_index_lexicon_size() const {
  // @@protoc_insertion_point(field_get:icing.lib.IndexStorageInfoProto.main_index_lexicon_size)
  return main_index_lexicon_size_;
}
inline void IndexStorageInfoProto::set_main_index_lexicon_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  main_index_lexicon_size_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.IndexStorageInfoProto.main_index_lexicon_size)
}

// optional int64 main_index_storage_size = 5;
inline bool IndexStorageInfoProto::has_main_index_storage_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IndexStorageInfoProto::clear_main_index_storage_size() {
  main_index_storage_size_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IndexStorageInfoProto::main_index_storage_size() const {
  // @@protoc_insertion_point(field_get:icing.lib.IndexStorageInfoProto.main_index_storage_size)
  return main_index_storage_size_;
}
inline void IndexStorageInfoProto::set_main_index_storage_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  main_index_storage_size_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.IndexStorageInfoProto.main_index_storage_size)
}

// optional int64 main_index_block_size = 6;
inline bool IndexStorageInfoProto::has_main_index_block_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IndexStorageInfoProto::clear_main_index_block_size() {
  main_index_block_size_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IndexStorageInfoProto::main_index_block_size() const {
  // @@protoc_insertion_point(field_get:icing.lib.IndexStorageInfoProto.main_index_block_size)
  return main_index_block_size_;
}
inline void IndexStorageInfoProto::set_main_index_block_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  main_index_block_size_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.IndexStorageInfoProto.main_index_block_size)
}

// optional int32 num_blocks = 7;
inline bool IndexStorageInfoProto::has_num_blocks() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IndexStorageInfoProto::clear_num_blocks() {
  num_blocks_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IndexStorageInfoProto::num_blocks() const {
  // @@protoc_insertion_point(field_get:icing.lib.IndexStorageInfoProto.num_blocks)
  return num_blocks_;
}
inline void IndexStorageInfoProto::set_num_blocks(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  num_blocks_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.IndexStorageInfoProto.num_blocks)
}

// optional float min_free_fraction = 8;
inline bool IndexStorageInfoProto::has_min_free_fraction() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IndexStorageInfoProto::clear_min_free_fraction() {
  min_free_fraction_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float IndexStorageInfoProto::min_free_fraction() const {
  // @@protoc_insertion_point(field_get:icing.lib.IndexStorageInfoProto.min_free_fraction)
  return min_free_fraction_;
}
inline void IndexStorageInfoProto::set_min_free_fraction(float value) {
  _has_bits_[0] |= 0x00000080u;
  min_free_fraction_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.IndexStorageInfoProto.min_free_fraction)
}

// -------------------------------------------------------------------

// StorageInfoProto

// optional int64 total_storage_size = 1;
inline bool StorageInfoProto::has_total_storage_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StorageInfoProto::clear_total_storage_size() {
  total_storage_size_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StorageInfoProto::total_storage_size() const {
  // @@protoc_insertion_point(field_get:icing.lib.StorageInfoProto.total_storage_size)
  return total_storage_size_;
}
inline void StorageInfoProto::set_total_storage_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  total_storage_size_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.StorageInfoProto.total_storage_size)
}

// optional .icing.lib.DocumentStorageInfoProto document_storage_info = 2;
inline bool StorageInfoProto::has_document_storage_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StorageInfoProto::clear_document_storage_info() {
  if (document_storage_info_ != nullptr) document_storage_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::icing::lib::DocumentStorageInfoProto& StorageInfoProto::document_storage_info() const {
  const ::icing::lib::DocumentStorageInfoProto* p = document_storage_info_;
  // @@protoc_insertion_point(field_get:icing.lib.StorageInfoProto.document_storage_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::DocumentStorageInfoProto*>(
      &::icing::lib::_DocumentStorageInfoProto_default_instance_);
}
inline ::icing::lib::DocumentStorageInfoProto* StorageInfoProto::release_document_storage_info() {
  // @@protoc_insertion_point(field_release:icing.lib.StorageInfoProto.document_storage_info)
  _has_bits_[0] &= ~0x00000001u;
  ::icing::lib::DocumentStorageInfoProto* temp = document_storage_info_;
  document_storage_info_ = nullptr;
  return temp;
}
inline ::icing::lib::DocumentStorageInfoProto* StorageInfoProto::mutable_document_storage_info() {
  _has_bits_[0] |= 0x00000001u;
  if (document_storage_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::DocumentStorageInfoProto>(GetArenaNoVirtual());
    document_storage_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.StorageInfoProto.document_storage_info)
  return document_storage_info_;
}
inline void StorageInfoProto::set_allocated_document_storage_info(::icing::lib::DocumentStorageInfoProto* document_storage_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete document_storage_info_;
  }
  if (document_storage_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      document_storage_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, document_storage_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  document_storage_info_ = document_storage_info;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.StorageInfoProto.document_storage_info)
}

// optional .icing.lib.SchemaStoreStorageInfoProto schema_store_storage_info = 3;
inline bool StorageInfoProto::has_schema_store_storage_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StorageInfoProto::clear_schema_store_storage_info() {
  if (schema_store_storage_info_ != nullptr) schema_store_storage_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::icing::lib::SchemaStoreStorageInfoProto& StorageInfoProto::schema_store_storage_info() const {
  const ::icing::lib::SchemaStoreStorageInfoProto* p = schema_store_storage_info_;
  // @@protoc_insertion_point(field_get:icing.lib.StorageInfoProto.schema_store_storage_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::SchemaStoreStorageInfoProto*>(
      &::icing::lib::_SchemaStoreStorageInfoProto_default_instance_);
}
inline ::icing::lib::SchemaStoreStorageInfoProto* StorageInfoProto::release_schema_store_storage_info() {
  // @@protoc_insertion_point(field_release:icing.lib.StorageInfoProto.schema_store_storage_info)
  _has_bits_[0] &= ~0x00000002u;
  ::icing::lib::SchemaStoreStorageInfoProto* temp = schema_store_storage_info_;
  schema_store_storage_info_ = nullptr;
  return temp;
}
inline ::icing::lib::SchemaStoreStorageInfoProto* StorageInfoProto::mutable_schema_store_storage_info() {
  _has_bits_[0] |= 0x00000002u;
  if (schema_store_storage_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::SchemaStoreStorageInfoProto>(GetArenaNoVirtual());
    schema_store_storage_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.StorageInfoProto.schema_store_storage_info)
  return schema_store_storage_info_;
}
inline void StorageInfoProto::set_allocated_schema_store_storage_info(::icing::lib::SchemaStoreStorageInfoProto* schema_store_storage_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete schema_store_storage_info_;
  }
  if (schema_store_storage_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      schema_store_storage_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema_store_storage_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  schema_store_storage_info_ = schema_store_storage_info;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.StorageInfoProto.schema_store_storage_info)
}

// optional .icing.lib.IndexStorageInfoProto index_storage_info = 4;
inline bool StorageInfoProto::has_index_storage_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StorageInfoProto::clear_index_storage_info() {
  if (index_storage_info_ != nullptr) index_storage_info_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::icing::lib::IndexStorageInfoProto& StorageInfoProto::index_storage_info() const {
  const ::icing::lib::IndexStorageInfoProto* p = index_storage_info_;
  // @@protoc_insertion_point(field_get:icing.lib.StorageInfoProto.index_storage_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::IndexStorageInfoProto*>(
      &::icing::lib::_IndexStorageInfoProto_default_instance_);
}
inline ::icing::lib::IndexStorageInfoProto* StorageInfoProto::release_index_storage_info() {
  // @@protoc_insertion_point(field_release:icing.lib.StorageInfoProto.index_storage_info)
  _has_bits_[0] &= ~0x00000004u;
  ::icing::lib::IndexStorageInfoProto* temp = index_storage_info_;
  index_storage_info_ = nullptr;
  return temp;
}
inline ::icing::lib::IndexStorageInfoProto* StorageInfoProto::mutable_index_storage_info() {
  _has_bits_[0] |= 0x00000004u;
  if (index_storage_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::IndexStorageInfoProto>(GetArenaNoVirtual());
    index_storage_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.StorageInfoProto.index_storage_info)
  return index_storage_info_;
}
inline void StorageInfoProto::set_allocated_index_storage_info(::icing::lib::IndexStorageInfoProto* index_storage_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete index_storage_info_;
  }
  if (index_storage_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      index_storage_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, index_storage_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  index_storage_info_ = index_storage_info;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.StorageInfoProto.index_storage_info)
}

// -------------------------------------------------------------------

// StorageInfoResultProto

// optional .icing.lib.StatusProto status = 1;
inline bool StorageInfoResultProto::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::icing::lib::StatusProto& StorageInfoResultProto::status() const {
  const ::icing::lib::StatusProto* p = status_;
  // @@protoc_insertion_point(field_get:icing.lib.StorageInfoResultProto.status)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::StatusProto*>(
      &::icing::lib::_StatusProto_default_instance_);
}
inline ::icing::lib::StatusProto* StorageInfoResultProto::release_status() {
  // @@protoc_insertion_point(field_release:icing.lib.StorageInfoResultProto.status)
  _has_bits_[0] &= ~0x00000001u;
  ::icing::lib::StatusProto* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::icing::lib::StatusProto* StorageInfoResultProto::mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::StatusProto>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.StorageInfoResultProto.status)
  return status_;
}
inline void StorageInfoResultProto::set_allocated_status(::icing::lib::StatusProto* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.StorageInfoResultProto.status)
}

// optional .icing.lib.StorageInfoProto storage_info = 2;
inline bool StorageInfoResultProto::has_storage_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StorageInfoResultProto::clear_storage_info() {
  if (storage_info_ != nullptr) storage_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::icing::lib::StorageInfoProto& StorageInfoResultProto::storage_info() const {
  const ::icing::lib::StorageInfoProto* p = storage_info_;
  // @@protoc_insertion_point(field_get:icing.lib.StorageInfoResultProto.storage_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::StorageInfoProto*>(
      &::icing::lib::_StorageInfoProto_default_instance_);
}
inline ::icing::lib::StorageInfoProto* StorageInfoResultProto::release_storage_info() {
  // @@protoc_insertion_point(field_release:icing.lib.StorageInfoResultProto.storage_info)
  _has_bits_[0] &= ~0x00000002u;
  ::icing::lib::StorageInfoProto* temp = storage_info_;
  storage_info_ = nullptr;
  return temp;
}
inline ::icing::lib::StorageInfoProto* StorageInfoResultProto::mutable_storage_info() {
  _has_bits_[0] |= 0x00000002u;
  if (storage_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::StorageInfoProto>(GetArenaNoVirtual());
    storage_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.StorageInfoResultProto.storage_info)
  return storage_info_;
}
inline void StorageInfoResultProto::set_allocated_storage_info(::icing::lib::StorageInfoProto* storage_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete storage_info_;
  }
  if (storage_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      storage_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  storage_info_ = storage_info;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.StorageInfoResultProto.storage_info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace lib
}  // namespace icing

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_icing_2fproto_2fstorage_2eproto
