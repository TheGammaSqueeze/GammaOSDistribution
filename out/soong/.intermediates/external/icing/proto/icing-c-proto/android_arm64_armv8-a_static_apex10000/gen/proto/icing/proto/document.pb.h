// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: icing/proto/document.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_icing_2fproto_2fdocument_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_icing_2fproto_2fdocument_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "icing/proto/logging.pb.h"
#include "icing/proto/status.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_icing_2fproto_2fdocument_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_icing_2fproto_2fdocument_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace icing {
namespace lib {
class DeleteByNamespaceResultProto;
class DeleteByNamespaceResultProtoDefaultTypeInternal;
extern DeleteByNamespaceResultProtoDefaultTypeInternal _DeleteByNamespaceResultProto_default_instance_;
class DeleteByQueryResultProto;
class DeleteByQueryResultProtoDefaultTypeInternal;
extern DeleteByQueryResultProtoDefaultTypeInternal _DeleteByQueryResultProto_default_instance_;
class DeleteBySchemaTypeResultProto;
class DeleteBySchemaTypeResultProtoDefaultTypeInternal;
extern DeleteBySchemaTypeResultProtoDefaultTypeInternal _DeleteBySchemaTypeResultProto_default_instance_;
class DeleteResultProto;
class DeleteResultProtoDefaultTypeInternal;
extern DeleteResultProtoDefaultTypeInternal _DeleteResultProto_default_instance_;
class DocumentProto;
class DocumentProtoDefaultTypeInternal;
extern DocumentProtoDefaultTypeInternal _DocumentProto_default_instance_;
class DocumentProto_InternalFields;
class DocumentProto_InternalFieldsDefaultTypeInternal;
extern DocumentProto_InternalFieldsDefaultTypeInternal _DocumentProto_InternalFields_default_instance_;
class GetAllNamespacesResultProto;
class GetAllNamespacesResultProtoDefaultTypeInternal;
extern GetAllNamespacesResultProtoDefaultTypeInternal _GetAllNamespacesResultProto_default_instance_;
class GetResultProto;
class GetResultProtoDefaultTypeInternal;
extern GetResultProtoDefaultTypeInternal _GetResultProto_default_instance_;
class PropertyProto;
class PropertyProtoDefaultTypeInternal;
extern PropertyProtoDefaultTypeInternal _PropertyProto_default_instance_;
class PutResultProto;
class PutResultProtoDefaultTypeInternal;
extern PutResultProtoDefaultTypeInternal _PutResultProto_default_instance_;
}  // namespace lib
}  // namespace icing
PROTOBUF_NAMESPACE_OPEN
template<> ::icing::lib::DeleteByNamespaceResultProto* Arena::CreateMaybeMessage<::icing::lib::DeleteByNamespaceResultProto>(Arena*);
template<> ::icing::lib::DeleteByQueryResultProto* Arena::CreateMaybeMessage<::icing::lib::DeleteByQueryResultProto>(Arena*);
template<> ::icing::lib::DeleteBySchemaTypeResultProto* Arena::CreateMaybeMessage<::icing::lib::DeleteBySchemaTypeResultProto>(Arena*);
template<> ::icing::lib::DeleteResultProto* Arena::CreateMaybeMessage<::icing::lib::DeleteResultProto>(Arena*);
template<> ::icing::lib::DocumentProto* Arena::CreateMaybeMessage<::icing::lib::DocumentProto>(Arena*);
template<> ::icing::lib::DocumentProto_InternalFields* Arena::CreateMaybeMessage<::icing::lib::DocumentProto_InternalFields>(Arena*);
template<> ::icing::lib::GetAllNamespacesResultProto* Arena::CreateMaybeMessage<::icing::lib::GetAllNamespacesResultProto>(Arena*);
template<> ::icing::lib::GetResultProto* Arena::CreateMaybeMessage<::icing::lib::GetResultProto>(Arena*);
template<> ::icing::lib::PropertyProto* Arena::CreateMaybeMessage<::icing::lib::PropertyProto>(Arena*);
template<> ::icing::lib::PutResultProto* Arena::CreateMaybeMessage<::icing::lib::PutResultProto>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace icing {
namespace lib {

// ===================================================================

class DocumentProto_InternalFields :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.DocumentProto.InternalFields) */ {
 public:
  DocumentProto_InternalFields();
  virtual ~DocumentProto_InternalFields();

  DocumentProto_InternalFields(const DocumentProto_InternalFields& from);
  DocumentProto_InternalFields(DocumentProto_InternalFields&& from) noexcept
    : DocumentProto_InternalFields() {
    *this = ::std::move(from);
  }

  inline DocumentProto_InternalFields& operator=(const DocumentProto_InternalFields& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentProto_InternalFields& operator=(DocumentProto_InternalFields&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DocumentProto_InternalFields& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DocumentProto_InternalFields* internal_default_instance() {
    return reinterpret_cast<const DocumentProto_InternalFields*>(
               &_DocumentProto_InternalFields_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DocumentProto_InternalFields& a, DocumentProto_InternalFields& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentProto_InternalFields* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DocumentProto_InternalFields* New() const final {
    return CreateMaybeMessage<DocumentProto_InternalFields>(nullptr);
  }

  DocumentProto_InternalFields* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DocumentProto_InternalFields>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DocumentProto_InternalFields& from);
  void MergeFrom(const DocumentProto_InternalFields& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DocumentProto_InternalFields* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.DocumentProto.InternalFields";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLengthInTokensFieldNumber = 1,
  };
  // optional int32 length_in_tokens = 1;
  bool has_length_in_tokens() const;
  void clear_length_in_tokens();
  ::PROTOBUF_NAMESPACE_ID::int32 length_in_tokens() const;
  void set_length_in_tokens(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:icing.lib.DocumentProto.InternalFields)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 length_in_tokens_;
  friend struct ::TableStruct_icing_2fproto_2fdocument_2eproto;
};
// -------------------------------------------------------------------

class DocumentProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.DocumentProto) */ {
 public:
  DocumentProto();
  virtual ~DocumentProto();

  DocumentProto(const DocumentProto& from);
  DocumentProto(DocumentProto&& from) noexcept
    : DocumentProto() {
    *this = ::std::move(from);
  }

  inline DocumentProto& operator=(const DocumentProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentProto& operator=(DocumentProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DocumentProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DocumentProto* internal_default_instance() {
    return reinterpret_cast<const DocumentProto*>(
               &_DocumentProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DocumentProto& a, DocumentProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DocumentProto* New() const final {
    return CreateMaybeMessage<DocumentProto>(nullptr);
  }

  DocumentProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DocumentProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DocumentProto& from);
  void MergeFrom(const DocumentProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DocumentProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.DocumentProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DocumentProto_InternalFields InternalFields;

  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 5,
    kNamespaceFieldNumber = 1,
    kUriFieldNumber = 2,
    kSchemaFieldNumber = 3,
    kInternalFieldsFieldNumber = 9,
    kCreationTimestampMsFieldNumber = 4,
    kTtlMsFieldNumber = 8,
    kScoreFieldNumber = 7,
  };
  // repeated .icing.lib.PropertyProto properties = 5;
  int properties_size() const;
  void clear_properties();
  ::icing::lib::PropertyProto* mutable_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::PropertyProto >*
      mutable_properties();
  const ::icing::lib::PropertyProto& properties(int index) const;
  ::icing::lib::PropertyProto* add_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::PropertyProto >&
      properties() const;

  // optional string namespace = 1;
  bool has_namespace_() const;
  void clear_namespace_();
  const std::string& namespace_() const;
  void set_namespace_(const std::string& value);
  void set_namespace_(std::string&& value);
  void set_namespace_(const char* value);
  void set_namespace_(const char* value, size_t size);
  std::string* mutable_namespace_();
  std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);

  // optional string uri = 2;
  bool has_uri() const;
  void clear_uri();
  const std::string& uri() const;
  void set_uri(const std::string& value);
  void set_uri(std::string&& value);
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  std::string* mutable_uri();
  std::string* release_uri();
  void set_allocated_uri(std::string* uri);

  // optional string schema = 3;
  bool has_schema() const;
  void clear_schema();
  const std::string& schema() const;
  void set_schema(const std::string& value);
  void set_schema(std::string&& value);
  void set_schema(const char* value);
  void set_schema(const char* value, size_t size);
  std::string* mutable_schema();
  std::string* release_schema();
  void set_allocated_schema(std::string* schema);

  // optional .icing.lib.DocumentProto.InternalFields internal_fields = 9;
  bool has_internal_fields() const;
  void clear_internal_fields();
  const ::icing::lib::DocumentProto_InternalFields& internal_fields() const;
  ::icing::lib::DocumentProto_InternalFields* release_internal_fields();
  ::icing::lib::DocumentProto_InternalFields* mutable_internal_fields();
  void set_allocated_internal_fields(::icing::lib::DocumentProto_InternalFields* internal_fields);

  // optional int64 creation_timestamp_ms = 4;
  bool has_creation_timestamp_ms() const;
  void clear_creation_timestamp_ms();
  ::PROTOBUF_NAMESPACE_ID::int64 creation_timestamp_ms() const;
  void set_creation_timestamp_ms(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 ttl_ms = 8 [default = 0];
  bool has_ttl_ms() const;
  void clear_ttl_ms();
  ::PROTOBUF_NAMESPACE_ID::int64 ttl_ms() const;
  void set_ttl_ms(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int32 score = 7 [default = 0];
  bool has_score() const;
  void clear_score();
  ::PROTOBUF_NAMESPACE_ID::int32 score() const;
  void set_score(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:icing.lib.DocumentProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::PropertyProto > properties_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_;
  ::icing::lib::DocumentProto_InternalFields* internal_fields_;
  ::PROTOBUF_NAMESPACE_ID::int64 creation_timestamp_ms_;
  ::PROTOBUF_NAMESPACE_ID::int64 ttl_ms_;
  ::PROTOBUF_NAMESPACE_ID::int32 score_;
  friend struct ::TableStruct_icing_2fproto_2fdocument_2eproto;
};
// -------------------------------------------------------------------

class PropertyProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.PropertyProto) */ {
 public:
  PropertyProto();
  virtual ~PropertyProto();

  PropertyProto(const PropertyProto& from);
  PropertyProto(PropertyProto&& from) noexcept
    : PropertyProto() {
    *this = ::std::move(from);
  }

  inline PropertyProto& operator=(const PropertyProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline PropertyProto& operator=(PropertyProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PropertyProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PropertyProto* internal_default_instance() {
    return reinterpret_cast<const PropertyProto*>(
               &_PropertyProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PropertyProto& a, PropertyProto& b) {
    a.Swap(&b);
  }
  inline void Swap(PropertyProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PropertyProto* New() const final {
    return CreateMaybeMessage<PropertyProto>(nullptr);
  }

  PropertyProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PropertyProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PropertyProto& from);
  void MergeFrom(const PropertyProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PropertyProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.PropertyProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStringValuesFieldNumber = 2,
    kInt64ValuesFieldNumber = 3,
    kDoubleValuesFieldNumber = 4,
    kBooleanValuesFieldNumber = 5,
    kBytesValuesFieldNumber = 6,
    kDocumentValuesFieldNumber = 7,
    kNameFieldNumber = 1,
  };
  // repeated string string_values = 2;
  int string_values_size() const;
  void clear_string_values();
  const std::string& string_values(int index) const;
  std::string* mutable_string_values(int index);
  void set_string_values(int index, const std::string& value);
  void set_string_values(int index, std::string&& value);
  void set_string_values(int index, const char* value);
  void set_string_values(int index, const char* value, size_t size);
  std::string* add_string_values();
  void add_string_values(const std::string& value);
  void add_string_values(std::string&& value);
  void add_string_values(const char* value);
  void add_string_values(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& string_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_string_values();

  // repeated int64 int64_values = 3;
  int int64_values_size() const;
  void clear_int64_values();
  ::PROTOBUF_NAMESPACE_ID::int64 int64_values(int index) const;
  void set_int64_values(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_int64_values(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      int64_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_int64_values();

  // repeated double double_values = 4;
  int double_values_size() const;
  void clear_double_values();
  double double_values(int index) const;
  void set_double_values(int index, double value);
  void add_double_values(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      double_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_double_values();

  // repeated bool boolean_values = 5;
  int boolean_values_size() const;
  void clear_boolean_values();
  bool boolean_values(int index) const;
  void set_boolean_values(int index, bool value);
  void add_boolean_values(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      boolean_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_boolean_values();

  // repeated bytes bytes_values = 6;
  int bytes_values_size() const;
  void clear_bytes_values();
  const std::string& bytes_values(int index) const;
  std::string* mutable_bytes_values(int index);
  void set_bytes_values(int index, const std::string& value);
  void set_bytes_values(int index, std::string&& value);
  void set_bytes_values(int index, const char* value);
  void set_bytes_values(int index, const void* value, size_t size);
  std::string* add_bytes_values();
  void add_bytes_values(const std::string& value);
  void add_bytes_values(std::string&& value);
  void add_bytes_values(const char* value);
  void add_bytes_values(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& bytes_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_bytes_values();

  // repeated .icing.lib.DocumentProto document_values = 7;
  int document_values_size() const;
  void clear_document_values();
  ::icing::lib::DocumentProto* mutable_document_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::DocumentProto >*
      mutable_document_values();
  const ::icing::lib::DocumentProto& document_values(int index) const;
  ::icing::lib::DocumentProto* add_document_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::DocumentProto >&
      document_values() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // @@protoc_insertion_point(class_scope:icing.lib.PropertyProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> string_values_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > int64_values_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > double_values_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > boolean_values_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> bytes_values_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::DocumentProto > document_values_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  friend struct ::TableStruct_icing_2fproto_2fdocument_2eproto;
};
// -------------------------------------------------------------------

class PutResultProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.PutResultProto) */ {
 public:
  PutResultProto();
  virtual ~PutResultProto();

  PutResultProto(const PutResultProto& from);
  PutResultProto(PutResultProto&& from) noexcept
    : PutResultProto() {
    *this = ::std::move(from);
  }

  inline PutResultProto& operator=(const PutResultProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutResultProto& operator=(PutResultProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PutResultProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PutResultProto* internal_default_instance() {
    return reinterpret_cast<const PutResultProto*>(
               &_PutResultProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PutResultProto& a, PutResultProto& b) {
    a.Swap(&b);
  }
  inline void Swap(PutResultProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PutResultProto* New() const final {
    return CreateMaybeMessage<PutResultProto>(nullptr);
  }

  PutResultProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PutResultProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PutResultProto& from);
  void MergeFrom(const PutResultProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PutResultProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.PutResultProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kPutDocumentStatsFieldNumber = 2,
  };
  // optional .icing.lib.StatusProto status = 1;
  bool has_status() const;
  void clear_status();
  const ::icing::lib::StatusProto& status() const;
  ::icing::lib::StatusProto* release_status();
  ::icing::lib::StatusProto* mutable_status();
  void set_allocated_status(::icing::lib::StatusProto* status);

  // optional .icing.lib.PutDocumentStatsProto put_document_stats = 2;
  bool has_put_document_stats() const;
  void clear_put_document_stats();
  const ::icing::lib::PutDocumentStatsProto& put_document_stats() const;
  ::icing::lib::PutDocumentStatsProto* release_put_document_stats();
  ::icing::lib::PutDocumentStatsProto* mutable_put_document_stats();
  void set_allocated_put_document_stats(::icing::lib::PutDocumentStatsProto* put_document_stats);

  // @@protoc_insertion_point(class_scope:icing.lib.PutResultProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::icing::lib::StatusProto* status_;
  ::icing::lib::PutDocumentStatsProto* put_document_stats_;
  friend struct ::TableStruct_icing_2fproto_2fdocument_2eproto;
};
// -------------------------------------------------------------------

class GetResultProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.GetResultProto) */ {
 public:
  GetResultProto();
  virtual ~GetResultProto();

  GetResultProto(const GetResultProto& from);
  GetResultProto(GetResultProto&& from) noexcept
    : GetResultProto() {
    *this = ::std::move(from);
  }

  inline GetResultProto& operator=(const GetResultProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResultProto& operator=(GetResultProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GetResultProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetResultProto* internal_default_instance() {
    return reinterpret_cast<const GetResultProto*>(
               &_GetResultProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetResultProto& a, GetResultProto& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResultProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetResultProto* New() const final {
    return CreateMaybeMessage<GetResultProto>(nullptr);
  }

  GetResultProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetResultProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const GetResultProto& from);
  void MergeFrom(const GetResultProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetResultProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.GetResultProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kDocumentFieldNumber = 2,
  };
  // optional .icing.lib.StatusProto status = 1;
  bool has_status() const;
  void clear_status();
  const ::icing::lib::StatusProto& status() const;
  ::icing::lib::StatusProto* release_status();
  ::icing::lib::StatusProto* mutable_status();
  void set_allocated_status(::icing::lib::StatusProto* status);

  // optional .icing.lib.DocumentProto document = 2;
  bool has_document() const;
  void clear_document();
  const ::icing::lib::DocumentProto& document() const;
  ::icing::lib::DocumentProto* release_document();
  ::icing::lib::DocumentProto* mutable_document();
  void set_allocated_document(::icing::lib::DocumentProto* document);

  // @@protoc_insertion_point(class_scope:icing.lib.GetResultProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::icing::lib::StatusProto* status_;
  ::icing::lib::DocumentProto* document_;
  friend struct ::TableStruct_icing_2fproto_2fdocument_2eproto;
};
// -------------------------------------------------------------------

class GetAllNamespacesResultProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.GetAllNamespacesResultProto) */ {
 public:
  GetAllNamespacesResultProto();
  virtual ~GetAllNamespacesResultProto();

  GetAllNamespacesResultProto(const GetAllNamespacesResultProto& from);
  GetAllNamespacesResultProto(GetAllNamespacesResultProto&& from) noexcept
    : GetAllNamespacesResultProto() {
    *this = ::std::move(from);
  }

  inline GetAllNamespacesResultProto& operator=(const GetAllNamespacesResultProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAllNamespacesResultProto& operator=(GetAllNamespacesResultProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GetAllNamespacesResultProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetAllNamespacesResultProto* internal_default_instance() {
    return reinterpret_cast<const GetAllNamespacesResultProto*>(
               &_GetAllNamespacesResultProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetAllNamespacesResultProto& a, GetAllNamespacesResultProto& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAllNamespacesResultProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetAllNamespacesResultProto* New() const final {
    return CreateMaybeMessage<GetAllNamespacesResultProto>(nullptr);
  }

  GetAllNamespacesResultProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetAllNamespacesResultProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const GetAllNamespacesResultProto& from);
  void MergeFrom(const GetAllNamespacesResultProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAllNamespacesResultProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.GetAllNamespacesResultProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespacesFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // repeated string namespaces = 2;
  int namespaces_size() const;
  void clear_namespaces();
  const std::string& namespaces(int index) const;
  std::string* mutable_namespaces(int index);
  void set_namespaces(int index, const std::string& value);
  void set_namespaces(int index, std::string&& value);
  void set_namespaces(int index, const char* value);
  void set_namespaces(int index, const char* value, size_t size);
  std::string* add_namespaces();
  void add_namespaces(const std::string& value);
  void add_namespaces(std::string&& value);
  void add_namespaces(const char* value);
  void add_namespaces(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& namespaces() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_namespaces();

  // optional .icing.lib.StatusProto status = 1;
  bool has_status() const;
  void clear_status();
  const ::icing::lib::StatusProto& status() const;
  ::icing::lib::StatusProto* release_status();
  ::icing::lib::StatusProto* mutable_status();
  void set_allocated_status(::icing::lib::StatusProto* status);

  // @@protoc_insertion_point(class_scope:icing.lib.GetAllNamespacesResultProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> namespaces_;
  ::icing::lib::StatusProto* status_;
  friend struct ::TableStruct_icing_2fproto_2fdocument_2eproto;
};
// -------------------------------------------------------------------

class DeleteResultProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.DeleteResultProto) */ {
 public:
  DeleteResultProto();
  virtual ~DeleteResultProto();

  DeleteResultProto(const DeleteResultProto& from);
  DeleteResultProto(DeleteResultProto&& from) noexcept
    : DeleteResultProto() {
    *this = ::std::move(from);
  }

  inline DeleteResultProto& operator=(const DeleteResultProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteResultProto& operator=(DeleteResultProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DeleteResultProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteResultProto* internal_default_instance() {
    return reinterpret_cast<const DeleteResultProto*>(
               &_DeleteResultProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DeleteResultProto& a, DeleteResultProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteResultProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteResultProto* New() const final {
    return CreateMaybeMessage<DeleteResultProto>(nullptr);
  }

  DeleteResultProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteResultProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DeleteResultProto& from);
  void MergeFrom(const DeleteResultProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeleteResultProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.DeleteResultProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kDeleteStatsFieldNumber = 2,
  };
  // optional .icing.lib.StatusProto status = 1;
  bool has_status() const;
  void clear_status();
  const ::icing::lib::StatusProto& status() const;
  ::icing::lib::StatusProto* release_status();
  ::icing::lib::StatusProto* mutable_status();
  void set_allocated_status(::icing::lib::StatusProto* status);

  // optional .icing.lib.DeleteStatsProto delete_stats = 2;
  bool has_delete_stats() const;
  void clear_delete_stats();
  const ::icing::lib::DeleteStatsProto& delete_stats() const;
  ::icing::lib::DeleteStatsProto* release_delete_stats();
  ::icing::lib::DeleteStatsProto* mutable_delete_stats();
  void set_allocated_delete_stats(::icing::lib::DeleteStatsProto* delete_stats);

  // @@protoc_insertion_point(class_scope:icing.lib.DeleteResultProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::icing::lib::StatusProto* status_;
  ::icing::lib::DeleteStatsProto* delete_stats_;
  friend struct ::TableStruct_icing_2fproto_2fdocument_2eproto;
};
// -------------------------------------------------------------------

class DeleteByNamespaceResultProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.DeleteByNamespaceResultProto) */ {
 public:
  DeleteByNamespaceResultProto();
  virtual ~DeleteByNamespaceResultProto();

  DeleteByNamespaceResultProto(const DeleteByNamespaceResultProto& from);
  DeleteByNamespaceResultProto(DeleteByNamespaceResultProto&& from) noexcept
    : DeleteByNamespaceResultProto() {
    *this = ::std::move(from);
  }

  inline DeleteByNamespaceResultProto& operator=(const DeleteByNamespaceResultProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteByNamespaceResultProto& operator=(DeleteByNamespaceResultProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DeleteByNamespaceResultProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteByNamespaceResultProto* internal_default_instance() {
    return reinterpret_cast<const DeleteByNamespaceResultProto*>(
               &_DeleteByNamespaceResultProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DeleteByNamespaceResultProto& a, DeleteByNamespaceResultProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteByNamespaceResultProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteByNamespaceResultProto* New() const final {
    return CreateMaybeMessage<DeleteByNamespaceResultProto>(nullptr);
  }

  DeleteByNamespaceResultProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteByNamespaceResultProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DeleteByNamespaceResultProto& from);
  void MergeFrom(const DeleteByNamespaceResultProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeleteByNamespaceResultProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.DeleteByNamespaceResultProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kDeleteStatsFieldNumber = 2,
  };
  // optional .icing.lib.StatusProto status = 1;
  bool has_status() const;
  void clear_status();
  const ::icing::lib::StatusProto& status() const;
  ::icing::lib::StatusProto* release_status();
  ::icing::lib::StatusProto* mutable_status();
  void set_allocated_status(::icing::lib::StatusProto* status);

  // optional .icing.lib.DeleteStatsProto delete_stats = 2;
  bool has_delete_stats() const;
  void clear_delete_stats();
  const ::icing::lib::DeleteStatsProto& delete_stats() const;
  ::icing::lib::DeleteStatsProto* release_delete_stats();
  ::icing::lib::DeleteStatsProto* mutable_delete_stats();
  void set_allocated_delete_stats(::icing::lib::DeleteStatsProto* delete_stats);

  // @@protoc_insertion_point(class_scope:icing.lib.DeleteByNamespaceResultProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::icing::lib::StatusProto* status_;
  ::icing::lib::DeleteStatsProto* delete_stats_;
  friend struct ::TableStruct_icing_2fproto_2fdocument_2eproto;
};
// -------------------------------------------------------------------

class DeleteBySchemaTypeResultProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.DeleteBySchemaTypeResultProto) */ {
 public:
  DeleteBySchemaTypeResultProto();
  virtual ~DeleteBySchemaTypeResultProto();

  DeleteBySchemaTypeResultProto(const DeleteBySchemaTypeResultProto& from);
  DeleteBySchemaTypeResultProto(DeleteBySchemaTypeResultProto&& from) noexcept
    : DeleteBySchemaTypeResultProto() {
    *this = ::std::move(from);
  }

  inline DeleteBySchemaTypeResultProto& operator=(const DeleteBySchemaTypeResultProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteBySchemaTypeResultProto& operator=(DeleteBySchemaTypeResultProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DeleteBySchemaTypeResultProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteBySchemaTypeResultProto* internal_default_instance() {
    return reinterpret_cast<const DeleteBySchemaTypeResultProto*>(
               &_DeleteBySchemaTypeResultProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DeleteBySchemaTypeResultProto& a, DeleteBySchemaTypeResultProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteBySchemaTypeResultProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteBySchemaTypeResultProto* New() const final {
    return CreateMaybeMessage<DeleteBySchemaTypeResultProto>(nullptr);
  }

  DeleteBySchemaTypeResultProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteBySchemaTypeResultProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DeleteBySchemaTypeResultProto& from);
  void MergeFrom(const DeleteBySchemaTypeResultProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeleteBySchemaTypeResultProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.DeleteBySchemaTypeResultProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kDeleteStatsFieldNumber = 2,
  };
  // optional .icing.lib.StatusProto status = 1;
  bool has_status() const;
  void clear_status();
  const ::icing::lib::StatusProto& status() const;
  ::icing::lib::StatusProto* release_status();
  ::icing::lib::StatusProto* mutable_status();
  void set_allocated_status(::icing::lib::StatusProto* status);

  // optional .icing.lib.DeleteStatsProto delete_stats = 2;
  bool has_delete_stats() const;
  void clear_delete_stats();
  const ::icing::lib::DeleteStatsProto& delete_stats() const;
  ::icing::lib::DeleteStatsProto* release_delete_stats();
  ::icing::lib::DeleteStatsProto* mutable_delete_stats();
  void set_allocated_delete_stats(::icing::lib::DeleteStatsProto* delete_stats);

  // @@protoc_insertion_point(class_scope:icing.lib.DeleteBySchemaTypeResultProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::icing::lib::StatusProto* status_;
  ::icing::lib::DeleteStatsProto* delete_stats_;
  friend struct ::TableStruct_icing_2fproto_2fdocument_2eproto;
};
// -------------------------------------------------------------------

class DeleteByQueryResultProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.DeleteByQueryResultProto) */ {
 public:
  DeleteByQueryResultProto();
  virtual ~DeleteByQueryResultProto();

  DeleteByQueryResultProto(const DeleteByQueryResultProto& from);
  DeleteByQueryResultProto(DeleteByQueryResultProto&& from) noexcept
    : DeleteByQueryResultProto() {
    *this = ::std::move(from);
  }

  inline DeleteByQueryResultProto& operator=(const DeleteByQueryResultProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteByQueryResultProto& operator=(DeleteByQueryResultProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DeleteByQueryResultProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteByQueryResultProto* internal_default_instance() {
    return reinterpret_cast<const DeleteByQueryResultProto*>(
               &_DeleteByQueryResultProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DeleteByQueryResultProto& a, DeleteByQueryResultProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteByQueryResultProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteByQueryResultProto* New() const final {
    return CreateMaybeMessage<DeleteByQueryResultProto>(nullptr);
  }

  DeleteByQueryResultProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteByQueryResultProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DeleteByQueryResultProto& from);
  void MergeFrom(const DeleteByQueryResultProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeleteByQueryResultProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.DeleteByQueryResultProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kDeleteByQueryStatsFieldNumber = 3,
  };
  // optional .icing.lib.StatusProto status = 1;
  bool has_status() const;
  void clear_status();
  const ::icing::lib::StatusProto& status() const;
  ::icing::lib::StatusProto* release_status();
  ::icing::lib::StatusProto* mutable_status();
  void set_allocated_status(::icing::lib::StatusProto* status);

  // optional .icing.lib.DeleteByQueryStatsProto delete_by_query_stats = 3;
  bool has_delete_by_query_stats() const;
  void clear_delete_by_query_stats();
  const ::icing::lib::DeleteByQueryStatsProto& delete_by_query_stats() const;
  ::icing::lib::DeleteByQueryStatsProto* release_delete_by_query_stats();
  ::icing::lib::DeleteByQueryStatsProto* mutable_delete_by_query_stats();
  void set_allocated_delete_by_query_stats(::icing::lib::DeleteByQueryStatsProto* delete_by_query_stats);

  // @@protoc_insertion_point(class_scope:icing.lib.DeleteByQueryResultProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::icing::lib::StatusProto* status_;
  ::icing::lib::DeleteByQueryStatsProto* delete_by_query_stats_;
  friend struct ::TableStruct_icing_2fproto_2fdocument_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DocumentProto_InternalFields

// optional int32 length_in_tokens = 1;
inline bool DocumentProto_InternalFields::has_length_in_tokens() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentProto_InternalFields::clear_length_in_tokens() {
  length_in_tokens_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DocumentProto_InternalFields::length_in_tokens() const {
  // @@protoc_insertion_point(field_get:icing.lib.DocumentProto.InternalFields.length_in_tokens)
  return length_in_tokens_;
}
inline void DocumentProto_InternalFields::set_length_in_tokens(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  length_in_tokens_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.DocumentProto.InternalFields.length_in_tokens)
}

// -------------------------------------------------------------------

// DocumentProto

// optional string namespace = 1;
inline bool DocumentProto::has_namespace_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentProto::clear_namespace_() {
  namespace__.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DocumentProto::namespace_() const {
  // @@protoc_insertion_point(field_get:icing.lib.DocumentProto.namespace)
  return namespace__.GetNoArena();
}
inline void DocumentProto::set_namespace_(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  namespace__.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:icing.lib.DocumentProto.namespace)
}
inline void DocumentProto::set_namespace_(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  namespace__.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:icing.lib.DocumentProto.namespace)
}
inline void DocumentProto::set_namespace_(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  namespace__.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:icing.lib.DocumentProto.namespace)
}
inline void DocumentProto::set_namespace_(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  namespace__.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:icing.lib.DocumentProto.namespace)
}
inline std::string* DocumentProto::mutable_namespace_() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:icing.lib.DocumentProto.namespace)
  return namespace__.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DocumentProto::release_namespace_() {
  // @@protoc_insertion_point(field_release:icing.lib.DocumentProto.namespace)
  if (!has_namespace_()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return namespace__.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DocumentProto::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  namespace__.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_);
  // @@protoc_insertion_point(field_set_allocated:icing.lib.DocumentProto.namespace)
}

// optional string uri = 2;
inline bool DocumentProto::has_uri() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DocumentProto::clear_uri() {
  uri_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DocumentProto::uri() const {
  // @@protoc_insertion_point(field_get:icing.lib.DocumentProto.uri)
  return uri_.GetNoArena();
}
inline void DocumentProto::set_uri(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  uri_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:icing.lib.DocumentProto.uri)
}
inline void DocumentProto::set_uri(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  uri_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:icing.lib.DocumentProto.uri)
}
inline void DocumentProto::set_uri(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  uri_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:icing.lib.DocumentProto.uri)
}
inline void DocumentProto::set_uri(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  uri_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:icing.lib.DocumentProto.uri)
}
inline std::string* DocumentProto::mutable_uri() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:icing.lib.DocumentProto.uri)
  return uri_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DocumentProto::release_uri() {
  // @@protoc_insertion_point(field_release:icing.lib.DocumentProto.uri)
  if (!has_uri()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return uri_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DocumentProto::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  uri_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri);
  // @@protoc_insertion_point(field_set_allocated:icing.lib.DocumentProto.uri)
}

// optional string schema = 3;
inline bool DocumentProto::has_schema() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DocumentProto::clear_schema() {
  schema_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DocumentProto::schema() const {
  // @@protoc_insertion_point(field_get:icing.lib.DocumentProto.schema)
  return schema_.GetNoArena();
}
inline void DocumentProto::set_schema(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  schema_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:icing.lib.DocumentProto.schema)
}
inline void DocumentProto::set_schema(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  schema_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:icing.lib.DocumentProto.schema)
}
inline void DocumentProto::set_schema(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  schema_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:icing.lib.DocumentProto.schema)
}
inline void DocumentProto::set_schema(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  schema_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:icing.lib.DocumentProto.schema)
}
inline std::string* DocumentProto::mutable_schema() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:icing.lib.DocumentProto.schema)
  return schema_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DocumentProto::release_schema() {
  // @@protoc_insertion_point(field_release:icing.lib.DocumentProto.schema)
  if (!has_schema()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return schema_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DocumentProto::set_allocated_schema(std::string* schema) {
  if (schema != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  schema_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), schema);
  // @@protoc_insertion_point(field_set_allocated:icing.lib.DocumentProto.schema)
}

// optional int64 creation_timestamp_ms = 4;
inline bool DocumentProto::has_creation_timestamp_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DocumentProto::clear_creation_timestamp_ms() {
  creation_timestamp_ms_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DocumentProto::creation_timestamp_ms() const {
  // @@protoc_insertion_point(field_get:icing.lib.DocumentProto.creation_timestamp_ms)
  return creation_timestamp_ms_;
}
inline void DocumentProto::set_creation_timestamp_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  creation_timestamp_ms_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.DocumentProto.creation_timestamp_ms)
}

// repeated .icing.lib.PropertyProto properties = 5;
inline int DocumentProto::properties_size() const {
  return properties_.size();
}
inline void DocumentProto::clear_properties() {
  properties_.Clear();
}
inline ::icing::lib::PropertyProto* DocumentProto::mutable_properties(int index) {
  // @@protoc_insertion_point(field_mutable:icing.lib.DocumentProto.properties)
  return properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::PropertyProto >*
DocumentProto::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.DocumentProto.properties)
  return &properties_;
}
inline const ::icing::lib::PropertyProto& DocumentProto::properties(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.DocumentProto.properties)
  return properties_.Get(index);
}
inline ::icing::lib::PropertyProto* DocumentProto::add_properties() {
  // @@protoc_insertion_point(field_add:icing.lib.DocumentProto.properties)
  return properties_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::PropertyProto >&
DocumentProto::properties() const {
  // @@protoc_insertion_point(field_list:icing.lib.DocumentProto.properties)
  return properties_;
}

// optional int32 score = 7 [default = 0];
inline bool DocumentProto::has_score() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DocumentProto::clear_score() {
  score_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DocumentProto::score() const {
  // @@protoc_insertion_point(field_get:icing.lib.DocumentProto.score)
  return score_;
}
inline void DocumentProto::set_score(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  score_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.DocumentProto.score)
}

// optional int64 ttl_ms = 8 [default = 0];
inline bool DocumentProto::has_ttl_ms() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DocumentProto::clear_ttl_ms() {
  ttl_ms_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DocumentProto::ttl_ms() const {
  // @@protoc_insertion_point(field_get:icing.lib.DocumentProto.ttl_ms)
  return ttl_ms_;
}
inline void DocumentProto::set_ttl_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  ttl_ms_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.DocumentProto.ttl_ms)
}

// optional .icing.lib.DocumentProto.InternalFields internal_fields = 9;
inline bool DocumentProto::has_internal_fields() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DocumentProto::clear_internal_fields() {
  if (internal_fields_ != nullptr) internal_fields_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::icing::lib::DocumentProto_InternalFields& DocumentProto::internal_fields() const {
  const ::icing::lib::DocumentProto_InternalFields* p = internal_fields_;
  // @@protoc_insertion_point(field_get:icing.lib.DocumentProto.internal_fields)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::DocumentProto_InternalFields*>(
      &::icing::lib::_DocumentProto_InternalFields_default_instance_);
}
inline ::icing::lib::DocumentProto_InternalFields* DocumentProto::release_internal_fields() {
  // @@protoc_insertion_point(field_release:icing.lib.DocumentProto.internal_fields)
  _has_bits_[0] &= ~0x00000008u;
  ::icing::lib::DocumentProto_InternalFields* temp = internal_fields_;
  internal_fields_ = nullptr;
  return temp;
}
inline ::icing::lib::DocumentProto_InternalFields* DocumentProto::mutable_internal_fields() {
  _has_bits_[0] |= 0x00000008u;
  if (internal_fields_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::DocumentProto_InternalFields>(GetArenaNoVirtual());
    internal_fields_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.DocumentProto.internal_fields)
  return internal_fields_;
}
inline void DocumentProto::set_allocated_internal_fields(::icing::lib::DocumentProto_InternalFields* internal_fields) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete internal_fields_;
  }
  if (internal_fields) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      internal_fields = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, internal_fields, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  internal_fields_ = internal_fields;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.DocumentProto.internal_fields)
}

// -------------------------------------------------------------------

// PropertyProto

// optional string name = 1;
inline bool PropertyProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PropertyProto::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PropertyProto::name() const {
  // @@protoc_insertion_point(field_get:icing.lib.PropertyProto.name)
  return name_.GetNoArena();
}
inline void PropertyProto::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:icing.lib.PropertyProto.name)
}
inline void PropertyProto::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:icing.lib.PropertyProto.name)
}
inline void PropertyProto::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:icing.lib.PropertyProto.name)
}
inline void PropertyProto::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:icing.lib.PropertyProto.name)
}
inline std::string* PropertyProto::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:icing.lib.PropertyProto.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PropertyProto::release_name() {
  // @@protoc_insertion_point(field_release:icing.lib.PropertyProto.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PropertyProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:icing.lib.PropertyProto.name)
}

// repeated string string_values = 2;
inline int PropertyProto::string_values_size() const {
  return string_values_.size();
}
inline void PropertyProto::clear_string_values() {
  string_values_.Clear();
}
inline const std::string& PropertyProto::string_values(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.PropertyProto.string_values)
  return string_values_.Get(index);
}
inline std::string* PropertyProto::mutable_string_values(int index) {
  // @@protoc_insertion_point(field_mutable:icing.lib.PropertyProto.string_values)
  return string_values_.Mutable(index);
}
inline void PropertyProto::set_string_values(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:icing.lib.PropertyProto.string_values)
  string_values_.Mutable(index)->assign(value);
}
inline void PropertyProto::set_string_values(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:icing.lib.PropertyProto.string_values)
  string_values_.Mutable(index)->assign(std::move(value));
}
inline void PropertyProto::set_string_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  string_values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:icing.lib.PropertyProto.string_values)
}
inline void PropertyProto::set_string_values(int index, const char* value, size_t size) {
  string_values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:icing.lib.PropertyProto.string_values)
}
inline std::string* PropertyProto::add_string_values() {
  // @@protoc_insertion_point(field_add_mutable:icing.lib.PropertyProto.string_values)
  return string_values_.Add();
}
inline void PropertyProto::add_string_values(const std::string& value) {
  string_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:icing.lib.PropertyProto.string_values)
}
inline void PropertyProto::add_string_values(std::string&& value) {
  string_values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:icing.lib.PropertyProto.string_values)
}
inline void PropertyProto::add_string_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  string_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:icing.lib.PropertyProto.string_values)
}
inline void PropertyProto::add_string_values(const char* value, size_t size) {
  string_values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:icing.lib.PropertyProto.string_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PropertyProto::string_values() const {
  // @@protoc_insertion_point(field_list:icing.lib.PropertyProto.string_values)
  return string_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PropertyProto::mutable_string_values() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.PropertyProto.string_values)
  return &string_values_;
}

// repeated int64 int64_values = 3;
inline int PropertyProto::int64_values_size() const {
  return int64_values_.size();
}
inline void PropertyProto::clear_int64_values() {
  int64_values_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PropertyProto::int64_values(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.PropertyProto.int64_values)
  return int64_values_.Get(index);
}
inline void PropertyProto::set_int64_values(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  int64_values_.Set(index, value);
  // @@protoc_insertion_point(field_set:icing.lib.PropertyProto.int64_values)
}
inline void PropertyProto::add_int64_values(::PROTOBUF_NAMESPACE_ID::int64 value) {
  int64_values_.Add(value);
  // @@protoc_insertion_point(field_add:icing.lib.PropertyProto.int64_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
PropertyProto::int64_values() const {
  // @@protoc_insertion_point(field_list:icing.lib.PropertyProto.int64_values)
  return int64_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
PropertyProto::mutable_int64_values() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.PropertyProto.int64_values)
  return &int64_values_;
}

// repeated double double_values = 4;
inline int PropertyProto::double_values_size() const {
  return double_values_.size();
}
inline void PropertyProto::clear_double_values() {
  double_values_.Clear();
}
inline double PropertyProto::double_values(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.PropertyProto.double_values)
  return double_values_.Get(index);
}
inline void PropertyProto::set_double_values(int index, double value) {
  double_values_.Set(index, value);
  // @@protoc_insertion_point(field_set:icing.lib.PropertyProto.double_values)
}
inline void PropertyProto::add_double_values(double value) {
  double_values_.Add(value);
  // @@protoc_insertion_point(field_add:icing.lib.PropertyProto.double_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
PropertyProto::double_values() const {
  // @@protoc_insertion_point(field_list:icing.lib.PropertyProto.double_values)
  return double_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
PropertyProto::mutable_double_values() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.PropertyProto.double_values)
  return &double_values_;
}

// repeated bool boolean_values = 5;
inline int PropertyProto::boolean_values_size() const {
  return boolean_values_.size();
}
inline void PropertyProto::clear_boolean_values() {
  boolean_values_.Clear();
}
inline bool PropertyProto::boolean_values(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.PropertyProto.boolean_values)
  return boolean_values_.Get(index);
}
inline void PropertyProto::set_boolean_values(int index, bool value) {
  boolean_values_.Set(index, value);
  // @@protoc_insertion_point(field_set:icing.lib.PropertyProto.boolean_values)
}
inline void PropertyProto::add_boolean_values(bool value) {
  boolean_values_.Add(value);
  // @@protoc_insertion_point(field_add:icing.lib.PropertyProto.boolean_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
PropertyProto::boolean_values() const {
  // @@protoc_insertion_point(field_list:icing.lib.PropertyProto.boolean_values)
  return boolean_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
PropertyProto::mutable_boolean_values() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.PropertyProto.boolean_values)
  return &boolean_values_;
}

// repeated bytes bytes_values = 6;
inline int PropertyProto::bytes_values_size() const {
  return bytes_values_.size();
}
inline void PropertyProto::clear_bytes_values() {
  bytes_values_.Clear();
}
inline const std::string& PropertyProto::bytes_values(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.PropertyProto.bytes_values)
  return bytes_values_.Get(index);
}
inline std::string* PropertyProto::mutable_bytes_values(int index) {
  // @@protoc_insertion_point(field_mutable:icing.lib.PropertyProto.bytes_values)
  return bytes_values_.Mutable(index);
}
inline void PropertyProto::set_bytes_values(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:icing.lib.PropertyProto.bytes_values)
  bytes_values_.Mutable(index)->assign(value);
}
inline void PropertyProto::set_bytes_values(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:icing.lib.PropertyProto.bytes_values)
  bytes_values_.Mutable(index)->assign(std::move(value));
}
inline void PropertyProto::set_bytes_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  bytes_values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:icing.lib.PropertyProto.bytes_values)
}
inline void PropertyProto::set_bytes_values(int index, const void* value, size_t size) {
  bytes_values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:icing.lib.PropertyProto.bytes_values)
}
inline std::string* PropertyProto::add_bytes_values() {
  // @@protoc_insertion_point(field_add_mutable:icing.lib.PropertyProto.bytes_values)
  return bytes_values_.Add();
}
inline void PropertyProto::add_bytes_values(const std::string& value) {
  bytes_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:icing.lib.PropertyProto.bytes_values)
}
inline void PropertyProto::add_bytes_values(std::string&& value) {
  bytes_values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:icing.lib.PropertyProto.bytes_values)
}
inline void PropertyProto::add_bytes_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  bytes_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:icing.lib.PropertyProto.bytes_values)
}
inline void PropertyProto::add_bytes_values(const void* value, size_t size) {
  bytes_values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:icing.lib.PropertyProto.bytes_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PropertyProto::bytes_values() const {
  // @@protoc_insertion_point(field_list:icing.lib.PropertyProto.bytes_values)
  return bytes_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PropertyProto::mutable_bytes_values() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.PropertyProto.bytes_values)
  return &bytes_values_;
}

// repeated .icing.lib.DocumentProto document_values = 7;
inline int PropertyProto::document_values_size() const {
  return document_values_.size();
}
inline void PropertyProto::clear_document_values() {
  document_values_.Clear();
}
inline ::icing::lib::DocumentProto* PropertyProto::mutable_document_values(int index) {
  // @@protoc_insertion_point(field_mutable:icing.lib.PropertyProto.document_values)
  return document_values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::DocumentProto >*
PropertyProto::mutable_document_values() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.PropertyProto.document_values)
  return &document_values_;
}
inline const ::icing::lib::DocumentProto& PropertyProto::document_values(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.PropertyProto.document_values)
  return document_values_.Get(index);
}
inline ::icing::lib::DocumentProto* PropertyProto::add_document_values() {
  // @@protoc_insertion_point(field_add:icing.lib.PropertyProto.document_values)
  return document_values_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::DocumentProto >&
PropertyProto::document_values() const {
  // @@protoc_insertion_point(field_list:icing.lib.PropertyProto.document_values)
  return document_values_;
}

// -------------------------------------------------------------------

// PutResultProto

// optional .icing.lib.StatusProto status = 1;
inline bool PutResultProto::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::icing::lib::StatusProto& PutResultProto::status() const {
  const ::icing::lib::StatusProto* p = status_;
  // @@protoc_insertion_point(field_get:icing.lib.PutResultProto.status)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::StatusProto*>(
      &::icing::lib::_StatusProto_default_instance_);
}
inline ::icing::lib::StatusProto* PutResultProto::release_status() {
  // @@protoc_insertion_point(field_release:icing.lib.PutResultProto.status)
  _has_bits_[0] &= ~0x00000001u;
  ::icing::lib::StatusProto* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::icing::lib::StatusProto* PutResultProto::mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::StatusProto>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.PutResultProto.status)
  return status_;
}
inline void PutResultProto::set_allocated_status(::icing::lib::StatusProto* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.PutResultProto.status)
}

// optional .icing.lib.PutDocumentStatsProto put_document_stats = 2;
inline bool PutResultProto::has_put_document_stats() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::icing::lib::PutDocumentStatsProto& PutResultProto::put_document_stats() const {
  const ::icing::lib::PutDocumentStatsProto* p = put_document_stats_;
  // @@protoc_insertion_point(field_get:icing.lib.PutResultProto.put_document_stats)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::PutDocumentStatsProto*>(
      &::icing::lib::_PutDocumentStatsProto_default_instance_);
}
inline ::icing::lib::PutDocumentStatsProto* PutResultProto::release_put_document_stats() {
  // @@protoc_insertion_point(field_release:icing.lib.PutResultProto.put_document_stats)
  _has_bits_[0] &= ~0x00000002u;
  ::icing::lib::PutDocumentStatsProto* temp = put_document_stats_;
  put_document_stats_ = nullptr;
  return temp;
}
inline ::icing::lib::PutDocumentStatsProto* PutResultProto::mutable_put_document_stats() {
  _has_bits_[0] |= 0x00000002u;
  if (put_document_stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::PutDocumentStatsProto>(GetArenaNoVirtual());
    put_document_stats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.PutResultProto.put_document_stats)
  return put_document_stats_;
}
inline void PutResultProto::set_allocated_put_document_stats(::icing::lib::PutDocumentStatsProto* put_document_stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(put_document_stats_);
  }
  if (put_document_stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      put_document_stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, put_document_stats, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  put_document_stats_ = put_document_stats;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.PutResultProto.put_document_stats)
}

// -------------------------------------------------------------------

// GetResultProto

// optional .icing.lib.StatusProto status = 1;
inline bool GetResultProto::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::icing::lib::StatusProto& GetResultProto::status() const {
  const ::icing::lib::StatusProto* p = status_;
  // @@protoc_insertion_point(field_get:icing.lib.GetResultProto.status)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::StatusProto*>(
      &::icing::lib::_StatusProto_default_instance_);
}
inline ::icing::lib::StatusProto* GetResultProto::release_status() {
  // @@protoc_insertion_point(field_release:icing.lib.GetResultProto.status)
  _has_bits_[0] &= ~0x00000001u;
  ::icing::lib::StatusProto* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::icing::lib::StatusProto* GetResultProto::mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::StatusProto>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.GetResultProto.status)
  return status_;
}
inline void GetResultProto::set_allocated_status(::icing::lib::StatusProto* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.GetResultProto.status)
}

// optional .icing.lib.DocumentProto document = 2;
inline bool GetResultProto::has_document() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetResultProto::clear_document() {
  if (document_ != nullptr) document_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::icing::lib::DocumentProto& GetResultProto::document() const {
  const ::icing::lib::DocumentProto* p = document_;
  // @@protoc_insertion_point(field_get:icing.lib.GetResultProto.document)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::DocumentProto*>(
      &::icing::lib::_DocumentProto_default_instance_);
}
inline ::icing::lib::DocumentProto* GetResultProto::release_document() {
  // @@protoc_insertion_point(field_release:icing.lib.GetResultProto.document)
  _has_bits_[0] &= ~0x00000002u;
  ::icing::lib::DocumentProto* temp = document_;
  document_ = nullptr;
  return temp;
}
inline ::icing::lib::DocumentProto* GetResultProto::mutable_document() {
  _has_bits_[0] |= 0x00000002u;
  if (document_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::DocumentProto>(GetArenaNoVirtual());
    document_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.GetResultProto.document)
  return document_;
}
inline void GetResultProto::set_allocated_document(::icing::lib::DocumentProto* document) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete document_;
  }
  if (document) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      document = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, document, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  document_ = document;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.GetResultProto.document)
}

// -------------------------------------------------------------------

// GetAllNamespacesResultProto

// optional .icing.lib.StatusProto status = 1;
inline bool GetAllNamespacesResultProto::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::icing::lib::StatusProto& GetAllNamespacesResultProto::status() const {
  const ::icing::lib::StatusProto* p = status_;
  // @@protoc_insertion_point(field_get:icing.lib.GetAllNamespacesResultProto.status)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::StatusProto*>(
      &::icing::lib::_StatusProto_default_instance_);
}
inline ::icing::lib::StatusProto* GetAllNamespacesResultProto::release_status() {
  // @@protoc_insertion_point(field_release:icing.lib.GetAllNamespacesResultProto.status)
  _has_bits_[0] &= ~0x00000001u;
  ::icing::lib::StatusProto* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::icing::lib::StatusProto* GetAllNamespacesResultProto::mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::StatusProto>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.GetAllNamespacesResultProto.status)
  return status_;
}
inline void GetAllNamespacesResultProto::set_allocated_status(::icing::lib::StatusProto* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.GetAllNamespacesResultProto.status)
}

// repeated string namespaces = 2;
inline int GetAllNamespacesResultProto::namespaces_size() const {
  return namespaces_.size();
}
inline void GetAllNamespacesResultProto::clear_namespaces() {
  namespaces_.Clear();
}
inline const std::string& GetAllNamespacesResultProto::namespaces(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.GetAllNamespacesResultProto.namespaces)
  return namespaces_.Get(index);
}
inline std::string* GetAllNamespacesResultProto::mutable_namespaces(int index) {
  // @@protoc_insertion_point(field_mutable:icing.lib.GetAllNamespacesResultProto.namespaces)
  return namespaces_.Mutable(index);
}
inline void GetAllNamespacesResultProto::set_namespaces(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:icing.lib.GetAllNamespacesResultProto.namespaces)
  namespaces_.Mutable(index)->assign(value);
}
inline void GetAllNamespacesResultProto::set_namespaces(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:icing.lib.GetAllNamespacesResultProto.namespaces)
  namespaces_.Mutable(index)->assign(std::move(value));
}
inline void GetAllNamespacesResultProto::set_namespaces(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  namespaces_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:icing.lib.GetAllNamespacesResultProto.namespaces)
}
inline void GetAllNamespacesResultProto::set_namespaces(int index, const char* value, size_t size) {
  namespaces_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:icing.lib.GetAllNamespacesResultProto.namespaces)
}
inline std::string* GetAllNamespacesResultProto::add_namespaces() {
  // @@protoc_insertion_point(field_add_mutable:icing.lib.GetAllNamespacesResultProto.namespaces)
  return namespaces_.Add();
}
inline void GetAllNamespacesResultProto::add_namespaces(const std::string& value) {
  namespaces_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:icing.lib.GetAllNamespacesResultProto.namespaces)
}
inline void GetAllNamespacesResultProto::add_namespaces(std::string&& value) {
  namespaces_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:icing.lib.GetAllNamespacesResultProto.namespaces)
}
inline void GetAllNamespacesResultProto::add_namespaces(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  namespaces_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:icing.lib.GetAllNamespacesResultProto.namespaces)
}
inline void GetAllNamespacesResultProto::add_namespaces(const char* value, size_t size) {
  namespaces_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:icing.lib.GetAllNamespacesResultProto.namespaces)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetAllNamespacesResultProto::namespaces() const {
  // @@protoc_insertion_point(field_list:icing.lib.GetAllNamespacesResultProto.namespaces)
  return namespaces_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetAllNamespacesResultProto::mutable_namespaces() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.GetAllNamespacesResultProto.namespaces)
  return &namespaces_;
}

// -------------------------------------------------------------------

// DeleteResultProto

// optional .icing.lib.StatusProto status = 1;
inline bool DeleteResultProto::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::icing::lib::StatusProto& DeleteResultProto::status() const {
  const ::icing::lib::StatusProto* p = status_;
  // @@protoc_insertion_point(field_get:icing.lib.DeleteResultProto.status)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::StatusProto*>(
      &::icing::lib::_StatusProto_default_instance_);
}
inline ::icing::lib::StatusProto* DeleteResultProto::release_status() {
  // @@protoc_insertion_point(field_release:icing.lib.DeleteResultProto.status)
  _has_bits_[0] &= ~0x00000001u;
  ::icing::lib::StatusProto* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::icing::lib::StatusProto* DeleteResultProto::mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::StatusProto>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.DeleteResultProto.status)
  return status_;
}
inline void DeleteResultProto::set_allocated_status(::icing::lib::StatusProto* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.DeleteResultProto.status)
}

// optional .icing.lib.DeleteStatsProto delete_stats = 2;
inline bool DeleteResultProto::has_delete_stats() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::icing::lib::DeleteStatsProto& DeleteResultProto::delete_stats() const {
  const ::icing::lib::DeleteStatsProto* p = delete_stats_;
  // @@protoc_insertion_point(field_get:icing.lib.DeleteResultProto.delete_stats)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::DeleteStatsProto*>(
      &::icing::lib::_DeleteStatsProto_default_instance_);
}
inline ::icing::lib::DeleteStatsProto* DeleteResultProto::release_delete_stats() {
  // @@protoc_insertion_point(field_release:icing.lib.DeleteResultProto.delete_stats)
  _has_bits_[0] &= ~0x00000002u;
  ::icing::lib::DeleteStatsProto* temp = delete_stats_;
  delete_stats_ = nullptr;
  return temp;
}
inline ::icing::lib::DeleteStatsProto* DeleteResultProto::mutable_delete_stats() {
  _has_bits_[0] |= 0x00000002u;
  if (delete_stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::DeleteStatsProto>(GetArenaNoVirtual());
    delete_stats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.DeleteResultProto.delete_stats)
  return delete_stats_;
}
inline void DeleteResultProto::set_allocated_delete_stats(::icing::lib::DeleteStatsProto* delete_stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(delete_stats_);
  }
  if (delete_stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      delete_stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, delete_stats, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  delete_stats_ = delete_stats;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.DeleteResultProto.delete_stats)
}

// -------------------------------------------------------------------

// DeleteByNamespaceResultProto

// optional .icing.lib.StatusProto status = 1;
inline bool DeleteByNamespaceResultProto::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::icing::lib::StatusProto& DeleteByNamespaceResultProto::status() const {
  const ::icing::lib::StatusProto* p = status_;
  // @@protoc_insertion_point(field_get:icing.lib.DeleteByNamespaceResultProto.status)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::StatusProto*>(
      &::icing::lib::_StatusProto_default_instance_);
}
inline ::icing::lib::StatusProto* DeleteByNamespaceResultProto::release_status() {
  // @@protoc_insertion_point(field_release:icing.lib.DeleteByNamespaceResultProto.status)
  _has_bits_[0] &= ~0x00000001u;
  ::icing::lib::StatusProto* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::icing::lib::StatusProto* DeleteByNamespaceResultProto::mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::StatusProto>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.DeleteByNamespaceResultProto.status)
  return status_;
}
inline void DeleteByNamespaceResultProto::set_allocated_status(::icing::lib::StatusProto* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.DeleteByNamespaceResultProto.status)
}

// optional .icing.lib.DeleteStatsProto delete_stats = 2;
inline bool DeleteByNamespaceResultProto::has_delete_stats() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::icing::lib::DeleteStatsProto& DeleteByNamespaceResultProto::delete_stats() const {
  const ::icing::lib::DeleteStatsProto* p = delete_stats_;
  // @@protoc_insertion_point(field_get:icing.lib.DeleteByNamespaceResultProto.delete_stats)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::DeleteStatsProto*>(
      &::icing::lib::_DeleteStatsProto_default_instance_);
}
inline ::icing::lib::DeleteStatsProto* DeleteByNamespaceResultProto::release_delete_stats() {
  // @@protoc_insertion_point(field_release:icing.lib.DeleteByNamespaceResultProto.delete_stats)
  _has_bits_[0] &= ~0x00000002u;
  ::icing::lib::DeleteStatsProto* temp = delete_stats_;
  delete_stats_ = nullptr;
  return temp;
}
inline ::icing::lib::DeleteStatsProto* DeleteByNamespaceResultProto::mutable_delete_stats() {
  _has_bits_[0] |= 0x00000002u;
  if (delete_stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::DeleteStatsProto>(GetArenaNoVirtual());
    delete_stats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.DeleteByNamespaceResultProto.delete_stats)
  return delete_stats_;
}
inline void DeleteByNamespaceResultProto::set_allocated_delete_stats(::icing::lib::DeleteStatsProto* delete_stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(delete_stats_);
  }
  if (delete_stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      delete_stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, delete_stats, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  delete_stats_ = delete_stats;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.DeleteByNamespaceResultProto.delete_stats)
}

// -------------------------------------------------------------------

// DeleteBySchemaTypeResultProto

// optional .icing.lib.StatusProto status = 1;
inline bool DeleteBySchemaTypeResultProto::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::icing::lib::StatusProto& DeleteBySchemaTypeResultProto::status() const {
  const ::icing::lib::StatusProto* p = status_;
  // @@protoc_insertion_point(field_get:icing.lib.DeleteBySchemaTypeResultProto.status)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::StatusProto*>(
      &::icing::lib::_StatusProto_default_instance_);
}
inline ::icing::lib::StatusProto* DeleteBySchemaTypeResultProto::release_status() {
  // @@protoc_insertion_point(field_release:icing.lib.DeleteBySchemaTypeResultProto.status)
  _has_bits_[0] &= ~0x00000001u;
  ::icing::lib::StatusProto* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::icing::lib::StatusProto* DeleteBySchemaTypeResultProto::mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::StatusProto>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.DeleteBySchemaTypeResultProto.status)
  return status_;
}
inline void DeleteBySchemaTypeResultProto::set_allocated_status(::icing::lib::StatusProto* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.DeleteBySchemaTypeResultProto.status)
}

// optional .icing.lib.DeleteStatsProto delete_stats = 2;
inline bool DeleteBySchemaTypeResultProto::has_delete_stats() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::icing::lib::DeleteStatsProto& DeleteBySchemaTypeResultProto::delete_stats() const {
  const ::icing::lib::DeleteStatsProto* p = delete_stats_;
  // @@protoc_insertion_point(field_get:icing.lib.DeleteBySchemaTypeResultProto.delete_stats)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::DeleteStatsProto*>(
      &::icing::lib::_DeleteStatsProto_default_instance_);
}
inline ::icing::lib::DeleteStatsProto* DeleteBySchemaTypeResultProto::release_delete_stats() {
  // @@protoc_insertion_point(field_release:icing.lib.DeleteBySchemaTypeResultProto.delete_stats)
  _has_bits_[0] &= ~0x00000002u;
  ::icing::lib::DeleteStatsProto* temp = delete_stats_;
  delete_stats_ = nullptr;
  return temp;
}
inline ::icing::lib::DeleteStatsProto* DeleteBySchemaTypeResultProto::mutable_delete_stats() {
  _has_bits_[0] |= 0x00000002u;
  if (delete_stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::DeleteStatsProto>(GetArenaNoVirtual());
    delete_stats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.DeleteBySchemaTypeResultProto.delete_stats)
  return delete_stats_;
}
inline void DeleteBySchemaTypeResultProto::set_allocated_delete_stats(::icing::lib::DeleteStatsProto* delete_stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(delete_stats_);
  }
  if (delete_stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      delete_stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, delete_stats, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  delete_stats_ = delete_stats;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.DeleteBySchemaTypeResultProto.delete_stats)
}

// -------------------------------------------------------------------

// DeleteByQueryResultProto

// optional .icing.lib.StatusProto status = 1;
inline bool DeleteByQueryResultProto::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::icing::lib::StatusProto& DeleteByQueryResultProto::status() const {
  const ::icing::lib::StatusProto* p = status_;
  // @@protoc_insertion_point(field_get:icing.lib.DeleteByQueryResultProto.status)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::StatusProto*>(
      &::icing::lib::_StatusProto_default_instance_);
}
inline ::icing::lib::StatusProto* DeleteByQueryResultProto::release_status() {
  // @@protoc_insertion_point(field_release:icing.lib.DeleteByQueryResultProto.status)
  _has_bits_[0] &= ~0x00000001u;
  ::icing::lib::StatusProto* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::icing::lib::StatusProto* DeleteByQueryResultProto::mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::StatusProto>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.DeleteByQueryResultProto.status)
  return status_;
}
inline void DeleteByQueryResultProto::set_allocated_status(::icing::lib::StatusProto* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.DeleteByQueryResultProto.status)
}

// optional .icing.lib.DeleteByQueryStatsProto delete_by_query_stats = 3;
inline bool DeleteByQueryResultProto::has_delete_by_query_stats() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::icing::lib::DeleteByQueryStatsProto& DeleteByQueryResultProto::delete_by_query_stats() const {
  const ::icing::lib::DeleteByQueryStatsProto* p = delete_by_query_stats_;
  // @@protoc_insertion_point(field_get:icing.lib.DeleteByQueryResultProto.delete_by_query_stats)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::DeleteByQueryStatsProto*>(
      &::icing::lib::_DeleteByQueryStatsProto_default_instance_);
}
inline ::icing::lib::DeleteByQueryStatsProto* DeleteByQueryResultProto::release_delete_by_query_stats() {
  // @@protoc_insertion_point(field_release:icing.lib.DeleteByQueryResultProto.delete_by_query_stats)
  _has_bits_[0] &= ~0x00000002u;
  ::icing::lib::DeleteByQueryStatsProto* temp = delete_by_query_stats_;
  delete_by_query_stats_ = nullptr;
  return temp;
}
inline ::icing::lib::DeleteByQueryStatsProto* DeleteByQueryResultProto::mutable_delete_by_query_stats() {
  _has_bits_[0] |= 0x00000002u;
  if (delete_by_query_stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::DeleteByQueryStatsProto>(GetArenaNoVirtual());
    delete_by_query_stats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.DeleteByQueryResultProto.delete_by_query_stats)
  return delete_by_query_stats_;
}
inline void DeleteByQueryResultProto::set_allocated_delete_by_query_stats(::icing::lib::DeleteByQueryStatsProto* delete_by_query_stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(delete_by_query_stats_);
  }
  if (delete_by_query_stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      delete_by_query_stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, delete_by_query_stats, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  delete_by_query_stats_ = delete_by_query_stats;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.DeleteByQueryResultProto.delete_by_query_stats)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace lib
}  // namespace icing

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_icing_2fproto_2fdocument_2eproto
