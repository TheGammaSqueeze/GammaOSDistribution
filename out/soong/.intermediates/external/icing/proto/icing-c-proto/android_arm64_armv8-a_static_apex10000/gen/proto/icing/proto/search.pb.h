// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: icing/proto/search.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_icing_2fproto_2fsearch_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_icing_2fproto_2fsearch_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "icing/proto/document.pb.h"
#include "icing/proto/logging.pb.h"
#include "icing/proto/status.pb.h"
#include "icing/proto/term.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_icing_2fproto_2fsearch_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_icing_2fproto_2fsearch_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace icing {
namespace lib {
class GetResultSpecProto;
class GetResultSpecProtoDefaultTypeInternal;
extern GetResultSpecProtoDefaultTypeInternal _GetResultSpecProto_default_instance_;
class ResultSpecProto;
class ResultSpecProtoDefaultTypeInternal;
extern ResultSpecProtoDefaultTypeInternal _ResultSpecProto_default_instance_;
class ResultSpecProto_ResultGrouping;
class ResultSpecProto_ResultGroupingDefaultTypeInternal;
extern ResultSpecProto_ResultGroupingDefaultTypeInternal _ResultSpecProto_ResultGrouping_default_instance_;
class ResultSpecProto_SnippetSpecProto;
class ResultSpecProto_SnippetSpecProtoDefaultTypeInternal;
extern ResultSpecProto_SnippetSpecProtoDefaultTypeInternal _ResultSpecProto_SnippetSpecProto_default_instance_;
class SearchResultProto;
class SearchResultProtoDefaultTypeInternal;
extern SearchResultProtoDefaultTypeInternal _SearchResultProto_default_instance_;
class SearchResultProto_DebugInfoProto;
class SearchResultProto_DebugInfoProtoDefaultTypeInternal;
extern SearchResultProto_DebugInfoProtoDefaultTypeInternal _SearchResultProto_DebugInfoProto_default_instance_;
class SearchResultProto_ResultProto;
class SearchResultProto_ResultProtoDefaultTypeInternal;
extern SearchResultProto_ResultProtoDefaultTypeInternal _SearchResultProto_ResultProto_default_instance_;
class SearchSpecProto;
class SearchSpecProtoDefaultTypeInternal;
extern SearchSpecProtoDefaultTypeInternal _SearchSpecProto_default_instance_;
class SnippetMatchProto;
class SnippetMatchProtoDefaultTypeInternal;
extern SnippetMatchProtoDefaultTypeInternal _SnippetMatchProto_default_instance_;
class SnippetProto;
class SnippetProtoDefaultTypeInternal;
extern SnippetProtoDefaultTypeInternal _SnippetProto_default_instance_;
class SnippetProto_EntryProto;
class SnippetProto_EntryProtoDefaultTypeInternal;
extern SnippetProto_EntryProtoDefaultTypeInternal _SnippetProto_EntryProto_default_instance_;
class TypePropertyMask;
class TypePropertyMaskDefaultTypeInternal;
extern TypePropertyMaskDefaultTypeInternal _TypePropertyMask_default_instance_;
}  // namespace lib
}  // namespace icing
PROTOBUF_NAMESPACE_OPEN
template<> ::icing::lib::GetResultSpecProto* Arena::CreateMaybeMessage<::icing::lib::GetResultSpecProto>(Arena*);
template<> ::icing::lib::ResultSpecProto* Arena::CreateMaybeMessage<::icing::lib::ResultSpecProto>(Arena*);
template<> ::icing::lib::ResultSpecProto_ResultGrouping* Arena::CreateMaybeMessage<::icing::lib::ResultSpecProto_ResultGrouping>(Arena*);
template<> ::icing::lib::ResultSpecProto_SnippetSpecProto* Arena::CreateMaybeMessage<::icing::lib::ResultSpecProto_SnippetSpecProto>(Arena*);
template<> ::icing::lib::SearchResultProto* Arena::CreateMaybeMessage<::icing::lib::SearchResultProto>(Arena*);
template<> ::icing::lib::SearchResultProto_DebugInfoProto* Arena::CreateMaybeMessage<::icing::lib::SearchResultProto_DebugInfoProto>(Arena*);
template<> ::icing::lib::SearchResultProto_ResultProto* Arena::CreateMaybeMessage<::icing::lib::SearchResultProto_ResultProto>(Arena*);
template<> ::icing::lib::SearchSpecProto* Arena::CreateMaybeMessage<::icing::lib::SearchSpecProto>(Arena*);
template<> ::icing::lib::SnippetMatchProto* Arena::CreateMaybeMessage<::icing::lib::SnippetMatchProto>(Arena*);
template<> ::icing::lib::SnippetProto* Arena::CreateMaybeMessage<::icing::lib::SnippetProto>(Arena*);
template<> ::icing::lib::SnippetProto_EntryProto* Arena::CreateMaybeMessage<::icing::lib::SnippetProto_EntryProto>(Arena*);
template<> ::icing::lib::TypePropertyMask* Arena::CreateMaybeMessage<::icing::lib::TypePropertyMask>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace icing {
namespace lib {

// ===================================================================

class SearchSpecProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.SearchSpecProto) */ {
 public:
  SearchSpecProto();
  virtual ~SearchSpecProto();

  SearchSpecProto(const SearchSpecProto& from);
  SearchSpecProto(SearchSpecProto&& from) noexcept
    : SearchSpecProto() {
    *this = ::std::move(from);
  }

  inline SearchSpecProto& operator=(const SearchSpecProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchSpecProto& operator=(SearchSpecProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SearchSpecProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SearchSpecProto* internal_default_instance() {
    return reinterpret_cast<const SearchSpecProto*>(
               &_SearchSpecProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SearchSpecProto& a, SearchSpecProto& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchSpecProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SearchSpecProto* New() const final {
    return CreateMaybeMessage<SearchSpecProto>(nullptr);
  }

  SearchSpecProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SearchSpecProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SearchSpecProto& from);
  void MergeFrom(const SearchSpecProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SearchSpecProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.SearchSpecProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceFiltersFieldNumber = 3,
    kSchemaTypeFiltersFieldNumber = 4,
    kQueryFieldNumber = 1,
    kTermMatchTypeFieldNumber = 2,
  };
  // repeated string namespace_filters = 3;
  int namespace_filters_size() const;
  void clear_namespace_filters();
  const std::string& namespace_filters(int index) const;
  std::string* mutable_namespace_filters(int index);
  void set_namespace_filters(int index, const std::string& value);
  void set_namespace_filters(int index, std::string&& value);
  void set_namespace_filters(int index, const char* value);
  void set_namespace_filters(int index, const char* value, size_t size);
  std::string* add_namespace_filters();
  void add_namespace_filters(const std::string& value);
  void add_namespace_filters(std::string&& value);
  void add_namespace_filters(const char* value);
  void add_namespace_filters(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& namespace_filters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_namespace_filters();

  // repeated string schema_type_filters = 4;
  int schema_type_filters_size() const;
  void clear_schema_type_filters();
  const std::string& schema_type_filters(int index) const;
  std::string* mutable_schema_type_filters(int index);
  void set_schema_type_filters(int index, const std::string& value);
  void set_schema_type_filters(int index, std::string&& value);
  void set_schema_type_filters(int index, const char* value);
  void set_schema_type_filters(int index, const char* value, size_t size);
  std::string* add_schema_type_filters();
  void add_schema_type_filters(const std::string& value);
  void add_schema_type_filters(std::string&& value);
  void add_schema_type_filters(const char* value);
  void add_schema_type_filters(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& schema_type_filters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_schema_type_filters();

  // optional string query = 1;
  bool has_query() const;
  void clear_query();
  const std::string& query() const;
  void set_query(const std::string& value);
  void set_query(std::string&& value);
  void set_query(const char* value);
  void set_query(const char* value, size_t size);
  std::string* mutable_query();
  std::string* release_query();
  void set_allocated_query(std::string* query);

  // optional .icing.lib.TermMatchType.Code term_match_type = 2;
  bool has_term_match_type() const;
  void clear_term_match_type();
  ::icing::lib::TermMatchType_Code term_match_type() const;
  void set_term_match_type(::icing::lib::TermMatchType_Code value);

  // @@protoc_insertion_point(class_scope:icing.lib.SearchSpecProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> namespace_filters_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> schema_type_filters_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_;
  int term_match_type_;
  friend struct ::TableStruct_icing_2fproto_2fsearch_2eproto;
};
// -------------------------------------------------------------------

class ResultSpecProto_SnippetSpecProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.ResultSpecProto.SnippetSpecProto) */ {
 public:
  ResultSpecProto_SnippetSpecProto();
  virtual ~ResultSpecProto_SnippetSpecProto();

  ResultSpecProto_SnippetSpecProto(const ResultSpecProto_SnippetSpecProto& from);
  ResultSpecProto_SnippetSpecProto(ResultSpecProto_SnippetSpecProto&& from) noexcept
    : ResultSpecProto_SnippetSpecProto() {
    *this = ::std::move(from);
  }

  inline ResultSpecProto_SnippetSpecProto& operator=(const ResultSpecProto_SnippetSpecProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResultSpecProto_SnippetSpecProto& operator=(ResultSpecProto_SnippetSpecProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ResultSpecProto_SnippetSpecProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResultSpecProto_SnippetSpecProto* internal_default_instance() {
    return reinterpret_cast<const ResultSpecProto_SnippetSpecProto*>(
               &_ResultSpecProto_SnippetSpecProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ResultSpecProto_SnippetSpecProto& a, ResultSpecProto_SnippetSpecProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ResultSpecProto_SnippetSpecProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResultSpecProto_SnippetSpecProto* New() const final {
    return CreateMaybeMessage<ResultSpecProto_SnippetSpecProto>(nullptr);
  }

  ResultSpecProto_SnippetSpecProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResultSpecProto_SnippetSpecProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ResultSpecProto_SnippetSpecProto& from);
  void MergeFrom(const ResultSpecProto_SnippetSpecProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResultSpecProto_SnippetSpecProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.ResultSpecProto.SnippetSpecProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumToSnippetFieldNumber = 1,
    kNumMatchesPerPropertyFieldNumber = 2,
    kMaxWindowBytesFieldNumber = 3,
  };
  // optional int32 num_to_snippet = 1;
  bool has_num_to_snippet() const;
  void clear_num_to_snippet();
  ::PROTOBUF_NAMESPACE_ID::int32 num_to_snippet() const;
  void set_num_to_snippet(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_matches_per_property = 2;
  bool has_num_matches_per_property() const;
  void clear_num_matches_per_property();
  ::PROTOBUF_NAMESPACE_ID::int32 num_matches_per_property() const;
  void set_num_matches_per_property(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 max_window_bytes = 3;
  bool has_max_window_bytes() const;
  void clear_max_window_bytes();
  ::PROTOBUF_NAMESPACE_ID::int32 max_window_bytes() const;
  void set_max_window_bytes(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:icing.lib.ResultSpecProto.SnippetSpecProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_to_snippet_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_matches_per_property_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_window_bytes_;
  friend struct ::TableStruct_icing_2fproto_2fsearch_2eproto;
};
// -------------------------------------------------------------------

class ResultSpecProto_ResultGrouping :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.ResultSpecProto.ResultGrouping) */ {
 public:
  ResultSpecProto_ResultGrouping();
  virtual ~ResultSpecProto_ResultGrouping();

  ResultSpecProto_ResultGrouping(const ResultSpecProto_ResultGrouping& from);
  ResultSpecProto_ResultGrouping(ResultSpecProto_ResultGrouping&& from) noexcept
    : ResultSpecProto_ResultGrouping() {
    *this = ::std::move(from);
  }

  inline ResultSpecProto_ResultGrouping& operator=(const ResultSpecProto_ResultGrouping& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResultSpecProto_ResultGrouping& operator=(ResultSpecProto_ResultGrouping&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ResultSpecProto_ResultGrouping& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResultSpecProto_ResultGrouping* internal_default_instance() {
    return reinterpret_cast<const ResultSpecProto_ResultGrouping*>(
               &_ResultSpecProto_ResultGrouping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ResultSpecProto_ResultGrouping& a, ResultSpecProto_ResultGrouping& b) {
    a.Swap(&b);
  }
  inline void Swap(ResultSpecProto_ResultGrouping* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResultSpecProto_ResultGrouping* New() const final {
    return CreateMaybeMessage<ResultSpecProto_ResultGrouping>(nullptr);
  }

  ResultSpecProto_ResultGrouping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResultSpecProto_ResultGrouping>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ResultSpecProto_ResultGrouping& from);
  void MergeFrom(const ResultSpecProto_ResultGrouping& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResultSpecProto_ResultGrouping* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.ResultSpecProto.ResultGrouping";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespacesFieldNumber = 1,
    kMaxResultsFieldNumber = 2,
  };
  // repeated string namespaces = 1;
  int namespaces_size() const;
  void clear_namespaces();
  const std::string& namespaces(int index) const;
  std::string* mutable_namespaces(int index);
  void set_namespaces(int index, const std::string& value);
  void set_namespaces(int index, std::string&& value);
  void set_namespaces(int index, const char* value);
  void set_namespaces(int index, const char* value, size_t size);
  std::string* add_namespaces();
  void add_namespaces(const std::string& value);
  void add_namespaces(std::string&& value);
  void add_namespaces(const char* value);
  void add_namespaces(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& namespaces() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_namespaces();

  // optional int32 max_results = 2;
  bool has_max_results() const;
  void clear_max_results();
  ::PROTOBUF_NAMESPACE_ID::int32 max_results() const;
  void set_max_results(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:icing.lib.ResultSpecProto.ResultGrouping)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> namespaces_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_results_;
  friend struct ::TableStruct_icing_2fproto_2fsearch_2eproto;
};
// -------------------------------------------------------------------

class ResultSpecProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.ResultSpecProto) */ {
 public:
  ResultSpecProto();
  virtual ~ResultSpecProto();

  ResultSpecProto(const ResultSpecProto& from);
  ResultSpecProto(ResultSpecProto&& from) noexcept
    : ResultSpecProto() {
    *this = ::std::move(from);
  }

  inline ResultSpecProto& operator=(const ResultSpecProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResultSpecProto& operator=(ResultSpecProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ResultSpecProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResultSpecProto* internal_default_instance() {
    return reinterpret_cast<const ResultSpecProto*>(
               &_ResultSpecProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ResultSpecProto& a, ResultSpecProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ResultSpecProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResultSpecProto* New() const final {
    return CreateMaybeMessage<ResultSpecProto>(nullptr);
  }

  ResultSpecProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResultSpecProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ResultSpecProto& from);
  void MergeFrom(const ResultSpecProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResultSpecProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.ResultSpecProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ResultSpecProto_SnippetSpecProto SnippetSpecProto;
  typedef ResultSpecProto_ResultGrouping ResultGrouping;

  // accessors -------------------------------------------------------

  enum : int {
    kTypePropertyMasksFieldNumber = 4,
    kResultGroupingsFieldNumber = 5,
    kSnippetSpecFieldNumber = 3,
    kDebugInfoFieldNumber = 2,
    kNumPerPageFieldNumber = 1,
  };
  // repeated .icing.lib.TypePropertyMask type_property_masks = 4;
  int type_property_masks_size() const;
  void clear_type_property_masks();
  ::icing::lib::TypePropertyMask* mutable_type_property_masks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::TypePropertyMask >*
      mutable_type_property_masks();
  const ::icing::lib::TypePropertyMask& type_property_masks(int index) const;
  ::icing::lib::TypePropertyMask* add_type_property_masks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::TypePropertyMask >&
      type_property_masks() const;

  // repeated .icing.lib.ResultSpecProto.ResultGrouping result_groupings = 5;
  int result_groupings_size() const;
  void clear_result_groupings();
  ::icing::lib::ResultSpecProto_ResultGrouping* mutable_result_groupings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::ResultSpecProto_ResultGrouping >*
      mutable_result_groupings();
  const ::icing::lib::ResultSpecProto_ResultGrouping& result_groupings(int index) const;
  ::icing::lib::ResultSpecProto_ResultGrouping* add_result_groupings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::ResultSpecProto_ResultGrouping >&
      result_groupings() const;

  // optional .icing.lib.ResultSpecProto.SnippetSpecProto snippet_spec = 3;
  bool has_snippet_spec() const;
  void clear_snippet_spec();
  const ::icing::lib::ResultSpecProto_SnippetSpecProto& snippet_spec() const;
  ::icing::lib::ResultSpecProto_SnippetSpecProto* release_snippet_spec();
  ::icing::lib::ResultSpecProto_SnippetSpecProto* mutable_snippet_spec();
  void set_allocated_snippet_spec(::icing::lib::ResultSpecProto_SnippetSpecProto* snippet_spec);

  // optional bool debug_info = 2;
  bool has_debug_info() const;
  void clear_debug_info();
  bool debug_info() const;
  void set_debug_info(bool value);

  // optional int32 num_per_page = 1 [default = 10];
  bool has_num_per_page() const;
  void clear_num_per_page();
  ::PROTOBUF_NAMESPACE_ID::int32 num_per_page() const;
  void set_num_per_page(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:icing.lib.ResultSpecProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::TypePropertyMask > type_property_masks_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::ResultSpecProto_ResultGrouping > result_groupings_;
  ::icing::lib::ResultSpecProto_SnippetSpecProto* snippet_spec_;
  bool debug_info_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_per_page_;
  friend struct ::TableStruct_icing_2fproto_2fsearch_2eproto;
};
// -------------------------------------------------------------------

class SnippetMatchProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.SnippetMatchProto) */ {
 public:
  SnippetMatchProto();
  virtual ~SnippetMatchProto();

  SnippetMatchProto(const SnippetMatchProto& from);
  SnippetMatchProto(SnippetMatchProto&& from) noexcept
    : SnippetMatchProto() {
    *this = ::std::move(from);
  }

  inline SnippetMatchProto& operator=(const SnippetMatchProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnippetMatchProto& operator=(SnippetMatchProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SnippetMatchProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SnippetMatchProto* internal_default_instance() {
    return reinterpret_cast<const SnippetMatchProto*>(
               &_SnippetMatchProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SnippetMatchProto& a, SnippetMatchProto& b) {
    a.Swap(&b);
  }
  inline void Swap(SnippetMatchProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SnippetMatchProto* New() const final {
    return CreateMaybeMessage<SnippetMatchProto>(nullptr);
  }

  SnippetMatchProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SnippetMatchProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SnippetMatchProto& from);
  void MergeFrom(const SnippetMatchProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SnippetMatchProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.SnippetMatchProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExactMatchBytePositionFieldNumber = 2,
    kExactMatchByteLengthFieldNumber = 3,
    kWindowBytePositionFieldNumber = 4,
    kWindowByteLengthFieldNumber = 5,
    kExactMatchUtf16PositionFieldNumber = 6,
    kExactMatchUtf16LengthFieldNumber = 7,
    kWindowUtf16PositionFieldNumber = 8,
    kWindowUtf16LengthFieldNumber = 9,
  };
  // optional int32 exact_match_byte_position = 2;
  bool has_exact_match_byte_position() const;
  void clear_exact_match_byte_position();
  ::PROTOBUF_NAMESPACE_ID::int32 exact_match_byte_position() const;
  void set_exact_match_byte_position(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 exact_match_byte_length = 3;
  bool has_exact_match_byte_length() const;
  void clear_exact_match_byte_length();
  ::PROTOBUF_NAMESPACE_ID::int32 exact_match_byte_length() const;
  void set_exact_match_byte_length(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 window_byte_position = 4;
  bool has_window_byte_position() const;
  void clear_window_byte_position();
  ::PROTOBUF_NAMESPACE_ID::int32 window_byte_position() const;
  void set_window_byte_position(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 window_byte_length = 5;
  bool has_window_byte_length() const;
  void clear_window_byte_length();
  ::PROTOBUF_NAMESPACE_ID::int32 window_byte_length() const;
  void set_window_byte_length(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 exact_match_utf16_position = 6;
  bool has_exact_match_utf16_position() const;
  void clear_exact_match_utf16_position();
  ::PROTOBUF_NAMESPACE_ID::int32 exact_match_utf16_position() const;
  void set_exact_match_utf16_position(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 exact_match_utf16_length = 7;
  bool has_exact_match_utf16_length() const;
  void clear_exact_match_utf16_length();
  ::PROTOBUF_NAMESPACE_ID::int32 exact_match_utf16_length() const;
  void set_exact_match_utf16_length(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 window_utf16_position = 8;
  bool has_window_utf16_position() const;
  void clear_window_utf16_position();
  ::PROTOBUF_NAMESPACE_ID::int32 window_utf16_position() const;
  void set_window_utf16_position(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 window_utf16_length = 9;
  bool has_window_utf16_length() const;
  void clear_window_utf16_length();
  ::PROTOBUF_NAMESPACE_ID::int32 window_utf16_length() const;
  void set_window_utf16_length(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:icing.lib.SnippetMatchProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 exact_match_byte_position_;
  ::PROTOBUF_NAMESPACE_ID::int32 exact_match_byte_length_;
  ::PROTOBUF_NAMESPACE_ID::int32 window_byte_position_;
  ::PROTOBUF_NAMESPACE_ID::int32 window_byte_length_;
  ::PROTOBUF_NAMESPACE_ID::int32 exact_match_utf16_position_;
  ::PROTOBUF_NAMESPACE_ID::int32 exact_match_utf16_length_;
  ::PROTOBUF_NAMESPACE_ID::int32 window_utf16_position_;
  ::PROTOBUF_NAMESPACE_ID::int32 window_utf16_length_;
  friend struct ::TableStruct_icing_2fproto_2fsearch_2eproto;
};
// -------------------------------------------------------------------

class SnippetProto_EntryProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.SnippetProto.EntryProto) */ {
 public:
  SnippetProto_EntryProto();
  virtual ~SnippetProto_EntryProto();

  SnippetProto_EntryProto(const SnippetProto_EntryProto& from);
  SnippetProto_EntryProto(SnippetProto_EntryProto&& from) noexcept
    : SnippetProto_EntryProto() {
    *this = ::std::move(from);
  }

  inline SnippetProto_EntryProto& operator=(const SnippetProto_EntryProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnippetProto_EntryProto& operator=(SnippetProto_EntryProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SnippetProto_EntryProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SnippetProto_EntryProto* internal_default_instance() {
    return reinterpret_cast<const SnippetProto_EntryProto*>(
               &_SnippetProto_EntryProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SnippetProto_EntryProto& a, SnippetProto_EntryProto& b) {
    a.Swap(&b);
  }
  inline void Swap(SnippetProto_EntryProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SnippetProto_EntryProto* New() const final {
    return CreateMaybeMessage<SnippetProto_EntryProto>(nullptr);
  }

  SnippetProto_EntryProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SnippetProto_EntryProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SnippetProto_EntryProto& from);
  void MergeFrom(const SnippetProto_EntryProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SnippetProto_EntryProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.SnippetProto.EntryProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnippetMatchesFieldNumber = 2,
    kPropertyNameFieldNumber = 1,
  };
  // repeated .icing.lib.SnippetMatchProto snippet_matches = 2;
  int snippet_matches_size() const;
  void clear_snippet_matches();
  ::icing::lib::SnippetMatchProto* mutable_snippet_matches(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::SnippetMatchProto >*
      mutable_snippet_matches();
  const ::icing::lib::SnippetMatchProto& snippet_matches(int index) const;
  ::icing::lib::SnippetMatchProto* add_snippet_matches();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::SnippetMatchProto >&
      snippet_matches() const;

  // optional string property_name = 1;
  bool has_property_name() const;
  void clear_property_name();
  const std::string& property_name() const;
  void set_property_name(const std::string& value);
  void set_property_name(std::string&& value);
  void set_property_name(const char* value);
  void set_property_name(const char* value, size_t size);
  std::string* mutable_property_name();
  std::string* release_property_name();
  void set_allocated_property_name(std::string* property_name);

  // @@protoc_insertion_point(class_scope:icing.lib.SnippetProto.EntryProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::SnippetMatchProto > snippet_matches_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr property_name_;
  friend struct ::TableStruct_icing_2fproto_2fsearch_2eproto;
};
// -------------------------------------------------------------------

class SnippetProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.SnippetProto) */ {
 public:
  SnippetProto();
  virtual ~SnippetProto();

  SnippetProto(const SnippetProto& from);
  SnippetProto(SnippetProto&& from) noexcept
    : SnippetProto() {
    *this = ::std::move(from);
  }

  inline SnippetProto& operator=(const SnippetProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnippetProto& operator=(SnippetProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SnippetProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SnippetProto* internal_default_instance() {
    return reinterpret_cast<const SnippetProto*>(
               &_SnippetProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SnippetProto& a, SnippetProto& b) {
    a.Swap(&b);
  }
  inline void Swap(SnippetProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SnippetProto* New() const final {
    return CreateMaybeMessage<SnippetProto>(nullptr);
  }

  SnippetProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SnippetProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SnippetProto& from);
  void MergeFrom(const SnippetProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SnippetProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.SnippetProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SnippetProto_EntryProto EntryProto;

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .icing.lib.SnippetProto.EntryProto entries = 1;
  int entries_size() const;
  void clear_entries();
  ::icing::lib::SnippetProto_EntryProto* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::SnippetProto_EntryProto >*
      mutable_entries();
  const ::icing::lib::SnippetProto_EntryProto& entries(int index) const;
  ::icing::lib::SnippetProto_EntryProto* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::SnippetProto_EntryProto >&
      entries() const;

  // @@protoc_insertion_point(class_scope:icing.lib.SnippetProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::SnippetProto_EntryProto > entries_;
  friend struct ::TableStruct_icing_2fproto_2fsearch_2eproto;
};
// -------------------------------------------------------------------

class SearchResultProto_ResultProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.SearchResultProto.ResultProto) */ {
 public:
  SearchResultProto_ResultProto();
  virtual ~SearchResultProto_ResultProto();

  SearchResultProto_ResultProto(const SearchResultProto_ResultProto& from);
  SearchResultProto_ResultProto(SearchResultProto_ResultProto&& from) noexcept
    : SearchResultProto_ResultProto() {
    *this = ::std::move(from);
  }

  inline SearchResultProto_ResultProto& operator=(const SearchResultProto_ResultProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchResultProto_ResultProto& operator=(SearchResultProto_ResultProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SearchResultProto_ResultProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SearchResultProto_ResultProto* internal_default_instance() {
    return reinterpret_cast<const SearchResultProto_ResultProto*>(
               &_SearchResultProto_ResultProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SearchResultProto_ResultProto& a, SearchResultProto_ResultProto& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchResultProto_ResultProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SearchResultProto_ResultProto* New() const final {
    return CreateMaybeMessage<SearchResultProto_ResultProto>(nullptr);
  }

  SearchResultProto_ResultProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SearchResultProto_ResultProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SearchResultProto_ResultProto& from);
  void MergeFrom(const SearchResultProto_ResultProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SearchResultProto_ResultProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.SearchResultProto.ResultProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentFieldNumber = 1,
    kSnippetFieldNumber = 2,
    kScoreFieldNumber = 3,
  };
  // optional .icing.lib.DocumentProto document = 1;
  bool has_document() const;
  void clear_document();
  const ::icing::lib::DocumentProto& document() const;
  ::icing::lib::DocumentProto* release_document();
  ::icing::lib::DocumentProto* mutable_document();
  void set_allocated_document(::icing::lib::DocumentProto* document);

  // optional .icing.lib.SnippetProto snippet = 2;
  bool has_snippet() const;
  void clear_snippet();
  const ::icing::lib::SnippetProto& snippet() const;
  ::icing::lib::SnippetProto* release_snippet();
  ::icing::lib::SnippetProto* mutable_snippet();
  void set_allocated_snippet(::icing::lib::SnippetProto* snippet);

  // optional double score = 3;
  bool has_score() const;
  void clear_score();
  double score() const;
  void set_score(double value);

  // @@protoc_insertion_point(class_scope:icing.lib.SearchResultProto.ResultProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::icing::lib::DocumentProto* document_;
  ::icing::lib::SnippetProto* snippet_;
  double score_;
  friend struct ::TableStruct_icing_2fproto_2fsearch_2eproto;
};
// -------------------------------------------------------------------

class SearchResultProto_DebugInfoProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.SearchResultProto.DebugInfoProto) */ {
 public:
  SearchResultProto_DebugInfoProto();
  virtual ~SearchResultProto_DebugInfoProto();

  SearchResultProto_DebugInfoProto(const SearchResultProto_DebugInfoProto& from);
  SearchResultProto_DebugInfoProto(SearchResultProto_DebugInfoProto&& from) noexcept
    : SearchResultProto_DebugInfoProto() {
    *this = ::std::move(from);
  }

  inline SearchResultProto_DebugInfoProto& operator=(const SearchResultProto_DebugInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchResultProto_DebugInfoProto& operator=(SearchResultProto_DebugInfoProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SearchResultProto_DebugInfoProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SearchResultProto_DebugInfoProto* internal_default_instance() {
    return reinterpret_cast<const SearchResultProto_DebugInfoProto*>(
               &_SearchResultProto_DebugInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SearchResultProto_DebugInfoProto& a, SearchResultProto_DebugInfoProto& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchResultProto_DebugInfoProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SearchResultProto_DebugInfoProto* New() const final {
    return CreateMaybeMessage<SearchResultProto_DebugInfoProto>(nullptr);
  }

  SearchResultProto_DebugInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SearchResultProto_DebugInfoProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SearchResultProto_DebugInfoProto& from);
  void MergeFrom(const SearchResultProto_DebugInfoProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SearchResultProto_DebugInfoProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.SearchResultProto.DebugInfoProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExecutedQueryFieldNumber = 3,
  };
  // optional string executed_query = 3;
  bool has_executed_query() const;
  void clear_executed_query();
  const std::string& executed_query() const;
  void set_executed_query(const std::string& value);
  void set_executed_query(std::string&& value);
  void set_executed_query(const char* value);
  void set_executed_query(const char* value, size_t size);
  std::string* mutable_executed_query();
  std::string* release_executed_query();
  void set_allocated_executed_query(std::string* executed_query);

  // @@protoc_insertion_point(class_scope:icing.lib.SearchResultProto.DebugInfoProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr executed_query_;
  friend struct ::TableStruct_icing_2fproto_2fsearch_2eproto;
};
// -------------------------------------------------------------------

class SearchResultProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.SearchResultProto) */ {
 public:
  SearchResultProto();
  virtual ~SearchResultProto();

  SearchResultProto(const SearchResultProto& from);
  SearchResultProto(SearchResultProto&& from) noexcept
    : SearchResultProto() {
    *this = ::std::move(from);
  }

  inline SearchResultProto& operator=(const SearchResultProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchResultProto& operator=(SearchResultProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SearchResultProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SearchResultProto* internal_default_instance() {
    return reinterpret_cast<const SearchResultProto*>(
               &_SearchResultProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SearchResultProto& a, SearchResultProto& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchResultProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SearchResultProto* New() const final {
    return CreateMaybeMessage<SearchResultProto>(nullptr);
  }

  SearchResultProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SearchResultProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SearchResultProto& from);
  void MergeFrom(const SearchResultProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SearchResultProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.SearchResultProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SearchResultProto_ResultProto ResultProto;
  typedef SearchResultProto_DebugInfoProto DebugInfoProto;

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 2,
    kStatusFieldNumber = 1,
    kDebugInfoFieldNumber = 3,
    kQueryStatsFieldNumber = 5,
    kNextPageTokenFieldNumber = 4,
  };
  // repeated .icing.lib.SearchResultProto.ResultProto results = 2;
  int results_size() const;
  void clear_results();
  ::icing::lib::SearchResultProto_ResultProto* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::SearchResultProto_ResultProto >*
      mutable_results();
  const ::icing::lib::SearchResultProto_ResultProto& results(int index) const;
  ::icing::lib::SearchResultProto_ResultProto* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::SearchResultProto_ResultProto >&
      results() const;

  // optional .icing.lib.StatusProto status = 1;
  bool has_status() const;
  void clear_status();
  const ::icing::lib::StatusProto& status() const;
  ::icing::lib::StatusProto* release_status();
  ::icing::lib::StatusProto* mutable_status();
  void set_allocated_status(::icing::lib::StatusProto* status);

  // optional .icing.lib.SearchResultProto.DebugInfoProto debug_info = 3;
  bool has_debug_info() const;
  void clear_debug_info();
  const ::icing::lib::SearchResultProto_DebugInfoProto& debug_info() const;
  ::icing::lib::SearchResultProto_DebugInfoProto* release_debug_info();
  ::icing::lib::SearchResultProto_DebugInfoProto* mutable_debug_info();
  void set_allocated_debug_info(::icing::lib::SearchResultProto_DebugInfoProto* debug_info);

  // optional .icing.lib.QueryStatsProto query_stats = 5;
  bool has_query_stats() const;
  void clear_query_stats();
  const ::icing::lib::QueryStatsProto& query_stats() const;
  ::icing::lib::QueryStatsProto* release_query_stats();
  ::icing::lib::QueryStatsProto* mutable_query_stats();
  void set_allocated_query_stats(::icing::lib::QueryStatsProto* query_stats);

  // optional uint64 next_page_token = 4;
  bool has_next_page_token() const;
  void clear_next_page_token();
  ::PROTOBUF_NAMESPACE_ID::uint64 next_page_token() const;
  void set_next_page_token(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:icing.lib.SearchResultProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::SearchResultProto_ResultProto > results_;
  ::icing::lib::StatusProto* status_;
  ::icing::lib::SearchResultProto_DebugInfoProto* debug_info_;
  ::icing::lib::QueryStatsProto* query_stats_;
  ::PROTOBUF_NAMESPACE_ID::uint64 next_page_token_;
  friend struct ::TableStruct_icing_2fproto_2fsearch_2eproto;
};
// -------------------------------------------------------------------

class TypePropertyMask :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.TypePropertyMask) */ {
 public:
  TypePropertyMask();
  virtual ~TypePropertyMask();

  TypePropertyMask(const TypePropertyMask& from);
  TypePropertyMask(TypePropertyMask&& from) noexcept
    : TypePropertyMask() {
    *this = ::std::move(from);
  }

  inline TypePropertyMask& operator=(const TypePropertyMask& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypePropertyMask& operator=(TypePropertyMask&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const TypePropertyMask& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TypePropertyMask* internal_default_instance() {
    return reinterpret_cast<const TypePropertyMask*>(
               &_TypePropertyMask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TypePropertyMask& a, TypePropertyMask& b) {
    a.Swap(&b);
  }
  inline void Swap(TypePropertyMask* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TypePropertyMask* New() const final {
    return CreateMaybeMessage<TypePropertyMask>(nullptr);
  }

  TypePropertyMask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TypePropertyMask>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const TypePropertyMask& from);
  void MergeFrom(const TypePropertyMask& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TypePropertyMask* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.TypePropertyMask";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathsFieldNumber = 2,
    kSchemaTypeFieldNumber = 1,
  };
  // repeated string paths = 2;
  int paths_size() const;
  void clear_paths();
  const std::string& paths(int index) const;
  std::string* mutable_paths(int index);
  void set_paths(int index, const std::string& value);
  void set_paths(int index, std::string&& value);
  void set_paths(int index, const char* value);
  void set_paths(int index, const char* value, size_t size);
  std::string* add_paths();
  void add_paths(const std::string& value);
  void add_paths(std::string&& value);
  void add_paths(const char* value);
  void add_paths(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& paths() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_paths();

  // optional string schema_type = 1;
  bool has_schema_type() const;
  void clear_schema_type();
  const std::string& schema_type() const;
  void set_schema_type(const std::string& value);
  void set_schema_type(std::string&& value);
  void set_schema_type(const char* value);
  void set_schema_type(const char* value, size_t size);
  std::string* mutable_schema_type();
  std::string* release_schema_type();
  void set_allocated_schema_type(std::string* schema_type);

  // @@protoc_insertion_point(class_scope:icing.lib.TypePropertyMask)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> paths_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_type_;
  friend struct ::TableStruct_icing_2fproto_2fsearch_2eproto;
};
// -------------------------------------------------------------------

class GetResultSpecProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.GetResultSpecProto) */ {
 public:
  GetResultSpecProto();
  virtual ~GetResultSpecProto();

  GetResultSpecProto(const GetResultSpecProto& from);
  GetResultSpecProto(GetResultSpecProto&& from) noexcept
    : GetResultSpecProto() {
    *this = ::std::move(from);
  }

  inline GetResultSpecProto& operator=(const GetResultSpecProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResultSpecProto& operator=(GetResultSpecProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GetResultSpecProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetResultSpecProto* internal_default_instance() {
    return reinterpret_cast<const GetResultSpecProto*>(
               &_GetResultSpecProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetResultSpecProto& a, GetResultSpecProto& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResultSpecProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetResultSpecProto* New() const final {
    return CreateMaybeMessage<GetResultSpecProto>(nullptr);
  }

  GetResultSpecProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetResultSpecProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const GetResultSpecProto& from);
  void MergeFrom(const GetResultSpecProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetResultSpecProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.GetResultSpecProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypePropertyMasksFieldNumber = 1,
  };
  // repeated .icing.lib.TypePropertyMask type_property_masks = 1;
  int type_property_masks_size() const;
  void clear_type_property_masks();
  ::icing::lib::TypePropertyMask* mutable_type_property_masks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::TypePropertyMask >*
      mutable_type_property_masks();
  const ::icing::lib::TypePropertyMask& type_property_masks(int index) const;
  ::icing::lib::TypePropertyMask* add_type_property_masks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::TypePropertyMask >&
      type_property_masks() const;

  // @@protoc_insertion_point(class_scope:icing.lib.GetResultSpecProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::TypePropertyMask > type_property_masks_;
  friend struct ::TableStruct_icing_2fproto_2fsearch_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SearchSpecProto

// optional string query = 1;
inline bool SearchSpecProto::has_query() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchSpecProto::clear_query() {
  query_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SearchSpecProto::query() const {
  // @@protoc_insertion_point(field_get:icing.lib.SearchSpecProto.query)
  return query_.GetNoArena();
}
inline void SearchSpecProto::set_query(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  query_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:icing.lib.SearchSpecProto.query)
}
inline void SearchSpecProto::set_query(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  query_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:icing.lib.SearchSpecProto.query)
}
inline void SearchSpecProto::set_query(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  query_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:icing.lib.SearchSpecProto.query)
}
inline void SearchSpecProto::set_query(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  query_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:icing.lib.SearchSpecProto.query)
}
inline std::string* SearchSpecProto::mutable_query() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:icing.lib.SearchSpecProto.query)
  return query_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SearchSpecProto::release_query() {
  // @@protoc_insertion_point(field_release:icing.lib.SearchSpecProto.query)
  if (!has_query()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return query_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SearchSpecProto::set_allocated_query(std::string* query) {
  if (query != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  query_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), query);
  // @@protoc_insertion_point(field_set_allocated:icing.lib.SearchSpecProto.query)
}

// optional .icing.lib.TermMatchType.Code term_match_type = 2;
inline bool SearchSpecProto::has_term_match_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchSpecProto::clear_term_match_type() {
  term_match_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::icing::lib::TermMatchType_Code SearchSpecProto::term_match_type() const {
  // @@protoc_insertion_point(field_get:icing.lib.SearchSpecProto.term_match_type)
  return static_cast< ::icing::lib::TermMatchType_Code >(term_match_type_);
}
inline void SearchSpecProto::set_term_match_type(::icing::lib::TermMatchType_Code value) {
  assert(::icing::lib::TermMatchType_Code_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  term_match_type_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.SearchSpecProto.term_match_type)
}

// repeated string namespace_filters = 3;
inline int SearchSpecProto::namespace_filters_size() const {
  return namespace_filters_.size();
}
inline void SearchSpecProto::clear_namespace_filters() {
  namespace_filters_.Clear();
}
inline const std::string& SearchSpecProto::namespace_filters(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.SearchSpecProto.namespace_filters)
  return namespace_filters_.Get(index);
}
inline std::string* SearchSpecProto::mutable_namespace_filters(int index) {
  // @@protoc_insertion_point(field_mutable:icing.lib.SearchSpecProto.namespace_filters)
  return namespace_filters_.Mutable(index);
}
inline void SearchSpecProto::set_namespace_filters(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:icing.lib.SearchSpecProto.namespace_filters)
  namespace_filters_.Mutable(index)->assign(value);
}
inline void SearchSpecProto::set_namespace_filters(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:icing.lib.SearchSpecProto.namespace_filters)
  namespace_filters_.Mutable(index)->assign(std::move(value));
}
inline void SearchSpecProto::set_namespace_filters(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  namespace_filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:icing.lib.SearchSpecProto.namespace_filters)
}
inline void SearchSpecProto::set_namespace_filters(int index, const char* value, size_t size) {
  namespace_filters_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:icing.lib.SearchSpecProto.namespace_filters)
}
inline std::string* SearchSpecProto::add_namespace_filters() {
  // @@protoc_insertion_point(field_add_mutable:icing.lib.SearchSpecProto.namespace_filters)
  return namespace_filters_.Add();
}
inline void SearchSpecProto::add_namespace_filters(const std::string& value) {
  namespace_filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:icing.lib.SearchSpecProto.namespace_filters)
}
inline void SearchSpecProto::add_namespace_filters(std::string&& value) {
  namespace_filters_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:icing.lib.SearchSpecProto.namespace_filters)
}
inline void SearchSpecProto::add_namespace_filters(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  namespace_filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:icing.lib.SearchSpecProto.namespace_filters)
}
inline void SearchSpecProto::add_namespace_filters(const char* value, size_t size) {
  namespace_filters_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:icing.lib.SearchSpecProto.namespace_filters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SearchSpecProto::namespace_filters() const {
  // @@protoc_insertion_point(field_list:icing.lib.SearchSpecProto.namespace_filters)
  return namespace_filters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SearchSpecProto::mutable_namespace_filters() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.SearchSpecProto.namespace_filters)
  return &namespace_filters_;
}

// repeated string schema_type_filters = 4;
inline int SearchSpecProto::schema_type_filters_size() const {
  return schema_type_filters_.size();
}
inline void SearchSpecProto::clear_schema_type_filters() {
  schema_type_filters_.Clear();
}
inline const std::string& SearchSpecProto::schema_type_filters(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.SearchSpecProto.schema_type_filters)
  return schema_type_filters_.Get(index);
}
inline std::string* SearchSpecProto::mutable_schema_type_filters(int index) {
  // @@protoc_insertion_point(field_mutable:icing.lib.SearchSpecProto.schema_type_filters)
  return schema_type_filters_.Mutable(index);
}
inline void SearchSpecProto::set_schema_type_filters(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:icing.lib.SearchSpecProto.schema_type_filters)
  schema_type_filters_.Mutable(index)->assign(value);
}
inline void SearchSpecProto::set_schema_type_filters(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:icing.lib.SearchSpecProto.schema_type_filters)
  schema_type_filters_.Mutable(index)->assign(std::move(value));
}
inline void SearchSpecProto::set_schema_type_filters(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  schema_type_filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:icing.lib.SearchSpecProto.schema_type_filters)
}
inline void SearchSpecProto::set_schema_type_filters(int index, const char* value, size_t size) {
  schema_type_filters_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:icing.lib.SearchSpecProto.schema_type_filters)
}
inline std::string* SearchSpecProto::add_schema_type_filters() {
  // @@protoc_insertion_point(field_add_mutable:icing.lib.SearchSpecProto.schema_type_filters)
  return schema_type_filters_.Add();
}
inline void SearchSpecProto::add_schema_type_filters(const std::string& value) {
  schema_type_filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:icing.lib.SearchSpecProto.schema_type_filters)
}
inline void SearchSpecProto::add_schema_type_filters(std::string&& value) {
  schema_type_filters_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:icing.lib.SearchSpecProto.schema_type_filters)
}
inline void SearchSpecProto::add_schema_type_filters(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  schema_type_filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:icing.lib.SearchSpecProto.schema_type_filters)
}
inline void SearchSpecProto::add_schema_type_filters(const char* value, size_t size) {
  schema_type_filters_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:icing.lib.SearchSpecProto.schema_type_filters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SearchSpecProto::schema_type_filters() const {
  // @@protoc_insertion_point(field_list:icing.lib.SearchSpecProto.schema_type_filters)
  return schema_type_filters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SearchSpecProto::mutable_schema_type_filters() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.SearchSpecProto.schema_type_filters)
  return &schema_type_filters_;
}

// -------------------------------------------------------------------

// ResultSpecProto_SnippetSpecProto

// optional int32 num_to_snippet = 1;
inline bool ResultSpecProto_SnippetSpecProto::has_num_to_snippet() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResultSpecProto_SnippetSpecProto::clear_num_to_snippet() {
  num_to_snippet_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ResultSpecProto_SnippetSpecProto::num_to_snippet() const {
  // @@protoc_insertion_point(field_get:icing.lib.ResultSpecProto.SnippetSpecProto.num_to_snippet)
  return num_to_snippet_;
}
inline void ResultSpecProto_SnippetSpecProto::set_num_to_snippet(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  num_to_snippet_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.ResultSpecProto.SnippetSpecProto.num_to_snippet)
}

// optional int32 num_matches_per_property = 2;
inline bool ResultSpecProto_SnippetSpecProto::has_num_matches_per_property() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResultSpecProto_SnippetSpecProto::clear_num_matches_per_property() {
  num_matches_per_property_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ResultSpecProto_SnippetSpecProto::num_matches_per_property() const {
  // @@protoc_insertion_point(field_get:icing.lib.ResultSpecProto.SnippetSpecProto.num_matches_per_property)
  return num_matches_per_property_;
}
inline void ResultSpecProto_SnippetSpecProto::set_num_matches_per_property(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  num_matches_per_property_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.ResultSpecProto.SnippetSpecProto.num_matches_per_property)
}

// optional int32 max_window_bytes = 3;
inline bool ResultSpecProto_SnippetSpecProto::has_max_window_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResultSpecProto_SnippetSpecProto::clear_max_window_bytes() {
  max_window_bytes_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ResultSpecProto_SnippetSpecProto::max_window_bytes() const {
  // @@protoc_insertion_point(field_get:icing.lib.ResultSpecProto.SnippetSpecProto.max_window_bytes)
  return max_window_bytes_;
}
inline void ResultSpecProto_SnippetSpecProto::set_max_window_bytes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  max_window_bytes_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.ResultSpecProto.SnippetSpecProto.max_window_bytes)
}

// -------------------------------------------------------------------

// ResultSpecProto_ResultGrouping

// repeated string namespaces = 1;
inline int ResultSpecProto_ResultGrouping::namespaces_size() const {
  return namespaces_.size();
}
inline void ResultSpecProto_ResultGrouping::clear_namespaces() {
  namespaces_.Clear();
}
inline const std::string& ResultSpecProto_ResultGrouping::namespaces(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.ResultSpecProto.ResultGrouping.namespaces)
  return namespaces_.Get(index);
}
inline std::string* ResultSpecProto_ResultGrouping::mutable_namespaces(int index) {
  // @@protoc_insertion_point(field_mutable:icing.lib.ResultSpecProto.ResultGrouping.namespaces)
  return namespaces_.Mutable(index);
}
inline void ResultSpecProto_ResultGrouping::set_namespaces(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:icing.lib.ResultSpecProto.ResultGrouping.namespaces)
  namespaces_.Mutable(index)->assign(value);
}
inline void ResultSpecProto_ResultGrouping::set_namespaces(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:icing.lib.ResultSpecProto.ResultGrouping.namespaces)
  namespaces_.Mutable(index)->assign(std::move(value));
}
inline void ResultSpecProto_ResultGrouping::set_namespaces(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  namespaces_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:icing.lib.ResultSpecProto.ResultGrouping.namespaces)
}
inline void ResultSpecProto_ResultGrouping::set_namespaces(int index, const char* value, size_t size) {
  namespaces_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:icing.lib.ResultSpecProto.ResultGrouping.namespaces)
}
inline std::string* ResultSpecProto_ResultGrouping::add_namespaces() {
  // @@protoc_insertion_point(field_add_mutable:icing.lib.ResultSpecProto.ResultGrouping.namespaces)
  return namespaces_.Add();
}
inline void ResultSpecProto_ResultGrouping::add_namespaces(const std::string& value) {
  namespaces_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:icing.lib.ResultSpecProto.ResultGrouping.namespaces)
}
inline void ResultSpecProto_ResultGrouping::add_namespaces(std::string&& value) {
  namespaces_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:icing.lib.ResultSpecProto.ResultGrouping.namespaces)
}
inline void ResultSpecProto_ResultGrouping::add_namespaces(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  namespaces_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:icing.lib.ResultSpecProto.ResultGrouping.namespaces)
}
inline void ResultSpecProto_ResultGrouping::add_namespaces(const char* value, size_t size) {
  namespaces_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:icing.lib.ResultSpecProto.ResultGrouping.namespaces)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ResultSpecProto_ResultGrouping::namespaces() const {
  // @@protoc_insertion_point(field_list:icing.lib.ResultSpecProto.ResultGrouping.namespaces)
  return namespaces_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ResultSpecProto_ResultGrouping::mutable_namespaces() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.ResultSpecProto.ResultGrouping.namespaces)
  return &namespaces_;
}

// optional int32 max_results = 2;
inline bool ResultSpecProto_ResultGrouping::has_max_results() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResultSpecProto_ResultGrouping::clear_max_results() {
  max_results_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ResultSpecProto_ResultGrouping::max_results() const {
  // @@protoc_insertion_point(field_get:icing.lib.ResultSpecProto.ResultGrouping.max_results)
  return max_results_;
}
inline void ResultSpecProto_ResultGrouping::set_max_results(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  max_results_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.ResultSpecProto.ResultGrouping.max_results)
}

// -------------------------------------------------------------------

// ResultSpecProto

// optional int32 num_per_page = 1 [default = 10];
inline bool ResultSpecProto::has_num_per_page() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResultSpecProto::clear_num_per_page() {
  num_per_page_ = 10;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ResultSpecProto::num_per_page() const {
  // @@protoc_insertion_point(field_get:icing.lib.ResultSpecProto.num_per_page)
  return num_per_page_;
}
inline void ResultSpecProto::set_num_per_page(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  num_per_page_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.ResultSpecProto.num_per_page)
}

// optional bool debug_info = 2;
inline bool ResultSpecProto::has_debug_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResultSpecProto::clear_debug_info() {
  debug_info_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ResultSpecProto::debug_info() const {
  // @@protoc_insertion_point(field_get:icing.lib.ResultSpecProto.debug_info)
  return debug_info_;
}
inline void ResultSpecProto::set_debug_info(bool value) {
  _has_bits_[0] |= 0x00000002u;
  debug_info_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.ResultSpecProto.debug_info)
}

// optional .icing.lib.ResultSpecProto.SnippetSpecProto snippet_spec = 3;
inline bool ResultSpecProto::has_snippet_spec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResultSpecProto::clear_snippet_spec() {
  if (snippet_spec_ != nullptr) snippet_spec_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::icing::lib::ResultSpecProto_SnippetSpecProto& ResultSpecProto::snippet_spec() const {
  const ::icing::lib::ResultSpecProto_SnippetSpecProto* p = snippet_spec_;
  // @@protoc_insertion_point(field_get:icing.lib.ResultSpecProto.snippet_spec)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::ResultSpecProto_SnippetSpecProto*>(
      &::icing::lib::_ResultSpecProto_SnippetSpecProto_default_instance_);
}
inline ::icing::lib::ResultSpecProto_SnippetSpecProto* ResultSpecProto::release_snippet_spec() {
  // @@protoc_insertion_point(field_release:icing.lib.ResultSpecProto.snippet_spec)
  _has_bits_[0] &= ~0x00000001u;
  ::icing::lib::ResultSpecProto_SnippetSpecProto* temp = snippet_spec_;
  snippet_spec_ = nullptr;
  return temp;
}
inline ::icing::lib::ResultSpecProto_SnippetSpecProto* ResultSpecProto::mutable_snippet_spec() {
  _has_bits_[0] |= 0x00000001u;
  if (snippet_spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::ResultSpecProto_SnippetSpecProto>(GetArenaNoVirtual());
    snippet_spec_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.ResultSpecProto.snippet_spec)
  return snippet_spec_;
}
inline void ResultSpecProto::set_allocated_snippet_spec(::icing::lib::ResultSpecProto_SnippetSpecProto* snippet_spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete snippet_spec_;
  }
  if (snippet_spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      snippet_spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, snippet_spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  snippet_spec_ = snippet_spec;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.ResultSpecProto.snippet_spec)
}

// repeated .icing.lib.TypePropertyMask type_property_masks = 4;
inline int ResultSpecProto::type_property_masks_size() const {
  return type_property_masks_.size();
}
inline void ResultSpecProto::clear_type_property_masks() {
  type_property_masks_.Clear();
}
inline ::icing::lib::TypePropertyMask* ResultSpecProto::mutable_type_property_masks(int index) {
  // @@protoc_insertion_point(field_mutable:icing.lib.ResultSpecProto.type_property_masks)
  return type_property_masks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::TypePropertyMask >*
ResultSpecProto::mutable_type_property_masks() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.ResultSpecProto.type_property_masks)
  return &type_property_masks_;
}
inline const ::icing::lib::TypePropertyMask& ResultSpecProto::type_property_masks(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.ResultSpecProto.type_property_masks)
  return type_property_masks_.Get(index);
}
inline ::icing::lib::TypePropertyMask* ResultSpecProto::add_type_property_masks() {
  // @@protoc_insertion_point(field_add:icing.lib.ResultSpecProto.type_property_masks)
  return type_property_masks_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::TypePropertyMask >&
ResultSpecProto::type_property_masks() const {
  // @@protoc_insertion_point(field_list:icing.lib.ResultSpecProto.type_property_masks)
  return type_property_masks_;
}

// repeated .icing.lib.ResultSpecProto.ResultGrouping result_groupings = 5;
inline int ResultSpecProto::result_groupings_size() const {
  return result_groupings_.size();
}
inline void ResultSpecProto::clear_result_groupings() {
  result_groupings_.Clear();
}
inline ::icing::lib::ResultSpecProto_ResultGrouping* ResultSpecProto::mutable_result_groupings(int index) {
  // @@protoc_insertion_point(field_mutable:icing.lib.ResultSpecProto.result_groupings)
  return result_groupings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::ResultSpecProto_ResultGrouping >*
ResultSpecProto::mutable_result_groupings() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.ResultSpecProto.result_groupings)
  return &result_groupings_;
}
inline const ::icing::lib::ResultSpecProto_ResultGrouping& ResultSpecProto::result_groupings(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.ResultSpecProto.result_groupings)
  return result_groupings_.Get(index);
}
inline ::icing::lib::ResultSpecProto_ResultGrouping* ResultSpecProto::add_result_groupings() {
  // @@protoc_insertion_point(field_add:icing.lib.ResultSpecProto.result_groupings)
  return result_groupings_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::ResultSpecProto_ResultGrouping >&
ResultSpecProto::result_groupings() const {
  // @@protoc_insertion_point(field_list:icing.lib.ResultSpecProto.result_groupings)
  return result_groupings_;
}

// -------------------------------------------------------------------

// SnippetMatchProto

// optional int32 exact_match_byte_position = 2;
inline bool SnippetMatchProto::has_exact_match_byte_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SnippetMatchProto::clear_exact_match_byte_position() {
  exact_match_byte_position_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SnippetMatchProto::exact_match_byte_position() const {
  // @@protoc_insertion_point(field_get:icing.lib.SnippetMatchProto.exact_match_byte_position)
  return exact_match_byte_position_;
}
inline void SnippetMatchProto::set_exact_match_byte_position(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  exact_match_byte_position_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.SnippetMatchProto.exact_match_byte_position)
}

// optional int32 exact_match_byte_length = 3;
inline bool SnippetMatchProto::has_exact_match_byte_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SnippetMatchProto::clear_exact_match_byte_length() {
  exact_match_byte_length_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SnippetMatchProto::exact_match_byte_length() const {
  // @@protoc_insertion_point(field_get:icing.lib.SnippetMatchProto.exact_match_byte_length)
  return exact_match_byte_length_;
}
inline void SnippetMatchProto::set_exact_match_byte_length(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  exact_match_byte_length_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.SnippetMatchProto.exact_match_byte_length)
}

// optional int32 exact_match_utf16_position = 6;
inline bool SnippetMatchProto::has_exact_match_utf16_position() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SnippetMatchProto::clear_exact_match_utf16_position() {
  exact_match_utf16_position_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SnippetMatchProto::exact_match_utf16_position() const {
  // @@protoc_insertion_point(field_get:icing.lib.SnippetMatchProto.exact_match_utf16_position)
  return exact_match_utf16_position_;
}
inline void SnippetMatchProto::set_exact_match_utf16_position(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  exact_match_utf16_position_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.SnippetMatchProto.exact_match_utf16_position)
}

// optional int32 exact_match_utf16_length = 7;
inline bool SnippetMatchProto::has_exact_match_utf16_length() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SnippetMatchProto::clear_exact_match_utf16_length() {
  exact_match_utf16_length_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SnippetMatchProto::exact_match_utf16_length() const {
  // @@protoc_insertion_point(field_get:icing.lib.SnippetMatchProto.exact_match_utf16_length)
  return exact_match_utf16_length_;
}
inline void SnippetMatchProto::set_exact_match_utf16_length(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  exact_match_utf16_length_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.SnippetMatchProto.exact_match_utf16_length)
}

// optional int32 window_byte_position = 4;
inline bool SnippetMatchProto::has_window_byte_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SnippetMatchProto::clear_window_byte_position() {
  window_byte_position_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SnippetMatchProto::window_byte_position() const {
  // @@protoc_insertion_point(field_get:icing.lib.SnippetMatchProto.window_byte_position)
  return window_byte_position_;
}
inline void SnippetMatchProto::set_window_byte_position(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  window_byte_position_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.SnippetMatchProto.window_byte_position)
}

// optional int32 window_byte_length = 5;
inline bool SnippetMatchProto::has_window_byte_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SnippetMatchProto::clear_window_byte_length() {
  window_byte_length_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SnippetMatchProto::window_byte_length() const {
  // @@protoc_insertion_point(field_get:icing.lib.SnippetMatchProto.window_byte_length)
  return window_byte_length_;
}
inline void SnippetMatchProto::set_window_byte_length(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  window_byte_length_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.SnippetMatchProto.window_byte_length)
}

// optional int32 window_utf16_position = 8;
inline bool SnippetMatchProto::has_window_utf16_position() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SnippetMatchProto::clear_window_utf16_position() {
  window_utf16_position_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SnippetMatchProto::window_utf16_position() const {
  // @@protoc_insertion_point(field_get:icing.lib.SnippetMatchProto.window_utf16_position)
  return window_utf16_position_;
}
inline void SnippetMatchProto::set_window_utf16_position(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  window_utf16_position_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.SnippetMatchProto.window_utf16_position)
}

// optional int32 window_utf16_length = 9;
inline bool SnippetMatchProto::has_window_utf16_length() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SnippetMatchProto::clear_window_utf16_length() {
  window_utf16_length_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SnippetMatchProto::window_utf16_length() const {
  // @@protoc_insertion_point(field_get:icing.lib.SnippetMatchProto.window_utf16_length)
  return window_utf16_length_;
}
inline void SnippetMatchProto::set_window_utf16_length(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  window_utf16_length_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.SnippetMatchProto.window_utf16_length)
}

// -------------------------------------------------------------------

// SnippetProto_EntryProto

// optional string property_name = 1;
inline bool SnippetProto_EntryProto::has_property_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SnippetProto_EntryProto::clear_property_name() {
  property_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SnippetProto_EntryProto::property_name() const {
  // @@protoc_insertion_point(field_get:icing.lib.SnippetProto.EntryProto.property_name)
  return property_name_.GetNoArena();
}
inline void SnippetProto_EntryProto::set_property_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  property_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:icing.lib.SnippetProto.EntryProto.property_name)
}
inline void SnippetProto_EntryProto::set_property_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  property_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:icing.lib.SnippetProto.EntryProto.property_name)
}
inline void SnippetProto_EntryProto::set_property_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  property_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:icing.lib.SnippetProto.EntryProto.property_name)
}
inline void SnippetProto_EntryProto::set_property_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  property_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:icing.lib.SnippetProto.EntryProto.property_name)
}
inline std::string* SnippetProto_EntryProto::mutable_property_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:icing.lib.SnippetProto.EntryProto.property_name)
  return property_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SnippetProto_EntryProto::release_property_name() {
  // @@protoc_insertion_point(field_release:icing.lib.SnippetProto.EntryProto.property_name)
  if (!has_property_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return property_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SnippetProto_EntryProto::set_allocated_property_name(std::string* property_name) {
  if (property_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  property_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), property_name);
  // @@protoc_insertion_point(field_set_allocated:icing.lib.SnippetProto.EntryProto.property_name)
}

// repeated .icing.lib.SnippetMatchProto snippet_matches = 2;
inline int SnippetProto_EntryProto::snippet_matches_size() const {
  return snippet_matches_.size();
}
inline void SnippetProto_EntryProto::clear_snippet_matches() {
  snippet_matches_.Clear();
}
inline ::icing::lib::SnippetMatchProto* SnippetProto_EntryProto::mutable_snippet_matches(int index) {
  // @@protoc_insertion_point(field_mutable:icing.lib.SnippetProto.EntryProto.snippet_matches)
  return snippet_matches_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::SnippetMatchProto >*
SnippetProto_EntryProto::mutable_snippet_matches() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.SnippetProto.EntryProto.snippet_matches)
  return &snippet_matches_;
}
inline const ::icing::lib::SnippetMatchProto& SnippetProto_EntryProto::snippet_matches(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.SnippetProto.EntryProto.snippet_matches)
  return snippet_matches_.Get(index);
}
inline ::icing::lib::SnippetMatchProto* SnippetProto_EntryProto::add_snippet_matches() {
  // @@protoc_insertion_point(field_add:icing.lib.SnippetProto.EntryProto.snippet_matches)
  return snippet_matches_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::SnippetMatchProto >&
SnippetProto_EntryProto::snippet_matches() const {
  // @@protoc_insertion_point(field_list:icing.lib.SnippetProto.EntryProto.snippet_matches)
  return snippet_matches_;
}

// -------------------------------------------------------------------

// SnippetProto

// repeated .icing.lib.SnippetProto.EntryProto entries = 1;
inline int SnippetProto::entries_size() const {
  return entries_.size();
}
inline void SnippetProto::clear_entries() {
  entries_.Clear();
}
inline ::icing::lib::SnippetProto_EntryProto* SnippetProto::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:icing.lib.SnippetProto.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::SnippetProto_EntryProto >*
SnippetProto::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.SnippetProto.entries)
  return &entries_;
}
inline const ::icing::lib::SnippetProto_EntryProto& SnippetProto::entries(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.SnippetProto.entries)
  return entries_.Get(index);
}
inline ::icing::lib::SnippetProto_EntryProto* SnippetProto::add_entries() {
  // @@protoc_insertion_point(field_add:icing.lib.SnippetProto.entries)
  return entries_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::SnippetProto_EntryProto >&
SnippetProto::entries() const {
  // @@protoc_insertion_point(field_list:icing.lib.SnippetProto.entries)
  return entries_;
}

// -------------------------------------------------------------------

// SearchResultProto_ResultProto

// optional .icing.lib.DocumentProto document = 1;
inline bool SearchResultProto_ResultProto::has_document() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::icing::lib::DocumentProto& SearchResultProto_ResultProto::document() const {
  const ::icing::lib::DocumentProto* p = document_;
  // @@protoc_insertion_point(field_get:icing.lib.SearchResultProto.ResultProto.document)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::DocumentProto*>(
      &::icing::lib::_DocumentProto_default_instance_);
}
inline ::icing::lib::DocumentProto* SearchResultProto_ResultProto::release_document() {
  // @@protoc_insertion_point(field_release:icing.lib.SearchResultProto.ResultProto.document)
  _has_bits_[0] &= ~0x00000001u;
  ::icing::lib::DocumentProto* temp = document_;
  document_ = nullptr;
  return temp;
}
inline ::icing::lib::DocumentProto* SearchResultProto_ResultProto::mutable_document() {
  _has_bits_[0] |= 0x00000001u;
  if (document_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::DocumentProto>(GetArenaNoVirtual());
    document_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.SearchResultProto.ResultProto.document)
  return document_;
}
inline void SearchResultProto_ResultProto::set_allocated_document(::icing::lib::DocumentProto* document) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(document_);
  }
  if (document) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      document = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, document, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  document_ = document;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.SearchResultProto.ResultProto.document)
}

// optional .icing.lib.SnippetProto snippet = 2;
inline bool SearchResultProto_ResultProto::has_snippet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchResultProto_ResultProto::clear_snippet() {
  if (snippet_ != nullptr) snippet_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::icing::lib::SnippetProto& SearchResultProto_ResultProto::snippet() const {
  const ::icing::lib::SnippetProto* p = snippet_;
  // @@protoc_insertion_point(field_get:icing.lib.SearchResultProto.ResultProto.snippet)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::SnippetProto*>(
      &::icing::lib::_SnippetProto_default_instance_);
}
inline ::icing::lib::SnippetProto* SearchResultProto_ResultProto::release_snippet() {
  // @@protoc_insertion_point(field_release:icing.lib.SearchResultProto.ResultProto.snippet)
  _has_bits_[0] &= ~0x00000002u;
  ::icing::lib::SnippetProto* temp = snippet_;
  snippet_ = nullptr;
  return temp;
}
inline ::icing::lib::SnippetProto* SearchResultProto_ResultProto::mutable_snippet() {
  _has_bits_[0] |= 0x00000002u;
  if (snippet_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::SnippetProto>(GetArenaNoVirtual());
    snippet_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.SearchResultProto.ResultProto.snippet)
  return snippet_;
}
inline void SearchResultProto_ResultProto::set_allocated_snippet(::icing::lib::SnippetProto* snippet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete snippet_;
  }
  if (snippet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      snippet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, snippet, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  snippet_ = snippet;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.SearchResultProto.ResultProto.snippet)
}

// optional double score = 3;
inline bool SearchResultProto_ResultProto::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SearchResultProto_ResultProto::clear_score() {
  score_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double SearchResultProto_ResultProto::score() const {
  // @@protoc_insertion_point(field_get:icing.lib.SearchResultProto.ResultProto.score)
  return score_;
}
inline void SearchResultProto_ResultProto::set_score(double value) {
  _has_bits_[0] |= 0x00000004u;
  score_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.SearchResultProto.ResultProto.score)
}

// -------------------------------------------------------------------

// SearchResultProto_DebugInfoProto

// optional string executed_query = 3;
inline bool SearchResultProto_DebugInfoProto::has_executed_query() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchResultProto_DebugInfoProto::clear_executed_query() {
  executed_query_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SearchResultProto_DebugInfoProto::executed_query() const {
  // @@protoc_insertion_point(field_get:icing.lib.SearchResultProto.DebugInfoProto.executed_query)
  return executed_query_.GetNoArena();
}
inline void SearchResultProto_DebugInfoProto::set_executed_query(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  executed_query_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:icing.lib.SearchResultProto.DebugInfoProto.executed_query)
}
inline void SearchResultProto_DebugInfoProto::set_executed_query(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  executed_query_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:icing.lib.SearchResultProto.DebugInfoProto.executed_query)
}
inline void SearchResultProto_DebugInfoProto::set_executed_query(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  executed_query_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:icing.lib.SearchResultProto.DebugInfoProto.executed_query)
}
inline void SearchResultProto_DebugInfoProto::set_executed_query(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  executed_query_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:icing.lib.SearchResultProto.DebugInfoProto.executed_query)
}
inline std::string* SearchResultProto_DebugInfoProto::mutable_executed_query() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:icing.lib.SearchResultProto.DebugInfoProto.executed_query)
  return executed_query_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SearchResultProto_DebugInfoProto::release_executed_query() {
  // @@protoc_insertion_point(field_release:icing.lib.SearchResultProto.DebugInfoProto.executed_query)
  if (!has_executed_query()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return executed_query_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SearchResultProto_DebugInfoProto::set_allocated_executed_query(std::string* executed_query) {
  if (executed_query != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  executed_query_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), executed_query);
  // @@protoc_insertion_point(field_set_allocated:icing.lib.SearchResultProto.DebugInfoProto.executed_query)
}

// -------------------------------------------------------------------

// SearchResultProto

// optional .icing.lib.StatusProto status = 1;
inline bool SearchResultProto::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::icing::lib::StatusProto& SearchResultProto::status() const {
  const ::icing::lib::StatusProto* p = status_;
  // @@protoc_insertion_point(field_get:icing.lib.SearchResultProto.status)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::StatusProto*>(
      &::icing::lib::_StatusProto_default_instance_);
}
inline ::icing::lib::StatusProto* SearchResultProto::release_status() {
  // @@protoc_insertion_point(field_release:icing.lib.SearchResultProto.status)
  _has_bits_[0] &= ~0x00000001u;
  ::icing::lib::StatusProto* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::icing::lib::StatusProto* SearchResultProto::mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::StatusProto>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.SearchResultProto.status)
  return status_;
}
inline void SearchResultProto::set_allocated_status(::icing::lib::StatusProto* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.SearchResultProto.status)
}

// repeated .icing.lib.SearchResultProto.ResultProto results = 2;
inline int SearchResultProto::results_size() const {
  return results_.size();
}
inline void SearchResultProto::clear_results() {
  results_.Clear();
}
inline ::icing::lib::SearchResultProto_ResultProto* SearchResultProto::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:icing.lib.SearchResultProto.results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::SearchResultProto_ResultProto >*
SearchResultProto::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.SearchResultProto.results)
  return &results_;
}
inline const ::icing::lib::SearchResultProto_ResultProto& SearchResultProto::results(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.SearchResultProto.results)
  return results_.Get(index);
}
inline ::icing::lib::SearchResultProto_ResultProto* SearchResultProto::add_results() {
  // @@protoc_insertion_point(field_add:icing.lib.SearchResultProto.results)
  return results_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::SearchResultProto_ResultProto >&
SearchResultProto::results() const {
  // @@protoc_insertion_point(field_list:icing.lib.SearchResultProto.results)
  return results_;
}

// optional .icing.lib.SearchResultProto.DebugInfoProto debug_info = 3;
inline bool SearchResultProto::has_debug_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchResultProto::clear_debug_info() {
  if (debug_info_ != nullptr) debug_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::icing::lib::SearchResultProto_DebugInfoProto& SearchResultProto::debug_info() const {
  const ::icing::lib::SearchResultProto_DebugInfoProto* p = debug_info_;
  // @@protoc_insertion_point(field_get:icing.lib.SearchResultProto.debug_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::SearchResultProto_DebugInfoProto*>(
      &::icing::lib::_SearchResultProto_DebugInfoProto_default_instance_);
}
inline ::icing::lib::SearchResultProto_DebugInfoProto* SearchResultProto::release_debug_info() {
  // @@protoc_insertion_point(field_release:icing.lib.SearchResultProto.debug_info)
  _has_bits_[0] &= ~0x00000002u;
  ::icing::lib::SearchResultProto_DebugInfoProto* temp = debug_info_;
  debug_info_ = nullptr;
  return temp;
}
inline ::icing::lib::SearchResultProto_DebugInfoProto* SearchResultProto::mutable_debug_info() {
  _has_bits_[0] |= 0x00000002u;
  if (debug_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::SearchResultProto_DebugInfoProto>(GetArenaNoVirtual());
    debug_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.SearchResultProto.debug_info)
  return debug_info_;
}
inline void SearchResultProto::set_allocated_debug_info(::icing::lib::SearchResultProto_DebugInfoProto* debug_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete debug_info_;
  }
  if (debug_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      debug_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, debug_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  debug_info_ = debug_info;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.SearchResultProto.debug_info)
}

// optional uint64 next_page_token = 4;
inline bool SearchResultProto::has_next_page_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SearchResultProto::clear_next_page_token() {
  next_page_token_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SearchResultProto::next_page_token() const {
  // @@protoc_insertion_point(field_get:icing.lib.SearchResultProto.next_page_token)
  return next_page_token_;
}
inline void SearchResultProto::set_next_page_token(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  next_page_token_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.SearchResultProto.next_page_token)
}

// optional .icing.lib.QueryStatsProto query_stats = 5;
inline bool SearchResultProto::has_query_stats() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline const ::icing::lib::QueryStatsProto& SearchResultProto::query_stats() const {
  const ::icing::lib::QueryStatsProto* p = query_stats_;
  // @@protoc_insertion_point(field_get:icing.lib.SearchResultProto.query_stats)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::QueryStatsProto*>(
      &::icing::lib::_QueryStatsProto_default_instance_);
}
inline ::icing::lib::QueryStatsProto* SearchResultProto::release_query_stats() {
  // @@protoc_insertion_point(field_release:icing.lib.SearchResultProto.query_stats)
  _has_bits_[0] &= ~0x00000004u;
  ::icing::lib::QueryStatsProto* temp = query_stats_;
  query_stats_ = nullptr;
  return temp;
}
inline ::icing::lib::QueryStatsProto* SearchResultProto::mutable_query_stats() {
  _has_bits_[0] |= 0x00000004u;
  if (query_stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::QueryStatsProto>(GetArenaNoVirtual());
    query_stats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.SearchResultProto.query_stats)
  return query_stats_;
}
inline void SearchResultProto::set_allocated_query_stats(::icing::lib::QueryStatsProto* query_stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(query_stats_);
  }
  if (query_stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      query_stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query_stats, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  query_stats_ = query_stats;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.SearchResultProto.query_stats)
}

// -------------------------------------------------------------------

// TypePropertyMask

// optional string schema_type = 1;
inline bool TypePropertyMask::has_schema_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TypePropertyMask::clear_schema_type() {
  schema_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TypePropertyMask::schema_type() const {
  // @@protoc_insertion_point(field_get:icing.lib.TypePropertyMask.schema_type)
  return schema_type_.GetNoArena();
}
inline void TypePropertyMask::set_schema_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  schema_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:icing.lib.TypePropertyMask.schema_type)
}
inline void TypePropertyMask::set_schema_type(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  schema_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:icing.lib.TypePropertyMask.schema_type)
}
inline void TypePropertyMask::set_schema_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  schema_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:icing.lib.TypePropertyMask.schema_type)
}
inline void TypePropertyMask::set_schema_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  schema_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:icing.lib.TypePropertyMask.schema_type)
}
inline std::string* TypePropertyMask::mutable_schema_type() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:icing.lib.TypePropertyMask.schema_type)
  return schema_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TypePropertyMask::release_schema_type() {
  // @@protoc_insertion_point(field_release:icing.lib.TypePropertyMask.schema_type)
  if (!has_schema_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return schema_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TypePropertyMask::set_allocated_schema_type(std::string* schema_type) {
  if (schema_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  schema_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), schema_type);
  // @@protoc_insertion_point(field_set_allocated:icing.lib.TypePropertyMask.schema_type)
}

// repeated string paths = 2;
inline int TypePropertyMask::paths_size() const {
  return paths_.size();
}
inline void TypePropertyMask::clear_paths() {
  paths_.Clear();
}
inline const std::string& TypePropertyMask::paths(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.TypePropertyMask.paths)
  return paths_.Get(index);
}
inline std::string* TypePropertyMask::mutable_paths(int index) {
  // @@protoc_insertion_point(field_mutable:icing.lib.TypePropertyMask.paths)
  return paths_.Mutable(index);
}
inline void TypePropertyMask::set_paths(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:icing.lib.TypePropertyMask.paths)
  paths_.Mutable(index)->assign(value);
}
inline void TypePropertyMask::set_paths(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:icing.lib.TypePropertyMask.paths)
  paths_.Mutable(index)->assign(std::move(value));
}
inline void TypePropertyMask::set_paths(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  paths_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:icing.lib.TypePropertyMask.paths)
}
inline void TypePropertyMask::set_paths(int index, const char* value, size_t size) {
  paths_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:icing.lib.TypePropertyMask.paths)
}
inline std::string* TypePropertyMask::add_paths() {
  // @@protoc_insertion_point(field_add_mutable:icing.lib.TypePropertyMask.paths)
  return paths_.Add();
}
inline void TypePropertyMask::add_paths(const std::string& value) {
  paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:icing.lib.TypePropertyMask.paths)
}
inline void TypePropertyMask::add_paths(std::string&& value) {
  paths_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:icing.lib.TypePropertyMask.paths)
}
inline void TypePropertyMask::add_paths(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:icing.lib.TypePropertyMask.paths)
}
inline void TypePropertyMask::add_paths(const char* value, size_t size) {
  paths_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:icing.lib.TypePropertyMask.paths)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TypePropertyMask::paths() const {
  // @@protoc_insertion_point(field_list:icing.lib.TypePropertyMask.paths)
  return paths_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TypePropertyMask::mutable_paths() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.TypePropertyMask.paths)
  return &paths_;
}

// -------------------------------------------------------------------

// GetResultSpecProto

// repeated .icing.lib.TypePropertyMask type_property_masks = 1;
inline int GetResultSpecProto::type_property_masks_size() const {
  return type_property_masks_.size();
}
inline void GetResultSpecProto::clear_type_property_masks() {
  type_property_masks_.Clear();
}
inline ::icing::lib::TypePropertyMask* GetResultSpecProto::mutable_type_property_masks(int index) {
  // @@protoc_insertion_point(field_mutable:icing.lib.GetResultSpecProto.type_property_masks)
  return type_property_masks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::TypePropertyMask >*
GetResultSpecProto::mutable_type_property_masks() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.GetResultSpecProto.type_property_masks)
  return &type_property_masks_;
}
inline const ::icing::lib::TypePropertyMask& GetResultSpecProto::type_property_masks(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.GetResultSpecProto.type_property_masks)
  return type_property_masks_.Get(index);
}
inline ::icing::lib::TypePropertyMask* GetResultSpecProto::add_type_property_masks() {
  // @@protoc_insertion_point(field_add:icing.lib.GetResultSpecProto.type_property_masks)
  return type_property_masks_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::TypePropertyMask >&
GetResultSpecProto::type_property_masks() const {
  // @@protoc_insertion_point(field_list:icing.lib.GetResultSpecProto.type_property_masks)
  return type_property_masks_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace lib
}  // namespace icing

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_icing_2fproto_2fsearch_2eproto
