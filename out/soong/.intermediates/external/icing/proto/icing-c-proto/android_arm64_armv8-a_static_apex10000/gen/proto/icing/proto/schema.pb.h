// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: icing/proto/schema.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_icing_2fproto_2fschema_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_icing_2fproto_2fschema_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "icing/proto/status.pb.h"
#include "icing/proto/term.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_icing_2fproto_2fschema_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_icing_2fproto_2fschema_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace icing {
namespace lib {
class DocumentIndexingConfig;
class DocumentIndexingConfigDefaultTypeInternal;
extern DocumentIndexingConfigDefaultTypeInternal _DocumentIndexingConfig_default_instance_;
class GetSchemaResultProto;
class GetSchemaResultProtoDefaultTypeInternal;
extern GetSchemaResultProtoDefaultTypeInternal _GetSchemaResultProto_default_instance_;
class GetSchemaTypeResultProto;
class GetSchemaTypeResultProtoDefaultTypeInternal;
extern GetSchemaTypeResultProtoDefaultTypeInternal _GetSchemaTypeResultProto_default_instance_;
class PropertyConfigProto;
class PropertyConfigProtoDefaultTypeInternal;
extern PropertyConfigProtoDefaultTypeInternal _PropertyConfigProto_default_instance_;
class PropertyConfigProto_Cardinality;
class PropertyConfigProto_CardinalityDefaultTypeInternal;
extern PropertyConfigProto_CardinalityDefaultTypeInternal _PropertyConfigProto_Cardinality_default_instance_;
class PropertyConfigProto_DataType;
class PropertyConfigProto_DataTypeDefaultTypeInternal;
extern PropertyConfigProto_DataTypeDefaultTypeInternal _PropertyConfigProto_DataType_default_instance_;
class SchemaProto;
class SchemaProtoDefaultTypeInternal;
extern SchemaProtoDefaultTypeInternal _SchemaProto_default_instance_;
class SchemaTypeConfigProto;
class SchemaTypeConfigProtoDefaultTypeInternal;
extern SchemaTypeConfigProtoDefaultTypeInternal _SchemaTypeConfigProto_default_instance_;
class SetSchemaResultProto;
class SetSchemaResultProtoDefaultTypeInternal;
extern SetSchemaResultProtoDefaultTypeInternal _SetSchemaResultProto_default_instance_;
class StringIndexingConfig;
class StringIndexingConfigDefaultTypeInternal;
extern StringIndexingConfigDefaultTypeInternal _StringIndexingConfig_default_instance_;
class StringIndexingConfig_TokenizerType;
class StringIndexingConfig_TokenizerTypeDefaultTypeInternal;
extern StringIndexingConfig_TokenizerTypeDefaultTypeInternal _StringIndexingConfig_TokenizerType_default_instance_;
}  // namespace lib
}  // namespace icing
PROTOBUF_NAMESPACE_OPEN
template<> ::icing::lib::DocumentIndexingConfig* Arena::CreateMaybeMessage<::icing::lib::DocumentIndexingConfig>(Arena*);
template<> ::icing::lib::GetSchemaResultProto* Arena::CreateMaybeMessage<::icing::lib::GetSchemaResultProto>(Arena*);
template<> ::icing::lib::GetSchemaTypeResultProto* Arena::CreateMaybeMessage<::icing::lib::GetSchemaTypeResultProto>(Arena*);
template<> ::icing::lib::PropertyConfigProto* Arena::CreateMaybeMessage<::icing::lib::PropertyConfigProto>(Arena*);
template<> ::icing::lib::PropertyConfigProto_Cardinality* Arena::CreateMaybeMessage<::icing::lib::PropertyConfigProto_Cardinality>(Arena*);
template<> ::icing::lib::PropertyConfigProto_DataType* Arena::CreateMaybeMessage<::icing::lib::PropertyConfigProto_DataType>(Arena*);
template<> ::icing::lib::SchemaProto* Arena::CreateMaybeMessage<::icing::lib::SchemaProto>(Arena*);
template<> ::icing::lib::SchemaTypeConfigProto* Arena::CreateMaybeMessage<::icing::lib::SchemaTypeConfigProto>(Arena*);
template<> ::icing::lib::SetSchemaResultProto* Arena::CreateMaybeMessage<::icing::lib::SetSchemaResultProto>(Arena*);
template<> ::icing::lib::StringIndexingConfig* Arena::CreateMaybeMessage<::icing::lib::StringIndexingConfig>(Arena*);
template<> ::icing::lib::StringIndexingConfig_TokenizerType* Arena::CreateMaybeMessage<::icing::lib::StringIndexingConfig_TokenizerType>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace icing {
namespace lib {

enum StringIndexingConfig_TokenizerType_Code : int {
  StringIndexingConfig_TokenizerType_Code_NONE = 0,
  StringIndexingConfig_TokenizerType_Code_PLAIN = 1
};
bool StringIndexingConfig_TokenizerType_Code_IsValid(int value);
constexpr StringIndexingConfig_TokenizerType_Code StringIndexingConfig_TokenizerType_Code_Code_MIN = StringIndexingConfig_TokenizerType_Code_NONE;
constexpr StringIndexingConfig_TokenizerType_Code StringIndexingConfig_TokenizerType_Code_Code_MAX = StringIndexingConfig_TokenizerType_Code_PLAIN;
constexpr int StringIndexingConfig_TokenizerType_Code_Code_ARRAYSIZE = StringIndexingConfig_TokenizerType_Code_Code_MAX + 1;

const std::string& StringIndexingConfig_TokenizerType_Code_Name(StringIndexingConfig_TokenizerType_Code value);
template<typename T>
inline const std::string& StringIndexingConfig_TokenizerType_Code_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StringIndexingConfig_TokenizerType_Code>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StringIndexingConfig_TokenizerType_Code_Name.");
  return StringIndexingConfig_TokenizerType_Code_Name(static_cast<StringIndexingConfig_TokenizerType_Code>(enum_t_value));
}
bool StringIndexingConfig_TokenizerType_Code_Parse(
    const std::string& name, StringIndexingConfig_TokenizerType_Code* value);
enum PropertyConfigProto_DataType_Code : int {
  PropertyConfigProto_DataType_Code_UNKNOWN = 0,
  PropertyConfigProto_DataType_Code_STRING = 1,
  PropertyConfigProto_DataType_Code_INT64 = 2,
  PropertyConfigProto_DataType_Code_DOUBLE = 3,
  PropertyConfigProto_DataType_Code_BOOLEAN = 4,
  PropertyConfigProto_DataType_Code_BYTES = 5,
  PropertyConfigProto_DataType_Code_DOCUMENT = 6
};
bool PropertyConfigProto_DataType_Code_IsValid(int value);
constexpr PropertyConfigProto_DataType_Code PropertyConfigProto_DataType_Code_Code_MIN = PropertyConfigProto_DataType_Code_UNKNOWN;
constexpr PropertyConfigProto_DataType_Code PropertyConfigProto_DataType_Code_Code_MAX = PropertyConfigProto_DataType_Code_DOCUMENT;
constexpr int PropertyConfigProto_DataType_Code_Code_ARRAYSIZE = PropertyConfigProto_DataType_Code_Code_MAX + 1;

const std::string& PropertyConfigProto_DataType_Code_Name(PropertyConfigProto_DataType_Code value);
template<typename T>
inline const std::string& PropertyConfigProto_DataType_Code_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PropertyConfigProto_DataType_Code>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PropertyConfigProto_DataType_Code_Name.");
  return PropertyConfigProto_DataType_Code_Name(static_cast<PropertyConfigProto_DataType_Code>(enum_t_value));
}
bool PropertyConfigProto_DataType_Code_Parse(
    const std::string& name, PropertyConfigProto_DataType_Code* value);
enum PropertyConfigProto_Cardinality_Code : int {
  PropertyConfigProto_Cardinality_Code_UNKNOWN = 0,
  PropertyConfigProto_Cardinality_Code_REPEATED = 1,
  PropertyConfigProto_Cardinality_Code_OPTIONAL = 2,
  PropertyConfigProto_Cardinality_Code_REQUIRED = 3
};
bool PropertyConfigProto_Cardinality_Code_IsValid(int value);
constexpr PropertyConfigProto_Cardinality_Code PropertyConfigProto_Cardinality_Code_Code_MIN = PropertyConfigProto_Cardinality_Code_UNKNOWN;
constexpr PropertyConfigProto_Cardinality_Code PropertyConfigProto_Cardinality_Code_Code_MAX = PropertyConfigProto_Cardinality_Code_REQUIRED;
constexpr int PropertyConfigProto_Cardinality_Code_Code_ARRAYSIZE = PropertyConfigProto_Cardinality_Code_Code_MAX + 1;

const std::string& PropertyConfigProto_Cardinality_Code_Name(PropertyConfigProto_Cardinality_Code value);
template<typename T>
inline const std::string& PropertyConfigProto_Cardinality_Code_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PropertyConfigProto_Cardinality_Code>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PropertyConfigProto_Cardinality_Code_Name.");
  return PropertyConfigProto_Cardinality_Code_Name(static_cast<PropertyConfigProto_Cardinality_Code>(enum_t_value));
}
bool PropertyConfigProto_Cardinality_Code_Parse(
    const std::string& name, PropertyConfigProto_Cardinality_Code* value);
// ===================================================================

class SchemaTypeConfigProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.SchemaTypeConfigProto) */ {
 public:
  SchemaTypeConfigProto();
  virtual ~SchemaTypeConfigProto();

  SchemaTypeConfigProto(const SchemaTypeConfigProto& from);
  SchemaTypeConfigProto(SchemaTypeConfigProto&& from) noexcept
    : SchemaTypeConfigProto() {
    *this = ::std::move(from);
  }

  inline SchemaTypeConfigProto& operator=(const SchemaTypeConfigProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaTypeConfigProto& operator=(SchemaTypeConfigProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SchemaTypeConfigProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SchemaTypeConfigProto* internal_default_instance() {
    return reinterpret_cast<const SchemaTypeConfigProto*>(
               &_SchemaTypeConfigProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SchemaTypeConfigProto& a, SchemaTypeConfigProto& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaTypeConfigProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SchemaTypeConfigProto* New() const final {
    return CreateMaybeMessage<SchemaTypeConfigProto>(nullptr);
  }

  SchemaTypeConfigProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SchemaTypeConfigProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SchemaTypeConfigProto& from);
  void MergeFrom(const SchemaTypeConfigProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchemaTypeConfigProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.SchemaTypeConfigProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 4,
    kSchemaTypeFieldNumber = 1,
    kVersionFieldNumber = 5,
  };
  // repeated .icing.lib.PropertyConfigProto properties = 4;
  int properties_size() const;
  void clear_properties();
  ::icing::lib::PropertyConfigProto* mutable_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::PropertyConfigProto >*
      mutable_properties();
  const ::icing::lib::PropertyConfigProto& properties(int index) const;
  ::icing::lib::PropertyConfigProto* add_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::PropertyConfigProto >&
      properties() const;

  // optional string schema_type = 1;
  bool has_schema_type() const;
  void clear_schema_type();
  const std::string& schema_type() const;
  void set_schema_type(const std::string& value);
  void set_schema_type(std::string&& value);
  void set_schema_type(const char* value);
  void set_schema_type(const char* value, size_t size);
  std::string* mutable_schema_type();
  std::string* release_schema_type();
  void set_allocated_schema_type(std::string* schema_type);

  // optional int32 version = 5;
  bool has_version() const;
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:icing.lib.SchemaTypeConfigProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::PropertyConfigProto > properties_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 version_;
  friend struct ::TableStruct_icing_2fproto_2fschema_2eproto;
};
// -------------------------------------------------------------------

class StringIndexingConfig_TokenizerType :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.StringIndexingConfig.TokenizerType) */ {
 public:
  StringIndexingConfig_TokenizerType();
  virtual ~StringIndexingConfig_TokenizerType();

  StringIndexingConfig_TokenizerType(const StringIndexingConfig_TokenizerType& from);
  StringIndexingConfig_TokenizerType(StringIndexingConfig_TokenizerType&& from) noexcept
    : StringIndexingConfig_TokenizerType() {
    *this = ::std::move(from);
  }

  inline StringIndexingConfig_TokenizerType& operator=(const StringIndexingConfig_TokenizerType& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringIndexingConfig_TokenizerType& operator=(StringIndexingConfig_TokenizerType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const StringIndexingConfig_TokenizerType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StringIndexingConfig_TokenizerType* internal_default_instance() {
    return reinterpret_cast<const StringIndexingConfig_TokenizerType*>(
               &_StringIndexingConfig_TokenizerType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(StringIndexingConfig_TokenizerType& a, StringIndexingConfig_TokenizerType& b) {
    a.Swap(&b);
  }
  inline void Swap(StringIndexingConfig_TokenizerType* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StringIndexingConfig_TokenizerType* New() const final {
    return CreateMaybeMessage<StringIndexingConfig_TokenizerType>(nullptr);
  }

  StringIndexingConfig_TokenizerType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StringIndexingConfig_TokenizerType>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const StringIndexingConfig_TokenizerType& from);
  void MergeFrom(const StringIndexingConfig_TokenizerType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StringIndexingConfig_TokenizerType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.StringIndexingConfig.TokenizerType";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef StringIndexingConfig_TokenizerType_Code Code;
  static constexpr Code NONE =
    StringIndexingConfig_TokenizerType_Code_NONE;
  static constexpr Code PLAIN =
    StringIndexingConfig_TokenizerType_Code_PLAIN;
  static inline bool Code_IsValid(int value) {
    return StringIndexingConfig_TokenizerType_Code_IsValid(value);
  }
  static constexpr Code Code_MIN =
    StringIndexingConfig_TokenizerType_Code_Code_MIN;
  static constexpr Code Code_MAX =
    StringIndexingConfig_TokenizerType_Code_Code_MAX;
  static constexpr int Code_ARRAYSIZE =
    StringIndexingConfig_TokenizerType_Code_Code_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Code_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Code>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Code_Name.");
    return StringIndexingConfig_TokenizerType_Code_Name(enum_t_value);
  }
  static inline bool Code_Parse(const std::string& name,
      Code* value) {
    return StringIndexingConfig_TokenizerType_Code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:icing.lib.StringIndexingConfig.TokenizerType)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_icing_2fproto_2fschema_2eproto;
};
// -------------------------------------------------------------------

class StringIndexingConfig :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.StringIndexingConfig) */ {
 public:
  StringIndexingConfig();
  virtual ~StringIndexingConfig();

  StringIndexingConfig(const StringIndexingConfig& from);
  StringIndexingConfig(StringIndexingConfig&& from) noexcept
    : StringIndexingConfig() {
    *this = ::std::move(from);
  }

  inline StringIndexingConfig& operator=(const StringIndexingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringIndexingConfig& operator=(StringIndexingConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const StringIndexingConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StringIndexingConfig* internal_default_instance() {
    return reinterpret_cast<const StringIndexingConfig*>(
               &_StringIndexingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StringIndexingConfig& a, StringIndexingConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(StringIndexingConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StringIndexingConfig* New() const final {
    return CreateMaybeMessage<StringIndexingConfig>(nullptr);
  }

  StringIndexingConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StringIndexingConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const StringIndexingConfig& from);
  void MergeFrom(const StringIndexingConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StringIndexingConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.StringIndexingConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef StringIndexingConfig_TokenizerType TokenizerType;

  // accessors -------------------------------------------------------

  enum : int {
    kTermMatchTypeFieldNumber = 1,
    kTokenizerTypeFieldNumber = 2,
  };
  // optional .icing.lib.TermMatchType.Code term_match_type = 1;
  bool has_term_match_type() const;
  void clear_term_match_type();
  ::icing::lib::TermMatchType_Code term_match_type() const;
  void set_term_match_type(::icing::lib::TermMatchType_Code value);

  // optional .icing.lib.StringIndexingConfig.TokenizerType.Code tokenizer_type = 2;
  bool has_tokenizer_type() const;
  void clear_tokenizer_type();
  ::icing::lib::StringIndexingConfig_TokenizerType_Code tokenizer_type() const;
  void set_tokenizer_type(::icing::lib::StringIndexingConfig_TokenizerType_Code value);

  // @@protoc_insertion_point(class_scope:icing.lib.StringIndexingConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int term_match_type_;
  int tokenizer_type_;
  friend struct ::TableStruct_icing_2fproto_2fschema_2eproto;
};
// -------------------------------------------------------------------

class DocumentIndexingConfig :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.DocumentIndexingConfig) */ {
 public:
  DocumentIndexingConfig();
  virtual ~DocumentIndexingConfig();

  DocumentIndexingConfig(const DocumentIndexingConfig& from);
  DocumentIndexingConfig(DocumentIndexingConfig&& from) noexcept
    : DocumentIndexingConfig() {
    *this = ::std::move(from);
  }

  inline DocumentIndexingConfig& operator=(const DocumentIndexingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentIndexingConfig& operator=(DocumentIndexingConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DocumentIndexingConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DocumentIndexingConfig* internal_default_instance() {
    return reinterpret_cast<const DocumentIndexingConfig*>(
               &_DocumentIndexingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DocumentIndexingConfig& a, DocumentIndexingConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentIndexingConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DocumentIndexingConfig* New() const final {
    return CreateMaybeMessage<DocumentIndexingConfig>(nullptr);
  }

  DocumentIndexingConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DocumentIndexingConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DocumentIndexingConfig& from);
  void MergeFrom(const DocumentIndexingConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DocumentIndexingConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.DocumentIndexingConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexNestedPropertiesFieldNumber = 1,
  };
  // optional bool index_nested_properties = 1;
  bool has_index_nested_properties() const;
  void clear_index_nested_properties();
  bool index_nested_properties() const;
  void set_index_nested_properties(bool value);

  // @@protoc_insertion_point(class_scope:icing.lib.DocumentIndexingConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool index_nested_properties_;
  friend struct ::TableStruct_icing_2fproto_2fschema_2eproto;
};
// -------------------------------------------------------------------

class PropertyConfigProto_DataType :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.PropertyConfigProto.DataType) */ {
 public:
  PropertyConfigProto_DataType();
  virtual ~PropertyConfigProto_DataType();

  PropertyConfigProto_DataType(const PropertyConfigProto_DataType& from);
  PropertyConfigProto_DataType(PropertyConfigProto_DataType&& from) noexcept
    : PropertyConfigProto_DataType() {
    *this = ::std::move(from);
  }

  inline PropertyConfigProto_DataType& operator=(const PropertyConfigProto_DataType& from) {
    CopyFrom(from);
    return *this;
  }
  inline PropertyConfigProto_DataType& operator=(PropertyConfigProto_DataType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PropertyConfigProto_DataType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PropertyConfigProto_DataType* internal_default_instance() {
    return reinterpret_cast<const PropertyConfigProto_DataType*>(
               &_PropertyConfigProto_DataType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PropertyConfigProto_DataType& a, PropertyConfigProto_DataType& b) {
    a.Swap(&b);
  }
  inline void Swap(PropertyConfigProto_DataType* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PropertyConfigProto_DataType* New() const final {
    return CreateMaybeMessage<PropertyConfigProto_DataType>(nullptr);
  }

  PropertyConfigProto_DataType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PropertyConfigProto_DataType>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PropertyConfigProto_DataType& from);
  void MergeFrom(const PropertyConfigProto_DataType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PropertyConfigProto_DataType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.PropertyConfigProto.DataType";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PropertyConfigProto_DataType_Code Code;
  static constexpr Code UNKNOWN =
    PropertyConfigProto_DataType_Code_UNKNOWN;
  static constexpr Code STRING =
    PropertyConfigProto_DataType_Code_STRING;
  static constexpr Code INT64 =
    PropertyConfigProto_DataType_Code_INT64;
  static constexpr Code DOUBLE =
    PropertyConfigProto_DataType_Code_DOUBLE;
  static constexpr Code BOOLEAN =
    PropertyConfigProto_DataType_Code_BOOLEAN;
  static constexpr Code BYTES =
    PropertyConfigProto_DataType_Code_BYTES;
  static constexpr Code DOCUMENT =
    PropertyConfigProto_DataType_Code_DOCUMENT;
  static inline bool Code_IsValid(int value) {
    return PropertyConfigProto_DataType_Code_IsValid(value);
  }
  static constexpr Code Code_MIN =
    PropertyConfigProto_DataType_Code_Code_MIN;
  static constexpr Code Code_MAX =
    PropertyConfigProto_DataType_Code_Code_MAX;
  static constexpr int Code_ARRAYSIZE =
    PropertyConfigProto_DataType_Code_Code_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Code_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Code>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Code_Name.");
    return PropertyConfigProto_DataType_Code_Name(enum_t_value);
  }
  static inline bool Code_Parse(const std::string& name,
      Code* value) {
    return PropertyConfigProto_DataType_Code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:icing.lib.PropertyConfigProto.DataType)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_icing_2fproto_2fschema_2eproto;
};
// -------------------------------------------------------------------

class PropertyConfigProto_Cardinality :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.PropertyConfigProto.Cardinality) */ {
 public:
  PropertyConfigProto_Cardinality();
  virtual ~PropertyConfigProto_Cardinality();

  PropertyConfigProto_Cardinality(const PropertyConfigProto_Cardinality& from);
  PropertyConfigProto_Cardinality(PropertyConfigProto_Cardinality&& from) noexcept
    : PropertyConfigProto_Cardinality() {
    *this = ::std::move(from);
  }

  inline PropertyConfigProto_Cardinality& operator=(const PropertyConfigProto_Cardinality& from) {
    CopyFrom(from);
    return *this;
  }
  inline PropertyConfigProto_Cardinality& operator=(PropertyConfigProto_Cardinality&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PropertyConfigProto_Cardinality& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PropertyConfigProto_Cardinality* internal_default_instance() {
    return reinterpret_cast<const PropertyConfigProto_Cardinality*>(
               &_PropertyConfigProto_Cardinality_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PropertyConfigProto_Cardinality& a, PropertyConfigProto_Cardinality& b) {
    a.Swap(&b);
  }
  inline void Swap(PropertyConfigProto_Cardinality* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PropertyConfigProto_Cardinality* New() const final {
    return CreateMaybeMessage<PropertyConfigProto_Cardinality>(nullptr);
  }

  PropertyConfigProto_Cardinality* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PropertyConfigProto_Cardinality>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PropertyConfigProto_Cardinality& from);
  void MergeFrom(const PropertyConfigProto_Cardinality& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PropertyConfigProto_Cardinality* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.PropertyConfigProto.Cardinality";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PropertyConfigProto_Cardinality_Code Code;
  static constexpr Code UNKNOWN =
    PropertyConfigProto_Cardinality_Code_UNKNOWN;
  static constexpr Code REPEATED =
    PropertyConfigProto_Cardinality_Code_REPEATED;
  static constexpr Code OPTIONAL =
    PropertyConfigProto_Cardinality_Code_OPTIONAL;
  static constexpr Code REQUIRED =
    PropertyConfigProto_Cardinality_Code_REQUIRED;
  static inline bool Code_IsValid(int value) {
    return PropertyConfigProto_Cardinality_Code_IsValid(value);
  }
  static constexpr Code Code_MIN =
    PropertyConfigProto_Cardinality_Code_Code_MIN;
  static constexpr Code Code_MAX =
    PropertyConfigProto_Cardinality_Code_Code_MAX;
  static constexpr int Code_ARRAYSIZE =
    PropertyConfigProto_Cardinality_Code_Code_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Code_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Code>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Code_Name.");
    return PropertyConfigProto_Cardinality_Code_Name(enum_t_value);
  }
  static inline bool Code_Parse(const std::string& name,
      Code* value) {
    return PropertyConfigProto_Cardinality_Code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:icing.lib.PropertyConfigProto.Cardinality)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_icing_2fproto_2fschema_2eproto;
};
// -------------------------------------------------------------------

class PropertyConfigProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.PropertyConfigProto) */ {
 public:
  PropertyConfigProto();
  virtual ~PropertyConfigProto();

  PropertyConfigProto(const PropertyConfigProto& from);
  PropertyConfigProto(PropertyConfigProto&& from) noexcept
    : PropertyConfigProto() {
    *this = ::std::move(from);
  }

  inline PropertyConfigProto& operator=(const PropertyConfigProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline PropertyConfigProto& operator=(PropertyConfigProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PropertyConfigProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PropertyConfigProto* internal_default_instance() {
    return reinterpret_cast<const PropertyConfigProto*>(
               &_PropertyConfigProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PropertyConfigProto& a, PropertyConfigProto& b) {
    a.Swap(&b);
  }
  inline void Swap(PropertyConfigProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PropertyConfigProto* New() const final {
    return CreateMaybeMessage<PropertyConfigProto>(nullptr);
  }

  PropertyConfigProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PropertyConfigProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PropertyConfigProto& from);
  void MergeFrom(const PropertyConfigProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PropertyConfigProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.PropertyConfigProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PropertyConfigProto_DataType DataType;
  typedef PropertyConfigProto_Cardinality Cardinality;

  // accessors -------------------------------------------------------

  enum : int {
    kPropertyNameFieldNumber = 1,
    kSchemaTypeFieldNumber = 3,
    kStringIndexingConfigFieldNumber = 5,
    kDocumentIndexingConfigFieldNumber = 6,
    kDataTypeFieldNumber = 2,
    kCardinalityFieldNumber = 4,
  };
  // optional string property_name = 1;
  bool has_property_name() const;
  void clear_property_name();
  const std::string& property_name() const;
  void set_property_name(const std::string& value);
  void set_property_name(std::string&& value);
  void set_property_name(const char* value);
  void set_property_name(const char* value, size_t size);
  std::string* mutable_property_name();
  std::string* release_property_name();
  void set_allocated_property_name(std::string* property_name);

  // optional string schema_type = 3;
  bool has_schema_type() const;
  void clear_schema_type();
  const std::string& schema_type() const;
  void set_schema_type(const std::string& value);
  void set_schema_type(std::string&& value);
  void set_schema_type(const char* value);
  void set_schema_type(const char* value, size_t size);
  std::string* mutable_schema_type();
  std::string* release_schema_type();
  void set_allocated_schema_type(std::string* schema_type);

  // optional .icing.lib.StringIndexingConfig string_indexing_config = 5;
  bool has_string_indexing_config() const;
  void clear_string_indexing_config();
  const ::icing::lib::StringIndexingConfig& string_indexing_config() const;
  ::icing::lib::StringIndexingConfig* release_string_indexing_config();
  ::icing::lib::StringIndexingConfig* mutable_string_indexing_config();
  void set_allocated_string_indexing_config(::icing::lib::StringIndexingConfig* string_indexing_config);

  // optional .icing.lib.DocumentIndexingConfig document_indexing_config = 6;
  bool has_document_indexing_config() const;
  void clear_document_indexing_config();
  const ::icing::lib::DocumentIndexingConfig& document_indexing_config() const;
  ::icing::lib::DocumentIndexingConfig* release_document_indexing_config();
  ::icing::lib::DocumentIndexingConfig* mutable_document_indexing_config();
  void set_allocated_document_indexing_config(::icing::lib::DocumentIndexingConfig* document_indexing_config);

  // optional .icing.lib.PropertyConfigProto.DataType.Code data_type = 2;
  bool has_data_type() const;
  void clear_data_type();
  ::icing::lib::PropertyConfigProto_DataType_Code data_type() const;
  void set_data_type(::icing::lib::PropertyConfigProto_DataType_Code value);

  // optional .icing.lib.PropertyConfigProto.Cardinality.Code cardinality = 4;
  bool has_cardinality() const;
  void clear_cardinality();
  ::icing::lib::PropertyConfigProto_Cardinality_Code cardinality() const;
  void set_cardinality(::icing::lib::PropertyConfigProto_Cardinality_Code value);

  // @@protoc_insertion_point(class_scope:icing.lib.PropertyConfigProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr property_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_type_;
  ::icing::lib::StringIndexingConfig* string_indexing_config_;
  ::icing::lib::DocumentIndexingConfig* document_indexing_config_;
  int data_type_;
  int cardinality_;
  friend struct ::TableStruct_icing_2fproto_2fschema_2eproto;
};
// -------------------------------------------------------------------

class SchemaProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.SchemaProto) */ {
 public:
  SchemaProto();
  virtual ~SchemaProto();

  SchemaProto(const SchemaProto& from);
  SchemaProto(SchemaProto&& from) noexcept
    : SchemaProto() {
    *this = ::std::move(from);
  }

  inline SchemaProto& operator=(const SchemaProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaProto& operator=(SchemaProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SchemaProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SchemaProto* internal_default_instance() {
    return reinterpret_cast<const SchemaProto*>(
               &_SchemaProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SchemaProto& a, SchemaProto& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SchemaProto* New() const final {
    return CreateMaybeMessage<SchemaProto>(nullptr);
  }

  SchemaProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SchemaProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SchemaProto& from);
  void MergeFrom(const SchemaProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchemaProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.SchemaProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypesFieldNumber = 1,
  };
  // repeated .icing.lib.SchemaTypeConfigProto types = 1;
  int types_size() const;
  void clear_types();
  ::icing::lib::SchemaTypeConfigProto* mutable_types(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::SchemaTypeConfigProto >*
      mutable_types();
  const ::icing::lib::SchemaTypeConfigProto& types(int index) const;
  ::icing::lib::SchemaTypeConfigProto* add_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::SchemaTypeConfigProto >&
      types() const;

  // @@protoc_insertion_point(class_scope:icing.lib.SchemaProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::SchemaTypeConfigProto > types_;
  friend struct ::TableStruct_icing_2fproto_2fschema_2eproto;
};
// -------------------------------------------------------------------

class SetSchemaResultProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.SetSchemaResultProto) */ {
 public:
  SetSchemaResultProto();
  virtual ~SetSchemaResultProto();

  SetSchemaResultProto(const SetSchemaResultProto& from);
  SetSchemaResultProto(SetSchemaResultProto&& from) noexcept
    : SetSchemaResultProto() {
    *this = ::std::move(from);
  }

  inline SetSchemaResultProto& operator=(const SetSchemaResultProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSchemaResultProto& operator=(SetSchemaResultProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SetSchemaResultProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetSchemaResultProto* internal_default_instance() {
    return reinterpret_cast<const SetSchemaResultProto*>(
               &_SetSchemaResultProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SetSchemaResultProto& a, SetSchemaResultProto& b) {
    a.Swap(&b);
  }
  inline void Swap(SetSchemaResultProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetSchemaResultProto* New() const final {
    return CreateMaybeMessage<SetSchemaResultProto>(nullptr);
  }

  SetSchemaResultProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetSchemaResultProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SetSchemaResultProto& from);
  void MergeFrom(const SetSchemaResultProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetSchemaResultProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.SetSchemaResultProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeletedSchemaTypesFieldNumber = 2,
    kIncompatibleSchemaTypesFieldNumber = 3,
    kNewSchemaTypesFieldNumber = 4,
    kFullyCompatibleChangedSchemaTypesFieldNumber = 5,
    kIndexIncompatibleChangedSchemaTypesFieldNumber = 6,
    kStatusFieldNumber = 1,
    kLatencyMsFieldNumber = 7,
  };
  // repeated string deleted_schema_types = 2;
  int deleted_schema_types_size() const;
  void clear_deleted_schema_types();
  const std::string& deleted_schema_types(int index) const;
  std::string* mutable_deleted_schema_types(int index);
  void set_deleted_schema_types(int index, const std::string& value);
  void set_deleted_schema_types(int index, std::string&& value);
  void set_deleted_schema_types(int index, const char* value);
  void set_deleted_schema_types(int index, const char* value, size_t size);
  std::string* add_deleted_schema_types();
  void add_deleted_schema_types(const std::string& value);
  void add_deleted_schema_types(std::string&& value);
  void add_deleted_schema_types(const char* value);
  void add_deleted_schema_types(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& deleted_schema_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_deleted_schema_types();

  // repeated string incompatible_schema_types = 3;
  int incompatible_schema_types_size() const;
  void clear_incompatible_schema_types();
  const std::string& incompatible_schema_types(int index) const;
  std::string* mutable_incompatible_schema_types(int index);
  void set_incompatible_schema_types(int index, const std::string& value);
  void set_incompatible_schema_types(int index, std::string&& value);
  void set_incompatible_schema_types(int index, const char* value);
  void set_incompatible_schema_types(int index, const char* value, size_t size);
  std::string* add_incompatible_schema_types();
  void add_incompatible_schema_types(const std::string& value);
  void add_incompatible_schema_types(std::string&& value);
  void add_incompatible_schema_types(const char* value);
  void add_incompatible_schema_types(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& incompatible_schema_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_incompatible_schema_types();

  // repeated string new_schema_types = 4;
  int new_schema_types_size() const;
  void clear_new_schema_types();
  const std::string& new_schema_types(int index) const;
  std::string* mutable_new_schema_types(int index);
  void set_new_schema_types(int index, const std::string& value);
  void set_new_schema_types(int index, std::string&& value);
  void set_new_schema_types(int index, const char* value);
  void set_new_schema_types(int index, const char* value, size_t size);
  std::string* add_new_schema_types();
  void add_new_schema_types(const std::string& value);
  void add_new_schema_types(std::string&& value);
  void add_new_schema_types(const char* value);
  void add_new_schema_types(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& new_schema_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_new_schema_types();

  // repeated string fully_compatible_changed_schema_types = 5;
  int fully_compatible_changed_schema_types_size() const;
  void clear_fully_compatible_changed_schema_types();
  const std::string& fully_compatible_changed_schema_types(int index) const;
  std::string* mutable_fully_compatible_changed_schema_types(int index);
  void set_fully_compatible_changed_schema_types(int index, const std::string& value);
  void set_fully_compatible_changed_schema_types(int index, std::string&& value);
  void set_fully_compatible_changed_schema_types(int index, const char* value);
  void set_fully_compatible_changed_schema_types(int index, const char* value, size_t size);
  std::string* add_fully_compatible_changed_schema_types();
  void add_fully_compatible_changed_schema_types(const std::string& value);
  void add_fully_compatible_changed_schema_types(std::string&& value);
  void add_fully_compatible_changed_schema_types(const char* value);
  void add_fully_compatible_changed_schema_types(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& fully_compatible_changed_schema_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_fully_compatible_changed_schema_types();

  // repeated string index_incompatible_changed_schema_types = 6;
  int index_incompatible_changed_schema_types_size() const;
  void clear_index_incompatible_changed_schema_types();
  const std::string& index_incompatible_changed_schema_types(int index) const;
  std::string* mutable_index_incompatible_changed_schema_types(int index);
  void set_index_incompatible_changed_schema_types(int index, const std::string& value);
  void set_index_incompatible_changed_schema_types(int index, std::string&& value);
  void set_index_incompatible_changed_schema_types(int index, const char* value);
  void set_index_incompatible_changed_schema_types(int index, const char* value, size_t size);
  std::string* add_index_incompatible_changed_schema_types();
  void add_index_incompatible_changed_schema_types(const std::string& value);
  void add_index_incompatible_changed_schema_types(std::string&& value);
  void add_index_incompatible_changed_schema_types(const char* value);
  void add_index_incompatible_changed_schema_types(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& index_incompatible_changed_schema_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_index_incompatible_changed_schema_types();

  // optional .icing.lib.StatusProto status = 1;
  bool has_status() const;
  void clear_status();
  const ::icing::lib::StatusProto& status() const;
  ::icing::lib::StatusProto* release_status();
  ::icing::lib::StatusProto* mutable_status();
  void set_allocated_status(::icing::lib::StatusProto* status);

  // optional int32 latency_ms = 7;
  bool has_latency_ms() const;
  void clear_latency_ms();
  ::PROTOBUF_NAMESPACE_ID::int32 latency_ms() const;
  void set_latency_ms(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:icing.lib.SetSchemaResultProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> deleted_schema_types_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> incompatible_schema_types_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> new_schema_types_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> fully_compatible_changed_schema_types_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> index_incompatible_changed_schema_types_;
  ::icing::lib::StatusProto* status_;
  ::PROTOBUF_NAMESPACE_ID::int32 latency_ms_;
  friend struct ::TableStruct_icing_2fproto_2fschema_2eproto;
};
// -------------------------------------------------------------------

class GetSchemaResultProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.GetSchemaResultProto) */ {
 public:
  GetSchemaResultProto();
  virtual ~GetSchemaResultProto();

  GetSchemaResultProto(const GetSchemaResultProto& from);
  GetSchemaResultProto(GetSchemaResultProto&& from) noexcept
    : GetSchemaResultProto() {
    *this = ::std::move(from);
  }

  inline GetSchemaResultProto& operator=(const GetSchemaResultProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSchemaResultProto& operator=(GetSchemaResultProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GetSchemaResultProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetSchemaResultProto* internal_default_instance() {
    return reinterpret_cast<const GetSchemaResultProto*>(
               &_GetSchemaResultProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetSchemaResultProto& a, GetSchemaResultProto& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSchemaResultProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetSchemaResultProto* New() const final {
    return CreateMaybeMessage<GetSchemaResultProto>(nullptr);
  }

  GetSchemaResultProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetSchemaResultProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const GetSchemaResultProto& from);
  void MergeFrom(const GetSchemaResultProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetSchemaResultProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.GetSchemaResultProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kSchemaFieldNumber = 2,
  };
  // optional .icing.lib.StatusProto status = 1;
  bool has_status() const;
  void clear_status();
  const ::icing::lib::StatusProto& status() const;
  ::icing::lib::StatusProto* release_status();
  ::icing::lib::StatusProto* mutable_status();
  void set_allocated_status(::icing::lib::StatusProto* status);

  // optional .icing.lib.SchemaProto schema = 2;
  bool has_schema() const;
  void clear_schema();
  const ::icing::lib::SchemaProto& schema() const;
  ::icing::lib::SchemaProto* release_schema();
  ::icing::lib::SchemaProto* mutable_schema();
  void set_allocated_schema(::icing::lib::SchemaProto* schema);

  // @@protoc_insertion_point(class_scope:icing.lib.GetSchemaResultProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::icing::lib::StatusProto* status_;
  ::icing::lib::SchemaProto* schema_;
  friend struct ::TableStruct_icing_2fproto_2fschema_2eproto;
};
// -------------------------------------------------------------------

class GetSchemaTypeResultProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:icing.lib.GetSchemaTypeResultProto) */ {
 public:
  GetSchemaTypeResultProto();
  virtual ~GetSchemaTypeResultProto();

  GetSchemaTypeResultProto(const GetSchemaTypeResultProto& from);
  GetSchemaTypeResultProto(GetSchemaTypeResultProto&& from) noexcept
    : GetSchemaTypeResultProto() {
    *this = ::std::move(from);
  }

  inline GetSchemaTypeResultProto& operator=(const GetSchemaTypeResultProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSchemaTypeResultProto& operator=(GetSchemaTypeResultProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GetSchemaTypeResultProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetSchemaTypeResultProto* internal_default_instance() {
    return reinterpret_cast<const GetSchemaTypeResultProto*>(
               &_GetSchemaTypeResultProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetSchemaTypeResultProto& a, GetSchemaTypeResultProto& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSchemaTypeResultProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetSchemaTypeResultProto* New() const final {
    return CreateMaybeMessage<GetSchemaTypeResultProto>(nullptr);
  }

  GetSchemaTypeResultProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetSchemaTypeResultProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const GetSchemaTypeResultProto& from);
  void MergeFrom(const GetSchemaTypeResultProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetSchemaTypeResultProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "icing.lib.GetSchemaTypeResultProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kSchemaTypeConfigFieldNumber = 2,
  };
  // optional .icing.lib.StatusProto status = 1;
  bool has_status() const;
  void clear_status();
  const ::icing::lib::StatusProto& status() const;
  ::icing::lib::StatusProto* release_status();
  ::icing::lib::StatusProto* mutable_status();
  void set_allocated_status(::icing::lib::StatusProto* status);

  // optional .icing.lib.SchemaTypeConfigProto schema_type_config = 2;
  bool has_schema_type_config() const;
  void clear_schema_type_config();
  const ::icing::lib::SchemaTypeConfigProto& schema_type_config() const;
  ::icing::lib::SchemaTypeConfigProto* release_schema_type_config();
  ::icing::lib::SchemaTypeConfigProto* mutable_schema_type_config();
  void set_allocated_schema_type_config(::icing::lib::SchemaTypeConfigProto* schema_type_config);

  // @@protoc_insertion_point(class_scope:icing.lib.GetSchemaTypeResultProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::icing::lib::StatusProto* status_;
  ::icing::lib::SchemaTypeConfigProto* schema_type_config_;
  friend struct ::TableStruct_icing_2fproto_2fschema_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SchemaTypeConfigProto

// optional string schema_type = 1;
inline bool SchemaTypeConfigProto::has_schema_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaTypeConfigProto::clear_schema_type() {
  schema_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchemaTypeConfigProto::schema_type() const {
  // @@protoc_insertion_point(field_get:icing.lib.SchemaTypeConfigProto.schema_type)
  return schema_type_.GetNoArena();
}
inline void SchemaTypeConfigProto::set_schema_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  schema_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:icing.lib.SchemaTypeConfigProto.schema_type)
}
inline void SchemaTypeConfigProto::set_schema_type(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  schema_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:icing.lib.SchemaTypeConfigProto.schema_type)
}
inline void SchemaTypeConfigProto::set_schema_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  schema_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:icing.lib.SchemaTypeConfigProto.schema_type)
}
inline void SchemaTypeConfigProto::set_schema_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  schema_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:icing.lib.SchemaTypeConfigProto.schema_type)
}
inline std::string* SchemaTypeConfigProto::mutable_schema_type() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:icing.lib.SchemaTypeConfigProto.schema_type)
  return schema_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SchemaTypeConfigProto::release_schema_type() {
  // @@protoc_insertion_point(field_release:icing.lib.SchemaTypeConfigProto.schema_type)
  if (!has_schema_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return schema_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SchemaTypeConfigProto::set_allocated_schema_type(std::string* schema_type) {
  if (schema_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  schema_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), schema_type);
  // @@protoc_insertion_point(field_set_allocated:icing.lib.SchemaTypeConfigProto.schema_type)
}

// repeated .icing.lib.PropertyConfigProto properties = 4;
inline int SchemaTypeConfigProto::properties_size() const {
  return properties_.size();
}
inline void SchemaTypeConfigProto::clear_properties() {
  properties_.Clear();
}
inline ::icing::lib::PropertyConfigProto* SchemaTypeConfigProto::mutable_properties(int index) {
  // @@protoc_insertion_point(field_mutable:icing.lib.SchemaTypeConfigProto.properties)
  return properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::PropertyConfigProto >*
SchemaTypeConfigProto::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.SchemaTypeConfigProto.properties)
  return &properties_;
}
inline const ::icing::lib::PropertyConfigProto& SchemaTypeConfigProto::properties(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.SchemaTypeConfigProto.properties)
  return properties_.Get(index);
}
inline ::icing::lib::PropertyConfigProto* SchemaTypeConfigProto::add_properties() {
  // @@protoc_insertion_point(field_add:icing.lib.SchemaTypeConfigProto.properties)
  return properties_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::PropertyConfigProto >&
SchemaTypeConfigProto::properties() const {
  // @@protoc_insertion_point(field_list:icing.lib.SchemaTypeConfigProto.properties)
  return properties_;
}

// optional int32 version = 5;
inline bool SchemaTypeConfigProto::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaTypeConfigProto::clear_version() {
  version_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchemaTypeConfigProto::version() const {
  // @@protoc_insertion_point(field_get:icing.lib.SchemaTypeConfigProto.version)
  return version_;
}
inline void SchemaTypeConfigProto::set_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  version_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.SchemaTypeConfigProto.version)
}

// -------------------------------------------------------------------

// StringIndexingConfig_TokenizerType

// -------------------------------------------------------------------

// StringIndexingConfig

// optional .icing.lib.TermMatchType.Code term_match_type = 1;
inline bool StringIndexingConfig::has_term_match_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StringIndexingConfig::clear_term_match_type() {
  term_match_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::icing::lib::TermMatchType_Code StringIndexingConfig::term_match_type() const {
  // @@protoc_insertion_point(field_get:icing.lib.StringIndexingConfig.term_match_type)
  return static_cast< ::icing::lib::TermMatchType_Code >(term_match_type_);
}
inline void StringIndexingConfig::set_term_match_type(::icing::lib::TermMatchType_Code value) {
  assert(::icing::lib::TermMatchType_Code_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  term_match_type_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.StringIndexingConfig.term_match_type)
}

// optional .icing.lib.StringIndexingConfig.TokenizerType.Code tokenizer_type = 2;
inline bool StringIndexingConfig::has_tokenizer_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StringIndexingConfig::clear_tokenizer_type() {
  tokenizer_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::icing::lib::StringIndexingConfig_TokenizerType_Code StringIndexingConfig::tokenizer_type() const {
  // @@protoc_insertion_point(field_get:icing.lib.StringIndexingConfig.tokenizer_type)
  return static_cast< ::icing::lib::StringIndexingConfig_TokenizerType_Code >(tokenizer_type_);
}
inline void StringIndexingConfig::set_tokenizer_type(::icing::lib::StringIndexingConfig_TokenizerType_Code value) {
  assert(::icing::lib::StringIndexingConfig_TokenizerType_Code_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  tokenizer_type_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.StringIndexingConfig.tokenizer_type)
}

// -------------------------------------------------------------------

// DocumentIndexingConfig

// optional bool index_nested_properties = 1;
inline bool DocumentIndexingConfig::has_index_nested_properties() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentIndexingConfig::clear_index_nested_properties() {
  index_nested_properties_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool DocumentIndexingConfig::index_nested_properties() const {
  // @@protoc_insertion_point(field_get:icing.lib.DocumentIndexingConfig.index_nested_properties)
  return index_nested_properties_;
}
inline void DocumentIndexingConfig::set_index_nested_properties(bool value) {
  _has_bits_[0] |= 0x00000001u;
  index_nested_properties_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.DocumentIndexingConfig.index_nested_properties)
}

// -------------------------------------------------------------------

// PropertyConfigProto_DataType

// -------------------------------------------------------------------

// PropertyConfigProto_Cardinality

// -------------------------------------------------------------------

// PropertyConfigProto

// optional string property_name = 1;
inline bool PropertyConfigProto::has_property_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PropertyConfigProto::clear_property_name() {
  property_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PropertyConfigProto::property_name() const {
  // @@protoc_insertion_point(field_get:icing.lib.PropertyConfigProto.property_name)
  return property_name_.GetNoArena();
}
inline void PropertyConfigProto::set_property_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  property_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:icing.lib.PropertyConfigProto.property_name)
}
inline void PropertyConfigProto::set_property_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  property_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:icing.lib.PropertyConfigProto.property_name)
}
inline void PropertyConfigProto::set_property_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  property_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:icing.lib.PropertyConfigProto.property_name)
}
inline void PropertyConfigProto::set_property_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  property_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:icing.lib.PropertyConfigProto.property_name)
}
inline std::string* PropertyConfigProto::mutable_property_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:icing.lib.PropertyConfigProto.property_name)
  return property_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PropertyConfigProto::release_property_name() {
  // @@protoc_insertion_point(field_release:icing.lib.PropertyConfigProto.property_name)
  if (!has_property_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return property_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PropertyConfigProto::set_allocated_property_name(std::string* property_name) {
  if (property_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  property_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), property_name);
  // @@protoc_insertion_point(field_set_allocated:icing.lib.PropertyConfigProto.property_name)
}

// optional .icing.lib.PropertyConfigProto.DataType.Code data_type = 2;
inline bool PropertyConfigProto::has_data_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PropertyConfigProto::clear_data_type() {
  data_type_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::icing::lib::PropertyConfigProto_DataType_Code PropertyConfigProto::data_type() const {
  // @@protoc_insertion_point(field_get:icing.lib.PropertyConfigProto.data_type)
  return static_cast< ::icing::lib::PropertyConfigProto_DataType_Code >(data_type_);
}
inline void PropertyConfigProto::set_data_type(::icing::lib::PropertyConfigProto_DataType_Code value) {
  assert(::icing::lib::PropertyConfigProto_DataType_Code_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  data_type_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.PropertyConfigProto.data_type)
}

// optional string schema_type = 3;
inline bool PropertyConfigProto::has_schema_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PropertyConfigProto::clear_schema_type() {
  schema_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PropertyConfigProto::schema_type() const {
  // @@protoc_insertion_point(field_get:icing.lib.PropertyConfigProto.schema_type)
  return schema_type_.GetNoArena();
}
inline void PropertyConfigProto::set_schema_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  schema_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:icing.lib.PropertyConfigProto.schema_type)
}
inline void PropertyConfigProto::set_schema_type(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  schema_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:icing.lib.PropertyConfigProto.schema_type)
}
inline void PropertyConfigProto::set_schema_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  schema_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:icing.lib.PropertyConfigProto.schema_type)
}
inline void PropertyConfigProto::set_schema_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  schema_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:icing.lib.PropertyConfigProto.schema_type)
}
inline std::string* PropertyConfigProto::mutable_schema_type() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:icing.lib.PropertyConfigProto.schema_type)
  return schema_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PropertyConfigProto::release_schema_type() {
  // @@protoc_insertion_point(field_release:icing.lib.PropertyConfigProto.schema_type)
  if (!has_schema_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return schema_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PropertyConfigProto::set_allocated_schema_type(std::string* schema_type) {
  if (schema_type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  schema_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), schema_type);
  // @@protoc_insertion_point(field_set_allocated:icing.lib.PropertyConfigProto.schema_type)
}

// optional .icing.lib.PropertyConfigProto.Cardinality.Code cardinality = 4;
inline bool PropertyConfigProto::has_cardinality() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PropertyConfigProto::clear_cardinality() {
  cardinality_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::icing::lib::PropertyConfigProto_Cardinality_Code PropertyConfigProto::cardinality() const {
  // @@protoc_insertion_point(field_get:icing.lib.PropertyConfigProto.cardinality)
  return static_cast< ::icing::lib::PropertyConfigProto_Cardinality_Code >(cardinality_);
}
inline void PropertyConfigProto::set_cardinality(::icing::lib::PropertyConfigProto_Cardinality_Code value) {
  assert(::icing::lib::PropertyConfigProto_Cardinality_Code_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  cardinality_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.PropertyConfigProto.cardinality)
}

// optional .icing.lib.StringIndexingConfig string_indexing_config = 5;
inline bool PropertyConfigProto::has_string_indexing_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PropertyConfigProto::clear_string_indexing_config() {
  if (string_indexing_config_ != nullptr) string_indexing_config_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::icing::lib::StringIndexingConfig& PropertyConfigProto::string_indexing_config() const {
  const ::icing::lib::StringIndexingConfig* p = string_indexing_config_;
  // @@protoc_insertion_point(field_get:icing.lib.PropertyConfigProto.string_indexing_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::StringIndexingConfig*>(
      &::icing::lib::_StringIndexingConfig_default_instance_);
}
inline ::icing::lib::StringIndexingConfig* PropertyConfigProto::release_string_indexing_config() {
  // @@protoc_insertion_point(field_release:icing.lib.PropertyConfigProto.string_indexing_config)
  _has_bits_[0] &= ~0x00000004u;
  ::icing::lib::StringIndexingConfig* temp = string_indexing_config_;
  string_indexing_config_ = nullptr;
  return temp;
}
inline ::icing::lib::StringIndexingConfig* PropertyConfigProto::mutable_string_indexing_config() {
  _has_bits_[0] |= 0x00000004u;
  if (string_indexing_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::StringIndexingConfig>(GetArenaNoVirtual());
    string_indexing_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.PropertyConfigProto.string_indexing_config)
  return string_indexing_config_;
}
inline void PropertyConfigProto::set_allocated_string_indexing_config(::icing::lib::StringIndexingConfig* string_indexing_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete string_indexing_config_;
  }
  if (string_indexing_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      string_indexing_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, string_indexing_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  string_indexing_config_ = string_indexing_config;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.PropertyConfigProto.string_indexing_config)
}

// optional .icing.lib.DocumentIndexingConfig document_indexing_config = 6;
inline bool PropertyConfigProto::has_document_indexing_config() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PropertyConfigProto::clear_document_indexing_config() {
  if (document_indexing_config_ != nullptr) document_indexing_config_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::icing::lib::DocumentIndexingConfig& PropertyConfigProto::document_indexing_config() const {
  const ::icing::lib::DocumentIndexingConfig* p = document_indexing_config_;
  // @@protoc_insertion_point(field_get:icing.lib.PropertyConfigProto.document_indexing_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::DocumentIndexingConfig*>(
      &::icing::lib::_DocumentIndexingConfig_default_instance_);
}
inline ::icing::lib::DocumentIndexingConfig* PropertyConfigProto::release_document_indexing_config() {
  // @@protoc_insertion_point(field_release:icing.lib.PropertyConfigProto.document_indexing_config)
  _has_bits_[0] &= ~0x00000008u;
  ::icing::lib::DocumentIndexingConfig* temp = document_indexing_config_;
  document_indexing_config_ = nullptr;
  return temp;
}
inline ::icing::lib::DocumentIndexingConfig* PropertyConfigProto::mutable_document_indexing_config() {
  _has_bits_[0] |= 0x00000008u;
  if (document_indexing_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::DocumentIndexingConfig>(GetArenaNoVirtual());
    document_indexing_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.PropertyConfigProto.document_indexing_config)
  return document_indexing_config_;
}
inline void PropertyConfigProto::set_allocated_document_indexing_config(::icing::lib::DocumentIndexingConfig* document_indexing_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete document_indexing_config_;
  }
  if (document_indexing_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      document_indexing_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, document_indexing_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  document_indexing_config_ = document_indexing_config;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.PropertyConfigProto.document_indexing_config)
}

// -------------------------------------------------------------------

// SchemaProto

// repeated .icing.lib.SchemaTypeConfigProto types = 1;
inline int SchemaProto::types_size() const {
  return types_.size();
}
inline void SchemaProto::clear_types() {
  types_.Clear();
}
inline ::icing::lib::SchemaTypeConfigProto* SchemaProto::mutable_types(int index) {
  // @@protoc_insertion_point(field_mutable:icing.lib.SchemaProto.types)
  return types_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::SchemaTypeConfigProto >*
SchemaProto::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.SchemaProto.types)
  return &types_;
}
inline const ::icing::lib::SchemaTypeConfigProto& SchemaProto::types(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.SchemaProto.types)
  return types_.Get(index);
}
inline ::icing::lib::SchemaTypeConfigProto* SchemaProto::add_types() {
  // @@protoc_insertion_point(field_add:icing.lib.SchemaProto.types)
  return types_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::icing::lib::SchemaTypeConfigProto >&
SchemaProto::types() const {
  // @@protoc_insertion_point(field_list:icing.lib.SchemaProto.types)
  return types_;
}

// -------------------------------------------------------------------

// SetSchemaResultProto

// optional .icing.lib.StatusProto status = 1;
inline bool SetSchemaResultProto::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::icing::lib::StatusProto& SetSchemaResultProto::status() const {
  const ::icing::lib::StatusProto* p = status_;
  // @@protoc_insertion_point(field_get:icing.lib.SetSchemaResultProto.status)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::StatusProto*>(
      &::icing::lib::_StatusProto_default_instance_);
}
inline ::icing::lib::StatusProto* SetSchemaResultProto::release_status() {
  // @@protoc_insertion_point(field_release:icing.lib.SetSchemaResultProto.status)
  _has_bits_[0] &= ~0x00000001u;
  ::icing::lib::StatusProto* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::icing::lib::StatusProto* SetSchemaResultProto::mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::StatusProto>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.SetSchemaResultProto.status)
  return status_;
}
inline void SetSchemaResultProto::set_allocated_status(::icing::lib::StatusProto* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.SetSchemaResultProto.status)
}

// repeated string deleted_schema_types = 2;
inline int SetSchemaResultProto::deleted_schema_types_size() const {
  return deleted_schema_types_.size();
}
inline void SetSchemaResultProto::clear_deleted_schema_types() {
  deleted_schema_types_.Clear();
}
inline const std::string& SetSchemaResultProto::deleted_schema_types(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.SetSchemaResultProto.deleted_schema_types)
  return deleted_schema_types_.Get(index);
}
inline std::string* SetSchemaResultProto::mutable_deleted_schema_types(int index) {
  // @@protoc_insertion_point(field_mutable:icing.lib.SetSchemaResultProto.deleted_schema_types)
  return deleted_schema_types_.Mutable(index);
}
inline void SetSchemaResultProto::set_deleted_schema_types(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:icing.lib.SetSchemaResultProto.deleted_schema_types)
  deleted_schema_types_.Mutable(index)->assign(value);
}
inline void SetSchemaResultProto::set_deleted_schema_types(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:icing.lib.SetSchemaResultProto.deleted_schema_types)
  deleted_schema_types_.Mutable(index)->assign(std::move(value));
}
inline void SetSchemaResultProto::set_deleted_schema_types(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  deleted_schema_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:icing.lib.SetSchemaResultProto.deleted_schema_types)
}
inline void SetSchemaResultProto::set_deleted_schema_types(int index, const char* value, size_t size) {
  deleted_schema_types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:icing.lib.SetSchemaResultProto.deleted_schema_types)
}
inline std::string* SetSchemaResultProto::add_deleted_schema_types() {
  // @@protoc_insertion_point(field_add_mutable:icing.lib.SetSchemaResultProto.deleted_schema_types)
  return deleted_schema_types_.Add();
}
inline void SetSchemaResultProto::add_deleted_schema_types(const std::string& value) {
  deleted_schema_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:icing.lib.SetSchemaResultProto.deleted_schema_types)
}
inline void SetSchemaResultProto::add_deleted_schema_types(std::string&& value) {
  deleted_schema_types_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:icing.lib.SetSchemaResultProto.deleted_schema_types)
}
inline void SetSchemaResultProto::add_deleted_schema_types(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  deleted_schema_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:icing.lib.SetSchemaResultProto.deleted_schema_types)
}
inline void SetSchemaResultProto::add_deleted_schema_types(const char* value, size_t size) {
  deleted_schema_types_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:icing.lib.SetSchemaResultProto.deleted_schema_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SetSchemaResultProto::deleted_schema_types() const {
  // @@protoc_insertion_point(field_list:icing.lib.SetSchemaResultProto.deleted_schema_types)
  return deleted_schema_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SetSchemaResultProto::mutable_deleted_schema_types() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.SetSchemaResultProto.deleted_schema_types)
  return &deleted_schema_types_;
}

// repeated string incompatible_schema_types = 3;
inline int SetSchemaResultProto::incompatible_schema_types_size() const {
  return incompatible_schema_types_.size();
}
inline void SetSchemaResultProto::clear_incompatible_schema_types() {
  incompatible_schema_types_.Clear();
}
inline const std::string& SetSchemaResultProto::incompatible_schema_types(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.SetSchemaResultProto.incompatible_schema_types)
  return incompatible_schema_types_.Get(index);
}
inline std::string* SetSchemaResultProto::mutable_incompatible_schema_types(int index) {
  // @@protoc_insertion_point(field_mutable:icing.lib.SetSchemaResultProto.incompatible_schema_types)
  return incompatible_schema_types_.Mutable(index);
}
inline void SetSchemaResultProto::set_incompatible_schema_types(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:icing.lib.SetSchemaResultProto.incompatible_schema_types)
  incompatible_schema_types_.Mutable(index)->assign(value);
}
inline void SetSchemaResultProto::set_incompatible_schema_types(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:icing.lib.SetSchemaResultProto.incompatible_schema_types)
  incompatible_schema_types_.Mutable(index)->assign(std::move(value));
}
inline void SetSchemaResultProto::set_incompatible_schema_types(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  incompatible_schema_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:icing.lib.SetSchemaResultProto.incompatible_schema_types)
}
inline void SetSchemaResultProto::set_incompatible_schema_types(int index, const char* value, size_t size) {
  incompatible_schema_types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:icing.lib.SetSchemaResultProto.incompatible_schema_types)
}
inline std::string* SetSchemaResultProto::add_incompatible_schema_types() {
  // @@protoc_insertion_point(field_add_mutable:icing.lib.SetSchemaResultProto.incompatible_schema_types)
  return incompatible_schema_types_.Add();
}
inline void SetSchemaResultProto::add_incompatible_schema_types(const std::string& value) {
  incompatible_schema_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:icing.lib.SetSchemaResultProto.incompatible_schema_types)
}
inline void SetSchemaResultProto::add_incompatible_schema_types(std::string&& value) {
  incompatible_schema_types_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:icing.lib.SetSchemaResultProto.incompatible_schema_types)
}
inline void SetSchemaResultProto::add_incompatible_schema_types(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  incompatible_schema_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:icing.lib.SetSchemaResultProto.incompatible_schema_types)
}
inline void SetSchemaResultProto::add_incompatible_schema_types(const char* value, size_t size) {
  incompatible_schema_types_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:icing.lib.SetSchemaResultProto.incompatible_schema_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SetSchemaResultProto::incompatible_schema_types() const {
  // @@protoc_insertion_point(field_list:icing.lib.SetSchemaResultProto.incompatible_schema_types)
  return incompatible_schema_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SetSchemaResultProto::mutable_incompatible_schema_types() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.SetSchemaResultProto.incompatible_schema_types)
  return &incompatible_schema_types_;
}

// repeated string new_schema_types = 4;
inline int SetSchemaResultProto::new_schema_types_size() const {
  return new_schema_types_.size();
}
inline void SetSchemaResultProto::clear_new_schema_types() {
  new_schema_types_.Clear();
}
inline const std::string& SetSchemaResultProto::new_schema_types(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.SetSchemaResultProto.new_schema_types)
  return new_schema_types_.Get(index);
}
inline std::string* SetSchemaResultProto::mutable_new_schema_types(int index) {
  // @@protoc_insertion_point(field_mutable:icing.lib.SetSchemaResultProto.new_schema_types)
  return new_schema_types_.Mutable(index);
}
inline void SetSchemaResultProto::set_new_schema_types(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:icing.lib.SetSchemaResultProto.new_schema_types)
  new_schema_types_.Mutable(index)->assign(value);
}
inline void SetSchemaResultProto::set_new_schema_types(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:icing.lib.SetSchemaResultProto.new_schema_types)
  new_schema_types_.Mutable(index)->assign(std::move(value));
}
inline void SetSchemaResultProto::set_new_schema_types(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  new_schema_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:icing.lib.SetSchemaResultProto.new_schema_types)
}
inline void SetSchemaResultProto::set_new_schema_types(int index, const char* value, size_t size) {
  new_schema_types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:icing.lib.SetSchemaResultProto.new_schema_types)
}
inline std::string* SetSchemaResultProto::add_new_schema_types() {
  // @@protoc_insertion_point(field_add_mutable:icing.lib.SetSchemaResultProto.new_schema_types)
  return new_schema_types_.Add();
}
inline void SetSchemaResultProto::add_new_schema_types(const std::string& value) {
  new_schema_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:icing.lib.SetSchemaResultProto.new_schema_types)
}
inline void SetSchemaResultProto::add_new_schema_types(std::string&& value) {
  new_schema_types_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:icing.lib.SetSchemaResultProto.new_schema_types)
}
inline void SetSchemaResultProto::add_new_schema_types(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  new_schema_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:icing.lib.SetSchemaResultProto.new_schema_types)
}
inline void SetSchemaResultProto::add_new_schema_types(const char* value, size_t size) {
  new_schema_types_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:icing.lib.SetSchemaResultProto.new_schema_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SetSchemaResultProto::new_schema_types() const {
  // @@protoc_insertion_point(field_list:icing.lib.SetSchemaResultProto.new_schema_types)
  return new_schema_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SetSchemaResultProto::mutable_new_schema_types() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.SetSchemaResultProto.new_schema_types)
  return &new_schema_types_;
}

// repeated string fully_compatible_changed_schema_types = 5;
inline int SetSchemaResultProto::fully_compatible_changed_schema_types_size() const {
  return fully_compatible_changed_schema_types_.size();
}
inline void SetSchemaResultProto::clear_fully_compatible_changed_schema_types() {
  fully_compatible_changed_schema_types_.Clear();
}
inline const std::string& SetSchemaResultProto::fully_compatible_changed_schema_types(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.SetSchemaResultProto.fully_compatible_changed_schema_types)
  return fully_compatible_changed_schema_types_.Get(index);
}
inline std::string* SetSchemaResultProto::mutable_fully_compatible_changed_schema_types(int index) {
  // @@protoc_insertion_point(field_mutable:icing.lib.SetSchemaResultProto.fully_compatible_changed_schema_types)
  return fully_compatible_changed_schema_types_.Mutable(index);
}
inline void SetSchemaResultProto::set_fully_compatible_changed_schema_types(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:icing.lib.SetSchemaResultProto.fully_compatible_changed_schema_types)
  fully_compatible_changed_schema_types_.Mutable(index)->assign(value);
}
inline void SetSchemaResultProto::set_fully_compatible_changed_schema_types(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:icing.lib.SetSchemaResultProto.fully_compatible_changed_schema_types)
  fully_compatible_changed_schema_types_.Mutable(index)->assign(std::move(value));
}
inline void SetSchemaResultProto::set_fully_compatible_changed_schema_types(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  fully_compatible_changed_schema_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:icing.lib.SetSchemaResultProto.fully_compatible_changed_schema_types)
}
inline void SetSchemaResultProto::set_fully_compatible_changed_schema_types(int index, const char* value, size_t size) {
  fully_compatible_changed_schema_types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:icing.lib.SetSchemaResultProto.fully_compatible_changed_schema_types)
}
inline std::string* SetSchemaResultProto::add_fully_compatible_changed_schema_types() {
  // @@protoc_insertion_point(field_add_mutable:icing.lib.SetSchemaResultProto.fully_compatible_changed_schema_types)
  return fully_compatible_changed_schema_types_.Add();
}
inline void SetSchemaResultProto::add_fully_compatible_changed_schema_types(const std::string& value) {
  fully_compatible_changed_schema_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:icing.lib.SetSchemaResultProto.fully_compatible_changed_schema_types)
}
inline void SetSchemaResultProto::add_fully_compatible_changed_schema_types(std::string&& value) {
  fully_compatible_changed_schema_types_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:icing.lib.SetSchemaResultProto.fully_compatible_changed_schema_types)
}
inline void SetSchemaResultProto::add_fully_compatible_changed_schema_types(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  fully_compatible_changed_schema_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:icing.lib.SetSchemaResultProto.fully_compatible_changed_schema_types)
}
inline void SetSchemaResultProto::add_fully_compatible_changed_schema_types(const char* value, size_t size) {
  fully_compatible_changed_schema_types_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:icing.lib.SetSchemaResultProto.fully_compatible_changed_schema_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SetSchemaResultProto::fully_compatible_changed_schema_types() const {
  // @@protoc_insertion_point(field_list:icing.lib.SetSchemaResultProto.fully_compatible_changed_schema_types)
  return fully_compatible_changed_schema_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SetSchemaResultProto::mutable_fully_compatible_changed_schema_types() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.SetSchemaResultProto.fully_compatible_changed_schema_types)
  return &fully_compatible_changed_schema_types_;
}

// repeated string index_incompatible_changed_schema_types = 6;
inline int SetSchemaResultProto::index_incompatible_changed_schema_types_size() const {
  return index_incompatible_changed_schema_types_.size();
}
inline void SetSchemaResultProto::clear_index_incompatible_changed_schema_types() {
  index_incompatible_changed_schema_types_.Clear();
}
inline const std::string& SetSchemaResultProto::index_incompatible_changed_schema_types(int index) const {
  // @@protoc_insertion_point(field_get:icing.lib.SetSchemaResultProto.index_incompatible_changed_schema_types)
  return index_incompatible_changed_schema_types_.Get(index);
}
inline std::string* SetSchemaResultProto::mutable_index_incompatible_changed_schema_types(int index) {
  // @@protoc_insertion_point(field_mutable:icing.lib.SetSchemaResultProto.index_incompatible_changed_schema_types)
  return index_incompatible_changed_schema_types_.Mutable(index);
}
inline void SetSchemaResultProto::set_index_incompatible_changed_schema_types(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:icing.lib.SetSchemaResultProto.index_incompatible_changed_schema_types)
  index_incompatible_changed_schema_types_.Mutable(index)->assign(value);
}
inline void SetSchemaResultProto::set_index_incompatible_changed_schema_types(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:icing.lib.SetSchemaResultProto.index_incompatible_changed_schema_types)
  index_incompatible_changed_schema_types_.Mutable(index)->assign(std::move(value));
}
inline void SetSchemaResultProto::set_index_incompatible_changed_schema_types(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  index_incompatible_changed_schema_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:icing.lib.SetSchemaResultProto.index_incompatible_changed_schema_types)
}
inline void SetSchemaResultProto::set_index_incompatible_changed_schema_types(int index, const char* value, size_t size) {
  index_incompatible_changed_schema_types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:icing.lib.SetSchemaResultProto.index_incompatible_changed_schema_types)
}
inline std::string* SetSchemaResultProto::add_index_incompatible_changed_schema_types() {
  // @@protoc_insertion_point(field_add_mutable:icing.lib.SetSchemaResultProto.index_incompatible_changed_schema_types)
  return index_incompatible_changed_schema_types_.Add();
}
inline void SetSchemaResultProto::add_index_incompatible_changed_schema_types(const std::string& value) {
  index_incompatible_changed_schema_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:icing.lib.SetSchemaResultProto.index_incompatible_changed_schema_types)
}
inline void SetSchemaResultProto::add_index_incompatible_changed_schema_types(std::string&& value) {
  index_incompatible_changed_schema_types_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:icing.lib.SetSchemaResultProto.index_incompatible_changed_schema_types)
}
inline void SetSchemaResultProto::add_index_incompatible_changed_schema_types(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  index_incompatible_changed_schema_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:icing.lib.SetSchemaResultProto.index_incompatible_changed_schema_types)
}
inline void SetSchemaResultProto::add_index_incompatible_changed_schema_types(const char* value, size_t size) {
  index_incompatible_changed_schema_types_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:icing.lib.SetSchemaResultProto.index_incompatible_changed_schema_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SetSchemaResultProto::index_incompatible_changed_schema_types() const {
  // @@protoc_insertion_point(field_list:icing.lib.SetSchemaResultProto.index_incompatible_changed_schema_types)
  return index_incompatible_changed_schema_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SetSchemaResultProto::mutable_index_incompatible_changed_schema_types() {
  // @@protoc_insertion_point(field_mutable_list:icing.lib.SetSchemaResultProto.index_incompatible_changed_schema_types)
  return &index_incompatible_changed_schema_types_;
}

// optional int32 latency_ms = 7;
inline bool SetSchemaResultProto::has_latency_ms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetSchemaResultProto::clear_latency_ms() {
  latency_ms_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SetSchemaResultProto::latency_ms() const {
  // @@protoc_insertion_point(field_get:icing.lib.SetSchemaResultProto.latency_ms)
  return latency_ms_;
}
inline void SetSchemaResultProto::set_latency_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  latency_ms_ = value;
  // @@protoc_insertion_point(field_set:icing.lib.SetSchemaResultProto.latency_ms)
}

// -------------------------------------------------------------------

// GetSchemaResultProto

// optional .icing.lib.StatusProto status = 1;
inline bool GetSchemaResultProto::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::icing::lib::StatusProto& GetSchemaResultProto::status() const {
  const ::icing::lib::StatusProto* p = status_;
  // @@protoc_insertion_point(field_get:icing.lib.GetSchemaResultProto.status)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::StatusProto*>(
      &::icing::lib::_StatusProto_default_instance_);
}
inline ::icing::lib::StatusProto* GetSchemaResultProto::release_status() {
  // @@protoc_insertion_point(field_release:icing.lib.GetSchemaResultProto.status)
  _has_bits_[0] &= ~0x00000001u;
  ::icing::lib::StatusProto* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::icing::lib::StatusProto* GetSchemaResultProto::mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::StatusProto>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.GetSchemaResultProto.status)
  return status_;
}
inline void GetSchemaResultProto::set_allocated_status(::icing::lib::StatusProto* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.GetSchemaResultProto.status)
}

// optional .icing.lib.SchemaProto schema = 2;
inline bool GetSchemaResultProto::has_schema() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetSchemaResultProto::clear_schema() {
  if (schema_ != nullptr) schema_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::icing::lib::SchemaProto& GetSchemaResultProto::schema() const {
  const ::icing::lib::SchemaProto* p = schema_;
  // @@protoc_insertion_point(field_get:icing.lib.GetSchemaResultProto.schema)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::SchemaProto*>(
      &::icing::lib::_SchemaProto_default_instance_);
}
inline ::icing::lib::SchemaProto* GetSchemaResultProto::release_schema() {
  // @@protoc_insertion_point(field_release:icing.lib.GetSchemaResultProto.schema)
  _has_bits_[0] &= ~0x00000002u;
  ::icing::lib::SchemaProto* temp = schema_;
  schema_ = nullptr;
  return temp;
}
inline ::icing::lib::SchemaProto* GetSchemaResultProto::mutable_schema() {
  _has_bits_[0] |= 0x00000002u;
  if (schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::SchemaProto>(GetArenaNoVirtual());
    schema_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.GetSchemaResultProto.schema)
  return schema_;
}
inline void GetSchemaResultProto::set_allocated_schema(::icing::lib::SchemaProto* schema) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete schema_;
  }
  if (schema) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      schema = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  schema_ = schema;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.GetSchemaResultProto.schema)
}

// -------------------------------------------------------------------

// GetSchemaTypeResultProto

// optional .icing.lib.StatusProto status = 1;
inline bool GetSchemaTypeResultProto::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::icing::lib::StatusProto& GetSchemaTypeResultProto::status() const {
  const ::icing::lib::StatusProto* p = status_;
  // @@protoc_insertion_point(field_get:icing.lib.GetSchemaTypeResultProto.status)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::StatusProto*>(
      &::icing::lib::_StatusProto_default_instance_);
}
inline ::icing::lib::StatusProto* GetSchemaTypeResultProto::release_status() {
  // @@protoc_insertion_point(field_release:icing.lib.GetSchemaTypeResultProto.status)
  _has_bits_[0] &= ~0x00000001u;
  ::icing::lib::StatusProto* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::icing::lib::StatusProto* GetSchemaTypeResultProto::mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::StatusProto>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.GetSchemaTypeResultProto.status)
  return status_;
}
inline void GetSchemaTypeResultProto::set_allocated_status(::icing::lib::StatusProto* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.GetSchemaTypeResultProto.status)
}

// optional .icing.lib.SchemaTypeConfigProto schema_type_config = 2;
inline bool GetSchemaTypeResultProto::has_schema_type_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetSchemaTypeResultProto::clear_schema_type_config() {
  if (schema_type_config_ != nullptr) schema_type_config_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::icing::lib::SchemaTypeConfigProto& GetSchemaTypeResultProto::schema_type_config() const {
  const ::icing::lib::SchemaTypeConfigProto* p = schema_type_config_;
  // @@protoc_insertion_point(field_get:icing.lib.GetSchemaTypeResultProto.schema_type_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::icing::lib::SchemaTypeConfigProto*>(
      &::icing::lib::_SchemaTypeConfigProto_default_instance_);
}
inline ::icing::lib::SchemaTypeConfigProto* GetSchemaTypeResultProto::release_schema_type_config() {
  // @@protoc_insertion_point(field_release:icing.lib.GetSchemaTypeResultProto.schema_type_config)
  _has_bits_[0] &= ~0x00000002u;
  ::icing::lib::SchemaTypeConfigProto* temp = schema_type_config_;
  schema_type_config_ = nullptr;
  return temp;
}
inline ::icing::lib::SchemaTypeConfigProto* GetSchemaTypeResultProto::mutable_schema_type_config() {
  _has_bits_[0] |= 0x00000002u;
  if (schema_type_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::icing::lib::SchemaTypeConfigProto>(GetArenaNoVirtual());
    schema_type_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:icing.lib.GetSchemaTypeResultProto.schema_type_config)
  return schema_type_config_;
}
inline void GetSchemaTypeResultProto::set_allocated_schema_type_config(::icing::lib::SchemaTypeConfigProto* schema_type_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete schema_type_config_;
  }
  if (schema_type_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      schema_type_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema_type_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  schema_type_config_ = schema_type_config;
  // @@protoc_insertion_point(field_set_allocated:icing.lib.GetSchemaTypeResultProto.schema_type_config)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace lib
}  // namespace icing

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::icing::lib::StringIndexingConfig_TokenizerType_Code> : ::std::true_type {};
template <> struct is_proto_enum< ::icing::lib::PropertyConfigProto_DataType_Code> : ::std::true_type {};
template <> struct is_proto_enum< ::icing::lib::PropertyConfigProto_Cardinality_Code> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_icing_2fproto_2fschema_2eproto
