// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ENCODERCONFIG_TFLITE_OPS_CUSTOM_SENTENCEPIECE_H_
#define FLATBUFFERS_GENERATED_ENCODERCONFIG_TFLITE_OPS_CUSTOM_SENTENCEPIECE_H_

#include "flatbuffers/flatbuffers.h"

#include "tensorflow_lite_support/custom_ops/kernel/sentencepiece/config_generated.h"

namespace tflite {
namespace ops {
namespace custom {
namespace sentencepiece {

struct EncoderConfig;
struct EncoderConfigBuilder;
struct EncoderConfigT;

struct EncoderConfigT : public flatbuffers::NativeTable {
  typedef EncoderConfig TableType;
  tflite::ops::custom::sentencepiece::EncoderVersion version;
  int32_t start_code;
  int32_t end_code;
  int32_t unknown_code;
  float unknown_penalty;
  int32_t encoding_offset;
  std::unique_ptr<tflite::ops::custom::sentencepiece::TrieT> pieces;
  std::vector<float> pieces_scores;
  bool remove_extra_whitespaces;
  bool add_dummy_prefix;
  bool escape_whitespaces;
  std::unique_ptr<tflite::ops::custom::sentencepiece::TrieT> normalized_prefixes;
  std::vector<int8_t> normalized_replacements;
  EncoderConfigT()
      : version(tflite::ops::custom::sentencepiece::EncoderVersion_SENTENCE_PIECE),
        start_code(0),
        end_code(0),
        unknown_code(-1),
        unknown_penalty(0.0f),
        encoding_offset(0),
        remove_extra_whitespaces(false),
        add_dummy_prefix(false),
        escape_whitespaces(false) {
  }
};

struct EncoderConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EncoderConfigT NativeTableType;
  typedef EncoderConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_START_CODE = 6,
    VT_END_CODE = 8,
    VT_UNKNOWN_CODE = 10,
    VT_UNKNOWN_PENALTY = 12,
    VT_ENCODING_OFFSET = 14,
    VT_PIECES = 16,
    VT_PIECES_SCORES = 18,
    VT_REMOVE_EXTRA_WHITESPACES = 20,
    VT_ADD_DUMMY_PREFIX = 22,
    VT_ESCAPE_WHITESPACES = 24,
    VT_NORMALIZED_PREFIXES = 26,
    VT_NORMALIZED_REPLACEMENTS = 28
  };
  tflite::ops::custom::sentencepiece::EncoderVersion version() const {
    return static_cast<tflite::ops::custom::sentencepiece::EncoderVersion>(GetField<int8_t>(VT_VERSION, 0));
  }
  int32_t start_code() const {
    return GetField<int32_t>(VT_START_CODE, 0);
  }
  int32_t end_code() const {
    return GetField<int32_t>(VT_END_CODE, 0);
  }
  int32_t unknown_code() const {
    return GetField<int32_t>(VT_UNKNOWN_CODE, -1);
  }
  float unknown_penalty() const {
    return GetField<float>(VT_UNKNOWN_PENALTY, 0.0f);
  }
  int32_t encoding_offset() const {
    return GetField<int32_t>(VT_ENCODING_OFFSET, 0);
  }
  const tflite::ops::custom::sentencepiece::Trie *pieces() const {
    return GetPointer<const tflite::ops::custom::sentencepiece::Trie *>(VT_PIECES);
  }
  const flatbuffers::Vector<float> *pieces_scores() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_PIECES_SCORES);
  }
  bool remove_extra_whitespaces() const {
    return GetField<uint8_t>(VT_REMOVE_EXTRA_WHITESPACES, 0) != 0;
  }
  bool add_dummy_prefix() const {
    return GetField<uint8_t>(VT_ADD_DUMMY_PREFIX, 0) != 0;
  }
  bool escape_whitespaces() const {
    return GetField<uint8_t>(VT_ESCAPE_WHITESPACES, 0) != 0;
  }
  const tflite::ops::custom::sentencepiece::Trie *normalized_prefixes() const {
    return GetPointer<const tflite::ops::custom::sentencepiece::Trie *>(VT_NORMALIZED_PREFIXES);
  }
  const flatbuffers::Vector<int8_t> *normalized_replacements() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_NORMALIZED_REPLACEMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_VERSION) &&
           VerifyField<int32_t>(verifier, VT_START_CODE) &&
           VerifyField<int32_t>(verifier, VT_END_CODE) &&
           VerifyField<int32_t>(verifier, VT_UNKNOWN_CODE) &&
           VerifyField<float>(verifier, VT_UNKNOWN_PENALTY) &&
           VerifyField<int32_t>(verifier, VT_ENCODING_OFFSET) &&
           VerifyOffset(verifier, VT_PIECES) &&
           verifier.VerifyTable(pieces()) &&
           VerifyOffset(verifier, VT_PIECES_SCORES) &&
           verifier.VerifyVector(pieces_scores()) &&
           VerifyField<uint8_t>(verifier, VT_REMOVE_EXTRA_WHITESPACES) &&
           VerifyField<uint8_t>(verifier, VT_ADD_DUMMY_PREFIX) &&
           VerifyField<uint8_t>(verifier, VT_ESCAPE_WHITESPACES) &&
           VerifyOffset(verifier, VT_NORMALIZED_PREFIXES) &&
           verifier.VerifyTable(normalized_prefixes()) &&
           VerifyOffset(verifier, VT_NORMALIZED_REPLACEMENTS) &&
           verifier.VerifyVector(normalized_replacements()) &&
           verifier.EndTable();
  }
  EncoderConfigT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EncoderConfigT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EncoderConfig> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EncoderConfigT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EncoderConfigBuilder {
  typedef EncoderConfig Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(tflite::ops::custom::sentencepiece::EncoderVersion version) {
    fbb_.AddElement<int8_t>(EncoderConfig::VT_VERSION, static_cast<int8_t>(version), 0);
  }
  void add_start_code(int32_t start_code) {
    fbb_.AddElement<int32_t>(EncoderConfig::VT_START_CODE, start_code, 0);
  }
  void add_end_code(int32_t end_code) {
    fbb_.AddElement<int32_t>(EncoderConfig::VT_END_CODE, end_code, 0);
  }
  void add_unknown_code(int32_t unknown_code) {
    fbb_.AddElement<int32_t>(EncoderConfig::VT_UNKNOWN_CODE, unknown_code, -1);
  }
  void add_unknown_penalty(float unknown_penalty) {
    fbb_.AddElement<float>(EncoderConfig::VT_UNKNOWN_PENALTY, unknown_penalty, 0.0f);
  }
  void add_encoding_offset(int32_t encoding_offset) {
    fbb_.AddElement<int32_t>(EncoderConfig::VT_ENCODING_OFFSET, encoding_offset, 0);
  }
  void add_pieces(flatbuffers::Offset<tflite::ops::custom::sentencepiece::Trie> pieces) {
    fbb_.AddOffset(EncoderConfig::VT_PIECES, pieces);
  }
  void add_pieces_scores(flatbuffers::Offset<flatbuffers::Vector<float>> pieces_scores) {
    fbb_.AddOffset(EncoderConfig::VT_PIECES_SCORES, pieces_scores);
  }
  void add_remove_extra_whitespaces(bool remove_extra_whitespaces) {
    fbb_.AddElement<uint8_t>(EncoderConfig::VT_REMOVE_EXTRA_WHITESPACES, static_cast<uint8_t>(remove_extra_whitespaces), 0);
  }
  void add_add_dummy_prefix(bool add_dummy_prefix) {
    fbb_.AddElement<uint8_t>(EncoderConfig::VT_ADD_DUMMY_PREFIX, static_cast<uint8_t>(add_dummy_prefix), 0);
  }
  void add_escape_whitespaces(bool escape_whitespaces) {
    fbb_.AddElement<uint8_t>(EncoderConfig::VT_ESCAPE_WHITESPACES, static_cast<uint8_t>(escape_whitespaces), 0);
  }
  void add_normalized_prefixes(flatbuffers::Offset<tflite::ops::custom::sentencepiece::Trie> normalized_prefixes) {
    fbb_.AddOffset(EncoderConfig::VT_NORMALIZED_PREFIXES, normalized_prefixes);
  }
  void add_normalized_replacements(flatbuffers::Offset<flatbuffers::Vector<int8_t>> normalized_replacements) {
    fbb_.AddOffset(EncoderConfig::VT_NORMALIZED_REPLACEMENTS, normalized_replacements);
  }
  explicit EncoderConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EncoderConfigBuilder &operator=(const EncoderConfigBuilder &);
  flatbuffers::Offset<EncoderConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EncoderConfig>(end);
    return o;
  }
};

inline flatbuffers::Offset<EncoderConfig> CreateEncoderConfig(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ops::custom::sentencepiece::EncoderVersion version = tflite::ops::custom::sentencepiece::EncoderVersion_SENTENCE_PIECE,
    int32_t start_code = 0,
    int32_t end_code = 0,
    int32_t unknown_code = -1,
    float unknown_penalty = 0.0f,
    int32_t encoding_offset = 0,
    flatbuffers::Offset<tflite::ops::custom::sentencepiece::Trie> pieces = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> pieces_scores = 0,
    bool remove_extra_whitespaces = false,
    bool add_dummy_prefix = false,
    bool escape_whitespaces = false,
    flatbuffers::Offset<tflite::ops::custom::sentencepiece::Trie> normalized_prefixes = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> normalized_replacements = 0) {
  EncoderConfigBuilder builder_(_fbb);
  builder_.add_normalized_replacements(normalized_replacements);
  builder_.add_normalized_prefixes(normalized_prefixes);
  builder_.add_pieces_scores(pieces_scores);
  builder_.add_pieces(pieces);
  builder_.add_encoding_offset(encoding_offset);
  builder_.add_unknown_penalty(unknown_penalty);
  builder_.add_unknown_code(unknown_code);
  builder_.add_end_code(end_code);
  builder_.add_start_code(start_code);
  builder_.add_escape_whitespaces(escape_whitespaces);
  builder_.add_add_dummy_prefix(add_dummy_prefix);
  builder_.add_remove_extra_whitespaces(remove_extra_whitespaces);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<EncoderConfig> CreateEncoderConfigDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ops::custom::sentencepiece::EncoderVersion version = tflite::ops::custom::sentencepiece::EncoderVersion_SENTENCE_PIECE,
    int32_t start_code = 0,
    int32_t end_code = 0,
    int32_t unknown_code = -1,
    float unknown_penalty = 0.0f,
    int32_t encoding_offset = 0,
    flatbuffers::Offset<tflite::ops::custom::sentencepiece::Trie> pieces = 0,
    const std::vector<float> *pieces_scores = nullptr,
    bool remove_extra_whitespaces = false,
    bool add_dummy_prefix = false,
    bool escape_whitespaces = false,
    flatbuffers::Offset<tflite::ops::custom::sentencepiece::Trie> normalized_prefixes = 0,
    const std::vector<int8_t> *normalized_replacements = nullptr) {
  auto pieces_scores__ = pieces_scores ? _fbb.CreateVector<float>(*pieces_scores) : 0;
  auto normalized_replacements__ = normalized_replacements ? _fbb.CreateVector<int8_t>(*normalized_replacements) : 0;
  return tflite::ops::custom::sentencepiece::CreateEncoderConfig(
      _fbb,
      version,
      start_code,
      end_code,
      unknown_code,
      unknown_penalty,
      encoding_offset,
      pieces,
      pieces_scores__,
      remove_extra_whitespaces,
      add_dummy_prefix,
      escape_whitespaces,
      normalized_prefixes,
      normalized_replacements__);
}

flatbuffers::Offset<EncoderConfig> CreateEncoderConfig(flatbuffers::FlatBufferBuilder &_fbb, const EncoderConfigT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline EncoderConfigT *EncoderConfig::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<tflite::ops::custom::sentencepiece::EncoderConfigT> _o = std::unique_ptr<tflite::ops::custom::sentencepiece::EncoderConfigT>(new EncoderConfigT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EncoderConfig::UnPackTo(EncoderConfigT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = version(); _o->version = _e; }
  { auto _e = start_code(); _o->start_code = _e; }
  { auto _e = end_code(); _o->end_code = _e; }
  { auto _e = unknown_code(); _o->unknown_code = _e; }
  { auto _e = unknown_penalty(); _o->unknown_penalty = _e; }
  { auto _e = encoding_offset(); _o->encoding_offset = _e; }
  { auto _e = pieces(); if (_e) _o->pieces = std::unique_ptr<tflite::ops::custom::sentencepiece::TrieT>(_e->UnPack(_resolver)); }
  { auto _e = pieces_scores(); if (_e) { _o->pieces_scores.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pieces_scores[_i] = _e->Get(_i); } } }
  { auto _e = remove_extra_whitespaces(); _o->remove_extra_whitespaces = _e; }
  { auto _e = add_dummy_prefix(); _o->add_dummy_prefix = _e; }
  { auto _e = escape_whitespaces(); _o->escape_whitespaces = _e; }
  { auto _e = normalized_prefixes(); if (_e) _o->normalized_prefixes = std::unique_ptr<tflite::ops::custom::sentencepiece::TrieT>(_e->UnPack(_resolver)); }
  { auto _e = normalized_replacements(); if (_e) { _o->normalized_replacements.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->normalized_replacements[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<EncoderConfig> EncoderConfig::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EncoderConfigT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEncoderConfig(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EncoderConfig> CreateEncoderConfig(flatbuffers::FlatBufferBuilder &_fbb, const EncoderConfigT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EncoderConfigT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _version = _o->version;
  auto _start_code = _o->start_code;
  auto _end_code = _o->end_code;
  auto _unknown_code = _o->unknown_code;
  auto _unknown_penalty = _o->unknown_penalty;
  auto _encoding_offset = _o->encoding_offset;
  auto _pieces = _o->pieces ? CreateTrie(_fbb, _o->pieces.get(), _rehasher) : 0;
  auto _pieces_scores = _o->pieces_scores.size() ? _fbb.CreateVector(_o->pieces_scores) : 0;
  auto _remove_extra_whitespaces = _o->remove_extra_whitespaces;
  auto _add_dummy_prefix = _o->add_dummy_prefix;
  auto _escape_whitespaces = _o->escape_whitespaces;
  auto _normalized_prefixes = _o->normalized_prefixes ? CreateTrie(_fbb, _o->normalized_prefixes.get(), _rehasher) : 0;
  auto _normalized_replacements = _o->normalized_replacements.size() ? _fbb.CreateVector(_o->normalized_replacements) : 0;
  return tflite::ops::custom::sentencepiece::CreateEncoderConfig(
      _fbb,
      _version,
      _start_code,
      _end_code,
      _unknown_code,
      _unknown_penalty,
      _encoding_offset,
      _pieces,
      _pieces_scores,
      _remove_extra_whitespaces,
      _add_dummy_prefix,
      _escape_whitespaces,
      _normalized_prefixes,
      _normalized_replacements);
}

inline const tflite::ops::custom::sentencepiece::EncoderConfig *GetEncoderConfig(const void *buf) {
  return flatbuffers::GetRoot<tflite::ops::custom::sentencepiece::EncoderConfig>(buf);
}

inline const tflite::ops::custom::sentencepiece::EncoderConfig *GetSizePrefixedEncoderConfig(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<tflite::ops::custom::sentencepiece::EncoderConfig>(buf);
}

inline bool VerifyEncoderConfigBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<tflite::ops::custom::sentencepiece::EncoderConfig>(nullptr);
}

inline bool VerifySizePrefixedEncoderConfigBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<tflite::ops::custom::sentencepiece::EncoderConfig>(nullptr);
}

inline void FinishEncoderConfigBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<tflite::ops::custom::sentencepiece::EncoderConfig> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedEncoderConfigBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<tflite::ops::custom::sentencepiece::EncoderConfig> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<tflite::ops::custom::sentencepiece::EncoderConfigT> UnPackEncoderConfig(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<tflite::ops::custom::sentencepiece::EncoderConfigT>(GetEncoderConfig(buf)->UnPack(res));
}

inline std::unique_ptr<tflite::ops::custom::sentencepiece::EncoderConfigT> UnPackSizePrefixedEncoderConfig(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<tflite::ops::custom::sentencepiece::EncoderConfigT>(GetSizePrefixedEncoderConfig(buf)->UnPack(res));
}

}  // namespace sentencepiece
}  // namespace custom
}  // namespace ops
}  // namespace tflite

#endif  // FLATBUFFERS_GENERATED_ENCODERCONFIG_TFLITE_OPS_CUSTOM_SENTENCEPIECE_H_
