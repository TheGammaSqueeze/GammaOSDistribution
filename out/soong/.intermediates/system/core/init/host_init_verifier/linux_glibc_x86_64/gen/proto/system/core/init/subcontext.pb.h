// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: system/core/init/subcontext.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_system_2fcore_2finit_2fsubcontext_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_system_2fcore_2finit_2fsubcontext_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_system_2fcore_2finit_2fsubcontext_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_system_2fcore_2finit_2fsubcontext_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
class SubcontextCommand;
class SubcontextCommandDefaultTypeInternal;
extern SubcontextCommandDefaultTypeInternal _SubcontextCommand_default_instance_;
class SubcontextCommand_ExecuteCommand;
class SubcontextCommand_ExecuteCommandDefaultTypeInternal;
extern SubcontextCommand_ExecuteCommandDefaultTypeInternal _SubcontextCommand_ExecuteCommand_default_instance_;
class SubcontextCommand_ExpandArgsCommand;
class SubcontextCommand_ExpandArgsCommandDefaultTypeInternal;
extern SubcontextCommand_ExpandArgsCommandDefaultTypeInternal _SubcontextCommand_ExpandArgsCommand_default_instance_;
class SubcontextReply;
class SubcontextReplyDefaultTypeInternal;
extern SubcontextReplyDefaultTypeInternal _SubcontextReply_default_instance_;
class SubcontextReply_ExpandArgsReply;
class SubcontextReply_ExpandArgsReplyDefaultTypeInternal;
extern SubcontextReply_ExpandArgsReplyDefaultTypeInternal _SubcontextReply_ExpandArgsReply_default_instance_;
class SubcontextReply_Failure;
class SubcontextReply_FailureDefaultTypeInternal;
extern SubcontextReply_FailureDefaultTypeInternal _SubcontextReply_Failure_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::SubcontextCommand* Arena::CreateMaybeMessage<::SubcontextCommand>(Arena*);
template<> ::SubcontextCommand_ExecuteCommand* Arena::CreateMaybeMessage<::SubcontextCommand_ExecuteCommand>(Arena*);
template<> ::SubcontextCommand_ExpandArgsCommand* Arena::CreateMaybeMessage<::SubcontextCommand_ExpandArgsCommand>(Arena*);
template<> ::SubcontextReply* Arena::CreateMaybeMessage<::SubcontextReply>(Arena*);
template<> ::SubcontextReply_ExpandArgsReply* Arena::CreateMaybeMessage<::SubcontextReply_ExpandArgsReply>(Arena*);
template<> ::SubcontextReply_Failure* Arena::CreateMaybeMessage<::SubcontextReply_Failure>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class SubcontextCommand_ExecuteCommand :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SubcontextCommand.ExecuteCommand) */ {
 public:
  SubcontextCommand_ExecuteCommand();
  virtual ~SubcontextCommand_ExecuteCommand();

  SubcontextCommand_ExecuteCommand(const SubcontextCommand_ExecuteCommand& from);
  SubcontextCommand_ExecuteCommand(SubcontextCommand_ExecuteCommand&& from) noexcept
    : SubcontextCommand_ExecuteCommand() {
    *this = ::std::move(from);
  }

  inline SubcontextCommand_ExecuteCommand& operator=(const SubcontextCommand_ExecuteCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubcontextCommand_ExecuteCommand& operator=(SubcontextCommand_ExecuteCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SubcontextCommand_ExecuteCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubcontextCommand_ExecuteCommand* internal_default_instance() {
    return reinterpret_cast<const SubcontextCommand_ExecuteCommand*>(
               &_SubcontextCommand_ExecuteCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SubcontextCommand_ExecuteCommand& a, SubcontextCommand_ExecuteCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(SubcontextCommand_ExecuteCommand* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubcontextCommand_ExecuteCommand* New() const final {
    return CreateMaybeMessage<SubcontextCommand_ExecuteCommand>(nullptr);
  }

  SubcontextCommand_ExecuteCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubcontextCommand_ExecuteCommand>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SubcontextCommand_ExecuteCommand& from);
  void MergeFrom(const SubcontextCommand_ExecuteCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubcontextCommand_ExecuteCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SubcontextCommand.ExecuteCommand";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 1,
  };
  // repeated string args = 1;
  int args_size() const;
  void clear_args();
  const std::string& args(int index) const;
  std::string* mutable_args(int index);
  void set_args(int index, const std::string& value);
  void set_args(int index, std::string&& value);
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, size_t size);
  std::string* add_args();
  void add_args(const std::string& value);
  void add_args(std::string&& value);
  void add_args(const char* value);
  void add_args(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& args() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_args();

  // @@protoc_insertion_point(class_scope:SubcontextCommand.ExecuteCommand)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> args_;
  friend struct ::TableStruct_system_2fcore_2finit_2fsubcontext_2eproto;
};
// -------------------------------------------------------------------

class SubcontextCommand_ExpandArgsCommand :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SubcontextCommand.ExpandArgsCommand) */ {
 public:
  SubcontextCommand_ExpandArgsCommand();
  virtual ~SubcontextCommand_ExpandArgsCommand();

  SubcontextCommand_ExpandArgsCommand(const SubcontextCommand_ExpandArgsCommand& from);
  SubcontextCommand_ExpandArgsCommand(SubcontextCommand_ExpandArgsCommand&& from) noexcept
    : SubcontextCommand_ExpandArgsCommand() {
    *this = ::std::move(from);
  }

  inline SubcontextCommand_ExpandArgsCommand& operator=(const SubcontextCommand_ExpandArgsCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubcontextCommand_ExpandArgsCommand& operator=(SubcontextCommand_ExpandArgsCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SubcontextCommand_ExpandArgsCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubcontextCommand_ExpandArgsCommand* internal_default_instance() {
    return reinterpret_cast<const SubcontextCommand_ExpandArgsCommand*>(
               &_SubcontextCommand_ExpandArgsCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SubcontextCommand_ExpandArgsCommand& a, SubcontextCommand_ExpandArgsCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(SubcontextCommand_ExpandArgsCommand* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubcontextCommand_ExpandArgsCommand* New() const final {
    return CreateMaybeMessage<SubcontextCommand_ExpandArgsCommand>(nullptr);
  }

  SubcontextCommand_ExpandArgsCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubcontextCommand_ExpandArgsCommand>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SubcontextCommand_ExpandArgsCommand& from);
  void MergeFrom(const SubcontextCommand_ExpandArgsCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubcontextCommand_ExpandArgsCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SubcontextCommand.ExpandArgsCommand";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 1,
  };
  // repeated string args = 1;
  int args_size() const;
  void clear_args();
  const std::string& args(int index) const;
  std::string* mutable_args(int index);
  void set_args(int index, const std::string& value);
  void set_args(int index, std::string&& value);
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, size_t size);
  std::string* add_args();
  void add_args(const std::string& value);
  void add_args(std::string&& value);
  void add_args(const char* value);
  void add_args(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& args() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_args();

  // @@protoc_insertion_point(class_scope:SubcontextCommand.ExpandArgsCommand)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> args_;
  friend struct ::TableStruct_system_2fcore_2finit_2fsubcontext_2eproto;
};
// -------------------------------------------------------------------

class SubcontextCommand :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SubcontextCommand) */ {
 public:
  SubcontextCommand();
  virtual ~SubcontextCommand();

  SubcontextCommand(const SubcontextCommand& from);
  SubcontextCommand(SubcontextCommand&& from) noexcept
    : SubcontextCommand() {
    *this = ::std::move(from);
  }

  inline SubcontextCommand& operator=(const SubcontextCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubcontextCommand& operator=(SubcontextCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SubcontextCommand& default_instance();

  enum CommandCase {
    kExecuteCommand = 1,
    kExpandArgsCommand = 2,
    COMMAND_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubcontextCommand* internal_default_instance() {
    return reinterpret_cast<const SubcontextCommand*>(
               &_SubcontextCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SubcontextCommand& a, SubcontextCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(SubcontextCommand* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubcontextCommand* New() const final {
    return CreateMaybeMessage<SubcontextCommand>(nullptr);
  }

  SubcontextCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubcontextCommand>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SubcontextCommand& from);
  void MergeFrom(const SubcontextCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubcontextCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SubcontextCommand";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SubcontextCommand_ExecuteCommand ExecuteCommand;
  typedef SubcontextCommand_ExpandArgsCommand ExpandArgsCommand;

  // accessors -------------------------------------------------------

  enum : int {
    kExecuteCommandFieldNumber = 1,
    kExpandArgsCommandFieldNumber = 2,
  };
  // optional .SubcontextCommand.ExecuteCommand execute_command = 1;
  bool has_execute_command() const;
  void clear_execute_command();
  const ::SubcontextCommand_ExecuteCommand& execute_command() const;
  ::SubcontextCommand_ExecuteCommand* release_execute_command();
  ::SubcontextCommand_ExecuteCommand* mutable_execute_command();
  void set_allocated_execute_command(::SubcontextCommand_ExecuteCommand* execute_command);

  // optional .SubcontextCommand.ExpandArgsCommand expand_args_command = 2;
  bool has_expand_args_command() const;
  void clear_expand_args_command();
  const ::SubcontextCommand_ExpandArgsCommand& expand_args_command() const;
  ::SubcontextCommand_ExpandArgsCommand* release_expand_args_command();
  ::SubcontextCommand_ExpandArgsCommand* mutable_expand_args_command();
  void set_allocated_expand_args_command(::SubcontextCommand_ExpandArgsCommand* expand_args_command);

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:SubcontextCommand)
 private:
  class _Internal;
  void set_has_execute_command();
  void set_has_expand_args_command();

  inline bool has_command() const;
  inline void clear_has_command();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  union CommandUnion {
    CommandUnion() {}
    ::SubcontextCommand_ExecuteCommand* execute_command_;
    ::SubcontextCommand_ExpandArgsCommand* expand_args_command_;
  } command_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_system_2fcore_2finit_2fsubcontext_2eproto;
};
// -------------------------------------------------------------------

class SubcontextReply_Failure :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SubcontextReply.Failure) */ {
 public:
  SubcontextReply_Failure();
  virtual ~SubcontextReply_Failure();

  SubcontextReply_Failure(const SubcontextReply_Failure& from);
  SubcontextReply_Failure(SubcontextReply_Failure&& from) noexcept
    : SubcontextReply_Failure() {
    *this = ::std::move(from);
  }

  inline SubcontextReply_Failure& operator=(const SubcontextReply_Failure& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubcontextReply_Failure& operator=(SubcontextReply_Failure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SubcontextReply_Failure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubcontextReply_Failure* internal_default_instance() {
    return reinterpret_cast<const SubcontextReply_Failure*>(
               &_SubcontextReply_Failure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SubcontextReply_Failure& a, SubcontextReply_Failure& b) {
    a.Swap(&b);
  }
  inline void Swap(SubcontextReply_Failure* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubcontextReply_Failure* New() const final {
    return CreateMaybeMessage<SubcontextReply_Failure>(nullptr);
  }

  SubcontextReply_Failure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubcontextReply_Failure>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SubcontextReply_Failure& from);
  void MergeFrom(const SubcontextReply_Failure& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubcontextReply_Failure* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SubcontextReply.Failure";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorStringFieldNumber = 1,
    kErrorErrnoFieldNumber = 2,
  };
  // optional string error_string = 1;
  bool has_error_string() const;
  void clear_error_string();
  const std::string& error_string() const;
  void set_error_string(const std::string& value);
  void set_error_string(std::string&& value);
  void set_error_string(const char* value);
  void set_error_string(const char* value, size_t size);
  std::string* mutable_error_string();
  std::string* release_error_string();
  void set_allocated_error_string(std::string* error_string);

  // optional int32 error_errno = 2;
  bool has_error_errno() const;
  void clear_error_errno();
  ::PROTOBUF_NAMESPACE_ID::int32 error_errno() const;
  void set_error_errno(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:SubcontextReply.Failure)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_string_;
  ::PROTOBUF_NAMESPACE_ID::int32 error_errno_;
  friend struct ::TableStruct_system_2fcore_2finit_2fsubcontext_2eproto;
};
// -------------------------------------------------------------------

class SubcontextReply_ExpandArgsReply :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SubcontextReply.ExpandArgsReply) */ {
 public:
  SubcontextReply_ExpandArgsReply();
  virtual ~SubcontextReply_ExpandArgsReply();

  SubcontextReply_ExpandArgsReply(const SubcontextReply_ExpandArgsReply& from);
  SubcontextReply_ExpandArgsReply(SubcontextReply_ExpandArgsReply&& from) noexcept
    : SubcontextReply_ExpandArgsReply() {
    *this = ::std::move(from);
  }

  inline SubcontextReply_ExpandArgsReply& operator=(const SubcontextReply_ExpandArgsReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubcontextReply_ExpandArgsReply& operator=(SubcontextReply_ExpandArgsReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SubcontextReply_ExpandArgsReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubcontextReply_ExpandArgsReply* internal_default_instance() {
    return reinterpret_cast<const SubcontextReply_ExpandArgsReply*>(
               &_SubcontextReply_ExpandArgsReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SubcontextReply_ExpandArgsReply& a, SubcontextReply_ExpandArgsReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SubcontextReply_ExpandArgsReply* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubcontextReply_ExpandArgsReply* New() const final {
    return CreateMaybeMessage<SubcontextReply_ExpandArgsReply>(nullptr);
  }

  SubcontextReply_ExpandArgsReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubcontextReply_ExpandArgsReply>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SubcontextReply_ExpandArgsReply& from);
  void MergeFrom(const SubcontextReply_ExpandArgsReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubcontextReply_ExpandArgsReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SubcontextReply.ExpandArgsReply";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExpandedArgsFieldNumber = 1,
  };
  // repeated string expanded_args = 1;
  int expanded_args_size() const;
  void clear_expanded_args();
  const std::string& expanded_args(int index) const;
  std::string* mutable_expanded_args(int index);
  void set_expanded_args(int index, const std::string& value);
  void set_expanded_args(int index, std::string&& value);
  void set_expanded_args(int index, const char* value);
  void set_expanded_args(int index, const char* value, size_t size);
  std::string* add_expanded_args();
  void add_expanded_args(const std::string& value);
  void add_expanded_args(std::string&& value);
  void add_expanded_args(const char* value);
  void add_expanded_args(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& expanded_args() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_expanded_args();

  // @@protoc_insertion_point(class_scope:SubcontextReply.ExpandArgsReply)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> expanded_args_;
  friend struct ::TableStruct_system_2fcore_2finit_2fsubcontext_2eproto;
};
// -------------------------------------------------------------------

class SubcontextReply :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SubcontextReply) */ {
 public:
  SubcontextReply();
  virtual ~SubcontextReply();

  SubcontextReply(const SubcontextReply& from);
  SubcontextReply(SubcontextReply&& from) noexcept
    : SubcontextReply() {
    *this = ::std::move(from);
  }

  inline SubcontextReply& operator=(const SubcontextReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubcontextReply& operator=(SubcontextReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SubcontextReply& default_instance();

  enum ReplyCase {
    kSuccess = 1,
    kFailure = 2,
    kExpandArgsReply = 3,
    REPLY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubcontextReply* internal_default_instance() {
    return reinterpret_cast<const SubcontextReply*>(
               &_SubcontextReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SubcontextReply& a, SubcontextReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SubcontextReply* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubcontextReply* New() const final {
    return CreateMaybeMessage<SubcontextReply>(nullptr);
  }

  SubcontextReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubcontextReply>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SubcontextReply& from);
  void MergeFrom(const SubcontextReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubcontextReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SubcontextReply";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SubcontextReply_Failure Failure;
  typedef SubcontextReply_ExpandArgsReply ExpandArgsReply;

  // accessors -------------------------------------------------------

  enum : int {
    kTriggerShutdownFieldNumber = 4,
    kSuccessFieldNumber = 1,
    kFailureFieldNumber = 2,
    kExpandArgsReplyFieldNumber = 3,
  };
  // optional string trigger_shutdown = 4;
  bool has_trigger_shutdown() const;
  void clear_trigger_shutdown();
  const std::string& trigger_shutdown() const;
  void set_trigger_shutdown(const std::string& value);
  void set_trigger_shutdown(std::string&& value);
  void set_trigger_shutdown(const char* value);
  void set_trigger_shutdown(const char* value, size_t size);
  std::string* mutable_trigger_shutdown();
  std::string* release_trigger_shutdown();
  void set_allocated_trigger_shutdown(std::string* trigger_shutdown);

  // optional bool success = 1;
  bool has_success() const;
  void clear_success();
  bool success() const;
  void set_success(bool value);

  // optional .SubcontextReply.Failure failure = 2;
  bool has_failure() const;
  void clear_failure();
  const ::SubcontextReply_Failure& failure() const;
  ::SubcontextReply_Failure* release_failure();
  ::SubcontextReply_Failure* mutable_failure();
  void set_allocated_failure(::SubcontextReply_Failure* failure);

  // optional .SubcontextReply.ExpandArgsReply expand_args_reply = 3;
  bool has_expand_args_reply() const;
  void clear_expand_args_reply();
  const ::SubcontextReply_ExpandArgsReply& expand_args_reply() const;
  ::SubcontextReply_ExpandArgsReply* release_expand_args_reply();
  ::SubcontextReply_ExpandArgsReply* mutable_expand_args_reply();
  void set_allocated_expand_args_reply(::SubcontextReply_ExpandArgsReply* expand_args_reply);

  void clear_reply();
  ReplyCase reply_case() const;
  // @@protoc_insertion_point(class_scope:SubcontextReply)
 private:
  class _Internal;
  void set_has_success();
  void set_has_failure();
  void set_has_expand_args_reply();

  inline bool has_reply() const;
  inline void clear_has_reply();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_shutdown_;
  union ReplyUnion {
    ReplyUnion() {}
    bool success_;
    ::SubcontextReply_Failure* failure_;
    ::SubcontextReply_ExpandArgsReply* expand_args_reply_;
  } reply_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_system_2fcore_2finit_2fsubcontext_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SubcontextCommand_ExecuteCommand

// repeated string args = 1;
inline int SubcontextCommand_ExecuteCommand::args_size() const {
  return args_.size();
}
inline void SubcontextCommand_ExecuteCommand::clear_args() {
  args_.Clear();
}
inline const std::string& SubcontextCommand_ExecuteCommand::args(int index) const {
  // @@protoc_insertion_point(field_get:SubcontextCommand.ExecuteCommand.args)
  return args_.Get(index);
}
inline std::string* SubcontextCommand_ExecuteCommand::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:SubcontextCommand.ExecuteCommand.args)
  return args_.Mutable(index);
}
inline void SubcontextCommand_ExecuteCommand::set_args(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:SubcontextCommand.ExecuteCommand.args)
  args_.Mutable(index)->assign(value);
}
inline void SubcontextCommand_ExecuteCommand::set_args(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:SubcontextCommand.ExecuteCommand.args)
  args_.Mutable(index)->assign(std::move(value));
}
inline void SubcontextCommand_ExecuteCommand::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SubcontextCommand.ExecuteCommand.args)
}
inline void SubcontextCommand_ExecuteCommand::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SubcontextCommand.ExecuteCommand.args)
}
inline std::string* SubcontextCommand_ExecuteCommand::add_args() {
  // @@protoc_insertion_point(field_add_mutable:SubcontextCommand.ExecuteCommand.args)
  return args_.Add();
}
inline void SubcontextCommand_ExecuteCommand::add_args(const std::string& value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SubcontextCommand.ExecuteCommand.args)
}
inline void SubcontextCommand_ExecuteCommand::add_args(std::string&& value) {
  args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SubcontextCommand.ExecuteCommand.args)
}
inline void SubcontextCommand_ExecuteCommand::add_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SubcontextCommand.ExecuteCommand.args)
}
inline void SubcontextCommand_ExecuteCommand::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SubcontextCommand.ExecuteCommand.args)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SubcontextCommand_ExecuteCommand::args() const {
  // @@protoc_insertion_point(field_list:SubcontextCommand.ExecuteCommand.args)
  return args_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SubcontextCommand_ExecuteCommand::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:SubcontextCommand.ExecuteCommand.args)
  return &args_;
}

// -------------------------------------------------------------------

// SubcontextCommand_ExpandArgsCommand

// repeated string args = 1;
inline int SubcontextCommand_ExpandArgsCommand::args_size() const {
  return args_.size();
}
inline void SubcontextCommand_ExpandArgsCommand::clear_args() {
  args_.Clear();
}
inline const std::string& SubcontextCommand_ExpandArgsCommand::args(int index) const {
  // @@protoc_insertion_point(field_get:SubcontextCommand.ExpandArgsCommand.args)
  return args_.Get(index);
}
inline std::string* SubcontextCommand_ExpandArgsCommand::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:SubcontextCommand.ExpandArgsCommand.args)
  return args_.Mutable(index);
}
inline void SubcontextCommand_ExpandArgsCommand::set_args(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:SubcontextCommand.ExpandArgsCommand.args)
  args_.Mutable(index)->assign(value);
}
inline void SubcontextCommand_ExpandArgsCommand::set_args(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:SubcontextCommand.ExpandArgsCommand.args)
  args_.Mutable(index)->assign(std::move(value));
}
inline void SubcontextCommand_ExpandArgsCommand::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SubcontextCommand.ExpandArgsCommand.args)
}
inline void SubcontextCommand_ExpandArgsCommand::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SubcontextCommand.ExpandArgsCommand.args)
}
inline std::string* SubcontextCommand_ExpandArgsCommand::add_args() {
  // @@protoc_insertion_point(field_add_mutable:SubcontextCommand.ExpandArgsCommand.args)
  return args_.Add();
}
inline void SubcontextCommand_ExpandArgsCommand::add_args(const std::string& value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SubcontextCommand.ExpandArgsCommand.args)
}
inline void SubcontextCommand_ExpandArgsCommand::add_args(std::string&& value) {
  args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SubcontextCommand.ExpandArgsCommand.args)
}
inline void SubcontextCommand_ExpandArgsCommand::add_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SubcontextCommand.ExpandArgsCommand.args)
}
inline void SubcontextCommand_ExpandArgsCommand::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SubcontextCommand.ExpandArgsCommand.args)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SubcontextCommand_ExpandArgsCommand::args() const {
  // @@protoc_insertion_point(field_list:SubcontextCommand.ExpandArgsCommand.args)
  return args_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SubcontextCommand_ExpandArgsCommand::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:SubcontextCommand.ExpandArgsCommand.args)
  return &args_;
}

// -------------------------------------------------------------------

// SubcontextCommand

// optional .SubcontextCommand.ExecuteCommand execute_command = 1;
inline bool SubcontextCommand::has_execute_command() const {
  return command_case() == kExecuteCommand;
}
inline void SubcontextCommand::set_has_execute_command() {
  _oneof_case_[0] = kExecuteCommand;
}
inline void SubcontextCommand::clear_execute_command() {
  if (has_execute_command()) {
    delete command_.execute_command_;
    clear_has_command();
  }
}
inline ::SubcontextCommand_ExecuteCommand* SubcontextCommand::release_execute_command() {
  // @@protoc_insertion_point(field_release:SubcontextCommand.execute_command)
  if (has_execute_command()) {
    clear_has_command();
      ::SubcontextCommand_ExecuteCommand* temp = command_.execute_command_;
    command_.execute_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SubcontextCommand_ExecuteCommand& SubcontextCommand::execute_command() const {
  // @@protoc_insertion_point(field_get:SubcontextCommand.execute_command)
  return has_execute_command()
      ? *command_.execute_command_
      : *reinterpret_cast< ::SubcontextCommand_ExecuteCommand*>(&::_SubcontextCommand_ExecuteCommand_default_instance_);
}
inline ::SubcontextCommand_ExecuteCommand* SubcontextCommand::mutable_execute_command() {
  if (!has_execute_command()) {
    clear_command();
    set_has_execute_command();
    command_.execute_command_ = CreateMaybeMessage< ::SubcontextCommand_ExecuteCommand >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SubcontextCommand.execute_command)
  return command_.execute_command_;
}

// optional .SubcontextCommand.ExpandArgsCommand expand_args_command = 2;
inline bool SubcontextCommand::has_expand_args_command() const {
  return command_case() == kExpandArgsCommand;
}
inline void SubcontextCommand::set_has_expand_args_command() {
  _oneof_case_[0] = kExpandArgsCommand;
}
inline void SubcontextCommand::clear_expand_args_command() {
  if (has_expand_args_command()) {
    delete command_.expand_args_command_;
    clear_has_command();
  }
}
inline ::SubcontextCommand_ExpandArgsCommand* SubcontextCommand::release_expand_args_command() {
  // @@protoc_insertion_point(field_release:SubcontextCommand.expand_args_command)
  if (has_expand_args_command()) {
    clear_has_command();
      ::SubcontextCommand_ExpandArgsCommand* temp = command_.expand_args_command_;
    command_.expand_args_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SubcontextCommand_ExpandArgsCommand& SubcontextCommand::expand_args_command() const {
  // @@protoc_insertion_point(field_get:SubcontextCommand.expand_args_command)
  return has_expand_args_command()
      ? *command_.expand_args_command_
      : *reinterpret_cast< ::SubcontextCommand_ExpandArgsCommand*>(&::_SubcontextCommand_ExpandArgsCommand_default_instance_);
}
inline ::SubcontextCommand_ExpandArgsCommand* SubcontextCommand::mutable_expand_args_command() {
  if (!has_expand_args_command()) {
    clear_command();
    set_has_expand_args_command();
    command_.expand_args_command_ = CreateMaybeMessage< ::SubcontextCommand_ExpandArgsCommand >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SubcontextCommand.expand_args_command)
  return command_.expand_args_command_;
}

inline bool SubcontextCommand::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void SubcontextCommand::clear_has_command() {
  _oneof_case_[0] = COMMAND_NOT_SET;
}
inline SubcontextCommand::CommandCase SubcontextCommand::command_case() const {
  return SubcontextCommand::CommandCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SubcontextReply_Failure

// optional string error_string = 1;
inline bool SubcontextReply_Failure::has_error_string() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubcontextReply_Failure::clear_error_string() {
  error_string_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SubcontextReply_Failure::error_string() const {
  // @@protoc_insertion_point(field_get:SubcontextReply.Failure.error_string)
  return error_string_.GetNoArena();
}
inline void SubcontextReply_Failure::set_error_string(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  error_string_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SubcontextReply.Failure.error_string)
}
inline void SubcontextReply_Failure::set_error_string(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  error_string_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SubcontextReply.Failure.error_string)
}
inline void SubcontextReply_Failure::set_error_string(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  error_string_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SubcontextReply.Failure.error_string)
}
inline void SubcontextReply_Failure::set_error_string(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  error_string_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SubcontextReply.Failure.error_string)
}
inline std::string* SubcontextReply_Failure::mutable_error_string() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:SubcontextReply.Failure.error_string)
  return error_string_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SubcontextReply_Failure::release_error_string() {
  // @@protoc_insertion_point(field_release:SubcontextReply.Failure.error_string)
  if (!has_error_string()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return error_string_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SubcontextReply_Failure::set_allocated_error_string(std::string* error_string) {
  if (error_string != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_string_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_string);
  // @@protoc_insertion_point(field_set_allocated:SubcontextReply.Failure.error_string)
}

// optional int32 error_errno = 2;
inline bool SubcontextReply_Failure::has_error_errno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubcontextReply_Failure::clear_error_errno() {
  error_errno_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SubcontextReply_Failure::error_errno() const {
  // @@protoc_insertion_point(field_get:SubcontextReply.Failure.error_errno)
  return error_errno_;
}
inline void SubcontextReply_Failure::set_error_errno(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  error_errno_ = value;
  // @@protoc_insertion_point(field_set:SubcontextReply.Failure.error_errno)
}

// -------------------------------------------------------------------

// SubcontextReply_ExpandArgsReply

// repeated string expanded_args = 1;
inline int SubcontextReply_ExpandArgsReply::expanded_args_size() const {
  return expanded_args_.size();
}
inline void SubcontextReply_ExpandArgsReply::clear_expanded_args() {
  expanded_args_.Clear();
}
inline const std::string& SubcontextReply_ExpandArgsReply::expanded_args(int index) const {
  // @@protoc_insertion_point(field_get:SubcontextReply.ExpandArgsReply.expanded_args)
  return expanded_args_.Get(index);
}
inline std::string* SubcontextReply_ExpandArgsReply::mutable_expanded_args(int index) {
  // @@protoc_insertion_point(field_mutable:SubcontextReply.ExpandArgsReply.expanded_args)
  return expanded_args_.Mutable(index);
}
inline void SubcontextReply_ExpandArgsReply::set_expanded_args(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:SubcontextReply.ExpandArgsReply.expanded_args)
  expanded_args_.Mutable(index)->assign(value);
}
inline void SubcontextReply_ExpandArgsReply::set_expanded_args(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:SubcontextReply.ExpandArgsReply.expanded_args)
  expanded_args_.Mutable(index)->assign(std::move(value));
}
inline void SubcontextReply_ExpandArgsReply::set_expanded_args(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  expanded_args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SubcontextReply.ExpandArgsReply.expanded_args)
}
inline void SubcontextReply_ExpandArgsReply::set_expanded_args(int index, const char* value, size_t size) {
  expanded_args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SubcontextReply.ExpandArgsReply.expanded_args)
}
inline std::string* SubcontextReply_ExpandArgsReply::add_expanded_args() {
  // @@protoc_insertion_point(field_add_mutable:SubcontextReply.ExpandArgsReply.expanded_args)
  return expanded_args_.Add();
}
inline void SubcontextReply_ExpandArgsReply::add_expanded_args(const std::string& value) {
  expanded_args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SubcontextReply.ExpandArgsReply.expanded_args)
}
inline void SubcontextReply_ExpandArgsReply::add_expanded_args(std::string&& value) {
  expanded_args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SubcontextReply.ExpandArgsReply.expanded_args)
}
inline void SubcontextReply_ExpandArgsReply::add_expanded_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  expanded_args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SubcontextReply.ExpandArgsReply.expanded_args)
}
inline void SubcontextReply_ExpandArgsReply::add_expanded_args(const char* value, size_t size) {
  expanded_args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SubcontextReply.ExpandArgsReply.expanded_args)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SubcontextReply_ExpandArgsReply::expanded_args() const {
  // @@protoc_insertion_point(field_list:SubcontextReply.ExpandArgsReply.expanded_args)
  return expanded_args_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SubcontextReply_ExpandArgsReply::mutable_expanded_args() {
  // @@protoc_insertion_point(field_mutable_list:SubcontextReply.ExpandArgsReply.expanded_args)
  return &expanded_args_;
}

// -------------------------------------------------------------------

// SubcontextReply

// optional bool success = 1;
inline bool SubcontextReply::has_success() const {
  return reply_case() == kSuccess;
}
inline void SubcontextReply::set_has_success() {
  _oneof_case_[0] = kSuccess;
}
inline void SubcontextReply::clear_success() {
  if (has_success()) {
    reply_.success_ = false;
    clear_has_reply();
  }
}
inline bool SubcontextReply::success() const {
  // @@protoc_insertion_point(field_get:SubcontextReply.success)
  if (has_success()) {
    return reply_.success_;
  }
  return false;
}
inline void SubcontextReply::set_success(bool value) {
  if (!has_success()) {
    clear_reply();
    set_has_success();
  }
  reply_.success_ = value;
  // @@protoc_insertion_point(field_set:SubcontextReply.success)
}

// optional .SubcontextReply.Failure failure = 2;
inline bool SubcontextReply::has_failure() const {
  return reply_case() == kFailure;
}
inline void SubcontextReply::set_has_failure() {
  _oneof_case_[0] = kFailure;
}
inline void SubcontextReply::clear_failure() {
  if (has_failure()) {
    delete reply_.failure_;
    clear_has_reply();
  }
}
inline ::SubcontextReply_Failure* SubcontextReply::release_failure() {
  // @@protoc_insertion_point(field_release:SubcontextReply.failure)
  if (has_failure()) {
    clear_has_reply();
      ::SubcontextReply_Failure* temp = reply_.failure_;
    reply_.failure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SubcontextReply_Failure& SubcontextReply::failure() const {
  // @@protoc_insertion_point(field_get:SubcontextReply.failure)
  return has_failure()
      ? *reply_.failure_
      : *reinterpret_cast< ::SubcontextReply_Failure*>(&::_SubcontextReply_Failure_default_instance_);
}
inline ::SubcontextReply_Failure* SubcontextReply::mutable_failure() {
  if (!has_failure()) {
    clear_reply();
    set_has_failure();
    reply_.failure_ = CreateMaybeMessage< ::SubcontextReply_Failure >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SubcontextReply.failure)
  return reply_.failure_;
}

// optional .SubcontextReply.ExpandArgsReply expand_args_reply = 3;
inline bool SubcontextReply::has_expand_args_reply() const {
  return reply_case() == kExpandArgsReply;
}
inline void SubcontextReply::set_has_expand_args_reply() {
  _oneof_case_[0] = kExpandArgsReply;
}
inline void SubcontextReply::clear_expand_args_reply() {
  if (has_expand_args_reply()) {
    delete reply_.expand_args_reply_;
    clear_has_reply();
  }
}
inline ::SubcontextReply_ExpandArgsReply* SubcontextReply::release_expand_args_reply() {
  // @@protoc_insertion_point(field_release:SubcontextReply.expand_args_reply)
  if (has_expand_args_reply()) {
    clear_has_reply();
      ::SubcontextReply_ExpandArgsReply* temp = reply_.expand_args_reply_;
    reply_.expand_args_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SubcontextReply_ExpandArgsReply& SubcontextReply::expand_args_reply() const {
  // @@protoc_insertion_point(field_get:SubcontextReply.expand_args_reply)
  return has_expand_args_reply()
      ? *reply_.expand_args_reply_
      : *reinterpret_cast< ::SubcontextReply_ExpandArgsReply*>(&::_SubcontextReply_ExpandArgsReply_default_instance_);
}
inline ::SubcontextReply_ExpandArgsReply* SubcontextReply::mutable_expand_args_reply() {
  if (!has_expand_args_reply()) {
    clear_reply();
    set_has_expand_args_reply();
    reply_.expand_args_reply_ = CreateMaybeMessage< ::SubcontextReply_ExpandArgsReply >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SubcontextReply.expand_args_reply)
  return reply_.expand_args_reply_;
}

// optional string trigger_shutdown = 4;
inline bool SubcontextReply::has_trigger_shutdown() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubcontextReply::clear_trigger_shutdown() {
  trigger_shutdown_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SubcontextReply::trigger_shutdown() const {
  // @@protoc_insertion_point(field_get:SubcontextReply.trigger_shutdown)
  return trigger_shutdown_.GetNoArena();
}
inline void SubcontextReply::set_trigger_shutdown(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  trigger_shutdown_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SubcontextReply.trigger_shutdown)
}
inline void SubcontextReply::set_trigger_shutdown(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  trigger_shutdown_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SubcontextReply.trigger_shutdown)
}
inline void SubcontextReply::set_trigger_shutdown(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  trigger_shutdown_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SubcontextReply.trigger_shutdown)
}
inline void SubcontextReply::set_trigger_shutdown(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  trigger_shutdown_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SubcontextReply.trigger_shutdown)
}
inline std::string* SubcontextReply::mutable_trigger_shutdown() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:SubcontextReply.trigger_shutdown)
  return trigger_shutdown_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SubcontextReply::release_trigger_shutdown() {
  // @@protoc_insertion_point(field_release:SubcontextReply.trigger_shutdown)
  if (!has_trigger_shutdown()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return trigger_shutdown_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SubcontextReply::set_allocated_trigger_shutdown(std::string* trigger_shutdown) {
  if (trigger_shutdown != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  trigger_shutdown_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), trigger_shutdown);
  // @@protoc_insertion_point(field_set_allocated:SubcontextReply.trigger_shutdown)
}

inline bool SubcontextReply::has_reply() const {
  return reply_case() != REPLY_NOT_SET;
}
inline void SubcontextReply::clear_has_reply() {
  _oneof_case_[0] = REPLY_NOT_SET;
}
inline SubcontextReply::ReplyCase SubcontextReply::reply_case() const {
  return SubcontextReply::ReplyCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_system_2fcore_2finit_2fsubcontext_2eproto
