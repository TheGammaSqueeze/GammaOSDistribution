// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: system/core/debuggerd/proto/tombstone.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_system_2fcore_2fdebuggerd_2fproto_2ftombstone_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_system_2fcore_2fdebuggerd_2fproto_2ftombstone_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_system_2fcore_2fdebuggerd_2fproto_2ftombstone_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_system_2fcore_2fdebuggerd_2fproto_2ftombstone_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
class ArmMTEMetadata;
class ArmMTEMetadataDefaultTypeInternal;
extern ArmMTEMetadataDefaultTypeInternal _ArmMTEMetadata_default_instance_;
class BacktraceFrame;
class BacktraceFrameDefaultTypeInternal;
extern BacktraceFrameDefaultTypeInternal _BacktraceFrame_default_instance_;
class Cause;
class CauseDefaultTypeInternal;
extern CauseDefaultTypeInternal _Cause_default_instance_;
class FD;
class FDDefaultTypeInternal;
extern FDDefaultTypeInternal _FD_default_instance_;
class HeapObject;
class HeapObjectDefaultTypeInternal;
extern HeapObjectDefaultTypeInternal _HeapObject_default_instance_;
class LogBuffer;
class LogBufferDefaultTypeInternal;
extern LogBufferDefaultTypeInternal _LogBuffer_default_instance_;
class LogMessage;
class LogMessageDefaultTypeInternal;
extern LogMessageDefaultTypeInternal _LogMessage_default_instance_;
class MemoryDump;
class MemoryDumpDefaultTypeInternal;
extern MemoryDumpDefaultTypeInternal _MemoryDump_default_instance_;
class MemoryError;
class MemoryErrorDefaultTypeInternal;
extern MemoryErrorDefaultTypeInternal _MemoryError_default_instance_;
class MemoryMapping;
class MemoryMappingDefaultTypeInternal;
extern MemoryMappingDefaultTypeInternal _MemoryMapping_default_instance_;
class Register;
class RegisterDefaultTypeInternal;
extern RegisterDefaultTypeInternal _Register_default_instance_;
class Signal;
class SignalDefaultTypeInternal;
extern SignalDefaultTypeInternal _Signal_default_instance_;
class Thread;
class ThreadDefaultTypeInternal;
extern ThreadDefaultTypeInternal _Thread_default_instance_;
class Tombstone;
class TombstoneDefaultTypeInternal;
extern TombstoneDefaultTypeInternal _Tombstone_default_instance_;
class Tombstone_ThreadsEntry_DoNotUse;
class Tombstone_ThreadsEntry_DoNotUseDefaultTypeInternal;
extern Tombstone_ThreadsEntry_DoNotUseDefaultTypeInternal _Tombstone_ThreadsEntry_DoNotUse_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::ArmMTEMetadata* Arena::CreateMaybeMessage<::ArmMTEMetadata>(Arena*);
template<> ::BacktraceFrame* Arena::CreateMaybeMessage<::BacktraceFrame>(Arena*);
template<> ::Cause* Arena::CreateMaybeMessage<::Cause>(Arena*);
template<> ::FD* Arena::CreateMaybeMessage<::FD>(Arena*);
template<> ::HeapObject* Arena::CreateMaybeMessage<::HeapObject>(Arena*);
template<> ::LogBuffer* Arena::CreateMaybeMessage<::LogBuffer>(Arena*);
template<> ::LogMessage* Arena::CreateMaybeMessage<::LogMessage>(Arena*);
template<> ::MemoryDump* Arena::CreateMaybeMessage<::MemoryDump>(Arena*);
template<> ::MemoryError* Arena::CreateMaybeMessage<::MemoryError>(Arena*);
template<> ::MemoryMapping* Arena::CreateMaybeMessage<::MemoryMapping>(Arena*);
template<> ::Register* Arena::CreateMaybeMessage<::Register>(Arena*);
template<> ::Signal* Arena::CreateMaybeMessage<::Signal>(Arena*);
template<> ::Thread* Arena::CreateMaybeMessage<::Thread>(Arena*);
template<> ::Tombstone* Arena::CreateMaybeMessage<::Tombstone>(Arena*);
template<> ::Tombstone_ThreadsEntry_DoNotUse* Arena::CreateMaybeMessage<::Tombstone_ThreadsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum MemoryError_Tool : int {
  MemoryError_Tool_GWP_ASAN = 0,
  MemoryError_Tool_SCUDO = 1,
  MemoryError_Tool_MemoryError_Tool_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MemoryError_Tool_MemoryError_Tool_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MemoryError_Tool_IsValid(int value);
constexpr MemoryError_Tool MemoryError_Tool_Tool_MIN = MemoryError_Tool_GWP_ASAN;
constexpr MemoryError_Tool MemoryError_Tool_Tool_MAX = MemoryError_Tool_SCUDO;
constexpr int MemoryError_Tool_Tool_ARRAYSIZE = MemoryError_Tool_Tool_MAX + 1;

const std::string& MemoryError_Tool_Name(MemoryError_Tool value);
template<typename T>
inline const std::string& MemoryError_Tool_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MemoryError_Tool>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MemoryError_Tool_Name.");
  return MemoryError_Tool_Name(static_cast<MemoryError_Tool>(enum_t_value));
}
bool MemoryError_Tool_Parse(
    const std::string& name, MemoryError_Tool* value);
enum MemoryError_Type : int {
  MemoryError_Type_UNKNOWN = 0,
  MemoryError_Type_USE_AFTER_FREE = 1,
  MemoryError_Type_DOUBLE_FREE = 2,
  MemoryError_Type_INVALID_FREE = 3,
  MemoryError_Type_BUFFER_OVERFLOW = 4,
  MemoryError_Type_BUFFER_UNDERFLOW = 5,
  MemoryError_Type_MemoryError_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MemoryError_Type_MemoryError_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MemoryError_Type_IsValid(int value);
constexpr MemoryError_Type MemoryError_Type_Type_MIN = MemoryError_Type_UNKNOWN;
constexpr MemoryError_Type MemoryError_Type_Type_MAX = MemoryError_Type_BUFFER_UNDERFLOW;
constexpr int MemoryError_Type_Type_ARRAYSIZE = MemoryError_Type_Type_MAX + 1;

const std::string& MemoryError_Type_Name(MemoryError_Type value);
template<typename T>
inline const std::string& MemoryError_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MemoryError_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MemoryError_Type_Name.");
  return MemoryError_Type_Name(static_cast<MemoryError_Type>(enum_t_value));
}
bool MemoryError_Type_Parse(
    const std::string& name, MemoryError_Type* value);
enum Architecture : int {
  ARM32 = 0,
  ARM64 = 1,
  X86 = 2,
  X86_64 = 3,
  Architecture_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Architecture_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Architecture_IsValid(int value);
constexpr Architecture Architecture_MIN = ARM32;
constexpr Architecture Architecture_MAX = X86_64;
constexpr int Architecture_ARRAYSIZE = Architecture_MAX + 1;

const std::string& Architecture_Name(Architecture value);
template<typename T>
inline const std::string& Architecture_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Architecture>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Architecture_Name.");
  return Architecture_Name(static_cast<Architecture>(enum_t_value));
}
bool Architecture_Parse(
    const std::string& name, Architecture* value);
// ===================================================================

class Tombstone_ThreadsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Tombstone_ThreadsEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint32, ::Thread,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Tombstone_ThreadsEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint32, ::Thread,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  Tombstone_ThreadsEntry_DoNotUse();
  Tombstone_ThreadsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Tombstone_ThreadsEntry_DoNotUse& other);
  static const Tombstone_ThreadsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Tombstone_ThreadsEntry_DoNotUse*>(&_Tombstone_ThreadsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class Tombstone :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Tombstone) */ {
 public:
  Tombstone();
  virtual ~Tombstone();

  Tombstone(const Tombstone& from);
  Tombstone(Tombstone&& from) noexcept
    : Tombstone() {
    *this = ::std::move(from);
  }

  inline Tombstone& operator=(const Tombstone& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tombstone& operator=(Tombstone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Tombstone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tombstone* internal_default_instance() {
    return reinterpret_cast<const Tombstone*>(
               &_Tombstone_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Tombstone& a, Tombstone& b) {
    a.Swap(&b);
  }
  inline void Swap(Tombstone* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Tombstone* New() const final {
    return CreateMaybeMessage<Tombstone>(nullptr);
  }

  Tombstone* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Tombstone>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Tombstone& from);
  void MergeFrom(const Tombstone& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Tombstone* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Tombstone";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kCommandLineFieldNumber = 9,
    kCausesFieldNumber = 15,
    kThreadsFieldNumber = 16,
    kMemoryMappingsFieldNumber = 17,
    kLogBuffersFieldNumber = 18,
    kOpenFdsFieldNumber = 19,
    kBuildFingerprintFieldNumber = 2,
    kRevisionFieldNumber = 3,
    kTimestampFieldNumber = 4,
    kSelinuxLabelFieldNumber = 8,
    kAbortMessageFieldNumber = 14,
    kSignalInfoFieldNumber = 10,
    kArchFieldNumber = 1,
    kPidFieldNumber = 5,
    kTidFieldNumber = 6,
    kUidFieldNumber = 7,
    kProcessUptimeFieldNumber = 20,
  };
  // repeated string command_line = 9;
  int command_line_size() const;
  void clear_command_line();
  const std::string& command_line(int index) const;
  std::string* mutable_command_line(int index);
  void set_command_line(int index, const std::string& value);
  void set_command_line(int index, std::string&& value);
  void set_command_line(int index, const char* value);
  void set_command_line(int index, const char* value, size_t size);
  std::string* add_command_line();
  void add_command_line(const std::string& value);
  void add_command_line(std::string&& value);
  void add_command_line(const char* value);
  void add_command_line(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& command_line() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_command_line();

  // repeated .Cause causes = 15;
  int causes_size() const;
  void clear_causes();
  ::Cause* mutable_causes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Cause >*
      mutable_causes();
  const ::Cause& causes(int index) const;
  ::Cause* add_causes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Cause >&
      causes() const;

  // map<uint32, .Thread> threads = 16;
  int threads_size() const;
  void clear_threads();
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::Thread >&
      threads() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::Thread >*
      mutable_threads();

  // repeated .MemoryMapping memory_mappings = 17;
  int memory_mappings_size() const;
  void clear_memory_mappings();
  ::MemoryMapping* mutable_memory_mappings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MemoryMapping >*
      mutable_memory_mappings();
  const ::MemoryMapping& memory_mappings(int index) const;
  ::MemoryMapping* add_memory_mappings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MemoryMapping >&
      memory_mappings() const;

  // repeated .LogBuffer log_buffers = 18;
  int log_buffers_size() const;
  void clear_log_buffers();
  ::LogBuffer* mutable_log_buffers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogBuffer >*
      mutable_log_buffers();
  const ::LogBuffer& log_buffers(int index) const;
  ::LogBuffer* add_log_buffers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogBuffer >&
      log_buffers() const;

  // repeated .FD open_fds = 19;
  int open_fds_size() const;
  void clear_open_fds();
  ::FD* mutable_open_fds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FD >*
      mutable_open_fds();
  const ::FD& open_fds(int index) const;
  ::FD* add_open_fds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FD >&
      open_fds() const;

  // string build_fingerprint = 2;
  void clear_build_fingerprint();
  const std::string& build_fingerprint() const;
  void set_build_fingerprint(const std::string& value);
  void set_build_fingerprint(std::string&& value);
  void set_build_fingerprint(const char* value);
  void set_build_fingerprint(const char* value, size_t size);
  std::string* mutable_build_fingerprint();
  std::string* release_build_fingerprint();
  void set_allocated_build_fingerprint(std::string* build_fingerprint);

  // string revision = 3;
  void clear_revision();
  const std::string& revision() const;
  void set_revision(const std::string& value);
  void set_revision(std::string&& value);
  void set_revision(const char* value);
  void set_revision(const char* value, size_t size);
  std::string* mutable_revision();
  std::string* release_revision();
  void set_allocated_revision(std::string* revision);

  // string timestamp = 4;
  void clear_timestamp();
  const std::string& timestamp() const;
  void set_timestamp(const std::string& value);
  void set_timestamp(std::string&& value);
  void set_timestamp(const char* value);
  void set_timestamp(const char* value, size_t size);
  std::string* mutable_timestamp();
  std::string* release_timestamp();
  void set_allocated_timestamp(std::string* timestamp);

  // string selinux_label = 8;
  void clear_selinux_label();
  const std::string& selinux_label() const;
  void set_selinux_label(const std::string& value);
  void set_selinux_label(std::string&& value);
  void set_selinux_label(const char* value);
  void set_selinux_label(const char* value, size_t size);
  std::string* mutable_selinux_label();
  std::string* release_selinux_label();
  void set_allocated_selinux_label(std::string* selinux_label);

  // string abort_message = 14;
  void clear_abort_message();
  const std::string& abort_message() const;
  void set_abort_message(const std::string& value);
  void set_abort_message(std::string&& value);
  void set_abort_message(const char* value);
  void set_abort_message(const char* value, size_t size);
  std::string* mutable_abort_message();
  std::string* release_abort_message();
  void set_allocated_abort_message(std::string* abort_message);

  // .Signal signal_info = 10;
  bool has_signal_info() const;
  void clear_signal_info();
  const ::Signal& signal_info() const;
  ::Signal* release_signal_info();
  ::Signal* mutable_signal_info();
  void set_allocated_signal_info(::Signal* signal_info);

  // .Architecture arch = 1;
  void clear_arch();
  ::Architecture arch() const;
  void set_arch(::Architecture value);

  // uint32 pid = 5;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::uint32 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 tid = 6;
  void clear_tid();
  ::PROTOBUF_NAMESPACE_ID::uint32 tid() const;
  void set_tid(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 uid = 7;
  void clear_uid();
  ::PROTOBUF_NAMESPACE_ID::uint32 uid() const;
  void set_uid(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 process_uptime = 20;
  void clear_process_uptime();
  ::PROTOBUF_NAMESPACE_ID::uint32 process_uptime() const;
  void set_process_uptime(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:Tombstone)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> command_line_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Cause > causes_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      Tombstone_ThreadsEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::uint32, ::Thread,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > threads_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MemoryMapping > memory_mappings_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogBuffer > log_buffers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FD > open_fds_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr build_fingerprint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr revision_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timestamp_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr selinux_label_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr abort_message_;
  ::Signal* signal_info_;
  int arch_;
  ::PROTOBUF_NAMESPACE_ID::uint32 pid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 tid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 uid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 process_uptime_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_system_2fcore_2fdebuggerd_2fproto_2ftombstone_2eproto;
};
// -------------------------------------------------------------------

class Signal :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Signal) */ {
 public:
  Signal();
  virtual ~Signal();

  Signal(const Signal& from);
  Signal(Signal&& from) noexcept
    : Signal() {
    *this = ::std::move(from);
  }

  inline Signal& operator=(const Signal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Signal& operator=(Signal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Signal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signal* internal_default_instance() {
    return reinterpret_cast<const Signal*>(
               &_Signal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Signal& a, Signal& b) {
    a.Swap(&b);
  }
  inline void Swap(Signal* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Signal* New() const final {
    return CreateMaybeMessage<Signal>(nullptr);
  }

  Signal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Signal>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Signal& from);
  void MergeFrom(const Signal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Signal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Signal";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kCodeNameFieldNumber = 4,
    kFaultAdjacentMetadataFieldNumber = 10,
    kNumberFieldNumber = 1,
    kCodeFieldNumber = 3,
    kSenderUidFieldNumber = 6,
    kHasSenderFieldNumber = 5,
    kHasFaultAddressFieldNumber = 8,
    kFaultAddressFieldNumber = 9,
    kSenderPidFieldNumber = 7,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // string code_name = 4;
  void clear_code_name();
  const std::string& code_name() const;
  void set_code_name(const std::string& value);
  void set_code_name(std::string&& value);
  void set_code_name(const char* value);
  void set_code_name(const char* value, size_t size);
  std::string* mutable_code_name();
  std::string* release_code_name();
  void set_allocated_code_name(std::string* code_name);

  // .MemoryDump fault_adjacent_metadata = 10;
  bool has_fault_adjacent_metadata() const;
  void clear_fault_adjacent_metadata();
  const ::MemoryDump& fault_adjacent_metadata() const;
  ::MemoryDump* release_fault_adjacent_metadata();
  ::MemoryDump* mutable_fault_adjacent_metadata();
  void set_allocated_fault_adjacent_metadata(::MemoryDump* fault_adjacent_metadata);

  // int32 number = 1;
  void clear_number();
  ::PROTOBUF_NAMESPACE_ID::int32 number() const;
  void set_number(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 code = 3;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 sender_uid = 6;
  void clear_sender_uid();
  ::PROTOBUF_NAMESPACE_ID::int32 sender_uid() const;
  void set_sender_uid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // bool has_sender = 5;
  void clear_has_sender();
  bool has_sender() const;
  void set_has_sender(bool value);

  // bool has_fault_address = 8;
  void clear_has_fault_address();
  bool has_fault_address() const;
  void set_has_fault_address(bool value);

  // uint64 fault_address = 9;
  void clear_fault_address();
  ::PROTOBUF_NAMESPACE_ID::uint64 fault_address() const;
  void set_fault_address(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // int32 sender_pid = 7;
  void clear_sender_pid();
  ::PROTOBUF_NAMESPACE_ID::int32 sender_pid() const;
  void set_sender_pid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:Signal)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_name_;
  ::MemoryDump* fault_adjacent_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 number_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  ::PROTOBUF_NAMESPACE_ID::int32 sender_uid_;
  bool has_sender_;
  bool has_fault_address_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fault_address_;
  ::PROTOBUF_NAMESPACE_ID::int32 sender_pid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_system_2fcore_2fdebuggerd_2fproto_2ftombstone_2eproto;
};
// -------------------------------------------------------------------

class HeapObject :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:HeapObject) */ {
 public:
  HeapObject();
  virtual ~HeapObject();

  HeapObject(const HeapObject& from);
  HeapObject(HeapObject&& from) noexcept
    : HeapObject() {
    *this = ::std::move(from);
  }

  inline HeapObject& operator=(const HeapObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeapObject& operator=(HeapObject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const HeapObject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeapObject* internal_default_instance() {
    return reinterpret_cast<const HeapObject*>(
               &_HeapObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(HeapObject& a, HeapObject& b) {
    a.Swap(&b);
  }
  inline void Swap(HeapObject* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HeapObject* New() const final {
    return CreateMaybeMessage<HeapObject>(nullptr);
  }

  HeapObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeapObject>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const HeapObject& from);
  void MergeFrom(const HeapObject& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeapObject* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HeapObject";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllocationBacktraceFieldNumber = 4,
    kDeallocationBacktraceFieldNumber = 6,
    kAddressFieldNumber = 1,
    kSizeFieldNumber = 2,
    kAllocationTidFieldNumber = 3,
    kDeallocationTidFieldNumber = 5,
  };
  // repeated .BacktraceFrame allocation_backtrace = 4;
  int allocation_backtrace_size() const;
  void clear_allocation_backtrace();
  ::BacktraceFrame* mutable_allocation_backtrace(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BacktraceFrame >*
      mutable_allocation_backtrace();
  const ::BacktraceFrame& allocation_backtrace(int index) const;
  ::BacktraceFrame* add_allocation_backtrace();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BacktraceFrame >&
      allocation_backtrace() const;

  // repeated .BacktraceFrame deallocation_backtrace = 6;
  int deallocation_backtrace_size() const;
  void clear_deallocation_backtrace();
  ::BacktraceFrame* mutable_deallocation_backtrace(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BacktraceFrame >*
      mutable_deallocation_backtrace();
  const ::BacktraceFrame& deallocation_backtrace(int index) const;
  ::BacktraceFrame* add_deallocation_backtrace();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BacktraceFrame >&
      deallocation_backtrace() const;

  // uint64 address = 1;
  void clear_address();
  ::PROTOBUF_NAMESPACE_ID::uint64 address() const;
  void set_address(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint64 size = 2;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint64 allocation_tid = 3;
  void clear_allocation_tid();
  ::PROTOBUF_NAMESPACE_ID::uint64 allocation_tid() const;
  void set_allocation_tid(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint64 deallocation_tid = 5;
  void clear_deallocation_tid();
  ::PROTOBUF_NAMESPACE_ID::uint64 deallocation_tid() const;
  void set_deallocation_tid(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:HeapObject)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BacktraceFrame > allocation_backtrace_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BacktraceFrame > deallocation_backtrace_;
  ::PROTOBUF_NAMESPACE_ID::uint64 address_;
  ::PROTOBUF_NAMESPACE_ID::uint64 size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 allocation_tid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 deallocation_tid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_system_2fcore_2fdebuggerd_2fproto_2ftombstone_2eproto;
};
// -------------------------------------------------------------------

class MemoryError :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:MemoryError) */ {
 public:
  MemoryError();
  virtual ~MemoryError();

  MemoryError(const MemoryError& from);
  MemoryError(MemoryError&& from) noexcept
    : MemoryError() {
    *this = ::std::move(from);
  }

  inline MemoryError& operator=(const MemoryError& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemoryError& operator=(MemoryError&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const MemoryError& default_instance();

  enum LocationCase {
    kHeap = 3,
    LOCATION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MemoryError* internal_default_instance() {
    return reinterpret_cast<const MemoryError*>(
               &_MemoryError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MemoryError& a, MemoryError& b) {
    a.Swap(&b);
  }
  inline void Swap(MemoryError* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MemoryError* New() const final {
    return CreateMaybeMessage<MemoryError>(nullptr);
  }

  MemoryError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MemoryError>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MemoryError& from);
  void MergeFrom(const MemoryError& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MemoryError* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MemoryError";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef MemoryError_Tool Tool;
  static constexpr Tool GWP_ASAN =
    MemoryError_Tool_GWP_ASAN;
  static constexpr Tool SCUDO =
    MemoryError_Tool_SCUDO;
  static inline bool Tool_IsValid(int value) {
    return MemoryError_Tool_IsValid(value);
  }
  static constexpr Tool Tool_MIN =
    MemoryError_Tool_Tool_MIN;
  static constexpr Tool Tool_MAX =
    MemoryError_Tool_Tool_MAX;
  static constexpr int Tool_ARRAYSIZE =
    MemoryError_Tool_Tool_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Tool_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Tool>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Tool_Name.");
    return MemoryError_Tool_Name(enum_t_value);
  }
  static inline bool Tool_Parse(const std::string& name,
      Tool* value) {
    return MemoryError_Tool_Parse(name, value);
  }

  typedef MemoryError_Type Type;
  static constexpr Type UNKNOWN =
    MemoryError_Type_UNKNOWN;
  static constexpr Type USE_AFTER_FREE =
    MemoryError_Type_USE_AFTER_FREE;
  static constexpr Type DOUBLE_FREE =
    MemoryError_Type_DOUBLE_FREE;
  static constexpr Type INVALID_FREE =
    MemoryError_Type_INVALID_FREE;
  static constexpr Type BUFFER_OVERFLOW =
    MemoryError_Type_BUFFER_OVERFLOW;
  static constexpr Type BUFFER_UNDERFLOW =
    MemoryError_Type_BUFFER_UNDERFLOW;
  static inline bool Type_IsValid(int value) {
    return MemoryError_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    MemoryError_Type_Type_MIN;
  static constexpr Type Type_MAX =
    MemoryError_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    MemoryError_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return MemoryError_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return MemoryError_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kToolFieldNumber = 1,
    kTypeFieldNumber = 2,
    kHeapFieldNumber = 3,
  };
  // .MemoryError.Tool tool = 1;
  void clear_tool();
  ::MemoryError_Tool tool() const;
  void set_tool(::MemoryError_Tool value);

  // .MemoryError.Type type = 2;
  void clear_type();
  ::MemoryError_Type type() const;
  void set_type(::MemoryError_Type value);

  // .HeapObject heap = 3;
  bool has_heap() const;
  void clear_heap();
  const ::HeapObject& heap() const;
  ::HeapObject* release_heap();
  ::HeapObject* mutable_heap();
  void set_allocated_heap(::HeapObject* heap);

  void clear_location();
  LocationCase location_case() const;
  // @@protoc_insertion_point(class_scope:MemoryError)
 private:
  class _Internal;
  void set_has_heap();

  inline bool has_location() const;
  inline void clear_has_location();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  int tool_;
  int type_;
  union LocationUnion {
    LocationUnion() {}
    ::HeapObject* heap_;
  } location_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_system_2fcore_2fdebuggerd_2fproto_2ftombstone_2eproto;
};
// -------------------------------------------------------------------

class Cause :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Cause) */ {
 public:
  Cause();
  virtual ~Cause();

  Cause(const Cause& from);
  Cause(Cause&& from) noexcept
    : Cause() {
    *this = ::std::move(from);
  }

  inline Cause& operator=(const Cause& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cause& operator=(Cause&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Cause& default_instance();

  enum DetailsCase {
    kMemoryError = 2,
    DETAILS_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Cause* internal_default_instance() {
    return reinterpret_cast<const Cause*>(
               &_Cause_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Cause& a, Cause& b) {
    a.Swap(&b);
  }
  inline void Swap(Cause* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Cause* New() const final {
    return CreateMaybeMessage<Cause>(nullptr);
  }

  Cause* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Cause>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Cause& from);
  void MergeFrom(const Cause& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Cause* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Cause";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHumanReadableFieldNumber = 1,
    kMemoryErrorFieldNumber = 2,
  };
  // string human_readable = 1;
  void clear_human_readable();
  const std::string& human_readable() const;
  void set_human_readable(const std::string& value);
  void set_human_readable(std::string&& value);
  void set_human_readable(const char* value);
  void set_human_readable(const char* value, size_t size);
  std::string* mutable_human_readable();
  std::string* release_human_readable();
  void set_allocated_human_readable(std::string* human_readable);

  // .MemoryError memory_error = 2;
  bool has_memory_error() const;
  void clear_memory_error();
  const ::MemoryError& memory_error() const;
  ::MemoryError* release_memory_error();
  ::MemoryError* mutable_memory_error();
  void set_allocated_memory_error(::MemoryError* memory_error);

  void clear_details();
  DetailsCase details_case() const;
  // @@protoc_insertion_point(class_scope:Cause)
 private:
  class _Internal;
  void set_has_memory_error();

  inline bool has_details() const;
  inline void clear_has_details();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr human_readable_;
  union DetailsUnion {
    DetailsUnion() {}
    ::MemoryError* memory_error_;
  } details_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_system_2fcore_2fdebuggerd_2fproto_2ftombstone_2eproto;
};
// -------------------------------------------------------------------

class Register :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Register) */ {
 public:
  Register();
  virtual ~Register();

  Register(const Register& from);
  Register(Register&& from) noexcept
    : Register() {
    *this = ::std::move(from);
  }

  inline Register& operator=(const Register& from) {
    CopyFrom(from);
    return *this;
  }
  inline Register& operator=(Register&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Register& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Register* internal_default_instance() {
    return reinterpret_cast<const Register*>(
               &_Register_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Register& a, Register& b) {
    a.Swap(&b);
  }
  inline void Swap(Register* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Register* New() const final {
    return CreateMaybeMessage<Register>(nullptr);
  }

  Register* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Register>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Register& from);
  void MergeFrom(const Register& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Register* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Register";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kU64FieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // uint64 u64 = 2;
  void clear_u64();
  ::PROTOBUF_NAMESPACE_ID::uint64 u64() const;
  void set_u64(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:Register)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 u64_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_system_2fcore_2fdebuggerd_2fproto_2ftombstone_2eproto;
};
// -------------------------------------------------------------------

class Thread :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Thread) */ {
 public:
  Thread();
  virtual ~Thread();

  Thread(const Thread& from);
  Thread(Thread&& from) noexcept
    : Thread() {
    *this = ::std::move(from);
  }

  inline Thread& operator=(const Thread& from) {
    CopyFrom(from);
    return *this;
  }
  inline Thread& operator=(Thread&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Thread& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Thread* internal_default_instance() {
    return reinterpret_cast<const Thread*>(
               &_Thread_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Thread& a, Thread& b) {
    a.Swap(&b);
  }
  inline void Swap(Thread* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Thread* New() const final {
    return CreateMaybeMessage<Thread>(nullptr);
  }

  Thread* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Thread>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Thread& from);
  void MergeFrom(const Thread& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Thread* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Thread";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegistersFieldNumber = 3,
    kCurrentBacktraceFieldNumber = 4,
    kMemoryDumpFieldNumber = 5,
    kBacktraceNoteFieldNumber = 7,
    kNameFieldNumber = 2,
    kTaggedAddrCtrlFieldNumber = 6,
    kIdFieldNumber = 1,
  };
  // repeated .Register registers = 3;
  int registers_size() const;
  void clear_registers();
  ::Register* mutable_registers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Register >*
      mutable_registers();
  const ::Register& registers(int index) const;
  ::Register* add_registers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Register >&
      registers() const;

  // repeated .BacktraceFrame current_backtrace = 4;
  int current_backtrace_size() const;
  void clear_current_backtrace();
  ::BacktraceFrame* mutable_current_backtrace(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BacktraceFrame >*
      mutable_current_backtrace();
  const ::BacktraceFrame& current_backtrace(int index) const;
  ::BacktraceFrame* add_current_backtrace();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BacktraceFrame >&
      current_backtrace() const;

  // repeated .MemoryDump memory_dump = 5;
  int memory_dump_size() const;
  void clear_memory_dump();
  ::MemoryDump* mutable_memory_dump(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MemoryDump >*
      mutable_memory_dump();
  const ::MemoryDump& memory_dump(int index) const;
  ::MemoryDump* add_memory_dump();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MemoryDump >&
      memory_dump() const;

  // repeated string backtrace_note = 7;
  int backtrace_note_size() const;
  void clear_backtrace_note();
  const std::string& backtrace_note(int index) const;
  std::string* mutable_backtrace_note(int index);
  void set_backtrace_note(int index, const std::string& value);
  void set_backtrace_note(int index, std::string&& value);
  void set_backtrace_note(int index, const char* value);
  void set_backtrace_note(int index, const char* value, size_t size);
  std::string* add_backtrace_note();
  void add_backtrace_note(const std::string& value);
  void add_backtrace_note(std::string&& value);
  void add_backtrace_note(const char* value);
  void add_backtrace_note(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& backtrace_note() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_backtrace_note();

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // int64 tagged_addr_ctrl = 6;
  void clear_tagged_addr_ctrl();
  ::PROTOBUF_NAMESPACE_ID::int64 tagged_addr_ctrl() const;
  void set_tagged_addr_ctrl(::PROTOBUF_NAMESPACE_ID::int64 value);

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:Thread)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Register > registers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BacktraceFrame > current_backtrace_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MemoryDump > memory_dump_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> backtrace_note_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int64 tagged_addr_ctrl_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_system_2fcore_2fdebuggerd_2fproto_2ftombstone_2eproto;
};
// -------------------------------------------------------------------

class BacktraceFrame :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:BacktraceFrame) */ {
 public:
  BacktraceFrame();
  virtual ~BacktraceFrame();

  BacktraceFrame(const BacktraceFrame& from);
  BacktraceFrame(BacktraceFrame&& from) noexcept
    : BacktraceFrame() {
    *this = ::std::move(from);
  }

  inline BacktraceFrame& operator=(const BacktraceFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline BacktraceFrame& operator=(BacktraceFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const BacktraceFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BacktraceFrame* internal_default_instance() {
    return reinterpret_cast<const BacktraceFrame*>(
               &_BacktraceFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BacktraceFrame& a, BacktraceFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(BacktraceFrame* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BacktraceFrame* New() const final {
    return CreateMaybeMessage<BacktraceFrame>(nullptr);
  }

  BacktraceFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BacktraceFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const BacktraceFrame& from);
  void MergeFrom(const BacktraceFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BacktraceFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BacktraceFrame";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFunctionNameFieldNumber = 4,
    kFileNameFieldNumber = 6,
    kBuildIdFieldNumber = 8,
    kRelPcFieldNumber = 1,
    kPcFieldNumber = 2,
    kSpFieldNumber = 3,
    kFunctionOffsetFieldNumber = 5,
    kFileMapOffsetFieldNumber = 7,
  };
  // string function_name = 4;
  void clear_function_name();
  const std::string& function_name() const;
  void set_function_name(const std::string& value);
  void set_function_name(std::string&& value);
  void set_function_name(const char* value);
  void set_function_name(const char* value, size_t size);
  std::string* mutable_function_name();
  std::string* release_function_name();
  void set_allocated_function_name(std::string* function_name);

  // string file_name = 6;
  void clear_file_name();
  const std::string& file_name() const;
  void set_file_name(const std::string& value);
  void set_file_name(std::string&& value);
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  std::string* mutable_file_name();
  std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);

  // string build_id = 8;
  void clear_build_id();
  const std::string& build_id() const;
  void set_build_id(const std::string& value);
  void set_build_id(std::string&& value);
  void set_build_id(const char* value);
  void set_build_id(const char* value, size_t size);
  std::string* mutable_build_id();
  std::string* release_build_id();
  void set_allocated_build_id(std::string* build_id);

  // uint64 rel_pc = 1;
  void clear_rel_pc();
  ::PROTOBUF_NAMESPACE_ID::uint64 rel_pc() const;
  void set_rel_pc(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint64 pc = 2;
  void clear_pc();
  ::PROTOBUF_NAMESPACE_ID::uint64 pc() const;
  void set_pc(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint64 sp = 3;
  void clear_sp();
  ::PROTOBUF_NAMESPACE_ID::uint64 sp() const;
  void set_sp(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint64 function_offset = 5;
  void clear_function_offset();
  ::PROTOBUF_NAMESPACE_ID::uint64 function_offset() const;
  void set_function_offset(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint64 file_map_offset = 7;
  void clear_file_map_offset();
  ::PROTOBUF_NAMESPACE_ID::uint64 file_map_offset() const;
  void set_file_map_offset(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:BacktraceFrame)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr build_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 rel_pc_;
  ::PROTOBUF_NAMESPACE_ID::uint64 pc_;
  ::PROTOBUF_NAMESPACE_ID::uint64 sp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 function_offset_;
  ::PROTOBUF_NAMESPACE_ID::uint64 file_map_offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_system_2fcore_2fdebuggerd_2fproto_2ftombstone_2eproto;
};
// -------------------------------------------------------------------

class ArmMTEMetadata :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ArmMTEMetadata) */ {
 public:
  ArmMTEMetadata();
  virtual ~ArmMTEMetadata();

  ArmMTEMetadata(const ArmMTEMetadata& from);
  ArmMTEMetadata(ArmMTEMetadata&& from) noexcept
    : ArmMTEMetadata() {
    *this = ::std::move(from);
  }

  inline ArmMTEMetadata& operator=(const ArmMTEMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArmMTEMetadata& operator=(ArmMTEMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ArmMTEMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArmMTEMetadata* internal_default_instance() {
    return reinterpret_cast<const ArmMTEMetadata*>(
               &_ArmMTEMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ArmMTEMetadata& a, ArmMTEMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(ArmMTEMetadata* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ArmMTEMetadata* New() const final {
    return CreateMaybeMessage<ArmMTEMetadata>(nullptr);
  }

  ArmMTEMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ArmMTEMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ArmMTEMetadata& from);
  void MergeFrom(const ArmMTEMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ArmMTEMetadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmMTEMetadata";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemoryTagsFieldNumber = 1,
  };
  // bytes memory_tags = 1;
  void clear_memory_tags();
  const std::string& memory_tags() const;
  void set_memory_tags(const std::string& value);
  void set_memory_tags(std::string&& value);
  void set_memory_tags(const char* value);
  void set_memory_tags(const void* value, size_t size);
  std::string* mutable_memory_tags();
  std::string* release_memory_tags();
  void set_allocated_memory_tags(std::string* memory_tags);

  // @@protoc_insertion_point(class_scope:ArmMTEMetadata)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memory_tags_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_system_2fcore_2fdebuggerd_2fproto_2ftombstone_2eproto;
};
// -------------------------------------------------------------------

class MemoryDump :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:MemoryDump) */ {
 public:
  MemoryDump();
  virtual ~MemoryDump();

  MemoryDump(const MemoryDump& from);
  MemoryDump(MemoryDump&& from) noexcept
    : MemoryDump() {
    *this = ::std::move(from);
  }

  inline MemoryDump& operator=(const MemoryDump& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemoryDump& operator=(MemoryDump&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const MemoryDump& default_instance();

  enum MetadataCase {
    kArmMteMetadata = 6,
    METADATA_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MemoryDump* internal_default_instance() {
    return reinterpret_cast<const MemoryDump*>(
               &_MemoryDump_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MemoryDump& a, MemoryDump& b) {
    a.Swap(&b);
  }
  inline void Swap(MemoryDump* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MemoryDump* New() const final {
    return CreateMaybeMessage<MemoryDump>(nullptr);
  }

  MemoryDump* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MemoryDump>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MemoryDump& from);
  void MergeFrom(const MemoryDump& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MemoryDump* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MemoryDump";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegisterNameFieldNumber = 1,
    kMappingNameFieldNumber = 2,
    kMemoryFieldNumber = 4,
    kBeginAddressFieldNumber = 3,
    kArmMteMetadataFieldNumber = 6,
  };
  // string register_name = 1;
  void clear_register_name();
  const std::string& register_name() const;
  void set_register_name(const std::string& value);
  void set_register_name(std::string&& value);
  void set_register_name(const char* value);
  void set_register_name(const char* value, size_t size);
  std::string* mutable_register_name();
  std::string* release_register_name();
  void set_allocated_register_name(std::string* register_name);

  // string mapping_name = 2;
  void clear_mapping_name();
  const std::string& mapping_name() const;
  void set_mapping_name(const std::string& value);
  void set_mapping_name(std::string&& value);
  void set_mapping_name(const char* value);
  void set_mapping_name(const char* value, size_t size);
  std::string* mutable_mapping_name();
  std::string* release_mapping_name();
  void set_allocated_mapping_name(std::string* mapping_name);

  // bytes memory = 4;
  void clear_memory();
  const std::string& memory() const;
  void set_memory(const std::string& value);
  void set_memory(std::string&& value);
  void set_memory(const char* value);
  void set_memory(const void* value, size_t size);
  std::string* mutable_memory();
  std::string* release_memory();
  void set_allocated_memory(std::string* memory);

  // uint64 begin_address = 3;
  void clear_begin_address();
  ::PROTOBUF_NAMESPACE_ID::uint64 begin_address() const;
  void set_begin_address(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // .ArmMTEMetadata arm_mte_metadata = 6;
  bool has_arm_mte_metadata() const;
  void clear_arm_mte_metadata();
  const ::ArmMTEMetadata& arm_mte_metadata() const;
  ::ArmMTEMetadata* release_arm_mte_metadata();
  ::ArmMTEMetadata* mutable_arm_mte_metadata();
  void set_allocated_arm_mte_metadata(::ArmMTEMetadata* arm_mte_metadata);

  void clear_metadata();
  MetadataCase metadata_case() const;
  // @@protoc_insertion_point(class_scope:MemoryDump)
 private:
  class _Internal;
  void set_has_arm_mte_metadata();

  inline bool has_metadata() const;
  inline void clear_has_metadata();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr register_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapping_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memory_;
  ::PROTOBUF_NAMESPACE_ID::uint64 begin_address_;
  union MetadataUnion {
    MetadataUnion() {}
    ::ArmMTEMetadata* arm_mte_metadata_;
  } metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_system_2fcore_2fdebuggerd_2fproto_2ftombstone_2eproto;
};
// -------------------------------------------------------------------

class MemoryMapping :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:MemoryMapping) */ {
 public:
  MemoryMapping();
  virtual ~MemoryMapping();

  MemoryMapping(const MemoryMapping& from);
  MemoryMapping(MemoryMapping&& from) noexcept
    : MemoryMapping() {
    *this = ::std::move(from);
  }

  inline MemoryMapping& operator=(const MemoryMapping& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemoryMapping& operator=(MemoryMapping&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const MemoryMapping& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MemoryMapping* internal_default_instance() {
    return reinterpret_cast<const MemoryMapping*>(
               &_MemoryMapping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MemoryMapping& a, MemoryMapping& b) {
    a.Swap(&b);
  }
  inline void Swap(MemoryMapping* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MemoryMapping* New() const final {
    return CreateMaybeMessage<MemoryMapping>(nullptr);
  }

  MemoryMapping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MemoryMapping>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MemoryMapping& from);
  void MergeFrom(const MemoryMapping& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MemoryMapping* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MemoryMapping";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMappingNameFieldNumber = 7,
    kBuildIdFieldNumber = 8,
    kBeginAddressFieldNumber = 1,
    kEndAddressFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kLoadBiasFieldNumber = 9,
    kReadFieldNumber = 4,
    kWriteFieldNumber = 5,
    kExecuteFieldNumber = 6,
  };
  // string mapping_name = 7;
  void clear_mapping_name();
  const std::string& mapping_name() const;
  void set_mapping_name(const std::string& value);
  void set_mapping_name(std::string&& value);
  void set_mapping_name(const char* value);
  void set_mapping_name(const char* value, size_t size);
  std::string* mutable_mapping_name();
  std::string* release_mapping_name();
  void set_allocated_mapping_name(std::string* mapping_name);

  // string build_id = 8;
  void clear_build_id();
  const std::string& build_id() const;
  void set_build_id(const std::string& value);
  void set_build_id(std::string&& value);
  void set_build_id(const char* value);
  void set_build_id(const char* value, size_t size);
  std::string* mutable_build_id();
  std::string* release_build_id();
  void set_allocated_build_id(std::string* build_id);

  // uint64 begin_address = 1;
  void clear_begin_address();
  ::PROTOBUF_NAMESPACE_ID::uint64 begin_address() const;
  void set_begin_address(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint64 end_address = 2;
  void clear_end_address();
  ::PROTOBUF_NAMESPACE_ID::uint64 end_address() const;
  void set_end_address(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint64 offset = 3;
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::uint64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint64 load_bias = 9;
  void clear_load_bias();
  ::PROTOBUF_NAMESPACE_ID::uint64 load_bias() const;
  void set_load_bias(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // bool read = 4;
  void clear_read();
  bool read() const;
  void set_read(bool value);

  // bool write = 5;
  void clear_write();
  bool write() const;
  void set_write(bool value);

  // bool execute = 6;
  void clear_execute();
  bool execute() const;
  void set_execute(bool value);

  // @@protoc_insertion_point(class_scope:MemoryMapping)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapping_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr build_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 begin_address_;
  ::PROTOBUF_NAMESPACE_ID::uint64 end_address_;
  ::PROTOBUF_NAMESPACE_ID::uint64 offset_;
  ::PROTOBUF_NAMESPACE_ID::uint64 load_bias_;
  bool read_;
  bool write_;
  bool execute_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_system_2fcore_2fdebuggerd_2fproto_2ftombstone_2eproto;
};
// -------------------------------------------------------------------

class FD :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:FD) */ {
 public:
  FD();
  virtual ~FD();

  FD(const FD& from);
  FD(FD&& from) noexcept
    : FD() {
    *this = ::std::move(from);
  }

  inline FD& operator=(const FD& from) {
    CopyFrom(from);
    return *this;
  }
  inline FD& operator=(FD&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const FD& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FD* internal_default_instance() {
    return reinterpret_cast<const FD*>(
               &_FD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FD& a, FD& b) {
    a.Swap(&b);
  }
  inline void Swap(FD* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FD* New() const final {
    return CreateMaybeMessage<FD>(nullptr);
  }

  FD* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FD>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const FD& from);
  void MergeFrom(const FD& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FD* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FD";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 2,
    kOwnerFieldNumber = 3,
    kTagFieldNumber = 4,
    kFdFieldNumber = 1,
  };
  // string path = 2;
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);

  // string owner = 3;
  void clear_owner();
  const std::string& owner() const;
  void set_owner(const std::string& value);
  void set_owner(std::string&& value);
  void set_owner(const char* value);
  void set_owner(const char* value, size_t size);
  std::string* mutable_owner();
  std::string* release_owner();
  void set_allocated_owner(std::string* owner);

  // uint64 tag = 4;
  void clear_tag();
  ::PROTOBUF_NAMESPACE_ID::uint64 tag() const;
  void set_tag(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // int32 fd = 1;
  void clear_fd();
  ::PROTOBUF_NAMESPACE_ID::int32 fd() const;
  void set_fd(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:FD)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
  ::PROTOBUF_NAMESPACE_ID::uint64 tag_;
  ::PROTOBUF_NAMESPACE_ID::int32 fd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_system_2fcore_2fdebuggerd_2fproto_2ftombstone_2eproto;
};
// -------------------------------------------------------------------

class LogBuffer :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:LogBuffer) */ {
 public:
  LogBuffer();
  virtual ~LogBuffer();

  LogBuffer(const LogBuffer& from);
  LogBuffer(LogBuffer&& from) noexcept
    : LogBuffer() {
    *this = ::std::move(from);
  }

  inline LogBuffer& operator=(const LogBuffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogBuffer& operator=(LogBuffer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const LogBuffer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogBuffer* internal_default_instance() {
    return reinterpret_cast<const LogBuffer*>(
               &_LogBuffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(LogBuffer& a, LogBuffer& b) {
    a.Swap(&b);
  }
  inline void Swap(LogBuffer* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogBuffer* New() const final {
    return CreateMaybeMessage<LogBuffer>(nullptr);
  }

  LogBuffer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogBuffer>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const LogBuffer& from);
  void MergeFrom(const LogBuffer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogBuffer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LogBuffer";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogsFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .LogMessage logs = 2;
  int logs_size() const;
  void clear_logs();
  ::LogMessage* mutable_logs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogMessage >*
      mutable_logs();
  const ::LogMessage& logs(int index) const;
  ::LogMessage* add_logs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogMessage >&
      logs() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // @@protoc_insertion_point(class_scope:LogBuffer)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogMessage > logs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_system_2fcore_2fdebuggerd_2fproto_2ftombstone_2eproto;
};
// -------------------------------------------------------------------

class LogMessage :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:LogMessage) */ {
 public:
  LogMessage();
  virtual ~LogMessage();

  LogMessage(const LogMessage& from);
  LogMessage(LogMessage&& from) noexcept
    : LogMessage() {
    *this = ::std::move(from);
  }

  inline LogMessage& operator=(const LogMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogMessage& operator=(LogMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const LogMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogMessage* internal_default_instance() {
    return reinterpret_cast<const LogMessage*>(
               &_LogMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(LogMessage& a, LogMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(LogMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogMessage* New() const final {
    return CreateMaybeMessage<LogMessage>(nullptr);
  }

  LogMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const LogMessage& from);
  void MergeFrom(const LogMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LogMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kTagFieldNumber = 5,
    kMessageFieldNumber = 6,
    kPidFieldNumber = 2,
    kTidFieldNumber = 3,
    kPriorityFieldNumber = 4,
  };
  // string timestamp = 1;
  void clear_timestamp();
  const std::string& timestamp() const;
  void set_timestamp(const std::string& value);
  void set_timestamp(std::string&& value);
  void set_timestamp(const char* value);
  void set_timestamp(const char* value, size_t size);
  std::string* mutable_timestamp();
  std::string* release_timestamp();
  void set_allocated_timestamp(std::string* timestamp);

  // string tag = 5;
  void clear_tag();
  const std::string& tag() const;
  void set_tag(const std::string& value);
  void set_tag(std::string&& value);
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  std::string* mutable_tag();
  std::string* release_tag();
  void set_allocated_tag(std::string* tag);

  // string message = 6;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);

  // uint32 pid = 2;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::uint32 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 tid = 3;
  void clear_tid();
  ::PROTOBUF_NAMESPACE_ID::uint32 tid() const;
  void set_tid(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 priority = 4;
  void clear_priority();
  ::PROTOBUF_NAMESPACE_ID::uint32 priority() const;
  void set_priority(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:LogMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timestamp_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::uint32 pid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 tid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 priority_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_system_2fcore_2fdebuggerd_2fproto_2ftombstone_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Tombstone

// .Architecture arch = 1;
inline void Tombstone::clear_arch() {
  arch_ = 0;
}
inline ::Architecture Tombstone::arch() const {
  // @@protoc_insertion_point(field_get:Tombstone.arch)
  return static_cast< ::Architecture >(arch_);
}
inline void Tombstone::set_arch(::Architecture value) {
  
  arch_ = value;
  // @@protoc_insertion_point(field_set:Tombstone.arch)
}

// string build_fingerprint = 2;
inline void Tombstone::clear_build_fingerprint() {
  build_fingerprint_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Tombstone::build_fingerprint() const {
  // @@protoc_insertion_point(field_get:Tombstone.build_fingerprint)
  return build_fingerprint_.GetNoArena();
}
inline void Tombstone::set_build_fingerprint(const std::string& value) {
  
  build_fingerprint_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Tombstone.build_fingerprint)
}
inline void Tombstone::set_build_fingerprint(std::string&& value) {
  
  build_fingerprint_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Tombstone.build_fingerprint)
}
inline void Tombstone::set_build_fingerprint(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  build_fingerprint_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Tombstone.build_fingerprint)
}
inline void Tombstone::set_build_fingerprint(const char* value, size_t size) {
  
  build_fingerprint_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Tombstone.build_fingerprint)
}
inline std::string* Tombstone::mutable_build_fingerprint() {
  
  // @@protoc_insertion_point(field_mutable:Tombstone.build_fingerprint)
  return build_fingerprint_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Tombstone::release_build_fingerprint() {
  // @@protoc_insertion_point(field_release:Tombstone.build_fingerprint)
  
  return build_fingerprint_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Tombstone::set_allocated_build_fingerprint(std::string* build_fingerprint) {
  if (build_fingerprint != nullptr) {
    
  } else {
    
  }
  build_fingerprint_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), build_fingerprint);
  // @@protoc_insertion_point(field_set_allocated:Tombstone.build_fingerprint)
}

// string revision = 3;
inline void Tombstone::clear_revision() {
  revision_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Tombstone::revision() const {
  // @@protoc_insertion_point(field_get:Tombstone.revision)
  return revision_.GetNoArena();
}
inline void Tombstone::set_revision(const std::string& value) {
  
  revision_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Tombstone.revision)
}
inline void Tombstone::set_revision(std::string&& value) {
  
  revision_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Tombstone.revision)
}
inline void Tombstone::set_revision(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  revision_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Tombstone.revision)
}
inline void Tombstone::set_revision(const char* value, size_t size) {
  
  revision_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Tombstone.revision)
}
inline std::string* Tombstone::mutable_revision() {
  
  // @@protoc_insertion_point(field_mutable:Tombstone.revision)
  return revision_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Tombstone::release_revision() {
  // @@protoc_insertion_point(field_release:Tombstone.revision)
  
  return revision_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Tombstone::set_allocated_revision(std::string* revision) {
  if (revision != nullptr) {
    
  } else {
    
  }
  revision_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), revision);
  // @@protoc_insertion_point(field_set_allocated:Tombstone.revision)
}

// string timestamp = 4;
inline void Tombstone::clear_timestamp() {
  timestamp_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Tombstone::timestamp() const {
  // @@protoc_insertion_point(field_get:Tombstone.timestamp)
  return timestamp_.GetNoArena();
}
inline void Tombstone::set_timestamp(const std::string& value) {
  
  timestamp_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Tombstone.timestamp)
}
inline void Tombstone::set_timestamp(std::string&& value) {
  
  timestamp_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Tombstone.timestamp)
}
inline void Tombstone::set_timestamp(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  timestamp_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Tombstone.timestamp)
}
inline void Tombstone::set_timestamp(const char* value, size_t size) {
  
  timestamp_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Tombstone.timestamp)
}
inline std::string* Tombstone::mutable_timestamp() {
  
  // @@protoc_insertion_point(field_mutable:Tombstone.timestamp)
  return timestamp_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Tombstone::release_timestamp() {
  // @@protoc_insertion_point(field_release:Tombstone.timestamp)
  
  return timestamp_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Tombstone::set_allocated_timestamp(std::string* timestamp) {
  if (timestamp != nullptr) {
    
  } else {
    
  }
  timestamp_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), timestamp);
  // @@protoc_insertion_point(field_set_allocated:Tombstone.timestamp)
}

// uint32 pid = 5;
inline void Tombstone::clear_pid() {
  pid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Tombstone::pid() const {
  // @@protoc_insertion_point(field_get:Tombstone.pid)
  return pid_;
}
inline void Tombstone::set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  pid_ = value;
  // @@protoc_insertion_point(field_set:Tombstone.pid)
}

// uint32 tid = 6;
inline void Tombstone::clear_tid() {
  tid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Tombstone::tid() const {
  // @@protoc_insertion_point(field_get:Tombstone.tid)
  return tid_;
}
inline void Tombstone::set_tid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  tid_ = value;
  // @@protoc_insertion_point(field_set:Tombstone.tid)
}

// uint32 uid = 7;
inline void Tombstone::clear_uid() {
  uid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Tombstone::uid() const {
  // @@protoc_insertion_point(field_get:Tombstone.uid)
  return uid_;
}
inline void Tombstone::set_uid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  uid_ = value;
  // @@protoc_insertion_point(field_set:Tombstone.uid)
}

// string selinux_label = 8;
inline void Tombstone::clear_selinux_label() {
  selinux_label_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Tombstone::selinux_label() const {
  // @@protoc_insertion_point(field_get:Tombstone.selinux_label)
  return selinux_label_.GetNoArena();
}
inline void Tombstone::set_selinux_label(const std::string& value) {
  
  selinux_label_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Tombstone.selinux_label)
}
inline void Tombstone::set_selinux_label(std::string&& value) {
  
  selinux_label_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Tombstone.selinux_label)
}
inline void Tombstone::set_selinux_label(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  selinux_label_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Tombstone.selinux_label)
}
inline void Tombstone::set_selinux_label(const char* value, size_t size) {
  
  selinux_label_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Tombstone.selinux_label)
}
inline std::string* Tombstone::mutable_selinux_label() {
  
  // @@protoc_insertion_point(field_mutable:Tombstone.selinux_label)
  return selinux_label_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Tombstone::release_selinux_label() {
  // @@protoc_insertion_point(field_release:Tombstone.selinux_label)
  
  return selinux_label_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Tombstone::set_allocated_selinux_label(std::string* selinux_label) {
  if (selinux_label != nullptr) {
    
  } else {
    
  }
  selinux_label_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), selinux_label);
  // @@protoc_insertion_point(field_set_allocated:Tombstone.selinux_label)
}

// repeated string command_line = 9;
inline int Tombstone::command_line_size() const {
  return command_line_.size();
}
inline void Tombstone::clear_command_line() {
  command_line_.Clear();
}
inline const std::string& Tombstone::command_line(int index) const {
  // @@protoc_insertion_point(field_get:Tombstone.command_line)
  return command_line_.Get(index);
}
inline std::string* Tombstone::mutable_command_line(int index) {
  // @@protoc_insertion_point(field_mutable:Tombstone.command_line)
  return command_line_.Mutable(index);
}
inline void Tombstone::set_command_line(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:Tombstone.command_line)
  command_line_.Mutable(index)->assign(value);
}
inline void Tombstone::set_command_line(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:Tombstone.command_line)
  command_line_.Mutable(index)->assign(std::move(value));
}
inline void Tombstone::set_command_line(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  command_line_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Tombstone.command_line)
}
inline void Tombstone::set_command_line(int index, const char* value, size_t size) {
  command_line_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Tombstone.command_line)
}
inline std::string* Tombstone::add_command_line() {
  // @@protoc_insertion_point(field_add_mutable:Tombstone.command_line)
  return command_line_.Add();
}
inline void Tombstone::add_command_line(const std::string& value) {
  command_line_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Tombstone.command_line)
}
inline void Tombstone::add_command_line(std::string&& value) {
  command_line_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Tombstone.command_line)
}
inline void Tombstone::add_command_line(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  command_line_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Tombstone.command_line)
}
inline void Tombstone::add_command_line(const char* value, size_t size) {
  command_line_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Tombstone.command_line)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Tombstone::command_line() const {
  // @@protoc_insertion_point(field_list:Tombstone.command_line)
  return command_line_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Tombstone::mutable_command_line() {
  // @@protoc_insertion_point(field_mutable_list:Tombstone.command_line)
  return &command_line_;
}

// uint32 process_uptime = 20;
inline void Tombstone::clear_process_uptime() {
  process_uptime_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Tombstone::process_uptime() const {
  // @@protoc_insertion_point(field_get:Tombstone.process_uptime)
  return process_uptime_;
}
inline void Tombstone::set_process_uptime(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  process_uptime_ = value;
  // @@protoc_insertion_point(field_set:Tombstone.process_uptime)
}

// .Signal signal_info = 10;
inline bool Tombstone::has_signal_info() const {
  return this != internal_default_instance() && signal_info_ != nullptr;
}
inline void Tombstone::clear_signal_info() {
  if (GetArenaNoVirtual() == nullptr && signal_info_ != nullptr) {
    delete signal_info_;
  }
  signal_info_ = nullptr;
}
inline const ::Signal& Tombstone::signal_info() const {
  const ::Signal* p = signal_info_;
  // @@protoc_insertion_point(field_get:Tombstone.signal_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::Signal*>(
      &::_Signal_default_instance_);
}
inline ::Signal* Tombstone::release_signal_info() {
  // @@protoc_insertion_point(field_release:Tombstone.signal_info)
  
  ::Signal* temp = signal_info_;
  signal_info_ = nullptr;
  return temp;
}
inline ::Signal* Tombstone::mutable_signal_info() {
  
  if (signal_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Signal>(GetArenaNoVirtual());
    signal_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Tombstone.signal_info)
  return signal_info_;
}
inline void Tombstone::set_allocated_signal_info(::Signal* signal_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete signal_info_;
  }
  if (signal_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      signal_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signal_info, submessage_arena);
    }
    
  } else {
    
  }
  signal_info_ = signal_info;
  // @@protoc_insertion_point(field_set_allocated:Tombstone.signal_info)
}

// string abort_message = 14;
inline void Tombstone::clear_abort_message() {
  abort_message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Tombstone::abort_message() const {
  // @@protoc_insertion_point(field_get:Tombstone.abort_message)
  return abort_message_.GetNoArena();
}
inline void Tombstone::set_abort_message(const std::string& value) {
  
  abort_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Tombstone.abort_message)
}
inline void Tombstone::set_abort_message(std::string&& value) {
  
  abort_message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Tombstone.abort_message)
}
inline void Tombstone::set_abort_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  abort_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Tombstone.abort_message)
}
inline void Tombstone::set_abort_message(const char* value, size_t size) {
  
  abort_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Tombstone.abort_message)
}
inline std::string* Tombstone::mutable_abort_message() {
  
  // @@protoc_insertion_point(field_mutable:Tombstone.abort_message)
  return abort_message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Tombstone::release_abort_message() {
  // @@protoc_insertion_point(field_release:Tombstone.abort_message)
  
  return abort_message_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Tombstone::set_allocated_abort_message(std::string* abort_message) {
  if (abort_message != nullptr) {
    
  } else {
    
  }
  abort_message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), abort_message);
  // @@protoc_insertion_point(field_set_allocated:Tombstone.abort_message)
}

// repeated .Cause causes = 15;
inline int Tombstone::causes_size() const {
  return causes_.size();
}
inline void Tombstone::clear_causes() {
  causes_.Clear();
}
inline ::Cause* Tombstone::mutable_causes(int index) {
  // @@protoc_insertion_point(field_mutable:Tombstone.causes)
  return causes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Cause >*
Tombstone::mutable_causes() {
  // @@protoc_insertion_point(field_mutable_list:Tombstone.causes)
  return &causes_;
}
inline const ::Cause& Tombstone::causes(int index) const {
  // @@protoc_insertion_point(field_get:Tombstone.causes)
  return causes_.Get(index);
}
inline ::Cause* Tombstone::add_causes() {
  // @@protoc_insertion_point(field_add:Tombstone.causes)
  return causes_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Cause >&
Tombstone::causes() const {
  // @@protoc_insertion_point(field_list:Tombstone.causes)
  return causes_;
}

// map<uint32, .Thread> threads = 16;
inline int Tombstone::threads_size() const {
  return threads_.size();
}
inline void Tombstone::clear_threads() {
  threads_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::Thread >&
Tombstone::threads() const {
  // @@protoc_insertion_point(field_map:Tombstone.threads)
  return threads_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::Thread >*
Tombstone::mutable_threads() {
  // @@protoc_insertion_point(field_mutable_map:Tombstone.threads)
  return threads_.MutableMap();
}

// repeated .MemoryMapping memory_mappings = 17;
inline int Tombstone::memory_mappings_size() const {
  return memory_mappings_.size();
}
inline void Tombstone::clear_memory_mappings() {
  memory_mappings_.Clear();
}
inline ::MemoryMapping* Tombstone::mutable_memory_mappings(int index) {
  // @@protoc_insertion_point(field_mutable:Tombstone.memory_mappings)
  return memory_mappings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MemoryMapping >*
Tombstone::mutable_memory_mappings() {
  // @@protoc_insertion_point(field_mutable_list:Tombstone.memory_mappings)
  return &memory_mappings_;
}
inline const ::MemoryMapping& Tombstone::memory_mappings(int index) const {
  // @@protoc_insertion_point(field_get:Tombstone.memory_mappings)
  return memory_mappings_.Get(index);
}
inline ::MemoryMapping* Tombstone::add_memory_mappings() {
  // @@protoc_insertion_point(field_add:Tombstone.memory_mappings)
  return memory_mappings_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MemoryMapping >&
Tombstone::memory_mappings() const {
  // @@protoc_insertion_point(field_list:Tombstone.memory_mappings)
  return memory_mappings_;
}

// repeated .LogBuffer log_buffers = 18;
inline int Tombstone::log_buffers_size() const {
  return log_buffers_.size();
}
inline void Tombstone::clear_log_buffers() {
  log_buffers_.Clear();
}
inline ::LogBuffer* Tombstone::mutable_log_buffers(int index) {
  // @@protoc_insertion_point(field_mutable:Tombstone.log_buffers)
  return log_buffers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogBuffer >*
Tombstone::mutable_log_buffers() {
  // @@protoc_insertion_point(field_mutable_list:Tombstone.log_buffers)
  return &log_buffers_;
}
inline const ::LogBuffer& Tombstone::log_buffers(int index) const {
  // @@protoc_insertion_point(field_get:Tombstone.log_buffers)
  return log_buffers_.Get(index);
}
inline ::LogBuffer* Tombstone::add_log_buffers() {
  // @@protoc_insertion_point(field_add:Tombstone.log_buffers)
  return log_buffers_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogBuffer >&
Tombstone::log_buffers() const {
  // @@protoc_insertion_point(field_list:Tombstone.log_buffers)
  return log_buffers_;
}

// repeated .FD open_fds = 19;
inline int Tombstone::open_fds_size() const {
  return open_fds_.size();
}
inline void Tombstone::clear_open_fds() {
  open_fds_.Clear();
}
inline ::FD* Tombstone::mutable_open_fds(int index) {
  // @@protoc_insertion_point(field_mutable:Tombstone.open_fds)
  return open_fds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FD >*
Tombstone::mutable_open_fds() {
  // @@protoc_insertion_point(field_mutable_list:Tombstone.open_fds)
  return &open_fds_;
}
inline const ::FD& Tombstone::open_fds(int index) const {
  // @@protoc_insertion_point(field_get:Tombstone.open_fds)
  return open_fds_.Get(index);
}
inline ::FD* Tombstone::add_open_fds() {
  // @@protoc_insertion_point(field_add:Tombstone.open_fds)
  return open_fds_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FD >&
Tombstone::open_fds() const {
  // @@protoc_insertion_point(field_list:Tombstone.open_fds)
  return open_fds_;
}

// -------------------------------------------------------------------

// Signal

// int32 number = 1;
inline void Signal::clear_number() {
  number_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Signal::number() const {
  // @@protoc_insertion_point(field_get:Signal.number)
  return number_;
}
inline void Signal::set_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  number_ = value;
  // @@protoc_insertion_point(field_set:Signal.number)
}

// string name = 2;
inline void Signal::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Signal::name() const {
  // @@protoc_insertion_point(field_get:Signal.name)
  return name_.GetNoArena();
}
inline void Signal::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Signal.name)
}
inline void Signal::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Signal.name)
}
inline void Signal::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Signal.name)
}
inline void Signal::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Signal.name)
}
inline std::string* Signal::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Signal.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Signal::release_name() {
  // @@protoc_insertion_point(field_release:Signal.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Signal::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Signal.name)
}

// int32 code = 3;
inline void Signal::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Signal::code() const {
  // @@protoc_insertion_point(field_get:Signal.code)
  return code_;
}
inline void Signal::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:Signal.code)
}

// string code_name = 4;
inline void Signal::clear_code_name() {
  code_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Signal::code_name() const {
  // @@protoc_insertion_point(field_get:Signal.code_name)
  return code_name_.GetNoArena();
}
inline void Signal::set_code_name(const std::string& value) {
  
  code_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Signal.code_name)
}
inline void Signal::set_code_name(std::string&& value) {
  
  code_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Signal.code_name)
}
inline void Signal::set_code_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  code_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Signal.code_name)
}
inline void Signal::set_code_name(const char* value, size_t size) {
  
  code_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Signal.code_name)
}
inline std::string* Signal::mutable_code_name() {
  
  // @@protoc_insertion_point(field_mutable:Signal.code_name)
  return code_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Signal::release_code_name() {
  // @@protoc_insertion_point(field_release:Signal.code_name)
  
  return code_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Signal::set_allocated_code_name(std::string* code_name) {
  if (code_name != nullptr) {
    
  } else {
    
  }
  code_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code_name);
  // @@protoc_insertion_point(field_set_allocated:Signal.code_name)
}

// bool has_sender = 5;
inline void Signal::clear_has_sender() {
  has_sender_ = false;
}
inline bool Signal::has_sender() const {
  // @@protoc_insertion_point(field_get:Signal.has_sender)
  return has_sender_;
}
inline void Signal::set_has_sender(bool value) {
  
  has_sender_ = value;
  // @@protoc_insertion_point(field_set:Signal.has_sender)
}

// int32 sender_uid = 6;
inline void Signal::clear_sender_uid() {
  sender_uid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Signal::sender_uid() const {
  // @@protoc_insertion_point(field_get:Signal.sender_uid)
  return sender_uid_;
}
inline void Signal::set_sender_uid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  sender_uid_ = value;
  // @@protoc_insertion_point(field_set:Signal.sender_uid)
}

// int32 sender_pid = 7;
inline void Signal::clear_sender_pid() {
  sender_pid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Signal::sender_pid() const {
  // @@protoc_insertion_point(field_get:Signal.sender_pid)
  return sender_pid_;
}
inline void Signal::set_sender_pid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  sender_pid_ = value;
  // @@protoc_insertion_point(field_set:Signal.sender_pid)
}

// bool has_fault_address = 8;
inline void Signal::clear_has_fault_address() {
  has_fault_address_ = false;
}
inline bool Signal::has_fault_address() const {
  // @@protoc_insertion_point(field_get:Signal.has_fault_address)
  return has_fault_address_;
}
inline void Signal::set_has_fault_address(bool value) {
  
  has_fault_address_ = value;
  // @@protoc_insertion_point(field_set:Signal.has_fault_address)
}

// uint64 fault_address = 9;
inline void Signal::clear_fault_address() {
  fault_address_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Signal::fault_address() const {
  // @@protoc_insertion_point(field_get:Signal.fault_address)
  return fault_address_;
}
inline void Signal::set_fault_address(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  fault_address_ = value;
  // @@protoc_insertion_point(field_set:Signal.fault_address)
}

// .MemoryDump fault_adjacent_metadata = 10;
inline bool Signal::has_fault_adjacent_metadata() const {
  return this != internal_default_instance() && fault_adjacent_metadata_ != nullptr;
}
inline void Signal::clear_fault_adjacent_metadata() {
  if (GetArenaNoVirtual() == nullptr && fault_adjacent_metadata_ != nullptr) {
    delete fault_adjacent_metadata_;
  }
  fault_adjacent_metadata_ = nullptr;
}
inline const ::MemoryDump& Signal::fault_adjacent_metadata() const {
  const ::MemoryDump* p = fault_adjacent_metadata_;
  // @@protoc_insertion_point(field_get:Signal.fault_adjacent_metadata)
  return p != nullptr ? *p : *reinterpret_cast<const ::MemoryDump*>(
      &::_MemoryDump_default_instance_);
}
inline ::MemoryDump* Signal::release_fault_adjacent_metadata() {
  // @@protoc_insertion_point(field_release:Signal.fault_adjacent_metadata)
  
  ::MemoryDump* temp = fault_adjacent_metadata_;
  fault_adjacent_metadata_ = nullptr;
  return temp;
}
inline ::MemoryDump* Signal::mutable_fault_adjacent_metadata() {
  
  if (fault_adjacent_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::MemoryDump>(GetArenaNoVirtual());
    fault_adjacent_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Signal.fault_adjacent_metadata)
  return fault_adjacent_metadata_;
}
inline void Signal::set_allocated_fault_adjacent_metadata(::MemoryDump* fault_adjacent_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete fault_adjacent_metadata_;
  }
  if (fault_adjacent_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fault_adjacent_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fault_adjacent_metadata, submessage_arena);
    }
    
  } else {
    
  }
  fault_adjacent_metadata_ = fault_adjacent_metadata;
  // @@protoc_insertion_point(field_set_allocated:Signal.fault_adjacent_metadata)
}

// -------------------------------------------------------------------

// HeapObject

// uint64 address = 1;
inline void HeapObject::clear_address() {
  address_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HeapObject::address() const {
  // @@protoc_insertion_point(field_get:HeapObject.address)
  return address_;
}
inline void HeapObject::set_address(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  address_ = value;
  // @@protoc_insertion_point(field_set:HeapObject.address)
}

// uint64 size = 2;
inline void HeapObject::clear_size() {
  size_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HeapObject::size() const {
  // @@protoc_insertion_point(field_get:HeapObject.size)
  return size_;
}
inline void HeapObject::set_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:HeapObject.size)
}

// uint64 allocation_tid = 3;
inline void HeapObject::clear_allocation_tid() {
  allocation_tid_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HeapObject::allocation_tid() const {
  // @@protoc_insertion_point(field_get:HeapObject.allocation_tid)
  return allocation_tid_;
}
inline void HeapObject::set_allocation_tid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  allocation_tid_ = value;
  // @@protoc_insertion_point(field_set:HeapObject.allocation_tid)
}

// repeated .BacktraceFrame allocation_backtrace = 4;
inline int HeapObject::allocation_backtrace_size() const {
  return allocation_backtrace_.size();
}
inline void HeapObject::clear_allocation_backtrace() {
  allocation_backtrace_.Clear();
}
inline ::BacktraceFrame* HeapObject::mutable_allocation_backtrace(int index) {
  // @@protoc_insertion_point(field_mutable:HeapObject.allocation_backtrace)
  return allocation_backtrace_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BacktraceFrame >*
HeapObject::mutable_allocation_backtrace() {
  // @@protoc_insertion_point(field_mutable_list:HeapObject.allocation_backtrace)
  return &allocation_backtrace_;
}
inline const ::BacktraceFrame& HeapObject::allocation_backtrace(int index) const {
  // @@protoc_insertion_point(field_get:HeapObject.allocation_backtrace)
  return allocation_backtrace_.Get(index);
}
inline ::BacktraceFrame* HeapObject::add_allocation_backtrace() {
  // @@protoc_insertion_point(field_add:HeapObject.allocation_backtrace)
  return allocation_backtrace_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BacktraceFrame >&
HeapObject::allocation_backtrace() const {
  // @@protoc_insertion_point(field_list:HeapObject.allocation_backtrace)
  return allocation_backtrace_;
}

// uint64 deallocation_tid = 5;
inline void HeapObject::clear_deallocation_tid() {
  deallocation_tid_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HeapObject::deallocation_tid() const {
  // @@protoc_insertion_point(field_get:HeapObject.deallocation_tid)
  return deallocation_tid_;
}
inline void HeapObject::set_deallocation_tid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  deallocation_tid_ = value;
  // @@protoc_insertion_point(field_set:HeapObject.deallocation_tid)
}

// repeated .BacktraceFrame deallocation_backtrace = 6;
inline int HeapObject::deallocation_backtrace_size() const {
  return deallocation_backtrace_.size();
}
inline void HeapObject::clear_deallocation_backtrace() {
  deallocation_backtrace_.Clear();
}
inline ::BacktraceFrame* HeapObject::mutable_deallocation_backtrace(int index) {
  // @@protoc_insertion_point(field_mutable:HeapObject.deallocation_backtrace)
  return deallocation_backtrace_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BacktraceFrame >*
HeapObject::mutable_deallocation_backtrace() {
  // @@protoc_insertion_point(field_mutable_list:HeapObject.deallocation_backtrace)
  return &deallocation_backtrace_;
}
inline const ::BacktraceFrame& HeapObject::deallocation_backtrace(int index) const {
  // @@protoc_insertion_point(field_get:HeapObject.deallocation_backtrace)
  return deallocation_backtrace_.Get(index);
}
inline ::BacktraceFrame* HeapObject::add_deallocation_backtrace() {
  // @@protoc_insertion_point(field_add:HeapObject.deallocation_backtrace)
  return deallocation_backtrace_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BacktraceFrame >&
HeapObject::deallocation_backtrace() const {
  // @@protoc_insertion_point(field_list:HeapObject.deallocation_backtrace)
  return deallocation_backtrace_;
}

// -------------------------------------------------------------------

// MemoryError

// .MemoryError.Tool tool = 1;
inline void MemoryError::clear_tool() {
  tool_ = 0;
}
inline ::MemoryError_Tool MemoryError::tool() const {
  // @@protoc_insertion_point(field_get:MemoryError.tool)
  return static_cast< ::MemoryError_Tool >(tool_);
}
inline void MemoryError::set_tool(::MemoryError_Tool value) {
  
  tool_ = value;
  // @@protoc_insertion_point(field_set:MemoryError.tool)
}

// .MemoryError.Type type = 2;
inline void MemoryError::clear_type() {
  type_ = 0;
}
inline ::MemoryError_Type MemoryError::type() const {
  // @@protoc_insertion_point(field_get:MemoryError.type)
  return static_cast< ::MemoryError_Type >(type_);
}
inline void MemoryError::set_type(::MemoryError_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:MemoryError.type)
}

// .HeapObject heap = 3;
inline bool MemoryError::has_heap() const {
  return location_case() == kHeap;
}
inline void MemoryError::set_has_heap() {
  _oneof_case_[0] = kHeap;
}
inline void MemoryError::clear_heap() {
  if (has_heap()) {
    delete location_.heap_;
    clear_has_location();
  }
}
inline ::HeapObject* MemoryError::release_heap() {
  // @@protoc_insertion_point(field_release:MemoryError.heap)
  if (has_heap()) {
    clear_has_location();
      ::HeapObject* temp = location_.heap_;
    location_.heap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::HeapObject& MemoryError::heap() const {
  // @@protoc_insertion_point(field_get:MemoryError.heap)
  return has_heap()
      ? *location_.heap_
      : *reinterpret_cast< ::HeapObject*>(&::_HeapObject_default_instance_);
}
inline ::HeapObject* MemoryError::mutable_heap() {
  if (!has_heap()) {
    clear_location();
    set_has_heap();
    location_.heap_ = CreateMaybeMessage< ::HeapObject >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:MemoryError.heap)
  return location_.heap_;
}

inline bool MemoryError::has_location() const {
  return location_case() != LOCATION_NOT_SET;
}
inline void MemoryError::clear_has_location() {
  _oneof_case_[0] = LOCATION_NOT_SET;
}
inline MemoryError::LocationCase MemoryError::location_case() const {
  return MemoryError::LocationCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Cause

// string human_readable = 1;
inline void Cause::clear_human_readable() {
  human_readable_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Cause::human_readable() const {
  // @@protoc_insertion_point(field_get:Cause.human_readable)
  return human_readable_.GetNoArena();
}
inline void Cause::set_human_readable(const std::string& value) {
  
  human_readable_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Cause.human_readable)
}
inline void Cause::set_human_readable(std::string&& value) {
  
  human_readable_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Cause.human_readable)
}
inline void Cause::set_human_readable(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  human_readable_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Cause.human_readable)
}
inline void Cause::set_human_readable(const char* value, size_t size) {
  
  human_readable_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Cause.human_readable)
}
inline std::string* Cause::mutable_human_readable() {
  
  // @@protoc_insertion_point(field_mutable:Cause.human_readable)
  return human_readable_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Cause::release_human_readable() {
  // @@protoc_insertion_point(field_release:Cause.human_readable)
  
  return human_readable_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Cause::set_allocated_human_readable(std::string* human_readable) {
  if (human_readable != nullptr) {
    
  } else {
    
  }
  human_readable_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), human_readable);
  // @@protoc_insertion_point(field_set_allocated:Cause.human_readable)
}

// .MemoryError memory_error = 2;
inline bool Cause::has_memory_error() const {
  return details_case() == kMemoryError;
}
inline void Cause::set_has_memory_error() {
  _oneof_case_[0] = kMemoryError;
}
inline void Cause::clear_memory_error() {
  if (has_memory_error()) {
    delete details_.memory_error_;
    clear_has_details();
  }
}
inline ::MemoryError* Cause::release_memory_error() {
  // @@protoc_insertion_point(field_release:Cause.memory_error)
  if (has_memory_error()) {
    clear_has_details();
      ::MemoryError* temp = details_.memory_error_;
    details_.memory_error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::MemoryError& Cause::memory_error() const {
  // @@protoc_insertion_point(field_get:Cause.memory_error)
  return has_memory_error()
      ? *details_.memory_error_
      : *reinterpret_cast< ::MemoryError*>(&::_MemoryError_default_instance_);
}
inline ::MemoryError* Cause::mutable_memory_error() {
  if (!has_memory_error()) {
    clear_details();
    set_has_memory_error();
    details_.memory_error_ = CreateMaybeMessage< ::MemoryError >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Cause.memory_error)
  return details_.memory_error_;
}

inline bool Cause::has_details() const {
  return details_case() != DETAILS_NOT_SET;
}
inline void Cause::clear_has_details() {
  _oneof_case_[0] = DETAILS_NOT_SET;
}
inline Cause::DetailsCase Cause::details_case() const {
  return Cause::DetailsCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Register

// string name = 1;
inline void Register::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Register::name() const {
  // @@protoc_insertion_point(field_get:Register.name)
  return name_.GetNoArena();
}
inline void Register::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Register.name)
}
inline void Register::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Register.name)
}
inline void Register::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Register.name)
}
inline void Register::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Register.name)
}
inline std::string* Register::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Register.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Register::release_name() {
  // @@protoc_insertion_point(field_release:Register.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Register::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Register.name)
}

// uint64 u64 = 2;
inline void Register::clear_u64() {
  u64_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Register::u64() const {
  // @@protoc_insertion_point(field_get:Register.u64)
  return u64_;
}
inline void Register::set_u64(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  u64_ = value;
  // @@protoc_insertion_point(field_set:Register.u64)
}

// -------------------------------------------------------------------

// Thread

// int32 id = 1;
inline void Thread::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Thread::id() const {
  // @@protoc_insertion_point(field_get:Thread.id)
  return id_;
}
inline void Thread::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:Thread.id)
}

// string name = 2;
inline void Thread::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Thread::name() const {
  // @@protoc_insertion_point(field_get:Thread.name)
  return name_.GetNoArena();
}
inline void Thread::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Thread.name)
}
inline void Thread::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Thread.name)
}
inline void Thread::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Thread.name)
}
inline void Thread::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Thread.name)
}
inline std::string* Thread::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Thread.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Thread::release_name() {
  // @@protoc_insertion_point(field_release:Thread.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Thread::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Thread.name)
}

// repeated .Register registers = 3;
inline int Thread::registers_size() const {
  return registers_.size();
}
inline void Thread::clear_registers() {
  registers_.Clear();
}
inline ::Register* Thread::mutable_registers(int index) {
  // @@protoc_insertion_point(field_mutable:Thread.registers)
  return registers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Register >*
Thread::mutable_registers() {
  // @@protoc_insertion_point(field_mutable_list:Thread.registers)
  return &registers_;
}
inline const ::Register& Thread::registers(int index) const {
  // @@protoc_insertion_point(field_get:Thread.registers)
  return registers_.Get(index);
}
inline ::Register* Thread::add_registers() {
  // @@protoc_insertion_point(field_add:Thread.registers)
  return registers_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Register >&
Thread::registers() const {
  // @@protoc_insertion_point(field_list:Thread.registers)
  return registers_;
}

// repeated string backtrace_note = 7;
inline int Thread::backtrace_note_size() const {
  return backtrace_note_.size();
}
inline void Thread::clear_backtrace_note() {
  backtrace_note_.Clear();
}
inline const std::string& Thread::backtrace_note(int index) const {
  // @@protoc_insertion_point(field_get:Thread.backtrace_note)
  return backtrace_note_.Get(index);
}
inline std::string* Thread::mutable_backtrace_note(int index) {
  // @@protoc_insertion_point(field_mutable:Thread.backtrace_note)
  return backtrace_note_.Mutable(index);
}
inline void Thread::set_backtrace_note(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:Thread.backtrace_note)
  backtrace_note_.Mutable(index)->assign(value);
}
inline void Thread::set_backtrace_note(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:Thread.backtrace_note)
  backtrace_note_.Mutable(index)->assign(std::move(value));
}
inline void Thread::set_backtrace_note(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  backtrace_note_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Thread.backtrace_note)
}
inline void Thread::set_backtrace_note(int index, const char* value, size_t size) {
  backtrace_note_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Thread.backtrace_note)
}
inline std::string* Thread::add_backtrace_note() {
  // @@protoc_insertion_point(field_add_mutable:Thread.backtrace_note)
  return backtrace_note_.Add();
}
inline void Thread::add_backtrace_note(const std::string& value) {
  backtrace_note_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Thread.backtrace_note)
}
inline void Thread::add_backtrace_note(std::string&& value) {
  backtrace_note_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Thread.backtrace_note)
}
inline void Thread::add_backtrace_note(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  backtrace_note_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Thread.backtrace_note)
}
inline void Thread::add_backtrace_note(const char* value, size_t size) {
  backtrace_note_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Thread.backtrace_note)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Thread::backtrace_note() const {
  // @@protoc_insertion_point(field_list:Thread.backtrace_note)
  return backtrace_note_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Thread::mutable_backtrace_note() {
  // @@protoc_insertion_point(field_mutable_list:Thread.backtrace_note)
  return &backtrace_note_;
}

// repeated .BacktraceFrame current_backtrace = 4;
inline int Thread::current_backtrace_size() const {
  return current_backtrace_.size();
}
inline void Thread::clear_current_backtrace() {
  current_backtrace_.Clear();
}
inline ::BacktraceFrame* Thread::mutable_current_backtrace(int index) {
  // @@protoc_insertion_point(field_mutable:Thread.current_backtrace)
  return current_backtrace_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BacktraceFrame >*
Thread::mutable_current_backtrace() {
  // @@protoc_insertion_point(field_mutable_list:Thread.current_backtrace)
  return &current_backtrace_;
}
inline const ::BacktraceFrame& Thread::current_backtrace(int index) const {
  // @@protoc_insertion_point(field_get:Thread.current_backtrace)
  return current_backtrace_.Get(index);
}
inline ::BacktraceFrame* Thread::add_current_backtrace() {
  // @@protoc_insertion_point(field_add:Thread.current_backtrace)
  return current_backtrace_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BacktraceFrame >&
Thread::current_backtrace() const {
  // @@protoc_insertion_point(field_list:Thread.current_backtrace)
  return current_backtrace_;
}

// repeated .MemoryDump memory_dump = 5;
inline int Thread::memory_dump_size() const {
  return memory_dump_.size();
}
inline void Thread::clear_memory_dump() {
  memory_dump_.Clear();
}
inline ::MemoryDump* Thread::mutable_memory_dump(int index) {
  // @@protoc_insertion_point(field_mutable:Thread.memory_dump)
  return memory_dump_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MemoryDump >*
Thread::mutable_memory_dump() {
  // @@protoc_insertion_point(field_mutable_list:Thread.memory_dump)
  return &memory_dump_;
}
inline const ::MemoryDump& Thread::memory_dump(int index) const {
  // @@protoc_insertion_point(field_get:Thread.memory_dump)
  return memory_dump_.Get(index);
}
inline ::MemoryDump* Thread::add_memory_dump() {
  // @@protoc_insertion_point(field_add:Thread.memory_dump)
  return memory_dump_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MemoryDump >&
Thread::memory_dump() const {
  // @@protoc_insertion_point(field_list:Thread.memory_dump)
  return memory_dump_;
}

// int64 tagged_addr_ctrl = 6;
inline void Thread::clear_tagged_addr_ctrl() {
  tagged_addr_ctrl_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Thread::tagged_addr_ctrl() const {
  // @@protoc_insertion_point(field_get:Thread.tagged_addr_ctrl)
  return tagged_addr_ctrl_;
}
inline void Thread::set_tagged_addr_ctrl(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  tagged_addr_ctrl_ = value;
  // @@protoc_insertion_point(field_set:Thread.tagged_addr_ctrl)
}

// -------------------------------------------------------------------

// BacktraceFrame

// uint64 rel_pc = 1;
inline void BacktraceFrame::clear_rel_pc() {
  rel_pc_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BacktraceFrame::rel_pc() const {
  // @@protoc_insertion_point(field_get:BacktraceFrame.rel_pc)
  return rel_pc_;
}
inline void BacktraceFrame::set_rel_pc(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  rel_pc_ = value;
  // @@protoc_insertion_point(field_set:BacktraceFrame.rel_pc)
}

// uint64 pc = 2;
inline void BacktraceFrame::clear_pc() {
  pc_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BacktraceFrame::pc() const {
  // @@protoc_insertion_point(field_get:BacktraceFrame.pc)
  return pc_;
}
inline void BacktraceFrame::set_pc(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  pc_ = value;
  // @@protoc_insertion_point(field_set:BacktraceFrame.pc)
}

// uint64 sp = 3;
inline void BacktraceFrame::clear_sp() {
  sp_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BacktraceFrame::sp() const {
  // @@protoc_insertion_point(field_get:BacktraceFrame.sp)
  return sp_;
}
inline void BacktraceFrame::set_sp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  sp_ = value;
  // @@protoc_insertion_point(field_set:BacktraceFrame.sp)
}

// string function_name = 4;
inline void BacktraceFrame::clear_function_name() {
  function_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& BacktraceFrame::function_name() const {
  // @@protoc_insertion_point(field_get:BacktraceFrame.function_name)
  return function_name_.GetNoArena();
}
inline void BacktraceFrame::set_function_name(const std::string& value) {
  
  function_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BacktraceFrame.function_name)
}
inline void BacktraceFrame::set_function_name(std::string&& value) {
  
  function_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:BacktraceFrame.function_name)
}
inline void BacktraceFrame::set_function_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  function_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BacktraceFrame.function_name)
}
inline void BacktraceFrame::set_function_name(const char* value, size_t size) {
  
  function_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BacktraceFrame.function_name)
}
inline std::string* BacktraceFrame::mutable_function_name() {
  
  // @@protoc_insertion_point(field_mutable:BacktraceFrame.function_name)
  return function_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BacktraceFrame::release_function_name() {
  // @@protoc_insertion_point(field_release:BacktraceFrame.function_name)
  
  return function_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BacktraceFrame::set_allocated_function_name(std::string* function_name) {
  if (function_name != nullptr) {
    
  } else {
    
  }
  function_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), function_name);
  // @@protoc_insertion_point(field_set_allocated:BacktraceFrame.function_name)
}

// uint64 function_offset = 5;
inline void BacktraceFrame::clear_function_offset() {
  function_offset_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BacktraceFrame::function_offset() const {
  // @@protoc_insertion_point(field_get:BacktraceFrame.function_offset)
  return function_offset_;
}
inline void BacktraceFrame::set_function_offset(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  function_offset_ = value;
  // @@protoc_insertion_point(field_set:BacktraceFrame.function_offset)
}

// string file_name = 6;
inline void BacktraceFrame::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& BacktraceFrame::file_name() const {
  // @@protoc_insertion_point(field_get:BacktraceFrame.file_name)
  return file_name_.GetNoArena();
}
inline void BacktraceFrame::set_file_name(const std::string& value) {
  
  file_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BacktraceFrame.file_name)
}
inline void BacktraceFrame::set_file_name(std::string&& value) {
  
  file_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:BacktraceFrame.file_name)
}
inline void BacktraceFrame::set_file_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  file_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BacktraceFrame.file_name)
}
inline void BacktraceFrame::set_file_name(const char* value, size_t size) {
  
  file_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BacktraceFrame.file_name)
}
inline std::string* BacktraceFrame::mutable_file_name() {
  
  // @@protoc_insertion_point(field_mutable:BacktraceFrame.file_name)
  return file_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BacktraceFrame::release_file_name() {
  // @@protoc_insertion_point(field_release:BacktraceFrame.file_name)
  
  return file_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BacktraceFrame::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:BacktraceFrame.file_name)
}

// uint64 file_map_offset = 7;
inline void BacktraceFrame::clear_file_map_offset() {
  file_map_offset_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BacktraceFrame::file_map_offset() const {
  // @@protoc_insertion_point(field_get:BacktraceFrame.file_map_offset)
  return file_map_offset_;
}
inline void BacktraceFrame::set_file_map_offset(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  file_map_offset_ = value;
  // @@protoc_insertion_point(field_set:BacktraceFrame.file_map_offset)
}

// string build_id = 8;
inline void BacktraceFrame::clear_build_id() {
  build_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& BacktraceFrame::build_id() const {
  // @@protoc_insertion_point(field_get:BacktraceFrame.build_id)
  return build_id_.GetNoArena();
}
inline void BacktraceFrame::set_build_id(const std::string& value) {
  
  build_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BacktraceFrame.build_id)
}
inline void BacktraceFrame::set_build_id(std::string&& value) {
  
  build_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:BacktraceFrame.build_id)
}
inline void BacktraceFrame::set_build_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  build_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BacktraceFrame.build_id)
}
inline void BacktraceFrame::set_build_id(const char* value, size_t size) {
  
  build_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BacktraceFrame.build_id)
}
inline std::string* BacktraceFrame::mutable_build_id() {
  
  // @@protoc_insertion_point(field_mutable:BacktraceFrame.build_id)
  return build_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BacktraceFrame::release_build_id() {
  // @@protoc_insertion_point(field_release:BacktraceFrame.build_id)
  
  return build_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BacktraceFrame::set_allocated_build_id(std::string* build_id) {
  if (build_id != nullptr) {
    
  } else {
    
  }
  build_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), build_id);
  // @@protoc_insertion_point(field_set_allocated:BacktraceFrame.build_id)
}

// -------------------------------------------------------------------

// ArmMTEMetadata

// bytes memory_tags = 1;
inline void ArmMTEMetadata::clear_memory_tags() {
  memory_tags_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ArmMTEMetadata::memory_tags() const {
  // @@protoc_insertion_point(field_get:ArmMTEMetadata.memory_tags)
  return memory_tags_.GetNoArena();
}
inline void ArmMTEMetadata::set_memory_tags(const std::string& value) {
  
  memory_tags_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ArmMTEMetadata.memory_tags)
}
inline void ArmMTEMetadata::set_memory_tags(std::string&& value) {
  
  memory_tags_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ArmMTEMetadata.memory_tags)
}
inline void ArmMTEMetadata::set_memory_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  memory_tags_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ArmMTEMetadata.memory_tags)
}
inline void ArmMTEMetadata::set_memory_tags(const void* value, size_t size) {
  
  memory_tags_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ArmMTEMetadata.memory_tags)
}
inline std::string* ArmMTEMetadata::mutable_memory_tags() {
  
  // @@protoc_insertion_point(field_mutable:ArmMTEMetadata.memory_tags)
  return memory_tags_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ArmMTEMetadata::release_memory_tags() {
  // @@protoc_insertion_point(field_release:ArmMTEMetadata.memory_tags)
  
  return memory_tags_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ArmMTEMetadata::set_allocated_memory_tags(std::string* memory_tags) {
  if (memory_tags != nullptr) {
    
  } else {
    
  }
  memory_tags_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), memory_tags);
  // @@protoc_insertion_point(field_set_allocated:ArmMTEMetadata.memory_tags)
}

// -------------------------------------------------------------------

// MemoryDump

// string register_name = 1;
inline void MemoryDump::clear_register_name() {
  register_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& MemoryDump::register_name() const {
  // @@protoc_insertion_point(field_get:MemoryDump.register_name)
  return register_name_.GetNoArena();
}
inline void MemoryDump::set_register_name(const std::string& value) {
  
  register_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MemoryDump.register_name)
}
inline void MemoryDump::set_register_name(std::string&& value) {
  
  register_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MemoryDump.register_name)
}
inline void MemoryDump::set_register_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  register_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MemoryDump.register_name)
}
inline void MemoryDump::set_register_name(const char* value, size_t size) {
  
  register_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MemoryDump.register_name)
}
inline std::string* MemoryDump::mutable_register_name() {
  
  // @@protoc_insertion_point(field_mutable:MemoryDump.register_name)
  return register_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MemoryDump::release_register_name() {
  // @@protoc_insertion_point(field_release:MemoryDump.register_name)
  
  return register_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MemoryDump::set_allocated_register_name(std::string* register_name) {
  if (register_name != nullptr) {
    
  } else {
    
  }
  register_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), register_name);
  // @@protoc_insertion_point(field_set_allocated:MemoryDump.register_name)
}

// string mapping_name = 2;
inline void MemoryDump::clear_mapping_name() {
  mapping_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& MemoryDump::mapping_name() const {
  // @@protoc_insertion_point(field_get:MemoryDump.mapping_name)
  return mapping_name_.GetNoArena();
}
inline void MemoryDump::set_mapping_name(const std::string& value) {
  
  mapping_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MemoryDump.mapping_name)
}
inline void MemoryDump::set_mapping_name(std::string&& value) {
  
  mapping_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MemoryDump.mapping_name)
}
inline void MemoryDump::set_mapping_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  mapping_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MemoryDump.mapping_name)
}
inline void MemoryDump::set_mapping_name(const char* value, size_t size) {
  
  mapping_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MemoryDump.mapping_name)
}
inline std::string* MemoryDump::mutable_mapping_name() {
  
  // @@protoc_insertion_point(field_mutable:MemoryDump.mapping_name)
  return mapping_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MemoryDump::release_mapping_name() {
  // @@protoc_insertion_point(field_release:MemoryDump.mapping_name)
  
  return mapping_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MemoryDump::set_allocated_mapping_name(std::string* mapping_name) {
  if (mapping_name != nullptr) {
    
  } else {
    
  }
  mapping_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mapping_name);
  // @@protoc_insertion_point(field_set_allocated:MemoryDump.mapping_name)
}

// uint64 begin_address = 3;
inline void MemoryDump::clear_begin_address() {
  begin_address_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MemoryDump::begin_address() const {
  // @@protoc_insertion_point(field_get:MemoryDump.begin_address)
  return begin_address_;
}
inline void MemoryDump::set_begin_address(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  begin_address_ = value;
  // @@protoc_insertion_point(field_set:MemoryDump.begin_address)
}

// bytes memory = 4;
inline void MemoryDump::clear_memory() {
  memory_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& MemoryDump::memory() const {
  // @@protoc_insertion_point(field_get:MemoryDump.memory)
  return memory_.GetNoArena();
}
inline void MemoryDump::set_memory(const std::string& value) {
  
  memory_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MemoryDump.memory)
}
inline void MemoryDump::set_memory(std::string&& value) {
  
  memory_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MemoryDump.memory)
}
inline void MemoryDump::set_memory(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  memory_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MemoryDump.memory)
}
inline void MemoryDump::set_memory(const void* value, size_t size) {
  
  memory_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MemoryDump.memory)
}
inline std::string* MemoryDump::mutable_memory() {
  
  // @@protoc_insertion_point(field_mutable:MemoryDump.memory)
  return memory_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MemoryDump::release_memory() {
  // @@protoc_insertion_point(field_release:MemoryDump.memory)
  
  return memory_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MemoryDump::set_allocated_memory(std::string* memory) {
  if (memory != nullptr) {
    
  } else {
    
  }
  memory_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), memory);
  // @@protoc_insertion_point(field_set_allocated:MemoryDump.memory)
}

// .ArmMTEMetadata arm_mte_metadata = 6;
inline bool MemoryDump::has_arm_mte_metadata() const {
  return metadata_case() == kArmMteMetadata;
}
inline void MemoryDump::set_has_arm_mte_metadata() {
  _oneof_case_[0] = kArmMteMetadata;
}
inline void MemoryDump::clear_arm_mte_metadata() {
  if (has_arm_mte_metadata()) {
    delete metadata_.arm_mte_metadata_;
    clear_has_metadata();
  }
}
inline ::ArmMTEMetadata* MemoryDump::release_arm_mte_metadata() {
  // @@protoc_insertion_point(field_release:MemoryDump.arm_mte_metadata)
  if (has_arm_mte_metadata()) {
    clear_has_metadata();
      ::ArmMTEMetadata* temp = metadata_.arm_mte_metadata_;
    metadata_.arm_mte_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ArmMTEMetadata& MemoryDump::arm_mte_metadata() const {
  // @@protoc_insertion_point(field_get:MemoryDump.arm_mte_metadata)
  return has_arm_mte_metadata()
      ? *metadata_.arm_mte_metadata_
      : *reinterpret_cast< ::ArmMTEMetadata*>(&::_ArmMTEMetadata_default_instance_);
}
inline ::ArmMTEMetadata* MemoryDump::mutable_arm_mte_metadata() {
  if (!has_arm_mte_metadata()) {
    clear_metadata();
    set_has_arm_mte_metadata();
    metadata_.arm_mte_metadata_ = CreateMaybeMessage< ::ArmMTEMetadata >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:MemoryDump.arm_mte_metadata)
  return metadata_.arm_mte_metadata_;
}

inline bool MemoryDump::has_metadata() const {
  return metadata_case() != METADATA_NOT_SET;
}
inline void MemoryDump::clear_has_metadata() {
  _oneof_case_[0] = METADATA_NOT_SET;
}
inline MemoryDump::MetadataCase MemoryDump::metadata_case() const {
  return MemoryDump::MetadataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MemoryMapping

// uint64 begin_address = 1;
inline void MemoryMapping::clear_begin_address() {
  begin_address_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MemoryMapping::begin_address() const {
  // @@protoc_insertion_point(field_get:MemoryMapping.begin_address)
  return begin_address_;
}
inline void MemoryMapping::set_begin_address(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  begin_address_ = value;
  // @@protoc_insertion_point(field_set:MemoryMapping.begin_address)
}

// uint64 end_address = 2;
inline void MemoryMapping::clear_end_address() {
  end_address_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MemoryMapping::end_address() const {
  // @@protoc_insertion_point(field_get:MemoryMapping.end_address)
  return end_address_;
}
inline void MemoryMapping::set_end_address(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  end_address_ = value;
  // @@protoc_insertion_point(field_set:MemoryMapping.end_address)
}

// uint64 offset = 3;
inline void MemoryMapping::clear_offset() {
  offset_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MemoryMapping::offset() const {
  // @@protoc_insertion_point(field_get:MemoryMapping.offset)
  return offset_;
}
inline void MemoryMapping::set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:MemoryMapping.offset)
}

// bool read = 4;
inline void MemoryMapping::clear_read() {
  read_ = false;
}
inline bool MemoryMapping::read() const {
  // @@protoc_insertion_point(field_get:MemoryMapping.read)
  return read_;
}
inline void MemoryMapping::set_read(bool value) {
  
  read_ = value;
  // @@protoc_insertion_point(field_set:MemoryMapping.read)
}

// bool write = 5;
inline void MemoryMapping::clear_write() {
  write_ = false;
}
inline bool MemoryMapping::write() const {
  // @@protoc_insertion_point(field_get:MemoryMapping.write)
  return write_;
}
inline void MemoryMapping::set_write(bool value) {
  
  write_ = value;
  // @@protoc_insertion_point(field_set:MemoryMapping.write)
}

// bool execute = 6;
inline void MemoryMapping::clear_execute() {
  execute_ = false;
}
inline bool MemoryMapping::execute() const {
  // @@protoc_insertion_point(field_get:MemoryMapping.execute)
  return execute_;
}
inline void MemoryMapping::set_execute(bool value) {
  
  execute_ = value;
  // @@protoc_insertion_point(field_set:MemoryMapping.execute)
}

// string mapping_name = 7;
inline void MemoryMapping::clear_mapping_name() {
  mapping_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& MemoryMapping::mapping_name() const {
  // @@protoc_insertion_point(field_get:MemoryMapping.mapping_name)
  return mapping_name_.GetNoArena();
}
inline void MemoryMapping::set_mapping_name(const std::string& value) {
  
  mapping_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MemoryMapping.mapping_name)
}
inline void MemoryMapping::set_mapping_name(std::string&& value) {
  
  mapping_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MemoryMapping.mapping_name)
}
inline void MemoryMapping::set_mapping_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  mapping_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MemoryMapping.mapping_name)
}
inline void MemoryMapping::set_mapping_name(const char* value, size_t size) {
  
  mapping_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MemoryMapping.mapping_name)
}
inline std::string* MemoryMapping::mutable_mapping_name() {
  
  // @@protoc_insertion_point(field_mutable:MemoryMapping.mapping_name)
  return mapping_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MemoryMapping::release_mapping_name() {
  // @@protoc_insertion_point(field_release:MemoryMapping.mapping_name)
  
  return mapping_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MemoryMapping::set_allocated_mapping_name(std::string* mapping_name) {
  if (mapping_name != nullptr) {
    
  } else {
    
  }
  mapping_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mapping_name);
  // @@protoc_insertion_point(field_set_allocated:MemoryMapping.mapping_name)
}

// string build_id = 8;
inline void MemoryMapping::clear_build_id() {
  build_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& MemoryMapping::build_id() const {
  // @@protoc_insertion_point(field_get:MemoryMapping.build_id)
  return build_id_.GetNoArena();
}
inline void MemoryMapping::set_build_id(const std::string& value) {
  
  build_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MemoryMapping.build_id)
}
inline void MemoryMapping::set_build_id(std::string&& value) {
  
  build_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MemoryMapping.build_id)
}
inline void MemoryMapping::set_build_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  build_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MemoryMapping.build_id)
}
inline void MemoryMapping::set_build_id(const char* value, size_t size) {
  
  build_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MemoryMapping.build_id)
}
inline std::string* MemoryMapping::mutable_build_id() {
  
  // @@protoc_insertion_point(field_mutable:MemoryMapping.build_id)
  return build_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MemoryMapping::release_build_id() {
  // @@protoc_insertion_point(field_release:MemoryMapping.build_id)
  
  return build_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MemoryMapping::set_allocated_build_id(std::string* build_id) {
  if (build_id != nullptr) {
    
  } else {
    
  }
  build_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), build_id);
  // @@protoc_insertion_point(field_set_allocated:MemoryMapping.build_id)
}

// uint64 load_bias = 9;
inline void MemoryMapping::clear_load_bias() {
  load_bias_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MemoryMapping::load_bias() const {
  // @@protoc_insertion_point(field_get:MemoryMapping.load_bias)
  return load_bias_;
}
inline void MemoryMapping::set_load_bias(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  load_bias_ = value;
  // @@protoc_insertion_point(field_set:MemoryMapping.load_bias)
}

// -------------------------------------------------------------------

// FD

// int32 fd = 1;
inline void FD::clear_fd() {
  fd_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FD::fd() const {
  // @@protoc_insertion_point(field_get:FD.fd)
  return fd_;
}
inline void FD::set_fd(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  fd_ = value;
  // @@protoc_insertion_point(field_set:FD.fd)
}

// string path = 2;
inline void FD::clear_path() {
  path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& FD::path() const {
  // @@protoc_insertion_point(field_get:FD.path)
  return path_.GetNoArena();
}
inline void FD::set_path(const std::string& value) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FD.path)
}
inline void FD::set_path(std::string&& value) {
  
  path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FD.path)
}
inline void FD::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FD.path)
}
inline void FD::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FD.path)
}
inline std::string* FD::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:FD.path)
  return path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FD::release_path() {
  // @@protoc_insertion_point(field_release:FD.path)
  
  return path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FD::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:FD.path)
}

// string owner = 3;
inline void FD::clear_owner() {
  owner_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& FD::owner() const {
  // @@protoc_insertion_point(field_get:FD.owner)
  return owner_.GetNoArena();
}
inline void FD::set_owner(const std::string& value) {
  
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FD.owner)
}
inline void FD::set_owner(std::string&& value) {
  
  owner_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FD.owner)
}
inline void FD::set_owner(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FD.owner)
}
inline void FD::set_owner(const char* value, size_t size) {
  
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FD.owner)
}
inline std::string* FD::mutable_owner() {
  
  // @@protoc_insertion_point(field_mutable:FD.owner)
  return owner_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FD::release_owner() {
  // @@protoc_insertion_point(field_release:FD.owner)
  
  return owner_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FD::set_allocated_owner(std::string* owner) {
  if (owner != nullptr) {
    
  } else {
    
  }
  owner_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner);
  // @@protoc_insertion_point(field_set_allocated:FD.owner)
}

// uint64 tag = 4;
inline void FD::clear_tag() {
  tag_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FD::tag() const {
  // @@protoc_insertion_point(field_get:FD.tag)
  return tag_;
}
inline void FD::set_tag(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  tag_ = value;
  // @@protoc_insertion_point(field_set:FD.tag)
}

// -------------------------------------------------------------------

// LogBuffer

// string name = 1;
inline void LogBuffer::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LogBuffer::name() const {
  // @@protoc_insertion_point(field_get:LogBuffer.name)
  return name_.GetNoArena();
}
inline void LogBuffer::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LogBuffer.name)
}
inline void LogBuffer::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LogBuffer.name)
}
inline void LogBuffer::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LogBuffer.name)
}
inline void LogBuffer::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LogBuffer.name)
}
inline std::string* LogBuffer::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:LogBuffer.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LogBuffer::release_name() {
  // @@protoc_insertion_point(field_release:LogBuffer.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LogBuffer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:LogBuffer.name)
}

// repeated .LogMessage logs = 2;
inline int LogBuffer::logs_size() const {
  return logs_.size();
}
inline void LogBuffer::clear_logs() {
  logs_.Clear();
}
inline ::LogMessage* LogBuffer::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:LogBuffer.logs)
  return logs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogMessage >*
LogBuffer::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:LogBuffer.logs)
  return &logs_;
}
inline const ::LogMessage& LogBuffer::logs(int index) const {
  // @@protoc_insertion_point(field_get:LogBuffer.logs)
  return logs_.Get(index);
}
inline ::LogMessage* LogBuffer::add_logs() {
  // @@protoc_insertion_point(field_add:LogBuffer.logs)
  return logs_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogMessage >&
LogBuffer::logs() const {
  // @@protoc_insertion_point(field_list:LogBuffer.logs)
  return logs_;
}

// -------------------------------------------------------------------

// LogMessage

// string timestamp = 1;
inline void LogMessage::clear_timestamp() {
  timestamp_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LogMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:LogMessage.timestamp)
  return timestamp_.GetNoArena();
}
inline void LogMessage::set_timestamp(const std::string& value) {
  
  timestamp_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LogMessage.timestamp)
}
inline void LogMessage::set_timestamp(std::string&& value) {
  
  timestamp_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LogMessage.timestamp)
}
inline void LogMessage::set_timestamp(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  timestamp_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LogMessage.timestamp)
}
inline void LogMessage::set_timestamp(const char* value, size_t size) {
  
  timestamp_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LogMessage.timestamp)
}
inline std::string* LogMessage::mutable_timestamp() {
  
  // @@protoc_insertion_point(field_mutable:LogMessage.timestamp)
  return timestamp_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LogMessage::release_timestamp() {
  // @@protoc_insertion_point(field_release:LogMessage.timestamp)
  
  return timestamp_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LogMessage::set_allocated_timestamp(std::string* timestamp) {
  if (timestamp != nullptr) {
    
  } else {
    
  }
  timestamp_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), timestamp);
  // @@protoc_insertion_point(field_set_allocated:LogMessage.timestamp)
}

// uint32 pid = 2;
inline void LogMessage::clear_pid() {
  pid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LogMessage::pid() const {
  // @@protoc_insertion_point(field_get:LogMessage.pid)
  return pid_;
}
inline void LogMessage::set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  pid_ = value;
  // @@protoc_insertion_point(field_set:LogMessage.pid)
}

// uint32 tid = 3;
inline void LogMessage::clear_tid() {
  tid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LogMessage::tid() const {
  // @@protoc_insertion_point(field_get:LogMessage.tid)
  return tid_;
}
inline void LogMessage::set_tid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  tid_ = value;
  // @@protoc_insertion_point(field_set:LogMessage.tid)
}

// uint32 priority = 4;
inline void LogMessage::clear_priority() {
  priority_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LogMessage::priority() const {
  // @@protoc_insertion_point(field_get:LogMessage.priority)
  return priority_;
}
inline void LogMessage::set_priority(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  priority_ = value;
  // @@protoc_insertion_point(field_set:LogMessage.priority)
}

// string tag = 5;
inline void LogMessage::clear_tag() {
  tag_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LogMessage::tag() const {
  // @@protoc_insertion_point(field_get:LogMessage.tag)
  return tag_.GetNoArena();
}
inline void LogMessage::set_tag(const std::string& value) {
  
  tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LogMessage.tag)
}
inline void LogMessage::set_tag(std::string&& value) {
  
  tag_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LogMessage.tag)
}
inline void LogMessage::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LogMessage.tag)
}
inline void LogMessage::set_tag(const char* value, size_t size) {
  
  tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LogMessage.tag)
}
inline std::string* LogMessage::mutable_tag() {
  
  // @@protoc_insertion_point(field_mutable:LogMessage.tag)
  return tag_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LogMessage::release_tag() {
  // @@protoc_insertion_point(field_release:LogMessage.tag)
  
  return tag_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LogMessage::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  tag_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:LogMessage.tag)
}

// string message = 6;
inline void LogMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LogMessage::message() const {
  // @@protoc_insertion_point(field_get:LogMessage.message)
  return message_.GetNoArena();
}
inline void LogMessage::set_message(const std::string& value) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LogMessage.message)
}
inline void LogMessage::set_message(std::string&& value) {
  
  message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LogMessage.message)
}
inline void LogMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LogMessage.message)
}
inline void LogMessage::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LogMessage.message)
}
inline std::string* LogMessage::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:LogMessage.message)
  return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LogMessage::release_message() {
  // @@protoc_insertion_point(field_release:LogMessage.message)
  
  return message_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LogMessage::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:LogMessage.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::MemoryError_Tool> : ::std::true_type {};
template <> struct is_proto_enum< ::MemoryError_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::Architecture> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_system_2fcore_2fdebuggerd_2fproto_2ftombstone_2eproto
