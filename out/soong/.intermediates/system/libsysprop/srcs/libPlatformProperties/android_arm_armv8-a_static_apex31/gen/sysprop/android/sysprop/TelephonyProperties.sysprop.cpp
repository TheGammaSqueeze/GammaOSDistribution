// Generated by the sysprop generator. DO NOT EDIT!

#include <android/sysprop/TelephonyProperties.sysprop.h>

#include <cctype>
#include <cerrno>
#include <cstdio>
#include <cstring>
#include <limits>
#include <utility>

#include <strings.h>
#ifdef __BIONIC__
#include <sys/system_properties.h>
[[maybe_unused]] static bool SetProp(const char* key, const char* value) {
    return __system_property_set(key, value) == 0;
}
#else
#include <android-base/properties.h>
[[maybe_unused]] static bool SetProp(const char* key, const char* value) {
    android::base::SetProperty(key, value);
    return true;
}
#endif

#include <android-base/parseint.h>
#include <log/log.h>

namespace {

using namespace android::sysprop::TelephonyProperties;

template <typename T> T DoParse(const char* str);

template <typename T> constexpr bool is_vector = false;

template <typename T> constexpr bool is_vector<std::vector<T>> = true;

template <> [[maybe_unused]] std::optional<bool> DoParse(const char* str) {
    static constexpr const char* kYes[] = {"1", "true"};
    static constexpr const char* kNo[] = {"0", "false"};

    for (const char* yes : kYes) {
        if (strcasecmp(yes, str) == 0) return std::make_optional(true);
    }

    for (const char* no : kNo) {
        if (strcasecmp(no, str) == 0) return std::make_optional(false);
    }

    return std::nullopt;
}

template <> [[maybe_unused]] std::optional<std::int32_t> DoParse(const char* str) {
    std::int32_t ret;
    return android::base::ParseInt(str, &ret) ? std::make_optional(ret) : std::nullopt;
}

template <> [[maybe_unused]] std::optional<std::uint32_t> DoParse(const char* str) {
    std::uint32_t ret;
    return android::base::ParseUint(str, &ret) ? std::make_optional(ret) : std::nullopt;
}

template <> [[maybe_unused]] std::optional<std::int64_t> DoParse(const char* str) {
    std::int64_t ret;
    return android::base::ParseInt(str, &ret) ? std::make_optional(ret) : std::nullopt;
}

template <> [[maybe_unused]] std::optional<std::uint64_t> DoParse(const char* str) {
    std::uint64_t ret;
    return android::base::ParseUint(str, &ret) ? std::make_optional(ret) : std::nullopt;
}

template <> [[maybe_unused]] std::optional<double> DoParse(const char* str) {
    int old_errno = errno;
    errno = 0;
    char* end;
    double ret = std::strtod(str, &end);
    if (errno != 0) {
        return std::nullopt;
    }
    if (str == end || *end != '\0') {
        errno = EINVAL;
        return std::nullopt;
    }
    errno = old_errno;
    return std::make_optional(ret);
}

template <> [[maybe_unused]] std::optional<std::string> DoParse(const char* str) {
    return *str == '\0' ? std::nullopt : std::make_optional(str);
}

template <typename Vec> [[maybe_unused]] Vec DoParseList(const char* str) {
    Vec ret;
    if (*str == '\0') return ret;
    const char* p = str;
    for (;;) {
        const char* r = p;
        std::string value;
        while (*r != ',') {
            if (*r == '\\') ++r;
            if (*r == '\0') break;
            value += *r++;
        }
        ret.emplace_back(DoParse<typename Vec::value_type>(value.c_str()));
        if (*r == '\0') break;
        p = r + 1;
    }
    return ret;
}

template <typename T> inline T TryParse(const char* str) {
    if constexpr(is_vector<T>) {
        return DoParseList<T>(str);
    } else {
        return DoParse<T>(str);
    }
}

[[maybe_unused]] std::string FormatValue(const std::optional<std::int32_t>& value) {
    return value ? std::to_string(*value) : "";
}

[[maybe_unused]] std::string FormatValue(const std::optional<std::uint32_t>& value) {
    return value ? std::to_string(*value) : "";
}

[[maybe_unused]] std::string FormatValue(const std::optional<std::int64_t>& value) {
    return value ? std::to_string(*value) : "";
}

[[maybe_unused]] std::string FormatValue(const std::optional<std::uint64_t>& value) {
    return value ? std::to_string(*value) : "";
}

[[maybe_unused]] std::string FormatValue(const std::optional<double>& value) {
    if (!value) return "";
    char buf[1024];
    std::sprintf(buf, "%.*g", std::numeric_limits<double>::max_digits10, *value);
    return buf;
}

[[maybe_unused]] std::string FormatValue(const std::optional<bool>& value) {
    return value ? (*value ? "true" : "false") : "";
}

template <typename T>
[[maybe_unused]] std::string FormatValue(const std::vector<T>& value) {
    if (value.empty()) return "";

    std::string ret;
    bool first = true;

    for (auto&& element : value) {
        if (!first) ret += ',';
        else first = false;
        if constexpr(std::is_same_v<T, std::optional<std::string>>) {
            if (element) {
                for (char c : *element) {
                    if (c == '\\' || c == ',') ret += '\\';
                    ret += c;
                }
            }
        } else {
            ret += FormatValue(element);
        }
    }

    return ret;
}

template <typename T>
T GetProp(const char* key, const char* legacy = nullptr) {
    std::string value;
#ifdef __BIONIC__
    auto pi = __system_property_find(key);
    if (pi != nullptr) {
        __system_property_read_callback(pi, [](void* cookie, const char*, const char* value, std::uint32_t) {
            *static_cast<std::string*>(cookie) = value;
        }, &value);
    }
#else
    value = android::base::GetProperty(key, "");
#endif
    if (value.empty() && legacy) {
        ALOGV("prop %s doesn't exist; fallback to legacy prop %s", key, legacy);
        return GetProp<T>(legacy);
    }
    return TryParse<T>(value.c_str());
}

}  // namespace

namespace android::sysprop::TelephonyProperties {

std::optional<bool> airplane_mode_on() {
    return GetProp<std::optional<bool>>("persist.radio.airplane_mode_on");
}

bool airplane_mode_on(const std::optional<bool>& value) {
    return SetProp("persist.radio.airplane_mode_on", FormatValue(std::optional<int>(value)).c_str());
}

std::vector<std::optional<std::string>> baseband_version() {
    return GetProp<std::vector<std::optional<std::string>>>("gsm.version.baseband");
}

bool baseband_version(const std::vector<std::optional<std::string>>& value) {
    return SetProp("gsm.version.baseband", FormatValue(value).c_str());
}

std::optional<std::string> ril_impl() {
    return GetProp<std::optional<std::string>>("gsm.version.ril-impl");
}

std::vector<std::optional<std::string>> operator_alpha() {
    return GetProp<std::vector<std::optional<std::string>>>("gsm.operator.alpha");
}

bool operator_alpha(const std::vector<std::optional<std::string>>& value) {
    return SetProp("gsm.operator.alpha", FormatValue(value).c_str());
}

std::vector<std::optional<std::string>> operator_numeric() {
    return GetProp<std::vector<std::optional<std::string>>>("gsm.operator.numeric");
}

bool operator_numeric(const std::vector<std::optional<std::string>>& value) {
    return SetProp("gsm.operator.numeric", FormatValue(value).c_str());
}

std::optional<bool> operator_is_manual() {
    return GetProp<std::optional<bool>>("operator.ismanual");
}

std::vector<std::optional<bool>> operator_is_roaming() {
    return GetProp<std::vector<std::optional<bool>>>("gsm.operator.isroaming");
}

bool operator_is_roaming(const std::vector<std::optional<bool>>& value) {
    return SetProp("gsm.operator.isroaming", FormatValue(value).c_str());
}

std::vector<std::optional<std::string>> operator_iso_country() {
    return GetProp<std::vector<std::optional<std::string>>>("gsm.operator.iso-country");
}

bool operator_iso_country(const std::vector<std::optional<std::string>>& value) {
    return SetProp("gsm.operator.iso-country", FormatValue(value).c_str());
}

std::optional<std::string> lte_on_cdma_product_type() {
    return GetProp<std::optional<std::string>>("telephony.lteOnCdmaProductType");
}

std::optional<std::int32_t> lte_on_cdma_device() {
    return GetProp<std::optional<std::int32_t>>("telephony.lteOnCdmaDevice");
}

std::vector<std::optional<std::int32_t>> current_active_phone() {
    return GetProp<std::vector<std::optional<std::int32_t>>>("gsm.current.phone-type");
}

bool current_active_phone(const std::vector<std::optional<std::int32_t>>& value) {
    return SetProp("gsm.current.phone-type", FormatValue(value).c_str());
}

std::vector<std::optional<std::string>> sim_state() {
    return GetProp<std::vector<std::optional<std::string>>>("gsm.sim.state");
}

bool sim_state(const std::vector<std::optional<std::string>>& value) {
    return SetProp("gsm.sim.state", FormatValue(value).c_str());
}

std::vector<std::optional<std::string>> icc_operator_numeric() {
    return GetProp<std::vector<std::optional<std::string>>>("gsm.sim.operator.numeric");
}

bool icc_operator_numeric(const std::vector<std::optional<std::string>>& value) {
    return SetProp("gsm.sim.operator.numeric", FormatValue(value).c_str());
}

std::vector<std::optional<std::string>> icc_operator_alpha() {
    return GetProp<std::vector<std::optional<std::string>>>("gsm.sim.operator.alpha");
}

bool icc_operator_alpha(const std::vector<std::optional<std::string>>& value) {
    return SetProp("gsm.sim.operator.alpha", FormatValue(value).c_str());
}

std::vector<std::optional<std::string>> icc_operator_iso_country() {
    return GetProp<std::vector<std::optional<std::string>>>("gsm.sim.operator.iso-country");
}

bool icc_operator_iso_country(const std::vector<std::optional<std::string>>& value) {
    return SetProp("gsm.sim.operator.iso-country", FormatValue(value).c_str());
}

std::vector<std::optional<std::string>> data_network_type() {
    return GetProp<std::vector<std::optional<std::string>>>("gsm.network.type");
}

bool data_network_type(const std::vector<std::optional<std::string>>& value) {
    return SetProp("gsm.network.type", FormatValue(value).c_str());
}

std::optional<bool> in_ecm_mode() {
    return GetProp<std::optional<bool>>("ril.cdma.inecmmode");
}

bool in_ecm_mode(const std::optional<bool>& value) {
    return SetProp("ril.cdma.inecmmode", FormatValue(value).c_str());
}

std::optional<std::int64_t> ecm_exit_timer() {
    return GetProp<std::optional<std::int64_t>>("ro.cdma.ecmexittimer");
}

std::optional<std::string> operator_idp_string() {
    return GetProp<std::optional<std::string>>("gsm.operator.idpstring");
}

bool operator_idp_string(const std::optional<std::string>& value) {
    return SetProp("gsm.operator.idpstring", value ? value->c_str() : "");
}

std::vector<std::optional<std::string>> otasp_num_schema() {
    return GetProp<std::vector<std::optional<std::string>>>("ro.cdma.otaspnumschema");
}

std::optional<bool> disable_call() {
    return GetProp<std::optional<bool>>("ro.telephony.disable-call");
}

std::optional<bool> ril_sends_multiple_call_ring() {
    return GetProp<std::optional<bool>>("ro.telephony.call_ring.multiple");
}

std::optional<std::int32_t> call_ring_delay() {
    return GetProp<std::optional<std::int32_t>>("ro.telephony.call_ring.delay");
}

std::optional<std::int32_t> cdma_msg_id() {
    return GetProp<std::optional<std::int32_t>>("persist.radio.cdma.msgid");
}

bool cdma_msg_id(const std::optional<std::int32_t>& value) {
    return SetProp("persist.radio.cdma.msgid", FormatValue(value).c_str());
}

std::optional<std::int32_t> wake_lock_timeout() {
    return GetProp<std::optional<std::int32_t>>("ro.ril.wake_lock_timeout");
}

std::optional<bool> reset_on_radio_tech_change() {
    return GetProp<std::optional<bool>>("persist.radio.reset_on_switch");
}

std::vector<std::optional<bool>> sms_receive() {
    return GetProp<std::vector<std::optional<bool>>>("telephony.sms.receive");
}

std::vector<std::optional<bool>> sms_send() {
    return GetProp<std::vector<std::optional<bool>>>("telephony.sms.send");
}

std::optional<bool> test_csim() {
    return GetProp<std::optional<bool>>("persist.radio.test-csim");
}

std::optional<bool> ignore_nitz() {
    return GetProp<std::optional<bool>>("telephony.test.ignore.nitz");
}

std::optional<std::string> multi_sim_config() {
    return GetProp<std::optional<std::string>>("persist.radio.multisim.config");
}

bool multi_sim_config(const std::optional<std::string>& value) {
    return SetProp("persist.radio.multisim.config", value ? value->c_str() : "");
}

std::optional<bool> reboot_on_modem_change() {
    return GetProp<std::optional<bool>>("persist.radio.reboot_on_modem_change");
}

std::optional<std::int32_t> videocall_audio_output() {
    return GetProp<std::optional<std::int32_t>>("persist.radio.call.audio.output");
}

std::optional<bool> enable_esim_ui_by_default() {
    return GetProp<std::optional<bool>>("esim.enable_esim_system_ui_by_default");
}

std::vector<std::optional<std::int32_t>> default_network() {
    return GetProp<std::vector<std::optional<std::int32_t>>>("ro.telephony.default_network");
}

std::optional<bool> data_roaming() {
    return GetProp<std::optional<bool>>("ro.com.android.dataroaming");
}

std::optional<bool> mobile_data() {
    return GetProp<std::optional<bool>>("ro.com.android.mobiledata");
}

std::optional<std::int32_t> wps_info() {
    return GetProp<std::optional<std::int32_t>>("wifidirect.wps");
}

std::optional<std::int32_t> max_active_modems() {
    return GetProp<std::optional<std::int32_t>>("telephony.active_modems.max_count");
}

std::optional<std::int32_t> sim_slots_count() {
    return GetProp<std::optional<std::int32_t>>("ro.telephony.sim_slots.count");
}

}  // namespace android::sysprop::TelephonyProperties
