// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: update_engine/update_metadata.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_update_5fengine_2fupdate_5fmetadata_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_update_5fengine_2fupdate_5fmetadata_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_update_5fengine_2fupdate_5fmetadata_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_update_5fengine_2fupdate_5fmetadata_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace chromeos_update_engine {
class ApexInfo;
class ApexInfoDefaultTypeInternal;
extern ApexInfoDefaultTypeInternal _ApexInfo_default_instance_;
class ApexMetadata;
class ApexMetadataDefaultTypeInternal;
extern ApexMetadataDefaultTypeInternal _ApexMetadata_default_instance_;
class CowMergeOperation;
class CowMergeOperationDefaultTypeInternal;
extern CowMergeOperationDefaultTypeInternal _CowMergeOperation_default_instance_;
class DeltaArchiveManifest;
class DeltaArchiveManifestDefaultTypeInternal;
extern DeltaArchiveManifestDefaultTypeInternal _DeltaArchiveManifest_default_instance_;
class DynamicPartitionGroup;
class DynamicPartitionGroupDefaultTypeInternal;
extern DynamicPartitionGroupDefaultTypeInternal _DynamicPartitionGroup_default_instance_;
class DynamicPartitionMetadata;
class DynamicPartitionMetadataDefaultTypeInternal;
extern DynamicPartitionMetadataDefaultTypeInternal _DynamicPartitionMetadata_default_instance_;
class Extent;
class ExtentDefaultTypeInternal;
extern ExtentDefaultTypeInternal _Extent_default_instance_;
class ImageInfo;
class ImageInfoDefaultTypeInternal;
extern ImageInfoDefaultTypeInternal _ImageInfo_default_instance_;
class InstallOperation;
class InstallOperationDefaultTypeInternal;
extern InstallOperationDefaultTypeInternal _InstallOperation_default_instance_;
class PartitionInfo;
class PartitionInfoDefaultTypeInternal;
extern PartitionInfoDefaultTypeInternal _PartitionInfo_default_instance_;
class PartitionUpdate;
class PartitionUpdateDefaultTypeInternal;
extern PartitionUpdateDefaultTypeInternal _PartitionUpdate_default_instance_;
class Signatures;
class SignaturesDefaultTypeInternal;
extern SignaturesDefaultTypeInternal _Signatures_default_instance_;
class Signatures_Signature;
class Signatures_SignatureDefaultTypeInternal;
extern Signatures_SignatureDefaultTypeInternal _Signatures_Signature_default_instance_;
}  // namespace chromeos_update_engine
PROTOBUF_NAMESPACE_OPEN
template<> ::chromeos_update_engine::ApexInfo* Arena::CreateMaybeMessage<::chromeos_update_engine::ApexInfo>(Arena*);
template<> ::chromeos_update_engine::ApexMetadata* Arena::CreateMaybeMessage<::chromeos_update_engine::ApexMetadata>(Arena*);
template<> ::chromeos_update_engine::CowMergeOperation* Arena::CreateMaybeMessage<::chromeos_update_engine::CowMergeOperation>(Arena*);
template<> ::chromeos_update_engine::DeltaArchiveManifest* Arena::CreateMaybeMessage<::chromeos_update_engine::DeltaArchiveManifest>(Arena*);
template<> ::chromeos_update_engine::DynamicPartitionGroup* Arena::CreateMaybeMessage<::chromeos_update_engine::DynamicPartitionGroup>(Arena*);
template<> ::chromeos_update_engine::DynamicPartitionMetadata* Arena::CreateMaybeMessage<::chromeos_update_engine::DynamicPartitionMetadata>(Arena*);
template<> ::chromeos_update_engine::Extent* Arena::CreateMaybeMessage<::chromeos_update_engine::Extent>(Arena*);
template<> ::chromeos_update_engine::ImageInfo* Arena::CreateMaybeMessage<::chromeos_update_engine::ImageInfo>(Arena*);
template<> ::chromeos_update_engine::InstallOperation* Arena::CreateMaybeMessage<::chromeos_update_engine::InstallOperation>(Arena*);
template<> ::chromeos_update_engine::PartitionInfo* Arena::CreateMaybeMessage<::chromeos_update_engine::PartitionInfo>(Arena*);
template<> ::chromeos_update_engine::PartitionUpdate* Arena::CreateMaybeMessage<::chromeos_update_engine::PartitionUpdate>(Arena*);
template<> ::chromeos_update_engine::Signatures* Arena::CreateMaybeMessage<::chromeos_update_engine::Signatures>(Arena*);
template<> ::chromeos_update_engine::Signatures_Signature* Arena::CreateMaybeMessage<::chromeos_update_engine::Signatures_Signature>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace chromeos_update_engine {

enum InstallOperation_Type : int {
  InstallOperation_Type_REPLACE = 0,
  InstallOperation_Type_REPLACE_BZ = 1,
  InstallOperation_Type_MOVE PROTOBUF_DEPRECATED = 2,
  InstallOperation_Type_BSDIFF PROTOBUF_DEPRECATED = 3,
  InstallOperation_Type_SOURCE_COPY = 4,
  InstallOperation_Type_SOURCE_BSDIFF = 5,
  InstallOperation_Type_REPLACE_XZ = 8,
  InstallOperation_Type_ZERO = 6,
  InstallOperation_Type_DISCARD = 7,
  InstallOperation_Type_BROTLI_BSDIFF = 10,
  InstallOperation_Type_PUFFDIFF = 9
};
bool InstallOperation_Type_IsValid(int value);
constexpr InstallOperation_Type InstallOperation_Type_Type_MIN = InstallOperation_Type_REPLACE;
constexpr InstallOperation_Type InstallOperation_Type_Type_MAX = InstallOperation_Type_BROTLI_BSDIFF;
constexpr int InstallOperation_Type_Type_ARRAYSIZE = InstallOperation_Type_Type_MAX + 1;

const std::string& InstallOperation_Type_Name(InstallOperation_Type value);
template<typename T>
inline const std::string& InstallOperation_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InstallOperation_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InstallOperation_Type_Name.");
  return InstallOperation_Type_Name(static_cast<InstallOperation_Type>(enum_t_value));
}
bool InstallOperation_Type_Parse(
    const std::string& name, InstallOperation_Type* value);
enum CowMergeOperation_Type : int {
  CowMergeOperation_Type_COW_COPY = 0
};
bool CowMergeOperation_Type_IsValid(int value);
constexpr CowMergeOperation_Type CowMergeOperation_Type_Type_MIN = CowMergeOperation_Type_COW_COPY;
constexpr CowMergeOperation_Type CowMergeOperation_Type_Type_MAX = CowMergeOperation_Type_COW_COPY;
constexpr int CowMergeOperation_Type_Type_ARRAYSIZE = CowMergeOperation_Type_Type_MAX + 1;

const std::string& CowMergeOperation_Type_Name(CowMergeOperation_Type value);
template<typename T>
inline const std::string& CowMergeOperation_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CowMergeOperation_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CowMergeOperation_Type_Name.");
  return CowMergeOperation_Type_Name(static_cast<CowMergeOperation_Type>(enum_t_value));
}
bool CowMergeOperation_Type_Parse(
    const std::string& name, CowMergeOperation_Type* value);
// ===================================================================

class Extent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.Extent) */ {
 public:
  Extent();
  virtual ~Extent();

  Extent(const Extent& from);
  Extent(Extent&& from) noexcept
    : Extent() {
    *this = ::std::move(from);
  }

  inline Extent& operator=(const Extent& from) {
    CopyFrom(from);
    return *this;
  }
  inline Extent& operator=(Extent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Extent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Extent* internal_default_instance() {
    return reinterpret_cast<const Extent*>(
               &_Extent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Extent& a, Extent& b) {
    a.Swap(&b);
  }
  inline void Swap(Extent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Extent* New() const final {
    return CreateMaybeMessage<Extent>(nullptr);
  }

  Extent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Extent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Extent& from);
  void MergeFrom(const Extent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Extent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.Extent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartBlockFieldNumber = 1,
    kNumBlocksFieldNumber = 2,
  };
  // optional uint64 start_block = 1;
  bool has_start_block() const;
  void clear_start_block();
  ::PROTOBUF_NAMESPACE_ID::uint64 start_block() const;
  void set_start_block(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 num_blocks = 2;
  bool has_num_blocks() const;
  void clear_num_blocks();
  ::PROTOBUF_NAMESPACE_ID::uint64 num_blocks() const;
  void set_num_blocks(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 start_block_;
  ::PROTOBUF_NAMESPACE_ID::uint64 num_blocks_;
  friend struct ::TableStruct_update_5fengine_2fupdate_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class Signatures_Signature :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.Signatures.Signature) */ {
 public:
  Signatures_Signature();
  virtual ~Signatures_Signature();

  Signatures_Signature(const Signatures_Signature& from);
  Signatures_Signature(Signatures_Signature&& from) noexcept
    : Signatures_Signature() {
    *this = ::std::move(from);
  }

  inline Signatures_Signature& operator=(const Signatures_Signature& from) {
    CopyFrom(from);
    return *this;
  }
  inline Signatures_Signature& operator=(Signatures_Signature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Signatures_Signature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signatures_Signature* internal_default_instance() {
    return reinterpret_cast<const Signatures_Signature*>(
               &_Signatures_Signature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Signatures_Signature& a, Signatures_Signature& b) {
    a.Swap(&b);
  }
  inline void Swap(Signatures_Signature* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Signatures_Signature* New() const final {
    return CreateMaybeMessage<Signatures_Signature>(nullptr);
  }

  Signatures_Signature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Signatures_Signature>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Signatures_Signature& from);
  void MergeFrom(const Signatures_Signature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Signatures_Signature* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.Signatures.Signature";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kVersionFieldNumber = 1,
    kUnpaddedSignatureSizeFieldNumber = 3,
  };
  // optional bytes data = 2;
  bool has_data() const;
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);

  // optional uint32 version = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_version() const;
  PROTOBUF_DEPRECATED void clear_version();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::uint32 version() const;
  PROTOBUF_DEPRECATED void set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional fixed32 unpadded_signature_size = 3;
  bool has_unpadded_signature_size() const;
  void clear_unpadded_signature_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 unpadded_signature_size() const;
  void set_unpadded_signature_size(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.Signatures.Signature)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::uint32 version_;
  ::PROTOBUF_NAMESPACE_ID::uint32 unpadded_signature_size_;
  friend struct ::TableStruct_update_5fengine_2fupdate_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class Signatures :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.Signatures) */ {
 public:
  Signatures();
  virtual ~Signatures();

  Signatures(const Signatures& from);
  Signatures(Signatures&& from) noexcept
    : Signatures() {
    *this = ::std::move(from);
  }

  inline Signatures& operator=(const Signatures& from) {
    CopyFrom(from);
    return *this;
  }
  inline Signatures& operator=(Signatures&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Signatures& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signatures* internal_default_instance() {
    return reinterpret_cast<const Signatures*>(
               &_Signatures_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Signatures& a, Signatures& b) {
    a.Swap(&b);
  }
  inline void Swap(Signatures* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Signatures* New() const final {
    return CreateMaybeMessage<Signatures>(nullptr);
  }

  Signatures* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Signatures>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Signatures& from);
  void MergeFrom(const Signatures& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Signatures* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.Signatures";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Signatures_Signature Signature;

  // accessors -------------------------------------------------------

  enum : int {
    kSignaturesFieldNumber = 1,
  };
  // repeated .chromeos_update_engine.Signatures.Signature signatures = 1;
  int signatures_size() const;
  void clear_signatures();
  ::chromeos_update_engine::Signatures_Signature* mutable_signatures(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >*
      mutable_signatures();
  const ::chromeos_update_engine::Signatures_Signature& signatures(int index) const;
  ::chromeos_update_engine::Signatures_Signature* add_signatures();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >&
      signatures() const;

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.Signatures)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature > signatures_;
  friend struct ::TableStruct_update_5fengine_2fupdate_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class PartitionInfo :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.PartitionInfo) */ {
 public:
  PartitionInfo();
  virtual ~PartitionInfo();

  PartitionInfo(const PartitionInfo& from);
  PartitionInfo(PartitionInfo&& from) noexcept
    : PartitionInfo() {
    *this = ::std::move(from);
  }

  inline PartitionInfo& operator=(const PartitionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartitionInfo& operator=(PartitionInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PartitionInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartitionInfo* internal_default_instance() {
    return reinterpret_cast<const PartitionInfo*>(
               &_PartitionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PartitionInfo& a, PartitionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PartitionInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartitionInfo* New() const final {
    return CreateMaybeMessage<PartitionInfo>(nullptr);
  }

  PartitionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartitionInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PartitionInfo& from);
  void MergeFrom(const PartitionInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PartitionInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.PartitionInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 2,
    kSizeFieldNumber = 1,
  };
  // optional bytes hash = 2;
  bool has_hash() const;
  void clear_hash();
  const std::string& hash() const;
  void set_hash(const std::string& value);
  void set_hash(std::string&& value);
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  std::string* mutable_hash();
  std::string* release_hash();
  void set_allocated_hash(std::string* hash);

  // optional uint64 size = 1;
  bool has_size() const;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.PartitionInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  ::PROTOBUF_NAMESPACE_ID::uint64 size_;
  friend struct ::TableStruct_update_5fengine_2fupdate_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ImageInfo :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.ImageInfo) */ {
 public:
  ImageInfo();
  virtual ~ImageInfo();

  ImageInfo(const ImageInfo& from);
  ImageInfo(ImageInfo&& from) noexcept
    : ImageInfo() {
    *this = ::std::move(from);
  }

  inline ImageInfo& operator=(const ImageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageInfo& operator=(ImageInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ImageInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageInfo* internal_default_instance() {
    return reinterpret_cast<const ImageInfo*>(
               &_ImageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ImageInfo& a, ImageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageInfo* New() const final {
    return CreateMaybeMessage<ImageInfo>(nullptr);
  }

  ImageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ImageInfo& from);
  void MergeFrom(const ImageInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImageInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.ImageInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoardFieldNumber = 1,
    kKeyFieldNumber = 2,
    kChannelFieldNumber = 3,
    kVersionFieldNumber = 4,
    kBuildChannelFieldNumber = 5,
    kBuildVersionFieldNumber = 6,
  };
  // optional string board = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_board() const;
  PROTOBUF_DEPRECATED void clear_board();
  PROTOBUF_DEPRECATED const std::string& board() const;
  PROTOBUF_DEPRECATED void set_board(const std::string& value);
  PROTOBUF_DEPRECATED void set_board(std::string&& value);
  PROTOBUF_DEPRECATED void set_board(const char* value);
  PROTOBUF_DEPRECATED void set_board(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_board();
  PROTOBUF_DEPRECATED std::string* release_board();
  PROTOBUF_DEPRECATED void set_allocated_board(std::string* board);

  // optional string key = 2 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_key() const;
  PROTOBUF_DEPRECATED void clear_key();
  PROTOBUF_DEPRECATED const std::string& key() const;
  PROTOBUF_DEPRECATED void set_key(const std::string& value);
  PROTOBUF_DEPRECATED void set_key(std::string&& value);
  PROTOBUF_DEPRECATED void set_key(const char* value);
  PROTOBUF_DEPRECATED void set_key(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_key();
  PROTOBUF_DEPRECATED std::string* release_key();
  PROTOBUF_DEPRECATED void set_allocated_key(std::string* key);

  // optional string channel = 3 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_channel() const;
  PROTOBUF_DEPRECATED void clear_channel();
  PROTOBUF_DEPRECATED const std::string& channel() const;
  PROTOBUF_DEPRECATED void set_channel(const std::string& value);
  PROTOBUF_DEPRECATED void set_channel(std::string&& value);
  PROTOBUF_DEPRECATED void set_channel(const char* value);
  PROTOBUF_DEPRECATED void set_channel(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_channel();
  PROTOBUF_DEPRECATED std::string* release_channel();
  PROTOBUF_DEPRECATED void set_allocated_channel(std::string* channel);

  // optional string version = 4 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_version() const;
  PROTOBUF_DEPRECATED void clear_version();
  PROTOBUF_DEPRECATED const std::string& version() const;
  PROTOBUF_DEPRECATED void set_version(const std::string& value);
  PROTOBUF_DEPRECATED void set_version(std::string&& value);
  PROTOBUF_DEPRECATED void set_version(const char* value);
  PROTOBUF_DEPRECATED void set_version(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_version();
  PROTOBUF_DEPRECATED std::string* release_version();
  PROTOBUF_DEPRECATED void set_allocated_version(std::string* version);

  // optional string build_channel = 5 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_build_channel() const;
  PROTOBUF_DEPRECATED void clear_build_channel();
  PROTOBUF_DEPRECATED const std::string& build_channel() const;
  PROTOBUF_DEPRECATED void set_build_channel(const std::string& value);
  PROTOBUF_DEPRECATED void set_build_channel(std::string&& value);
  PROTOBUF_DEPRECATED void set_build_channel(const char* value);
  PROTOBUF_DEPRECATED void set_build_channel(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_build_channel();
  PROTOBUF_DEPRECATED std::string* release_build_channel();
  PROTOBUF_DEPRECATED void set_allocated_build_channel(std::string* build_channel);

  // optional string build_version = 6 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_build_version() const;
  PROTOBUF_DEPRECATED void clear_build_version();
  PROTOBUF_DEPRECATED const std::string& build_version() const;
  PROTOBUF_DEPRECATED void set_build_version(const std::string& value);
  PROTOBUF_DEPRECATED void set_build_version(std::string&& value);
  PROTOBUF_DEPRECATED void set_build_version(const char* value);
  PROTOBUF_DEPRECATED void set_build_version(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_build_version();
  PROTOBUF_DEPRECATED std::string* release_build_version();
  PROTOBUF_DEPRECATED void set_allocated_build_version(std::string* build_version);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.ImageInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr board_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr build_channel_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr build_version_;
  friend struct ::TableStruct_update_5fengine_2fupdate_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class InstallOperation :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.InstallOperation) */ {
 public:
  InstallOperation();
  virtual ~InstallOperation();

  InstallOperation(const InstallOperation& from);
  InstallOperation(InstallOperation&& from) noexcept
    : InstallOperation() {
    *this = ::std::move(from);
  }

  inline InstallOperation& operator=(const InstallOperation& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstallOperation& operator=(InstallOperation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const InstallOperation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InstallOperation* internal_default_instance() {
    return reinterpret_cast<const InstallOperation*>(
               &_InstallOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InstallOperation& a, InstallOperation& b) {
    a.Swap(&b);
  }
  inline void Swap(InstallOperation* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InstallOperation* New() const final {
    return CreateMaybeMessage<InstallOperation>(nullptr);
  }

  InstallOperation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InstallOperation>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const InstallOperation& from);
  void MergeFrom(const InstallOperation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InstallOperation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.InstallOperation";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef InstallOperation_Type Type;
  static constexpr Type REPLACE =
    InstallOperation_Type_REPLACE;
  static constexpr Type REPLACE_BZ =
    InstallOperation_Type_REPLACE_BZ;
  PROTOBUF_DEPRECATED static constexpr Type MOVE =
    InstallOperation_Type_MOVE;
  PROTOBUF_DEPRECATED static constexpr Type BSDIFF =
    InstallOperation_Type_BSDIFF;
  static constexpr Type SOURCE_COPY =
    InstallOperation_Type_SOURCE_COPY;
  static constexpr Type SOURCE_BSDIFF =
    InstallOperation_Type_SOURCE_BSDIFF;
  static constexpr Type REPLACE_XZ =
    InstallOperation_Type_REPLACE_XZ;
  static constexpr Type ZERO =
    InstallOperation_Type_ZERO;
  static constexpr Type DISCARD =
    InstallOperation_Type_DISCARD;
  static constexpr Type BROTLI_BSDIFF =
    InstallOperation_Type_BROTLI_BSDIFF;
  static constexpr Type PUFFDIFF =
    InstallOperation_Type_PUFFDIFF;
  static inline bool Type_IsValid(int value) {
    return InstallOperation_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    InstallOperation_Type_Type_MIN;
  static constexpr Type Type_MAX =
    InstallOperation_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    InstallOperation_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return InstallOperation_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return InstallOperation_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSrcExtentsFieldNumber = 4,
    kDstExtentsFieldNumber = 6,
    kDataSha256HashFieldNumber = 8,
    kSrcSha256HashFieldNumber = 9,
    kDataOffsetFieldNumber = 2,
    kDataLengthFieldNumber = 3,
    kSrcLengthFieldNumber = 5,
    kDstLengthFieldNumber = 7,
    kTypeFieldNumber = 1,
  };
  // repeated .chromeos_update_engine.Extent src_extents = 4;
  int src_extents_size() const;
  void clear_src_extents();
  ::chromeos_update_engine::Extent* mutable_src_extents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Extent >*
      mutable_src_extents();
  const ::chromeos_update_engine::Extent& src_extents(int index) const;
  ::chromeos_update_engine::Extent* add_src_extents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Extent >&
      src_extents() const;

  // repeated .chromeos_update_engine.Extent dst_extents = 6;
  int dst_extents_size() const;
  void clear_dst_extents();
  ::chromeos_update_engine::Extent* mutable_dst_extents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Extent >*
      mutable_dst_extents();
  const ::chromeos_update_engine::Extent& dst_extents(int index) const;
  ::chromeos_update_engine::Extent* add_dst_extents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Extent >&
      dst_extents() const;

  // optional bytes data_sha256_hash = 8;
  bool has_data_sha256_hash() const;
  void clear_data_sha256_hash();
  const std::string& data_sha256_hash() const;
  void set_data_sha256_hash(const std::string& value);
  void set_data_sha256_hash(std::string&& value);
  void set_data_sha256_hash(const char* value);
  void set_data_sha256_hash(const void* value, size_t size);
  std::string* mutable_data_sha256_hash();
  std::string* release_data_sha256_hash();
  void set_allocated_data_sha256_hash(std::string* data_sha256_hash);

  // optional bytes src_sha256_hash = 9;
  bool has_src_sha256_hash() const;
  void clear_src_sha256_hash();
  const std::string& src_sha256_hash() const;
  void set_src_sha256_hash(const std::string& value);
  void set_src_sha256_hash(std::string&& value);
  void set_src_sha256_hash(const char* value);
  void set_src_sha256_hash(const void* value, size_t size);
  std::string* mutable_src_sha256_hash();
  std::string* release_src_sha256_hash();
  void set_allocated_src_sha256_hash(std::string* src_sha256_hash);

  // optional uint64 data_offset = 2;
  bool has_data_offset() const;
  void clear_data_offset();
  ::PROTOBUF_NAMESPACE_ID::uint64 data_offset() const;
  void set_data_offset(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 data_length = 3;
  bool has_data_length() const;
  void clear_data_length();
  ::PROTOBUF_NAMESPACE_ID::uint64 data_length() const;
  void set_data_length(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 src_length = 5;
  bool has_src_length() const;
  void clear_src_length();
  ::PROTOBUF_NAMESPACE_ID::uint64 src_length() const;
  void set_src_length(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 dst_length = 7;
  bool has_dst_length() const;
  void clear_dst_length();
  ::PROTOBUF_NAMESPACE_ID::uint64 dst_length() const;
  void set_dst_length(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required .chromeos_update_engine.InstallOperation.Type type = 1;
  bool has_type() const;
  void clear_type();
  ::chromeos_update_engine::InstallOperation_Type type() const;
  void set_type(::chromeos_update_engine::InstallOperation_Type value);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.InstallOperation)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Extent > src_extents_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Extent > dst_extents_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_sha256_hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_sha256_hash_;
  ::PROTOBUF_NAMESPACE_ID::uint64 data_offset_;
  ::PROTOBUF_NAMESPACE_ID::uint64 data_length_;
  ::PROTOBUF_NAMESPACE_ID::uint64 src_length_;
  ::PROTOBUF_NAMESPACE_ID::uint64 dst_length_;
  int type_;
  friend struct ::TableStruct_update_5fengine_2fupdate_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class CowMergeOperation :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.CowMergeOperation) */ {
 public:
  CowMergeOperation();
  virtual ~CowMergeOperation();

  CowMergeOperation(const CowMergeOperation& from);
  CowMergeOperation(CowMergeOperation&& from) noexcept
    : CowMergeOperation() {
    *this = ::std::move(from);
  }

  inline CowMergeOperation& operator=(const CowMergeOperation& from) {
    CopyFrom(from);
    return *this;
  }
  inline CowMergeOperation& operator=(CowMergeOperation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CowMergeOperation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CowMergeOperation* internal_default_instance() {
    return reinterpret_cast<const CowMergeOperation*>(
               &_CowMergeOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CowMergeOperation& a, CowMergeOperation& b) {
    a.Swap(&b);
  }
  inline void Swap(CowMergeOperation* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CowMergeOperation* New() const final {
    return CreateMaybeMessage<CowMergeOperation>(nullptr);
  }

  CowMergeOperation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CowMergeOperation>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const CowMergeOperation& from);
  void MergeFrom(const CowMergeOperation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CowMergeOperation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.CowMergeOperation";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CowMergeOperation_Type Type;
  static constexpr Type COW_COPY =
    CowMergeOperation_Type_COW_COPY;
  static inline bool Type_IsValid(int value) {
    return CowMergeOperation_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    CowMergeOperation_Type_Type_MIN;
  static constexpr Type Type_MAX =
    CowMergeOperation_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    CowMergeOperation_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return CowMergeOperation_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return CowMergeOperation_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSrcExtentFieldNumber = 2,
    kDstExtentFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // optional .chromeos_update_engine.Extent src_extent = 2;
  bool has_src_extent() const;
  void clear_src_extent();
  const ::chromeos_update_engine::Extent& src_extent() const;
  ::chromeos_update_engine::Extent* release_src_extent();
  ::chromeos_update_engine::Extent* mutable_src_extent();
  void set_allocated_src_extent(::chromeos_update_engine::Extent* src_extent);

  // optional .chromeos_update_engine.Extent dst_extent = 3;
  bool has_dst_extent() const;
  void clear_dst_extent();
  const ::chromeos_update_engine::Extent& dst_extent() const;
  ::chromeos_update_engine::Extent* release_dst_extent();
  ::chromeos_update_engine::Extent* mutable_dst_extent();
  void set_allocated_dst_extent(::chromeos_update_engine::Extent* dst_extent);

  // optional .chromeos_update_engine.CowMergeOperation.Type type = 1;
  bool has_type() const;
  void clear_type();
  ::chromeos_update_engine::CowMergeOperation_Type type() const;
  void set_type(::chromeos_update_engine::CowMergeOperation_Type value);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.CowMergeOperation)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::chromeos_update_engine::Extent* src_extent_;
  ::chromeos_update_engine::Extent* dst_extent_;
  int type_;
  friend struct ::TableStruct_update_5fengine_2fupdate_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class PartitionUpdate :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.PartitionUpdate) */ {
 public:
  PartitionUpdate();
  virtual ~PartitionUpdate();

  PartitionUpdate(const PartitionUpdate& from);
  PartitionUpdate(PartitionUpdate&& from) noexcept
    : PartitionUpdate() {
    *this = ::std::move(from);
  }

  inline PartitionUpdate& operator=(const PartitionUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartitionUpdate& operator=(PartitionUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PartitionUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartitionUpdate* internal_default_instance() {
    return reinterpret_cast<const PartitionUpdate*>(
               &_PartitionUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PartitionUpdate& a, PartitionUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(PartitionUpdate* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartitionUpdate* New() const final {
    return CreateMaybeMessage<PartitionUpdate>(nullptr);
  }

  PartitionUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartitionUpdate>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PartitionUpdate& from);
  void MergeFrom(const PartitionUpdate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PartitionUpdate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.PartitionUpdate";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewPartitionSignatureFieldNumber = 5,
    kOperationsFieldNumber = 8,
    kMergeOperationsFieldNumber = 18,
    kPartitionNameFieldNumber = 1,
    kPostinstallPathFieldNumber = 3,
    kFilesystemTypeFieldNumber = 4,
    kHashTreeAlgorithmFieldNumber = 12,
    kHashTreeSaltFieldNumber = 13,
    kVersionFieldNumber = 17,
    kOldPartitionInfoFieldNumber = 6,
    kNewPartitionInfoFieldNumber = 7,
    kHashTreeDataExtentFieldNumber = 10,
    kHashTreeExtentFieldNumber = 11,
    kFecDataExtentFieldNumber = 14,
    kFecExtentFieldNumber = 15,
    kEstimateCowSizeFieldNumber = 19,
    kRunPostinstallFieldNumber = 2,
    kPostinstallOptionalFieldNumber = 9,
    kFecRootsFieldNumber = 16,
  };
  // repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;
  int new_partition_signature_size() const;
  void clear_new_partition_signature();
  ::chromeos_update_engine::Signatures_Signature* mutable_new_partition_signature(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >*
      mutable_new_partition_signature();
  const ::chromeos_update_engine::Signatures_Signature& new_partition_signature(int index) const;
  ::chromeos_update_engine::Signatures_Signature* add_new_partition_signature();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >&
      new_partition_signature() const;

  // repeated .chromeos_update_engine.InstallOperation operations = 8;
  int operations_size() const;
  void clear_operations();
  ::chromeos_update_engine::InstallOperation* mutable_operations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >*
      mutable_operations();
  const ::chromeos_update_engine::InstallOperation& operations(int index) const;
  ::chromeos_update_engine::InstallOperation* add_operations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >&
      operations() const;

  // repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;
  int merge_operations_size() const;
  void clear_merge_operations();
  ::chromeos_update_engine::CowMergeOperation* mutable_merge_operations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::CowMergeOperation >*
      mutable_merge_operations();
  const ::chromeos_update_engine::CowMergeOperation& merge_operations(int index) const;
  ::chromeos_update_engine::CowMergeOperation* add_merge_operations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::CowMergeOperation >&
      merge_operations() const;

  // required string partition_name = 1;
  bool has_partition_name() const;
  void clear_partition_name();
  const std::string& partition_name() const;
  void set_partition_name(const std::string& value);
  void set_partition_name(std::string&& value);
  void set_partition_name(const char* value);
  void set_partition_name(const char* value, size_t size);
  std::string* mutable_partition_name();
  std::string* release_partition_name();
  void set_allocated_partition_name(std::string* partition_name);

  // optional string postinstall_path = 3;
  bool has_postinstall_path() const;
  void clear_postinstall_path();
  const std::string& postinstall_path() const;
  void set_postinstall_path(const std::string& value);
  void set_postinstall_path(std::string&& value);
  void set_postinstall_path(const char* value);
  void set_postinstall_path(const char* value, size_t size);
  std::string* mutable_postinstall_path();
  std::string* release_postinstall_path();
  void set_allocated_postinstall_path(std::string* postinstall_path);

  // optional string filesystem_type = 4;
  bool has_filesystem_type() const;
  void clear_filesystem_type();
  const std::string& filesystem_type() const;
  void set_filesystem_type(const std::string& value);
  void set_filesystem_type(std::string&& value);
  void set_filesystem_type(const char* value);
  void set_filesystem_type(const char* value, size_t size);
  std::string* mutable_filesystem_type();
  std::string* release_filesystem_type();
  void set_allocated_filesystem_type(std::string* filesystem_type);

  // optional string hash_tree_algorithm = 12;
  bool has_hash_tree_algorithm() const;
  void clear_hash_tree_algorithm();
  const std::string& hash_tree_algorithm() const;
  void set_hash_tree_algorithm(const std::string& value);
  void set_hash_tree_algorithm(std::string&& value);
  void set_hash_tree_algorithm(const char* value);
  void set_hash_tree_algorithm(const char* value, size_t size);
  std::string* mutable_hash_tree_algorithm();
  std::string* release_hash_tree_algorithm();
  void set_allocated_hash_tree_algorithm(std::string* hash_tree_algorithm);

  // optional bytes hash_tree_salt = 13;
  bool has_hash_tree_salt() const;
  void clear_hash_tree_salt();
  const std::string& hash_tree_salt() const;
  void set_hash_tree_salt(const std::string& value);
  void set_hash_tree_salt(std::string&& value);
  void set_hash_tree_salt(const char* value);
  void set_hash_tree_salt(const void* value, size_t size);
  std::string* mutable_hash_tree_salt();
  std::string* release_hash_tree_salt();
  void set_allocated_hash_tree_salt(std::string* hash_tree_salt);

  // optional string version = 17;
  bool has_version() const;
  void clear_version();
  const std::string& version() const;
  void set_version(const std::string& value);
  void set_version(std::string&& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  std::string* mutable_version();
  std::string* release_version();
  void set_allocated_version(std::string* version);

  // optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;
  bool has_old_partition_info() const;
  void clear_old_partition_info();
  const ::chromeos_update_engine::PartitionInfo& old_partition_info() const;
  ::chromeos_update_engine::PartitionInfo* release_old_partition_info();
  ::chromeos_update_engine::PartitionInfo* mutable_old_partition_info();
  void set_allocated_old_partition_info(::chromeos_update_engine::PartitionInfo* old_partition_info);

  // optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;
  bool has_new_partition_info() const;
  void clear_new_partition_info();
  const ::chromeos_update_engine::PartitionInfo& new_partition_info() const;
  ::chromeos_update_engine::PartitionInfo* release_new_partition_info();
  ::chromeos_update_engine::PartitionInfo* mutable_new_partition_info();
  void set_allocated_new_partition_info(::chromeos_update_engine::PartitionInfo* new_partition_info);

  // optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;
  bool has_hash_tree_data_extent() const;
  void clear_hash_tree_data_extent();
  const ::chromeos_update_engine::Extent& hash_tree_data_extent() const;
  ::chromeos_update_engine::Extent* release_hash_tree_data_extent();
  ::chromeos_update_engine::Extent* mutable_hash_tree_data_extent();
  void set_allocated_hash_tree_data_extent(::chromeos_update_engine::Extent* hash_tree_data_extent);

  // optional .chromeos_update_engine.Extent hash_tree_extent = 11;
  bool has_hash_tree_extent() const;
  void clear_hash_tree_extent();
  const ::chromeos_update_engine::Extent& hash_tree_extent() const;
  ::chromeos_update_engine::Extent* release_hash_tree_extent();
  ::chromeos_update_engine::Extent* mutable_hash_tree_extent();
  void set_allocated_hash_tree_extent(::chromeos_update_engine::Extent* hash_tree_extent);

  // optional .chromeos_update_engine.Extent fec_data_extent = 14;
  bool has_fec_data_extent() const;
  void clear_fec_data_extent();
  const ::chromeos_update_engine::Extent& fec_data_extent() const;
  ::chromeos_update_engine::Extent* release_fec_data_extent();
  ::chromeos_update_engine::Extent* mutable_fec_data_extent();
  void set_allocated_fec_data_extent(::chromeos_update_engine::Extent* fec_data_extent);

  // optional .chromeos_update_engine.Extent fec_extent = 15;
  bool has_fec_extent() const;
  void clear_fec_extent();
  const ::chromeos_update_engine::Extent& fec_extent() const;
  ::chromeos_update_engine::Extent* release_fec_extent();
  ::chromeos_update_engine::Extent* mutable_fec_extent();
  void set_allocated_fec_extent(::chromeos_update_engine::Extent* fec_extent);

  // optional uint64 estimate_cow_size = 19;
  bool has_estimate_cow_size() const;
  void clear_estimate_cow_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 estimate_cow_size() const;
  void set_estimate_cow_size(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional bool run_postinstall = 2;
  bool has_run_postinstall() const;
  void clear_run_postinstall();
  bool run_postinstall() const;
  void set_run_postinstall(bool value);

  // optional bool postinstall_optional = 9;
  bool has_postinstall_optional() const;
  void clear_postinstall_optional();
  bool postinstall_optional() const;
  void set_postinstall_optional(bool value);

  // optional uint32 fec_roots = 16 [default = 2];
  bool has_fec_roots() const;
  void clear_fec_roots();
  ::PROTOBUF_NAMESPACE_ID::uint32 fec_roots() const;
  void set_fec_roots(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.PartitionUpdate)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature > new_partition_signature_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::InstallOperation > operations_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::CowMergeOperation > merge_operations_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partition_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr postinstall_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filesystem_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_tree_algorithm_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_tree_salt_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::chromeos_update_engine::PartitionInfo* old_partition_info_;
  ::chromeos_update_engine::PartitionInfo* new_partition_info_;
  ::chromeos_update_engine::Extent* hash_tree_data_extent_;
  ::chromeos_update_engine::Extent* hash_tree_extent_;
  ::chromeos_update_engine::Extent* fec_data_extent_;
  ::chromeos_update_engine::Extent* fec_extent_;
  ::PROTOBUF_NAMESPACE_ID::uint64 estimate_cow_size_;
  bool run_postinstall_;
  bool postinstall_optional_;
  ::PROTOBUF_NAMESPACE_ID::uint32 fec_roots_;
  friend struct ::TableStruct_update_5fengine_2fupdate_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class DynamicPartitionGroup :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.DynamicPartitionGroup) */ {
 public:
  DynamicPartitionGroup();
  virtual ~DynamicPartitionGroup();

  DynamicPartitionGroup(const DynamicPartitionGroup& from);
  DynamicPartitionGroup(DynamicPartitionGroup&& from) noexcept
    : DynamicPartitionGroup() {
    *this = ::std::move(from);
  }

  inline DynamicPartitionGroup& operator=(const DynamicPartitionGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline DynamicPartitionGroup& operator=(DynamicPartitionGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DynamicPartitionGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DynamicPartitionGroup* internal_default_instance() {
    return reinterpret_cast<const DynamicPartitionGroup*>(
               &_DynamicPartitionGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DynamicPartitionGroup& a, DynamicPartitionGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(DynamicPartitionGroup* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DynamicPartitionGroup* New() const final {
    return CreateMaybeMessage<DynamicPartitionGroup>(nullptr);
  }

  DynamicPartitionGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DynamicPartitionGroup>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DynamicPartitionGroup& from);
  void MergeFrom(const DynamicPartitionGroup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DynamicPartitionGroup* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.DynamicPartitionGroup";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartitionNamesFieldNumber = 3,
    kNameFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // repeated string partition_names = 3;
  int partition_names_size() const;
  void clear_partition_names();
  const std::string& partition_names(int index) const;
  std::string* mutable_partition_names(int index);
  void set_partition_names(int index, const std::string& value);
  void set_partition_names(int index, std::string&& value);
  void set_partition_names(int index, const char* value);
  void set_partition_names(int index, const char* value, size_t size);
  std::string* add_partition_names();
  void add_partition_names(const std::string& value);
  void add_partition_names(std::string&& value);
  void add_partition_names(const char* value);
  void add_partition_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& partition_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_partition_names();

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // optional uint64 size = 2;
  bool has_size() const;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.DynamicPartitionGroup)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> partition_names_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 size_;
  friend struct ::TableStruct_update_5fengine_2fupdate_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class DynamicPartitionMetadata :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.DynamicPartitionMetadata) */ {
 public:
  DynamicPartitionMetadata();
  virtual ~DynamicPartitionMetadata();

  DynamicPartitionMetadata(const DynamicPartitionMetadata& from);
  DynamicPartitionMetadata(DynamicPartitionMetadata&& from) noexcept
    : DynamicPartitionMetadata() {
    *this = ::std::move(from);
  }

  inline DynamicPartitionMetadata& operator=(const DynamicPartitionMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline DynamicPartitionMetadata& operator=(DynamicPartitionMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DynamicPartitionMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DynamicPartitionMetadata* internal_default_instance() {
    return reinterpret_cast<const DynamicPartitionMetadata*>(
               &_DynamicPartitionMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DynamicPartitionMetadata& a, DynamicPartitionMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(DynamicPartitionMetadata* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DynamicPartitionMetadata* New() const final {
    return CreateMaybeMessage<DynamicPartitionMetadata>(nullptr);
  }

  DynamicPartitionMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DynamicPartitionMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DynamicPartitionMetadata& from);
  void MergeFrom(const DynamicPartitionMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DynamicPartitionMetadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.DynamicPartitionMetadata";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupsFieldNumber = 1,
    kVabcCompressionParamFieldNumber = 4,
    kSnapshotEnabledFieldNumber = 2,
    kVabcEnabledFieldNumber = 3,
    kCowVersionFieldNumber = 5,
  };
  // repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;
  int groups_size() const;
  void clear_groups();
  ::chromeos_update_engine::DynamicPartitionGroup* mutable_groups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::DynamicPartitionGroup >*
      mutable_groups();
  const ::chromeos_update_engine::DynamicPartitionGroup& groups(int index) const;
  ::chromeos_update_engine::DynamicPartitionGroup* add_groups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::DynamicPartitionGroup >&
      groups() const;

  // optional string vabc_compression_param = 4;
  bool has_vabc_compression_param() const;
  void clear_vabc_compression_param();
  const std::string& vabc_compression_param() const;
  void set_vabc_compression_param(const std::string& value);
  void set_vabc_compression_param(std::string&& value);
  void set_vabc_compression_param(const char* value);
  void set_vabc_compression_param(const char* value, size_t size);
  std::string* mutable_vabc_compression_param();
  std::string* release_vabc_compression_param();
  void set_allocated_vabc_compression_param(std::string* vabc_compression_param);

  // optional bool snapshot_enabled = 2;
  bool has_snapshot_enabled() const;
  void clear_snapshot_enabled();
  bool snapshot_enabled() const;
  void set_snapshot_enabled(bool value);

  // optional bool vabc_enabled = 3;
  bool has_vabc_enabled() const;
  void clear_vabc_enabled();
  bool vabc_enabled() const;
  void set_vabc_enabled(bool value);

  // optional uint32 cow_version = 5;
  bool has_cow_version() const;
  void clear_cow_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 cow_version() const;
  void set_cow_version(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.DynamicPartitionMetadata)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::DynamicPartitionGroup > groups_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vabc_compression_param_;
  bool snapshot_enabled_;
  bool vabc_enabled_;
  ::PROTOBUF_NAMESPACE_ID::uint32 cow_version_;
  friend struct ::TableStruct_update_5fengine_2fupdate_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ApexInfo :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.ApexInfo) */ {
 public:
  ApexInfo();
  virtual ~ApexInfo();

  ApexInfo(const ApexInfo& from);
  ApexInfo(ApexInfo&& from) noexcept
    : ApexInfo() {
    *this = ::std::move(from);
  }

  inline ApexInfo& operator=(const ApexInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApexInfo& operator=(ApexInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ApexInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ApexInfo* internal_default_instance() {
    return reinterpret_cast<const ApexInfo*>(
               &_ApexInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ApexInfo& a, ApexInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ApexInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ApexInfo* New() const final {
    return CreateMaybeMessage<ApexInfo>(nullptr);
  }

  ApexInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ApexInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ApexInfo& from);
  void MergeFrom(const ApexInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ApexInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.ApexInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackageNameFieldNumber = 1,
    kVersionFieldNumber = 2,
    kDecompressedSizeFieldNumber = 4,
    kIsCompressedFieldNumber = 3,
  };
  // optional string package_name = 1;
  bool has_package_name() const;
  void clear_package_name();
  const std::string& package_name() const;
  void set_package_name(const std::string& value);
  void set_package_name(std::string&& value);
  void set_package_name(const char* value);
  void set_package_name(const char* value, size_t size);
  std::string* mutable_package_name();
  std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);

  // optional int64 version = 2;
  bool has_version() const;
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int64 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 decompressed_size = 4;
  bool has_decompressed_size() const;
  void clear_decompressed_size();
  ::PROTOBUF_NAMESPACE_ID::int64 decompressed_size() const;
  void set_decompressed_size(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional bool is_compressed = 3;
  bool has_is_compressed() const;
  void clear_is_compressed();
  bool is_compressed() const;
  void set_is_compressed(bool value);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.ApexInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
  ::PROTOBUF_NAMESPACE_ID::int64 version_;
  ::PROTOBUF_NAMESPACE_ID::int64 decompressed_size_;
  bool is_compressed_;
  friend struct ::TableStruct_update_5fengine_2fupdate_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ApexMetadata :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.ApexMetadata) */ {
 public:
  ApexMetadata();
  virtual ~ApexMetadata();

  ApexMetadata(const ApexMetadata& from);
  ApexMetadata(ApexMetadata&& from) noexcept
    : ApexMetadata() {
    *this = ::std::move(from);
  }

  inline ApexMetadata& operator=(const ApexMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApexMetadata& operator=(ApexMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ApexMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ApexMetadata* internal_default_instance() {
    return reinterpret_cast<const ApexMetadata*>(
               &_ApexMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ApexMetadata& a, ApexMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(ApexMetadata* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ApexMetadata* New() const final {
    return CreateMaybeMessage<ApexMetadata>(nullptr);
  }

  ApexMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ApexMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ApexMetadata& from);
  void MergeFrom(const ApexMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ApexMetadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.ApexMetadata";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApexInfoFieldNumber = 1,
  };
  // repeated .chromeos_update_engine.ApexInfo apex_info = 1;
  int apex_info_size() const;
  void clear_apex_info();
  ::chromeos_update_engine::ApexInfo* mutable_apex_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::ApexInfo >*
      mutable_apex_info();
  const ::chromeos_update_engine::ApexInfo& apex_info(int index) const;
  ::chromeos_update_engine::ApexInfo* add_apex_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::ApexInfo >&
      apex_info() const;

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.ApexMetadata)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::ApexInfo > apex_info_;
  friend struct ::TableStruct_update_5fengine_2fupdate_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class DeltaArchiveManifest :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.DeltaArchiveManifest) */ {
 public:
  DeltaArchiveManifest();
  virtual ~DeltaArchiveManifest();

  DeltaArchiveManifest(const DeltaArchiveManifest& from);
  DeltaArchiveManifest(DeltaArchiveManifest&& from) noexcept
    : DeltaArchiveManifest() {
    *this = ::std::move(from);
  }

  inline DeltaArchiveManifest& operator=(const DeltaArchiveManifest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeltaArchiveManifest& operator=(DeltaArchiveManifest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DeltaArchiveManifest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeltaArchiveManifest* internal_default_instance() {
    return reinterpret_cast<const DeltaArchiveManifest*>(
               &_DeltaArchiveManifest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DeltaArchiveManifest& a, DeltaArchiveManifest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeltaArchiveManifest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeltaArchiveManifest* New() const final {
    return CreateMaybeMessage<DeltaArchiveManifest>(nullptr);
  }

  DeltaArchiveManifest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeltaArchiveManifest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DeltaArchiveManifest& from);
  void MergeFrom(const DeltaArchiveManifest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeltaArchiveManifest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.DeltaArchiveManifest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstallOperationsFieldNumber = 1,
    kKernelInstallOperationsFieldNumber = 2,
    kPartitionsFieldNumber = 13,
    kApexInfoFieldNumber = 17,
    kOldKernelInfoFieldNumber = 6,
    kNewKernelInfoFieldNumber = 7,
    kOldRootfsInfoFieldNumber = 8,
    kNewRootfsInfoFieldNumber = 9,
    kOldImageInfoFieldNumber = 10,
    kNewImageInfoFieldNumber = 11,
    kDynamicPartitionMetadataFieldNumber = 15,
    kSignaturesOffsetFieldNumber = 4,
    kSignaturesSizeFieldNumber = 5,
    kMaxTimestampFieldNumber = 14,
    kMinorVersionFieldNumber = 12,
    kPartialUpdateFieldNumber = 16,
    kBlockSizeFieldNumber = 3,
  };
  // repeated .chromeos_update_engine.InstallOperation install_operations = 1 [deprecated = true];
  PROTOBUF_DEPRECATED int install_operations_size() const;
  PROTOBUF_DEPRECATED void clear_install_operations();
  PROTOBUF_DEPRECATED ::chromeos_update_engine::InstallOperation* mutable_install_operations(int index);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >*
      mutable_install_operations();
  PROTOBUF_DEPRECATED const ::chromeos_update_engine::InstallOperation& install_operations(int index) const;
  PROTOBUF_DEPRECATED ::chromeos_update_engine::InstallOperation* add_install_operations();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >&
      install_operations() const;

  // repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2 [deprecated = true];
  PROTOBUF_DEPRECATED int kernel_install_operations_size() const;
  PROTOBUF_DEPRECATED void clear_kernel_install_operations();
  PROTOBUF_DEPRECATED ::chromeos_update_engine::InstallOperation* mutable_kernel_install_operations(int index);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >*
      mutable_kernel_install_operations();
  PROTOBUF_DEPRECATED const ::chromeos_update_engine::InstallOperation& kernel_install_operations(int index) const;
  PROTOBUF_DEPRECATED ::chromeos_update_engine::InstallOperation* add_kernel_install_operations();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >&
      kernel_install_operations() const;

  // repeated .chromeos_update_engine.PartitionUpdate partitions = 13;
  int partitions_size() const;
  void clear_partitions();
  ::chromeos_update_engine::PartitionUpdate* mutable_partitions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::PartitionUpdate >*
      mutable_partitions();
  const ::chromeos_update_engine::PartitionUpdate& partitions(int index) const;
  ::chromeos_update_engine::PartitionUpdate* add_partitions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::PartitionUpdate >&
      partitions() const;

  // repeated .chromeos_update_engine.ApexInfo apex_info = 17;
  int apex_info_size() const;
  void clear_apex_info();
  ::chromeos_update_engine::ApexInfo* mutable_apex_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::ApexInfo >*
      mutable_apex_info();
  const ::chromeos_update_engine::ApexInfo& apex_info(int index) const;
  ::chromeos_update_engine::ApexInfo* add_apex_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::ApexInfo >&
      apex_info() const;

  // optional .chromeos_update_engine.PartitionInfo old_kernel_info = 6 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_old_kernel_info() const;
  PROTOBUF_DEPRECATED void clear_old_kernel_info();
  PROTOBUF_DEPRECATED const ::chromeos_update_engine::PartitionInfo& old_kernel_info() const;
  PROTOBUF_DEPRECATED ::chromeos_update_engine::PartitionInfo* release_old_kernel_info();
  PROTOBUF_DEPRECATED ::chromeos_update_engine::PartitionInfo* mutable_old_kernel_info();
  PROTOBUF_DEPRECATED void set_allocated_old_kernel_info(::chromeos_update_engine::PartitionInfo* old_kernel_info);

  // optional .chromeos_update_engine.PartitionInfo new_kernel_info = 7 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_new_kernel_info() const;
  PROTOBUF_DEPRECATED void clear_new_kernel_info();
  PROTOBUF_DEPRECATED const ::chromeos_update_engine::PartitionInfo& new_kernel_info() const;
  PROTOBUF_DEPRECATED ::chromeos_update_engine::PartitionInfo* release_new_kernel_info();
  PROTOBUF_DEPRECATED ::chromeos_update_engine::PartitionInfo* mutable_new_kernel_info();
  PROTOBUF_DEPRECATED void set_allocated_new_kernel_info(::chromeos_update_engine::PartitionInfo* new_kernel_info);

  // optional .chromeos_update_engine.PartitionInfo old_rootfs_info = 8 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_old_rootfs_info() const;
  PROTOBUF_DEPRECATED void clear_old_rootfs_info();
  PROTOBUF_DEPRECATED const ::chromeos_update_engine::PartitionInfo& old_rootfs_info() const;
  PROTOBUF_DEPRECATED ::chromeos_update_engine::PartitionInfo* release_old_rootfs_info();
  PROTOBUF_DEPRECATED ::chromeos_update_engine::PartitionInfo* mutable_old_rootfs_info();
  PROTOBUF_DEPRECATED void set_allocated_old_rootfs_info(::chromeos_update_engine::PartitionInfo* old_rootfs_info);

  // optional .chromeos_update_engine.PartitionInfo new_rootfs_info = 9 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_new_rootfs_info() const;
  PROTOBUF_DEPRECATED void clear_new_rootfs_info();
  PROTOBUF_DEPRECATED const ::chromeos_update_engine::PartitionInfo& new_rootfs_info() const;
  PROTOBUF_DEPRECATED ::chromeos_update_engine::PartitionInfo* release_new_rootfs_info();
  PROTOBUF_DEPRECATED ::chromeos_update_engine::PartitionInfo* mutable_new_rootfs_info();
  PROTOBUF_DEPRECATED void set_allocated_new_rootfs_info(::chromeos_update_engine::PartitionInfo* new_rootfs_info);

  // optional .chromeos_update_engine.ImageInfo old_image_info = 10 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_old_image_info() const;
  PROTOBUF_DEPRECATED void clear_old_image_info();
  PROTOBUF_DEPRECATED const ::chromeos_update_engine::ImageInfo& old_image_info() const;
  PROTOBUF_DEPRECATED ::chromeos_update_engine::ImageInfo* release_old_image_info();
  PROTOBUF_DEPRECATED ::chromeos_update_engine::ImageInfo* mutable_old_image_info();
  PROTOBUF_DEPRECATED void set_allocated_old_image_info(::chromeos_update_engine::ImageInfo* old_image_info);

  // optional .chromeos_update_engine.ImageInfo new_image_info = 11 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_new_image_info() const;
  PROTOBUF_DEPRECATED void clear_new_image_info();
  PROTOBUF_DEPRECATED const ::chromeos_update_engine::ImageInfo& new_image_info() const;
  PROTOBUF_DEPRECATED ::chromeos_update_engine::ImageInfo* release_new_image_info();
  PROTOBUF_DEPRECATED ::chromeos_update_engine::ImageInfo* mutable_new_image_info();
  PROTOBUF_DEPRECATED void set_allocated_new_image_info(::chromeos_update_engine::ImageInfo* new_image_info);

  // optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;
  bool has_dynamic_partition_metadata() const;
  void clear_dynamic_partition_metadata();
  const ::chromeos_update_engine::DynamicPartitionMetadata& dynamic_partition_metadata() const;
  ::chromeos_update_engine::DynamicPartitionMetadata* release_dynamic_partition_metadata();
  ::chromeos_update_engine::DynamicPartitionMetadata* mutable_dynamic_partition_metadata();
  void set_allocated_dynamic_partition_metadata(::chromeos_update_engine::DynamicPartitionMetadata* dynamic_partition_metadata);

  // optional uint64 signatures_offset = 4;
  bool has_signatures_offset() const;
  void clear_signatures_offset();
  ::PROTOBUF_NAMESPACE_ID::uint64 signatures_offset() const;
  void set_signatures_offset(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 signatures_size = 5;
  bool has_signatures_size() const;
  void clear_signatures_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 signatures_size() const;
  void set_signatures_size(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional int64 max_timestamp = 14;
  bool has_max_timestamp() const;
  void clear_max_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 max_timestamp() const;
  void set_max_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional uint32 minor_version = 12 [default = 0];
  bool has_minor_version() const;
  void clear_minor_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 minor_version() const;
  void set_minor_version(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional bool partial_update = 16;
  bool has_partial_update() const;
  void clear_partial_update();
  bool partial_update() const;
  void set_partial_update(bool value);

  // optional uint32 block_size = 3 [default = 4096];
  bool has_block_size() const;
  void clear_block_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 block_size() const;
  void set_block_size(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.DeltaArchiveManifest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::InstallOperation > install_operations_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::InstallOperation > kernel_install_operations_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::PartitionUpdate > partitions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::ApexInfo > apex_info_;
  ::chromeos_update_engine::PartitionInfo* old_kernel_info_;
  ::chromeos_update_engine::PartitionInfo* new_kernel_info_;
  ::chromeos_update_engine::PartitionInfo* old_rootfs_info_;
  ::chromeos_update_engine::PartitionInfo* new_rootfs_info_;
  ::chromeos_update_engine::ImageInfo* old_image_info_;
  ::chromeos_update_engine::ImageInfo* new_image_info_;
  ::chromeos_update_engine::DynamicPartitionMetadata* dynamic_partition_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint64 signatures_offset_;
  ::PROTOBUF_NAMESPACE_ID::uint64 signatures_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 max_timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint32 minor_version_;
  bool partial_update_;
  ::PROTOBUF_NAMESPACE_ID::uint32 block_size_;
  friend struct ::TableStruct_update_5fengine_2fupdate_5fmetadata_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Extent

// optional uint64 start_block = 1;
inline bool Extent::has_start_block() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Extent::clear_start_block() {
  start_block_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Extent::start_block() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Extent.start_block)
  return start_block_;
}
inline void Extent::set_start_block(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  start_block_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.Extent.start_block)
}

// optional uint64 num_blocks = 2;
inline bool Extent::has_num_blocks() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Extent::clear_num_blocks() {
  num_blocks_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Extent::num_blocks() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Extent.num_blocks)
  return num_blocks_;
}
inline void Extent::set_num_blocks(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  num_blocks_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.Extent.num_blocks)
}

// -------------------------------------------------------------------

// Signatures_Signature

// optional uint32 version = 1 [deprecated = true];
inline bool Signatures_Signature::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Signatures_Signature::clear_version() {
  version_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Signatures_Signature::version() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Signatures.Signature.version)
  return version_;
}
inline void Signatures_Signature::set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  version_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.Signatures.Signature.version)
}

// optional bytes data = 2;
inline bool Signatures_Signature::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Signatures_Signature::clear_data() {
  data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Signatures_Signature::data() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Signatures.Signature.data)
  return data_.GetNoArena();
}
inline void Signatures_Signature::set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.Signatures.Signature.data)
}
inline void Signatures_Signature::set_data(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.Signatures.Signature.data)
}
inline void Signatures_Signature::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.Signatures.Signature.data)
}
inline void Signatures_Signature::set_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.Signatures.Signature.data)
}
inline std::string* Signatures_Signature::mutable_data() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.Signatures.Signature.data)
  return data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Signatures_Signature::release_data() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.Signatures.Signature.data)
  if (!has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Signatures_Signature::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.Signatures.Signature.data)
}

// optional fixed32 unpadded_signature_size = 3;
inline bool Signatures_Signature::has_unpadded_signature_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Signatures_Signature::clear_unpadded_signature_size() {
  unpadded_signature_size_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Signatures_Signature::unpadded_signature_size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Signatures.Signature.unpadded_signature_size)
  return unpadded_signature_size_;
}
inline void Signatures_Signature::set_unpadded_signature_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  unpadded_signature_size_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.Signatures.Signature.unpadded_signature_size)
}

// -------------------------------------------------------------------

// Signatures

// repeated .chromeos_update_engine.Signatures.Signature signatures = 1;
inline int Signatures::signatures_size() const {
  return signatures_.size();
}
inline void Signatures::clear_signatures() {
  signatures_.Clear();
}
inline ::chromeos_update_engine::Signatures_Signature* Signatures::mutable_signatures(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.Signatures.signatures)
  return signatures_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >*
Signatures::mutable_signatures() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.Signatures.signatures)
  return &signatures_;
}
inline const ::chromeos_update_engine::Signatures_Signature& Signatures::signatures(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Signatures.signatures)
  return signatures_.Get(index);
}
inline ::chromeos_update_engine::Signatures_Signature* Signatures::add_signatures() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.Signatures.signatures)
  return signatures_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >&
Signatures::signatures() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.Signatures.signatures)
  return signatures_;
}

// -------------------------------------------------------------------

// PartitionInfo

// optional uint64 size = 1;
inline bool PartitionInfo::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PartitionInfo::clear_size() {
  size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PartitionInfo::size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionInfo.size)
  return size_;
}
inline void PartitionInfo::set_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  size_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionInfo.size)
}

// optional bytes hash = 2;
inline bool PartitionInfo::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PartitionInfo::clear_hash() {
  hash_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PartitionInfo::hash() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionInfo.hash)
  return hash_.GetNoArena();
}
inline void PartitionInfo::set_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionInfo.hash)
}
inline void PartitionInfo::set_hash(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  hash_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.PartitionInfo.hash)
}
inline void PartitionInfo::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.PartitionInfo.hash)
}
inline void PartitionInfo::set_hash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.PartitionInfo.hash)
}
inline std::string* PartitionInfo::mutable_hash() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionInfo.hash)
  return hash_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PartitionInfo::release_hash() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionInfo.hash)
  if (!has_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return hash_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionInfo::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hash_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionInfo.hash)
}

// -------------------------------------------------------------------

// ImageInfo

// optional string board = 1 [deprecated = true];
inline bool ImageInfo::has_board() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageInfo::clear_board() {
  board_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ImageInfo::board() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ImageInfo.board)
  return board_.GetNoArena();
}
inline void ImageInfo::set_board(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  board_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ImageInfo.board)
}
inline void ImageInfo::set_board(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  board_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.ImageInfo.board)
}
inline void ImageInfo::set_board(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  board_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.ImageInfo.board)
}
inline void ImageInfo::set_board(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  board_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.ImageInfo.board)
}
inline std::string* ImageInfo::mutable_board() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.ImageInfo.board)
  return board_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ImageInfo::release_board() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.ImageInfo.board)
  if (!has_board()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return board_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ImageInfo::set_allocated_board(std::string* board) {
  if (board != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  board_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), board);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.ImageInfo.board)
}

// optional string key = 2 [deprecated = true];
inline bool ImageInfo::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageInfo::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ImageInfo::key() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ImageInfo.key)
  return key_.GetNoArena();
}
inline void ImageInfo::set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ImageInfo.key)
}
inline void ImageInfo::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.ImageInfo.key)
}
inline void ImageInfo::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.ImageInfo.key)
}
inline void ImageInfo::set_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.ImageInfo.key)
}
inline std::string* ImageInfo::mutable_key() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.ImageInfo.key)
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ImageInfo::release_key() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.ImageInfo.key)
  if (!has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ImageInfo::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.ImageInfo.key)
}

// optional string channel = 3 [deprecated = true];
inline bool ImageInfo::has_channel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageInfo::clear_channel() {
  channel_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ImageInfo::channel() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ImageInfo.channel)
  return channel_.GetNoArena();
}
inline void ImageInfo::set_channel(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  channel_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ImageInfo.channel)
}
inline void ImageInfo::set_channel(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  channel_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.ImageInfo.channel)
}
inline void ImageInfo::set_channel(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  channel_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.ImageInfo.channel)
}
inline void ImageInfo::set_channel(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  channel_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.ImageInfo.channel)
}
inline std::string* ImageInfo::mutable_channel() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.ImageInfo.channel)
  return channel_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ImageInfo::release_channel() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.ImageInfo.channel)
  if (!has_channel()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return channel_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ImageInfo::set_allocated_channel(std::string* channel) {
  if (channel != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  channel_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), channel);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.ImageInfo.channel)
}

// optional string version = 4 [deprecated = true];
inline bool ImageInfo::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ImageInfo::version() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ImageInfo.version)
  return version_.GetNoArena();
}
inline void ImageInfo::set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ImageInfo.version)
}
inline void ImageInfo::set_version(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.ImageInfo.version)
}
inline void ImageInfo::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.ImageInfo.version)
}
inline void ImageInfo::set_version(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.ImageInfo.version)
}
inline std::string* ImageInfo::mutable_version() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.ImageInfo.version)
  return version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ImageInfo::release_version() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.ImageInfo.version)
  if (!has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ImageInfo::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.ImageInfo.version)
}

// optional string build_channel = 5 [deprecated = true];
inline bool ImageInfo::has_build_channel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImageInfo::clear_build_channel() {
  build_channel_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ImageInfo::build_channel() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ImageInfo.build_channel)
  return build_channel_.GetNoArena();
}
inline void ImageInfo::set_build_channel(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  build_channel_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ImageInfo.build_channel)
}
inline void ImageInfo::set_build_channel(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  build_channel_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.ImageInfo.build_channel)
}
inline void ImageInfo::set_build_channel(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  build_channel_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.ImageInfo.build_channel)
}
inline void ImageInfo::set_build_channel(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  build_channel_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.ImageInfo.build_channel)
}
inline std::string* ImageInfo::mutable_build_channel() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.ImageInfo.build_channel)
  return build_channel_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ImageInfo::release_build_channel() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.ImageInfo.build_channel)
  if (!has_build_channel()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return build_channel_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ImageInfo::set_allocated_build_channel(std::string* build_channel) {
  if (build_channel != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  build_channel_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), build_channel);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.ImageInfo.build_channel)
}

// optional string build_version = 6 [deprecated = true];
inline bool ImageInfo::has_build_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ImageInfo::clear_build_version() {
  build_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ImageInfo::build_version() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ImageInfo.build_version)
  return build_version_.GetNoArena();
}
inline void ImageInfo::set_build_version(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  build_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ImageInfo.build_version)
}
inline void ImageInfo::set_build_version(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  build_version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.ImageInfo.build_version)
}
inline void ImageInfo::set_build_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  build_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.ImageInfo.build_version)
}
inline void ImageInfo::set_build_version(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000020u;
  build_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.ImageInfo.build_version)
}
inline std::string* ImageInfo::mutable_build_version() {
  _has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.ImageInfo.build_version)
  return build_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ImageInfo::release_build_version() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.ImageInfo.build_version)
  if (!has_build_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return build_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ImageInfo::set_allocated_build_version(std::string* build_version) {
  if (build_version != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  build_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), build_version);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.ImageInfo.build_version)
}

// -------------------------------------------------------------------

// InstallOperation

// required .chromeos_update_engine.InstallOperation.Type type = 1;
inline bool InstallOperation::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InstallOperation::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::chromeos_update_engine::InstallOperation_Type InstallOperation::type() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.type)
  return static_cast< ::chromeos_update_engine::InstallOperation_Type >(type_);
}
inline void InstallOperation::set_type(::chromeos_update_engine::InstallOperation_Type value) {
  assert(::chromeos_update_engine::InstallOperation_Type_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  type_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.type)
}

// optional uint64 data_offset = 2;
inline bool InstallOperation::has_data_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstallOperation::clear_data_offset() {
  data_offset_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 InstallOperation::data_offset() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.data_offset)
  return data_offset_;
}
inline void InstallOperation::set_data_offset(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  data_offset_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.data_offset)
}

// optional uint64 data_length = 3;
inline bool InstallOperation::has_data_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InstallOperation::clear_data_length() {
  data_length_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 InstallOperation::data_length() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.data_length)
  return data_length_;
}
inline void InstallOperation::set_data_length(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  data_length_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.data_length)
}

// repeated .chromeos_update_engine.Extent src_extents = 4;
inline int InstallOperation::src_extents_size() const {
  return src_extents_.size();
}
inline void InstallOperation::clear_src_extents() {
  src_extents_.Clear();
}
inline ::chromeos_update_engine::Extent* InstallOperation::mutable_src_extents(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.InstallOperation.src_extents)
  return src_extents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Extent >*
InstallOperation::mutable_src_extents() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.InstallOperation.src_extents)
  return &src_extents_;
}
inline const ::chromeos_update_engine::Extent& InstallOperation::src_extents(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.src_extents)
  return src_extents_.Get(index);
}
inline ::chromeos_update_engine::Extent* InstallOperation::add_src_extents() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.InstallOperation.src_extents)
  return src_extents_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Extent >&
InstallOperation::src_extents() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.InstallOperation.src_extents)
  return src_extents_;
}

// optional uint64 src_length = 5;
inline bool InstallOperation::has_src_length() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InstallOperation::clear_src_length() {
  src_length_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 InstallOperation::src_length() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.src_length)
  return src_length_;
}
inline void InstallOperation::set_src_length(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  src_length_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.src_length)
}

// repeated .chromeos_update_engine.Extent dst_extents = 6;
inline int InstallOperation::dst_extents_size() const {
  return dst_extents_.size();
}
inline void InstallOperation::clear_dst_extents() {
  dst_extents_.Clear();
}
inline ::chromeos_update_engine::Extent* InstallOperation::mutable_dst_extents(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.InstallOperation.dst_extents)
  return dst_extents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Extent >*
InstallOperation::mutable_dst_extents() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.InstallOperation.dst_extents)
  return &dst_extents_;
}
inline const ::chromeos_update_engine::Extent& InstallOperation::dst_extents(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.dst_extents)
  return dst_extents_.Get(index);
}
inline ::chromeos_update_engine::Extent* InstallOperation::add_dst_extents() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.InstallOperation.dst_extents)
  return dst_extents_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Extent >&
InstallOperation::dst_extents() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.InstallOperation.dst_extents)
  return dst_extents_;
}

// optional uint64 dst_length = 7;
inline bool InstallOperation::has_dst_length() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InstallOperation::clear_dst_length() {
  dst_length_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 InstallOperation::dst_length() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.dst_length)
  return dst_length_;
}
inline void InstallOperation::set_dst_length(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  dst_length_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.dst_length)
}

// optional bytes data_sha256_hash = 8;
inline bool InstallOperation::has_data_sha256_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstallOperation::clear_data_sha256_hash() {
  data_sha256_hash_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InstallOperation::data_sha256_hash() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.data_sha256_hash)
  return data_sha256_hash_.GetNoArena();
}
inline void InstallOperation::set_data_sha256_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_sha256_hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.data_sha256_hash)
}
inline void InstallOperation::set_data_sha256_hash(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  data_sha256_hash_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.InstallOperation.data_sha256_hash)
}
inline void InstallOperation::set_data_sha256_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  data_sha256_hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.InstallOperation.data_sha256_hash)
}
inline void InstallOperation::set_data_sha256_hash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  data_sha256_hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.InstallOperation.data_sha256_hash)
}
inline std::string* InstallOperation::mutable_data_sha256_hash() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.InstallOperation.data_sha256_hash)
  return data_sha256_hash_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InstallOperation::release_data_sha256_hash() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.InstallOperation.data_sha256_hash)
  if (!has_data_sha256_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data_sha256_hash_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InstallOperation::set_allocated_data_sha256_hash(std::string* data_sha256_hash) {
  if (data_sha256_hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_sha256_hash_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data_sha256_hash);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.InstallOperation.data_sha256_hash)
}

// optional bytes src_sha256_hash = 9;
inline bool InstallOperation::has_src_sha256_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstallOperation::clear_src_sha256_hash() {
  src_sha256_hash_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InstallOperation::src_sha256_hash() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.src_sha256_hash)
  return src_sha256_hash_.GetNoArena();
}
inline void InstallOperation::set_src_sha256_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  src_sha256_hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.src_sha256_hash)
}
inline void InstallOperation::set_src_sha256_hash(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  src_sha256_hash_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.InstallOperation.src_sha256_hash)
}
inline void InstallOperation::set_src_sha256_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  src_sha256_hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.InstallOperation.src_sha256_hash)
}
inline void InstallOperation::set_src_sha256_hash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  src_sha256_hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.InstallOperation.src_sha256_hash)
}
inline std::string* InstallOperation::mutable_src_sha256_hash() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.InstallOperation.src_sha256_hash)
  return src_sha256_hash_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InstallOperation::release_src_sha256_hash() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.InstallOperation.src_sha256_hash)
  if (!has_src_sha256_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return src_sha256_hash_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InstallOperation::set_allocated_src_sha256_hash(std::string* src_sha256_hash) {
  if (src_sha256_hash != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  src_sha256_hash_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), src_sha256_hash);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.InstallOperation.src_sha256_hash)
}

// -------------------------------------------------------------------

// CowMergeOperation

// optional .chromeos_update_engine.CowMergeOperation.Type type = 1;
inline bool CowMergeOperation::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CowMergeOperation::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::chromeos_update_engine::CowMergeOperation_Type CowMergeOperation::type() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.CowMergeOperation.type)
  return static_cast< ::chromeos_update_engine::CowMergeOperation_Type >(type_);
}
inline void CowMergeOperation::set_type(::chromeos_update_engine::CowMergeOperation_Type value) {
  assert(::chromeos_update_engine::CowMergeOperation_Type_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.CowMergeOperation.type)
}

// optional .chromeos_update_engine.Extent src_extent = 2;
inline bool CowMergeOperation::has_src_extent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CowMergeOperation::clear_src_extent() {
  if (src_extent_ != nullptr) src_extent_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::chromeos_update_engine::Extent& CowMergeOperation::src_extent() const {
  const ::chromeos_update_engine::Extent* p = src_extent_;
  // @@protoc_insertion_point(field_get:chromeos_update_engine.CowMergeOperation.src_extent)
  return p != nullptr ? *p : *reinterpret_cast<const ::chromeos_update_engine::Extent*>(
      &::chromeos_update_engine::_Extent_default_instance_);
}
inline ::chromeos_update_engine::Extent* CowMergeOperation::release_src_extent() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.CowMergeOperation.src_extent)
  _has_bits_[0] &= ~0x00000001u;
  ::chromeos_update_engine::Extent* temp = src_extent_;
  src_extent_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::Extent* CowMergeOperation::mutable_src_extent() {
  _has_bits_[0] |= 0x00000001u;
  if (src_extent_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::Extent>(GetArenaNoVirtual());
    src_extent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.CowMergeOperation.src_extent)
  return src_extent_;
}
inline void CowMergeOperation::set_allocated_src_extent(::chromeos_update_engine::Extent* src_extent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete src_extent_;
  }
  if (src_extent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      src_extent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src_extent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  src_extent_ = src_extent;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.CowMergeOperation.src_extent)
}

// optional .chromeos_update_engine.Extent dst_extent = 3;
inline bool CowMergeOperation::has_dst_extent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CowMergeOperation::clear_dst_extent() {
  if (dst_extent_ != nullptr) dst_extent_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::chromeos_update_engine::Extent& CowMergeOperation::dst_extent() const {
  const ::chromeos_update_engine::Extent* p = dst_extent_;
  // @@protoc_insertion_point(field_get:chromeos_update_engine.CowMergeOperation.dst_extent)
  return p != nullptr ? *p : *reinterpret_cast<const ::chromeos_update_engine::Extent*>(
      &::chromeos_update_engine::_Extent_default_instance_);
}
inline ::chromeos_update_engine::Extent* CowMergeOperation::release_dst_extent() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.CowMergeOperation.dst_extent)
  _has_bits_[0] &= ~0x00000002u;
  ::chromeos_update_engine::Extent* temp = dst_extent_;
  dst_extent_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::Extent* CowMergeOperation::mutable_dst_extent() {
  _has_bits_[0] |= 0x00000002u;
  if (dst_extent_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::Extent>(GetArenaNoVirtual());
    dst_extent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.CowMergeOperation.dst_extent)
  return dst_extent_;
}
inline void CowMergeOperation::set_allocated_dst_extent(::chromeos_update_engine::Extent* dst_extent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dst_extent_;
  }
  if (dst_extent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dst_extent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dst_extent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  dst_extent_ = dst_extent;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.CowMergeOperation.dst_extent)
}

// -------------------------------------------------------------------

// PartitionUpdate

// required string partition_name = 1;
inline bool PartitionUpdate::has_partition_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PartitionUpdate::clear_partition_name() {
  partition_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PartitionUpdate::partition_name() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.partition_name)
  return partition_name_.GetNoArena();
}
inline void PartitionUpdate::set_partition_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  partition_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.partition_name)
}
inline void PartitionUpdate::set_partition_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  partition_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.PartitionUpdate.partition_name)
}
inline void PartitionUpdate::set_partition_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  partition_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.PartitionUpdate.partition_name)
}
inline void PartitionUpdate::set_partition_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  partition_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.PartitionUpdate.partition_name)
}
inline std::string* PartitionUpdate::mutable_partition_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.partition_name)
  return partition_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PartitionUpdate::release_partition_name() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.partition_name)
  if (!has_partition_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return partition_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionUpdate::set_allocated_partition_name(std::string* partition_name) {
  if (partition_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  partition_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), partition_name);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.partition_name)
}

// optional bool run_postinstall = 2;
inline bool PartitionUpdate::has_run_postinstall() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PartitionUpdate::clear_run_postinstall() {
  run_postinstall_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool PartitionUpdate::run_postinstall() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.run_postinstall)
  return run_postinstall_;
}
inline void PartitionUpdate::set_run_postinstall(bool value) {
  _has_bits_[0] |= 0x00002000u;
  run_postinstall_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.run_postinstall)
}

// optional string postinstall_path = 3;
inline bool PartitionUpdate::has_postinstall_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PartitionUpdate::clear_postinstall_path() {
  postinstall_path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PartitionUpdate::postinstall_path() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.postinstall_path)
  return postinstall_path_.GetNoArena();
}
inline void PartitionUpdate::set_postinstall_path(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  postinstall_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.postinstall_path)
}
inline void PartitionUpdate::set_postinstall_path(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  postinstall_path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.PartitionUpdate.postinstall_path)
}
inline void PartitionUpdate::set_postinstall_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  postinstall_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.PartitionUpdate.postinstall_path)
}
inline void PartitionUpdate::set_postinstall_path(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  postinstall_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.PartitionUpdate.postinstall_path)
}
inline std::string* PartitionUpdate::mutable_postinstall_path() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.postinstall_path)
  return postinstall_path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PartitionUpdate::release_postinstall_path() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.postinstall_path)
  if (!has_postinstall_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return postinstall_path_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionUpdate::set_allocated_postinstall_path(std::string* postinstall_path) {
  if (postinstall_path != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  postinstall_path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), postinstall_path);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.postinstall_path)
}

// optional string filesystem_type = 4;
inline bool PartitionUpdate::has_filesystem_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PartitionUpdate::clear_filesystem_type() {
  filesystem_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PartitionUpdate::filesystem_type() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.filesystem_type)
  return filesystem_type_.GetNoArena();
}
inline void PartitionUpdate::set_filesystem_type(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  filesystem_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.filesystem_type)
}
inline void PartitionUpdate::set_filesystem_type(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  filesystem_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.PartitionUpdate.filesystem_type)
}
inline void PartitionUpdate::set_filesystem_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  filesystem_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.PartitionUpdate.filesystem_type)
}
inline void PartitionUpdate::set_filesystem_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  filesystem_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.PartitionUpdate.filesystem_type)
}
inline std::string* PartitionUpdate::mutable_filesystem_type() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.filesystem_type)
  return filesystem_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PartitionUpdate::release_filesystem_type() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.filesystem_type)
  if (!has_filesystem_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return filesystem_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionUpdate::set_allocated_filesystem_type(std::string* filesystem_type) {
  if (filesystem_type != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  filesystem_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filesystem_type);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.filesystem_type)
}

// repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;
inline int PartitionUpdate::new_partition_signature_size() const {
  return new_partition_signature_.size();
}
inline void PartitionUpdate::clear_new_partition_signature() {
  new_partition_signature_.Clear();
}
inline ::chromeos_update_engine::Signatures_Signature* PartitionUpdate::mutable_new_partition_signature(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.new_partition_signature)
  return new_partition_signature_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >*
PartitionUpdate::mutable_new_partition_signature() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.PartitionUpdate.new_partition_signature)
  return &new_partition_signature_;
}
inline const ::chromeos_update_engine::Signatures_Signature& PartitionUpdate::new_partition_signature(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.new_partition_signature)
  return new_partition_signature_.Get(index);
}
inline ::chromeos_update_engine::Signatures_Signature* PartitionUpdate::add_new_partition_signature() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.PartitionUpdate.new_partition_signature)
  return new_partition_signature_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >&
PartitionUpdate::new_partition_signature() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.PartitionUpdate.new_partition_signature)
  return new_partition_signature_;
}

// optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;
inline bool PartitionUpdate::has_old_partition_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PartitionUpdate::clear_old_partition_info() {
  if (old_partition_info_ != nullptr) old_partition_info_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::chromeos_update_engine::PartitionInfo& PartitionUpdate::old_partition_info() const {
  const ::chromeos_update_engine::PartitionInfo* p = old_partition_info_;
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.old_partition_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::chromeos_update_engine::PartitionInfo*>(
      &::chromeos_update_engine::_PartitionInfo_default_instance_);
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::release_old_partition_info() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.old_partition_info)
  _has_bits_[0] &= ~0x00000040u;
  ::chromeos_update_engine::PartitionInfo* temp = old_partition_info_;
  old_partition_info_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::mutable_old_partition_info() {
  _has_bits_[0] |= 0x00000040u;
  if (old_partition_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::PartitionInfo>(GetArenaNoVirtual());
    old_partition_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.old_partition_info)
  return old_partition_info_;
}
inline void PartitionUpdate::set_allocated_old_partition_info(::chromeos_update_engine::PartitionInfo* old_partition_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete old_partition_info_;
  }
  if (old_partition_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      old_partition_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old_partition_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  old_partition_info_ = old_partition_info;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.old_partition_info)
}

// optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;
inline bool PartitionUpdate::has_new_partition_info() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PartitionUpdate::clear_new_partition_info() {
  if (new_partition_info_ != nullptr) new_partition_info_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::chromeos_update_engine::PartitionInfo& PartitionUpdate::new_partition_info() const {
  const ::chromeos_update_engine::PartitionInfo* p = new_partition_info_;
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.new_partition_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::chromeos_update_engine::PartitionInfo*>(
      &::chromeos_update_engine::_PartitionInfo_default_instance_);
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::release_new_partition_info() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.new_partition_info)
  _has_bits_[0] &= ~0x00000080u;
  ::chromeos_update_engine::PartitionInfo* temp = new_partition_info_;
  new_partition_info_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::mutable_new_partition_info() {
  _has_bits_[0] |= 0x00000080u;
  if (new_partition_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::PartitionInfo>(GetArenaNoVirtual());
    new_partition_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.new_partition_info)
  return new_partition_info_;
}
inline void PartitionUpdate::set_allocated_new_partition_info(::chromeos_update_engine::PartitionInfo* new_partition_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete new_partition_info_;
  }
  if (new_partition_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      new_partition_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_partition_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  new_partition_info_ = new_partition_info;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.new_partition_info)
}

// repeated .chromeos_update_engine.InstallOperation operations = 8;
inline int PartitionUpdate::operations_size() const {
  return operations_.size();
}
inline void PartitionUpdate::clear_operations() {
  operations_.Clear();
}
inline ::chromeos_update_engine::InstallOperation* PartitionUpdate::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.operations)
  return operations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >*
PartitionUpdate::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.PartitionUpdate.operations)
  return &operations_;
}
inline const ::chromeos_update_engine::InstallOperation& PartitionUpdate::operations(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.operations)
  return operations_.Get(index);
}
inline ::chromeos_update_engine::InstallOperation* PartitionUpdate::add_operations() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.PartitionUpdate.operations)
  return operations_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >&
PartitionUpdate::operations() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.PartitionUpdate.operations)
  return operations_;
}

// optional bool postinstall_optional = 9;
inline bool PartitionUpdate::has_postinstall_optional() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PartitionUpdate::clear_postinstall_optional() {
  postinstall_optional_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool PartitionUpdate::postinstall_optional() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.postinstall_optional)
  return postinstall_optional_;
}
inline void PartitionUpdate::set_postinstall_optional(bool value) {
  _has_bits_[0] |= 0x00004000u;
  postinstall_optional_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.postinstall_optional)
}

// optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;
inline bool PartitionUpdate::has_hash_tree_data_extent() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PartitionUpdate::clear_hash_tree_data_extent() {
  if (hash_tree_data_extent_ != nullptr) hash_tree_data_extent_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::chromeos_update_engine::Extent& PartitionUpdate::hash_tree_data_extent() const {
  const ::chromeos_update_engine::Extent* p = hash_tree_data_extent_;
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.hash_tree_data_extent)
  return p != nullptr ? *p : *reinterpret_cast<const ::chromeos_update_engine::Extent*>(
      &::chromeos_update_engine::_Extent_default_instance_);
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::release_hash_tree_data_extent() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.hash_tree_data_extent)
  _has_bits_[0] &= ~0x00000100u;
  ::chromeos_update_engine::Extent* temp = hash_tree_data_extent_;
  hash_tree_data_extent_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::mutable_hash_tree_data_extent() {
  _has_bits_[0] |= 0x00000100u;
  if (hash_tree_data_extent_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::Extent>(GetArenaNoVirtual());
    hash_tree_data_extent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.hash_tree_data_extent)
  return hash_tree_data_extent_;
}
inline void PartitionUpdate::set_allocated_hash_tree_data_extent(::chromeos_update_engine::Extent* hash_tree_data_extent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete hash_tree_data_extent_;
  }
  if (hash_tree_data_extent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      hash_tree_data_extent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hash_tree_data_extent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  hash_tree_data_extent_ = hash_tree_data_extent;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.hash_tree_data_extent)
}

// optional .chromeos_update_engine.Extent hash_tree_extent = 11;
inline bool PartitionUpdate::has_hash_tree_extent() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PartitionUpdate::clear_hash_tree_extent() {
  if (hash_tree_extent_ != nullptr) hash_tree_extent_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::chromeos_update_engine::Extent& PartitionUpdate::hash_tree_extent() const {
  const ::chromeos_update_engine::Extent* p = hash_tree_extent_;
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.hash_tree_extent)
  return p != nullptr ? *p : *reinterpret_cast<const ::chromeos_update_engine::Extent*>(
      &::chromeos_update_engine::_Extent_default_instance_);
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::release_hash_tree_extent() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.hash_tree_extent)
  _has_bits_[0] &= ~0x00000200u;
  ::chromeos_update_engine::Extent* temp = hash_tree_extent_;
  hash_tree_extent_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::mutable_hash_tree_extent() {
  _has_bits_[0] |= 0x00000200u;
  if (hash_tree_extent_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::Extent>(GetArenaNoVirtual());
    hash_tree_extent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.hash_tree_extent)
  return hash_tree_extent_;
}
inline void PartitionUpdate::set_allocated_hash_tree_extent(::chromeos_update_engine::Extent* hash_tree_extent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete hash_tree_extent_;
  }
  if (hash_tree_extent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      hash_tree_extent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hash_tree_extent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  hash_tree_extent_ = hash_tree_extent;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.hash_tree_extent)
}

// optional string hash_tree_algorithm = 12;
inline bool PartitionUpdate::has_hash_tree_algorithm() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PartitionUpdate::clear_hash_tree_algorithm() {
  hash_tree_algorithm_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PartitionUpdate::hash_tree_algorithm() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
  return hash_tree_algorithm_.GetNoArena();
}
inline void PartitionUpdate::set_hash_tree_algorithm(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  hash_tree_algorithm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
}
inline void PartitionUpdate::set_hash_tree_algorithm(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  hash_tree_algorithm_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
}
inline void PartitionUpdate::set_hash_tree_algorithm(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  hash_tree_algorithm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
}
inline void PartitionUpdate::set_hash_tree_algorithm(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  hash_tree_algorithm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
}
inline std::string* PartitionUpdate::mutable_hash_tree_algorithm() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
  return hash_tree_algorithm_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PartitionUpdate::release_hash_tree_algorithm() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
  if (!has_hash_tree_algorithm()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return hash_tree_algorithm_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionUpdate::set_allocated_hash_tree_algorithm(std::string* hash_tree_algorithm) {
  if (hash_tree_algorithm != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  hash_tree_algorithm_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash_tree_algorithm);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
}

// optional bytes hash_tree_salt = 13;
inline bool PartitionUpdate::has_hash_tree_salt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PartitionUpdate::clear_hash_tree_salt() {
  hash_tree_salt_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& PartitionUpdate::hash_tree_salt() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
  return hash_tree_salt_.GetNoArena();
}
inline void PartitionUpdate::set_hash_tree_salt(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  hash_tree_salt_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
}
inline void PartitionUpdate::set_hash_tree_salt(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  hash_tree_salt_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
}
inline void PartitionUpdate::set_hash_tree_salt(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  hash_tree_salt_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
}
inline void PartitionUpdate::set_hash_tree_salt(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  hash_tree_salt_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
}
inline std::string* PartitionUpdate::mutable_hash_tree_salt() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
  return hash_tree_salt_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PartitionUpdate::release_hash_tree_salt() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
  if (!has_hash_tree_salt()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return hash_tree_salt_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionUpdate::set_allocated_hash_tree_salt(std::string* hash_tree_salt) {
  if (hash_tree_salt != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  hash_tree_salt_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash_tree_salt);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
}

// optional .chromeos_update_engine.Extent fec_data_extent = 14;
inline bool PartitionUpdate::has_fec_data_extent() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PartitionUpdate::clear_fec_data_extent() {
  if (fec_data_extent_ != nullptr) fec_data_extent_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::chromeos_update_engine::Extent& PartitionUpdate::fec_data_extent() const {
  const ::chromeos_update_engine::Extent* p = fec_data_extent_;
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.fec_data_extent)
  return p != nullptr ? *p : *reinterpret_cast<const ::chromeos_update_engine::Extent*>(
      &::chromeos_update_engine::_Extent_default_instance_);
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::release_fec_data_extent() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.fec_data_extent)
  _has_bits_[0] &= ~0x00000400u;
  ::chromeos_update_engine::Extent* temp = fec_data_extent_;
  fec_data_extent_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::mutable_fec_data_extent() {
  _has_bits_[0] |= 0x00000400u;
  if (fec_data_extent_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::Extent>(GetArenaNoVirtual());
    fec_data_extent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.fec_data_extent)
  return fec_data_extent_;
}
inline void PartitionUpdate::set_allocated_fec_data_extent(::chromeos_update_engine::Extent* fec_data_extent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete fec_data_extent_;
  }
  if (fec_data_extent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fec_data_extent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fec_data_extent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  fec_data_extent_ = fec_data_extent;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.fec_data_extent)
}

// optional .chromeos_update_engine.Extent fec_extent = 15;
inline bool PartitionUpdate::has_fec_extent() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PartitionUpdate::clear_fec_extent() {
  if (fec_extent_ != nullptr) fec_extent_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::chromeos_update_engine::Extent& PartitionUpdate::fec_extent() const {
  const ::chromeos_update_engine::Extent* p = fec_extent_;
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.fec_extent)
  return p != nullptr ? *p : *reinterpret_cast<const ::chromeos_update_engine::Extent*>(
      &::chromeos_update_engine::_Extent_default_instance_);
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::release_fec_extent() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.fec_extent)
  _has_bits_[0] &= ~0x00000800u;
  ::chromeos_update_engine::Extent* temp = fec_extent_;
  fec_extent_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::mutable_fec_extent() {
  _has_bits_[0] |= 0x00000800u;
  if (fec_extent_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::Extent>(GetArenaNoVirtual());
    fec_extent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.fec_extent)
  return fec_extent_;
}
inline void PartitionUpdate::set_allocated_fec_extent(::chromeos_update_engine::Extent* fec_extent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete fec_extent_;
  }
  if (fec_extent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fec_extent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fec_extent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  fec_extent_ = fec_extent;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.fec_extent)
}

// optional uint32 fec_roots = 16 [default = 2];
inline bool PartitionUpdate::has_fec_roots() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PartitionUpdate::clear_fec_roots() {
  fec_roots_ = 2u;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PartitionUpdate::fec_roots() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.fec_roots)
  return fec_roots_;
}
inline void PartitionUpdate::set_fec_roots(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00008000u;
  fec_roots_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.fec_roots)
}

// optional string version = 17;
inline bool PartitionUpdate::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PartitionUpdate::clear_version() {
  version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& PartitionUpdate::version() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.version)
  return version_.GetNoArena();
}
inline void PartitionUpdate::set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.version)
}
inline void PartitionUpdate::set_version(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.PartitionUpdate.version)
}
inline void PartitionUpdate::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.PartitionUpdate.version)
}
inline void PartitionUpdate::set_version(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000020u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.PartitionUpdate.version)
}
inline std::string* PartitionUpdate::mutable_version() {
  _has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.version)
  return version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PartitionUpdate::release_version() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.version)
  if (!has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionUpdate::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.version)
}

// repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;
inline int PartitionUpdate::merge_operations_size() const {
  return merge_operations_.size();
}
inline void PartitionUpdate::clear_merge_operations() {
  merge_operations_.Clear();
}
inline ::chromeos_update_engine::CowMergeOperation* PartitionUpdate::mutable_merge_operations(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.merge_operations)
  return merge_operations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::CowMergeOperation >*
PartitionUpdate::mutable_merge_operations() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.PartitionUpdate.merge_operations)
  return &merge_operations_;
}
inline const ::chromeos_update_engine::CowMergeOperation& PartitionUpdate::merge_operations(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.merge_operations)
  return merge_operations_.Get(index);
}
inline ::chromeos_update_engine::CowMergeOperation* PartitionUpdate::add_merge_operations() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.PartitionUpdate.merge_operations)
  return merge_operations_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::CowMergeOperation >&
PartitionUpdate::merge_operations() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.PartitionUpdate.merge_operations)
  return merge_operations_;
}

// optional uint64 estimate_cow_size = 19;
inline bool PartitionUpdate::has_estimate_cow_size() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PartitionUpdate::clear_estimate_cow_size() {
  estimate_cow_size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PartitionUpdate::estimate_cow_size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.estimate_cow_size)
  return estimate_cow_size_;
}
inline void PartitionUpdate::set_estimate_cow_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00001000u;
  estimate_cow_size_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.estimate_cow_size)
}

// -------------------------------------------------------------------

// DynamicPartitionGroup

// required string name = 1;
inline bool DynamicPartitionGroup::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DynamicPartitionGroup::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DynamicPartitionGroup::name() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionGroup.name)
  return name_.GetNoArena();
}
inline void DynamicPartitionGroup::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionGroup.name)
}
inline void DynamicPartitionGroup::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.DynamicPartitionGroup.name)
}
inline void DynamicPartitionGroup::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.DynamicPartitionGroup.name)
}
inline void DynamicPartitionGroup::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.DynamicPartitionGroup.name)
}
inline std::string* DynamicPartitionGroup::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DynamicPartitionGroup.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DynamicPartitionGroup::release_name() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DynamicPartitionGroup.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DynamicPartitionGroup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DynamicPartitionGroup.name)
}

// optional uint64 size = 2;
inline bool DynamicPartitionGroup::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DynamicPartitionGroup::clear_size() {
  size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DynamicPartitionGroup::size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionGroup.size)
  return size_;
}
inline void DynamicPartitionGroup::set_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  size_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionGroup.size)
}

// repeated string partition_names = 3;
inline int DynamicPartitionGroup::partition_names_size() const {
  return partition_names_.size();
}
inline void DynamicPartitionGroup::clear_partition_names() {
  partition_names_.Clear();
}
inline const std::string& DynamicPartitionGroup::partition_names(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionGroup.partition_names)
  return partition_names_.Get(index);
}
inline std::string* DynamicPartitionGroup::mutable_partition_names(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DynamicPartitionGroup.partition_names)
  return partition_names_.Mutable(index);
}
inline void DynamicPartitionGroup::set_partition_names(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionGroup.partition_names)
  partition_names_.Mutable(index)->assign(value);
}
inline void DynamicPartitionGroup::set_partition_names(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionGroup.partition_names)
  partition_names_.Mutable(index)->assign(std::move(value));
}
inline void DynamicPartitionGroup::set_partition_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  partition_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.DynamicPartitionGroup.partition_names)
}
inline void DynamicPartitionGroup::set_partition_names(int index, const char* value, size_t size) {
  partition_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.DynamicPartitionGroup.partition_names)
}
inline std::string* DynamicPartitionGroup::add_partition_names() {
  // @@protoc_insertion_point(field_add_mutable:chromeos_update_engine.DynamicPartitionGroup.partition_names)
  return partition_names_.Add();
}
inline void DynamicPartitionGroup::add_partition_names(const std::string& value) {
  partition_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:chromeos_update_engine.DynamicPartitionGroup.partition_names)
}
inline void DynamicPartitionGroup::add_partition_names(std::string&& value) {
  partition_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:chromeos_update_engine.DynamicPartitionGroup.partition_names)
}
inline void DynamicPartitionGroup::add_partition_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  partition_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:chromeos_update_engine.DynamicPartitionGroup.partition_names)
}
inline void DynamicPartitionGroup::add_partition_names(const char* value, size_t size) {
  partition_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:chromeos_update_engine.DynamicPartitionGroup.partition_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DynamicPartitionGroup::partition_names() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.DynamicPartitionGroup.partition_names)
  return partition_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DynamicPartitionGroup::mutable_partition_names() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.DynamicPartitionGroup.partition_names)
  return &partition_names_;
}

// -------------------------------------------------------------------

// DynamicPartitionMetadata

// repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;
inline int DynamicPartitionMetadata::groups_size() const {
  return groups_.size();
}
inline void DynamicPartitionMetadata::clear_groups() {
  groups_.Clear();
}
inline ::chromeos_update_engine::DynamicPartitionGroup* DynamicPartitionMetadata::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DynamicPartitionMetadata.groups)
  return groups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::DynamicPartitionGroup >*
DynamicPartitionMetadata::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.DynamicPartitionMetadata.groups)
  return &groups_;
}
inline const ::chromeos_update_engine::DynamicPartitionGroup& DynamicPartitionMetadata::groups(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionMetadata.groups)
  return groups_.Get(index);
}
inline ::chromeos_update_engine::DynamicPartitionGroup* DynamicPartitionMetadata::add_groups() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.DynamicPartitionMetadata.groups)
  return groups_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::DynamicPartitionGroup >&
DynamicPartitionMetadata::groups() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.DynamicPartitionMetadata.groups)
  return groups_;
}

// optional bool snapshot_enabled = 2;
inline bool DynamicPartitionMetadata::has_snapshot_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DynamicPartitionMetadata::clear_snapshot_enabled() {
  snapshot_enabled_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool DynamicPartitionMetadata::snapshot_enabled() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionMetadata.snapshot_enabled)
  return snapshot_enabled_;
}
inline void DynamicPartitionMetadata::set_snapshot_enabled(bool value) {
  _has_bits_[0] |= 0x00000002u;
  snapshot_enabled_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionMetadata.snapshot_enabled)
}

// optional bool vabc_enabled = 3;
inline bool DynamicPartitionMetadata::has_vabc_enabled() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DynamicPartitionMetadata::clear_vabc_enabled() {
  vabc_enabled_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool DynamicPartitionMetadata::vabc_enabled() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionMetadata.vabc_enabled)
  return vabc_enabled_;
}
inline void DynamicPartitionMetadata::set_vabc_enabled(bool value) {
  _has_bits_[0] |= 0x00000004u;
  vabc_enabled_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionMetadata.vabc_enabled)
}

// optional string vabc_compression_param = 4;
inline bool DynamicPartitionMetadata::has_vabc_compression_param() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DynamicPartitionMetadata::clear_vabc_compression_param() {
  vabc_compression_param_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DynamicPartitionMetadata::vabc_compression_param() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
  return vabc_compression_param_.GetNoArena();
}
inline void DynamicPartitionMetadata::set_vabc_compression_param(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  vabc_compression_param_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
}
inline void DynamicPartitionMetadata::set_vabc_compression_param(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  vabc_compression_param_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
}
inline void DynamicPartitionMetadata::set_vabc_compression_param(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  vabc_compression_param_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
}
inline void DynamicPartitionMetadata::set_vabc_compression_param(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  vabc_compression_param_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
}
inline std::string* DynamicPartitionMetadata::mutable_vabc_compression_param() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
  return vabc_compression_param_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DynamicPartitionMetadata::release_vabc_compression_param() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
  if (!has_vabc_compression_param()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return vabc_compression_param_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DynamicPartitionMetadata::set_allocated_vabc_compression_param(std::string* vabc_compression_param) {
  if (vabc_compression_param != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  vabc_compression_param_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vabc_compression_param);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
}

// optional uint32 cow_version = 5;
inline bool DynamicPartitionMetadata::has_cow_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DynamicPartitionMetadata::clear_cow_version() {
  cow_version_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DynamicPartitionMetadata::cow_version() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionMetadata.cow_version)
  return cow_version_;
}
inline void DynamicPartitionMetadata::set_cow_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  cow_version_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionMetadata.cow_version)
}

// -------------------------------------------------------------------

// ApexInfo

// optional string package_name = 1;
inline bool ApexInfo::has_package_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApexInfo::clear_package_name() {
  package_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ApexInfo::package_name() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ApexInfo.package_name)
  return package_name_.GetNoArena();
}
inline void ApexInfo::set_package_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  package_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ApexInfo.package_name)
}
inline void ApexInfo::set_package_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  package_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.ApexInfo.package_name)
}
inline void ApexInfo::set_package_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  package_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.ApexInfo.package_name)
}
inline void ApexInfo::set_package_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  package_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.ApexInfo.package_name)
}
inline std::string* ApexInfo::mutable_package_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.ApexInfo.package_name)
  return package_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ApexInfo::release_package_name() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.ApexInfo.package_name)
  if (!has_package_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return package_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ApexInfo::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  package_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), package_name);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.ApexInfo.package_name)
}

// optional int64 version = 2;
inline bool ApexInfo::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApexInfo::clear_version() {
  version_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ApexInfo::version() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ApexInfo.version)
  return version_;
}
inline void ApexInfo::set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  version_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ApexInfo.version)
}

// optional bool is_compressed = 3;
inline bool ApexInfo::has_is_compressed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ApexInfo::clear_is_compressed() {
  is_compressed_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ApexInfo::is_compressed() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ApexInfo.is_compressed)
  return is_compressed_;
}
inline void ApexInfo::set_is_compressed(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_compressed_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ApexInfo.is_compressed)
}

// optional int64 decompressed_size = 4;
inline bool ApexInfo::has_decompressed_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApexInfo::clear_decompressed_size() {
  decompressed_size_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ApexInfo::decompressed_size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ApexInfo.decompressed_size)
  return decompressed_size_;
}
inline void ApexInfo::set_decompressed_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  decompressed_size_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ApexInfo.decompressed_size)
}

// -------------------------------------------------------------------

// ApexMetadata

// repeated .chromeos_update_engine.ApexInfo apex_info = 1;
inline int ApexMetadata::apex_info_size() const {
  return apex_info_.size();
}
inline void ApexMetadata::clear_apex_info() {
  apex_info_.Clear();
}
inline ::chromeos_update_engine::ApexInfo* ApexMetadata::mutable_apex_info(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.ApexMetadata.apex_info)
  return apex_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::ApexInfo >*
ApexMetadata::mutable_apex_info() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.ApexMetadata.apex_info)
  return &apex_info_;
}
inline const ::chromeos_update_engine::ApexInfo& ApexMetadata::apex_info(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ApexMetadata.apex_info)
  return apex_info_.Get(index);
}
inline ::chromeos_update_engine::ApexInfo* ApexMetadata::add_apex_info() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.ApexMetadata.apex_info)
  return apex_info_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::ApexInfo >&
ApexMetadata::apex_info() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.ApexMetadata.apex_info)
  return apex_info_;
}

// -------------------------------------------------------------------

// DeltaArchiveManifest

// repeated .chromeos_update_engine.InstallOperation install_operations = 1 [deprecated = true];
inline int DeltaArchiveManifest::install_operations_size() const {
  return install_operations_.size();
}
inline void DeltaArchiveManifest::clear_install_operations() {
  install_operations_.Clear();
}
inline ::chromeos_update_engine::InstallOperation* DeltaArchiveManifest::mutable_install_operations(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.install_operations)
  return install_operations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >*
DeltaArchiveManifest::mutable_install_operations() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.DeltaArchiveManifest.install_operations)
  return &install_operations_;
}
inline const ::chromeos_update_engine::InstallOperation& DeltaArchiveManifest::install_operations(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.install_operations)
  return install_operations_.Get(index);
}
inline ::chromeos_update_engine::InstallOperation* DeltaArchiveManifest::add_install_operations() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.DeltaArchiveManifest.install_operations)
  return install_operations_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >&
DeltaArchiveManifest::install_operations() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.DeltaArchiveManifest.install_operations)
  return install_operations_;
}

// repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2 [deprecated = true];
inline int DeltaArchiveManifest::kernel_install_operations_size() const {
  return kernel_install_operations_.size();
}
inline void DeltaArchiveManifest::clear_kernel_install_operations() {
  kernel_install_operations_.Clear();
}
inline ::chromeos_update_engine::InstallOperation* DeltaArchiveManifest::mutable_kernel_install_operations(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.kernel_install_operations)
  return kernel_install_operations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >*
DeltaArchiveManifest::mutable_kernel_install_operations() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.DeltaArchiveManifest.kernel_install_operations)
  return &kernel_install_operations_;
}
inline const ::chromeos_update_engine::InstallOperation& DeltaArchiveManifest::kernel_install_operations(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.kernel_install_operations)
  return kernel_install_operations_.Get(index);
}
inline ::chromeos_update_engine::InstallOperation* DeltaArchiveManifest::add_kernel_install_operations() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.DeltaArchiveManifest.kernel_install_operations)
  return kernel_install_operations_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >&
DeltaArchiveManifest::kernel_install_operations() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.DeltaArchiveManifest.kernel_install_operations)
  return kernel_install_operations_;
}

// optional uint32 block_size = 3 [default = 4096];
inline bool DeltaArchiveManifest::has_block_size() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DeltaArchiveManifest::clear_block_size() {
  block_size_ = 4096u;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeltaArchiveManifest::block_size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.block_size)
  return block_size_;
}
inline void DeltaArchiveManifest::set_block_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00001000u;
  block_size_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.block_size)
}

// optional uint64 signatures_offset = 4;
inline bool DeltaArchiveManifest::has_signatures_offset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DeltaArchiveManifest::clear_signatures_offset() {
  signatures_offset_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DeltaArchiveManifest::signatures_offset() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.signatures_offset)
  return signatures_offset_;
}
inline void DeltaArchiveManifest::set_signatures_offset(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000080u;
  signatures_offset_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.signatures_offset)
}

// optional uint64 signatures_size = 5;
inline bool DeltaArchiveManifest::has_signatures_size() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DeltaArchiveManifest::clear_signatures_size() {
  signatures_size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DeltaArchiveManifest::signatures_size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.signatures_size)
  return signatures_size_;
}
inline void DeltaArchiveManifest::set_signatures_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000100u;
  signatures_size_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.signatures_size)
}

// optional .chromeos_update_engine.PartitionInfo old_kernel_info = 6 [deprecated = true];
inline bool DeltaArchiveManifest::has_old_kernel_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeltaArchiveManifest::clear_old_kernel_info() {
  if (old_kernel_info_ != nullptr) old_kernel_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::chromeos_update_engine::PartitionInfo& DeltaArchiveManifest::old_kernel_info() const {
  const ::chromeos_update_engine::PartitionInfo* p = old_kernel_info_;
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.old_kernel_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::chromeos_update_engine::PartitionInfo*>(
      &::chromeos_update_engine::_PartitionInfo_default_instance_);
}
inline ::chromeos_update_engine::PartitionInfo* DeltaArchiveManifest::release_old_kernel_info() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DeltaArchiveManifest.old_kernel_info)
  _has_bits_[0] &= ~0x00000001u;
  ::chromeos_update_engine::PartitionInfo* temp = old_kernel_info_;
  old_kernel_info_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::PartitionInfo* DeltaArchiveManifest::mutable_old_kernel_info() {
  _has_bits_[0] |= 0x00000001u;
  if (old_kernel_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::PartitionInfo>(GetArenaNoVirtual());
    old_kernel_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.old_kernel_info)
  return old_kernel_info_;
}
inline void DeltaArchiveManifest::set_allocated_old_kernel_info(::chromeos_update_engine::PartitionInfo* old_kernel_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete old_kernel_info_;
  }
  if (old_kernel_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      old_kernel_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old_kernel_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  old_kernel_info_ = old_kernel_info;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DeltaArchiveManifest.old_kernel_info)
}

// optional .chromeos_update_engine.PartitionInfo new_kernel_info = 7 [deprecated = true];
inline bool DeltaArchiveManifest::has_new_kernel_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeltaArchiveManifest::clear_new_kernel_info() {
  if (new_kernel_info_ != nullptr) new_kernel_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::chromeos_update_engine::PartitionInfo& DeltaArchiveManifest::new_kernel_info() const {
  const ::chromeos_update_engine::PartitionInfo* p = new_kernel_info_;
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.new_kernel_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::chromeos_update_engine::PartitionInfo*>(
      &::chromeos_update_engine::_PartitionInfo_default_instance_);
}
inline ::chromeos_update_engine::PartitionInfo* DeltaArchiveManifest::release_new_kernel_info() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DeltaArchiveManifest.new_kernel_info)
  _has_bits_[0] &= ~0x00000002u;
  ::chromeos_update_engine::PartitionInfo* temp = new_kernel_info_;
  new_kernel_info_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::PartitionInfo* DeltaArchiveManifest::mutable_new_kernel_info() {
  _has_bits_[0] |= 0x00000002u;
  if (new_kernel_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::PartitionInfo>(GetArenaNoVirtual());
    new_kernel_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.new_kernel_info)
  return new_kernel_info_;
}
inline void DeltaArchiveManifest::set_allocated_new_kernel_info(::chromeos_update_engine::PartitionInfo* new_kernel_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete new_kernel_info_;
  }
  if (new_kernel_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      new_kernel_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_kernel_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  new_kernel_info_ = new_kernel_info;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DeltaArchiveManifest.new_kernel_info)
}

// optional .chromeos_update_engine.PartitionInfo old_rootfs_info = 8 [deprecated = true];
inline bool DeltaArchiveManifest::has_old_rootfs_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeltaArchiveManifest::clear_old_rootfs_info() {
  if (old_rootfs_info_ != nullptr) old_rootfs_info_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::chromeos_update_engine::PartitionInfo& DeltaArchiveManifest::old_rootfs_info() const {
  const ::chromeos_update_engine::PartitionInfo* p = old_rootfs_info_;
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.old_rootfs_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::chromeos_update_engine::PartitionInfo*>(
      &::chromeos_update_engine::_PartitionInfo_default_instance_);
}
inline ::chromeos_update_engine::PartitionInfo* DeltaArchiveManifest::release_old_rootfs_info() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DeltaArchiveManifest.old_rootfs_info)
  _has_bits_[0] &= ~0x00000004u;
  ::chromeos_update_engine::PartitionInfo* temp = old_rootfs_info_;
  old_rootfs_info_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::PartitionInfo* DeltaArchiveManifest::mutable_old_rootfs_info() {
  _has_bits_[0] |= 0x00000004u;
  if (old_rootfs_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::PartitionInfo>(GetArenaNoVirtual());
    old_rootfs_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.old_rootfs_info)
  return old_rootfs_info_;
}
inline void DeltaArchiveManifest::set_allocated_old_rootfs_info(::chromeos_update_engine::PartitionInfo* old_rootfs_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete old_rootfs_info_;
  }
  if (old_rootfs_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      old_rootfs_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old_rootfs_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  old_rootfs_info_ = old_rootfs_info;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DeltaArchiveManifest.old_rootfs_info)
}

// optional .chromeos_update_engine.PartitionInfo new_rootfs_info = 9 [deprecated = true];
inline bool DeltaArchiveManifest::has_new_rootfs_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeltaArchiveManifest::clear_new_rootfs_info() {
  if (new_rootfs_info_ != nullptr) new_rootfs_info_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::chromeos_update_engine::PartitionInfo& DeltaArchiveManifest::new_rootfs_info() const {
  const ::chromeos_update_engine::PartitionInfo* p = new_rootfs_info_;
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.new_rootfs_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::chromeos_update_engine::PartitionInfo*>(
      &::chromeos_update_engine::_PartitionInfo_default_instance_);
}
inline ::chromeos_update_engine::PartitionInfo* DeltaArchiveManifest::release_new_rootfs_info() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DeltaArchiveManifest.new_rootfs_info)
  _has_bits_[0] &= ~0x00000008u;
  ::chromeos_update_engine::PartitionInfo* temp = new_rootfs_info_;
  new_rootfs_info_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::PartitionInfo* DeltaArchiveManifest::mutable_new_rootfs_info() {
  _has_bits_[0] |= 0x00000008u;
  if (new_rootfs_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::PartitionInfo>(GetArenaNoVirtual());
    new_rootfs_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.new_rootfs_info)
  return new_rootfs_info_;
}
inline void DeltaArchiveManifest::set_allocated_new_rootfs_info(::chromeos_update_engine::PartitionInfo* new_rootfs_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete new_rootfs_info_;
  }
  if (new_rootfs_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      new_rootfs_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_rootfs_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  new_rootfs_info_ = new_rootfs_info;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DeltaArchiveManifest.new_rootfs_info)
}

// optional .chromeos_update_engine.ImageInfo old_image_info = 10 [deprecated = true];
inline bool DeltaArchiveManifest::has_old_image_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeltaArchiveManifest::clear_old_image_info() {
  if (old_image_info_ != nullptr) old_image_info_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::chromeos_update_engine::ImageInfo& DeltaArchiveManifest::old_image_info() const {
  const ::chromeos_update_engine::ImageInfo* p = old_image_info_;
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.old_image_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::chromeos_update_engine::ImageInfo*>(
      &::chromeos_update_engine::_ImageInfo_default_instance_);
}
inline ::chromeos_update_engine::ImageInfo* DeltaArchiveManifest::release_old_image_info() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DeltaArchiveManifest.old_image_info)
  _has_bits_[0] &= ~0x00000010u;
  ::chromeos_update_engine::ImageInfo* temp = old_image_info_;
  old_image_info_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::ImageInfo* DeltaArchiveManifest::mutable_old_image_info() {
  _has_bits_[0] |= 0x00000010u;
  if (old_image_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::ImageInfo>(GetArenaNoVirtual());
    old_image_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.old_image_info)
  return old_image_info_;
}
inline void DeltaArchiveManifest::set_allocated_old_image_info(::chromeos_update_engine::ImageInfo* old_image_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete old_image_info_;
  }
  if (old_image_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      old_image_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old_image_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  old_image_info_ = old_image_info;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DeltaArchiveManifest.old_image_info)
}

// optional .chromeos_update_engine.ImageInfo new_image_info = 11 [deprecated = true];
inline bool DeltaArchiveManifest::has_new_image_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeltaArchiveManifest::clear_new_image_info() {
  if (new_image_info_ != nullptr) new_image_info_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::chromeos_update_engine::ImageInfo& DeltaArchiveManifest::new_image_info() const {
  const ::chromeos_update_engine::ImageInfo* p = new_image_info_;
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.new_image_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::chromeos_update_engine::ImageInfo*>(
      &::chromeos_update_engine::_ImageInfo_default_instance_);
}
inline ::chromeos_update_engine::ImageInfo* DeltaArchiveManifest::release_new_image_info() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DeltaArchiveManifest.new_image_info)
  _has_bits_[0] &= ~0x00000020u;
  ::chromeos_update_engine::ImageInfo* temp = new_image_info_;
  new_image_info_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::ImageInfo* DeltaArchiveManifest::mutable_new_image_info() {
  _has_bits_[0] |= 0x00000020u;
  if (new_image_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::ImageInfo>(GetArenaNoVirtual());
    new_image_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.new_image_info)
  return new_image_info_;
}
inline void DeltaArchiveManifest::set_allocated_new_image_info(::chromeos_update_engine::ImageInfo* new_image_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete new_image_info_;
  }
  if (new_image_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      new_image_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_image_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  new_image_info_ = new_image_info;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DeltaArchiveManifest.new_image_info)
}

// optional uint32 minor_version = 12 [default = 0];
inline bool DeltaArchiveManifest::has_minor_version() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DeltaArchiveManifest::clear_minor_version() {
  minor_version_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeltaArchiveManifest::minor_version() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.minor_version)
  return minor_version_;
}
inline void DeltaArchiveManifest::set_minor_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000400u;
  minor_version_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.minor_version)
}

// repeated .chromeos_update_engine.PartitionUpdate partitions = 13;
inline int DeltaArchiveManifest::partitions_size() const {
  return partitions_.size();
}
inline void DeltaArchiveManifest::clear_partitions() {
  partitions_.Clear();
}
inline ::chromeos_update_engine::PartitionUpdate* DeltaArchiveManifest::mutable_partitions(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.partitions)
  return partitions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::PartitionUpdate >*
DeltaArchiveManifest::mutable_partitions() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.DeltaArchiveManifest.partitions)
  return &partitions_;
}
inline const ::chromeos_update_engine::PartitionUpdate& DeltaArchiveManifest::partitions(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.partitions)
  return partitions_.Get(index);
}
inline ::chromeos_update_engine::PartitionUpdate* DeltaArchiveManifest::add_partitions() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.DeltaArchiveManifest.partitions)
  return partitions_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::PartitionUpdate >&
DeltaArchiveManifest::partitions() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.DeltaArchiveManifest.partitions)
  return partitions_;
}

// optional int64 max_timestamp = 14;
inline bool DeltaArchiveManifest::has_max_timestamp() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DeltaArchiveManifest::clear_max_timestamp() {
  max_timestamp_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DeltaArchiveManifest::max_timestamp() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.max_timestamp)
  return max_timestamp_;
}
inline void DeltaArchiveManifest::set_max_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000200u;
  max_timestamp_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.max_timestamp)
}

// optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;
inline bool DeltaArchiveManifest::has_dynamic_partition_metadata() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DeltaArchiveManifest::clear_dynamic_partition_metadata() {
  if (dynamic_partition_metadata_ != nullptr) dynamic_partition_metadata_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::chromeos_update_engine::DynamicPartitionMetadata& DeltaArchiveManifest::dynamic_partition_metadata() const {
  const ::chromeos_update_engine::DynamicPartitionMetadata* p = dynamic_partition_metadata_;
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.dynamic_partition_metadata)
  return p != nullptr ? *p : *reinterpret_cast<const ::chromeos_update_engine::DynamicPartitionMetadata*>(
      &::chromeos_update_engine::_DynamicPartitionMetadata_default_instance_);
}
inline ::chromeos_update_engine::DynamicPartitionMetadata* DeltaArchiveManifest::release_dynamic_partition_metadata() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DeltaArchiveManifest.dynamic_partition_metadata)
  _has_bits_[0] &= ~0x00000040u;
  ::chromeos_update_engine::DynamicPartitionMetadata* temp = dynamic_partition_metadata_;
  dynamic_partition_metadata_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::DynamicPartitionMetadata* DeltaArchiveManifest::mutable_dynamic_partition_metadata() {
  _has_bits_[0] |= 0x00000040u;
  if (dynamic_partition_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::DynamicPartitionMetadata>(GetArenaNoVirtual());
    dynamic_partition_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.dynamic_partition_metadata)
  return dynamic_partition_metadata_;
}
inline void DeltaArchiveManifest::set_allocated_dynamic_partition_metadata(::chromeos_update_engine::DynamicPartitionMetadata* dynamic_partition_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dynamic_partition_metadata_;
  }
  if (dynamic_partition_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dynamic_partition_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dynamic_partition_metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  dynamic_partition_metadata_ = dynamic_partition_metadata;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DeltaArchiveManifest.dynamic_partition_metadata)
}

// optional bool partial_update = 16;
inline bool DeltaArchiveManifest::has_partial_update() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DeltaArchiveManifest::clear_partial_update() {
  partial_update_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool DeltaArchiveManifest::partial_update() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.partial_update)
  return partial_update_;
}
inline void DeltaArchiveManifest::set_partial_update(bool value) {
  _has_bits_[0] |= 0x00000800u;
  partial_update_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.partial_update)
}

// repeated .chromeos_update_engine.ApexInfo apex_info = 17;
inline int DeltaArchiveManifest::apex_info_size() const {
  return apex_info_.size();
}
inline void DeltaArchiveManifest::clear_apex_info() {
  apex_info_.Clear();
}
inline ::chromeos_update_engine::ApexInfo* DeltaArchiveManifest::mutable_apex_info(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.apex_info)
  return apex_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::ApexInfo >*
DeltaArchiveManifest::mutable_apex_info() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.DeltaArchiveManifest.apex_info)
  return &apex_info_;
}
inline const ::chromeos_update_engine::ApexInfo& DeltaArchiveManifest::apex_info(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.apex_info)
  return apex_info_.Get(index);
}
inline ::chromeos_update_engine::ApexInfo* DeltaArchiveManifest::add_apex_info() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.DeltaArchiveManifest.apex_info)
  return apex_info_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::ApexInfo >&
DeltaArchiveManifest::apex_info() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.DeltaArchiveManifest.apex_info)
  return apex_info_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chromeos_update_engine

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::chromeos_update_engine::InstallOperation_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::chromeos_update_engine::CowMergeOperation_Type> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_update_5fengine_2fupdate_5fmetadata_2eproto
