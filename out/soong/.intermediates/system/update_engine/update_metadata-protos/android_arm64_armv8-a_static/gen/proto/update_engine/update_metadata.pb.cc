// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: update_engine/update_metadata.proto

#include "update_engine/update_metadata.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_update_5fengine_2fupdate_5fmetadata_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ApexInfo_update_5fengine_2fupdate_5fmetadata_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_update_5fengine_2fupdate_5fmetadata_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_CowMergeOperation_update_5fengine_2fupdate_5fmetadata_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_update_5fengine_2fupdate_5fmetadata_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DynamicPartitionGroup_update_5fengine_2fupdate_5fmetadata_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_update_5fengine_2fupdate_5fmetadata_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_DynamicPartitionMetadata_update_5fengine_2fupdate_5fmetadata_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_update_5fengine_2fupdate_5fmetadata_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Extent_update_5fengine_2fupdate_5fmetadata_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_update_5fengine_2fupdate_5fmetadata_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ImageInfo_update_5fengine_2fupdate_5fmetadata_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_update_5fengine_2fupdate_5fmetadata_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_InstallOperation_update_5fengine_2fupdate_5fmetadata_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_update_5fengine_2fupdate_5fmetadata_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PartitionInfo_update_5fengine_2fupdate_5fmetadata_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_update_5fengine_2fupdate_5fmetadata_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<5> scc_info_PartitionUpdate_update_5fengine_2fupdate_5fmetadata_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_update_5fengine_2fupdate_5fmetadata_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Signatures_Signature_update_5fengine_2fupdate_5fmetadata_2eproto;
namespace chromeos_update_engine {
class ExtentDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Extent> _instance;
} _Extent_default_instance_;
class Signatures_SignatureDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Signatures_Signature> _instance;
} _Signatures_Signature_default_instance_;
class SignaturesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Signatures> _instance;
} _Signatures_default_instance_;
class PartitionInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PartitionInfo> _instance;
} _PartitionInfo_default_instance_;
class ImageInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ImageInfo> _instance;
} _ImageInfo_default_instance_;
class InstallOperationDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<InstallOperation> _instance;
} _InstallOperation_default_instance_;
class CowMergeOperationDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CowMergeOperation> _instance;
} _CowMergeOperation_default_instance_;
class PartitionUpdateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PartitionUpdate> _instance;
} _PartitionUpdate_default_instance_;
class DynamicPartitionGroupDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DynamicPartitionGroup> _instance;
} _DynamicPartitionGroup_default_instance_;
class DynamicPartitionMetadataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DynamicPartitionMetadata> _instance;
} _DynamicPartitionMetadata_default_instance_;
class ApexInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ApexInfo> _instance;
} _ApexInfo_default_instance_;
class ApexMetadataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ApexMetadata> _instance;
} _ApexMetadata_default_instance_;
class DeltaArchiveManifestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DeltaArchiveManifest> _instance;
} _DeltaArchiveManifest_default_instance_;
}  // namespace chromeos_update_engine
static void InitDefaultsscc_info_ApexInfo_update_5fengine_2fupdate_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_ApexInfo_default_instance_;
    new (ptr) ::chromeos_update_engine::ApexInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::ApexInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ApexInfo_update_5fengine_2fupdate_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_ApexInfo_update_5fengine_2fupdate_5fmetadata_2eproto}, {}};

static void InitDefaultsscc_info_ApexMetadata_update_5fengine_2fupdate_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_ApexMetadata_default_instance_;
    new (ptr) ::chromeos_update_engine::ApexMetadata();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::ApexMetadata::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ApexMetadata_update_5fengine_2fupdate_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_ApexMetadata_update_5fengine_2fupdate_5fmetadata_2eproto}, {
      &scc_info_ApexInfo_update_5fengine_2fupdate_5fmetadata_2eproto.base,}};

static void InitDefaultsscc_info_CowMergeOperation_update_5fengine_2fupdate_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_CowMergeOperation_default_instance_;
    new (ptr) ::chromeos_update_engine::CowMergeOperation();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::CowMergeOperation::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_CowMergeOperation_update_5fengine_2fupdate_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_CowMergeOperation_update_5fengine_2fupdate_5fmetadata_2eproto}, {
      &scc_info_Extent_update_5fengine_2fupdate_5fmetadata_2eproto.base,}};

static void InitDefaultsscc_info_DeltaArchiveManifest_update_5fengine_2fupdate_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_DeltaArchiveManifest_default_instance_;
    new (ptr) ::chromeos_update_engine::DeltaArchiveManifest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::DeltaArchiveManifest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<6> scc_info_DeltaArchiveManifest_update_5fengine_2fupdate_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 6, InitDefaultsscc_info_DeltaArchiveManifest_update_5fengine_2fupdate_5fmetadata_2eproto}, {
      &scc_info_InstallOperation_update_5fengine_2fupdate_5fmetadata_2eproto.base,
      &scc_info_PartitionInfo_update_5fengine_2fupdate_5fmetadata_2eproto.base,
      &scc_info_ImageInfo_update_5fengine_2fupdate_5fmetadata_2eproto.base,
      &scc_info_PartitionUpdate_update_5fengine_2fupdate_5fmetadata_2eproto.base,
      &scc_info_DynamicPartitionMetadata_update_5fengine_2fupdate_5fmetadata_2eproto.base,
      &scc_info_ApexInfo_update_5fengine_2fupdate_5fmetadata_2eproto.base,}};

static void InitDefaultsscc_info_DynamicPartitionGroup_update_5fengine_2fupdate_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_DynamicPartitionGroup_default_instance_;
    new (ptr) ::chromeos_update_engine::DynamicPartitionGroup();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::DynamicPartitionGroup::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DynamicPartitionGroup_update_5fengine_2fupdate_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_DynamicPartitionGroup_update_5fengine_2fupdate_5fmetadata_2eproto}, {}};

static void InitDefaultsscc_info_DynamicPartitionMetadata_update_5fengine_2fupdate_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_DynamicPartitionMetadata_default_instance_;
    new (ptr) ::chromeos_update_engine::DynamicPartitionMetadata();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::DynamicPartitionMetadata::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_DynamicPartitionMetadata_update_5fengine_2fupdate_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_DynamicPartitionMetadata_update_5fengine_2fupdate_5fmetadata_2eproto}, {
      &scc_info_DynamicPartitionGroup_update_5fengine_2fupdate_5fmetadata_2eproto.base,}};

static void InitDefaultsscc_info_Extent_update_5fengine_2fupdate_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_Extent_default_instance_;
    new (ptr) ::chromeos_update_engine::Extent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::Extent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Extent_update_5fengine_2fupdate_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Extent_update_5fengine_2fupdate_5fmetadata_2eproto}, {}};

static void InitDefaultsscc_info_ImageInfo_update_5fengine_2fupdate_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_ImageInfo_default_instance_;
    new (ptr) ::chromeos_update_engine::ImageInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::ImageInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ImageInfo_update_5fengine_2fupdate_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_ImageInfo_update_5fengine_2fupdate_5fmetadata_2eproto}, {}};

static void InitDefaultsscc_info_InstallOperation_update_5fengine_2fupdate_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_InstallOperation_default_instance_;
    new (ptr) ::chromeos_update_engine::InstallOperation();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::InstallOperation::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_InstallOperation_update_5fengine_2fupdate_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_InstallOperation_update_5fengine_2fupdate_5fmetadata_2eproto}, {
      &scc_info_Extent_update_5fengine_2fupdate_5fmetadata_2eproto.base,}};

static void InitDefaultsscc_info_PartitionInfo_update_5fengine_2fupdate_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_PartitionInfo_default_instance_;
    new (ptr) ::chromeos_update_engine::PartitionInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::PartitionInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PartitionInfo_update_5fengine_2fupdate_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_PartitionInfo_update_5fengine_2fupdate_5fmetadata_2eproto}, {}};

static void InitDefaultsscc_info_PartitionUpdate_update_5fengine_2fupdate_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_PartitionUpdate_default_instance_;
    new (ptr) ::chromeos_update_engine::PartitionUpdate();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::PartitionUpdate::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<5> scc_info_PartitionUpdate_update_5fengine_2fupdate_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 5, InitDefaultsscc_info_PartitionUpdate_update_5fengine_2fupdate_5fmetadata_2eproto}, {
      &scc_info_Signatures_Signature_update_5fengine_2fupdate_5fmetadata_2eproto.base,
      &scc_info_PartitionInfo_update_5fengine_2fupdate_5fmetadata_2eproto.base,
      &scc_info_InstallOperation_update_5fengine_2fupdate_5fmetadata_2eproto.base,
      &scc_info_Extent_update_5fengine_2fupdate_5fmetadata_2eproto.base,
      &scc_info_CowMergeOperation_update_5fengine_2fupdate_5fmetadata_2eproto.base,}};

static void InitDefaultsscc_info_Signatures_update_5fengine_2fupdate_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_Signatures_default_instance_;
    new (ptr) ::chromeos_update_engine::Signatures();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::Signatures::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Signatures_update_5fengine_2fupdate_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_Signatures_update_5fengine_2fupdate_5fmetadata_2eproto}, {
      &scc_info_Signatures_Signature_update_5fengine_2fupdate_5fmetadata_2eproto.base,}};

static void InitDefaultsscc_info_Signatures_Signature_update_5fengine_2fupdate_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_Signatures_Signature_default_instance_;
    new (ptr) ::chromeos_update_engine::Signatures_Signature();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::Signatures_Signature::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Signatures_Signature_update_5fengine_2fupdate_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Signatures_Signature_update_5fengine_2fupdate_5fmetadata_2eproto}, {}};

namespace chromeos_update_engine {
bool InstallOperation_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> InstallOperation_Type_strings[11] = {};

static const char InstallOperation_Type_names[] =
  "BROTLI_BSDIFF"
  "BSDIFF"
  "DISCARD"
  "MOVE"
  "PUFFDIFF"
  "REPLACE"
  "REPLACE_BZ"
  "REPLACE_XZ"
  "SOURCE_BSDIFF"
  "SOURCE_COPY"
  "ZERO";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry InstallOperation_Type_entries[] = {
  { {InstallOperation_Type_names + 0, 13}, 10 },
  { {InstallOperation_Type_names + 13, 6}, 3 },
  { {InstallOperation_Type_names + 19, 7}, 7 },
  { {InstallOperation_Type_names + 26, 4}, 2 },
  { {InstallOperation_Type_names + 30, 8}, 9 },
  { {InstallOperation_Type_names + 38, 7}, 0 },
  { {InstallOperation_Type_names + 45, 10}, 1 },
  { {InstallOperation_Type_names + 55, 10}, 8 },
  { {InstallOperation_Type_names + 65, 13}, 5 },
  { {InstallOperation_Type_names + 78, 11}, 4 },
  { {InstallOperation_Type_names + 89, 4}, 6 },
};

static const int InstallOperation_Type_entries_by_number[] = {
  5, // 0 -> REPLACE
  6, // 1 -> REPLACE_BZ
  3, // 2 -> MOVE
  1, // 3 -> BSDIFF
  9, // 4 -> SOURCE_COPY
  8, // 5 -> SOURCE_BSDIFF
  10, // 6 -> ZERO
  2, // 7 -> DISCARD
  7, // 8 -> REPLACE_XZ
  4, // 9 -> PUFFDIFF
  0, // 10 -> BROTLI_BSDIFF
};

const std::string& InstallOperation_Type_Name(
    InstallOperation_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          InstallOperation_Type_entries,
          InstallOperation_Type_entries_by_number,
          11, InstallOperation_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      InstallOperation_Type_entries,
      InstallOperation_Type_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     InstallOperation_Type_strings[idx].get();
}
bool InstallOperation_Type_Parse(
    const std::string& name, InstallOperation_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      InstallOperation_Type_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<InstallOperation_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr InstallOperation_Type InstallOperation::REPLACE;
constexpr InstallOperation_Type InstallOperation::REPLACE_BZ;
constexpr InstallOperation_Type InstallOperation::MOVE;
constexpr InstallOperation_Type InstallOperation::BSDIFF;
constexpr InstallOperation_Type InstallOperation::SOURCE_COPY;
constexpr InstallOperation_Type InstallOperation::SOURCE_BSDIFF;
constexpr InstallOperation_Type InstallOperation::REPLACE_XZ;
constexpr InstallOperation_Type InstallOperation::ZERO;
constexpr InstallOperation_Type InstallOperation::DISCARD;
constexpr InstallOperation_Type InstallOperation::BROTLI_BSDIFF;
constexpr InstallOperation_Type InstallOperation::PUFFDIFF;
constexpr InstallOperation_Type InstallOperation::Type_MIN;
constexpr InstallOperation_Type InstallOperation::Type_MAX;
constexpr int InstallOperation::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool CowMergeOperation_Type_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CowMergeOperation_Type_strings[1] = {};

static const char CowMergeOperation_Type_names[] =
  "COW_COPY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CowMergeOperation_Type_entries[] = {
  { {CowMergeOperation_Type_names + 0, 8}, 0 },
};

static const int CowMergeOperation_Type_entries_by_number[] = {
  0, // 0 -> COW_COPY
};

const std::string& CowMergeOperation_Type_Name(
    CowMergeOperation_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CowMergeOperation_Type_entries,
          CowMergeOperation_Type_entries_by_number,
          1, CowMergeOperation_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CowMergeOperation_Type_entries,
      CowMergeOperation_Type_entries_by_number,
      1, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CowMergeOperation_Type_strings[idx].get();
}
bool CowMergeOperation_Type_Parse(
    const std::string& name, CowMergeOperation_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CowMergeOperation_Type_entries, 1, name, &int_value);
  if (success) {
    *value = static_cast<CowMergeOperation_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr CowMergeOperation_Type CowMergeOperation::COW_COPY;
constexpr CowMergeOperation_Type CowMergeOperation::Type_MIN;
constexpr CowMergeOperation_Type CowMergeOperation::Type_MAX;
constexpr int CowMergeOperation::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void Extent::InitAsDefaultInstance() {
}
class Extent::_Internal {
 public:
  using HasBits = decltype(std::declval<Extent>()._has_bits_);
  static void set_has_start_block(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Extent::Extent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.Extent)
}
Extent::Extent(const Extent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&start_block_, &from.start_block_,
    static_cast<size_t>(reinterpret_cast<char*>(&num_blocks_) -
    reinterpret_cast<char*>(&start_block_)) + sizeof(num_blocks_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.Extent)
}

void Extent::SharedCtor() {
  ::memset(&start_block_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&num_blocks_) -
      reinterpret_cast<char*>(&start_block_)) + sizeof(num_blocks_));
}

Extent::~Extent() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.Extent)
  SharedDtor();
}

void Extent::SharedDtor() {
}

void Extent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Extent& Extent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Extent_update_5fengine_2fupdate_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void Extent::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.Extent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&start_block_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&num_blocks_) -
        reinterpret_cast<char*>(&start_block_)) + sizeof(num_blocks_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Extent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 start_block = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_start_block(&has_bits);
          start_block_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 num_blocks = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_num_blocks(&has_bits);
          num_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Extent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.Extent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 start_block = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_start_block(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &start_block_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 num_blocks = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_num_blocks(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &num_blocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.Extent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.Extent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Extent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.Extent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 start_block = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->start_block(), output);
  }

  // optional uint64 num_blocks = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->num_blocks(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.Extent)
}

size_t Extent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.Extent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 start_block = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->start_block());
    }

    // optional uint64 num_blocks = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->num_blocks());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Extent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Extent*>(
      &from));
}

void Extent::MergeFrom(const Extent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.Extent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      start_block_ = from.start_block_;
    }
    if (cached_has_bits & 0x00000002u) {
      num_blocks_ = from.num_blocks_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Extent::CopyFrom(const Extent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.Extent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Extent::IsInitialized() const {
  return true;
}

void Extent::InternalSwap(Extent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(start_block_, other->start_block_);
  swap(num_blocks_, other->num_blocks_);
}

std::string Extent::GetTypeName() const {
  return "chromeos_update_engine.Extent";
}


// ===================================================================

void Signatures_Signature::InitAsDefaultInstance() {
}
class Signatures_Signature::_Internal {
 public:
  using HasBits = decltype(std::declval<Signatures_Signature>()._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_unpadded_signature_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Signatures_Signature::Signatures_Signature()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.Signatures.Signature)
}
Signatures_Signature::Signatures_Signature(const Signatures_Signature& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_data()) {
    data_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.data_);
  }
  ::memcpy(&version_, &from.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&unpadded_signature_size_) -
    reinterpret_cast<char*>(&version_)) + sizeof(unpadded_signature_size_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.Signatures.Signature)
}

void Signatures_Signature::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Signatures_Signature_update_5fengine_2fupdate_5fmetadata_2eproto.base);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&version_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&unpadded_signature_size_) -
      reinterpret_cast<char*>(&version_)) + sizeof(unpadded_signature_size_));
}

Signatures_Signature::~Signatures_Signature() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.Signatures.Signature)
  SharedDtor();
}

void Signatures_Signature::SharedDtor() {
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Signatures_Signature::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Signatures_Signature& Signatures_Signature::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Signatures_Signature_update_5fengine_2fupdate_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void Signatures_Signature::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.Signatures.Signature)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    data_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&unpadded_signature_size_) -
        reinterpret_cast<char*>(&version_)) + sizeof(unpadded_signature_size_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Signatures_Signature::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 version = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_data(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional fixed32 unpadded_signature_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_unpadded_signature_size(&has_bits);
          unpadded_signature_size_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Signatures_Signature::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.Signatures.Signature)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 version = 1 [deprecated = true];
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_version(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes data = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed32 unpadded_signature_size = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (29 & 0xFF)) {
          _Internal::set_has_unpadded_signature_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &unpadded_signature_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.Signatures.Signature)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.Signatures.Signature)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Signatures_Signature::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.Signatures.Signature)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 version = 1 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }

  // optional bytes data = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->data(), output);
  }

  // optional fixed32 unpadded_signature_size = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32(3, this->unpadded_signature_size(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.Signatures.Signature)
}

size_t Signatures_Signature::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.Signatures.Signature)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes data = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->data());
    }

    // optional uint32 version = 1 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->version());
    }

    // optional fixed32 unpadded_signature_size = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Signatures_Signature::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Signatures_Signature*>(
      &from));
}

void Signatures_Signature::MergeFrom(const Signatures_Signature& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.Signatures.Signature)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      data_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.data_);
    }
    if (cached_has_bits & 0x00000002u) {
      version_ = from.version_;
    }
    if (cached_has_bits & 0x00000004u) {
      unpadded_signature_size_ = from.unpadded_signature_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Signatures_Signature::CopyFrom(const Signatures_Signature& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.Signatures.Signature)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Signatures_Signature::IsInitialized() const {
  return true;
}

void Signatures_Signature::InternalSwap(Signatures_Signature* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  data_.Swap(&other->data_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(version_, other->version_);
  swap(unpadded_signature_size_, other->unpadded_signature_size_);
}

std::string Signatures_Signature::GetTypeName() const {
  return "chromeos_update_engine.Signatures.Signature";
}


// ===================================================================

void Signatures::InitAsDefaultInstance() {
}
class Signatures::_Internal {
 public:
  using HasBits = decltype(std::declval<Signatures>()._has_bits_);
};

Signatures::Signatures()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.Signatures)
}
Signatures::Signatures(const Signatures& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      signatures_(from.signatures_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.Signatures)
}

void Signatures::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Signatures_update_5fengine_2fupdate_5fmetadata_2eproto.base);
}

Signatures::~Signatures() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.Signatures)
  SharedDtor();
}

void Signatures::SharedDtor() {
}

void Signatures::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Signatures& Signatures::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Signatures_update_5fengine_2fupdate_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void Signatures::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.Signatures)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  signatures_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Signatures::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .chromeos_update_engine.Signatures.Signature signatures = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_signatures(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Signatures::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.Signatures)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .chromeos_update_engine.Signatures.Signature signatures = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_signatures()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.Signatures)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.Signatures)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Signatures::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.Signatures)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.Signatures.Signature signatures = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->signatures_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1,
      this->signatures(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.Signatures)
}

size_t Signatures::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.Signatures)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.Signatures.Signature signatures = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->signatures_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->signatures(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Signatures::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Signatures*>(
      &from));
}

void Signatures::MergeFrom(const Signatures& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.Signatures)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  signatures_.MergeFrom(from.signatures_);
}

void Signatures::CopyFrom(const Signatures& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.Signatures)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Signatures::IsInitialized() const {
  return true;
}

void Signatures::InternalSwap(Signatures* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&signatures_)->InternalSwap(CastToBase(&other->signatures_));
}

std::string Signatures::GetTypeName() const {
  return "chromeos_update_engine.Signatures";
}


// ===================================================================

void PartitionInfo::InitAsDefaultInstance() {
}
class PartitionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<PartitionInfo>()._has_bits_);
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PartitionInfo::PartitionInfo()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.PartitionInfo)
}
PartitionInfo::PartitionInfo(const PartitionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_hash()) {
    hash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.hash_);
  }
  size_ = from.size_;
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.PartitionInfo)
}

void PartitionInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_PartitionInfo_update_5fengine_2fupdate_5fmetadata_2eproto.base);
  hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  size_ = PROTOBUF_ULONGLONG(0);
}

PartitionInfo::~PartitionInfo() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.PartitionInfo)
  SharedDtor();
}

void PartitionInfo::SharedDtor() {
  hash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PartitionInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PartitionInfo& PartitionInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PartitionInfo_update_5fengine_2fupdate_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void PartitionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.PartitionInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    hash_.ClearNonDefaultToEmptyNoArena();
  }
  size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* PartitionInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_size(&has_bits);
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_hash(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool PartitionInfo::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.PartitionInfo)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 size = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes hash = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_hash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.PartitionInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.PartitionInfo)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void PartitionInfo::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.PartitionInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 size = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->size(), output);
  }

  // optional bytes hash = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->hash(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.PartitionInfo)
}

size_t PartitionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.PartitionInfo)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes hash = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->hash());
    }

    // optional uint64 size = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->size());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PartitionInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PartitionInfo*>(
      &from));
}

void PartitionInfo::MergeFrom(const PartitionInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.PartitionInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      hash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.hash_);
    }
    if (cached_has_bits & 0x00000002u) {
      size_ = from.size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PartitionInfo::CopyFrom(const PartitionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.PartitionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PartitionInfo::IsInitialized() const {
  return true;
}

void PartitionInfo::InternalSwap(PartitionInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  hash_.Swap(&other->hash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(size_, other->size_);
}

std::string PartitionInfo::GetTypeName() const {
  return "chromeos_update_engine.PartitionInfo";
}


// ===================================================================

void ImageInfo::InitAsDefaultInstance() {
}
class ImageInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ImageInfo>()._has_bits_);
  static void set_has_board(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_channel(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_build_channel(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_build_version(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

ImageInfo::ImageInfo()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.ImageInfo)
}
ImageInfo::ImageInfo(const ImageInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  board_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_board()) {
    board_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.board_);
  }
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_key()) {
    key_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.key_);
  }
  channel_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_channel()) {
    channel_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.channel_);
  }
  version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_version()) {
    version_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.version_);
  }
  build_channel_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_build_channel()) {
    build_channel_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.build_channel_);
  }
  build_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_build_version()) {
    build_version_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.build_version_);
  }
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.ImageInfo)
}

void ImageInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ImageInfo_update_5fengine_2fupdate_5fmetadata_2eproto.base);
  board_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  channel_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  build_channel_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  build_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

ImageInfo::~ImageInfo() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.ImageInfo)
  SharedDtor();
}

void ImageInfo::SharedDtor() {
  board_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  channel_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  build_channel_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  build_version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ImageInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ImageInfo& ImageInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ImageInfo_update_5fengine_2fupdate_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void ImageInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.ImageInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      board_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      key_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      channel_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      version_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      build_channel_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000020u) {
      build_version_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ImageInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string board = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_board(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string key = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_key(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string channel = 3 [deprecated = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_channel(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string version = 4 [deprecated = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_version(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string build_channel = 5 [deprecated = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_build_channel(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string build_version = 6 [deprecated = true];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_build_version(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ImageInfo::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.ImageInfo)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string board = 1 [deprecated = true];
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_board()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string key = 2 [deprecated = true];
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string channel = 3 [deprecated = true];
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_channel()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string version = 4 [deprecated = true];
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string build_channel = 5 [deprecated = true];
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_build_channel()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string build_version = 6 [deprecated = true];
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_build_version()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.ImageInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.ImageInfo)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ImageInfo::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.ImageInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string board = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->board(), output);
  }

  // optional string key = 2 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->key(), output);
  }

  // optional string channel = 3 [deprecated = true];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->channel(), output);
  }

  // optional string version = 4 [deprecated = true];
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->version(), output);
  }

  // optional string build_channel = 5 [deprecated = true];
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->build_channel(), output);
  }

  // optional string build_version = 6 [deprecated = true];
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->build_version(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.ImageInfo)
}

size_t ImageInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.ImageInfo)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string board = 1 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->board());
    }

    // optional string key = 2 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->key());
    }

    // optional string channel = 3 [deprecated = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->channel());
    }

    // optional string version = 4 [deprecated = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional string build_channel = 5 [deprecated = true];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->build_channel());
    }

    // optional string build_version = 6 [deprecated = true];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->build_version());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ImageInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ImageInfo*>(
      &from));
}

void ImageInfo::MergeFrom(const ImageInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.ImageInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      board_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.board_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      key_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.key_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      channel_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.channel_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      version_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.version_);
    }
    if (cached_has_bits & 0x00000010u) {
      _has_bits_[0] |= 0x00000010u;
      build_channel_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.build_channel_);
    }
    if (cached_has_bits & 0x00000020u) {
      _has_bits_[0] |= 0x00000020u;
      build_version_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.build_version_);
    }
  }
}

void ImageInfo::CopyFrom(const ImageInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.ImageInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageInfo::IsInitialized() const {
  return true;
}

void ImageInfo::InternalSwap(ImageInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  board_.Swap(&other->board_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  key_.Swap(&other->key_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  channel_.Swap(&other->channel_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  version_.Swap(&other->version_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  build_channel_.Swap(&other->build_channel_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  build_version_.Swap(&other->build_version_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

std::string ImageInfo::GetTypeName() const {
  return "chromeos_update_engine.ImageInfo";
}


// ===================================================================

void InstallOperation::InitAsDefaultInstance() {
}
class InstallOperation::_Internal {
 public:
  using HasBits = decltype(std::declval<InstallOperation>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_data_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_data_length(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_src_length(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_dst_length(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_data_sha256_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_src_sha256_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

InstallOperation::InstallOperation()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.InstallOperation)
}
InstallOperation::InstallOperation(const InstallOperation& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      src_extents_(from.src_extents_),
      dst_extents_(from.dst_extents_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  data_sha256_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_data_sha256_hash()) {
    data_sha256_hash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.data_sha256_hash_);
  }
  src_sha256_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_src_sha256_hash()) {
    src_sha256_hash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.src_sha256_hash_);
  }
  ::memcpy(&data_offset_, &from.data_offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&data_offset_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.InstallOperation)
}

void InstallOperation::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_InstallOperation_update_5fengine_2fupdate_5fmetadata_2eproto.base);
  data_sha256_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  src_sha256_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&data_offset_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&data_offset_)) + sizeof(type_));
}

InstallOperation::~InstallOperation() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.InstallOperation)
  SharedDtor();
}

void InstallOperation::SharedDtor() {
  data_sha256_hash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  src_sha256_hash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void InstallOperation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const InstallOperation& InstallOperation::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_InstallOperation_update_5fengine_2fupdate_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void InstallOperation::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.InstallOperation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  src_extents_.Clear();
  dst_extents_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      data_sha256_hash_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      src_sha256_hash_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&data_offset_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&type_) -
        reinterpret_cast<char*>(&data_offset_)) + sizeof(type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* InstallOperation::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .chromeos_update_engine.InstallOperation.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::chromeos_update_engine::InstallOperation_Type_IsValid(val))) {
            set_type(static_cast<::chromeos_update_engine::InstallOperation_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint64 data_offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_data_offset(&has_bits);
          data_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 data_length = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_data_length(&has_bits);
          data_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .chromeos_update_engine.Extent src_extents = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_src_extents(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 34);
        } else goto handle_unusual;
        continue;
      // optional uint64 src_length = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_src_length(&has_bits);
          src_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .chromeos_update_engine.Extent dst_extents = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_dst_extents(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 50);
        } else goto handle_unusual;
        continue;
      // optional uint64 dst_length = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_dst_length(&has_bits);
          dst_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes data_sha256_hash = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_data_sha256_hash(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes src_sha256_hash = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_src_sha256_hash(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool InstallOperation::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.InstallOperation)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .chromeos_update_engine.InstallOperation.Type type = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::chromeos_update_engine::InstallOperation_Type_IsValid(value)) {
            set_type(static_cast< ::chromeos_update_engine::InstallOperation_Type >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 data_offset = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_data_offset(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &data_offset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 data_length = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_data_length(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &data_length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .chromeos_update_engine.Extent src_extents = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_src_extents()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 src_length = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_src_length(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &src_length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .chromeos_update_engine.Extent dst_extents = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_dst_extents()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 dst_length = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_dst_length(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dst_length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes data_sha256_hash = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (66 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data_sha256_hash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes src_sha256_hash = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (74 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_src_sha256_hash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.InstallOperation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.InstallOperation)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void InstallOperation::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.InstallOperation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .chromeos_update_engine.InstallOperation.Type type = 1;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional uint64 data_offset = 2;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->data_offset(), output);
  }

  // optional uint64 data_length = 3;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->data_length(), output);
  }

  // repeated .chromeos_update_engine.Extent src_extents = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->src_extents_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      4,
      this->src_extents(static_cast<int>(i)),
      output);
  }

  // optional uint64 src_length = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(5, this->src_length(), output);
  }

  // repeated .chromeos_update_engine.Extent dst_extents = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->dst_extents_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      6,
      this->dst_extents(static_cast<int>(i)),
      output);
  }

  // optional uint64 dst_length = 7;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(7, this->dst_length(), output);
  }

  // optional bytes data_sha256_hash = 8;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      8, this->data_sha256_hash(), output);
  }

  // optional bytes src_sha256_hash = 9;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      9, this->src_sha256_hash(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.InstallOperation)
}

size_t InstallOperation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.InstallOperation)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required .chromeos_update_engine.InstallOperation.Type type = 1;
  if (has_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->type());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.Extent src_extents = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->src_extents_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->src_extents(static_cast<int>(i)));
    }
  }

  // repeated .chromeos_update_engine.Extent dst_extents = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->dst_extents_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->dst_extents(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes data_sha256_hash = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->data_sha256_hash());
    }

    // optional bytes src_sha256_hash = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->src_sha256_hash());
    }

    // optional uint64 data_offset = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->data_offset());
    }

    // optional uint64 data_length = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->data_length());
    }

    // optional uint64 src_length = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->src_length());
    }

    // optional uint64 dst_length = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dst_length());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InstallOperation::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const InstallOperation*>(
      &from));
}

void InstallOperation::MergeFrom(const InstallOperation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.InstallOperation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  src_extents_.MergeFrom(from.src_extents_);
  dst_extents_.MergeFrom(from.dst_extents_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      data_sha256_hash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.data_sha256_hash_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      src_sha256_hash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.src_sha256_hash_);
    }
    if (cached_has_bits & 0x00000004u) {
      data_offset_ = from.data_offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      data_length_ = from.data_length_;
    }
    if (cached_has_bits & 0x00000010u) {
      src_length_ = from.src_length_;
    }
    if (cached_has_bits & 0x00000020u) {
      dst_length_ = from.dst_length_;
    }
    if (cached_has_bits & 0x00000040u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void InstallOperation::CopyFrom(const InstallOperation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.InstallOperation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InstallOperation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000040) != 0x00000040) return false;
  return true;
}

void InstallOperation::InternalSwap(InstallOperation* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&src_extents_)->InternalSwap(CastToBase(&other->src_extents_));
  CastToBase(&dst_extents_)->InternalSwap(CastToBase(&other->dst_extents_));
  data_sha256_hash_.Swap(&other->data_sha256_hash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  src_sha256_hash_.Swap(&other->src_sha256_hash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(data_offset_, other->data_offset_);
  swap(data_length_, other->data_length_);
  swap(src_length_, other->src_length_);
  swap(dst_length_, other->dst_length_);
  swap(type_, other->type_);
}

std::string InstallOperation::GetTypeName() const {
  return "chromeos_update_engine.InstallOperation";
}


// ===================================================================

void CowMergeOperation::InitAsDefaultInstance() {
  ::chromeos_update_engine::_CowMergeOperation_default_instance_._instance.get_mutable()->src_extent_ = const_cast< ::chromeos_update_engine::Extent*>(
      ::chromeos_update_engine::Extent::internal_default_instance());
  ::chromeos_update_engine::_CowMergeOperation_default_instance_._instance.get_mutable()->dst_extent_ = const_cast< ::chromeos_update_engine::Extent*>(
      ::chromeos_update_engine::Extent::internal_default_instance());
}
class CowMergeOperation::_Internal {
 public:
  using HasBits = decltype(std::declval<CowMergeOperation>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::chromeos_update_engine::Extent& src_extent(const CowMergeOperation* msg);
  static void set_has_src_extent(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::chromeos_update_engine::Extent& dst_extent(const CowMergeOperation* msg);
  static void set_has_dst_extent(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::chromeos_update_engine::Extent&
CowMergeOperation::_Internal::src_extent(const CowMergeOperation* msg) {
  return *msg->src_extent_;
}
const ::chromeos_update_engine::Extent&
CowMergeOperation::_Internal::dst_extent(const CowMergeOperation* msg) {
  return *msg->dst_extent_;
}
CowMergeOperation::CowMergeOperation()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.CowMergeOperation)
}
CowMergeOperation::CowMergeOperation(const CowMergeOperation& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_src_extent()) {
    src_extent_ = new ::chromeos_update_engine::Extent(*from.src_extent_);
  } else {
    src_extent_ = nullptr;
  }
  if (from.has_dst_extent()) {
    dst_extent_ = new ::chromeos_update_engine::Extent(*from.dst_extent_);
  } else {
    dst_extent_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.CowMergeOperation)
}

void CowMergeOperation::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CowMergeOperation_update_5fengine_2fupdate_5fmetadata_2eproto.base);
  ::memset(&src_extent_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&src_extent_)) + sizeof(type_));
}

CowMergeOperation::~CowMergeOperation() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.CowMergeOperation)
  SharedDtor();
}

void CowMergeOperation::SharedDtor() {
  if (this != internal_default_instance()) delete src_extent_;
  if (this != internal_default_instance()) delete dst_extent_;
}

void CowMergeOperation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CowMergeOperation& CowMergeOperation::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CowMergeOperation_update_5fengine_2fupdate_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void CowMergeOperation::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.CowMergeOperation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(src_extent_ != nullptr);
      src_extent_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(dst_extent_ != nullptr);
      dst_extent_->Clear();
    }
  }
  type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CowMergeOperation::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .chromeos_update_engine.CowMergeOperation.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::chromeos_update_engine::CowMergeOperation_Type_IsValid(val))) {
            set_type(static_cast<::chromeos_update_engine::CowMergeOperation_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .chromeos_update_engine.Extent src_extent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_src_extent(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .chromeos_update_engine.Extent dst_extent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_dst_extent(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CowMergeOperation::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.CowMergeOperation)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .chromeos_update_engine.CowMergeOperation.Type type = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::chromeos_update_engine::CowMergeOperation_Type_IsValid(value)) {
            set_type(static_cast< ::chromeos_update_engine::CowMergeOperation_Type >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chromeos_update_engine.Extent src_extent = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_src_extent()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chromeos_update_engine.Extent dst_extent = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_dst_extent()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.CowMergeOperation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.CowMergeOperation)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CowMergeOperation::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.CowMergeOperation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .chromeos_update_engine.CowMergeOperation.Type type = 1;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .chromeos_update_engine.Extent src_extent = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2, _Internal::src_extent(this), output);
  }

  // optional .chromeos_update_engine.Extent dst_extent = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      3, _Internal::dst_extent(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.CowMergeOperation)
}

size_t CowMergeOperation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.CowMergeOperation)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .chromeos_update_engine.Extent src_extent = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *src_extent_);
    }

    // optional .chromeos_update_engine.Extent dst_extent = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *dst_extent_);
    }

    // optional .chromeos_update_engine.CowMergeOperation.Type type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CowMergeOperation::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CowMergeOperation*>(
      &from));
}

void CowMergeOperation::MergeFrom(const CowMergeOperation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.CowMergeOperation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_src_extent()->::chromeos_update_engine::Extent::MergeFrom(from.src_extent());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_dst_extent()->::chromeos_update_engine::Extent::MergeFrom(from.dst_extent());
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CowMergeOperation::CopyFrom(const CowMergeOperation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.CowMergeOperation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CowMergeOperation::IsInitialized() const {
  return true;
}

void CowMergeOperation::InternalSwap(CowMergeOperation* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(src_extent_, other->src_extent_);
  swap(dst_extent_, other->dst_extent_);
  swap(type_, other->type_);
}

std::string CowMergeOperation::GetTypeName() const {
  return "chromeos_update_engine.CowMergeOperation";
}


// ===================================================================

void PartitionUpdate::InitAsDefaultInstance() {
  ::chromeos_update_engine::_PartitionUpdate_default_instance_._instance.get_mutable()->old_partition_info_ = const_cast< ::chromeos_update_engine::PartitionInfo*>(
      ::chromeos_update_engine::PartitionInfo::internal_default_instance());
  ::chromeos_update_engine::_PartitionUpdate_default_instance_._instance.get_mutable()->new_partition_info_ = const_cast< ::chromeos_update_engine::PartitionInfo*>(
      ::chromeos_update_engine::PartitionInfo::internal_default_instance());
  ::chromeos_update_engine::_PartitionUpdate_default_instance_._instance.get_mutable()->hash_tree_data_extent_ = const_cast< ::chromeos_update_engine::Extent*>(
      ::chromeos_update_engine::Extent::internal_default_instance());
  ::chromeos_update_engine::_PartitionUpdate_default_instance_._instance.get_mutable()->hash_tree_extent_ = const_cast< ::chromeos_update_engine::Extent*>(
      ::chromeos_update_engine::Extent::internal_default_instance());
  ::chromeos_update_engine::_PartitionUpdate_default_instance_._instance.get_mutable()->fec_data_extent_ = const_cast< ::chromeos_update_engine::Extent*>(
      ::chromeos_update_engine::Extent::internal_default_instance());
  ::chromeos_update_engine::_PartitionUpdate_default_instance_._instance.get_mutable()->fec_extent_ = const_cast< ::chromeos_update_engine::Extent*>(
      ::chromeos_update_engine::Extent::internal_default_instance());
}
class PartitionUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<PartitionUpdate>()._has_bits_);
  static void set_has_partition_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_run_postinstall(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_postinstall_path(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_filesystem_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::chromeos_update_engine::PartitionInfo& old_partition_info(const PartitionUpdate* msg);
  static void set_has_old_partition_info(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::chromeos_update_engine::PartitionInfo& new_partition_info(const PartitionUpdate* msg);
  static void set_has_new_partition_info(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_postinstall_optional(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::chromeos_update_engine::Extent& hash_tree_data_extent(const PartitionUpdate* msg);
  static void set_has_hash_tree_data_extent(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::chromeos_update_engine::Extent& hash_tree_extent(const PartitionUpdate* msg);
  static void set_has_hash_tree_extent(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_hash_tree_algorithm(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_hash_tree_salt(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::chromeos_update_engine::Extent& fec_data_extent(const PartitionUpdate* msg);
  static void set_has_fec_data_extent(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::chromeos_update_engine::Extent& fec_extent(const PartitionUpdate* msg);
  static void set_has_fec_extent(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_fec_roots(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_estimate_cow_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
};

const ::chromeos_update_engine::PartitionInfo&
PartitionUpdate::_Internal::old_partition_info(const PartitionUpdate* msg) {
  return *msg->old_partition_info_;
}
const ::chromeos_update_engine::PartitionInfo&
PartitionUpdate::_Internal::new_partition_info(const PartitionUpdate* msg) {
  return *msg->new_partition_info_;
}
const ::chromeos_update_engine::Extent&
PartitionUpdate::_Internal::hash_tree_data_extent(const PartitionUpdate* msg) {
  return *msg->hash_tree_data_extent_;
}
const ::chromeos_update_engine::Extent&
PartitionUpdate::_Internal::hash_tree_extent(const PartitionUpdate* msg) {
  return *msg->hash_tree_extent_;
}
const ::chromeos_update_engine::Extent&
PartitionUpdate::_Internal::fec_data_extent(const PartitionUpdate* msg) {
  return *msg->fec_data_extent_;
}
const ::chromeos_update_engine::Extent&
PartitionUpdate::_Internal::fec_extent(const PartitionUpdate* msg) {
  return *msg->fec_extent_;
}
PartitionUpdate::PartitionUpdate()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.PartitionUpdate)
}
PartitionUpdate::PartitionUpdate(const PartitionUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      new_partition_signature_(from.new_partition_signature_),
      operations_(from.operations_),
      merge_operations_(from.merge_operations_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  partition_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_partition_name()) {
    partition_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.partition_name_);
  }
  postinstall_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_postinstall_path()) {
    postinstall_path_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.postinstall_path_);
  }
  filesystem_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_filesystem_type()) {
    filesystem_type_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.filesystem_type_);
  }
  hash_tree_algorithm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_hash_tree_algorithm()) {
    hash_tree_algorithm_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.hash_tree_algorithm_);
  }
  hash_tree_salt_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_hash_tree_salt()) {
    hash_tree_salt_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.hash_tree_salt_);
  }
  version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_version()) {
    version_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.version_);
  }
  if (from.has_old_partition_info()) {
    old_partition_info_ = new ::chromeos_update_engine::PartitionInfo(*from.old_partition_info_);
  } else {
    old_partition_info_ = nullptr;
  }
  if (from.has_new_partition_info()) {
    new_partition_info_ = new ::chromeos_update_engine::PartitionInfo(*from.new_partition_info_);
  } else {
    new_partition_info_ = nullptr;
  }
  if (from.has_hash_tree_data_extent()) {
    hash_tree_data_extent_ = new ::chromeos_update_engine::Extent(*from.hash_tree_data_extent_);
  } else {
    hash_tree_data_extent_ = nullptr;
  }
  if (from.has_hash_tree_extent()) {
    hash_tree_extent_ = new ::chromeos_update_engine::Extent(*from.hash_tree_extent_);
  } else {
    hash_tree_extent_ = nullptr;
  }
  if (from.has_fec_data_extent()) {
    fec_data_extent_ = new ::chromeos_update_engine::Extent(*from.fec_data_extent_);
  } else {
    fec_data_extent_ = nullptr;
  }
  if (from.has_fec_extent()) {
    fec_extent_ = new ::chromeos_update_engine::Extent(*from.fec_extent_);
  } else {
    fec_extent_ = nullptr;
  }
  ::memcpy(&estimate_cow_size_, &from.estimate_cow_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&fec_roots_) -
    reinterpret_cast<char*>(&estimate_cow_size_)) + sizeof(fec_roots_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.PartitionUpdate)
}

void PartitionUpdate::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_PartitionUpdate_update_5fengine_2fupdate_5fmetadata_2eproto.base);
  partition_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  postinstall_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  filesystem_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  hash_tree_algorithm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  hash_tree_salt_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&old_partition_info_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&postinstall_optional_) -
      reinterpret_cast<char*>(&old_partition_info_)) + sizeof(postinstall_optional_));
  fec_roots_ = 2u;
}

PartitionUpdate::~PartitionUpdate() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.PartitionUpdate)
  SharedDtor();
}

void PartitionUpdate::SharedDtor() {
  partition_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  postinstall_path_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  filesystem_type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  hash_tree_algorithm_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  hash_tree_salt_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete old_partition_info_;
  if (this != internal_default_instance()) delete new_partition_info_;
  if (this != internal_default_instance()) delete hash_tree_data_extent_;
  if (this != internal_default_instance()) delete hash_tree_extent_;
  if (this != internal_default_instance()) delete fec_data_extent_;
  if (this != internal_default_instance()) delete fec_extent_;
}

void PartitionUpdate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PartitionUpdate& PartitionUpdate::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PartitionUpdate_update_5fengine_2fupdate_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void PartitionUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.PartitionUpdate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  new_partition_signature_.Clear();
  operations_.Clear();
  merge_operations_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      partition_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      postinstall_path_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      filesystem_type_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      hash_tree_algorithm_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      hash_tree_salt_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000020u) {
      version_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(old_partition_info_ != nullptr);
      old_partition_info_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(new_partition_info_ != nullptr);
      new_partition_info_->Clear();
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(hash_tree_data_extent_ != nullptr);
      hash_tree_data_extent_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(hash_tree_extent_ != nullptr);
      hash_tree_extent_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(fec_data_extent_ != nullptr);
      fec_data_extent_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(fec_extent_ != nullptr);
      fec_extent_->Clear();
    }
  }
  if (cached_has_bits & 0x0000f000u) {
    ::memset(&estimate_cow_size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&postinstall_optional_) -
        reinterpret_cast<char*>(&estimate_cow_size_)) + sizeof(postinstall_optional_));
    fec_roots_ = 2u;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* PartitionUpdate::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string partition_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_partition_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool run_postinstall = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_run_postinstall(&has_bits);
          run_postinstall_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string postinstall_path = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_postinstall_path(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string filesystem_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_filesystem_type(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_new_partition_signature(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 42);
        } else goto handle_unusual;
        continue;
      // optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(mutable_old_partition_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(mutable_new_partition_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .chromeos_update_engine.InstallOperation operations = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_operations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 66);
        } else goto handle_unusual;
        continue;
      // optional bool postinstall_optional = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_postinstall_optional(&has_bits);
          postinstall_optional_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(mutable_hash_tree_data_extent(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .chromeos_update_engine.Extent hash_tree_extent = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(mutable_hash_tree_extent(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string hash_tree_algorithm = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_hash_tree_algorithm(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes hash_tree_salt = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_hash_tree_salt(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .chromeos_update_engine.Extent fec_data_extent = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          ptr = ctx->ParseMessage(mutable_fec_data_extent(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .chromeos_update_engine.Extent fec_extent = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 122)) {
          ptr = ctx->ParseMessage(mutable_fec_extent(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 fec_roots = 16 [default = 2];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          _Internal::set_has_fec_roots(&has_bits);
          fec_roots_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string version = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 138)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_version(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 146)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(add_merge_operations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint16>(ptr) == 402);
        } else goto handle_unusual;
        continue;
      // optional uint64 estimate_cow_size = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          _Internal::set_has_estimate_cow_size(&has_bits);
          estimate_cow_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool PartitionUpdate::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.PartitionUpdate)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string partition_name = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_partition_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool run_postinstall = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_run_postinstall(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &run_postinstall_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string postinstall_path = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_postinstall_path()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string filesystem_type = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_filesystem_type()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_new_partition_signature()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_old_partition_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (58 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_new_partition_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .chromeos_update_engine.InstallOperation operations = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (66 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_operations()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool postinstall_optional = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          _Internal::set_has_postinstall_optional(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &postinstall_optional_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (82 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_hash_tree_data_extent()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chromeos_update_engine.Extent hash_tree_extent = 11;
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (90 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_hash_tree_extent()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string hash_tree_algorithm = 12;
      case 12: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (98 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_hash_tree_algorithm()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes hash_tree_salt = 13;
      case 13: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (106 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_hash_tree_salt()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chromeos_update_engine.Extent fec_data_extent = 14;
      case 14: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (114 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_fec_data_extent()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chromeos_update_engine.Extent fec_extent = 15;
      case 15: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (122 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_fec_extent()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 fec_roots = 16 [default = 2];
      case 16: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (128 & 0xFF)) {
          _Internal::set_has_fec_roots(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fec_roots_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string version = 17;
      case 17: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (138 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;
      case 18: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (146 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_merge_operations()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 estimate_cow_size = 19;
      case 19: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (152 & 0xFF)) {
          _Internal::set_has_estimate_cow_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &estimate_cow_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.PartitionUpdate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.PartitionUpdate)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void PartitionUpdate::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.PartitionUpdate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string partition_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->partition_name(), output);
  }

  // optional bool run_postinstall = 2;
  if (cached_has_bits & 0x00002000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(2, this->run_postinstall(), output);
  }

  // optional string postinstall_path = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->postinstall_path(), output);
  }

  // optional string filesystem_type = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->filesystem_type(), output);
  }

  // repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->new_partition_signature_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      5,
      this->new_partition_signature(static_cast<int>(i)),
      output);
  }

  // optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      6, _Internal::old_partition_info(this), output);
  }

  // optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      7, _Internal::new_partition_info(this), output);
  }

  // repeated .chromeos_update_engine.InstallOperation operations = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->operations_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      8,
      this->operations(static_cast<int>(i)),
      output);
  }

  // optional bool postinstall_optional = 9;
  if (cached_has_bits & 0x00004000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(9, this->postinstall_optional(), output);
  }

  // optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      10, _Internal::hash_tree_data_extent(this), output);
  }

  // optional .chromeos_update_engine.Extent hash_tree_extent = 11;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      11, _Internal::hash_tree_extent(this), output);
  }

  // optional string hash_tree_algorithm = 12;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      12, this->hash_tree_algorithm(), output);
  }

  // optional bytes hash_tree_salt = 13;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      13, this->hash_tree_salt(), output);
  }

  // optional .chromeos_update_engine.Extent fec_data_extent = 14;
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      14, _Internal::fec_data_extent(this), output);
  }

  // optional .chromeos_update_engine.Extent fec_extent = 15;
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      15, _Internal::fec_extent(this), output);
  }

  // optional uint32 fec_roots = 16 [default = 2];
  if (cached_has_bits & 0x00008000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(16, this->fec_roots(), output);
  }

  // optional string version = 17;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      17, this->version(), output);
  }

  // repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->merge_operations_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      18,
      this->merge_operations(static_cast<int>(i)),
      output);
  }

  // optional uint64 estimate_cow_size = 19;
  if (cached_has_bits & 0x00001000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(19, this->estimate_cow_size(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.PartitionUpdate)
}

size_t PartitionUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.PartitionUpdate)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required string partition_name = 1;
  if (has_partition_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->partition_name());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->new_partition_signature_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->new_partition_signature(static_cast<int>(i)));
    }
  }

  // repeated .chromeos_update_engine.InstallOperation operations = 8;
  {
    unsigned int count = static_cast<unsigned int>(this->operations_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->operations(static_cast<int>(i)));
    }
  }

  // repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;
  {
    unsigned int count = static_cast<unsigned int>(this->merge_operations_size());
    total_size += 2UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->merge_operations(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional string postinstall_path = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->postinstall_path());
    }

    // optional string filesystem_type = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->filesystem_type());
    }

    // optional string hash_tree_algorithm = 12;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->hash_tree_algorithm());
    }

    // optional bytes hash_tree_salt = 13;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->hash_tree_salt());
    }

    // optional string version = 17;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *old_partition_info_);
    }

    // optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *new_partition_info_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *hash_tree_data_extent_);
    }

    // optional .chromeos_update_engine.Extent hash_tree_extent = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *hash_tree_extent_);
    }

    // optional .chromeos_update_engine.Extent fec_data_extent = 14;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *fec_data_extent_);
    }

    // optional .chromeos_update_engine.Extent fec_extent = 15;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *fec_extent_);
    }

    // optional uint64 estimate_cow_size = 19;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->estimate_cow_size());
    }

    // optional bool run_postinstall = 2;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool postinstall_optional = 9;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional uint32 fec_roots = 16 [default = 2];
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->fec_roots());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PartitionUpdate::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PartitionUpdate*>(
      &from));
}

void PartitionUpdate::MergeFrom(const PartitionUpdate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.PartitionUpdate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  new_partition_signature_.MergeFrom(from.new_partition_signature_);
  operations_.MergeFrom(from.operations_);
  merge_operations_.MergeFrom(from.merge_operations_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      partition_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.partition_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      postinstall_path_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.postinstall_path_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      filesystem_type_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.filesystem_type_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      hash_tree_algorithm_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.hash_tree_algorithm_);
    }
    if (cached_has_bits & 0x00000010u) {
      _has_bits_[0] |= 0x00000010u;
      hash_tree_salt_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.hash_tree_salt_);
    }
    if (cached_has_bits & 0x00000020u) {
      _has_bits_[0] |= 0x00000020u;
      version_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.version_);
    }
    if (cached_has_bits & 0x00000040u) {
      mutable_old_partition_info()->::chromeos_update_engine::PartitionInfo::MergeFrom(from.old_partition_info());
    }
    if (cached_has_bits & 0x00000080u) {
      mutable_new_partition_info()->::chromeos_update_engine::PartitionInfo::MergeFrom(from.new_partition_info());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      mutable_hash_tree_data_extent()->::chromeos_update_engine::Extent::MergeFrom(from.hash_tree_data_extent());
    }
    if (cached_has_bits & 0x00000200u) {
      mutable_hash_tree_extent()->::chromeos_update_engine::Extent::MergeFrom(from.hash_tree_extent());
    }
    if (cached_has_bits & 0x00000400u) {
      mutable_fec_data_extent()->::chromeos_update_engine::Extent::MergeFrom(from.fec_data_extent());
    }
    if (cached_has_bits & 0x00000800u) {
      mutable_fec_extent()->::chromeos_update_engine::Extent::MergeFrom(from.fec_extent());
    }
    if (cached_has_bits & 0x00001000u) {
      estimate_cow_size_ = from.estimate_cow_size_;
    }
    if (cached_has_bits & 0x00002000u) {
      run_postinstall_ = from.run_postinstall_;
    }
    if (cached_has_bits & 0x00004000u) {
      postinstall_optional_ = from.postinstall_optional_;
    }
    if (cached_has_bits & 0x00008000u) {
      fec_roots_ = from.fec_roots_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PartitionUpdate::CopyFrom(const PartitionUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.PartitionUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PartitionUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->operations())) return false;
  return true;
}

void PartitionUpdate::InternalSwap(PartitionUpdate* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&new_partition_signature_)->InternalSwap(CastToBase(&other->new_partition_signature_));
  CastToBase(&operations_)->InternalSwap(CastToBase(&other->operations_));
  CastToBase(&merge_operations_)->InternalSwap(CastToBase(&other->merge_operations_));
  partition_name_.Swap(&other->partition_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  postinstall_path_.Swap(&other->postinstall_path_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  filesystem_type_.Swap(&other->filesystem_type_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  hash_tree_algorithm_.Swap(&other->hash_tree_algorithm_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  hash_tree_salt_.Swap(&other->hash_tree_salt_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  version_.Swap(&other->version_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(old_partition_info_, other->old_partition_info_);
  swap(new_partition_info_, other->new_partition_info_);
  swap(hash_tree_data_extent_, other->hash_tree_data_extent_);
  swap(hash_tree_extent_, other->hash_tree_extent_);
  swap(fec_data_extent_, other->fec_data_extent_);
  swap(fec_extent_, other->fec_extent_);
  swap(estimate_cow_size_, other->estimate_cow_size_);
  swap(run_postinstall_, other->run_postinstall_);
  swap(postinstall_optional_, other->postinstall_optional_);
  swap(fec_roots_, other->fec_roots_);
}

std::string PartitionUpdate::GetTypeName() const {
  return "chromeos_update_engine.PartitionUpdate";
}


// ===================================================================

void DynamicPartitionGroup::InitAsDefaultInstance() {
}
class DynamicPartitionGroup::_Internal {
 public:
  using HasBits = decltype(std::declval<DynamicPartitionGroup>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

DynamicPartitionGroup::DynamicPartitionGroup()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.DynamicPartitionGroup)
}
DynamicPartitionGroup::DynamicPartitionGroup(const DynamicPartitionGroup& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      partition_names_(from.partition_names_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  size_ = from.size_;
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.DynamicPartitionGroup)
}

void DynamicPartitionGroup::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_DynamicPartitionGroup_update_5fengine_2fupdate_5fmetadata_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  size_ = PROTOBUF_ULONGLONG(0);
}

DynamicPartitionGroup::~DynamicPartitionGroup() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.DynamicPartitionGroup)
  SharedDtor();
}

void DynamicPartitionGroup::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DynamicPartitionGroup::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DynamicPartitionGroup& DynamicPartitionGroup::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_DynamicPartitionGroup_update_5fengine_2fupdate_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void DynamicPartitionGroup::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.DynamicPartitionGroup)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  partition_names_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmptyNoArena();
  }
  size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* DynamicPartitionGroup::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_size(&has_bits);
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string partition_names = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(add_partition_names(), ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 26);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool DynamicPartitionGroup::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.DynamicPartitionGroup)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 size = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string partition_names = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->add_partition_names()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.DynamicPartitionGroup)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.DynamicPartitionGroup)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void DynamicPartitionGroup::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.DynamicPartitionGroup)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional uint64 size = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->size(), output);
  }

  // repeated string partition_names = 3;
  for (int i = 0, n = this->partition_names_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteString(
      3, this->partition_names(i), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.DynamicPartitionGroup)
}

size_t DynamicPartitionGroup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.DynamicPartitionGroup)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required string name = 1;
  if (has_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->name());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string partition_names = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->partition_names_size());
  for (int i = 0, n = this->partition_names_size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      this->partition_names(i));
  }

  // optional uint64 size = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->size());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DynamicPartitionGroup::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DynamicPartitionGroup*>(
      &from));
}

void DynamicPartitionGroup::MergeFrom(const DynamicPartitionGroup& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.DynamicPartitionGroup)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  partition_names_.MergeFrom(from.partition_names_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      size_ = from.size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DynamicPartitionGroup::CopyFrom(const DynamicPartitionGroup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.DynamicPartitionGroup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DynamicPartitionGroup::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void DynamicPartitionGroup::InternalSwap(DynamicPartitionGroup* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  partition_names_.InternalSwap(CastToBase(&other->partition_names_));
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(size_, other->size_);
}

std::string DynamicPartitionGroup::GetTypeName() const {
  return "chromeos_update_engine.DynamicPartitionGroup";
}


// ===================================================================

void DynamicPartitionMetadata::InitAsDefaultInstance() {
}
class DynamicPartitionMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<DynamicPartitionMetadata>()._has_bits_);
  static void set_has_snapshot_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vabc_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_vabc_compression_param(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cow_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

DynamicPartitionMetadata::DynamicPartitionMetadata()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.DynamicPartitionMetadata)
}
DynamicPartitionMetadata::DynamicPartitionMetadata(const DynamicPartitionMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      groups_(from.groups_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  vabc_compression_param_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_vabc_compression_param()) {
    vabc_compression_param_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.vabc_compression_param_);
  }
  ::memcpy(&snapshot_enabled_, &from.snapshot_enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&cow_version_) -
    reinterpret_cast<char*>(&snapshot_enabled_)) + sizeof(cow_version_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.DynamicPartitionMetadata)
}

void DynamicPartitionMetadata::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_DynamicPartitionMetadata_update_5fengine_2fupdate_5fmetadata_2eproto.base);
  vabc_compression_param_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&snapshot_enabled_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&cow_version_) -
      reinterpret_cast<char*>(&snapshot_enabled_)) + sizeof(cow_version_));
}

DynamicPartitionMetadata::~DynamicPartitionMetadata() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.DynamicPartitionMetadata)
  SharedDtor();
}

void DynamicPartitionMetadata::SharedDtor() {
  vabc_compression_param_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DynamicPartitionMetadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DynamicPartitionMetadata& DynamicPartitionMetadata::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_DynamicPartitionMetadata_update_5fengine_2fupdate_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void DynamicPartitionMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.DynamicPartitionMetadata)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  groups_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    vabc_compression_param_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&snapshot_enabled_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cow_version_) -
        reinterpret_cast<char*>(&snapshot_enabled_)) + sizeof(cow_version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* DynamicPartitionMetadata::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_groups(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      // optional bool snapshot_enabled = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_snapshot_enabled(&has_bits);
          snapshot_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool vabc_enabled = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_vabc_enabled(&has_bits);
          vabc_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string vabc_compression_param = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_vabc_compression_param(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 cow_version = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_cow_version(&has_bits);
          cow_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool DynamicPartitionMetadata::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.DynamicPartitionMetadata)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_groups()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool snapshot_enabled = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_snapshot_enabled(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &snapshot_enabled_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool vabc_enabled = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_vabc_enabled(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &vabc_enabled_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string vabc_compression_param = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_vabc_compression_param()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 cow_version = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_cow_version(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cow_version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.DynamicPartitionMetadata)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.DynamicPartitionMetadata)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void DynamicPartitionMetadata::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.DynamicPartitionMetadata)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->groups_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1,
      this->groups(static_cast<int>(i)),
      output);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool snapshot_enabled = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(2, this->snapshot_enabled(), output);
  }

  // optional bool vabc_enabled = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(3, this->vabc_enabled(), output);
  }

  // optional string vabc_compression_param = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->vabc_compression_param(), output);
  }

  // optional uint32 cow_version = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->cow_version(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.DynamicPartitionMetadata)
}

size_t DynamicPartitionMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.DynamicPartitionMetadata)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->groups_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->groups(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string vabc_compression_param = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->vabc_compression_param());
    }

    // optional bool snapshot_enabled = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool vabc_enabled = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional uint32 cow_version = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->cow_version());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DynamicPartitionMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DynamicPartitionMetadata*>(
      &from));
}

void DynamicPartitionMetadata::MergeFrom(const DynamicPartitionMetadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.DynamicPartitionMetadata)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  groups_.MergeFrom(from.groups_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      vabc_compression_param_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.vabc_compression_param_);
    }
    if (cached_has_bits & 0x00000002u) {
      snapshot_enabled_ = from.snapshot_enabled_;
    }
    if (cached_has_bits & 0x00000004u) {
      vabc_enabled_ = from.vabc_enabled_;
    }
    if (cached_has_bits & 0x00000008u) {
      cow_version_ = from.cow_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DynamicPartitionMetadata::CopyFrom(const DynamicPartitionMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.DynamicPartitionMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DynamicPartitionMetadata::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->groups())) return false;
  return true;
}

void DynamicPartitionMetadata::InternalSwap(DynamicPartitionMetadata* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&groups_)->InternalSwap(CastToBase(&other->groups_));
  vabc_compression_param_.Swap(&other->vabc_compression_param_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(snapshot_enabled_, other->snapshot_enabled_);
  swap(vabc_enabled_, other->vabc_enabled_);
  swap(cow_version_, other->cow_version_);
}

std::string DynamicPartitionMetadata::GetTypeName() const {
  return "chromeos_update_engine.DynamicPartitionMetadata";
}


// ===================================================================

void ApexInfo::InitAsDefaultInstance() {
}
class ApexInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ApexInfo>()._has_bits_);
  static void set_has_package_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_compressed(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_decompressed_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ApexInfo::ApexInfo()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.ApexInfo)
}
ApexInfo::ApexInfo(const ApexInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  package_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_package_name()) {
    package_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.package_name_);
  }
  ::memcpy(&version_, &from.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_compressed_) -
    reinterpret_cast<char*>(&version_)) + sizeof(is_compressed_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.ApexInfo)
}

void ApexInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ApexInfo_update_5fengine_2fupdate_5fmetadata_2eproto.base);
  package_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&version_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_compressed_) -
      reinterpret_cast<char*>(&version_)) + sizeof(is_compressed_));
}

ApexInfo::~ApexInfo() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.ApexInfo)
  SharedDtor();
}

void ApexInfo::SharedDtor() {
  package_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ApexInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ApexInfo& ApexInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ApexInfo_update_5fengine_2fupdate_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void ApexInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.ApexInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    package_name_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_compressed_) -
        reinterpret_cast<char*>(&version_)) + sizeof(is_compressed_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ApexInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string package_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_package_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_compressed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_is_compressed(&has_bits);
          is_compressed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 decompressed_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_decompressed_size(&has_bits);
          decompressed_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ApexInfo::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.ApexInfo)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_name = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_package_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 version = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_version(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool is_compressed = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_is_compressed(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_compressed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 decompressed_size = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_decompressed_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &decompressed_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.ApexInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.ApexInfo)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ApexInfo::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.ApexInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string package_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->package_name(), output);
  }

  // optional int64 version = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(2, this->version(), output);
  }

  // optional bool is_compressed = 3;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(3, this->is_compressed(), output);
  }

  // optional int64 decompressed_size = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(4, this->decompressed_size(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.ApexInfo)
}

size_t ApexInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.ApexInfo)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string package_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->package_name());
    }

    // optional int64 version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->version());
    }

    // optional int64 decompressed_size = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->decompressed_size());
    }

    // optional bool is_compressed = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ApexInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ApexInfo*>(
      &from));
}

void ApexInfo::MergeFrom(const ApexInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.ApexInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      package_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.package_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      version_ = from.version_;
    }
    if (cached_has_bits & 0x00000004u) {
      decompressed_size_ = from.decompressed_size_;
    }
    if (cached_has_bits & 0x00000008u) {
      is_compressed_ = from.is_compressed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ApexInfo::CopyFrom(const ApexInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.ApexInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApexInfo::IsInitialized() const {
  return true;
}

void ApexInfo::InternalSwap(ApexInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  package_name_.Swap(&other->package_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(version_, other->version_);
  swap(decompressed_size_, other->decompressed_size_);
  swap(is_compressed_, other->is_compressed_);
}

std::string ApexInfo::GetTypeName() const {
  return "chromeos_update_engine.ApexInfo";
}


// ===================================================================

void ApexMetadata::InitAsDefaultInstance() {
}
class ApexMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<ApexMetadata>()._has_bits_);
};

ApexMetadata::ApexMetadata()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.ApexMetadata)
}
ApexMetadata::ApexMetadata(const ApexMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      apex_info_(from.apex_info_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.ApexMetadata)
}

void ApexMetadata::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ApexMetadata_update_5fengine_2fupdate_5fmetadata_2eproto.base);
}

ApexMetadata::~ApexMetadata() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.ApexMetadata)
  SharedDtor();
}

void ApexMetadata::SharedDtor() {
}

void ApexMetadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ApexMetadata& ApexMetadata::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ApexMetadata_update_5fengine_2fupdate_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void ApexMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.ApexMetadata)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  apex_info_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ApexMetadata::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .chromeos_update_engine.ApexInfo apex_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_apex_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ApexMetadata::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.ApexMetadata)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .chromeos_update_engine.ApexInfo apex_info = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_apex_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.ApexMetadata)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.ApexMetadata)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ApexMetadata::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.ApexMetadata)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.ApexInfo apex_info = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->apex_info_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1,
      this->apex_info(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.ApexMetadata)
}

size_t ApexMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.ApexMetadata)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.ApexInfo apex_info = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->apex_info_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->apex_info(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ApexMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ApexMetadata*>(
      &from));
}

void ApexMetadata::MergeFrom(const ApexMetadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.ApexMetadata)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  apex_info_.MergeFrom(from.apex_info_);
}

void ApexMetadata::CopyFrom(const ApexMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.ApexMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApexMetadata::IsInitialized() const {
  return true;
}

void ApexMetadata::InternalSwap(ApexMetadata* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&apex_info_)->InternalSwap(CastToBase(&other->apex_info_));
}

std::string ApexMetadata::GetTypeName() const {
  return "chromeos_update_engine.ApexMetadata";
}


// ===================================================================

void DeltaArchiveManifest::InitAsDefaultInstance() {
  ::chromeos_update_engine::_DeltaArchiveManifest_default_instance_._instance.get_mutable()->old_kernel_info_ = const_cast< ::chromeos_update_engine::PartitionInfo*>(
      ::chromeos_update_engine::PartitionInfo::internal_default_instance());
  ::chromeos_update_engine::_DeltaArchiveManifest_default_instance_._instance.get_mutable()->new_kernel_info_ = const_cast< ::chromeos_update_engine::PartitionInfo*>(
      ::chromeos_update_engine::PartitionInfo::internal_default_instance());
  ::chromeos_update_engine::_DeltaArchiveManifest_default_instance_._instance.get_mutable()->old_rootfs_info_ = const_cast< ::chromeos_update_engine::PartitionInfo*>(
      ::chromeos_update_engine::PartitionInfo::internal_default_instance());
  ::chromeos_update_engine::_DeltaArchiveManifest_default_instance_._instance.get_mutable()->new_rootfs_info_ = const_cast< ::chromeos_update_engine::PartitionInfo*>(
      ::chromeos_update_engine::PartitionInfo::internal_default_instance());
  ::chromeos_update_engine::_DeltaArchiveManifest_default_instance_._instance.get_mutable()->old_image_info_ = const_cast< ::chromeos_update_engine::ImageInfo*>(
      ::chromeos_update_engine::ImageInfo::internal_default_instance());
  ::chromeos_update_engine::_DeltaArchiveManifest_default_instance_._instance.get_mutable()->new_image_info_ = const_cast< ::chromeos_update_engine::ImageInfo*>(
      ::chromeos_update_engine::ImageInfo::internal_default_instance());
  ::chromeos_update_engine::_DeltaArchiveManifest_default_instance_._instance.get_mutable()->dynamic_partition_metadata_ = const_cast< ::chromeos_update_engine::DynamicPartitionMetadata*>(
      ::chromeos_update_engine::DynamicPartitionMetadata::internal_default_instance());
}
class DeltaArchiveManifest::_Internal {
 public:
  using HasBits = decltype(std::declval<DeltaArchiveManifest>()._has_bits_);
  static void set_has_block_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_signatures_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_signatures_size(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::chromeos_update_engine::PartitionInfo& old_kernel_info(const DeltaArchiveManifest* msg);
  static void set_has_old_kernel_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::chromeos_update_engine::PartitionInfo& new_kernel_info(const DeltaArchiveManifest* msg);
  static void set_has_new_kernel_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::chromeos_update_engine::PartitionInfo& old_rootfs_info(const DeltaArchiveManifest* msg);
  static void set_has_old_rootfs_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::chromeos_update_engine::PartitionInfo& new_rootfs_info(const DeltaArchiveManifest* msg);
  static void set_has_new_rootfs_info(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::chromeos_update_engine::ImageInfo& old_image_info(const DeltaArchiveManifest* msg);
  static void set_has_old_image_info(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::chromeos_update_engine::ImageInfo& new_image_info(const DeltaArchiveManifest* msg);
  static void set_has_new_image_info(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_minor_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_max_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::chromeos_update_engine::DynamicPartitionMetadata& dynamic_partition_metadata(const DeltaArchiveManifest* msg);
  static void set_has_dynamic_partition_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_partial_update(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

const ::chromeos_update_engine::PartitionInfo&
DeltaArchiveManifest::_Internal::old_kernel_info(const DeltaArchiveManifest* msg) {
  return *msg->old_kernel_info_;
}
const ::chromeos_update_engine::PartitionInfo&
DeltaArchiveManifest::_Internal::new_kernel_info(const DeltaArchiveManifest* msg) {
  return *msg->new_kernel_info_;
}
const ::chromeos_update_engine::PartitionInfo&
DeltaArchiveManifest::_Internal::old_rootfs_info(const DeltaArchiveManifest* msg) {
  return *msg->old_rootfs_info_;
}
const ::chromeos_update_engine::PartitionInfo&
DeltaArchiveManifest::_Internal::new_rootfs_info(const DeltaArchiveManifest* msg) {
  return *msg->new_rootfs_info_;
}
const ::chromeos_update_engine::ImageInfo&
DeltaArchiveManifest::_Internal::old_image_info(const DeltaArchiveManifest* msg) {
  return *msg->old_image_info_;
}
const ::chromeos_update_engine::ImageInfo&
DeltaArchiveManifest::_Internal::new_image_info(const DeltaArchiveManifest* msg) {
  return *msg->new_image_info_;
}
const ::chromeos_update_engine::DynamicPartitionMetadata&
DeltaArchiveManifest::_Internal::dynamic_partition_metadata(const DeltaArchiveManifest* msg) {
  return *msg->dynamic_partition_metadata_;
}
DeltaArchiveManifest::DeltaArchiveManifest()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.DeltaArchiveManifest)
}
DeltaArchiveManifest::DeltaArchiveManifest(const DeltaArchiveManifest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      install_operations_(from.install_operations_),
      kernel_install_operations_(from.kernel_install_operations_),
      partitions_(from.partitions_),
      apex_info_(from.apex_info_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_old_kernel_info()) {
    old_kernel_info_ = new ::chromeos_update_engine::PartitionInfo(*from.old_kernel_info_);
  } else {
    old_kernel_info_ = nullptr;
  }
  if (from.has_new_kernel_info()) {
    new_kernel_info_ = new ::chromeos_update_engine::PartitionInfo(*from.new_kernel_info_);
  } else {
    new_kernel_info_ = nullptr;
  }
  if (from.has_old_rootfs_info()) {
    old_rootfs_info_ = new ::chromeos_update_engine::PartitionInfo(*from.old_rootfs_info_);
  } else {
    old_rootfs_info_ = nullptr;
  }
  if (from.has_new_rootfs_info()) {
    new_rootfs_info_ = new ::chromeos_update_engine::PartitionInfo(*from.new_rootfs_info_);
  } else {
    new_rootfs_info_ = nullptr;
  }
  if (from.has_old_image_info()) {
    old_image_info_ = new ::chromeos_update_engine::ImageInfo(*from.old_image_info_);
  } else {
    old_image_info_ = nullptr;
  }
  if (from.has_new_image_info()) {
    new_image_info_ = new ::chromeos_update_engine::ImageInfo(*from.new_image_info_);
  } else {
    new_image_info_ = nullptr;
  }
  if (from.has_dynamic_partition_metadata()) {
    dynamic_partition_metadata_ = new ::chromeos_update_engine::DynamicPartitionMetadata(*from.dynamic_partition_metadata_);
  } else {
    dynamic_partition_metadata_ = nullptr;
  }
  ::memcpy(&signatures_offset_, &from.signatures_offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&block_size_) -
    reinterpret_cast<char*>(&signatures_offset_)) + sizeof(block_size_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.DeltaArchiveManifest)
}

void DeltaArchiveManifest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_DeltaArchiveManifest_update_5fengine_2fupdate_5fmetadata_2eproto.base);
  ::memset(&old_kernel_info_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&partial_update_) -
      reinterpret_cast<char*>(&old_kernel_info_)) + sizeof(partial_update_));
  block_size_ = 4096u;
}

DeltaArchiveManifest::~DeltaArchiveManifest() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.DeltaArchiveManifest)
  SharedDtor();
}

void DeltaArchiveManifest::SharedDtor() {
  if (this != internal_default_instance()) delete old_kernel_info_;
  if (this != internal_default_instance()) delete new_kernel_info_;
  if (this != internal_default_instance()) delete old_rootfs_info_;
  if (this != internal_default_instance()) delete new_rootfs_info_;
  if (this != internal_default_instance()) delete old_image_info_;
  if (this != internal_default_instance()) delete new_image_info_;
  if (this != internal_default_instance()) delete dynamic_partition_metadata_;
}

void DeltaArchiveManifest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DeltaArchiveManifest& DeltaArchiveManifest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_DeltaArchiveManifest_update_5fengine_2fupdate_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void DeltaArchiveManifest::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.DeltaArchiveManifest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  install_operations_.Clear();
  kernel_install_operations_.Clear();
  partitions_.Clear();
  apex_info_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(old_kernel_info_ != nullptr);
      old_kernel_info_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(new_kernel_info_ != nullptr);
      new_kernel_info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(old_rootfs_info_ != nullptr);
      old_rootfs_info_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(new_rootfs_info_ != nullptr);
      new_rootfs_info_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(old_image_info_ != nullptr);
      old_image_info_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(new_image_info_ != nullptr);
      new_image_info_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(dynamic_partition_metadata_ != nullptr);
      dynamic_partition_metadata_->Clear();
    }
  }
  signatures_offset_ = PROTOBUF_ULONGLONG(0);
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&signatures_size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&partial_update_) -
        reinterpret_cast<char*>(&signatures_size_)) + sizeof(partial_update_));
    block_size_ = 4096u;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* DeltaArchiveManifest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .chromeos_update_engine.InstallOperation install_operations = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_install_operations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      // repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_kernel_install_operations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      // optional uint32 block_size = 3 [default = 4096];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_block_size(&has_bits);
          block_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 signatures_offset = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_signatures_offset(&has_bits);
          signatures_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 signatures_size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_signatures_size(&has_bits);
          signatures_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .chromeos_update_engine.PartitionInfo old_kernel_info = 6 [deprecated = true];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(mutable_old_kernel_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .chromeos_update_engine.PartitionInfo new_kernel_info = 7 [deprecated = true];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(mutable_new_kernel_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .chromeos_update_engine.PartitionInfo old_rootfs_info = 8 [deprecated = true];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(mutable_old_rootfs_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .chromeos_update_engine.PartitionInfo new_rootfs_info = 9 [deprecated = true];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(mutable_new_rootfs_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .chromeos_update_engine.ImageInfo old_image_info = 10 [deprecated = true];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(mutable_old_image_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .chromeos_update_engine.ImageInfo new_image_info = 11 [deprecated = true];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(mutable_new_image_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 minor_version = 12 [default = 0];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_minor_version(&has_bits);
          minor_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .chromeos_update_engine.PartitionUpdate partitions = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_partitions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 106);
        } else goto handle_unusual;
        continue;
      // optional int64 max_timestamp = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_max_timestamp(&has_bits);
          max_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 122)) {
          ptr = ctx->ParseMessage(mutable_dynamic_partition_metadata(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool partial_update = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          _Internal::set_has_partial_update(&has_bits);
          partial_update_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .chromeos_update_engine.ApexInfo apex_info = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 138)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(add_apex_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint16>(ptr) == 394);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool DeltaArchiveManifest::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.DeltaArchiveManifest)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .chromeos_update_engine.InstallOperation install_operations = 1 [deprecated = true];
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_install_operations()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2 [deprecated = true];
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_kernel_install_operations()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 block_size = 3 [default = 4096];
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_block_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &block_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 signatures_offset = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_signatures_offset(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &signatures_offset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 signatures_size = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_signatures_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &signatures_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chromeos_update_engine.PartitionInfo old_kernel_info = 6 [deprecated = true];
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_old_kernel_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chromeos_update_engine.PartitionInfo new_kernel_info = 7 [deprecated = true];
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (58 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_new_kernel_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chromeos_update_engine.PartitionInfo old_rootfs_info = 8 [deprecated = true];
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (66 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_old_rootfs_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chromeos_update_engine.PartitionInfo new_rootfs_info = 9 [deprecated = true];
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (74 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_new_rootfs_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chromeos_update_engine.ImageInfo old_image_info = 10 [deprecated = true];
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (82 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_old_image_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chromeos_update_engine.ImageInfo new_image_info = 11 [deprecated = true];
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (90 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_new_image_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 minor_version = 12 [default = 0];
      case 12: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (96 & 0xFF)) {
          _Internal::set_has_minor_version(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &minor_version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .chromeos_update_engine.PartitionUpdate partitions = 13;
      case 13: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (106 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_partitions()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 max_timestamp = 14;
      case 14: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (112 & 0xFF)) {
          _Internal::set_has_max_timestamp(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &max_timestamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;
      case 15: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (122 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_dynamic_partition_metadata()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool partial_update = 16;
      case 16: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (128 & 0xFF)) {
          _Internal::set_has_partial_update(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &partial_update_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .chromeos_update_engine.ApexInfo apex_info = 17;
      case 17: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (138 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_apex_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.DeltaArchiveManifest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.DeltaArchiveManifest)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void DeltaArchiveManifest::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.DeltaArchiveManifest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.InstallOperation install_operations = 1 [deprecated = true];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->install_operations_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1,
      this->install_operations(static_cast<int>(i)),
      output);
  }

  // repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2 [deprecated = true];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->kernel_install_operations_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2,
      this->kernel_install_operations(static_cast<int>(i)),
      output);
  }

  cached_has_bits = _has_bits_[0];
  // optional uint32 block_size = 3 [default = 4096];
  if (cached_has_bits & 0x00001000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->block_size(), output);
  }

  // optional uint64 signatures_offset = 4;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(4, this->signatures_offset(), output);
  }

  // optional uint64 signatures_size = 5;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(5, this->signatures_size(), output);
  }

  // optional .chromeos_update_engine.PartitionInfo old_kernel_info = 6 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      6, _Internal::old_kernel_info(this), output);
  }

  // optional .chromeos_update_engine.PartitionInfo new_kernel_info = 7 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      7, _Internal::new_kernel_info(this), output);
  }

  // optional .chromeos_update_engine.PartitionInfo old_rootfs_info = 8 [deprecated = true];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      8, _Internal::old_rootfs_info(this), output);
  }

  // optional .chromeos_update_engine.PartitionInfo new_rootfs_info = 9 [deprecated = true];
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      9, _Internal::new_rootfs_info(this), output);
  }

  // optional .chromeos_update_engine.ImageInfo old_image_info = 10 [deprecated = true];
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      10, _Internal::old_image_info(this), output);
  }

  // optional .chromeos_update_engine.ImageInfo new_image_info = 11 [deprecated = true];
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      11, _Internal::new_image_info(this), output);
  }

  // optional uint32 minor_version = 12 [default = 0];
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(12, this->minor_version(), output);
  }

  // repeated .chromeos_update_engine.PartitionUpdate partitions = 13;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->partitions_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      13,
      this->partitions(static_cast<int>(i)),
      output);
  }

  // optional int64 max_timestamp = 14;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(14, this->max_timestamp(), output);
  }

  // optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      15, _Internal::dynamic_partition_metadata(this), output);
  }

  // optional bool partial_update = 16;
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(16, this->partial_update(), output);
  }

  // repeated .chromeos_update_engine.ApexInfo apex_info = 17;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->apex_info_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      17,
      this->apex_info(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.DeltaArchiveManifest)
}

size_t DeltaArchiveManifest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.DeltaArchiveManifest)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.InstallOperation install_operations = 1 [deprecated = true];
  {
    unsigned int count = static_cast<unsigned int>(this->install_operations_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->install_operations(static_cast<int>(i)));
    }
  }

  // repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2 [deprecated = true];
  {
    unsigned int count = static_cast<unsigned int>(this->kernel_install_operations_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->kernel_install_operations(static_cast<int>(i)));
    }
  }

  // repeated .chromeos_update_engine.PartitionUpdate partitions = 13;
  {
    unsigned int count = static_cast<unsigned int>(this->partitions_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->partitions(static_cast<int>(i)));
    }
  }

  // repeated .chromeos_update_engine.ApexInfo apex_info = 17;
  {
    unsigned int count = static_cast<unsigned int>(this->apex_info_size());
    total_size += 2UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->apex_info(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .chromeos_update_engine.PartitionInfo old_kernel_info = 6 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *old_kernel_info_);
    }

    // optional .chromeos_update_engine.PartitionInfo new_kernel_info = 7 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *new_kernel_info_);
    }

    // optional .chromeos_update_engine.PartitionInfo old_rootfs_info = 8 [deprecated = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *old_rootfs_info_);
    }

    // optional .chromeos_update_engine.PartitionInfo new_rootfs_info = 9 [deprecated = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *new_rootfs_info_);
    }

    // optional .chromeos_update_engine.ImageInfo old_image_info = 10 [deprecated = true];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *old_image_info_);
    }

    // optional .chromeos_update_engine.ImageInfo new_image_info = 11 [deprecated = true];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *new_image_info_);
    }

    // optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *dynamic_partition_metadata_);
    }

    // optional uint64 signatures_offset = 4;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->signatures_offset());
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional uint64 signatures_size = 5;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->signatures_size());
    }

    // optional int64 max_timestamp = 14;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->max_timestamp());
    }

    // optional uint32 minor_version = 12 [default = 0];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->minor_version());
    }

    // optional bool partial_update = 16;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + 1;
    }

    // optional uint32 block_size = 3 [default = 4096];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->block_size());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeltaArchiveManifest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DeltaArchiveManifest*>(
      &from));
}

void DeltaArchiveManifest::MergeFrom(const DeltaArchiveManifest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.DeltaArchiveManifest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  install_operations_.MergeFrom(from.install_operations_);
  kernel_install_operations_.MergeFrom(from.kernel_install_operations_);
  partitions_.MergeFrom(from.partitions_);
  apex_info_.MergeFrom(from.apex_info_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_old_kernel_info()->::chromeos_update_engine::PartitionInfo::MergeFrom(from.old_kernel_info());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_new_kernel_info()->::chromeos_update_engine::PartitionInfo::MergeFrom(from.new_kernel_info());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_old_rootfs_info()->::chromeos_update_engine::PartitionInfo::MergeFrom(from.old_rootfs_info());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_new_rootfs_info()->::chromeos_update_engine::PartitionInfo::MergeFrom(from.new_rootfs_info());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_old_image_info()->::chromeos_update_engine::ImageInfo::MergeFrom(from.old_image_info());
    }
    if (cached_has_bits & 0x00000020u) {
      mutable_new_image_info()->::chromeos_update_engine::ImageInfo::MergeFrom(from.new_image_info());
    }
    if (cached_has_bits & 0x00000040u) {
      mutable_dynamic_partition_metadata()->::chromeos_update_engine::DynamicPartitionMetadata::MergeFrom(from.dynamic_partition_metadata());
    }
    if (cached_has_bits & 0x00000080u) {
      signatures_offset_ = from.signatures_offset_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      signatures_size_ = from.signatures_size_;
    }
    if (cached_has_bits & 0x00000200u) {
      max_timestamp_ = from.max_timestamp_;
    }
    if (cached_has_bits & 0x00000400u) {
      minor_version_ = from.minor_version_;
    }
    if (cached_has_bits & 0x00000800u) {
      partial_update_ = from.partial_update_;
    }
    if (cached_has_bits & 0x00001000u) {
      block_size_ = from.block_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DeltaArchiveManifest::CopyFrom(const DeltaArchiveManifest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.DeltaArchiveManifest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeltaArchiveManifest::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->install_operations())) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->kernel_install_operations())) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->partitions())) return false;
  if (has_dynamic_partition_metadata()) {
    if (!this->dynamic_partition_metadata_->IsInitialized()) return false;
  }
  return true;
}

void DeltaArchiveManifest::InternalSwap(DeltaArchiveManifest* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&install_operations_)->InternalSwap(CastToBase(&other->install_operations_));
  CastToBase(&kernel_install_operations_)->InternalSwap(CastToBase(&other->kernel_install_operations_));
  CastToBase(&partitions_)->InternalSwap(CastToBase(&other->partitions_));
  CastToBase(&apex_info_)->InternalSwap(CastToBase(&other->apex_info_));
  swap(old_kernel_info_, other->old_kernel_info_);
  swap(new_kernel_info_, other->new_kernel_info_);
  swap(old_rootfs_info_, other->old_rootfs_info_);
  swap(new_rootfs_info_, other->new_rootfs_info_);
  swap(old_image_info_, other->old_image_info_);
  swap(new_image_info_, other->new_image_info_);
  swap(dynamic_partition_metadata_, other->dynamic_partition_metadata_);
  swap(signatures_offset_, other->signatures_offset_);
  swap(signatures_size_, other->signatures_size_);
  swap(max_timestamp_, other->max_timestamp_);
  swap(minor_version_, other->minor_version_);
  swap(partial_update_, other->partial_update_);
  swap(block_size_, other->block_size_);
}

std::string DeltaArchiveManifest::GetTypeName() const {
  return "chromeos_update_engine.DeltaArchiveManifest";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace chromeos_update_engine
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::Extent* Arena::CreateMaybeMessage< ::chromeos_update_engine::Extent >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::Extent >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::Signatures_Signature* Arena::CreateMaybeMessage< ::chromeos_update_engine::Signatures_Signature >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::Signatures_Signature >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::Signatures* Arena::CreateMaybeMessage< ::chromeos_update_engine::Signatures >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::Signatures >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::PartitionInfo* Arena::CreateMaybeMessage< ::chromeos_update_engine::PartitionInfo >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::PartitionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::ImageInfo* Arena::CreateMaybeMessage< ::chromeos_update_engine::ImageInfo >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::ImageInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::InstallOperation* Arena::CreateMaybeMessage< ::chromeos_update_engine::InstallOperation >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::InstallOperation >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::CowMergeOperation* Arena::CreateMaybeMessage< ::chromeos_update_engine::CowMergeOperation >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::CowMergeOperation >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::PartitionUpdate* Arena::CreateMaybeMessage< ::chromeos_update_engine::PartitionUpdate >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::PartitionUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::DynamicPartitionGroup* Arena::CreateMaybeMessage< ::chromeos_update_engine::DynamicPartitionGroup >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::DynamicPartitionGroup >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::DynamicPartitionMetadata* Arena::CreateMaybeMessage< ::chromeos_update_engine::DynamicPartitionMetadata >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::DynamicPartitionMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::ApexInfo* Arena::CreateMaybeMessage< ::chromeos_update_engine::ApexInfo >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::ApexInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::ApexMetadata* Arena::CreateMaybeMessage< ::chromeos_update_engine::ApexMetadata >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::ApexMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::DeltaArchiveManifest* Arena::CreateMaybeMessage< ::chromeos_update_engine::DeltaArchiveManifest >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::DeltaArchiveManifest >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
