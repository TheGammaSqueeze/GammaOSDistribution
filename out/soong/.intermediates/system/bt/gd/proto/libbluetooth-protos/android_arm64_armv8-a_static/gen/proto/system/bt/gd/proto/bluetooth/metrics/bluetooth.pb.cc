// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: system/bt/gd/proto/bluetooth/metrics/bluetooth.proto

#include "system/bt/gd/proto/bluetooth/metrics/bluetooth.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_A2DPSession_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_BluetoothSession_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DeviceInfo_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_HeadsetProfileConnectionStats_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_PairEvent_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ProfileConnectionStats_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RFCommSession_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ScanEvent_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_WakeEvent_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
namespace bluetooth {
namespace metrics {
namespace BluetoothMetricsProto {
class BluetoothLogDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<BluetoothLog> _instance;
} _BluetoothLog_default_instance_;
class DeviceInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DeviceInfo> _instance;
} _DeviceInfo_default_instance_;
class BluetoothSessionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<BluetoothSession> _instance;
} _BluetoothSession_default_instance_;
class RFCommSessionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RFCommSession> _instance;
} _RFCommSession_default_instance_;
class A2DPSessionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<A2DPSession> _instance;
} _A2DPSession_default_instance_;
class PairEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PairEvent> _instance;
} _PairEvent_default_instance_;
class WakeEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<WakeEvent> _instance;
} _WakeEvent_default_instance_;
class ScanEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ScanEvent> _instance;
} _ScanEvent_default_instance_;
class ProfileConnectionStatsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ProfileConnectionStats> _instance;
} _ProfileConnectionStats_default_instance_;
class HeadsetProfileConnectionStatsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<HeadsetProfileConnectionStats> _instance;
} _HeadsetProfileConnectionStats_default_instance_;
}  // namespace BluetoothMetricsProto
}  // namespace metrics
}  // namespace bluetooth
static void InitDefaultsscc_info_A2DPSession_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::bluetooth::metrics::BluetoothMetricsProto::_A2DPSession_default_instance_;
    new (ptr) ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_A2DPSession_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_A2DPSession_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto}, {}};

static void InitDefaultsscc_info_BluetoothLog_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::bluetooth::metrics::BluetoothMetricsProto::_BluetoothLog_default_instance_;
    new (ptr) ::bluetooth::metrics::BluetoothMetricsProto::BluetoothLog();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::bluetooth::metrics::BluetoothMetricsProto::BluetoothLog::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<6> scc_info_BluetoothLog_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 6, InitDefaultsscc_info_BluetoothLog_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto}, {
      &scc_info_BluetoothSession_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto.base,
      &scc_info_PairEvent_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto.base,
      &scc_info_WakeEvent_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto.base,
      &scc_info_ScanEvent_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto.base,
      &scc_info_ProfileConnectionStats_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto.base,
      &scc_info_HeadsetProfileConnectionStats_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto.base,}};

static void InitDefaultsscc_info_BluetoothSession_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::bluetooth::metrics::BluetoothMetricsProto::_BluetoothSession_default_instance_;
    new (ptr) ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_BluetoothSession_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, InitDefaultsscc_info_BluetoothSession_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto}, {
      &scc_info_DeviceInfo_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto.base,
      &scc_info_RFCommSession_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto.base,
      &scc_info_A2DPSession_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto.base,}};

static void InitDefaultsscc_info_DeviceInfo_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::bluetooth::metrics::BluetoothMetricsProto::_DeviceInfo_default_instance_;
    new (ptr) ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DeviceInfo_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_DeviceInfo_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto}, {}};

static void InitDefaultsscc_info_HeadsetProfileConnectionStats_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::bluetooth::metrics::BluetoothMetricsProto::_HeadsetProfileConnectionStats_default_instance_;
    new (ptr) ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_HeadsetProfileConnectionStats_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_HeadsetProfileConnectionStats_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto}, {}};

static void InitDefaultsscc_info_PairEvent_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::bluetooth::metrics::BluetoothMetricsProto::_PairEvent_default_instance_;
    new (ptr) ::bluetooth::metrics::BluetoothMetricsProto::PairEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::bluetooth::metrics::BluetoothMetricsProto::PairEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_PairEvent_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_PairEvent_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto}, {
      &scc_info_DeviceInfo_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto.base,}};

static void InitDefaultsscc_info_ProfileConnectionStats_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::bluetooth::metrics::BluetoothMetricsProto::_ProfileConnectionStats_default_instance_;
    new (ptr) ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ProfileConnectionStats_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_ProfileConnectionStats_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto}, {}};

static void InitDefaultsscc_info_RFCommSession_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::bluetooth::metrics::BluetoothMetricsProto::_RFCommSession_default_instance_;
    new (ptr) ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RFCommSession_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_RFCommSession_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto}, {}};

static void InitDefaultsscc_info_ScanEvent_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::bluetooth::metrics::BluetoothMetricsProto::_ScanEvent_default_instance_;
    new (ptr) ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ScanEvent_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_ScanEvent_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto}, {}};

static void InitDefaultsscc_info_WakeEvent_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::bluetooth::metrics::BluetoothMetricsProto::_WakeEvent_default_instance_;
    new (ptr) ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_WakeEvent_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_WakeEvent_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto}, {}};

namespace bluetooth {
namespace metrics {
namespace BluetoothMetricsProto {
bool DeviceInfo_DeviceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceInfo_DeviceType_strings[4] = {};

static const char DeviceInfo_DeviceType_names[] =
  "DEVICE_TYPE_BREDR"
  "DEVICE_TYPE_DUMO"
  "DEVICE_TYPE_LE"
  "DEVICE_TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceInfo_DeviceType_entries[] = {
  { {DeviceInfo_DeviceType_names + 0, 17}, 1 },
  { {DeviceInfo_DeviceType_names + 17, 16}, 3 },
  { {DeviceInfo_DeviceType_names + 33, 14}, 2 },
  { {DeviceInfo_DeviceType_names + 47, 19}, 0 },
};

static const int DeviceInfo_DeviceType_entries_by_number[] = {
  3, // 0 -> DEVICE_TYPE_UNKNOWN
  0, // 1 -> DEVICE_TYPE_BREDR
  2, // 2 -> DEVICE_TYPE_LE
  1, // 3 -> DEVICE_TYPE_DUMO
};

const std::string& DeviceInfo_DeviceType_Name(
    DeviceInfo_DeviceType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceInfo_DeviceType_entries,
          DeviceInfo_DeviceType_entries_by_number,
          4, DeviceInfo_DeviceType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceInfo_DeviceType_entries,
      DeviceInfo_DeviceType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceInfo_DeviceType_strings[idx].get();
}
bool DeviceInfo_DeviceType_Parse(
    const std::string& name, DeviceInfo_DeviceType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceInfo_DeviceType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DeviceInfo_DeviceType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr DeviceInfo_DeviceType DeviceInfo::DEVICE_TYPE_UNKNOWN;
constexpr DeviceInfo_DeviceType DeviceInfo::DEVICE_TYPE_BREDR;
constexpr DeviceInfo_DeviceType DeviceInfo::DEVICE_TYPE_LE;
constexpr DeviceInfo_DeviceType DeviceInfo::DEVICE_TYPE_DUMO;
constexpr DeviceInfo_DeviceType DeviceInfo::DeviceType_MIN;
constexpr DeviceInfo_DeviceType DeviceInfo::DeviceType_MAX;
constexpr int DeviceInfo::DeviceType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool BluetoothSession_ConnectionTechnologyType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BluetoothSession_ConnectionTechnologyType_strings[3] = {};

static const char BluetoothSession_ConnectionTechnologyType_names[] =
  "CONNECTION_TECHNOLOGY_TYPE_BREDR"
  "CONNECTION_TECHNOLOGY_TYPE_LE"
  "CONNECTION_TECHNOLOGY_TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BluetoothSession_ConnectionTechnologyType_entries[] = {
  { {BluetoothSession_ConnectionTechnologyType_names + 0, 32}, 2 },
  { {BluetoothSession_ConnectionTechnologyType_names + 32, 29}, 1 },
  { {BluetoothSession_ConnectionTechnologyType_names + 61, 34}, 0 },
};

static const int BluetoothSession_ConnectionTechnologyType_entries_by_number[] = {
  2, // 0 -> CONNECTION_TECHNOLOGY_TYPE_UNKNOWN
  1, // 1 -> CONNECTION_TECHNOLOGY_TYPE_LE
  0, // 2 -> CONNECTION_TECHNOLOGY_TYPE_BREDR
};

const std::string& BluetoothSession_ConnectionTechnologyType_Name(
    BluetoothSession_ConnectionTechnologyType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BluetoothSession_ConnectionTechnologyType_entries,
          BluetoothSession_ConnectionTechnologyType_entries_by_number,
          3, BluetoothSession_ConnectionTechnologyType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BluetoothSession_ConnectionTechnologyType_entries,
      BluetoothSession_ConnectionTechnologyType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BluetoothSession_ConnectionTechnologyType_strings[idx].get();
}
bool BluetoothSession_ConnectionTechnologyType_Parse(
    const std::string& name, BluetoothSession_ConnectionTechnologyType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BluetoothSession_ConnectionTechnologyType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<BluetoothSession_ConnectionTechnologyType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr BluetoothSession_ConnectionTechnologyType BluetoothSession::CONNECTION_TECHNOLOGY_TYPE_UNKNOWN;
constexpr BluetoothSession_ConnectionTechnologyType BluetoothSession::CONNECTION_TECHNOLOGY_TYPE_LE;
constexpr BluetoothSession_ConnectionTechnologyType BluetoothSession::CONNECTION_TECHNOLOGY_TYPE_BREDR;
constexpr BluetoothSession_ConnectionTechnologyType BluetoothSession::ConnectionTechnologyType_MIN;
constexpr BluetoothSession_ConnectionTechnologyType BluetoothSession::ConnectionTechnologyType_MAX;
constexpr int BluetoothSession::ConnectionTechnologyType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool BluetoothSession_DisconnectReasonType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BluetoothSession_DisconnectReasonType_strings[3] = {};

static const char BluetoothSession_DisconnectReasonType_names[] =
  "METRICS_DUMP"
  "NEXT_START_WITHOUT_END_PREVIOUS"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BluetoothSession_DisconnectReasonType_entries[] = {
  { {BluetoothSession_DisconnectReasonType_names + 0, 12}, 1 },
  { {BluetoothSession_DisconnectReasonType_names + 12, 31}, 2 },
  { {BluetoothSession_DisconnectReasonType_names + 43, 7}, 0 },
};

static const int BluetoothSession_DisconnectReasonType_entries_by_number[] = {
  2, // 0 -> UNKNOWN
  0, // 1 -> METRICS_DUMP
  1, // 2 -> NEXT_START_WITHOUT_END_PREVIOUS
};

const std::string& BluetoothSession_DisconnectReasonType_Name(
    BluetoothSession_DisconnectReasonType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BluetoothSession_DisconnectReasonType_entries,
          BluetoothSession_DisconnectReasonType_entries_by_number,
          3, BluetoothSession_DisconnectReasonType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BluetoothSession_DisconnectReasonType_entries,
      BluetoothSession_DisconnectReasonType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BluetoothSession_DisconnectReasonType_strings[idx].get();
}
bool BluetoothSession_DisconnectReasonType_Parse(
    const std::string& name, BluetoothSession_DisconnectReasonType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BluetoothSession_DisconnectReasonType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<BluetoothSession_DisconnectReasonType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr BluetoothSession_DisconnectReasonType BluetoothSession::UNKNOWN;
constexpr BluetoothSession_DisconnectReasonType BluetoothSession::METRICS_DUMP;
constexpr BluetoothSession_DisconnectReasonType BluetoothSession::NEXT_START_WITHOUT_END_PREVIOUS;
constexpr BluetoothSession_DisconnectReasonType BluetoothSession::DisconnectReasonType_MIN;
constexpr BluetoothSession_DisconnectReasonType BluetoothSession::DisconnectReasonType_MAX;
constexpr int BluetoothSession::DisconnectReasonType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool WakeEvent_WakeEventType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> WakeEvent_WakeEventType_strings[3] = {};

static const char WakeEvent_WakeEventType_names[] =
  "ACQUIRED"
  "RELEASED"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry WakeEvent_WakeEventType_entries[] = {
  { {WakeEvent_WakeEventType_names + 0, 8}, 1 },
  { {WakeEvent_WakeEventType_names + 8, 8}, 2 },
  { {WakeEvent_WakeEventType_names + 16, 7}, 0 },
};

static const int WakeEvent_WakeEventType_entries_by_number[] = {
  2, // 0 -> UNKNOWN
  0, // 1 -> ACQUIRED
  1, // 2 -> RELEASED
};

const std::string& WakeEvent_WakeEventType_Name(
    WakeEvent_WakeEventType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          WakeEvent_WakeEventType_entries,
          WakeEvent_WakeEventType_entries_by_number,
          3, WakeEvent_WakeEventType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      WakeEvent_WakeEventType_entries,
      WakeEvent_WakeEventType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     WakeEvent_WakeEventType_strings[idx].get();
}
bool WakeEvent_WakeEventType_Parse(
    const std::string& name, WakeEvent_WakeEventType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      WakeEvent_WakeEventType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<WakeEvent_WakeEventType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr WakeEvent_WakeEventType WakeEvent::UNKNOWN;
constexpr WakeEvent_WakeEventType WakeEvent::ACQUIRED;
constexpr WakeEvent_WakeEventType WakeEvent::RELEASED;
constexpr WakeEvent_WakeEventType WakeEvent::WakeEventType_MIN;
constexpr WakeEvent_WakeEventType WakeEvent::WakeEventType_MAX;
constexpr int WakeEvent::WakeEventType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool ScanEvent_ScanTechnologyType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ScanEvent_ScanTechnologyType_strings[4] = {};

static const char ScanEvent_ScanTechnologyType_names[] =
  "SCAN_TECH_TYPE_BOTH"
  "SCAN_TECH_TYPE_BREDR"
  "SCAN_TECH_TYPE_LE"
  "SCAN_TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ScanEvent_ScanTechnologyType_entries[] = {
  { {ScanEvent_ScanTechnologyType_names + 0, 19}, 3 },
  { {ScanEvent_ScanTechnologyType_names + 19, 20}, 2 },
  { {ScanEvent_ScanTechnologyType_names + 39, 17}, 1 },
  { {ScanEvent_ScanTechnologyType_names + 56, 17}, 0 },
};

static const int ScanEvent_ScanTechnologyType_entries_by_number[] = {
  3, // 0 -> SCAN_TYPE_UNKNOWN
  2, // 1 -> SCAN_TECH_TYPE_LE
  1, // 2 -> SCAN_TECH_TYPE_BREDR
  0, // 3 -> SCAN_TECH_TYPE_BOTH
};

const std::string& ScanEvent_ScanTechnologyType_Name(
    ScanEvent_ScanTechnologyType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ScanEvent_ScanTechnologyType_entries,
          ScanEvent_ScanTechnologyType_entries_by_number,
          4, ScanEvent_ScanTechnologyType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ScanEvent_ScanTechnologyType_entries,
      ScanEvent_ScanTechnologyType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ScanEvent_ScanTechnologyType_strings[idx].get();
}
bool ScanEvent_ScanTechnologyType_Parse(
    const std::string& name, ScanEvent_ScanTechnologyType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ScanEvent_ScanTechnologyType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ScanEvent_ScanTechnologyType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr ScanEvent_ScanTechnologyType ScanEvent::SCAN_TYPE_UNKNOWN;
constexpr ScanEvent_ScanTechnologyType ScanEvent::SCAN_TECH_TYPE_LE;
constexpr ScanEvent_ScanTechnologyType ScanEvent::SCAN_TECH_TYPE_BREDR;
constexpr ScanEvent_ScanTechnologyType ScanEvent::SCAN_TECH_TYPE_BOTH;
constexpr ScanEvent_ScanTechnologyType ScanEvent::ScanTechnologyType_MIN;
constexpr ScanEvent_ScanTechnologyType ScanEvent::ScanTechnologyType_MAX;
constexpr int ScanEvent::ScanTechnologyType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool ScanEvent_ScanEventType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ScanEvent_ScanEventType_strings[2] = {};

static const char ScanEvent_ScanEventType_names[] =
  "SCAN_EVENT_START"
  "SCAN_EVENT_STOP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ScanEvent_ScanEventType_entries[] = {
  { {ScanEvent_ScanEventType_names + 0, 16}, 0 },
  { {ScanEvent_ScanEventType_names + 16, 15}, 1 },
};

static const int ScanEvent_ScanEventType_entries_by_number[] = {
  0, // 0 -> SCAN_EVENT_START
  1, // 1 -> SCAN_EVENT_STOP
};

const std::string& ScanEvent_ScanEventType_Name(
    ScanEvent_ScanEventType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ScanEvent_ScanEventType_entries,
          ScanEvent_ScanEventType_entries_by_number,
          2, ScanEvent_ScanEventType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ScanEvent_ScanEventType_entries,
      ScanEvent_ScanEventType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ScanEvent_ScanEventType_strings[idx].get();
}
bool ScanEvent_ScanEventType_Parse(
    const std::string& name, ScanEvent_ScanEventType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ScanEvent_ScanEventType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<ScanEvent_ScanEventType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr ScanEvent_ScanEventType ScanEvent::SCAN_EVENT_START;
constexpr ScanEvent_ScanEventType ScanEvent::SCAN_EVENT_STOP;
constexpr ScanEvent_ScanEventType ScanEvent::ScanEventType_MIN;
constexpr ScanEvent_ScanEventType ScanEvent::ScanEventType_MAX;
constexpr int ScanEvent::ScanEventType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool A2dpSourceCodec_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> A2dpSourceCodec_strings[6] = {};

static const char A2dpSourceCodec_names[] =
  "A2DP_SOURCE_CODEC_AAC"
  "A2DP_SOURCE_CODEC_APTX"
  "A2DP_SOURCE_CODEC_APTX_HD"
  "A2DP_SOURCE_CODEC_LDAC"
  "A2DP_SOURCE_CODEC_SBC"
  "A2DP_SOURCE_CODEC_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry A2dpSourceCodec_entries[] = {
  { {A2dpSourceCodec_names + 0, 21}, 2 },
  { {A2dpSourceCodec_names + 21, 22}, 3 },
  { {A2dpSourceCodec_names + 43, 25}, 4 },
  { {A2dpSourceCodec_names + 68, 22}, 5 },
  { {A2dpSourceCodec_names + 90, 21}, 1 },
  { {A2dpSourceCodec_names + 111, 25}, 0 },
};

static const int A2dpSourceCodec_entries_by_number[] = {
  5, // 0 -> A2DP_SOURCE_CODEC_UNKNOWN
  4, // 1 -> A2DP_SOURCE_CODEC_SBC
  0, // 2 -> A2DP_SOURCE_CODEC_AAC
  1, // 3 -> A2DP_SOURCE_CODEC_APTX
  2, // 4 -> A2DP_SOURCE_CODEC_APTX_HD
  3, // 5 -> A2DP_SOURCE_CODEC_LDAC
};

const std::string& A2dpSourceCodec_Name(
    A2dpSourceCodec value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          A2dpSourceCodec_entries,
          A2dpSourceCodec_entries_by_number,
          6, A2dpSourceCodec_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      A2dpSourceCodec_entries,
      A2dpSourceCodec_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     A2dpSourceCodec_strings[idx].get();
}
bool A2dpSourceCodec_Parse(
    const std::string& name, A2dpSourceCodec* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      A2dpSourceCodec_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<A2dpSourceCodec>(int_value);
  }
  return success;
}
bool ProfileId_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ProfileId_strings[20] = {};

static const char ProfileId_names[] =
  "A2DP"
  "A2DP_SINK"
  "AVRCP"
  "AVRCP_CONTROLLER"
  "GATT"
  "GATT_SERVER"
  "HEADSET"
  "HEADSET_CLIENT"
  "HEALTH"
  "HEARING_AID"
  "HID_DEVICE"
  "HID_HOST"
  "MAP"
  "MAP_CLIENT"
  "OPP"
  "PAN"
  "PBAP"
  "PBAP_CLIENT"
  "PROFILE_UNKNOWN"
  "SAP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ProfileId_entries[] = {
  { {ProfileId_names + 0, 4}, 2 },
  { {ProfileId_names + 4, 9}, 11 },
  { {ProfileId_names + 13, 5}, 13 },
  { {ProfileId_names + 18, 16}, 12 },
  { {ProfileId_names + 34, 4}, 7 },
  { {ProfileId_names + 38, 11}, 8 },
  { {ProfileId_names + 49, 7}, 1 },
  { {ProfileId_names + 56, 14}, 16 },
  { {ProfileId_names + 70, 6}, 3 },
  { {ProfileId_names + 76, 11}, 21 },
  { {ProfileId_names + 87, 10}, 19 },
  { {ProfileId_names + 97, 8}, 4 },
  { {ProfileId_names + 105, 3}, 9 },
  { {ProfileId_names + 108, 10}, 18 },
  { {ProfileId_names + 118, 3}, 20 },
  { {ProfileId_names + 121, 3}, 5 },
  { {ProfileId_names + 124, 4}, 6 },
  { {ProfileId_names + 128, 11}, 17 },
  { {ProfileId_names + 139, 15}, 0 },
  { {ProfileId_names + 154, 3}, 10 },
};

static const int ProfileId_entries_by_number[] = {
  18, // 0 -> PROFILE_UNKNOWN
  6, // 1 -> HEADSET
  0, // 2 -> A2DP
  8, // 3 -> HEALTH
  11, // 4 -> HID_HOST
  15, // 5 -> PAN
  16, // 6 -> PBAP
  4, // 7 -> GATT
  5, // 8 -> GATT_SERVER
  12, // 9 -> MAP
  19, // 10 -> SAP
  1, // 11 -> A2DP_SINK
  3, // 12 -> AVRCP_CONTROLLER
  2, // 13 -> AVRCP
  7, // 16 -> HEADSET_CLIENT
  17, // 17 -> PBAP_CLIENT
  13, // 18 -> MAP_CLIENT
  10, // 19 -> HID_DEVICE
  14, // 20 -> OPP
  9, // 21 -> HEARING_AID
};

const std::string& ProfileId_Name(
    ProfileId value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ProfileId_entries,
          ProfileId_entries_by_number,
          20, ProfileId_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ProfileId_entries,
      ProfileId_entries_by_number,
      20, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ProfileId_strings[idx].get();
}
bool ProfileId_Parse(
    const std::string& name, ProfileId* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ProfileId_entries, 20, name, &int_value);
  if (success) {
    *value = static_cast<ProfileId>(int_value);
  }
  return success;
}
bool HeadsetProfileType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> HeadsetProfileType_strings[3] = {};

static const char HeadsetProfileType_names[] =
  "HEADSET_PROFILE_UNKNOWN"
  "HFP"
  "HSP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry HeadsetProfileType_entries[] = {
  { {HeadsetProfileType_names + 0, 23}, 0 },
  { {HeadsetProfileType_names + 23, 3}, 2 },
  { {HeadsetProfileType_names + 26, 3}, 1 },
};

static const int HeadsetProfileType_entries_by_number[] = {
  0, // 0 -> HEADSET_PROFILE_UNKNOWN
  2, // 1 -> HSP
  1, // 2 -> HFP
};

const std::string& HeadsetProfileType_Name(
    HeadsetProfileType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          HeadsetProfileType_entries,
          HeadsetProfileType_entries_by_number,
          3, HeadsetProfileType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      HeadsetProfileType_entries,
      HeadsetProfileType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     HeadsetProfileType_strings[idx].get();
}
bool HeadsetProfileType_Parse(
    const std::string& name, HeadsetProfileType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      HeadsetProfileType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<HeadsetProfileType>(int_value);
  }
  return success;
}

// ===================================================================

void BluetoothLog::InitAsDefaultInstance() {
}
class BluetoothLog::_Internal {
 public:
  using HasBits = decltype(std::declval<BluetoothLog>()._has_bits_);
  static void set_has_num_bonded_devices(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_num_bluetooth_session(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_pair_event(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_wake_event(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_num_scan_event(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

BluetoothLog::BluetoothLog()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog)
}
BluetoothLog::BluetoothLog(const BluetoothLog& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      session_(from.session_),
      pair_event_(from.pair_event_),
      wake_event_(from.wake_event_),
      scan_event_(from.scan_event_),
      profile_connection_stats_(from.profile_connection_stats_),
      headset_profile_connection_stats_(from.headset_profile_connection_stats_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&num_bluetooth_session_, &from.num_bluetooth_session_,
    static_cast<size_t>(reinterpret_cast<char*>(&num_bonded_devices_) -
    reinterpret_cast<char*>(&num_bluetooth_session_)) + sizeof(num_bonded_devices_));
  // @@protoc_insertion_point(copy_constructor:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog)
}

void BluetoothLog::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_BluetoothLog_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto.base);
  ::memset(&num_bluetooth_session_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&num_bonded_devices_) -
      reinterpret_cast<char*>(&num_bluetooth_session_)) + sizeof(num_bonded_devices_));
}

BluetoothLog::~BluetoothLog() {
  // @@protoc_insertion_point(destructor:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog)
  SharedDtor();
}

void BluetoothLog::SharedDtor() {
}

void BluetoothLog::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BluetoothLog& BluetoothLog::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_BluetoothLog_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto.base);
  return *internal_default_instance();
}


void BluetoothLog::Clear() {
// @@protoc_insertion_point(message_clear_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  session_.Clear();
  pair_event_.Clear();
  wake_event_.Clear();
  scan_event_.Clear();
  profile_connection_stats_.Clear();
  headset_profile_connection_stats_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&num_bluetooth_session_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&num_bonded_devices_) -
        reinterpret_cast<char*>(&num_bluetooth_session_)) + sizeof(num_bonded_devices_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* BluetoothLog::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession session = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_session(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      // repeated .bluetooth.metrics.BluetoothMetricsProto.PairEvent pair_event = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_pair_event(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      // repeated .bluetooth.metrics.BluetoothMetricsProto.WakeEvent wake_event = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_wake_event(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 26);
        } else goto handle_unusual;
        continue;
      // repeated .bluetooth.metrics.BluetoothMetricsProto.ScanEvent scan_event = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_scan_event(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 34);
        } else goto handle_unusual;
        continue;
      // optional int32 num_bonded_devices = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_num_bonded_devices(&has_bits);
          num_bonded_devices_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 num_bluetooth_session = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_num_bluetooth_session(&has_bits);
          num_bluetooth_session_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 num_pair_event = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_num_pair_event(&has_bits);
          num_pair_event_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 num_wake_event = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_num_wake_event(&has_bits);
          num_wake_event_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 num_scan_event = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_num_scan_event(&has_bits);
          num_scan_event_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats profile_connection_stats = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_profile_connection_stats(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 82);
        } else goto handle_unusual;
        continue;
      // repeated .bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats headset_profile_connection_stats = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_headset_profile_connection_stats(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 90);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool BluetoothLog::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession session = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_session()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .bluetooth.metrics.BluetoothMetricsProto.PairEvent pair_event = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_pair_event()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .bluetooth.metrics.BluetoothMetricsProto.WakeEvent wake_event = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_wake_event()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .bluetooth.metrics.BluetoothMetricsProto.ScanEvent scan_event = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_scan_event()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_bonded_devices = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_num_bonded_devices(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_bonded_devices_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 num_bluetooth_session = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_num_bluetooth_session(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &num_bluetooth_session_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 num_pair_event = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_num_pair_event(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &num_pair_event_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 num_wake_event = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          _Internal::set_has_num_wake_event(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &num_wake_event_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 num_scan_event = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          _Internal::set_has_num_scan_event(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &num_scan_event_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats profile_connection_stats = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (82 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_profile_connection_stats()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats headset_profile_connection_stats = 11;
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (90 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_headset_profile_connection_stats()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void BluetoothLog::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession session = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->session_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1,
      this->session(static_cast<int>(i)),
      output);
  }

  // repeated .bluetooth.metrics.BluetoothMetricsProto.PairEvent pair_event = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->pair_event_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2,
      this->pair_event(static_cast<int>(i)),
      output);
  }

  // repeated .bluetooth.metrics.BluetoothMetricsProto.WakeEvent wake_event = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->wake_event_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      3,
      this->wake_event(static_cast<int>(i)),
      output);
  }

  // repeated .bluetooth.metrics.BluetoothMetricsProto.ScanEvent scan_event = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->scan_event_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      4,
      this->scan_event(static_cast<int>(i)),
      output);
  }

  cached_has_bits = _has_bits_[0];
  // optional int32 num_bonded_devices = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->num_bonded_devices(), output);
  }

  // optional int64 num_bluetooth_session = 6;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(6, this->num_bluetooth_session(), output);
  }

  // optional int64 num_pair_event = 7;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(7, this->num_pair_event(), output);
  }

  // optional int64 num_wake_event = 8;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(8, this->num_wake_event(), output);
  }

  // optional int64 num_scan_event = 9;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(9, this->num_scan_event(), output);
  }

  // repeated .bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats profile_connection_stats = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->profile_connection_stats_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      10,
      this->profile_connection_stats(static_cast<int>(i)),
      output);
  }

  // repeated .bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats headset_profile_connection_stats = 11;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->headset_profile_connection_stats_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      11,
      this->headset_profile_connection_stats(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog)
}

size_t BluetoothLog::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession session = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->session_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->session(static_cast<int>(i)));
    }
  }

  // repeated .bluetooth.metrics.BluetoothMetricsProto.PairEvent pair_event = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->pair_event_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->pair_event(static_cast<int>(i)));
    }
  }

  // repeated .bluetooth.metrics.BluetoothMetricsProto.WakeEvent wake_event = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->wake_event_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->wake_event(static_cast<int>(i)));
    }
  }

  // repeated .bluetooth.metrics.BluetoothMetricsProto.ScanEvent scan_event = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->scan_event_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->scan_event(static_cast<int>(i)));
    }
  }

  // repeated .bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats profile_connection_stats = 10;
  {
    unsigned int count = static_cast<unsigned int>(this->profile_connection_stats_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->profile_connection_stats(static_cast<int>(i)));
    }
  }

  // repeated .bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats headset_profile_connection_stats = 11;
  {
    unsigned int count = static_cast<unsigned int>(this->headset_profile_connection_stats_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->headset_profile_connection_stats(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int64 num_bluetooth_session = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->num_bluetooth_session());
    }

    // optional int64 num_pair_event = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->num_pair_event());
    }

    // optional int64 num_wake_event = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->num_wake_event());
    }

    // optional int64 num_scan_event = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->num_scan_event());
    }

    // optional int32 num_bonded_devices = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_bonded_devices());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BluetoothLog::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BluetoothLog*>(
      &from));
}

void BluetoothLog::MergeFrom(const BluetoothLog& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  session_.MergeFrom(from.session_);
  pair_event_.MergeFrom(from.pair_event_);
  wake_event_.MergeFrom(from.wake_event_);
  scan_event_.MergeFrom(from.scan_event_);
  profile_connection_stats_.MergeFrom(from.profile_connection_stats_);
  headset_profile_connection_stats_.MergeFrom(from.headset_profile_connection_stats_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      num_bluetooth_session_ = from.num_bluetooth_session_;
    }
    if (cached_has_bits & 0x00000002u) {
      num_pair_event_ = from.num_pair_event_;
    }
    if (cached_has_bits & 0x00000004u) {
      num_wake_event_ = from.num_wake_event_;
    }
    if (cached_has_bits & 0x00000008u) {
      num_scan_event_ = from.num_scan_event_;
    }
    if (cached_has_bits & 0x00000010u) {
      num_bonded_devices_ = from.num_bonded_devices_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void BluetoothLog::CopyFrom(const BluetoothLog& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BluetoothLog::IsInitialized() const {
  return true;
}

void BluetoothLog::InternalSwap(BluetoothLog* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&session_)->InternalSwap(CastToBase(&other->session_));
  CastToBase(&pair_event_)->InternalSwap(CastToBase(&other->pair_event_));
  CastToBase(&wake_event_)->InternalSwap(CastToBase(&other->wake_event_));
  CastToBase(&scan_event_)->InternalSwap(CastToBase(&other->scan_event_));
  CastToBase(&profile_connection_stats_)->InternalSwap(CastToBase(&other->profile_connection_stats_));
  CastToBase(&headset_profile_connection_stats_)->InternalSwap(CastToBase(&other->headset_profile_connection_stats_));
  swap(num_bluetooth_session_, other->num_bluetooth_session_);
  swap(num_pair_event_, other->num_pair_event_);
  swap(num_wake_event_, other->num_wake_event_);
  swap(num_scan_event_, other->num_scan_event_);
  swap(num_bonded_devices_, other->num_bonded_devices_);
}

std::string BluetoothLog::GetTypeName() const {
  return "bluetooth.metrics.BluetoothMetricsProto.BluetoothLog";
}


// ===================================================================

void DeviceInfo::InitAsDefaultInstance() {
}
class DeviceInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceInfo>()._has_bits_);
  static void set_has_device_class(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_device_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

DeviceInfo::DeviceInfo()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo)
}
DeviceInfo::DeviceInfo(const DeviceInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&device_class_, &from.device_class_,
    static_cast<size_t>(reinterpret_cast<char*>(&device_type_) -
    reinterpret_cast<char*>(&device_class_)) + sizeof(device_type_));
  // @@protoc_insertion_point(copy_constructor:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo)
}

void DeviceInfo::SharedCtor() {
  ::memset(&device_class_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&device_type_) -
      reinterpret_cast<char*>(&device_class_)) + sizeof(device_type_));
}

DeviceInfo::~DeviceInfo() {
  // @@protoc_insertion_point(destructor:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo)
  SharedDtor();
}

void DeviceInfo::SharedDtor() {
}

void DeviceInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DeviceInfo& DeviceInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_DeviceInfo_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto.base);
  return *internal_default_instance();
}


void DeviceInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&device_class_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&device_type_) -
        reinterpret_cast<char*>(&device_class_)) + sizeof(device_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* DeviceInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 device_class = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_device_class(&has_bits);
          device_class_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo.DeviceType device_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo_DeviceType_IsValid(val))) {
            set_device_type(static_cast<::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo_DeviceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool DeviceInfo::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 device_class = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_device_class(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &device_class_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo.DeviceType device_type = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo_DeviceType_IsValid(value)) {
            set_device_type(static_cast< ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo_DeviceType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void DeviceInfo::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 device_class = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->device_class(), output);
  }

  // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo.DeviceType device_type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      2, this->device_type(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo)
}

size_t DeviceInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 device_class = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->device_class());
    }

    // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo.DeviceType device_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->device_type());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DeviceInfo*>(
      &from));
}

void DeviceInfo::MergeFrom(const DeviceInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      device_class_ = from.device_class_;
    }
    if (cached_has_bits & 0x00000002u) {
      device_type_ = from.device_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DeviceInfo::CopyFrom(const DeviceInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceInfo::IsInitialized() const {
  return true;
}

void DeviceInfo::InternalSwap(DeviceInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(device_class_, other->device_class_);
  swap(device_type_, other->device_type_);
}

std::string DeviceInfo::GetTypeName() const {
  return "bluetooth.metrics.BluetoothMetricsProto.DeviceInfo";
}


// ===================================================================

void BluetoothSession::InitAsDefaultInstance() {
  ::bluetooth::metrics::BluetoothMetricsProto::_BluetoothSession_default_instance_._instance.get_mutable()->device_connected_to_ = const_cast< ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo*>(
      ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo::internal_default_instance());
  ::bluetooth::metrics::BluetoothMetricsProto::_BluetoothSession_default_instance_._instance.get_mutable()->rfcomm_session_ = const_cast< ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession*>(
      ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession::internal_default_instance());
  ::bluetooth::metrics::BluetoothMetricsProto::_BluetoothSession_default_instance_._instance.get_mutable()->a2dp_session_ = const_cast< ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession*>(
      ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession::internal_default_instance());
}
class BluetoothSession::_Internal {
 public:
  using HasBits = decltype(std::declval<BluetoothSession>()._has_bits_);
  static void set_has_session_duration_sec(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_connection_technology_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_disconnect_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo& device_connected_to(const BluetoothSession* msg);
  static void set_has_device_connected_to(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession& rfcomm_session(const BluetoothSession* msg);
  static void set_has_rfcomm_session(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession& a2dp_session(const BluetoothSession* msg);
  static void set_has_a2dp_session(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_disconnect_reason_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo&
BluetoothSession::_Internal::device_connected_to(const BluetoothSession* msg) {
  return *msg->device_connected_to_;
}
const ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession&
BluetoothSession::_Internal::rfcomm_session(const BluetoothSession* msg) {
  return *msg->rfcomm_session_;
}
const ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession&
BluetoothSession::_Internal::a2dp_session(const BluetoothSession* msg) {
  return *msg->a2dp_session_;
}
BluetoothSession::BluetoothSession()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession)
}
BluetoothSession::BluetoothSession(const BluetoothSession& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  disconnect_reason_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_disconnect_reason()) {
    disconnect_reason_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.disconnect_reason_);
  }
  if (from.has_device_connected_to()) {
    device_connected_to_ = new ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo(*from.device_connected_to_);
  } else {
    device_connected_to_ = nullptr;
  }
  if (from.has_rfcomm_session()) {
    rfcomm_session_ = new ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession(*from.rfcomm_session_);
  } else {
    rfcomm_session_ = nullptr;
  }
  if (from.has_a2dp_session()) {
    a2dp_session_ = new ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession(*from.a2dp_session_);
  } else {
    a2dp_session_ = nullptr;
  }
  ::memcpy(&session_duration_sec_, &from.session_duration_sec_,
    static_cast<size_t>(reinterpret_cast<char*>(&disconnect_reason_type_) -
    reinterpret_cast<char*>(&session_duration_sec_)) + sizeof(disconnect_reason_type_));
  // @@protoc_insertion_point(copy_constructor:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession)
}

void BluetoothSession::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_BluetoothSession_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto.base);
  disconnect_reason_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&device_connected_to_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&disconnect_reason_type_) -
      reinterpret_cast<char*>(&device_connected_to_)) + sizeof(disconnect_reason_type_));
}

BluetoothSession::~BluetoothSession() {
  // @@protoc_insertion_point(destructor:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession)
  SharedDtor();
}

void BluetoothSession::SharedDtor() {
  disconnect_reason_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete device_connected_to_;
  if (this != internal_default_instance()) delete rfcomm_session_;
  if (this != internal_default_instance()) delete a2dp_session_;
}

void BluetoothSession::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BluetoothSession& BluetoothSession::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_BluetoothSession_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto.base);
  return *internal_default_instance();
}


void BluetoothSession::Clear() {
// @@protoc_insertion_point(message_clear_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      disconnect_reason_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(device_connected_to_ != nullptr);
      device_connected_to_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(rfcomm_session_ != nullptr);
      rfcomm_session_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(a2dp_session_ != nullptr);
      a2dp_session_->Clear();
    }
  }
  if (cached_has_bits & 0x00000070u) {
    ::memset(&session_duration_sec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&disconnect_reason_type_) -
        reinterpret_cast<char*>(&session_duration_sec_)) + sizeof(disconnect_reason_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* BluetoothSession::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int64 session_duration_sec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_session_duration_sec(&has_bits);
          session_duration_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.ConnectionTechnologyType connection_technology_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_ConnectionTechnologyType_IsValid(val))) {
            set_connection_technology_type(static_cast<::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_ConnectionTechnologyType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string disconnect_reason = 4 [deprecated = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_disconnect_reason(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo device_connected_to = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(mutable_device_connected_to(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .bluetooth.metrics.BluetoothMetricsProto.RFCommSession rfcomm_session = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(mutable_rfcomm_session(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .bluetooth.metrics.BluetoothMetricsProto.A2DPSession a2dp_session = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(mutable_a2dp_session(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.DisconnectReasonType disconnect_reason_type = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_DisconnectReasonType_IsValid(val))) {
            set_disconnect_reason_type(static_cast<::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_DisconnectReasonType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool BluetoothSession::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 session_duration_sec = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_session_duration_sec(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &session_duration_sec_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.ConnectionTechnologyType connection_technology_type = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_ConnectionTechnologyType_IsValid(value)) {
            set_connection_technology_type(static_cast< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_ConnectionTechnologyType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(24u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string disconnect_reason = 4 [deprecated = true];
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_disconnect_reason()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo device_connected_to = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_device_connected_to()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .bluetooth.metrics.BluetoothMetricsProto.RFCommSession rfcomm_session = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_rfcomm_session()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .bluetooth.metrics.BluetoothMetricsProto.A2DPSession a2dp_session = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (58 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_a2dp_session()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.DisconnectReasonType disconnect_reason_type = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_DisconnectReasonType_IsValid(value)) {
            set_disconnect_reason_type(static_cast< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_DisconnectReasonType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(64u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void BluetoothSession::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 session_duration_sec = 2;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(2, this->session_duration_sec(), output);
  }

  // optional .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.ConnectionTechnologyType connection_technology_type = 3;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      3, this->connection_technology_type(), output);
  }

  // optional string disconnect_reason = 4 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->disconnect_reason(), output);
  }

  // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo device_connected_to = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      5, _Internal::device_connected_to(this), output);
  }

  // optional .bluetooth.metrics.BluetoothMetricsProto.RFCommSession rfcomm_session = 6;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      6, _Internal::rfcomm_session(this), output);
  }

  // optional .bluetooth.metrics.BluetoothMetricsProto.A2DPSession a2dp_session = 7;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      7, _Internal::a2dp_session(this), output);
  }

  // optional .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.DisconnectReasonType disconnect_reason_type = 8;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      8, this->disconnect_reason_type(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession)
}

size_t BluetoothSession::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string disconnect_reason = 4 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->disconnect_reason());
    }

    // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo device_connected_to = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *device_connected_to_);
    }

    // optional .bluetooth.metrics.BluetoothMetricsProto.RFCommSession rfcomm_session = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rfcomm_session_);
    }

    // optional .bluetooth.metrics.BluetoothMetricsProto.A2DPSession a2dp_session = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *a2dp_session_);
    }

    // optional int64 session_duration_sec = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->session_duration_sec());
    }

    // optional .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.ConnectionTechnologyType connection_technology_type = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->connection_technology_type());
    }

    // optional .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.DisconnectReasonType disconnect_reason_type = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->disconnect_reason_type());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BluetoothSession::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BluetoothSession*>(
      &from));
}

void BluetoothSession::MergeFrom(const BluetoothSession& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      disconnect_reason_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.disconnect_reason_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_device_connected_to()->::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo::MergeFrom(from.device_connected_to());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_rfcomm_session()->::bluetooth::metrics::BluetoothMetricsProto::RFCommSession::MergeFrom(from.rfcomm_session());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_a2dp_session()->::bluetooth::metrics::BluetoothMetricsProto::A2DPSession::MergeFrom(from.a2dp_session());
    }
    if (cached_has_bits & 0x00000010u) {
      session_duration_sec_ = from.session_duration_sec_;
    }
    if (cached_has_bits & 0x00000020u) {
      connection_technology_type_ = from.connection_technology_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      disconnect_reason_type_ = from.disconnect_reason_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void BluetoothSession::CopyFrom(const BluetoothSession& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BluetoothSession::IsInitialized() const {
  return true;
}

void BluetoothSession::InternalSwap(BluetoothSession* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  disconnect_reason_.Swap(&other->disconnect_reason_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(device_connected_to_, other->device_connected_to_);
  swap(rfcomm_session_, other->rfcomm_session_);
  swap(a2dp_session_, other->a2dp_session_);
  swap(session_duration_sec_, other->session_duration_sec_);
  swap(connection_technology_type_, other->connection_technology_type_);
  swap(disconnect_reason_type_, other->disconnect_reason_type_);
}

std::string BluetoothSession::GetTypeName() const {
  return "bluetooth.metrics.BluetoothMetricsProto.BluetoothSession";
}


// ===================================================================

void RFCommSession::InitAsDefaultInstance() {
}
class RFCommSession::_Internal {
 public:
  using HasBits = decltype(std::declval<RFCommSession>()._has_bits_);
  static void set_has_rx_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tx_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

RFCommSession::RFCommSession()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:bluetooth.metrics.BluetoothMetricsProto.RFCommSession)
}
RFCommSession::RFCommSession(const RFCommSession& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&rx_bytes_, &from.rx_bytes_,
    static_cast<size_t>(reinterpret_cast<char*>(&tx_bytes_) -
    reinterpret_cast<char*>(&rx_bytes_)) + sizeof(tx_bytes_));
  // @@protoc_insertion_point(copy_constructor:bluetooth.metrics.BluetoothMetricsProto.RFCommSession)
}

void RFCommSession::SharedCtor() {
  ::memset(&rx_bytes_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&tx_bytes_) -
      reinterpret_cast<char*>(&rx_bytes_)) + sizeof(tx_bytes_));
}

RFCommSession::~RFCommSession() {
  // @@protoc_insertion_point(destructor:bluetooth.metrics.BluetoothMetricsProto.RFCommSession)
  SharedDtor();
}

void RFCommSession::SharedDtor() {
}

void RFCommSession::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RFCommSession& RFCommSession::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RFCommSession_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto.base);
  return *internal_default_instance();
}


void RFCommSession::Clear() {
// @@protoc_insertion_point(message_clear_start:bluetooth.metrics.BluetoothMetricsProto.RFCommSession)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&rx_bytes_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&tx_bytes_) -
        reinterpret_cast<char*>(&rx_bytes_)) + sizeof(tx_bytes_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* RFCommSession::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 rx_bytes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_rx_bytes(&has_bits);
          rx_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 tx_bytes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_tx_bytes(&has_bits);
          tx_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool RFCommSession::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:bluetooth.metrics.BluetoothMetricsProto.RFCommSession)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 rx_bytes = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_rx_bytes(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &rx_bytes_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 tx_bytes = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_tx_bytes(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &tx_bytes_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:bluetooth.metrics.BluetoothMetricsProto.RFCommSession)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:bluetooth.metrics.BluetoothMetricsProto.RFCommSession)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void RFCommSession::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:bluetooth.metrics.BluetoothMetricsProto.RFCommSession)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 rx_bytes = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->rx_bytes(), output);
  }

  // optional int32 tx_bytes = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->tx_bytes(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:bluetooth.metrics.BluetoothMetricsProto.RFCommSession)
}

size_t RFCommSession::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bluetooth.metrics.BluetoothMetricsProto.RFCommSession)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 rx_bytes = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->rx_bytes());
    }

    // optional int32 tx_bytes = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->tx_bytes());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RFCommSession::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RFCommSession*>(
      &from));
}

void RFCommSession::MergeFrom(const RFCommSession& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bluetooth.metrics.BluetoothMetricsProto.RFCommSession)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      rx_bytes_ = from.rx_bytes_;
    }
    if (cached_has_bits & 0x00000002u) {
      tx_bytes_ = from.tx_bytes_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RFCommSession::CopyFrom(const RFCommSession& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bluetooth.metrics.BluetoothMetricsProto.RFCommSession)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RFCommSession::IsInitialized() const {
  return true;
}

void RFCommSession::InternalSwap(RFCommSession* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(rx_bytes_, other->rx_bytes_);
  swap(tx_bytes_, other->tx_bytes_);
}

std::string RFCommSession::GetTypeName() const {
  return "bluetooth.metrics.BluetoothMetricsProto.RFCommSession";
}


// ===================================================================

void A2DPSession::InitAsDefaultInstance() {
}
class A2DPSession::_Internal {
 public:
  using HasBits = decltype(std::declval<A2DPSession>()._has_bits_);
  static void set_has_media_timer_min_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_media_timer_max_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_media_timer_avg_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_buffer_overruns_max_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_buffer_overruns_total(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_buffer_underruns_average(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_buffer_underruns_count(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_audio_duration_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_source_codec(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_is_a2dp_offload(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

A2DPSession::A2DPSession()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:bluetooth.metrics.BluetoothMetricsProto.A2DPSession)
}
A2DPSession::A2DPSession(const A2DPSession& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&media_timer_min_millis_, &from.media_timer_min_millis_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_a2dp_offload_) -
    reinterpret_cast<char*>(&media_timer_min_millis_)) + sizeof(is_a2dp_offload_));
  // @@protoc_insertion_point(copy_constructor:bluetooth.metrics.BluetoothMetricsProto.A2DPSession)
}

void A2DPSession::SharedCtor() {
  ::memset(&media_timer_min_millis_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_a2dp_offload_) -
      reinterpret_cast<char*>(&media_timer_min_millis_)) + sizeof(is_a2dp_offload_));
}

A2DPSession::~A2DPSession() {
  // @@protoc_insertion_point(destructor:bluetooth.metrics.BluetoothMetricsProto.A2DPSession)
  SharedDtor();
}

void A2DPSession::SharedDtor() {
}

void A2DPSession::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const A2DPSession& A2DPSession::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_A2DPSession_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto.base);
  return *internal_default_instance();
}


void A2DPSession::Clear() {
// @@protoc_insertion_point(message_clear_start:bluetooth.metrics.BluetoothMetricsProto.A2DPSession)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&media_timer_min_millis_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&buffer_underruns_count_) -
        reinterpret_cast<char*>(&media_timer_min_millis_)) + sizeof(buffer_underruns_count_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&source_codec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_a2dp_offload_) -
        reinterpret_cast<char*>(&source_codec_)) + sizeof(is_a2dp_offload_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* A2DPSession::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 media_timer_min_millis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_media_timer_min_millis(&has_bits);
          media_timer_min_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 media_timer_max_millis = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_media_timer_max_millis(&has_bits);
          media_timer_max_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 media_timer_avg_millis = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_media_timer_avg_millis(&has_bits);
          media_timer_avg_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 buffer_overruns_max_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_buffer_overruns_max_count(&has_bits);
          buffer_overruns_max_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 buffer_overruns_total = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_buffer_overruns_total(&has_bits);
          buffer_overruns_total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float buffer_underruns_average = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_buffer_underruns_average(&has_bits);
          buffer_underruns_average_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional int32 buffer_underruns_count = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_buffer_underruns_count(&has_bits);
          buffer_underruns_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 audio_duration_millis = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_audio_duration_millis(&has_bits);
          audio_duration_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .bluetooth.metrics.BluetoothMetricsProto.A2dpSourceCodec source_codec = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::bluetooth::metrics::BluetoothMetricsProto::A2dpSourceCodec_IsValid(val))) {
            set_source_codec(static_cast<::bluetooth::metrics::BluetoothMetricsProto::A2dpSourceCodec>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool is_a2dp_offload = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_is_a2dp_offload(&has_bits);
          is_a2dp_offload_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool A2DPSession::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:bluetooth.metrics.BluetoothMetricsProto.A2DPSession)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 media_timer_min_millis = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_media_timer_min_millis(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &media_timer_min_millis_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 media_timer_max_millis = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_media_timer_max_millis(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &media_timer_max_millis_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 media_timer_avg_millis = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_media_timer_avg_millis(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &media_timer_avg_millis_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 buffer_overruns_max_count = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_buffer_overruns_max_count(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &buffer_overruns_max_count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 buffer_overruns_total = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_buffer_overruns_total(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &buffer_overruns_total_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float buffer_underruns_average = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (53 & 0xFF)) {
          _Internal::set_has_buffer_underruns_average(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &buffer_underruns_average_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 buffer_underruns_count = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_buffer_underruns_count(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &buffer_underruns_count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 audio_duration_millis = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          _Internal::set_has_audio_duration_millis(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &audio_duration_millis_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .bluetooth.metrics.BluetoothMetricsProto.A2dpSourceCodec source_codec = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::bluetooth::metrics::BluetoothMetricsProto::A2dpSourceCodec_IsValid(value)) {
            set_source_codec(static_cast< ::bluetooth::metrics::BluetoothMetricsProto::A2dpSourceCodec >(value));
          } else {
            unknown_fields_stream.WriteVarint32(72u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool is_a2dp_offload = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (80 & 0xFF)) {
          _Internal::set_has_is_a2dp_offload(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_a2dp_offload_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:bluetooth.metrics.BluetoothMetricsProto.A2DPSession)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:bluetooth.metrics.BluetoothMetricsProto.A2DPSession)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void A2DPSession::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:bluetooth.metrics.BluetoothMetricsProto.A2DPSession)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 media_timer_min_millis = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->media_timer_min_millis(), output);
  }

  // optional int32 media_timer_max_millis = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->media_timer_max_millis(), output);
  }

  // optional int32 media_timer_avg_millis = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->media_timer_avg_millis(), output);
  }

  // optional int32 buffer_overruns_max_count = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->buffer_overruns_max_count(), output);
  }

  // optional int32 buffer_overruns_total = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->buffer_overruns_total(), output);
  }

  // optional float buffer_underruns_average = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(6, this->buffer_underruns_average(), output);
  }

  // optional int32 buffer_underruns_count = 7;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(7, this->buffer_underruns_count(), output);
  }

  // optional int64 audio_duration_millis = 8;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(8, this->audio_duration_millis(), output);
  }

  // optional .bluetooth.metrics.BluetoothMetricsProto.A2dpSourceCodec source_codec = 9;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      9, this->source_codec(), output);
  }

  // optional bool is_a2dp_offload = 10;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(10, this->is_a2dp_offload(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:bluetooth.metrics.BluetoothMetricsProto.A2DPSession)
}

size_t A2DPSession::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bluetooth.metrics.BluetoothMetricsProto.A2DPSession)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional int32 media_timer_min_millis = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->media_timer_min_millis());
    }

    // optional int32 media_timer_max_millis = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->media_timer_max_millis());
    }

    // optional int32 media_timer_avg_millis = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->media_timer_avg_millis());
    }

    // optional int32 buffer_overruns_max_count = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->buffer_overruns_max_count());
    }

    // optional int32 buffer_overruns_total = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->buffer_overruns_total());
    }

    // optional float buffer_underruns_average = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional int64 audio_duration_millis = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->audio_duration_millis());
    }

    // optional int32 buffer_underruns_count = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->buffer_underruns_count());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional .bluetooth.metrics.BluetoothMetricsProto.A2dpSourceCodec source_codec = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->source_codec());
    }

    // optional bool is_a2dp_offload = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void A2DPSession::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const A2DPSession*>(
      &from));
}

void A2DPSession::MergeFrom(const A2DPSession& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bluetooth.metrics.BluetoothMetricsProto.A2DPSession)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      media_timer_min_millis_ = from.media_timer_min_millis_;
    }
    if (cached_has_bits & 0x00000002u) {
      media_timer_max_millis_ = from.media_timer_max_millis_;
    }
    if (cached_has_bits & 0x00000004u) {
      media_timer_avg_millis_ = from.media_timer_avg_millis_;
    }
    if (cached_has_bits & 0x00000008u) {
      buffer_overruns_max_count_ = from.buffer_overruns_max_count_;
    }
    if (cached_has_bits & 0x00000010u) {
      buffer_overruns_total_ = from.buffer_overruns_total_;
    }
    if (cached_has_bits & 0x00000020u) {
      buffer_underruns_average_ = from.buffer_underruns_average_;
    }
    if (cached_has_bits & 0x00000040u) {
      audio_duration_millis_ = from.audio_duration_millis_;
    }
    if (cached_has_bits & 0x00000080u) {
      buffer_underruns_count_ = from.buffer_underruns_count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      source_codec_ = from.source_codec_;
    }
    if (cached_has_bits & 0x00000200u) {
      is_a2dp_offload_ = from.is_a2dp_offload_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void A2DPSession::CopyFrom(const A2DPSession& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bluetooth.metrics.BluetoothMetricsProto.A2DPSession)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool A2DPSession::IsInitialized() const {
  return true;
}

void A2DPSession::InternalSwap(A2DPSession* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(media_timer_min_millis_, other->media_timer_min_millis_);
  swap(media_timer_max_millis_, other->media_timer_max_millis_);
  swap(media_timer_avg_millis_, other->media_timer_avg_millis_);
  swap(buffer_overruns_max_count_, other->buffer_overruns_max_count_);
  swap(buffer_overruns_total_, other->buffer_overruns_total_);
  swap(buffer_underruns_average_, other->buffer_underruns_average_);
  swap(audio_duration_millis_, other->audio_duration_millis_);
  swap(buffer_underruns_count_, other->buffer_underruns_count_);
  swap(source_codec_, other->source_codec_);
  swap(is_a2dp_offload_, other->is_a2dp_offload_);
}

std::string A2DPSession::GetTypeName() const {
  return "bluetooth.metrics.BluetoothMetricsProto.A2DPSession";
}


// ===================================================================

void PairEvent::InitAsDefaultInstance() {
  ::bluetooth::metrics::BluetoothMetricsProto::_PairEvent_default_instance_._instance.get_mutable()->device_paired_with_ = const_cast< ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo*>(
      ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo::internal_default_instance());
}
class PairEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<PairEvent>()._has_bits_);
  static void set_has_disconnect_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_event_time_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo& device_paired_with(const PairEvent* msg);
  static void set_has_device_paired_with(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo&
PairEvent::_Internal::device_paired_with(const PairEvent* msg) {
  return *msg->device_paired_with_;
}
PairEvent::PairEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:bluetooth.metrics.BluetoothMetricsProto.PairEvent)
}
PairEvent::PairEvent(const PairEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_device_paired_with()) {
    device_paired_with_ = new ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo(*from.device_paired_with_);
  } else {
    device_paired_with_ = nullptr;
  }
  ::memcpy(&event_time_millis_, &from.event_time_millis_,
    static_cast<size_t>(reinterpret_cast<char*>(&disconnect_reason_) -
    reinterpret_cast<char*>(&event_time_millis_)) + sizeof(disconnect_reason_));
  // @@protoc_insertion_point(copy_constructor:bluetooth.metrics.BluetoothMetricsProto.PairEvent)
}

void PairEvent::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_PairEvent_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto.base);
  ::memset(&device_paired_with_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&disconnect_reason_) -
      reinterpret_cast<char*>(&device_paired_with_)) + sizeof(disconnect_reason_));
}

PairEvent::~PairEvent() {
  // @@protoc_insertion_point(destructor:bluetooth.metrics.BluetoothMetricsProto.PairEvent)
  SharedDtor();
}

void PairEvent::SharedDtor() {
  if (this != internal_default_instance()) delete device_paired_with_;
}

void PairEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PairEvent& PairEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PairEvent_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto.base);
  return *internal_default_instance();
}


void PairEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:bluetooth.metrics.BluetoothMetricsProto.PairEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(device_paired_with_ != nullptr);
    device_paired_with_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&event_time_millis_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&disconnect_reason_) -
        reinterpret_cast<char*>(&event_time_millis_)) + sizeof(disconnect_reason_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* PairEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 disconnect_reason = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_disconnect_reason(&has_bits);
          disconnect_reason_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 event_time_millis = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_event_time_millis(&has_bits);
          event_time_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo device_paired_with = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_device_paired_with(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool PairEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:bluetooth.metrics.BluetoothMetricsProto.PairEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 disconnect_reason = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_disconnect_reason(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &disconnect_reason_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 event_time_millis = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_event_time_millis(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &event_time_millis_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo device_paired_with = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_device_paired_with()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:bluetooth.metrics.BluetoothMetricsProto.PairEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:bluetooth.metrics.BluetoothMetricsProto.PairEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void PairEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:bluetooth.metrics.BluetoothMetricsProto.PairEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 disconnect_reason = 1;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->disconnect_reason(), output);
  }

  // optional int64 event_time_millis = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(2, this->event_time_millis(), output);
  }

  // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo device_paired_with = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      3, _Internal::device_paired_with(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:bluetooth.metrics.BluetoothMetricsProto.PairEvent)
}

size_t PairEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bluetooth.metrics.BluetoothMetricsProto.PairEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo device_paired_with = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *device_paired_with_);
    }

    // optional int64 event_time_millis = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->event_time_millis());
    }

    // optional int32 disconnect_reason = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->disconnect_reason());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PairEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PairEvent*>(
      &from));
}

void PairEvent::MergeFrom(const PairEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bluetooth.metrics.BluetoothMetricsProto.PairEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_device_paired_with()->::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo::MergeFrom(from.device_paired_with());
    }
    if (cached_has_bits & 0x00000002u) {
      event_time_millis_ = from.event_time_millis_;
    }
    if (cached_has_bits & 0x00000004u) {
      disconnect_reason_ = from.disconnect_reason_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PairEvent::CopyFrom(const PairEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bluetooth.metrics.BluetoothMetricsProto.PairEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PairEvent::IsInitialized() const {
  return true;
}

void PairEvent::InternalSwap(PairEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(device_paired_with_, other->device_paired_with_);
  swap(event_time_millis_, other->event_time_millis_);
  swap(disconnect_reason_, other->disconnect_reason_);
}

std::string PairEvent::GetTypeName() const {
  return "bluetooth.metrics.BluetoothMetricsProto.PairEvent";
}


// ===================================================================

void WakeEvent::InitAsDefaultInstance() {
}
class WakeEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<WakeEvent>()._has_bits_);
  static void set_has_wake_event_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_requestor(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_event_time_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

WakeEvent::WakeEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:bluetooth.metrics.BluetoothMetricsProto.WakeEvent)
}
WakeEvent::WakeEvent(const WakeEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  requestor_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_requestor()) {
    requestor_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.requestor_);
  }
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  ::memcpy(&event_time_millis_, &from.event_time_millis_,
    static_cast<size_t>(reinterpret_cast<char*>(&wake_event_type_) -
    reinterpret_cast<char*>(&event_time_millis_)) + sizeof(wake_event_type_));
  // @@protoc_insertion_point(copy_constructor:bluetooth.metrics.BluetoothMetricsProto.WakeEvent)
}

void WakeEvent::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_WakeEvent_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto.base);
  requestor_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&event_time_millis_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&wake_event_type_) -
      reinterpret_cast<char*>(&event_time_millis_)) + sizeof(wake_event_type_));
}

WakeEvent::~WakeEvent() {
  // @@protoc_insertion_point(destructor:bluetooth.metrics.BluetoothMetricsProto.WakeEvent)
  SharedDtor();
}

void WakeEvent::SharedDtor() {
  requestor_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void WakeEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const WakeEvent& WakeEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_WakeEvent_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto.base);
  return *internal_default_instance();
}


void WakeEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:bluetooth.metrics.BluetoothMetricsProto.WakeEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      requestor_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      name_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&event_time_millis_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&wake_event_type_) -
        reinterpret_cast<char*>(&event_time_millis_)) + sizeof(wake_event_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* WakeEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .bluetooth.metrics.BluetoothMetricsProto.WakeEvent.WakeEventType wake_event_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::bluetooth::metrics::BluetoothMetricsProto::WakeEvent_WakeEventType_IsValid(val))) {
            set_wake_event_type(static_cast<::bluetooth::metrics::BluetoothMetricsProto::WakeEvent_WakeEventType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string requestor = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_requestor(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 event_time_millis = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_event_time_millis(&has_bits);
          event_time_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool WakeEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:bluetooth.metrics.BluetoothMetricsProto.WakeEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .bluetooth.metrics.BluetoothMetricsProto.WakeEvent.WakeEventType wake_event_type = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::bluetooth::metrics::BluetoothMetricsProto::WakeEvent_WakeEventType_IsValid(value)) {
            set_wake_event_type(static_cast< ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent_WakeEventType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string requestor = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_requestor()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string name = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 event_time_millis = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_event_time_millis(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &event_time_millis_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:bluetooth.metrics.BluetoothMetricsProto.WakeEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:bluetooth.metrics.BluetoothMetricsProto.WakeEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void WakeEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:bluetooth.metrics.BluetoothMetricsProto.WakeEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .bluetooth.metrics.BluetoothMetricsProto.WakeEvent.WakeEventType wake_event_type = 1;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->wake_event_type(), output);
  }

  // optional string requestor = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->requestor(), output);
  }

  // optional string name = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->name(), output);
  }

  // optional int64 event_time_millis = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(4, this->event_time_millis(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:bluetooth.metrics.BluetoothMetricsProto.WakeEvent)
}

size_t WakeEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bluetooth.metrics.BluetoothMetricsProto.WakeEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string requestor = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->requestor());
    }

    // optional string name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int64 event_time_millis = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->event_time_millis());
    }

    // optional .bluetooth.metrics.BluetoothMetricsProto.WakeEvent.WakeEventType wake_event_type = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->wake_event_type());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WakeEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const WakeEvent*>(
      &from));
}

void WakeEvent::MergeFrom(const WakeEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bluetooth.metrics.BluetoothMetricsProto.WakeEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      requestor_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.requestor_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000004u) {
      event_time_millis_ = from.event_time_millis_;
    }
    if (cached_has_bits & 0x00000008u) {
      wake_event_type_ = from.wake_event_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void WakeEvent::CopyFrom(const WakeEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bluetooth.metrics.BluetoothMetricsProto.WakeEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WakeEvent::IsInitialized() const {
  return true;
}

void WakeEvent::InternalSwap(WakeEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  requestor_.Swap(&other->requestor_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(event_time_millis_, other->event_time_millis_);
  swap(wake_event_type_, other->wake_event_type_);
}

std::string WakeEvent::GetTypeName() const {
  return "bluetooth.metrics.BluetoothMetricsProto.WakeEvent";
}


// ===================================================================

void ScanEvent::InitAsDefaultInstance() {
}
class ScanEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<ScanEvent>()._has_bits_);
  static void set_has_scan_event_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_initiator(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_scan_technology_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_number_results(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_event_time_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

ScanEvent::ScanEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:bluetooth.metrics.BluetoothMetricsProto.ScanEvent)
}
ScanEvent::ScanEvent(const ScanEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  initiator_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_initiator()) {
    initiator_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.initiator_);
  }
  ::memcpy(&scan_event_type_, &from.scan_event_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&number_results_) -
    reinterpret_cast<char*>(&scan_event_type_)) + sizeof(number_results_));
  // @@protoc_insertion_point(copy_constructor:bluetooth.metrics.BluetoothMetricsProto.ScanEvent)
}

void ScanEvent::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ScanEvent_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto.base);
  initiator_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&scan_event_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&number_results_) -
      reinterpret_cast<char*>(&scan_event_type_)) + sizeof(number_results_));
}

ScanEvent::~ScanEvent() {
  // @@protoc_insertion_point(destructor:bluetooth.metrics.BluetoothMetricsProto.ScanEvent)
  SharedDtor();
}

void ScanEvent::SharedDtor() {
  initiator_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ScanEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ScanEvent& ScanEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ScanEvent_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto.base);
  return *internal_default_instance();
}


void ScanEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:bluetooth.metrics.BluetoothMetricsProto.ScanEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    initiator_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&scan_event_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&number_results_) -
        reinterpret_cast<char*>(&scan_event_type_)) + sizeof(number_results_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ScanEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .bluetooth.metrics.BluetoothMetricsProto.ScanEvent.ScanEventType scan_event_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanEventType_IsValid(val))) {
            set_scan_event_type(static_cast<::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanEventType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string initiator = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_initiator(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .bluetooth.metrics.BluetoothMetricsProto.ScanEvent.ScanTechnologyType scan_technology_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanTechnologyType_IsValid(val))) {
            set_scan_technology_type(static_cast<::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanTechnologyType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional int32 number_results = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_number_results(&has_bits);
          number_results_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 event_time_millis = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_event_time_millis(&has_bits);
          event_time_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ScanEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:bluetooth.metrics.BluetoothMetricsProto.ScanEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .bluetooth.metrics.BluetoothMetricsProto.ScanEvent.ScanEventType scan_event_type = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanEventType_IsValid(value)) {
            set_scan_event_type(static_cast< ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanEventType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string initiator = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_initiator()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .bluetooth.metrics.BluetoothMetricsProto.ScanEvent.ScanTechnologyType scan_technology_type = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanTechnologyType_IsValid(value)) {
            set_scan_technology_type(static_cast< ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanTechnologyType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(24u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 number_results = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_number_results(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &number_results_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 event_time_millis = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_event_time_millis(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &event_time_millis_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:bluetooth.metrics.BluetoothMetricsProto.ScanEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:bluetooth.metrics.BluetoothMetricsProto.ScanEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ScanEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:bluetooth.metrics.BluetoothMetricsProto.ScanEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .bluetooth.metrics.BluetoothMetricsProto.ScanEvent.ScanEventType scan_event_type = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->scan_event_type(), output);
  }

  // optional string initiator = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->initiator(), output);
  }

  // optional .bluetooth.metrics.BluetoothMetricsProto.ScanEvent.ScanTechnologyType scan_technology_type = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      3, this->scan_technology_type(), output);
  }

  // optional int32 number_results = 4;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->number_results(), output);
  }

  // optional int64 event_time_millis = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(5, this->event_time_millis(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:bluetooth.metrics.BluetoothMetricsProto.ScanEvent)
}

size_t ScanEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bluetooth.metrics.BluetoothMetricsProto.ScanEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string initiator = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->initiator());
    }

    // optional .bluetooth.metrics.BluetoothMetricsProto.ScanEvent.ScanEventType scan_event_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->scan_event_type());
    }

    // optional .bluetooth.metrics.BluetoothMetricsProto.ScanEvent.ScanTechnologyType scan_technology_type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->scan_technology_type());
    }

    // optional int64 event_time_millis = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->event_time_millis());
    }

    // optional int32 number_results = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->number_results());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ScanEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ScanEvent*>(
      &from));
}

void ScanEvent::MergeFrom(const ScanEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bluetooth.metrics.BluetoothMetricsProto.ScanEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      initiator_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.initiator_);
    }
    if (cached_has_bits & 0x00000002u) {
      scan_event_type_ = from.scan_event_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      scan_technology_type_ = from.scan_technology_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      event_time_millis_ = from.event_time_millis_;
    }
    if (cached_has_bits & 0x00000010u) {
      number_results_ = from.number_results_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ScanEvent::CopyFrom(const ScanEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bluetooth.metrics.BluetoothMetricsProto.ScanEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScanEvent::IsInitialized() const {
  return true;
}

void ScanEvent::InternalSwap(ScanEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  initiator_.Swap(&other->initiator_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(scan_event_type_, other->scan_event_type_);
  swap(scan_technology_type_, other->scan_technology_type_);
  swap(event_time_millis_, other->event_time_millis_);
  swap(number_results_, other->number_results_);
}

std::string ScanEvent::GetTypeName() const {
  return "bluetooth.metrics.BluetoothMetricsProto.ScanEvent";
}


// ===================================================================

void ProfileConnectionStats::InitAsDefaultInstance() {
}
class ProfileConnectionStats::_Internal {
 public:
  using HasBits = decltype(std::declval<ProfileConnectionStats>()._has_bits_);
  static void set_has_profile_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_times_connected(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ProfileConnectionStats::ProfileConnectionStats()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats)
}
ProfileConnectionStats::ProfileConnectionStats(const ProfileConnectionStats& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&profile_id_, &from.profile_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&num_times_connected_) -
    reinterpret_cast<char*>(&profile_id_)) + sizeof(num_times_connected_));
  // @@protoc_insertion_point(copy_constructor:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats)
}

void ProfileConnectionStats::SharedCtor() {
  ::memset(&profile_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&num_times_connected_) -
      reinterpret_cast<char*>(&profile_id_)) + sizeof(num_times_connected_));
}

ProfileConnectionStats::~ProfileConnectionStats() {
  // @@protoc_insertion_point(destructor:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats)
  SharedDtor();
}

void ProfileConnectionStats::SharedDtor() {
}

void ProfileConnectionStats::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ProfileConnectionStats& ProfileConnectionStats::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ProfileConnectionStats_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto.base);
  return *internal_default_instance();
}


void ProfileConnectionStats::Clear() {
// @@protoc_insertion_point(message_clear_start:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&profile_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&num_times_connected_) -
        reinterpret_cast<char*>(&profile_id_)) + sizeof(num_times_connected_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ProfileConnectionStats::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .bluetooth.metrics.BluetoothMetricsProto.ProfileId profile_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::bluetooth::metrics::BluetoothMetricsProto::ProfileId_IsValid(val))) {
            set_profile_id(static_cast<::bluetooth::metrics::BluetoothMetricsProto::ProfileId>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional int32 num_times_connected = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_num_times_connected(&has_bits);
          num_times_connected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ProfileConnectionStats::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .bluetooth.metrics.BluetoothMetricsProto.ProfileId profile_id = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::bluetooth::metrics::BluetoothMetricsProto::ProfileId_IsValid(value)) {
            set_profile_id(static_cast< ::bluetooth::metrics::BluetoothMetricsProto::ProfileId >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_times_connected = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_num_times_connected(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_times_connected_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ProfileConnectionStats::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .bluetooth.metrics.BluetoothMetricsProto.ProfileId profile_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->profile_id(), output);
  }

  // optional int32 num_times_connected = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->num_times_connected(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats)
}

size_t ProfileConnectionStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .bluetooth.metrics.BluetoothMetricsProto.ProfileId profile_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->profile_id());
    }

    // optional int32 num_times_connected = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_times_connected());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ProfileConnectionStats::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ProfileConnectionStats*>(
      &from));
}

void ProfileConnectionStats::MergeFrom(const ProfileConnectionStats& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      profile_id_ = from.profile_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      num_times_connected_ = from.num_times_connected_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ProfileConnectionStats::CopyFrom(const ProfileConnectionStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProfileConnectionStats::IsInitialized() const {
  return true;
}

void ProfileConnectionStats::InternalSwap(ProfileConnectionStats* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(profile_id_, other->profile_id_);
  swap(num_times_connected_, other->num_times_connected_);
}

std::string ProfileConnectionStats::GetTypeName() const {
  return "bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats";
}


// ===================================================================

void HeadsetProfileConnectionStats::InitAsDefaultInstance() {
}
class HeadsetProfileConnectionStats::_Internal {
 public:
  using HasBits = decltype(std::declval<HeadsetProfileConnectionStats>()._has_bits_);
  static void set_has_headset_profile_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_times_connected(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

HeadsetProfileConnectionStats::HeadsetProfileConnectionStats()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats)
}
HeadsetProfileConnectionStats::HeadsetProfileConnectionStats(const HeadsetProfileConnectionStats& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&headset_profile_type_, &from.headset_profile_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&num_times_connected_) -
    reinterpret_cast<char*>(&headset_profile_type_)) + sizeof(num_times_connected_));
  // @@protoc_insertion_point(copy_constructor:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats)
}

void HeadsetProfileConnectionStats::SharedCtor() {
  ::memset(&headset_profile_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&num_times_connected_) -
      reinterpret_cast<char*>(&headset_profile_type_)) + sizeof(num_times_connected_));
}

HeadsetProfileConnectionStats::~HeadsetProfileConnectionStats() {
  // @@protoc_insertion_point(destructor:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats)
  SharedDtor();
}

void HeadsetProfileConnectionStats::SharedDtor() {
}

void HeadsetProfileConnectionStats::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const HeadsetProfileConnectionStats& HeadsetProfileConnectionStats::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_HeadsetProfileConnectionStats_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto.base);
  return *internal_default_instance();
}


void HeadsetProfileConnectionStats::Clear() {
// @@protoc_insertion_point(message_clear_start:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&headset_profile_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&num_times_connected_) -
        reinterpret_cast<char*>(&headset_profile_type_)) + sizeof(num_times_connected_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* HeadsetProfileConnectionStats::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileType headset_profile_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileType_IsValid(val))) {
            set_headset_profile_type(static_cast<::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional int32 num_times_connected = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_num_times_connected(&has_bits);
          num_times_connected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool HeadsetProfileConnectionStats::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileType headset_profile_type = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileType_IsValid(value)) {
            set_headset_profile_type(static_cast< ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_times_connected = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_num_times_connected(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_times_connected_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void HeadsetProfileConnectionStats::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileType headset_profile_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->headset_profile_type(), output);
  }

  // optional int32 num_times_connected = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->num_times_connected(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats)
}

size_t HeadsetProfileConnectionStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileType headset_profile_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->headset_profile_type());
    }

    // optional int32 num_times_connected = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_times_connected());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HeadsetProfileConnectionStats::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const HeadsetProfileConnectionStats*>(
      &from));
}

void HeadsetProfileConnectionStats::MergeFrom(const HeadsetProfileConnectionStats& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      headset_profile_type_ = from.headset_profile_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      num_times_connected_ = from.num_times_connected_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void HeadsetProfileConnectionStats::CopyFrom(const HeadsetProfileConnectionStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeadsetProfileConnectionStats::IsInitialized() const {
  return true;
}

void HeadsetProfileConnectionStats::InternalSwap(HeadsetProfileConnectionStats* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(headset_profile_type_, other->headset_profile_type_);
  swap(num_times_connected_, other->num_times_connected_);
}

std::string HeadsetProfileConnectionStats::GetTypeName() const {
  return "bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace BluetoothMetricsProto
}  // namespace metrics
}  // namespace bluetooth
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::bluetooth::metrics::BluetoothMetricsProto::BluetoothLog* Arena::CreateMaybeMessage< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothLog >(Arena* arena) {
  return Arena::CreateInternal< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothLog >(arena);
}
template<> PROTOBUF_NOINLINE ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* Arena::CreateMaybeMessage< ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo >(Arena* arena) {
  return Arena::CreateInternal< ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession* Arena::CreateMaybeMessage< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession >(Arena* arena) {
  return Arena::CreateInternal< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession >(arena);
}
template<> PROTOBUF_NOINLINE ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* Arena::CreateMaybeMessage< ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession >(Arena* arena) {
  return Arena::CreateInternal< ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession >(arena);
}
template<> PROTOBUF_NOINLINE ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* Arena::CreateMaybeMessage< ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession >(Arena* arena) {
  return Arena::CreateInternal< ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession >(arena);
}
template<> PROTOBUF_NOINLINE ::bluetooth::metrics::BluetoothMetricsProto::PairEvent* Arena::CreateMaybeMessage< ::bluetooth::metrics::BluetoothMetricsProto::PairEvent >(Arena* arena) {
  return Arena::CreateInternal< ::bluetooth::metrics::BluetoothMetricsProto::PairEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent* Arena::CreateMaybeMessage< ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent >(Arena* arena) {
  return Arena::CreateInternal< ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent* Arena::CreateMaybeMessage< ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent >(Arena* arena) {
  return Arena::CreateInternal< ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats* Arena::CreateMaybeMessage< ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats >(Arena* arena) {
  return Arena::CreateInternal< ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats >(arena);
}
template<> PROTOBUF_NOINLINE ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats* Arena::CreateMaybeMessage< ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats >(Arena* arena) {
  return Arena::CreateInternal< ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
