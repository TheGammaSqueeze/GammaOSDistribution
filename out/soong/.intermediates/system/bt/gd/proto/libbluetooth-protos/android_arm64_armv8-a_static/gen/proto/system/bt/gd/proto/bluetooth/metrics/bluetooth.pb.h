// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: system/bt/gd/proto/bluetooth/metrics/bluetooth.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace bluetooth {
namespace metrics {
namespace BluetoothMetricsProto {
class A2DPSession;
class A2DPSessionDefaultTypeInternal;
extern A2DPSessionDefaultTypeInternal _A2DPSession_default_instance_;
class BluetoothLog;
class BluetoothLogDefaultTypeInternal;
extern BluetoothLogDefaultTypeInternal _BluetoothLog_default_instance_;
class BluetoothSession;
class BluetoothSessionDefaultTypeInternal;
extern BluetoothSessionDefaultTypeInternal _BluetoothSession_default_instance_;
class DeviceInfo;
class DeviceInfoDefaultTypeInternal;
extern DeviceInfoDefaultTypeInternal _DeviceInfo_default_instance_;
class HeadsetProfileConnectionStats;
class HeadsetProfileConnectionStatsDefaultTypeInternal;
extern HeadsetProfileConnectionStatsDefaultTypeInternal _HeadsetProfileConnectionStats_default_instance_;
class PairEvent;
class PairEventDefaultTypeInternal;
extern PairEventDefaultTypeInternal _PairEvent_default_instance_;
class ProfileConnectionStats;
class ProfileConnectionStatsDefaultTypeInternal;
extern ProfileConnectionStatsDefaultTypeInternal _ProfileConnectionStats_default_instance_;
class RFCommSession;
class RFCommSessionDefaultTypeInternal;
extern RFCommSessionDefaultTypeInternal _RFCommSession_default_instance_;
class ScanEvent;
class ScanEventDefaultTypeInternal;
extern ScanEventDefaultTypeInternal _ScanEvent_default_instance_;
class WakeEvent;
class WakeEventDefaultTypeInternal;
extern WakeEventDefaultTypeInternal _WakeEvent_default_instance_;
}  // namespace BluetoothMetricsProto
}  // namespace metrics
}  // namespace bluetooth
PROTOBUF_NAMESPACE_OPEN
template<> ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* Arena::CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::A2DPSession>(Arena*);
template<> ::bluetooth::metrics::BluetoothMetricsProto::BluetoothLog* Arena::CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::BluetoothLog>(Arena*);
template<> ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession* Arena::CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession>(Arena*);
template<> ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* Arena::CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo>(Arena*);
template<> ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats* Arena::CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats>(Arena*);
template<> ::bluetooth::metrics::BluetoothMetricsProto::PairEvent* Arena::CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::PairEvent>(Arena*);
template<> ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats* Arena::CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats>(Arena*);
template<> ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* Arena::CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::RFCommSession>(Arena*);
template<> ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent* Arena::CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::ScanEvent>(Arena*);
template<> ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent* Arena::CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::WakeEvent>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bluetooth {
namespace metrics {
namespace BluetoothMetricsProto {

enum DeviceInfo_DeviceType : int {
  DeviceInfo_DeviceType_DEVICE_TYPE_UNKNOWN = 0,
  DeviceInfo_DeviceType_DEVICE_TYPE_BREDR = 1,
  DeviceInfo_DeviceType_DEVICE_TYPE_LE = 2,
  DeviceInfo_DeviceType_DEVICE_TYPE_DUMO = 3
};
bool DeviceInfo_DeviceType_IsValid(int value);
constexpr DeviceInfo_DeviceType DeviceInfo_DeviceType_DeviceType_MIN = DeviceInfo_DeviceType_DEVICE_TYPE_UNKNOWN;
constexpr DeviceInfo_DeviceType DeviceInfo_DeviceType_DeviceType_MAX = DeviceInfo_DeviceType_DEVICE_TYPE_DUMO;
constexpr int DeviceInfo_DeviceType_DeviceType_ARRAYSIZE = DeviceInfo_DeviceType_DeviceType_MAX + 1;

const std::string& DeviceInfo_DeviceType_Name(DeviceInfo_DeviceType value);
template<typename T>
inline const std::string& DeviceInfo_DeviceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceInfo_DeviceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceInfo_DeviceType_Name.");
  return DeviceInfo_DeviceType_Name(static_cast<DeviceInfo_DeviceType>(enum_t_value));
}
bool DeviceInfo_DeviceType_Parse(
    const std::string& name, DeviceInfo_DeviceType* value);
enum BluetoothSession_ConnectionTechnologyType : int {
  BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_UNKNOWN = 0,
  BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_LE = 1,
  BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_BREDR = 2
};
bool BluetoothSession_ConnectionTechnologyType_IsValid(int value);
constexpr BluetoothSession_ConnectionTechnologyType BluetoothSession_ConnectionTechnologyType_ConnectionTechnologyType_MIN = BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_UNKNOWN;
constexpr BluetoothSession_ConnectionTechnologyType BluetoothSession_ConnectionTechnologyType_ConnectionTechnologyType_MAX = BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_BREDR;
constexpr int BluetoothSession_ConnectionTechnologyType_ConnectionTechnologyType_ARRAYSIZE = BluetoothSession_ConnectionTechnologyType_ConnectionTechnologyType_MAX + 1;

const std::string& BluetoothSession_ConnectionTechnologyType_Name(BluetoothSession_ConnectionTechnologyType value);
template<typename T>
inline const std::string& BluetoothSession_ConnectionTechnologyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BluetoothSession_ConnectionTechnologyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BluetoothSession_ConnectionTechnologyType_Name.");
  return BluetoothSession_ConnectionTechnologyType_Name(static_cast<BluetoothSession_ConnectionTechnologyType>(enum_t_value));
}
bool BluetoothSession_ConnectionTechnologyType_Parse(
    const std::string& name, BluetoothSession_ConnectionTechnologyType* value);
enum BluetoothSession_DisconnectReasonType : int {
  BluetoothSession_DisconnectReasonType_UNKNOWN = 0,
  BluetoothSession_DisconnectReasonType_METRICS_DUMP = 1,
  BluetoothSession_DisconnectReasonType_NEXT_START_WITHOUT_END_PREVIOUS = 2
};
bool BluetoothSession_DisconnectReasonType_IsValid(int value);
constexpr BluetoothSession_DisconnectReasonType BluetoothSession_DisconnectReasonType_DisconnectReasonType_MIN = BluetoothSession_DisconnectReasonType_UNKNOWN;
constexpr BluetoothSession_DisconnectReasonType BluetoothSession_DisconnectReasonType_DisconnectReasonType_MAX = BluetoothSession_DisconnectReasonType_NEXT_START_WITHOUT_END_PREVIOUS;
constexpr int BluetoothSession_DisconnectReasonType_DisconnectReasonType_ARRAYSIZE = BluetoothSession_DisconnectReasonType_DisconnectReasonType_MAX + 1;

const std::string& BluetoothSession_DisconnectReasonType_Name(BluetoothSession_DisconnectReasonType value);
template<typename T>
inline const std::string& BluetoothSession_DisconnectReasonType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BluetoothSession_DisconnectReasonType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BluetoothSession_DisconnectReasonType_Name.");
  return BluetoothSession_DisconnectReasonType_Name(static_cast<BluetoothSession_DisconnectReasonType>(enum_t_value));
}
bool BluetoothSession_DisconnectReasonType_Parse(
    const std::string& name, BluetoothSession_DisconnectReasonType* value);
enum WakeEvent_WakeEventType : int {
  WakeEvent_WakeEventType_UNKNOWN = 0,
  WakeEvent_WakeEventType_ACQUIRED = 1,
  WakeEvent_WakeEventType_RELEASED = 2
};
bool WakeEvent_WakeEventType_IsValid(int value);
constexpr WakeEvent_WakeEventType WakeEvent_WakeEventType_WakeEventType_MIN = WakeEvent_WakeEventType_UNKNOWN;
constexpr WakeEvent_WakeEventType WakeEvent_WakeEventType_WakeEventType_MAX = WakeEvent_WakeEventType_RELEASED;
constexpr int WakeEvent_WakeEventType_WakeEventType_ARRAYSIZE = WakeEvent_WakeEventType_WakeEventType_MAX + 1;

const std::string& WakeEvent_WakeEventType_Name(WakeEvent_WakeEventType value);
template<typename T>
inline const std::string& WakeEvent_WakeEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WakeEvent_WakeEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WakeEvent_WakeEventType_Name.");
  return WakeEvent_WakeEventType_Name(static_cast<WakeEvent_WakeEventType>(enum_t_value));
}
bool WakeEvent_WakeEventType_Parse(
    const std::string& name, WakeEvent_WakeEventType* value);
enum ScanEvent_ScanTechnologyType : int {
  ScanEvent_ScanTechnologyType_SCAN_TYPE_UNKNOWN = 0,
  ScanEvent_ScanTechnologyType_SCAN_TECH_TYPE_LE = 1,
  ScanEvent_ScanTechnologyType_SCAN_TECH_TYPE_BREDR = 2,
  ScanEvent_ScanTechnologyType_SCAN_TECH_TYPE_BOTH = 3
};
bool ScanEvent_ScanTechnologyType_IsValid(int value);
constexpr ScanEvent_ScanTechnologyType ScanEvent_ScanTechnologyType_ScanTechnologyType_MIN = ScanEvent_ScanTechnologyType_SCAN_TYPE_UNKNOWN;
constexpr ScanEvent_ScanTechnologyType ScanEvent_ScanTechnologyType_ScanTechnologyType_MAX = ScanEvent_ScanTechnologyType_SCAN_TECH_TYPE_BOTH;
constexpr int ScanEvent_ScanTechnologyType_ScanTechnologyType_ARRAYSIZE = ScanEvent_ScanTechnologyType_ScanTechnologyType_MAX + 1;

const std::string& ScanEvent_ScanTechnologyType_Name(ScanEvent_ScanTechnologyType value);
template<typename T>
inline const std::string& ScanEvent_ScanTechnologyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ScanEvent_ScanTechnologyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ScanEvent_ScanTechnologyType_Name.");
  return ScanEvent_ScanTechnologyType_Name(static_cast<ScanEvent_ScanTechnologyType>(enum_t_value));
}
bool ScanEvent_ScanTechnologyType_Parse(
    const std::string& name, ScanEvent_ScanTechnologyType* value);
enum ScanEvent_ScanEventType : int {
  ScanEvent_ScanEventType_SCAN_EVENT_START = 0,
  ScanEvent_ScanEventType_SCAN_EVENT_STOP = 1
};
bool ScanEvent_ScanEventType_IsValid(int value);
constexpr ScanEvent_ScanEventType ScanEvent_ScanEventType_ScanEventType_MIN = ScanEvent_ScanEventType_SCAN_EVENT_START;
constexpr ScanEvent_ScanEventType ScanEvent_ScanEventType_ScanEventType_MAX = ScanEvent_ScanEventType_SCAN_EVENT_STOP;
constexpr int ScanEvent_ScanEventType_ScanEventType_ARRAYSIZE = ScanEvent_ScanEventType_ScanEventType_MAX + 1;

const std::string& ScanEvent_ScanEventType_Name(ScanEvent_ScanEventType value);
template<typename T>
inline const std::string& ScanEvent_ScanEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ScanEvent_ScanEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ScanEvent_ScanEventType_Name.");
  return ScanEvent_ScanEventType_Name(static_cast<ScanEvent_ScanEventType>(enum_t_value));
}
bool ScanEvent_ScanEventType_Parse(
    const std::string& name, ScanEvent_ScanEventType* value);
enum A2dpSourceCodec : int {
  A2DP_SOURCE_CODEC_UNKNOWN = 0,
  A2DP_SOURCE_CODEC_SBC = 1,
  A2DP_SOURCE_CODEC_AAC = 2,
  A2DP_SOURCE_CODEC_APTX = 3,
  A2DP_SOURCE_CODEC_APTX_HD = 4,
  A2DP_SOURCE_CODEC_LDAC = 5
};
bool A2dpSourceCodec_IsValid(int value);
constexpr A2dpSourceCodec A2dpSourceCodec_MIN = A2DP_SOURCE_CODEC_UNKNOWN;
constexpr A2dpSourceCodec A2dpSourceCodec_MAX = A2DP_SOURCE_CODEC_LDAC;
constexpr int A2dpSourceCodec_ARRAYSIZE = A2dpSourceCodec_MAX + 1;

const std::string& A2dpSourceCodec_Name(A2dpSourceCodec value);
template<typename T>
inline const std::string& A2dpSourceCodec_Name(T enum_t_value) {
  static_assert(::std::is_same<T, A2dpSourceCodec>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function A2dpSourceCodec_Name.");
  return A2dpSourceCodec_Name(static_cast<A2dpSourceCodec>(enum_t_value));
}
bool A2dpSourceCodec_Parse(
    const std::string& name, A2dpSourceCodec* value);
enum ProfileId : int {
  PROFILE_UNKNOWN = 0,
  HEADSET = 1,
  A2DP = 2,
  HEALTH = 3,
  HID_HOST = 4,
  PAN = 5,
  PBAP = 6,
  GATT = 7,
  GATT_SERVER = 8,
  MAP = 9,
  SAP = 10,
  A2DP_SINK = 11,
  AVRCP_CONTROLLER = 12,
  AVRCP = 13,
  HEADSET_CLIENT = 16,
  PBAP_CLIENT = 17,
  MAP_CLIENT = 18,
  HID_DEVICE = 19,
  OPP = 20,
  HEARING_AID = 21
};
bool ProfileId_IsValid(int value);
constexpr ProfileId ProfileId_MIN = PROFILE_UNKNOWN;
constexpr ProfileId ProfileId_MAX = HEARING_AID;
constexpr int ProfileId_ARRAYSIZE = ProfileId_MAX + 1;

const std::string& ProfileId_Name(ProfileId value);
template<typename T>
inline const std::string& ProfileId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProfileId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProfileId_Name.");
  return ProfileId_Name(static_cast<ProfileId>(enum_t_value));
}
bool ProfileId_Parse(
    const std::string& name, ProfileId* value);
enum HeadsetProfileType : int {
  HEADSET_PROFILE_UNKNOWN = 0,
  HSP = 1,
  HFP = 2
};
bool HeadsetProfileType_IsValid(int value);
constexpr HeadsetProfileType HeadsetProfileType_MIN = HEADSET_PROFILE_UNKNOWN;
constexpr HeadsetProfileType HeadsetProfileType_MAX = HFP;
constexpr int HeadsetProfileType_ARRAYSIZE = HeadsetProfileType_MAX + 1;

const std::string& HeadsetProfileType_Name(HeadsetProfileType value);
template<typename T>
inline const std::string& HeadsetProfileType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HeadsetProfileType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HeadsetProfileType_Name.");
  return HeadsetProfileType_Name(static_cast<HeadsetProfileType>(enum_t_value));
}
bool HeadsetProfileType_Parse(
    const std::string& name, HeadsetProfileType* value);
// ===================================================================

class BluetoothLog :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog) */ {
 public:
  BluetoothLog();
  virtual ~BluetoothLog();

  BluetoothLog(const BluetoothLog& from);
  BluetoothLog(BluetoothLog&& from) noexcept
    : BluetoothLog() {
    *this = ::std::move(from);
  }

  inline BluetoothLog& operator=(const BluetoothLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline BluetoothLog& operator=(BluetoothLog&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const BluetoothLog& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BluetoothLog* internal_default_instance() {
    return reinterpret_cast<const BluetoothLog*>(
               &_BluetoothLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BluetoothLog& a, BluetoothLog& b) {
    a.Swap(&b);
  }
  inline void Swap(BluetoothLog* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BluetoothLog* New() const final {
    return CreateMaybeMessage<BluetoothLog>(nullptr);
  }

  BluetoothLog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BluetoothLog>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const BluetoothLog& from);
  void MergeFrom(const BluetoothLog& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BluetoothLog* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bluetooth.metrics.BluetoothMetricsProto.BluetoothLog";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionFieldNumber = 1,
    kPairEventFieldNumber = 2,
    kWakeEventFieldNumber = 3,
    kScanEventFieldNumber = 4,
    kProfileConnectionStatsFieldNumber = 10,
    kHeadsetProfileConnectionStatsFieldNumber = 11,
    kNumBluetoothSessionFieldNumber = 6,
    kNumPairEventFieldNumber = 7,
    kNumWakeEventFieldNumber = 8,
    kNumScanEventFieldNumber = 9,
    kNumBondedDevicesFieldNumber = 5,
  };
  // repeated .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession session = 1;
  int session_size() const;
  void clear_session();
  ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession* mutable_session(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession >*
      mutable_session();
  const ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession& session(int index) const;
  ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession* add_session();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession >&
      session() const;

  // repeated .bluetooth.metrics.BluetoothMetricsProto.PairEvent pair_event = 2;
  int pair_event_size() const;
  void clear_pair_event();
  ::bluetooth::metrics::BluetoothMetricsProto::PairEvent* mutable_pair_event(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::PairEvent >*
      mutable_pair_event();
  const ::bluetooth::metrics::BluetoothMetricsProto::PairEvent& pair_event(int index) const;
  ::bluetooth::metrics::BluetoothMetricsProto::PairEvent* add_pair_event();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::PairEvent >&
      pair_event() const;

  // repeated .bluetooth.metrics.BluetoothMetricsProto.WakeEvent wake_event = 3;
  int wake_event_size() const;
  void clear_wake_event();
  ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent* mutable_wake_event(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent >*
      mutable_wake_event();
  const ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent& wake_event(int index) const;
  ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent* add_wake_event();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent >&
      wake_event() const;

  // repeated .bluetooth.metrics.BluetoothMetricsProto.ScanEvent scan_event = 4;
  int scan_event_size() const;
  void clear_scan_event();
  ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent* mutable_scan_event(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent >*
      mutable_scan_event();
  const ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent& scan_event(int index) const;
  ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent* add_scan_event();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent >&
      scan_event() const;

  // repeated .bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats profile_connection_stats = 10;
  int profile_connection_stats_size() const;
  void clear_profile_connection_stats();
  ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats* mutable_profile_connection_stats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats >*
      mutable_profile_connection_stats();
  const ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats& profile_connection_stats(int index) const;
  ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats* add_profile_connection_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats >&
      profile_connection_stats() const;

  // repeated .bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats headset_profile_connection_stats = 11;
  int headset_profile_connection_stats_size() const;
  void clear_headset_profile_connection_stats();
  ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats* mutable_headset_profile_connection_stats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats >*
      mutable_headset_profile_connection_stats();
  const ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats& headset_profile_connection_stats(int index) const;
  ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats* add_headset_profile_connection_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats >&
      headset_profile_connection_stats() const;

  // optional int64 num_bluetooth_session = 6;
  bool has_num_bluetooth_session() const;
  void clear_num_bluetooth_session();
  ::PROTOBUF_NAMESPACE_ID::int64 num_bluetooth_session() const;
  void set_num_bluetooth_session(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 num_pair_event = 7;
  bool has_num_pair_event() const;
  void clear_num_pair_event();
  ::PROTOBUF_NAMESPACE_ID::int64 num_pair_event() const;
  void set_num_pair_event(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 num_wake_event = 8;
  bool has_num_wake_event() const;
  void clear_num_wake_event();
  ::PROTOBUF_NAMESPACE_ID::int64 num_wake_event() const;
  void set_num_wake_event(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 num_scan_event = 9;
  bool has_num_scan_event() const;
  void clear_num_scan_event();
  ::PROTOBUF_NAMESPACE_ID::int64 num_scan_event() const;
  void set_num_scan_event(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int32 num_bonded_devices = 5;
  bool has_num_bonded_devices() const;
  void clear_num_bonded_devices();
  ::PROTOBUF_NAMESPACE_ID::int32 num_bonded_devices() const;
  void set_num_bonded_devices(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession > session_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::PairEvent > pair_event_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent > wake_event_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent > scan_event_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats > profile_connection_stats_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats > headset_profile_connection_stats_;
  ::PROTOBUF_NAMESPACE_ID::int64 num_bluetooth_session_;
  ::PROTOBUF_NAMESPACE_ID::int64 num_pair_event_;
  ::PROTOBUF_NAMESPACE_ID::int64 num_wake_event_;
  ::PROTOBUF_NAMESPACE_ID::int64 num_scan_event_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_bonded_devices_;
  friend struct ::TableStruct_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
};
// -------------------------------------------------------------------

class DeviceInfo :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo) */ {
 public:
  DeviceInfo();
  virtual ~DeviceInfo();

  DeviceInfo(const DeviceInfo& from);
  DeviceInfo(DeviceInfo&& from) noexcept
    : DeviceInfo() {
    *this = ::std::move(from);
  }

  inline DeviceInfo& operator=(const DeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceInfo& operator=(DeviceInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DeviceInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeviceInfo* internal_default_instance() {
    return reinterpret_cast<const DeviceInfo*>(
               &_DeviceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DeviceInfo& a, DeviceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeviceInfo* New() const final {
    return CreateMaybeMessage<DeviceInfo>(nullptr);
  }

  DeviceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeviceInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DeviceInfo& from);
  void MergeFrom(const DeviceInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bluetooth.metrics.BluetoothMetricsProto.DeviceInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DeviceInfo_DeviceType DeviceType;
  static constexpr DeviceType DEVICE_TYPE_UNKNOWN =
    DeviceInfo_DeviceType_DEVICE_TYPE_UNKNOWN;
  static constexpr DeviceType DEVICE_TYPE_BREDR =
    DeviceInfo_DeviceType_DEVICE_TYPE_BREDR;
  static constexpr DeviceType DEVICE_TYPE_LE =
    DeviceInfo_DeviceType_DEVICE_TYPE_LE;
  static constexpr DeviceType DEVICE_TYPE_DUMO =
    DeviceInfo_DeviceType_DEVICE_TYPE_DUMO;
  static inline bool DeviceType_IsValid(int value) {
    return DeviceInfo_DeviceType_IsValid(value);
  }
  static constexpr DeviceType DeviceType_MIN =
    DeviceInfo_DeviceType_DeviceType_MIN;
  static constexpr DeviceType DeviceType_MAX =
    DeviceInfo_DeviceType_DeviceType_MAX;
  static constexpr int DeviceType_ARRAYSIZE =
    DeviceInfo_DeviceType_DeviceType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& DeviceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DeviceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DeviceType_Name.");
    return DeviceInfo_DeviceType_Name(enum_t_value);
  }
  static inline bool DeviceType_Parse(const std::string& name,
      DeviceType* value) {
    return DeviceInfo_DeviceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceClassFieldNumber = 1,
    kDeviceTypeFieldNumber = 2,
  };
  // optional int32 device_class = 1;
  bool has_device_class() const;
  void clear_device_class();
  ::PROTOBUF_NAMESPACE_ID::int32 device_class() const;
  void set_device_class(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo.DeviceType device_type = 2;
  bool has_device_type() const;
  void clear_device_type();
  ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo_DeviceType device_type() const;
  void set_device_type(::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo_DeviceType value);

  // @@protoc_insertion_point(class_scope:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 device_class_;
  int device_type_;
  friend struct ::TableStruct_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
};
// -------------------------------------------------------------------

class BluetoothSession :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession) */ {
 public:
  BluetoothSession();
  virtual ~BluetoothSession();

  BluetoothSession(const BluetoothSession& from);
  BluetoothSession(BluetoothSession&& from) noexcept
    : BluetoothSession() {
    *this = ::std::move(from);
  }

  inline BluetoothSession& operator=(const BluetoothSession& from) {
    CopyFrom(from);
    return *this;
  }
  inline BluetoothSession& operator=(BluetoothSession&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const BluetoothSession& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BluetoothSession* internal_default_instance() {
    return reinterpret_cast<const BluetoothSession*>(
               &_BluetoothSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BluetoothSession& a, BluetoothSession& b) {
    a.Swap(&b);
  }
  inline void Swap(BluetoothSession* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BluetoothSession* New() const final {
    return CreateMaybeMessage<BluetoothSession>(nullptr);
  }

  BluetoothSession* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BluetoothSession>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const BluetoothSession& from);
  void MergeFrom(const BluetoothSession& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BluetoothSession* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bluetooth.metrics.BluetoothMetricsProto.BluetoothSession";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef BluetoothSession_ConnectionTechnologyType ConnectionTechnologyType;
  static constexpr ConnectionTechnologyType CONNECTION_TECHNOLOGY_TYPE_UNKNOWN =
    BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_UNKNOWN;
  static constexpr ConnectionTechnologyType CONNECTION_TECHNOLOGY_TYPE_LE =
    BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_LE;
  static constexpr ConnectionTechnologyType CONNECTION_TECHNOLOGY_TYPE_BREDR =
    BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_BREDR;
  static inline bool ConnectionTechnologyType_IsValid(int value) {
    return BluetoothSession_ConnectionTechnologyType_IsValid(value);
  }
  static constexpr ConnectionTechnologyType ConnectionTechnologyType_MIN =
    BluetoothSession_ConnectionTechnologyType_ConnectionTechnologyType_MIN;
  static constexpr ConnectionTechnologyType ConnectionTechnologyType_MAX =
    BluetoothSession_ConnectionTechnologyType_ConnectionTechnologyType_MAX;
  static constexpr int ConnectionTechnologyType_ARRAYSIZE =
    BluetoothSession_ConnectionTechnologyType_ConnectionTechnologyType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ConnectionTechnologyType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ConnectionTechnologyType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ConnectionTechnologyType_Name.");
    return BluetoothSession_ConnectionTechnologyType_Name(enum_t_value);
  }
  static inline bool ConnectionTechnologyType_Parse(const std::string& name,
      ConnectionTechnologyType* value) {
    return BluetoothSession_ConnectionTechnologyType_Parse(name, value);
  }

  typedef BluetoothSession_DisconnectReasonType DisconnectReasonType;
  static constexpr DisconnectReasonType UNKNOWN =
    BluetoothSession_DisconnectReasonType_UNKNOWN;
  static constexpr DisconnectReasonType METRICS_DUMP =
    BluetoothSession_DisconnectReasonType_METRICS_DUMP;
  static constexpr DisconnectReasonType NEXT_START_WITHOUT_END_PREVIOUS =
    BluetoothSession_DisconnectReasonType_NEXT_START_WITHOUT_END_PREVIOUS;
  static inline bool DisconnectReasonType_IsValid(int value) {
    return BluetoothSession_DisconnectReasonType_IsValid(value);
  }
  static constexpr DisconnectReasonType DisconnectReasonType_MIN =
    BluetoothSession_DisconnectReasonType_DisconnectReasonType_MIN;
  static constexpr DisconnectReasonType DisconnectReasonType_MAX =
    BluetoothSession_DisconnectReasonType_DisconnectReasonType_MAX;
  static constexpr int DisconnectReasonType_ARRAYSIZE =
    BluetoothSession_DisconnectReasonType_DisconnectReasonType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& DisconnectReasonType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DisconnectReasonType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DisconnectReasonType_Name.");
    return BluetoothSession_DisconnectReasonType_Name(enum_t_value);
  }
  static inline bool DisconnectReasonType_Parse(const std::string& name,
      DisconnectReasonType* value) {
    return BluetoothSession_DisconnectReasonType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDisconnectReasonFieldNumber = 4,
    kDeviceConnectedToFieldNumber = 5,
    kRfcommSessionFieldNumber = 6,
    kA2DpSessionFieldNumber = 7,
    kSessionDurationSecFieldNumber = 2,
    kConnectionTechnologyTypeFieldNumber = 3,
    kDisconnectReasonTypeFieldNumber = 8,
  };
  // optional string disconnect_reason = 4 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_disconnect_reason() const;
  PROTOBUF_DEPRECATED void clear_disconnect_reason();
  PROTOBUF_DEPRECATED const std::string& disconnect_reason() const;
  PROTOBUF_DEPRECATED void set_disconnect_reason(const std::string& value);
  PROTOBUF_DEPRECATED void set_disconnect_reason(std::string&& value);
  PROTOBUF_DEPRECATED void set_disconnect_reason(const char* value);
  PROTOBUF_DEPRECATED void set_disconnect_reason(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_disconnect_reason();
  PROTOBUF_DEPRECATED std::string* release_disconnect_reason();
  PROTOBUF_DEPRECATED void set_allocated_disconnect_reason(std::string* disconnect_reason);

  // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo device_connected_to = 5;
  bool has_device_connected_to() const;
  void clear_device_connected_to();
  const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo& device_connected_to() const;
  ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* release_device_connected_to();
  ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* mutable_device_connected_to();
  void set_allocated_device_connected_to(::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* device_connected_to);

  // optional .bluetooth.metrics.BluetoothMetricsProto.RFCommSession rfcomm_session = 6;
  bool has_rfcomm_session() const;
  void clear_rfcomm_session();
  const ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession& rfcomm_session() const;
  ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* release_rfcomm_session();
  ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* mutable_rfcomm_session();
  void set_allocated_rfcomm_session(::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* rfcomm_session);

  // optional .bluetooth.metrics.BluetoothMetricsProto.A2DPSession a2dp_session = 7;
  bool has_a2dp_session() const;
  void clear_a2dp_session();
  const ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession& a2dp_session() const;
  ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* release_a2dp_session();
  ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* mutable_a2dp_session();
  void set_allocated_a2dp_session(::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* a2dp_session);

  // optional int64 session_duration_sec = 2;
  bool has_session_duration_sec() const;
  void clear_session_duration_sec();
  ::PROTOBUF_NAMESPACE_ID::int64 session_duration_sec() const;
  void set_session_duration_sec(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.ConnectionTechnologyType connection_technology_type = 3;
  bool has_connection_technology_type() const;
  void clear_connection_technology_type();
  ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_ConnectionTechnologyType connection_technology_type() const;
  void set_connection_technology_type(::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_ConnectionTechnologyType value);

  // optional .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.DisconnectReasonType disconnect_reason_type = 8;
  bool has_disconnect_reason_type() const;
  void clear_disconnect_reason_type();
  ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_DisconnectReasonType disconnect_reason_type() const;
  void set_disconnect_reason_type(::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_DisconnectReasonType value);

  // @@protoc_insertion_point(class_scope:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr disconnect_reason_;
  ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* device_connected_to_;
  ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* rfcomm_session_;
  ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* a2dp_session_;
  ::PROTOBUF_NAMESPACE_ID::int64 session_duration_sec_;
  int connection_technology_type_;
  int disconnect_reason_type_;
  friend struct ::TableStruct_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
};
// -------------------------------------------------------------------

class RFCommSession :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:bluetooth.metrics.BluetoothMetricsProto.RFCommSession) */ {
 public:
  RFCommSession();
  virtual ~RFCommSession();

  RFCommSession(const RFCommSession& from);
  RFCommSession(RFCommSession&& from) noexcept
    : RFCommSession() {
    *this = ::std::move(from);
  }

  inline RFCommSession& operator=(const RFCommSession& from) {
    CopyFrom(from);
    return *this;
  }
  inline RFCommSession& operator=(RFCommSession&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RFCommSession& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RFCommSession* internal_default_instance() {
    return reinterpret_cast<const RFCommSession*>(
               &_RFCommSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RFCommSession& a, RFCommSession& b) {
    a.Swap(&b);
  }
  inline void Swap(RFCommSession* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RFCommSession* New() const final {
    return CreateMaybeMessage<RFCommSession>(nullptr);
  }

  RFCommSession* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RFCommSession>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RFCommSession& from);
  void MergeFrom(const RFCommSession& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RFCommSession* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bluetooth.metrics.BluetoothMetricsProto.RFCommSession";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRxBytesFieldNumber = 1,
    kTxBytesFieldNumber = 2,
  };
  // optional int32 rx_bytes = 1;
  bool has_rx_bytes() const;
  void clear_rx_bytes();
  ::PROTOBUF_NAMESPACE_ID::int32 rx_bytes() const;
  void set_rx_bytes(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 tx_bytes = 2;
  bool has_tx_bytes() const;
  void clear_tx_bytes();
  ::PROTOBUF_NAMESPACE_ID::int32 tx_bytes() const;
  void set_tx_bytes(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:bluetooth.metrics.BluetoothMetricsProto.RFCommSession)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 rx_bytes_;
  ::PROTOBUF_NAMESPACE_ID::int32 tx_bytes_;
  friend struct ::TableStruct_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
};
// -------------------------------------------------------------------

class A2DPSession :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:bluetooth.metrics.BluetoothMetricsProto.A2DPSession) */ {
 public:
  A2DPSession();
  virtual ~A2DPSession();

  A2DPSession(const A2DPSession& from);
  A2DPSession(A2DPSession&& from) noexcept
    : A2DPSession() {
    *this = ::std::move(from);
  }

  inline A2DPSession& operator=(const A2DPSession& from) {
    CopyFrom(from);
    return *this;
  }
  inline A2DPSession& operator=(A2DPSession&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const A2DPSession& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const A2DPSession* internal_default_instance() {
    return reinterpret_cast<const A2DPSession*>(
               &_A2DPSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(A2DPSession& a, A2DPSession& b) {
    a.Swap(&b);
  }
  inline void Swap(A2DPSession* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline A2DPSession* New() const final {
    return CreateMaybeMessage<A2DPSession>(nullptr);
  }

  A2DPSession* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<A2DPSession>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const A2DPSession& from);
  void MergeFrom(const A2DPSession& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(A2DPSession* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bluetooth.metrics.BluetoothMetricsProto.A2DPSession";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMediaTimerMinMillisFieldNumber = 1,
    kMediaTimerMaxMillisFieldNumber = 2,
    kMediaTimerAvgMillisFieldNumber = 3,
    kBufferOverrunsMaxCountFieldNumber = 4,
    kBufferOverrunsTotalFieldNumber = 5,
    kBufferUnderrunsAverageFieldNumber = 6,
    kAudioDurationMillisFieldNumber = 8,
    kBufferUnderrunsCountFieldNumber = 7,
    kSourceCodecFieldNumber = 9,
    kIsA2DpOffloadFieldNumber = 10,
  };
  // optional int32 media_timer_min_millis = 1;
  bool has_media_timer_min_millis() const;
  void clear_media_timer_min_millis();
  ::PROTOBUF_NAMESPACE_ID::int32 media_timer_min_millis() const;
  void set_media_timer_min_millis(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 media_timer_max_millis = 2;
  bool has_media_timer_max_millis() const;
  void clear_media_timer_max_millis();
  ::PROTOBUF_NAMESPACE_ID::int32 media_timer_max_millis() const;
  void set_media_timer_max_millis(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 media_timer_avg_millis = 3;
  bool has_media_timer_avg_millis() const;
  void clear_media_timer_avg_millis();
  ::PROTOBUF_NAMESPACE_ID::int32 media_timer_avg_millis() const;
  void set_media_timer_avg_millis(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 buffer_overruns_max_count = 4;
  bool has_buffer_overruns_max_count() const;
  void clear_buffer_overruns_max_count();
  ::PROTOBUF_NAMESPACE_ID::int32 buffer_overruns_max_count() const;
  void set_buffer_overruns_max_count(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 buffer_overruns_total = 5;
  bool has_buffer_overruns_total() const;
  void clear_buffer_overruns_total();
  ::PROTOBUF_NAMESPACE_ID::int32 buffer_overruns_total() const;
  void set_buffer_overruns_total(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional float buffer_underruns_average = 6;
  bool has_buffer_underruns_average() const;
  void clear_buffer_underruns_average();
  float buffer_underruns_average() const;
  void set_buffer_underruns_average(float value);

  // optional int64 audio_duration_millis = 8;
  bool has_audio_duration_millis() const;
  void clear_audio_duration_millis();
  ::PROTOBUF_NAMESPACE_ID::int64 audio_duration_millis() const;
  void set_audio_duration_millis(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int32 buffer_underruns_count = 7;
  bool has_buffer_underruns_count() const;
  void clear_buffer_underruns_count();
  ::PROTOBUF_NAMESPACE_ID::int32 buffer_underruns_count() const;
  void set_buffer_underruns_count(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional .bluetooth.metrics.BluetoothMetricsProto.A2dpSourceCodec source_codec = 9;
  bool has_source_codec() const;
  void clear_source_codec();
  ::bluetooth::metrics::BluetoothMetricsProto::A2dpSourceCodec source_codec() const;
  void set_source_codec(::bluetooth::metrics::BluetoothMetricsProto::A2dpSourceCodec value);

  // optional bool is_a2dp_offload = 10;
  bool has_is_a2dp_offload() const;
  void clear_is_a2dp_offload();
  bool is_a2dp_offload() const;
  void set_is_a2dp_offload(bool value);

  // @@protoc_insertion_point(class_scope:bluetooth.metrics.BluetoothMetricsProto.A2DPSession)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 media_timer_min_millis_;
  ::PROTOBUF_NAMESPACE_ID::int32 media_timer_max_millis_;
  ::PROTOBUF_NAMESPACE_ID::int32 media_timer_avg_millis_;
  ::PROTOBUF_NAMESPACE_ID::int32 buffer_overruns_max_count_;
  ::PROTOBUF_NAMESPACE_ID::int32 buffer_overruns_total_;
  float buffer_underruns_average_;
  ::PROTOBUF_NAMESPACE_ID::int64 audio_duration_millis_;
  ::PROTOBUF_NAMESPACE_ID::int32 buffer_underruns_count_;
  int source_codec_;
  bool is_a2dp_offload_;
  friend struct ::TableStruct_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
};
// -------------------------------------------------------------------

class PairEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:bluetooth.metrics.BluetoothMetricsProto.PairEvent) */ {
 public:
  PairEvent();
  virtual ~PairEvent();

  PairEvent(const PairEvent& from);
  PairEvent(PairEvent&& from) noexcept
    : PairEvent() {
    *this = ::std::move(from);
  }

  inline PairEvent& operator=(const PairEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline PairEvent& operator=(PairEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PairEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PairEvent* internal_default_instance() {
    return reinterpret_cast<const PairEvent*>(
               &_PairEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PairEvent& a, PairEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(PairEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PairEvent* New() const final {
    return CreateMaybeMessage<PairEvent>(nullptr);
  }

  PairEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PairEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PairEvent& from);
  void MergeFrom(const PairEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PairEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bluetooth.metrics.BluetoothMetricsProto.PairEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicePairedWithFieldNumber = 3,
    kEventTimeMillisFieldNumber = 2,
    kDisconnectReasonFieldNumber = 1,
  };
  // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo device_paired_with = 3;
  bool has_device_paired_with() const;
  void clear_device_paired_with();
  const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo& device_paired_with() const;
  ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* release_device_paired_with();
  ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* mutable_device_paired_with();
  void set_allocated_device_paired_with(::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* device_paired_with);

  // optional int64 event_time_millis = 2;
  bool has_event_time_millis() const;
  void clear_event_time_millis();
  ::PROTOBUF_NAMESPACE_ID::int64 event_time_millis() const;
  void set_event_time_millis(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int32 disconnect_reason = 1;
  bool has_disconnect_reason() const;
  void clear_disconnect_reason();
  ::PROTOBUF_NAMESPACE_ID::int32 disconnect_reason() const;
  void set_disconnect_reason(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:bluetooth.metrics.BluetoothMetricsProto.PairEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* device_paired_with_;
  ::PROTOBUF_NAMESPACE_ID::int64 event_time_millis_;
  ::PROTOBUF_NAMESPACE_ID::int32 disconnect_reason_;
  friend struct ::TableStruct_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
};
// -------------------------------------------------------------------

class WakeEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:bluetooth.metrics.BluetoothMetricsProto.WakeEvent) */ {
 public:
  WakeEvent();
  virtual ~WakeEvent();

  WakeEvent(const WakeEvent& from);
  WakeEvent(WakeEvent&& from) noexcept
    : WakeEvent() {
    *this = ::std::move(from);
  }

  inline WakeEvent& operator=(const WakeEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline WakeEvent& operator=(WakeEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const WakeEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WakeEvent* internal_default_instance() {
    return reinterpret_cast<const WakeEvent*>(
               &_WakeEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(WakeEvent& a, WakeEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(WakeEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WakeEvent* New() const final {
    return CreateMaybeMessage<WakeEvent>(nullptr);
  }

  WakeEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WakeEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const WakeEvent& from);
  void MergeFrom(const WakeEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WakeEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bluetooth.metrics.BluetoothMetricsProto.WakeEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef WakeEvent_WakeEventType WakeEventType;
  static constexpr WakeEventType UNKNOWN =
    WakeEvent_WakeEventType_UNKNOWN;
  static constexpr WakeEventType ACQUIRED =
    WakeEvent_WakeEventType_ACQUIRED;
  static constexpr WakeEventType RELEASED =
    WakeEvent_WakeEventType_RELEASED;
  static inline bool WakeEventType_IsValid(int value) {
    return WakeEvent_WakeEventType_IsValid(value);
  }
  static constexpr WakeEventType WakeEventType_MIN =
    WakeEvent_WakeEventType_WakeEventType_MIN;
  static constexpr WakeEventType WakeEventType_MAX =
    WakeEvent_WakeEventType_WakeEventType_MAX;
  static constexpr int WakeEventType_ARRAYSIZE =
    WakeEvent_WakeEventType_WakeEventType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& WakeEventType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, WakeEventType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function WakeEventType_Name.");
    return WakeEvent_WakeEventType_Name(enum_t_value);
  }
  static inline bool WakeEventType_Parse(const std::string& name,
      WakeEventType* value) {
    return WakeEvent_WakeEventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRequestorFieldNumber = 2,
    kNameFieldNumber = 3,
    kEventTimeMillisFieldNumber = 4,
    kWakeEventTypeFieldNumber = 1,
  };
  // optional string requestor = 2;
  bool has_requestor() const;
  void clear_requestor();
  const std::string& requestor() const;
  void set_requestor(const std::string& value);
  void set_requestor(std::string&& value);
  void set_requestor(const char* value);
  void set_requestor(const char* value, size_t size);
  std::string* mutable_requestor();
  std::string* release_requestor();
  void set_allocated_requestor(std::string* requestor);

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // optional int64 event_time_millis = 4;
  bool has_event_time_millis() const;
  void clear_event_time_millis();
  ::PROTOBUF_NAMESPACE_ID::int64 event_time_millis() const;
  void set_event_time_millis(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional .bluetooth.metrics.BluetoothMetricsProto.WakeEvent.WakeEventType wake_event_type = 1;
  bool has_wake_event_type() const;
  void clear_wake_event_type();
  ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent_WakeEventType wake_event_type() const;
  void set_wake_event_type(::bluetooth::metrics::BluetoothMetricsProto::WakeEvent_WakeEventType value);

  // @@protoc_insertion_point(class_scope:bluetooth.metrics.BluetoothMetricsProto.WakeEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requestor_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int64 event_time_millis_;
  int wake_event_type_;
  friend struct ::TableStruct_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
};
// -------------------------------------------------------------------

class ScanEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:bluetooth.metrics.BluetoothMetricsProto.ScanEvent) */ {
 public:
  ScanEvent();
  virtual ~ScanEvent();

  ScanEvent(const ScanEvent& from);
  ScanEvent(ScanEvent&& from) noexcept
    : ScanEvent() {
    *this = ::std::move(from);
  }

  inline ScanEvent& operator=(const ScanEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScanEvent& operator=(ScanEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ScanEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScanEvent* internal_default_instance() {
    return reinterpret_cast<const ScanEvent*>(
               &_ScanEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ScanEvent& a, ScanEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ScanEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScanEvent* New() const final {
    return CreateMaybeMessage<ScanEvent>(nullptr);
  }

  ScanEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScanEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ScanEvent& from);
  void MergeFrom(const ScanEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScanEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bluetooth.metrics.BluetoothMetricsProto.ScanEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ScanEvent_ScanTechnologyType ScanTechnologyType;
  static constexpr ScanTechnologyType SCAN_TYPE_UNKNOWN =
    ScanEvent_ScanTechnologyType_SCAN_TYPE_UNKNOWN;
  static constexpr ScanTechnologyType SCAN_TECH_TYPE_LE =
    ScanEvent_ScanTechnologyType_SCAN_TECH_TYPE_LE;
  static constexpr ScanTechnologyType SCAN_TECH_TYPE_BREDR =
    ScanEvent_ScanTechnologyType_SCAN_TECH_TYPE_BREDR;
  static constexpr ScanTechnologyType SCAN_TECH_TYPE_BOTH =
    ScanEvent_ScanTechnologyType_SCAN_TECH_TYPE_BOTH;
  static inline bool ScanTechnologyType_IsValid(int value) {
    return ScanEvent_ScanTechnologyType_IsValid(value);
  }
  static constexpr ScanTechnologyType ScanTechnologyType_MIN =
    ScanEvent_ScanTechnologyType_ScanTechnologyType_MIN;
  static constexpr ScanTechnologyType ScanTechnologyType_MAX =
    ScanEvent_ScanTechnologyType_ScanTechnologyType_MAX;
  static constexpr int ScanTechnologyType_ARRAYSIZE =
    ScanEvent_ScanTechnologyType_ScanTechnologyType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ScanTechnologyType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ScanTechnologyType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ScanTechnologyType_Name.");
    return ScanEvent_ScanTechnologyType_Name(enum_t_value);
  }
  static inline bool ScanTechnologyType_Parse(const std::string& name,
      ScanTechnologyType* value) {
    return ScanEvent_ScanTechnologyType_Parse(name, value);
  }

  typedef ScanEvent_ScanEventType ScanEventType;
  static constexpr ScanEventType SCAN_EVENT_START =
    ScanEvent_ScanEventType_SCAN_EVENT_START;
  static constexpr ScanEventType SCAN_EVENT_STOP =
    ScanEvent_ScanEventType_SCAN_EVENT_STOP;
  static inline bool ScanEventType_IsValid(int value) {
    return ScanEvent_ScanEventType_IsValid(value);
  }
  static constexpr ScanEventType ScanEventType_MIN =
    ScanEvent_ScanEventType_ScanEventType_MIN;
  static constexpr ScanEventType ScanEventType_MAX =
    ScanEvent_ScanEventType_ScanEventType_MAX;
  static constexpr int ScanEventType_ARRAYSIZE =
    ScanEvent_ScanEventType_ScanEventType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ScanEventType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ScanEventType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ScanEventType_Name.");
    return ScanEvent_ScanEventType_Name(enum_t_value);
  }
  static inline bool ScanEventType_Parse(const std::string& name,
      ScanEventType* value) {
    return ScanEvent_ScanEventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInitiatorFieldNumber = 2,
    kScanEventTypeFieldNumber = 1,
    kScanTechnologyTypeFieldNumber = 3,
    kEventTimeMillisFieldNumber = 5,
    kNumberResultsFieldNumber = 4,
  };
  // optional string initiator = 2;
  bool has_initiator() const;
  void clear_initiator();
  const std::string& initiator() const;
  void set_initiator(const std::string& value);
  void set_initiator(std::string&& value);
  void set_initiator(const char* value);
  void set_initiator(const char* value, size_t size);
  std::string* mutable_initiator();
  std::string* release_initiator();
  void set_allocated_initiator(std::string* initiator);

  // optional .bluetooth.metrics.BluetoothMetricsProto.ScanEvent.ScanEventType scan_event_type = 1;
  bool has_scan_event_type() const;
  void clear_scan_event_type();
  ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanEventType scan_event_type() const;
  void set_scan_event_type(::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanEventType value);

  // optional .bluetooth.metrics.BluetoothMetricsProto.ScanEvent.ScanTechnologyType scan_technology_type = 3;
  bool has_scan_technology_type() const;
  void clear_scan_technology_type();
  ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanTechnologyType scan_technology_type() const;
  void set_scan_technology_type(::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanTechnologyType value);

  // optional int64 event_time_millis = 5;
  bool has_event_time_millis() const;
  void clear_event_time_millis();
  ::PROTOBUF_NAMESPACE_ID::int64 event_time_millis() const;
  void set_event_time_millis(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int32 number_results = 4;
  bool has_number_results() const;
  void clear_number_results();
  ::PROTOBUF_NAMESPACE_ID::int32 number_results() const;
  void set_number_results(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:bluetooth.metrics.BluetoothMetricsProto.ScanEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initiator_;
  int scan_event_type_;
  int scan_technology_type_;
  ::PROTOBUF_NAMESPACE_ID::int64 event_time_millis_;
  ::PROTOBUF_NAMESPACE_ID::int32 number_results_;
  friend struct ::TableStruct_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
};
// -------------------------------------------------------------------

class ProfileConnectionStats :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats) */ {
 public:
  ProfileConnectionStats();
  virtual ~ProfileConnectionStats();

  ProfileConnectionStats(const ProfileConnectionStats& from);
  ProfileConnectionStats(ProfileConnectionStats&& from) noexcept
    : ProfileConnectionStats() {
    *this = ::std::move(from);
  }

  inline ProfileConnectionStats& operator=(const ProfileConnectionStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProfileConnectionStats& operator=(ProfileConnectionStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ProfileConnectionStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProfileConnectionStats* internal_default_instance() {
    return reinterpret_cast<const ProfileConnectionStats*>(
               &_ProfileConnectionStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ProfileConnectionStats& a, ProfileConnectionStats& b) {
    a.Swap(&b);
  }
  inline void Swap(ProfileConnectionStats* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProfileConnectionStats* New() const final {
    return CreateMaybeMessage<ProfileConnectionStats>(nullptr);
  }

  ProfileConnectionStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProfileConnectionStats>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ProfileConnectionStats& from);
  void MergeFrom(const ProfileConnectionStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProfileConnectionStats* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProfileIdFieldNumber = 1,
    kNumTimesConnectedFieldNumber = 2,
  };
  // optional .bluetooth.metrics.BluetoothMetricsProto.ProfileId profile_id = 1;
  bool has_profile_id() const;
  void clear_profile_id();
  ::bluetooth::metrics::BluetoothMetricsProto::ProfileId profile_id() const;
  void set_profile_id(::bluetooth::metrics::BluetoothMetricsProto::ProfileId value);

  // optional int32 num_times_connected = 2;
  bool has_num_times_connected() const;
  void clear_num_times_connected();
  ::PROTOBUF_NAMESPACE_ID::int32 num_times_connected() const;
  void set_num_times_connected(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int profile_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_times_connected_;
  friend struct ::TableStruct_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
};
// -------------------------------------------------------------------

class HeadsetProfileConnectionStats :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats) */ {
 public:
  HeadsetProfileConnectionStats();
  virtual ~HeadsetProfileConnectionStats();

  HeadsetProfileConnectionStats(const HeadsetProfileConnectionStats& from);
  HeadsetProfileConnectionStats(HeadsetProfileConnectionStats&& from) noexcept
    : HeadsetProfileConnectionStats() {
    *this = ::std::move(from);
  }

  inline HeadsetProfileConnectionStats& operator=(const HeadsetProfileConnectionStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeadsetProfileConnectionStats& operator=(HeadsetProfileConnectionStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const HeadsetProfileConnectionStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeadsetProfileConnectionStats* internal_default_instance() {
    return reinterpret_cast<const HeadsetProfileConnectionStats*>(
               &_HeadsetProfileConnectionStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(HeadsetProfileConnectionStats& a, HeadsetProfileConnectionStats& b) {
    a.Swap(&b);
  }
  inline void Swap(HeadsetProfileConnectionStats* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HeadsetProfileConnectionStats* New() const final {
    return CreateMaybeMessage<HeadsetProfileConnectionStats>(nullptr);
  }

  HeadsetProfileConnectionStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeadsetProfileConnectionStats>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const HeadsetProfileConnectionStats& from);
  void MergeFrom(const HeadsetProfileConnectionStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeadsetProfileConnectionStats* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadsetProfileTypeFieldNumber = 1,
    kNumTimesConnectedFieldNumber = 2,
  };
  // optional .bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileType headset_profile_type = 1;
  bool has_headset_profile_type() const;
  void clear_headset_profile_type();
  ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileType headset_profile_type() const;
  void set_headset_profile_type(::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileType value);

  // optional int32 num_times_connected = 2;
  bool has_num_times_connected() const;
  void clear_num_times_connected();
  ::PROTOBUF_NAMESPACE_ID::int32 num_times_connected() const;
  void set_num_times_connected(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int headset_profile_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_times_connected_;
  friend struct ::TableStruct_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BluetoothLog

// repeated .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession session = 1;
inline int BluetoothLog::session_size() const {
  return session_.size();
}
inline void BluetoothLog::clear_session() {
  session_.Clear();
}
inline ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession* BluetoothLog::mutable_session(int index) {
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.session)
  return session_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession >*
BluetoothLog::mutable_session() {
  // @@protoc_insertion_point(field_mutable_list:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.session)
  return &session_;
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession& BluetoothLog::session(int index) const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.session)
  return session_.Get(index);
}
inline ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession* BluetoothLog::add_session() {
  // @@protoc_insertion_point(field_add:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.session)
  return session_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession >&
BluetoothLog::session() const {
  // @@protoc_insertion_point(field_list:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.session)
  return session_;
}

// repeated .bluetooth.metrics.BluetoothMetricsProto.PairEvent pair_event = 2;
inline int BluetoothLog::pair_event_size() const {
  return pair_event_.size();
}
inline void BluetoothLog::clear_pair_event() {
  pair_event_.Clear();
}
inline ::bluetooth::metrics::BluetoothMetricsProto::PairEvent* BluetoothLog::mutable_pair_event(int index) {
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.pair_event)
  return pair_event_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::PairEvent >*
BluetoothLog::mutable_pair_event() {
  // @@protoc_insertion_point(field_mutable_list:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.pair_event)
  return &pair_event_;
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::PairEvent& BluetoothLog::pair_event(int index) const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.pair_event)
  return pair_event_.Get(index);
}
inline ::bluetooth::metrics::BluetoothMetricsProto::PairEvent* BluetoothLog::add_pair_event() {
  // @@protoc_insertion_point(field_add:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.pair_event)
  return pair_event_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::PairEvent >&
BluetoothLog::pair_event() const {
  // @@protoc_insertion_point(field_list:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.pair_event)
  return pair_event_;
}

// repeated .bluetooth.metrics.BluetoothMetricsProto.WakeEvent wake_event = 3;
inline int BluetoothLog::wake_event_size() const {
  return wake_event_.size();
}
inline void BluetoothLog::clear_wake_event() {
  wake_event_.Clear();
}
inline ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent* BluetoothLog::mutable_wake_event(int index) {
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.wake_event)
  return wake_event_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent >*
BluetoothLog::mutable_wake_event() {
  // @@protoc_insertion_point(field_mutable_list:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.wake_event)
  return &wake_event_;
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent& BluetoothLog::wake_event(int index) const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.wake_event)
  return wake_event_.Get(index);
}
inline ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent* BluetoothLog::add_wake_event() {
  // @@protoc_insertion_point(field_add:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.wake_event)
  return wake_event_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent >&
BluetoothLog::wake_event() const {
  // @@protoc_insertion_point(field_list:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.wake_event)
  return wake_event_;
}

// repeated .bluetooth.metrics.BluetoothMetricsProto.ScanEvent scan_event = 4;
inline int BluetoothLog::scan_event_size() const {
  return scan_event_.size();
}
inline void BluetoothLog::clear_scan_event() {
  scan_event_.Clear();
}
inline ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent* BluetoothLog::mutable_scan_event(int index) {
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.scan_event)
  return scan_event_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent >*
BluetoothLog::mutable_scan_event() {
  // @@protoc_insertion_point(field_mutable_list:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.scan_event)
  return &scan_event_;
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent& BluetoothLog::scan_event(int index) const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.scan_event)
  return scan_event_.Get(index);
}
inline ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent* BluetoothLog::add_scan_event() {
  // @@protoc_insertion_point(field_add:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.scan_event)
  return scan_event_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent >&
BluetoothLog::scan_event() const {
  // @@protoc_insertion_point(field_list:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.scan_event)
  return scan_event_;
}

// optional int32 num_bonded_devices = 5;
inline bool BluetoothLog::has_num_bonded_devices() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BluetoothLog::clear_num_bonded_devices() {
  num_bonded_devices_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BluetoothLog::num_bonded_devices() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.num_bonded_devices)
  return num_bonded_devices_;
}
inline void BluetoothLog::set_num_bonded_devices(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  num_bonded_devices_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.num_bonded_devices)
}

// optional int64 num_bluetooth_session = 6;
inline bool BluetoothLog::has_num_bluetooth_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BluetoothLog::clear_num_bluetooth_session() {
  num_bluetooth_session_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BluetoothLog::num_bluetooth_session() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.num_bluetooth_session)
  return num_bluetooth_session_;
}
inline void BluetoothLog::set_num_bluetooth_session(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  num_bluetooth_session_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.num_bluetooth_session)
}

// optional int64 num_pair_event = 7;
inline bool BluetoothLog::has_num_pair_event() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BluetoothLog::clear_num_pair_event() {
  num_pair_event_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BluetoothLog::num_pair_event() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.num_pair_event)
  return num_pair_event_;
}
inline void BluetoothLog::set_num_pair_event(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  num_pair_event_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.num_pair_event)
}

// optional int64 num_wake_event = 8;
inline bool BluetoothLog::has_num_wake_event() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BluetoothLog::clear_num_wake_event() {
  num_wake_event_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BluetoothLog::num_wake_event() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.num_wake_event)
  return num_wake_event_;
}
inline void BluetoothLog::set_num_wake_event(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  num_wake_event_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.num_wake_event)
}

// optional int64 num_scan_event = 9;
inline bool BluetoothLog::has_num_scan_event() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BluetoothLog::clear_num_scan_event() {
  num_scan_event_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BluetoothLog::num_scan_event() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.num_scan_event)
  return num_scan_event_;
}
inline void BluetoothLog::set_num_scan_event(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  num_scan_event_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.num_scan_event)
}

// repeated .bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats profile_connection_stats = 10;
inline int BluetoothLog::profile_connection_stats_size() const {
  return profile_connection_stats_.size();
}
inline void BluetoothLog::clear_profile_connection_stats() {
  profile_connection_stats_.Clear();
}
inline ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats* BluetoothLog::mutable_profile_connection_stats(int index) {
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.profile_connection_stats)
  return profile_connection_stats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats >*
BluetoothLog::mutable_profile_connection_stats() {
  // @@protoc_insertion_point(field_mutable_list:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.profile_connection_stats)
  return &profile_connection_stats_;
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats& BluetoothLog::profile_connection_stats(int index) const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.profile_connection_stats)
  return profile_connection_stats_.Get(index);
}
inline ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats* BluetoothLog::add_profile_connection_stats() {
  // @@protoc_insertion_point(field_add:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.profile_connection_stats)
  return profile_connection_stats_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats >&
BluetoothLog::profile_connection_stats() const {
  // @@protoc_insertion_point(field_list:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.profile_connection_stats)
  return profile_connection_stats_;
}

// repeated .bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats headset_profile_connection_stats = 11;
inline int BluetoothLog::headset_profile_connection_stats_size() const {
  return headset_profile_connection_stats_.size();
}
inline void BluetoothLog::clear_headset_profile_connection_stats() {
  headset_profile_connection_stats_.Clear();
}
inline ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats* BluetoothLog::mutable_headset_profile_connection_stats(int index) {
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.headset_profile_connection_stats)
  return headset_profile_connection_stats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats >*
BluetoothLog::mutable_headset_profile_connection_stats() {
  // @@protoc_insertion_point(field_mutable_list:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.headset_profile_connection_stats)
  return &headset_profile_connection_stats_;
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats& BluetoothLog::headset_profile_connection_stats(int index) const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.headset_profile_connection_stats)
  return headset_profile_connection_stats_.Get(index);
}
inline ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats* BluetoothLog::add_headset_profile_connection_stats() {
  // @@protoc_insertion_point(field_add:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.headset_profile_connection_stats)
  return headset_profile_connection_stats_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats >&
BluetoothLog::headset_profile_connection_stats() const {
  // @@protoc_insertion_point(field_list:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.headset_profile_connection_stats)
  return headset_profile_connection_stats_;
}

// -------------------------------------------------------------------

// DeviceInfo

// optional int32 device_class = 1;
inline bool DeviceInfo::has_device_class() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceInfo::clear_device_class() {
  device_class_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeviceInfo::device_class() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo.device_class)
  return device_class_;
}
inline void DeviceInfo::set_device_class(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  device_class_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo.device_class)
}

// optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo.DeviceType device_type = 2;
inline bool DeviceInfo::has_device_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceInfo::clear_device_type() {
  device_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo_DeviceType DeviceInfo::device_type() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo.device_type)
  return static_cast< ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo_DeviceType >(device_type_);
}
inline void DeviceInfo::set_device_type(::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo_DeviceType value) {
  assert(::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo_DeviceType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  device_type_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo.device_type)
}

// -------------------------------------------------------------------

// BluetoothSession

// optional int64 session_duration_sec = 2;
inline bool BluetoothSession::has_session_duration_sec() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BluetoothSession::clear_session_duration_sec() {
  session_duration_sec_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BluetoothSession::session_duration_sec() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.session_duration_sec)
  return session_duration_sec_;
}
inline void BluetoothSession::set_session_duration_sec(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  session_duration_sec_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.session_duration_sec)
}

// optional .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.ConnectionTechnologyType connection_technology_type = 3;
inline bool BluetoothSession::has_connection_technology_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BluetoothSession::clear_connection_technology_type() {
  connection_technology_type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_ConnectionTechnologyType BluetoothSession::connection_technology_type() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.connection_technology_type)
  return static_cast< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_ConnectionTechnologyType >(connection_technology_type_);
}
inline void BluetoothSession::set_connection_technology_type(::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_ConnectionTechnologyType value) {
  assert(::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_ConnectionTechnologyType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  connection_technology_type_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.connection_technology_type)
}

// optional string disconnect_reason = 4 [deprecated = true];
inline bool BluetoothSession::has_disconnect_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BluetoothSession::clear_disconnect_reason() {
  disconnect_reason_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BluetoothSession::disconnect_reason() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.disconnect_reason)
  return disconnect_reason_.GetNoArena();
}
inline void BluetoothSession::set_disconnect_reason(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  disconnect_reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.disconnect_reason)
}
inline void BluetoothSession::set_disconnect_reason(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  disconnect_reason_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.disconnect_reason)
}
inline void BluetoothSession::set_disconnect_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  disconnect_reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.disconnect_reason)
}
inline void BluetoothSession::set_disconnect_reason(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  disconnect_reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.disconnect_reason)
}
inline std::string* BluetoothSession::mutable_disconnect_reason() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.disconnect_reason)
  return disconnect_reason_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BluetoothSession::release_disconnect_reason() {
  // @@protoc_insertion_point(field_release:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.disconnect_reason)
  if (!has_disconnect_reason()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return disconnect_reason_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BluetoothSession::set_allocated_disconnect_reason(std::string* disconnect_reason) {
  if (disconnect_reason != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  disconnect_reason_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), disconnect_reason);
  // @@protoc_insertion_point(field_set_allocated:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.disconnect_reason)
}

// optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo device_connected_to = 5;
inline bool BluetoothSession::has_device_connected_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BluetoothSession::clear_device_connected_to() {
  if (device_connected_to_ != nullptr) device_connected_to_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo& BluetoothSession::device_connected_to() const {
  const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* p = device_connected_to_;
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.device_connected_to)
  return p != nullptr ? *p : *reinterpret_cast<const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo*>(
      &::bluetooth::metrics::BluetoothMetricsProto::_DeviceInfo_default_instance_);
}
inline ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* BluetoothSession::release_device_connected_to() {
  // @@protoc_insertion_point(field_release:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.device_connected_to)
  _has_bits_[0] &= ~0x00000002u;
  ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* temp = device_connected_to_;
  device_connected_to_ = nullptr;
  return temp;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* BluetoothSession::mutable_device_connected_to() {
  _has_bits_[0] |= 0x00000002u;
  if (device_connected_to_ == nullptr) {
    auto* p = CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo>(GetArenaNoVirtual());
    device_connected_to_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.device_connected_to)
  return device_connected_to_;
}
inline void BluetoothSession::set_allocated_device_connected_to(::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* device_connected_to) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete device_connected_to_;
  }
  if (device_connected_to) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      device_connected_to = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_connected_to, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  device_connected_to_ = device_connected_to;
  // @@protoc_insertion_point(field_set_allocated:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.device_connected_to)
}

// optional .bluetooth.metrics.BluetoothMetricsProto.RFCommSession rfcomm_session = 6;
inline bool BluetoothSession::has_rfcomm_session() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BluetoothSession::clear_rfcomm_session() {
  if (rfcomm_session_ != nullptr) rfcomm_session_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession& BluetoothSession::rfcomm_session() const {
  const ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* p = rfcomm_session_;
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.rfcomm_session)
  return p != nullptr ? *p : *reinterpret_cast<const ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession*>(
      &::bluetooth::metrics::BluetoothMetricsProto::_RFCommSession_default_instance_);
}
inline ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* BluetoothSession::release_rfcomm_session() {
  // @@protoc_insertion_point(field_release:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.rfcomm_session)
  _has_bits_[0] &= ~0x00000004u;
  ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* temp = rfcomm_session_;
  rfcomm_session_ = nullptr;
  return temp;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* BluetoothSession::mutable_rfcomm_session() {
  _has_bits_[0] |= 0x00000004u;
  if (rfcomm_session_ == nullptr) {
    auto* p = CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::RFCommSession>(GetArenaNoVirtual());
    rfcomm_session_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.rfcomm_session)
  return rfcomm_session_;
}
inline void BluetoothSession::set_allocated_rfcomm_session(::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* rfcomm_session) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete rfcomm_session_;
  }
  if (rfcomm_session) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rfcomm_session = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rfcomm_session, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  rfcomm_session_ = rfcomm_session;
  // @@protoc_insertion_point(field_set_allocated:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.rfcomm_session)
}

// optional .bluetooth.metrics.BluetoothMetricsProto.A2DPSession a2dp_session = 7;
inline bool BluetoothSession::has_a2dp_session() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BluetoothSession::clear_a2dp_session() {
  if (a2dp_session_ != nullptr) a2dp_session_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession& BluetoothSession::a2dp_session() const {
  const ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* p = a2dp_session_;
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.a2dp_session)
  return p != nullptr ? *p : *reinterpret_cast<const ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession*>(
      &::bluetooth::metrics::BluetoothMetricsProto::_A2DPSession_default_instance_);
}
inline ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* BluetoothSession::release_a2dp_session() {
  // @@protoc_insertion_point(field_release:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.a2dp_session)
  _has_bits_[0] &= ~0x00000008u;
  ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* temp = a2dp_session_;
  a2dp_session_ = nullptr;
  return temp;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* BluetoothSession::mutable_a2dp_session() {
  _has_bits_[0] |= 0x00000008u;
  if (a2dp_session_ == nullptr) {
    auto* p = CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::A2DPSession>(GetArenaNoVirtual());
    a2dp_session_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.a2dp_session)
  return a2dp_session_;
}
inline void BluetoothSession::set_allocated_a2dp_session(::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* a2dp_session) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete a2dp_session_;
  }
  if (a2dp_session) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      a2dp_session = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, a2dp_session, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  a2dp_session_ = a2dp_session;
  // @@protoc_insertion_point(field_set_allocated:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.a2dp_session)
}

// optional .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.DisconnectReasonType disconnect_reason_type = 8;
inline bool BluetoothSession::has_disconnect_reason_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BluetoothSession::clear_disconnect_reason_type() {
  disconnect_reason_type_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_DisconnectReasonType BluetoothSession::disconnect_reason_type() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.disconnect_reason_type)
  return static_cast< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_DisconnectReasonType >(disconnect_reason_type_);
}
inline void BluetoothSession::set_disconnect_reason_type(::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_DisconnectReasonType value) {
  assert(::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_DisconnectReasonType_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  disconnect_reason_type_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.disconnect_reason_type)
}

// -------------------------------------------------------------------

// RFCommSession

// optional int32 rx_bytes = 1;
inline bool RFCommSession::has_rx_bytes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RFCommSession::clear_rx_bytes() {
  rx_bytes_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RFCommSession::rx_bytes() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.RFCommSession.rx_bytes)
  return rx_bytes_;
}
inline void RFCommSession::set_rx_bytes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  rx_bytes_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.RFCommSession.rx_bytes)
}

// optional int32 tx_bytes = 2;
inline bool RFCommSession::has_tx_bytes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RFCommSession::clear_tx_bytes() {
  tx_bytes_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RFCommSession::tx_bytes() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.RFCommSession.tx_bytes)
  return tx_bytes_;
}
inline void RFCommSession::set_tx_bytes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  tx_bytes_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.RFCommSession.tx_bytes)
}

// -------------------------------------------------------------------

// A2DPSession

// optional int32 media_timer_min_millis = 1;
inline bool A2DPSession::has_media_timer_min_millis() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void A2DPSession::clear_media_timer_min_millis() {
  media_timer_min_millis_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 A2DPSession::media_timer_min_millis() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.media_timer_min_millis)
  return media_timer_min_millis_;
}
inline void A2DPSession::set_media_timer_min_millis(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  media_timer_min_millis_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.media_timer_min_millis)
}

// optional int32 media_timer_max_millis = 2;
inline bool A2DPSession::has_media_timer_max_millis() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void A2DPSession::clear_media_timer_max_millis() {
  media_timer_max_millis_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 A2DPSession::media_timer_max_millis() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.media_timer_max_millis)
  return media_timer_max_millis_;
}
inline void A2DPSession::set_media_timer_max_millis(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  media_timer_max_millis_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.media_timer_max_millis)
}

// optional int32 media_timer_avg_millis = 3;
inline bool A2DPSession::has_media_timer_avg_millis() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void A2DPSession::clear_media_timer_avg_millis() {
  media_timer_avg_millis_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 A2DPSession::media_timer_avg_millis() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.media_timer_avg_millis)
  return media_timer_avg_millis_;
}
inline void A2DPSession::set_media_timer_avg_millis(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  media_timer_avg_millis_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.media_timer_avg_millis)
}

// optional int32 buffer_overruns_max_count = 4;
inline bool A2DPSession::has_buffer_overruns_max_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void A2DPSession::clear_buffer_overruns_max_count() {
  buffer_overruns_max_count_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 A2DPSession::buffer_overruns_max_count() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.buffer_overruns_max_count)
  return buffer_overruns_max_count_;
}
inline void A2DPSession::set_buffer_overruns_max_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  buffer_overruns_max_count_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.buffer_overruns_max_count)
}

// optional int32 buffer_overruns_total = 5;
inline bool A2DPSession::has_buffer_overruns_total() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void A2DPSession::clear_buffer_overruns_total() {
  buffer_overruns_total_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 A2DPSession::buffer_overruns_total() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.buffer_overruns_total)
  return buffer_overruns_total_;
}
inline void A2DPSession::set_buffer_overruns_total(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  buffer_overruns_total_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.buffer_overruns_total)
}

// optional float buffer_underruns_average = 6;
inline bool A2DPSession::has_buffer_underruns_average() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void A2DPSession::clear_buffer_underruns_average() {
  buffer_underruns_average_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float A2DPSession::buffer_underruns_average() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.buffer_underruns_average)
  return buffer_underruns_average_;
}
inline void A2DPSession::set_buffer_underruns_average(float value) {
  _has_bits_[0] |= 0x00000020u;
  buffer_underruns_average_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.buffer_underruns_average)
}

// optional int32 buffer_underruns_count = 7;
inline bool A2DPSession::has_buffer_underruns_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void A2DPSession::clear_buffer_underruns_count() {
  buffer_underruns_count_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 A2DPSession::buffer_underruns_count() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.buffer_underruns_count)
  return buffer_underruns_count_;
}
inline void A2DPSession::set_buffer_underruns_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  buffer_underruns_count_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.buffer_underruns_count)
}

// optional int64 audio_duration_millis = 8;
inline bool A2DPSession::has_audio_duration_millis() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void A2DPSession::clear_audio_duration_millis() {
  audio_duration_millis_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 A2DPSession::audio_duration_millis() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.audio_duration_millis)
  return audio_duration_millis_;
}
inline void A2DPSession::set_audio_duration_millis(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  audio_duration_millis_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.audio_duration_millis)
}

// optional .bluetooth.metrics.BluetoothMetricsProto.A2dpSourceCodec source_codec = 9;
inline bool A2DPSession::has_source_codec() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void A2DPSession::clear_source_codec() {
  source_codec_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::A2dpSourceCodec A2DPSession::source_codec() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.source_codec)
  return static_cast< ::bluetooth::metrics::BluetoothMetricsProto::A2dpSourceCodec >(source_codec_);
}
inline void A2DPSession::set_source_codec(::bluetooth::metrics::BluetoothMetricsProto::A2dpSourceCodec value) {
  assert(::bluetooth::metrics::BluetoothMetricsProto::A2dpSourceCodec_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  source_codec_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.source_codec)
}

// optional bool is_a2dp_offload = 10;
inline bool A2DPSession::has_is_a2dp_offload() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void A2DPSession::clear_is_a2dp_offload() {
  is_a2dp_offload_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool A2DPSession::is_a2dp_offload() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.is_a2dp_offload)
  return is_a2dp_offload_;
}
inline void A2DPSession::set_is_a2dp_offload(bool value) {
  _has_bits_[0] |= 0x00000200u;
  is_a2dp_offload_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.is_a2dp_offload)
}

// -------------------------------------------------------------------

// PairEvent

// optional int32 disconnect_reason = 1;
inline bool PairEvent::has_disconnect_reason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PairEvent::clear_disconnect_reason() {
  disconnect_reason_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PairEvent::disconnect_reason() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.PairEvent.disconnect_reason)
  return disconnect_reason_;
}
inline void PairEvent::set_disconnect_reason(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  disconnect_reason_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.PairEvent.disconnect_reason)
}

// optional int64 event_time_millis = 2;
inline bool PairEvent::has_event_time_millis() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PairEvent::clear_event_time_millis() {
  event_time_millis_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PairEvent::event_time_millis() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.PairEvent.event_time_millis)
  return event_time_millis_;
}
inline void PairEvent::set_event_time_millis(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  event_time_millis_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.PairEvent.event_time_millis)
}

// optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo device_paired_with = 3;
inline bool PairEvent::has_device_paired_with() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PairEvent::clear_device_paired_with() {
  if (device_paired_with_ != nullptr) device_paired_with_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo& PairEvent::device_paired_with() const {
  const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* p = device_paired_with_;
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.PairEvent.device_paired_with)
  return p != nullptr ? *p : *reinterpret_cast<const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo*>(
      &::bluetooth::metrics::BluetoothMetricsProto::_DeviceInfo_default_instance_);
}
inline ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* PairEvent::release_device_paired_with() {
  // @@protoc_insertion_point(field_release:bluetooth.metrics.BluetoothMetricsProto.PairEvent.device_paired_with)
  _has_bits_[0] &= ~0x00000001u;
  ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* temp = device_paired_with_;
  device_paired_with_ = nullptr;
  return temp;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* PairEvent::mutable_device_paired_with() {
  _has_bits_[0] |= 0x00000001u;
  if (device_paired_with_ == nullptr) {
    auto* p = CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo>(GetArenaNoVirtual());
    device_paired_with_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.PairEvent.device_paired_with)
  return device_paired_with_;
}
inline void PairEvent::set_allocated_device_paired_with(::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* device_paired_with) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete device_paired_with_;
  }
  if (device_paired_with) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      device_paired_with = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_paired_with, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  device_paired_with_ = device_paired_with;
  // @@protoc_insertion_point(field_set_allocated:bluetooth.metrics.BluetoothMetricsProto.PairEvent.device_paired_with)
}

// -------------------------------------------------------------------

// WakeEvent

// optional .bluetooth.metrics.BluetoothMetricsProto.WakeEvent.WakeEventType wake_event_type = 1;
inline bool WakeEvent::has_wake_event_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WakeEvent::clear_wake_event_type() {
  wake_event_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent_WakeEventType WakeEvent::wake_event_type() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.wake_event_type)
  return static_cast< ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent_WakeEventType >(wake_event_type_);
}
inline void WakeEvent::set_wake_event_type(::bluetooth::metrics::BluetoothMetricsProto::WakeEvent_WakeEventType value) {
  assert(::bluetooth::metrics::BluetoothMetricsProto::WakeEvent_WakeEventType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  wake_event_type_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.wake_event_type)
}

// optional string requestor = 2;
inline bool WakeEvent::has_requestor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WakeEvent::clear_requestor() {
  requestor_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WakeEvent::requestor() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.requestor)
  return requestor_.GetNoArena();
}
inline void WakeEvent::set_requestor(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  requestor_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.requestor)
}
inline void WakeEvent::set_requestor(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  requestor_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.requestor)
}
inline void WakeEvent::set_requestor(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  requestor_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.requestor)
}
inline void WakeEvent::set_requestor(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  requestor_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.requestor)
}
inline std::string* WakeEvent::mutable_requestor() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.requestor)
  return requestor_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* WakeEvent::release_requestor() {
  // @@protoc_insertion_point(field_release:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.requestor)
  if (!has_requestor()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return requestor_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void WakeEvent::set_allocated_requestor(std::string* requestor) {
  if (requestor != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  requestor_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), requestor);
  // @@protoc_insertion_point(field_set_allocated:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.requestor)
}

// optional string name = 3;
inline bool WakeEvent::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WakeEvent::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& WakeEvent::name() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.name)
  return name_.GetNoArena();
}
inline void WakeEvent::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.name)
}
inline void WakeEvent::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.name)
}
inline void WakeEvent::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.name)
}
inline void WakeEvent::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.name)
}
inline std::string* WakeEvent::mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* WakeEvent::release_name() {
  // @@protoc_insertion_point(field_release:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void WakeEvent::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.name)
}

// optional int64 event_time_millis = 4;
inline bool WakeEvent::has_event_time_millis() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WakeEvent::clear_event_time_millis() {
  event_time_millis_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WakeEvent::event_time_millis() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.event_time_millis)
  return event_time_millis_;
}
inline void WakeEvent::set_event_time_millis(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  event_time_millis_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.event_time_millis)
}

// -------------------------------------------------------------------

// ScanEvent

// optional .bluetooth.metrics.BluetoothMetricsProto.ScanEvent.ScanEventType scan_event_type = 1;
inline bool ScanEvent::has_scan_event_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScanEvent::clear_scan_event_type() {
  scan_event_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanEventType ScanEvent::scan_event_type() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.scan_event_type)
  return static_cast< ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanEventType >(scan_event_type_);
}
inline void ScanEvent::set_scan_event_type(::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanEventType value) {
  assert(::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanEventType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  scan_event_type_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.scan_event_type)
}

// optional string initiator = 2;
inline bool ScanEvent::has_initiator() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScanEvent::clear_initiator() {
  initiator_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ScanEvent::initiator() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.initiator)
  return initiator_.GetNoArena();
}
inline void ScanEvent::set_initiator(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  initiator_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.initiator)
}
inline void ScanEvent::set_initiator(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  initiator_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.initiator)
}
inline void ScanEvent::set_initiator(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  initiator_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.initiator)
}
inline void ScanEvent::set_initiator(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  initiator_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.initiator)
}
inline std::string* ScanEvent::mutable_initiator() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.initiator)
  return initiator_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ScanEvent::release_initiator() {
  // @@protoc_insertion_point(field_release:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.initiator)
  if (!has_initiator()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return initiator_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ScanEvent::set_allocated_initiator(std::string* initiator) {
  if (initiator != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  initiator_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), initiator);
  // @@protoc_insertion_point(field_set_allocated:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.initiator)
}

// optional .bluetooth.metrics.BluetoothMetricsProto.ScanEvent.ScanTechnologyType scan_technology_type = 3;
inline bool ScanEvent::has_scan_technology_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScanEvent::clear_scan_technology_type() {
  scan_technology_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanTechnologyType ScanEvent::scan_technology_type() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.scan_technology_type)
  return static_cast< ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanTechnologyType >(scan_technology_type_);
}
inline void ScanEvent::set_scan_technology_type(::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanTechnologyType value) {
  assert(::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanTechnologyType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  scan_technology_type_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.scan_technology_type)
}

// optional int32 number_results = 4;
inline bool ScanEvent::has_number_results() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ScanEvent::clear_number_results() {
  number_results_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ScanEvent::number_results() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.number_results)
  return number_results_;
}
inline void ScanEvent::set_number_results(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  number_results_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.number_results)
}

// optional int64 event_time_millis = 5;
inline bool ScanEvent::has_event_time_millis() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScanEvent::clear_event_time_millis() {
  event_time_millis_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ScanEvent::event_time_millis() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.event_time_millis)
  return event_time_millis_;
}
inline void ScanEvent::set_event_time_millis(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  event_time_millis_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.event_time_millis)
}

// -------------------------------------------------------------------

// ProfileConnectionStats

// optional .bluetooth.metrics.BluetoothMetricsProto.ProfileId profile_id = 1;
inline bool ProfileConnectionStats::has_profile_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProfileConnectionStats::clear_profile_id() {
  profile_id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::ProfileId ProfileConnectionStats::profile_id() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats.profile_id)
  return static_cast< ::bluetooth::metrics::BluetoothMetricsProto::ProfileId >(profile_id_);
}
inline void ProfileConnectionStats::set_profile_id(::bluetooth::metrics::BluetoothMetricsProto::ProfileId value) {
  assert(::bluetooth::metrics::BluetoothMetricsProto::ProfileId_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  profile_id_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats.profile_id)
}

// optional int32 num_times_connected = 2;
inline bool ProfileConnectionStats::has_num_times_connected() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProfileConnectionStats::clear_num_times_connected() {
  num_times_connected_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ProfileConnectionStats::num_times_connected() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats.num_times_connected)
  return num_times_connected_;
}
inline void ProfileConnectionStats::set_num_times_connected(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  num_times_connected_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats.num_times_connected)
}

// -------------------------------------------------------------------

// HeadsetProfileConnectionStats

// optional .bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileType headset_profile_type = 1;
inline bool HeadsetProfileConnectionStats::has_headset_profile_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeadsetProfileConnectionStats::clear_headset_profile_type() {
  headset_profile_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileType HeadsetProfileConnectionStats::headset_profile_type() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats.headset_profile_type)
  return static_cast< ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileType >(headset_profile_type_);
}
inline void HeadsetProfileConnectionStats::set_headset_profile_type(::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileType value) {
  assert(::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  headset_profile_type_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats.headset_profile_type)
}

// optional int32 num_times_connected = 2;
inline bool HeadsetProfileConnectionStats::has_num_times_connected() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeadsetProfileConnectionStats::clear_num_times_connected() {
  num_times_connected_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeadsetProfileConnectionStats::num_times_connected() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats.num_times_connected)
  return num_times_connected_;
}
inline void HeadsetProfileConnectionStats::set_num_times_connected(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  num_times_connected_ = value;
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats.num_times_connected)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace BluetoothMetricsProto
}  // namespace metrics
}  // namespace bluetooth

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo_DeviceType> : ::std::true_type {};
template <> struct is_proto_enum< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_ConnectionTechnologyType> : ::std::true_type {};
template <> struct is_proto_enum< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_DisconnectReasonType> : ::std::true_type {};
template <> struct is_proto_enum< ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent_WakeEventType> : ::std::true_type {};
template <> struct is_proto_enum< ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanTechnologyType> : ::std::true_type {};
template <> struct is_proto_enum< ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanEventType> : ::std::true_type {};
template <> struct is_proto_enum< ::bluetooth::metrics::BluetoothMetricsProto::A2dpSourceCodec> : ::std::true_type {};
template <> struct is_proto_enum< ::bluetooth::metrics::BluetoothMetricsProto::ProfileId> : ::std::true_type {};
template <> struct is_proto_enum< ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_system_2fbt_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto
