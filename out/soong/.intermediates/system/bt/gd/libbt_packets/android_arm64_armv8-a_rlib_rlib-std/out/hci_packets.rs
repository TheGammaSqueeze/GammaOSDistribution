// @generated rust packets from hci_packets.pdl


use bytes::{Bytes, BytesMut, BufMut};
use num_derive::{FromPrimitive, ToPrimitive};
use num_traits::{FromPrimitive, ToPrimitive};
use std::convert::TryInto;
use thiserror::Error;
use std::sync::Arc;

type Result<T> = std::result::Result<T, Error>;

#[derive(Debug, Error)]
pub enum Error {
  #[error("Packet parsing failed")]
  InvalidPacketError,
  #[error("{field} was {value:x}, which is not known")]
  ConstraintOutOfBounds {
    field: String,
    value: u64,
  },
  #[error("when parsing {obj}.{field} needed length of {wanted} but got {got}")]
  InvalidLengthError {
    obj: String,
    field: String,
    wanted: usize,
    got: usize,
  },
  #[error("Due to size restrictions a struct could not be parsed.")]
  ImpossibleStructError,
}

pub trait Packet {
  fn to_bytes(self) -> Bytes;
  fn to_vec(self) -> Vec<u8>;
}

pub trait CommandExpectations { type ResponseType;fn _to_response_type(pkt: EventPacket) -> Self::ResponseType;}use std::convert::TryFrom;#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum Enable {Disabled = 0x0,Enabled = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum GapDataType {Invalid = 0x0,Flags = 0x1,IncompleteList16BitUuids = 0x2,CompleteList16BitUuids = 0x3,IncompleteList32BitUuids = 0x4,CompleteList32BitUuids = 0x5,IncompleteList128BitUuids = 0x6,CompleteList128BitUuids = 0x7,ShortenedLocalName = 0x8,CompleteLocalName = 0x9,TxPowerLevel = 0xa,ClassOfDevice = 0xd,SimplePairingHashC = 0xe,SimplePairingRandomizerR = 0xf,DeviceId = 0x10,SecurityManagerOobFlags = 0x11,SlaveConnectionIntervalRange = 0x12,List16bitServiceSolicitationUuids = 0x14,List128bitServiceSolicitationUuids = 0x15,ServiceData16BitUuids = 0x16,PublicTargetAddress = 0x17,RandomTargetAddress = 0x18,Appearance = 0x19,AdvertisingInterval = 0x1a,LeBluetoothDeviceAddress = 0x1b,LeRole = 0x1c,SimplePairingHashC256 = 0x1d,SimplePairingRandomizerR256 = 0x1e,List32bitServiceSolicitationUuids = 0x1f,ServiceData32BitUuids = 0x20,ServiceData128BitUuids = 0x21,LeSecureConnectionsConfirmationValue = 0x22,LeSecureConnectionsRandomValue = 0x23,Uri = 0x24,IndoorPositioning = 0x25,TransportDiscoveryData = 0x26,LeSupportedFeatures = 0x27,ChannelMapUpdateIndication = 0x28,MeshPbAdv = 0x29,MeshMessage = 0x2a,MeshBeacon = 0x2b,BigInfo = 0x2c,BroadcastCode = 0x2d,ThreeDInformationData = 0x3d,ManufacturerSpecificData = 0xff,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum PacketBoundaryFlag {FirstNonAutomaticallyFlushable = 0x0,ContinuingFragment = 0x1,FirstAutomaticallyFlushable = 0x2,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum BroadcastFlag {PointToPoint = 0x0,ActivePeripheralBroadcast = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum PacketStatusFlag {CorrectlyReceived = 0x0,PossiblyIncomplete = 0x1,NoData = 0x2,PartiallyLost = 0x3,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum OpCode {None = 0x0,Inquiry = 0x401,InquiryCancel = 0x402,PeriodicInquiryMode = 0x403,ExitPeriodicInquiryMode = 0x404,CreateConnection = 0x405,Disconnect = 0x406,CreateConnectionCancel = 0x408,AcceptConnectionRequest = 0x409,RejectConnectionRequest = 0x40a,LinkKeyRequestReply = 0x40b,LinkKeyRequestNegativeReply = 0x40c,PinCodeRequestReply = 0x40d,PinCodeRequestNegativeReply = 0x40e,ChangeConnectionPacketType = 0x40f,AuthenticationRequested = 0x411,SetConnectionEncryption = 0x413,ChangeConnectionLinkKey = 0x415,CentralLinkKey = 0x417,RemoteNameRequest = 0x419,RemoteNameRequestCancel = 0x41a,ReadRemoteSupportedFeatures = 0x41b,ReadRemoteExtendedFeatures = 0x41c,ReadRemoteVersionInformation = 0x41d,ReadClockOffset = 0x41f,ReadLmpHandle = 0x420,SetupSynchronousConnection = 0x428,AcceptSynchronousConnection = 0x429,RejectSynchronousConnection = 0x42a,IoCapabilityRequestReply = 0x42b,UserConfirmationRequestReply = 0x42c,UserConfirmationRequestNegativeReply = 0x42d,UserPasskeyRequestReply = 0x42e,UserPasskeyRequestNegativeReply = 0x42f,RemoteOobDataRequestReply = 0x430,RemoteOobDataRequestNegativeReply = 0x433,IoCapabilityRequestNegativeReply = 0x434,EnhancedSetupSynchronousConnection = 0x43d,EnhancedAcceptSynchronousConnection = 0x43e,RemoteOobExtendedDataRequestReply = 0x445,HoldMode = 0x801,SniffMode = 0x803,ExitSniffMode = 0x804,QosSetup = 0x807,RoleDiscovery = 0x809,SwitchRole = 0x80b,ReadLinkPolicySettings = 0x80c,WriteLinkPolicySettings = 0x80d,ReadDefaultLinkPolicySettings = 0x80e,WriteDefaultLinkPolicySettings = 0x80f,FlowSpecification = 0x810,SniffSubrating = 0x811,SetEventMask = 0xc01,Reset = 0xc03,SetEventFilter = 0xc05,Flush = 0xc08,ReadPinType = 0xc09,WritePinType = 0xc0a,ReadStoredLinkKey = 0xc0d,WriteStoredLinkKey = 0xc11,DeleteStoredLinkKey = 0xc12,WriteLocalName = 0xc13,ReadLocalName = 0xc14,ReadConnectionAcceptTimeout = 0xc15,WriteConnectionAcceptTimeout = 0xc16,ReadPageTimeout = 0xc17,WritePageTimeout = 0xc18,ReadScanEnable = 0xc19,WriteScanEnable = 0xc1a,ReadPageScanActivity = 0xc1b,WritePageScanActivity = 0xc1c,ReadInquiryScanActivity = 0xc1d,WriteInquiryScanActivity = 0xc1e,ReadAuthenticationEnable = 0xc1f,WriteAuthenticationEnable = 0xc20,ReadClassOfDevice = 0xc23,WriteClassOfDevice = 0xc24,ReadVoiceSetting = 0xc25,WriteVoiceSetting = 0xc26,ReadAutomaticFlushTimeout = 0xc27,WriteAutomaticFlushTimeout = 0xc28,ReadNumBroadcastRetransmits = 0xc29,WriteNumBroadcastRetransmits = 0xc2a,ReadHoldModeActivity = 0xc2b,WriteHoldModeActivity = 0xc2c,ReadTransmitPowerLevel = 0xc2d,ReadSynchronousFlowControlEnable = 0xc2e,WriteSynchronousFlowControlEnable = 0xc2f,SetControllerToHostFlowControl = 0xc31,HostBufferSize = 0xc33,HostNumCompletedPackets = 0xc35,ReadLinkSupervisionTimeout = 0xc36,WriteLinkSupervisionTimeout = 0xc37,ReadNumberOfSupportedIac = 0xc38,ReadCurrentIacLap = 0xc39,WriteCurrentIacLap = 0xc3a,SetAfhHostChannelClassification = 0xc3f,ReadInquiryScanType = 0xc42,WriteInquiryScanType = 0xc43,ReadInquiryMode = 0xc44,WriteInquiryMode = 0xc45,ReadPageScanType = 0xc46,WritePageScanType = 0xc47,ReadAfhChannelAssessmentMode = 0xc48,WriteAfhChannelAssessmentMode = 0xc49,ReadExtendedInquiryResponse = 0xc51,WriteExtendedInquiryResponse = 0xc52,RefreshEncryptionKey = 0xc53,ReadSimplePairingMode = 0xc55,WriteSimplePairingMode = 0xc56,ReadLocalOobData = 0xc57,ReadInquiryResponseTransmitPowerLevel = 0xc58,WriteInquiryTransmitPowerLevel = 0xc59,EnhancedFlush = 0xc5f,SendKeypressNotification = 0xc60,SetEventMaskPage2 = 0xc63,ReadLeHostSupport = 0xc6c,WriteLeHostSupport = 0xc6d,ReadSecureConnectionsHostSupport = 0xc79,WriteSecureConnectionsHostSupport = 0xc7a,ReadLocalOobExtendedData = 0xc7d,SetEcosystemBaseInterval = 0xc82,ConfigureDataPath = 0xc83,ReadLocalVersionInformation = 0x1001,ReadLocalSupportedCommands = 0x1002,ReadLocalSupportedFeatures = 0x1003,ReadLocalExtendedFeatures = 0x1004,ReadBufferSize = 0x1005,ReadBdAddr = 0x1009,ReadDataBlockSize = 0x100a,ReadLocalSupportedCodecsV1 = 0x100b,ReadLocalSupportedCodecsV2 = 0x100d,ReadLocalSupportedCodecCapabilities = 0x100e,ReadLocalSupportedControllerDelay = 0x100f,ReadFailedContactCounter = 0x1401,ResetFailedContactCounter = 0x1402,ReadLinkQuality = 0x1403,ReadRssi = 0x1405,ReadAfhChannelMap = 0x1406,ReadClock = 0x1407,ReadEncryptionKeySize = 0x1408,ReadLoopbackMode = 0x1801,WriteLoopbackMode = 0x1802,EnableDeviceUnderTestMode = 0x1803,WriteSimplePairingDebugMode = 0x1804,WriteSecureConnectionsTestMode = 0x180a,LeSetEventMask = 0x2001,LeReadBufferSizeV1 = 0x2002,LeReadLocalSupportedFeatures = 0x2003,LeSetRandomAddress = 0x2005,LeSetAdvertisingParameters = 0x2006,LeReadAdvertisingPhysicalChannelTxPower = 0x2007,LeSetAdvertisingData = 0x2008,LeSetScanResponseData = 0x2009,LeSetAdvertisingEnable = 0x200a,LeSetScanParameters = 0x200b,LeSetScanEnable = 0x200c,LeCreateConnection = 0x200d,LeCreateConnectionCancel = 0x200e,LeReadConnectListSize = 0x200f,LeClearConnectList = 0x2010,LeAddDeviceToConnectList = 0x2011,LeRemoveDeviceFromConnectList = 0x2012,LeConnectionUpdate = 0x2013,LeSetHostChannelClassification = 0x2014,LeReadChannelMap = 0x2015,LeReadRemoteFeatures = 0x2016,LeEncrypt = 0x2017,LeRand = 0x2018,LeStartEncryption = 0x2019,LeLongTermKeyRequestReply = 0x201a,LeLongTermKeyRequestNegativeReply = 0x201b,LeReadSupportedStates = 0x201c,LeReceiverTest = 0x201d,LeTransmitterTest = 0x201e,LeTestEnd = 0x201f,LeRemoteConnectionParameterRequestReply = 0x2020,LeRemoteConnectionParameterRequestNegativeReply = 0x2021,LeSetDataLength = 0x2022,LeReadSuggestedDefaultDataLength = 0x2023,LeWriteSuggestedDefaultDataLength = 0x2024,LeReadLocalP256PublicKeyCommand = 0x2025,LeGenerateDhkeyCommandV1 = 0x2026,LeAddDeviceToResolvingList = 0x2027,LeRemoveDeviceFromResolvingList = 0x2028,LeClearResolvingList = 0x2029,LeReadResolvingListSize = 0x202a,LeReadPeerResolvableAddress = 0x202b,LeReadLocalResolvableAddress = 0x202c,LeSetAddressResolutionEnable = 0x202d,LeSetResolvablePrivateAddressTimeout = 0x202e,LeReadMaximumDataLength = 0x202f,LeReadPhy = 0x2030,LeSetDefaultPhy = 0x2031,LeSetPhy = 0x2032,LeEnhancedReceiverTest = 0x2033,LeEnhancedTransmitterTest = 0x2034,LeSetExtendedAdvertisingRandomAddress = 0x2035,LeSetExtendedAdvertisingParameters = 0x2036,LeSetExtendedAdvertisingData = 0x2037,LeSetExtendedAdvertisingScanResponse = 0x2038,LeSetExtendedAdvertisingEnable = 0x2039,LeReadMaximumAdvertisingDataLength = 0x203a,LeReadNumberOfSupportedAdvertisingSets = 0x203b,LeRemoveAdvertisingSet = 0x203c,LeClearAdvertisingSets = 0x203d,LeSetPeriodicAdvertisingParam = 0x203e,LeSetPeriodicAdvertisingData = 0x203f,LeSetPeriodicAdvertisingEnable = 0x2040,LeSetExtendedScanParameters = 0x2041,LeSetExtendedScanEnable = 0x2042,LeExtendedCreateConnection = 0x2043,LePeriodicAdvertisingCreateSync = 0x2044,LePeriodicAdvertisingCreateSyncCancel = 0x2045,LePeriodicAdvertisingTerminateSync = 0x2046,LeAddDeviceToPeriodicAdvertisingList = 0x2047,LeRemoveDeviceFromPeriodicAdvertisingList = 0x2048,LeClearPeriodicAdvertisingList = 0x2049,LeReadPeriodicAdvertisingListSize = 0x204a,LeReadTransmitPower = 0x204b,LeReadRfPathCompensationPower = 0x204c,LeWriteRfPathCompensationPower = 0x204d,LeSetPrivacyMode = 0x204e,LeSetPeriodicAdvertisingReceiveEnable = 0x2059,LePeriodicAdvertisingSyncTransfer = 0x205a,LePeriodicAdvertisingSetInfoTransfer = 0x205b,LeSetPeriodicAdvertisingSyncTransferParameters = 0x205c,LeSetDefaultPeriodicAdvertisingSyncTransferParameters = 0x205d,LeGenerateDhkeyCommand = 0x205e,LeModifySleepClockAccuracy = 0x205f,LeReadBufferSizeV2 = 0x2060,LeReadIsoTxSync = 0x2061,LeSetCigParameters = 0x2062,LeSetCigParametersTest = 0x2063,LeCreateCis = 0x2064,LeRemoveCig = 0x2065,LeAcceptCisRequest = 0x2066,LeRejectCisRequest = 0x2067,LeCreateBig = 0x2068,LeTerminateBig = 0x206a,LeBigCreateSync = 0x206b,LeBigTerminateSync = 0x206c,LeRequestPeerSca = 0x206d,LeSetupIsoDataPath = 0x206e,LeRemoveIsoDataPath = 0x206f,LeSetHostFeature = 0x2074,LeReadIsoLinkQuality = 0x2075,LeEnhancedReadTransmitPowerLevel = 0x2076,LeReadRemoteTransmitPowerLevel = 0x2077,LeSetPathLossReportingParameters = 0x2078,LeSetPathLossReportingEnable = 0x2079,LeSetTransmitPowerReportingEnable = 0x207a,LeGetVendorCapabilities = 0xfd53,LeMultiAdvt = 0xfd54,LeBatchScan = 0xfd56,LeAdvFilter = 0xfd57,LeEnergyInfo = 0xfd59,LeExtendedScanParams = 0xfd5a,ControllerDebugInfo = 0xfd5b,ControllerA2dpOpcode = 0xfd5d,ControllerBqr = 0xfd5e,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum OpCodeIndex {Inquiry = 0x0,InquiryCancel = 0x1,PeriodicInquiryMode = 0x2,ExitPeriodicInquiryMode = 0x3,CreateConnection = 0x4,Disconnect = 0x5,CreateConnectionCancel = 0x7,AcceptConnectionRequest = 0xa,RejectConnectionRequest = 0xb,LinkKeyRequestReply = 0xc,LinkKeyRequestNegativeReply = 0xd,PinCodeRequestReply = 0xe,PinCodeRequestNegativeReply = 0xf,ChangeConnectionPacketType = 0x10,AuthenticationRequested = 0x11,SetConnectionEncryption = 0x14,ChangeConnectionLinkKey = 0x15,CentralLinkKey = 0x16,RemoteNameRequest = 0x17,RemoteNameRequestCancel = 0x18,ReadRemoteSupportedFeatures = 0x19,ReadRemoteExtendedFeatures = 0x1a,ReadRemoteVersionInformation = 0x1b,ReadClockOffset = 0x1e,ReadLmpHandle = 0x1f,HoldMode = 0x29,SniffMode = 0x2a,ExitSniffMode = 0x2b,QosSetup = 0x2e,RoleDiscovery = 0x2f,SwitchRole = 0x32,ReadLinkPolicySettings = 0x33,WriteLinkPolicySettings = 0x34,ReadDefaultLinkPolicySettings = 0x35,WriteDefaultLinkPolicySettings = 0x36,FlowSpecification = 0x37,SetEventMask = 0x38,Reset = 0x39,SetEventFilter = 0x3c,Flush = 0x3d,ReadPinType = 0x3e,WritePinType = 0x3f,ReadStoredLinkKey = 0x41,WriteStoredLinkKey = 0x42,DeleteStoredLinkKey = 0x43,WriteLocalName = 0x46,ReadLocalName = 0x47,ReadConnectionAcceptTimeout = 0x48,WriteConnectionAcceptTimeout = 0x49,ReadPageTimeout = 0x4a,WritePageTimeout = 0x4b,ReadScanEnable = 0x4c,WriteScanEnable = 0x4d,ReadPageScanActivity = 0x50,WritePageScanActivity = 0x51,ReadInquiryScanActivity = 0x52,WriteInquiryScanActivity = 0x53,ReadAuthenticationEnable = 0x54,WriteAuthenticationEnable = 0x55,ReadClassOfDevice = 0x5a,WriteClassOfDevice = 0x5b,ReadVoiceSetting = 0x5c,WriteVoiceSetting = 0x5d,ReadAutomaticFlushTimeout = 0x5e,WriteAutomaticFlushTimeout = 0x5f,ReadNumBroadcastRetransmits = 0x60,WriteNumBroadcastRetransmits = 0x61,ReadHoldModeActivity = 0x64,WriteHoldModeActivity = 0x65,ReadTransmitPowerLevel = 0x66,ReadSynchronousFlowControlEnable = 0x67,WriteSynchronousFlowControlEnable = 0x68,SetControllerToHostFlowControl = 0x69,HostBufferSize = 0x6a,HostNumCompletedPackets = 0x6b,ReadLinkSupervisionTimeout = 0x6e,WriteLinkSupervisionTimeout = 0x6f,ReadNumberOfSupportedIac = 0x70,ReadCurrentIacLap = 0x71,WriteCurrentIacLap = 0x72,SetAfhHostChannelClassification = 0x79,ReadInquiryScanType = 0x7c,WriteInquiryScanType = 0x7d,ReadInquiryMode = 0x7e,WriteInquiryMode = 0x7f,ReadPageScanType = 0x82,WritePageScanType = 0x83,ReadAfhChannelAssessmentMode = 0x84,WriteAfhChannelAssessmentMode = 0x85,ReadLocalVersionInformation = 0x8f,ReadLocalSupportedFeatures = 0x91,ReadLocalExtendedFeatures = 0x92,ReadBufferSize = 0x93,ReadBdAddr = 0x97,ReadFailedContactCounter = 0x98,ResetFailedContactCounter = 0x99,ReadLinkQuality = 0x9a,ReadRssi = 0x9b,ReadAfhChannelMap = 0x9c,ReadClock = 0x9d,ReadLoopbackMode = 0xa0,WriteLoopbackMode = 0xa1,EnableDeviceUnderTestMode = 0xa2,SetupSynchronousConnection = 0xa3,AcceptSynchronousConnection = 0xa4,RejectSynchronousConnection = 0xa5,ReadExtendedInquiryResponse = 0xaa,WriteExtendedInquiryResponse = 0xab,RefreshEncryptionKey = 0xac,SniffSubrating = 0xae,ReadSimplePairingMode = 0xaf,WriteSimplePairingMode = 0xb0,ReadLocalOobData = 0xb1,ReadInquiryResponseTransmitPowerLevel = 0xb4,WriteInquiryTransmitPowerLevel = 0xb5,IoCapabilityRequestReply = 0xbb,UserConfirmationRequestReply = 0xbe,UserConfirmationRequestNegativeReply = 0xbf,UserPasskeyRequestReply = 0xc0,UserPasskeyRequestNegativeReply = 0xc1,RemoteOobDataRequestReply = 0xc2,WriteSimplePairingDebugMode = 0xc3,EnhancedFlush = 0xc4,RemoteOobDataRequestNegativeReply = 0xc5,SendKeypressNotification = 0xca,IoCapabilityRequestNegativeReply = 0xcb,ReadEncryptionKeySize = 0xcc,SetEventMaskPage2 = 0xde,ReadDataBlockSize = 0xe8,ReadLeHostSupport = 0xf5,WriteLeHostSupport = 0xf6,LeSetEventMask = 0xfa,LeReadBufferSizeV1 = 0xfb,LeReadLocalSupportedFeatures = 0xfc,LeSetRandomAddress = 0xfe,LeSetAdvertisingParameters = 0xff,LeReadAdvertisingPhysicalChannelTxPower = 0x100,LeSetAdvertisingData = 0x101,LeSetScanResponseData = 0x104,LeSetAdvertisingEnable = 0x105,LeSetScanParameters = 0x106,LeSetScanEnable = 0x107,LeCreateConnection = 0x108,LeCreateConnectionCancel = 0x109,LeReadConnectListSize = 0x10a,LeClearConnectList = 0x10b,LeAddDeviceToConnectList = 0x10e,LeRemoveDeviceFromConnectList = 0x10f,LeConnectionUpdate = 0x110,LeSetHostChannelClassification = 0x111,LeReadChannelMap = 0x112,LeReadRemoteFeatures = 0x113,LeEncrypt = 0x114,LeRand = 0x115,LeStartEncryption = 0x118,LeLongTermKeyRequestReply = 0x119,LeLongTermKeyRequestNegativeReply = 0x11a,LeReadSupportedStates = 0x11b,LeReceiverTest = 0x11c,LeTransmitterTest = 0x11d,LeTestEnd = 0x11e,EnhancedSetupSynchronousConnection = 0x125,EnhancedAcceptSynchronousConnection = 0x126,ReadLocalSupportedCodecsV1 = 0x127,RemoteOobExtendedDataRequestReply = 0x141,ReadSecureConnectionsHostSupport = 0x142,WriteSecureConnectionsHostSupport = 0x143,ReadLocalOobExtendedData = 0x146,WriteSecureConnectionsTestMode = 0x147,LeRemoteConnectionParameterRequestReply = 0x14e,LeRemoteConnectionParameterRequestNegativeReply = 0x14f,LeSetDataLength = 0x150,LeReadSuggestedDefaultDataLength = 0x151,LeWriteSuggestedDefaultDataLength = 0x154,LeReadLocalP256PublicKeyCommand = 0x155,LeGenerateDhkeyCommandV1 = 0x156,LeAddDeviceToResolvingList = 0x157,LeRemoveDeviceFromResolvingList = 0x158,LeClearResolvingList = 0x159,LeReadResolvingListSize = 0x15a,LeReadPeerResolvableAddress = 0x15b,LeReadLocalResolvableAddress = 0x15e,LeSetAddressResolutionEnable = 0x15f,LeSetResolvablePrivateAddressTimeout = 0x160,LeReadMaximumDataLength = 0x161,LeReadPhy = 0x162,LeSetDefaultPhy = 0x163,LeSetPhy = 0x164,LeEnhancedReceiverTest = 0x165,LeEnhancedTransmitterTest = 0x168,LeSetExtendedAdvertisingRandomAddress = 0x169,LeSetExtendedAdvertisingParameters = 0x16a,LeSetExtendedAdvertisingData = 0x16b,LeSetExtendedAdvertisingScanResponse = 0x16c,LeSetExtendedAdvertisingEnable = 0x16d,LeReadMaximumAdvertisingDataLength = 0x16e,LeReadNumberOfSupportedAdvertisingSets = 0x16f,LeRemoveAdvertisingSet = 0x172,LeClearAdvertisingSets = 0x173,LeSetPeriodicAdvertisingParam = 0x174,LeSetPeriodicAdvertisingData = 0x175,LeSetPeriodicAdvertisingEnable = 0x176,LeSetExtendedScanParameters = 0x177,LeSetExtendedScanEnable = 0x178,LeExtendedCreateConnection = 0x179,LePeriodicAdvertisingCreateSync = 0x17c,LePeriodicAdvertisingCreateSyncCancel = 0x17d,LePeriodicAdvertisingTerminateSync = 0x17e,LeAddDeviceToPeriodicAdvertisingList = 0x17f,LeRemoveDeviceFromPeriodicAdvertisingList = 0x180,LeClearPeriodicAdvertisingList = 0x181,LeReadPeriodicAdvertisingListSize = 0x182,LeReadTransmitPower = 0x183,LeReadRfPathCompensationPower = 0x186,LeWriteRfPathCompensationPower = 0x187,LeSetPrivacyMode = 0x188,LeSetPeriodicAdvertisingReceiveEnable = 0x195,LePeriodicAdvertisingSyncTransfer = 0x196,LePeriodicAdvertisingSetInfoTransfer = 0x197,LeSetPeriodicAdvertisingSyncTransferParameters = 0x19a,LeSetDefaultPeriodicAdvertisingSyncTransferParameters = 0x19b,LeGenerateDhkeyCommand = 0x19c,LeModifySleepClockAccuracy = 0x19e,LeReadBufferSizeV2 = 0x19f,LeReadIsoTxSync = 0x1a0,LeSetCigParameters = 0x1a1,LeSetCigParametersTest = 0x1a2,LeCreateCis = 0x1a5,LeRemoveCig = 0x1a6,LeAcceptCisRequest = 0x1a7,LeRejectCisRequest = 0x1a8,LeCreateBig = 0x1a9,LeTerminateBig = 0x1ab,LeBigCreateSync = 0x1ae,LeBigTerminateSync = 0x1af,LeRequestPeerSca = 0x1b0,LeSetupIsoDataPath = 0x1b1,LeRemoveIsoDataPath = 0x1b2,LeSetHostFeature = 0x1b9,LeReadIsoLinkQuality = 0x1ba,LeEnhancedReadTransmitPowerLevel = 0x1bb,LeReadRemoteTransmitPowerLevel = 0x1bc,LeSetPathLossReportingParameters = 0x1bd,LeSetPathLossReportingEnable = 0x1be,LeSetTransmitPowerReportingEnable = 0x1bf,SetEcosystemBaseInterval = 0x1c3,ReadLocalSupportedCodecsV2 = 0x1c4,ReadLocalSupportedCodecCapabilities = 0x1c5,ReadLocalSupportedControllerDelay = 0x1c6,ConfigureDataPath = 0x1c7,}impl TryFrom<OpCode> for OpCodeIndex {type Error = &'static str;fn try_from(value: OpCode) -> std::result::Result<Self, Self::Error> {match value {OpCode::Inquiry => Ok(OpCodeIndex::Inquiry),OpCode::InquiryCancel => Ok(OpCodeIndex::InquiryCancel),OpCode::PeriodicInquiryMode => Ok(OpCodeIndex::PeriodicInquiryMode),OpCode::ExitPeriodicInquiryMode => Ok(OpCodeIndex::ExitPeriodicInquiryMode),OpCode::CreateConnection => Ok(OpCodeIndex::CreateConnection),OpCode::Disconnect => Ok(OpCodeIndex::Disconnect),OpCode::CreateConnectionCancel => Ok(OpCodeIndex::CreateConnectionCancel),OpCode::AcceptConnectionRequest => Ok(OpCodeIndex::AcceptConnectionRequest),OpCode::RejectConnectionRequest => Ok(OpCodeIndex::RejectConnectionRequest),OpCode::LinkKeyRequestReply => Ok(OpCodeIndex::LinkKeyRequestReply),OpCode::LinkKeyRequestNegativeReply => Ok(OpCodeIndex::LinkKeyRequestNegativeReply),OpCode::PinCodeRequestReply => Ok(OpCodeIndex::PinCodeRequestReply),OpCode::PinCodeRequestNegativeReply => Ok(OpCodeIndex::PinCodeRequestNegativeReply),OpCode::ChangeConnectionPacketType => Ok(OpCodeIndex::ChangeConnectionPacketType),OpCode::AuthenticationRequested => Ok(OpCodeIndex::AuthenticationRequested),OpCode::SetConnectionEncryption => Ok(OpCodeIndex::SetConnectionEncryption),OpCode::ChangeConnectionLinkKey => Ok(OpCodeIndex::ChangeConnectionLinkKey),OpCode::CentralLinkKey => Ok(OpCodeIndex::CentralLinkKey),OpCode::RemoteNameRequest => Ok(OpCodeIndex::RemoteNameRequest),OpCode::RemoteNameRequestCancel => Ok(OpCodeIndex::RemoteNameRequestCancel),OpCode::ReadRemoteSupportedFeatures => Ok(OpCodeIndex::ReadRemoteSupportedFeatures),OpCode::ReadRemoteExtendedFeatures => Ok(OpCodeIndex::ReadRemoteExtendedFeatures),OpCode::ReadRemoteVersionInformation => Ok(OpCodeIndex::ReadRemoteVersionInformation),OpCode::ReadClockOffset => Ok(OpCodeIndex::ReadClockOffset),OpCode::ReadLmpHandle => Ok(OpCodeIndex::ReadLmpHandle),OpCode::HoldMode => Ok(OpCodeIndex::HoldMode),OpCode::SniffMode => Ok(OpCodeIndex::SniffMode),OpCode::ExitSniffMode => Ok(OpCodeIndex::ExitSniffMode),OpCode::QosSetup => Ok(OpCodeIndex::QosSetup),OpCode::RoleDiscovery => Ok(OpCodeIndex::RoleDiscovery),OpCode::SwitchRole => Ok(OpCodeIndex::SwitchRole),OpCode::ReadLinkPolicySettings => Ok(OpCodeIndex::ReadLinkPolicySettings),OpCode::WriteLinkPolicySettings => Ok(OpCodeIndex::WriteLinkPolicySettings),OpCode::ReadDefaultLinkPolicySettings => Ok(OpCodeIndex::ReadDefaultLinkPolicySettings),OpCode::WriteDefaultLinkPolicySettings => Ok(OpCodeIndex::WriteDefaultLinkPolicySettings),OpCode::FlowSpecification => Ok(OpCodeIndex::FlowSpecification),OpCode::SetEventMask => Ok(OpCodeIndex::SetEventMask),OpCode::Reset => Ok(OpCodeIndex::Reset),OpCode::SetEventFilter => Ok(OpCodeIndex::SetEventFilter),OpCode::Flush => Ok(OpCodeIndex::Flush),OpCode::ReadPinType => Ok(OpCodeIndex::ReadPinType),OpCode::WritePinType => Ok(OpCodeIndex::WritePinType),OpCode::ReadStoredLinkKey => Ok(OpCodeIndex::ReadStoredLinkKey),OpCode::WriteStoredLinkKey => Ok(OpCodeIndex::WriteStoredLinkKey),OpCode::DeleteStoredLinkKey => Ok(OpCodeIndex::DeleteStoredLinkKey),OpCode::WriteLocalName => Ok(OpCodeIndex::WriteLocalName),OpCode::ReadLocalName => Ok(OpCodeIndex::ReadLocalName),OpCode::ReadConnectionAcceptTimeout => Ok(OpCodeIndex::ReadConnectionAcceptTimeout),OpCode::WriteConnectionAcceptTimeout => Ok(OpCodeIndex::WriteConnectionAcceptTimeout),OpCode::ReadPageTimeout => Ok(OpCodeIndex::ReadPageTimeout),OpCode::WritePageTimeout => Ok(OpCodeIndex::WritePageTimeout),OpCode::ReadScanEnable => Ok(OpCodeIndex::ReadScanEnable),OpCode::WriteScanEnable => Ok(OpCodeIndex::WriteScanEnable),OpCode::ReadPageScanActivity => Ok(OpCodeIndex::ReadPageScanActivity),OpCode::WritePageScanActivity => Ok(OpCodeIndex::WritePageScanActivity),OpCode::ReadInquiryScanActivity => Ok(OpCodeIndex::ReadInquiryScanActivity),OpCode::WriteInquiryScanActivity => Ok(OpCodeIndex::WriteInquiryScanActivity),OpCode::ReadAuthenticationEnable => Ok(OpCodeIndex::ReadAuthenticationEnable),OpCode::WriteAuthenticationEnable => Ok(OpCodeIndex::WriteAuthenticationEnable),OpCode::ReadClassOfDevice => Ok(OpCodeIndex::ReadClassOfDevice),OpCode::WriteClassOfDevice => Ok(OpCodeIndex::WriteClassOfDevice),OpCode::ReadVoiceSetting => Ok(OpCodeIndex::ReadVoiceSetting),OpCode::WriteVoiceSetting => Ok(OpCodeIndex::WriteVoiceSetting),OpCode::ReadAutomaticFlushTimeout => Ok(OpCodeIndex::ReadAutomaticFlushTimeout),OpCode::WriteAutomaticFlushTimeout => Ok(OpCodeIndex::WriteAutomaticFlushTimeout),OpCode::ReadNumBroadcastRetransmits => Ok(OpCodeIndex::ReadNumBroadcastRetransmits),OpCode::WriteNumBroadcastRetransmits => Ok(OpCodeIndex::WriteNumBroadcastRetransmits),OpCode::ReadHoldModeActivity => Ok(OpCodeIndex::ReadHoldModeActivity),OpCode::WriteHoldModeActivity => Ok(OpCodeIndex::WriteHoldModeActivity),OpCode::ReadTransmitPowerLevel => Ok(OpCodeIndex::ReadTransmitPowerLevel),OpCode::ReadSynchronousFlowControlEnable => Ok(OpCodeIndex::ReadSynchronousFlowControlEnable),OpCode::WriteSynchronousFlowControlEnable => Ok(OpCodeIndex::WriteSynchronousFlowControlEnable),OpCode::SetControllerToHostFlowControl => Ok(OpCodeIndex::SetControllerToHostFlowControl),OpCode::HostBufferSize => Ok(OpCodeIndex::HostBufferSize),OpCode::HostNumCompletedPackets => Ok(OpCodeIndex::HostNumCompletedPackets),OpCode::ReadLinkSupervisionTimeout => Ok(OpCodeIndex::ReadLinkSupervisionTimeout),OpCode::WriteLinkSupervisionTimeout => Ok(OpCodeIndex::WriteLinkSupervisionTimeout),OpCode::ReadNumberOfSupportedIac => Ok(OpCodeIndex::ReadNumberOfSupportedIac),OpCode::ReadCurrentIacLap => Ok(OpCodeIndex::ReadCurrentIacLap),OpCode::WriteCurrentIacLap => Ok(OpCodeIndex::WriteCurrentIacLap),OpCode::SetAfhHostChannelClassification => Ok(OpCodeIndex::SetAfhHostChannelClassification),OpCode::ReadInquiryScanType => Ok(OpCodeIndex::ReadInquiryScanType),OpCode::WriteInquiryScanType => Ok(OpCodeIndex::WriteInquiryScanType),OpCode::ReadInquiryMode => Ok(OpCodeIndex::ReadInquiryMode),OpCode::WriteInquiryMode => Ok(OpCodeIndex::WriteInquiryMode),OpCode::ReadPageScanType => Ok(OpCodeIndex::ReadPageScanType),OpCode::WritePageScanType => Ok(OpCodeIndex::WritePageScanType),OpCode::ReadAfhChannelAssessmentMode => Ok(OpCodeIndex::ReadAfhChannelAssessmentMode),OpCode::WriteAfhChannelAssessmentMode => Ok(OpCodeIndex::WriteAfhChannelAssessmentMode),OpCode::ReadLocalVersionInformation => Ok(OpCodeIndex::ReadLocalVersionInformation),OpCode::ReadLocalSupportedFeatures => Ok(OpCodeIndex::ReadLocalSupportedFeatures),OpCode::ReadLocalExtendedFeatures => Ok(OpCodeIndex::ReadLocalExtendedFeatures),OpCode::ReadBufferSize => Ok(OpCodeIndex::ReadBufferSize),OpCode::ReadBdAddr => Ok(OpCodeIndex::ReadBdAddr),OpCode::ReadFailedContactCounter => Ok(OpCodeIndex::ReadFailedContactCounter),OpCode::ResetFailedContactCounter => Ok(OpCodeIndex::ResetFailedContactCounter),OpCode::ReadLinkQuality => Ok(OpCodeIndex::ReadLinkQuality),OpCode::ReadRssi => Ok(OpCodeIndex::ReadRssi),OpCode::ReadAfhChannelMap => Ok(OpCodeIndex::ReadAfhChannelMap),OpCode::ReadClock => Ok(OpCodeIndex::ReadClock),OpCode::ReadLoopbackMode => Ok(OpCodeIndex::ReadLoopbackMode),OpCode::WriteLoopbackMode => Ok(OpCodeIndex::WriteLoopbackMode),OpCode::EnableDeviceUnderTestMode => Ok(OpCodeIndex::EnableDeviceUnderTestMode),OpCode::SetupSynchronousConnection => Ok(OpCodeIndex::SetupSynchronousConnection),OpCode::AcceptSynchronousConnection => Ok(OpCodeIndex::AcceptSynchronousConnection),OpCode::RejectSynchronousConnection => Ok(OpCodeIndex::RejectSynchronousConnection),OpCode::ReadExtendedInquiryResponse => Ok(OpCodeIndex::ReadExtendedInquiryResponse),OpCode::WriteExtendedInquiryResponse => Ok(OpCodeIndex::WriteExtendedInquiryResponse),OpCode::RefreshEncryptionKey => Ok(OpCodeIndex::RefreshEncryptionKey),OpCode::SniffSubrating => Ok(OpCodeIndex::SniffSubrating),OpCode::ReadSimplePairingMode => Ok(OpCodeIndex::ReadSimplePairingMode),OpCode::WriteSimplePairingMode => Ok(OpCodeIndex::WriteSimplePairingMode),OpCode::ReadLocalOobData => Ok(OpCodeIndex::ReadLocalOobData),OpCode::ReadInquiryResponseTransmitPowerLevel => Ok(OpCodeIndex::ReadInquiryResponseTransmitPowerLevel),OpCode::WriteInquiryTransmitPowerLevel => Ok(OpCodeIndex::WriteInquiryTransmitPowerLevel),OpCode::IoCapabilityRequestReply => Ok(OpCodeIndex::IoCapabilityRequestReply),OpCode::UserConfirmationRequestReply => Ok(OpCodeIndex::UserConfirmationRequestReply),OpCode::UserConfirmationRequestNegativeReply => Ok(OpCodeIndex::UserConfirmationRequestNegativeReply),OpCode::UserPasskeyRequestReply => Ok(OpCodeIndex::UserPasskeyRequestReply),OpCode::UserPasskeyRequestNegativeReply => Ok(OpCodeIndex::UserPasskeyRequestNegativeReply),OpCode::RemoteOobDataRequestReply => Ok(OpCodeIndex::RemoteOobDataRequestReply),OpCode::WriteSimplePairingDebugMode => Ok(OpCodeIndex::WriteSimplePairingDebugMode),OpCode::EnhancedFlush => Ok(OpCodeIndex::EnhancedFlush),OpCode::RemoteOobDataRequestNegativeReply => Ok(OpCodeIndex::RemoteOobDataRequestNegativeReply),OpCode::SendKeypressNotification => Ok(OpCodeIndex::SendKeypressNotification),OpCode::IoCapabilityRequestNegativeReply => Ok(OpCodeIndex::IoCapabilityRequestNegativeReply),OpCode::ReadEncryptionKeySize => Ok(OpCodeIndex::ReadEncryptionKeySize),OpCode::SetEventMaskPage2 => Ok(OpCodeIndex::SetEventMaskPage2),OpCode::ReadDataBlockSize => Ok(OpCodeIndex::ReadDataBlockSize),OpCode::ReadLeHostSupport => Ok(OpCodeIndex::ReadLeHostSupport),OpCode::WriteLeHostSupport => Ok(OpCodeIndex::WriteLeHostSupport),OpCode::LeSetEventMask => Ok(OpCodeIndex::LeSetEventMask),OpCode::LeReadBufferSizeV1 => Ok(OpCodeIndex::LeReadBufferSizeV1),OpCode::LeReadLocalSupportedFeatures => Ok(OpCodeIndex::LeReadLocalSupportedFeatures),OpCode::LeSetRandomAddress => Ok(OpCodeIndex::LeSetRandomAddress),OpCode::LeSetAdvertisingParameters => Ok(OpCodeIndex::LeSetAdvertisingParameters),OpCode::LeReadAdvertisingPhysicalChannelTxPower => Ok(OpCodeIndex::LeReadAdvertisingPhysicalChannelTxPower),OpCode::LeSetAdvertisingData => Ok(OpCodeIndex::LeSetAdvertisingData),OpCode::LeSetScanResponseData => Ok(OpCodeIndex::LeSetScanResponseData),OpCode::LeSetAdvertisingEnable => Ok(OpCodeIndex::LeSetAdvertisingEnable),OpCode::LeSetScanParameters => Ok(OpCodeIndex::LeSetScanParameters),OpCode::LeSetScanEnable => Ok(OpCodeIndex::LeSetScanEnable),OpCode::LeCreateConnection => Ok(OpCodeIndex::LeCreateConnection),OpCode::LeCreateConnectionCancel => Ok(OpCodeIndex::LeCreateConnectionCancel),OpCode::LeReadConnectListSize => Ok(OpCodeIndex::LeReadConnectListSize),OpCode::LeClearConnectList => Ok(OpCodeIndex::LeClearConnectList),OpCode::LeAddDeviceToConnectList => Ok(OpCodeIndex::LeAddDeviceToConnectList),OpCode::LeRemoveDeviceFromConnectList => Ok(OpCodeIndex::LeRemoveDeviceFromConnectList),OpCode::LeConnectionUpdate => Ok(OpCodeIndex::LeConnectionUpdate),OpCode::LeSetHostChannelClassification => Ok(OpCodeIndex::LeSetHostChannelClassification),OpCode::LeReadChannelMap => Ok(OpCodeIndex::LeReadChannelMap),OpCode::LeReadRemoteFeatures => Ok(OpCodeIndex::LeReadRemoteFeatures),OpCode::LeEncrypt => Ok(OpCodeIndex::LeEncrypt),OpCode::LeRand => Ok(OpCodeIndex::LeRand),OpCode::LeStartEncryption => Ok(OpCodeIndex::LeStartEncryption),OpCode::LeLongTermKeyRequestReply => Ok(OpCodeIndex::LeLongTermKeyRequestReply),OpCode::LeLongTermKeyRequestNegativeReply => Ok(OpCodeIndex::LeLongTermKeyRequestNegativeReply),OpCode::LeReadSupportedStates => Ok(OpCodeIndex::LeReadSupportedStates),OpCode::LeReceiverTest => Ok(OpCodeIndex::LeReceiverTest),OpCode::LeTransmitterTest => Ok(OpCodeIndex::LeTransmitterTest),OpCode::LeTestEnd => Ok(OpCodeIndex::LeTestEnd),OpCode::EnhancedSetupSynchronousConnection => Ok(OpCodeIndex::EnhancedSetupSynchronousConnection),OpCode::EnhancedAcceptSynchronousConnection => Ok(OpCodeIndex::EnhancedAcceptSynchronousConnection),OpCode::ReadLocalSupportedCodecsV1 => Ok(OpCodeIndex::ReadLocalSupportedCodecsV1),OpCode::RemoteOobExtendedDataRequestReply => Ok(OpCodeIndex::RemoteOobExtendedDataRequestReply),OpCode::ReadSecureConnectionsHostSupport => Ok(OpCodeIndex::ReadSecureConnectionsHostSupport),OpCode::WriteSecureConnectionsHostSupport => Ok(OpCodeIndex::WriteSecureConnectionsHostSupport),OpCode::ReadLocalOobExtendedData => Ok(OpCodeIndex::ReadLocalOobExtendedData),OpCode::WriteSecureConnectionsTestMode => Ok(OpCodeIndex::WriteSecureConnectionsTestMode),OpCode::LeRemoteConnectionParameterRequestReply => Ok(OpCodeIndex::LeRemoteConnectionParameterRequestReply),OpCode::LeRemoteConnectionParameterRequestNegativeReply => Ok(OpCodeIndex::LeRemoteConnectionParameterRequestNegativeReply),OpCode::LeSetDataLength => Ok(OpCodeIndex::LeSetDataLength),OpCode::LeReadSuggestedDefaultDataLength => Ok(OpCodeIndex::LeReadSuggestedDefaultDataLength),OpCode::LeWriteSuggestedDefaultDataLength => Ok(OpCodeIndex::LeWriteSuggestedDefaultDataLength),OpCode::LeReadLocalP256PublicKeyCommand => Ok(OpCodeIndex::LeReadLocalP256PublicKeyCommand),OpCode::LeGenerateDhkeyCommandV1 => Ok(OpCodeIndex::LeGenerateDhkeyCommandV1),OpCode::LeAddDeviceToResolvingList => Ok(OpCodeIndex::LeAddDeviceToResolvingList),OpCode::LeRemoveDeviceFromResolvingList => Ok(OpCodeIndex::LeRemoveDeviceFromResolvingList),OpCode::LeClearResolvingList => Ok(OpCodeIndex::LeClearResolvingList),OpCode::LeReadResolvingListSize => Ok(OpCodeIndex::LeReadResolvingListSize),OpCode::LeReadPeerResolvableAddress => Ok(OpCodeIndex::LeReadPeerResolvableAddress),OpCode::LeReadLocalResolvableAddress => Ok(OpCodeIndex::LeReadLocalResolvableAddress),OpCode::LeSetAddressResolutionEnable => Ok(OpCodeIndex::LeSetAddressResolutionEnable),OpCode::LeSetResolvablePrivateAddressTimeout => Ok(OpCodeIndex::LeSetResolvablePrivateAddressTimeout),OpCode::LeReadMaximumDataLength => Ok(OpCodeIndex::LeReadMaximumDataLength),OpCode::LeReadPhy => Ok(OpCodeIndex::LeReadPhy),OpCode::LeSetDefaultPhy => Ok(OpCodeIndex::LeSetDefaultPhy),OpCode::LeSetPhy => Ok(OpCodeIndex::LeSetPhy),OpCode::LeEnhancedReceiverTest => Ok(OpCodeIndex::LeEnhancedReceiverTest),OpCode::LeEnhancedTransmitterTest => Ok(OpCodeIndex::LeEnhancedTransmitterTest),OpCode::LeSetExtendedAdvertisingRandomAddress => Ok(OpCodeIndex::LeSetExtendedAdvertisingRandomAddress),OpCode::LeSetExtendedAdvertisingParameters => Ok(OpCodeIndex::LeSetExtendedAdvertisingParameters),OpCode::LeSetExtendedAdvertisingData => Ok(OpCodeIndex::LeSetExtendedAdvertisingData),OpCode::LeSetExtendedAdvertisingScanResponse => Ok(OpCodeIndex::LeSetExtendedAdvertisingScanResponse),OpCode::LeSetExtendedAdvertisingEnable => Ok(OpCodeIndex::LeSetExtendedAdvertisingEnable),OpCode::LeReadMaximumAdvertisingDataLength => Ok(OpCodeIndex::LeReadMaximumAdvertisingDataLength),OpCode::LeReadNumberOfSupportedAdvertisingSets => Ok(OpCodeIndex::LeReadNumberOfSupportedAdvertisingSets),OpCode::LeRemoveAdvertisingSet => Ok(OpCodeIndex::LeRemoveAdvertisingSet),OpCode::LeClearAdvertisingSets => Ok(OpCodeIndex::LeClearAdvertisingSets),OpCode::LeSetPeriodicAdvertisingParam => Ok(OpCodeIndex::LeSetPeriodicAdvertisingParam),OpCode::LeSetPeriodicAdvertisingData => Ok(OpCodeIndex::LeSetPeriodicAdvertisingData),OpCode::LeSetPeriodicAdvertisingEnable => Ok(OpCodeIndex::LeSetPeriodicAdvertisingEnable),OpCode::LeSetExtendedScanParameters => Ok(OpCodeIndex::LeSetExtendedScanParameters),OpCode::LeSetExtendedScanEnable => Ok(OpCodeIndex::LeSetExtendedScanEnable),OpCode::LeExtendedCreateConnection => Ok(OpCodeIndex::LeExtendedCreateConnection),OpCode::LePeriodicAdvertisingCreateSync => Ok(OpCodeIndex::LePeriodicAdvertisingCreateSync),OpCode::LePeriodicAdvertisingCreateSyncCancel => Ok(OpCodeIndex::LePeriodicAdvertisingCreateSyncCancel),OpCode::LePeriodicAdvertisingTerminateSync => Ok(OpCodeIndex::LePeriodicAdvertisingTerminateSync),OpCode::LeAddDeviceToPeriodicAdvertisingList => Ok(OpCodeIndex::LeAddDeviceToPeriodicAdvertisingList),OpCode::LeRemoveDeviceFromPeriodicAdvertisingList => Ok(OpCodeIndex::LeRemoveDeviceFromPeriodicAdvertisingList),OpCode::LeClearPeriodicAdvertisingList => Ok(OpCodeIndex::LeClearPeriodicAdvertisingList),OpCode::LeReadPeriodicAdvertisingListSize => Ok(OpCodeIndex::LeReadPeriodicAdvertisingListSize),OpCode::LeReadTransmitPower => Ok(OpCodeIndex::LeReadTransmitPower),OpCode::LeReadRfPathCompensationPower => Ok(OpCodeIndex::LeReadRfPathCompensationPower),OpCode::LeWriteRfPathCompensationPower => Ok(OpCodeIndex::LeWriteRfPathCompensationPower),OpCode::LeSetPrivacyMode => Ok(OpCodeIndex::LeSetPrivacyMode),OpCode::LeSetPeriodicAdvertisingReceiveEnable => Ok(OpCodeIndex::LeSetPeriodicAdvertisingReceiveEnable),OpCode::LePeriodicAdvertisingSyncTransfer => Ok(OpCodeIndex::LePeriodicAdvertisingSyncTransfer),OpCode::LePeriodicAdvertisingSetInfoTransfer => Ok(OpCodeIndex::LePeriodicAdvertisingSetInfoTransfer),OpCode::LeSetPeriodicAdvertisingSyncTransferParameters => Ok(OpCodeIndex::LeSetPeriodicAdvertisingSyncTransferParameters),OpCode::LeSetDefaultPeriodicAdvertisingSyncTransferParameters => Ok(OpCodeIndex::LeSetDefaultPeriodicAdvertisingSyncTransferParameters),OpCode::LeGenerateDhkeyCommand => Ok(OpCodeIndex::LeGenerateDhkeyCommand),OpCode::LeModifySleepClockAccuracy => Ok(OpCodeIndex::LeModifySleepClockAccuracy),OpCode::LeReadBufferSizeV2 => Ok(OpCodeIndex::LeReadBufferSizeV2),OpCode::LeReadIsoTxSync => Ok(OpCodeIndex::LeReadIsoTxSync),OpCode::LeSetCigParameters => Ok(OpCodeIndex::LeSetCigParameters),OpCode::LeSetCigParametersTest => Ok(OpCodeIndex::LeSetCigParametersTest),OpCode::LeCreateCis => Ok(OpCodeIndex::LeCreateCis),OpCode::LeRemoveCig => Ok(OpCodeIndex::LeRemoveCig),OpCode::LeAcceptCisRequest => Ok(OpCodeIndex::LeAcceptCisRequest),OpCode::LeRejectCisRequest => Ok(OpCodeIndex::LeRejectCisRequest),OpCode::LeCreateBig => Ok(OpCodeIndex::LeCreateBig),OpCode::LeTerminateBig => Ok(OpCodeIndex::LeTerminateBig),OpCode::LeBigCreateSync => Ok(OpCodeIndex::LeBigCreateSync),OpCode::LeBigTerminateSync => Ok(OpCodeIndex::LeBigTerminateSync),OpCode::LeRequestPeerSca => Ok(OpCodeIndex::LeRequestPeerSca),OpCode::LeSetupIsoDataPath => Ok(OpCodeIndex::LeSetupIsoDataPath),OpCode::LeRemoveIsoDataPath => Ok(OpCodeIndex::LeRemoveIsoDataPath),OpCode::LeSetHostFeature => Ok(OpCodeIndex::LeSetHostFeature),OpCode::LeReadIsoLinkQuality => Ok(OpCodeIndex::LeReadIsoLinkQuality),OpCode::LeEnhancedReadTransmitPowerLevel => Ok(OpCodeIndex::LeEnhancedReadTransmitPowerLevel),OpCode::LeReadRemoteTransmitPowerLevel => Ok(OpCodeIndex::LeReadRemoteTransmitPowerLevel),OpCode::LeSetPathLossReportingParameters => Ok(OpCodeIndex::LeSetPathLossReportingParameters),OpCode::LeSetPathLossReportingEnable => Ok(OpCodeIndex::LeSetPathLossReportingEnable),OpCode::LeSetTransmitPowerReportingEnable => Ok(OpCodeIndex::LeSetTransmitPowerReportingEnable),OpCode::SetEcosystemBaseInterval => Ok(OpCodeIndex::SetEcosystemBaseInterval),OpCode::ReadLocalSupportedCodecsV2 => Ok(OpCodeIndex::ReadLocalSupportedCodecsV2),OpCode::ReadLocalSupportedCodecCapabilities => Ok(OpCodeIndex::ReadLocalSupportedCodecCapabilities),OpCode::ReadLocalSupportedControllerDelay => Ok(OpCodeIndex::ReadLocalSupportedControllerDelay),OpCode::ConfigureDataPath => Ok(OpCodeIndex::ConfigureDataPath),_ => Err("No mapping for provided key"),}}}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum EventCode {InquiryComplete = 0x1,InquiryResult = 0x2,ConnectionComplete = 0x3,ConnectionRequest = 0x4,DisconnectionComplete = 0x5,AuthenticationComplete = 0x6,RemoteNameRequestComplete = 0x7,EncryptionChange = 0x8,ChangeConnectionLinkKeyComplete = 0x9,CentralLinkKeyComplete = 0xa,ReadRemoteSupportedFeaturesComplete = 0xb,ReadRemoteVersionInformationComplete = 0xc,QosSetupComplete = 0xd,CommandComplete = 0xe,CommandStatus = 0xf,HardwareError = 0x10,FlushOccurred = 0x11,RoleChange = 0x12,NumberOfCompletedPackets = 0x13,ModeChange = 0x14,ReturnLinkKeys = 0x15,PinCodeRequest = 0x16,LinkKeyRequest = 0x17,LinkKeyNotification = 0x18,LoopbackCommand = 0x19,DataBufferOverflow = 0x1a,MaxSlotsChange = 0x1b,ReadClockOffsetComplete = 0x1c,ConnectionPacketTypeChanged = 0x1d,QosViolation = 0x1e,PageScanRepetitionModeChange = 0x20,FlowSpecificationComplete = 0x21,InquiryResultWithRssi = 0x22,ReadRemoteExtendedFeaturesComplete = 0x23,SynchronousConnectionComplete = 0x2c,SynchronousConnectionChanged = 0x2d,SniffSubrating = 0x2e,ExtendedInquiryResult = 0x2f,EncryptionKeyRefreshComplete = 0x30,IoCapabilityRequest = 0x31,IoCapabilityResponse = 0x32,UserConfirmationRequest = 0x33,UserPasskeyRequest = 0x34,RemoteOobDataRequest = 0x35,SimplePairingComplete = 0x36,LinkSupervisionTimeoutChanged = 0x38,EnhancedFlushComplete = 0x39,UserPasskeyNotification = 0x3b,KeypressNotification = 0x3c,RemoteHostSupportedFeaturesNotification = 0x3d,LeMetaEvent = 0x3e,NumberOfCompletedDataBlocks = 0x48,VendorSpecific = 0xff,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum SubeventCode {ConnectionComplete = 0x1,AdvertisingReport = 0x2,ConnectionUpdateComplete = 0x3,ReadRemoteFeaturesComplete = 0x4,LongTermKeyRequest = 0x5,RemoteConnectionParameterRequest = 0x6,DataLengthChange = 0x7,ReadLocalP256PublicKeyComplete = 0x8,GenerateDhkeyComplete = 0x9,EnhancedConnectionComplete = 0xa,DirectedAdvertisingReport = 0xb,PhyUpdateComplete = 0xc,ExtendedAdvertisingReport = 0xd,PeriodicAdvertisingSyncEstablished = 0xe,PeriodicAdvertisingReport = 0xf,PeriodicAdvertisingSyncLost = 0x10,ScanTimeout = 0x11,AdvertisingSetTerminated = 0x12,ScanRequestReceived = 0x13,ChannelSelectionAlgorithm = 0x14,ConnectionlessIqReport = 0x15,ConnectionIqReport = 0x16,CteRequestFailed = 0x17,PeriodicAdvertisingSyncTransferReceived = 0x18,CisEstablished = 0x19,CisRequest = 0x1a,CreateBigComplete = 0x1b,TerminateBigComplete = 0x1c,BigSyncEstablished = 0x1d,BigSyncLost = 0x1e,RequestPeerScaComplete = 0x1f,PathLossThreshold = 0x20,TransmitPowerReporting = 0x21,BigInfoAdvertisingReport = 0x22,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum VseSubeventCode {BleThreshold = 0x54,BleTracking = 0x56,DebugInfo = 0x57,BqrEvent = 0x58,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum FeatureFlag {Unsupported = 0x0,Supported = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum ErrorCode {Success = 0x0,UnknownHciCommand = 0x1,UnknownConnection = 0x2,HardwareFailure = 0x3,PageTimeout = 0x4,AuthenticationFailure = 0x5,PinOrKeyMissing = 0x6,MemoryCapacityExceeded = 0x7,ConnectionTimeout = 0x8,ConnectionLimitExceeded = 0x9,SynchronousConnectionLimitExceeded = 0xa,ConnectionAlreadyExists = 0xb,CommandDisallowed = 0xc,ConnectionRejectedLimitedResources = 0xd,ConnectionRejectedSecurityReasons = 0xe,ConnectionRejectedUnacceptableBdAddr = 0xf,ConnectionAcceptTimeout = 0x10,UnsuportedFeatureOrParameterValue = 0x11,InvalidHciCommandParameters = 0x12,RemoteUserTerminatedConnection = 0x13,RemoteDeviceTerminatedConnectionLowResources = 0x14,RemoteDeviceTerminatedConnectionPowerOff = 0x15,ConnectionTerminatedByLocalHost = 0x16,RepeatedAttempts = 0x17,PairingNotAllowed = 0x18,UnknownLmpPdu = 0x19,UnsupportedRemoteOrLmpFeature = 0x1a,ScoOffsetRejected = 0x1b,ScoIntervalRejected = 0x1c,ScoAirModeRejected = 0x1d,InvalidLmpOrLlParameters = 0x1e,UnspecifiedError = 0x1f,UnsupportedLmpOrLlParameter = 0x20,RoleChangeNotAllowed = 0x21,LinkLayerCollision = 0x23,EncryptionModeNotAcceptable = 0x25,RoleSwitchFailed = 0x35,ControllerBusy = 0x3a,ConnectionFailedEstablishment = 0x3e,StatusUnknown = 0xff,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum PageScanRepetitionMode {R0 = 0x0,R1 = 0x1,R2 = 0x2,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum ClockOffsetValid {Invalid = 0x0,Valid = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum CreateConnectionRoleSwitch {RemainCentral = 0x0,AllowRoleSwitch = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum DisconnectReason {AuthenticationFailure = 0x5,RemoteUserTerminatedConnection = 0x13,RemoteDeviceTerminatedConnectionLowResources = 0x14,RemoteDeviceTerminatedConnectionPowerOff = 0x15,UnsupportedRemoteFeature = 0x1a,PairingWithUnitKeyNotSupported = 0x29,UnacceptableConnectionParameters = 0x3b,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum AcceptConnectionRequestRole {BecomeCentral = 0x0,RemainPeripheral = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum RejectConnectionReason {LimitedResources = 0xd,SecurityReasons = 0xe,UnacceptableBdAddr = 0xf,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum KeyFlag {SemiPermanent = 0x0,Temporary = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum IoCapability {DisplayOnly = 0x0,DisplayYesNo = 0x1,KeyboardOnly = 0x2,NoInputNoOutput = 0x3,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum OobDataPresent {NotPresent = 0x0,P192Present = 0x1,P256Present = 0x2,P192And256Present = 0x3,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum AuthenticationRequirements {NoBonding = 0x0,NoBondingMitmProtection = 0x1,DedicatedBonding = 0x2,DedicatedBondingMitmProtection = 0x3,GeneralBonding = 0x4,GeneralBondingMitmProtection = 0x5,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum ScoCodingFormatValues {UlawLong = 0x0,AlawLong = 0x1,Cvsd = 0x2,Transparent = 0x3,LinearPcm = 0x4,Msbc = 0x5,Lc3 = 0x6,VendorSpecific = 0xff,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum ScoPcmDataFormat {NotUsed = 0x0,OnesComplement = 0x1,TwosComplement = 0x2,SignMagnitude = 0x3,Unsigned = 0x4,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum ScoDataPath {Hci = 0x0,GdPcm = 0x1,AudioTestMode = 0xff,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum SynchronousPacketTypeBits {Hv1Allowed = 0x0,Hv2Allowed = 0x1,Hv3Allowed = 0x2,Ev3Allowed = 0x4,Ev4Allowed = 0x8,Ev5Allowed = 0x10,No2Ev3Allowed = 0x20,No3Ev3Allowed = 0x40,No2Ev5Allowed = 0x80,No3Ev5Allowed = 0x100,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum RetransmissionEffort {NoRetransmission = 0x0,OptimizedForPower = 0x1,OptimizedForLinkQuality = 0x2,DoNotCare = 0xff,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum ServiceType {NoTraffic = 0x0,BestEffort = 0x1,Guaranteed = 0x2,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum Role {Central = 0x0,Peripheral = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum LinkPolicy {EnableRoleSwitch = 0x1,EnableHoldMode = 0x2,EnableSniffMode = 0x4,EnableParkMode = 0x8,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum FlowDirection {OutgoingFlow = 0x0,IncomingFlow = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum FilterType {ClearAllFilters = 0x0,InquiryResult = 0x1,ConnectionSetup = 0x2,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum FilterConditionType {AllDevices = 0x0,ClassOfDevice = 0x1,Address = 0x2,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum AutoAcceptFlag {AutoAcceptOff = 0x1,AutoAcceptOnRoleSwitchDisabled = 0x2,AutoAcceptOnRoleSwitchEnabled = 0x3,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum PinType {Variable = 0x0,Fixed = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum ReadStoredLinkKeyReadAllFlag {SpecifiedBdAddr = 0x0,All = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum DeleteStoredLinkKeyDeleteAllFlag {SpecifiedBdAddr = 0x0,All = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum ScanEnable {NoScans = 0x0,InquiryScanOnly = 0x1,PageScanOnly = 0x2,InquiryAndPageScan = 0x3,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum AuthenticationEnable {NotRequired = 0x0,Required = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum HoldModeActivity {MaintainCurrentPowerState = 0x0,SuspendPageScan = 0x1,SuspendInquiryScan = 0x2,SuspendPeriodicInquiry = 0x3,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum TransmitPowerLevelType {Current = 0x0,Maximum = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum InquiryScanType {Standard = 0x0,Interlaced = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum InquiryMode {Standard = 0x0,Rssi = 0x1,RssiOrExtended = 0x2,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum PageScanType {Standard = 0x0,Interlaced = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum FecRequired {NotRequired = 0x0,Required = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum KeypressNotificationType {EntryStarted = 0x0,DigitEntered = 0x1,DigitErased = 0x2,Cleared = 0x3,EntryCompleted = 0x4,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum DataPathDirection {Input = 0x0,Output = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum HciVersion {V10b = 0x0,V11 = 0x1,V12 = 0x2,V20 = 0x3,V21 = 0x4,V30 = 0x5,V40 = 0x6,V41 = 0x7,V42 = 0x8,V50 = 0x9,V51 = 0xa,V52 = 0xb,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum LmpVersion {V10b = 0x0,V11 = 0x1,V12 = 0x2,V20 = 0x3,V21 = 0x4,V30 = 0x5,V40 = 0x6,V41 = 0x7,V42 = 0x8,V50 = 0x9,V51 = 0xa,V52 = 0xb,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum AfhMode {AfhDisabled = 0x0,AfhEnabled = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum WhichClock {Local = 0x0,Piconet = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum LoopbackMode {NoLoopback = 0x0,EnableLocal = 0x1,EnableRemote = 0x2,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum AdvertisingFilterPolicy {AllDevices = 0x0,ListedScan = 0x1,ListedConnect = 0x2,ListedScanAndConnect = 0x3,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum PeerAddressType {PublicDeviceOrIdentityAddress = 0x0,RandomDeviceOrIdentityAddress = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum AdvertisingType {AdvInd = 0x0,AdvDirectInd = 0x1,AdvScanInd = 0x2,AdvNonconnInd = 0x3,AdvDirectIndLow = 0x4,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum AddressType {PublicDeviceAddress = 0x0,RandomDeviceAddress = 0x1,PublicIdentityAddress = 0x2,RandomIdentityAddress = 0x3,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum OwnAddressType {PublicDeviceAddress = 0x0,RandomDeviceAddress = 0x1,ResolvableOrPublicAddress = 0x2,ResolvableOrRandomAddress = 0x3,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum LeScanType {Passive = 0x0,Active = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum LeScanningFilterPolicy {AcceptAll = 0x0,ConnectListOnly = 0x1,CheckInitiatorsIdentity = 0x2,ConnectListAndInitiatorsIdentity = 0x3,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum InitiatorFilterPolicy {UsePeerAddress = 0x0,UseConnectList = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum ConnectListAddressType {Public = 0x0,Random = 0x1,AnonymousAdvertisers = 0xff,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum LeTestPayload {Prbs9 = 0x0,RepeatedF0 = 0x1,RepeatedAa = 0x2,Prbs15 = 0x3,RepeatedFf = 0x4,Repeated00 = 0x5,Repeated0f = 0x6,Repeated55 = 0x7,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum PhyType {Le1m = 0x1,Le2m = 0x2,LeCoded = 0x3,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum PhyOptions {NoPreference = 0x0,S2 = 0x1,S8 = 0x2,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum ModulationIndex {Standard = 0x0,Stable = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum LegacyAdvertisingProperties {AdvNonconnInd = 0x0,AdvScanInd = 0x2,AdvInd = 0x3,AdvDirectIndLow = 0x5,AdvDirectIndHigh = 0xd,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum PrimaryPhyType {Le1m = 0x1,LeCoded = 0x3,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum SecondaryPhyType {NoPackets = 0x0,Le1m = 0x1,Le2m = 0x2,LeCoded = 0x3,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum Operation {IntermediateFragment = 0x0,FirstFragment = 0x1,LastFragment = 0x2,CompleteAdvertisement = 0x3,UnchangedData = 0x4,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum FragmentPreference {ControllerMayFragment = 0x0,ControllerShouldNot = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum FilterDuplicates {Disabled = 0x0,Enabled = 0x1,ResetEachPeriod = 0x2,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum AdvertisingAddressType {PublicAddress = 0x0,RandomAddress = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum PrivacyMode {Network = 0x0,Device = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum SyncTransferMode {NoSync = 0x0,SendSyncReceivedDisableReports = 0x1,SendSyncReceivedSendReports = 0x2,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum UseDebugKey {UseGeneratedKey = 0x0,UseDebugKey = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum ScaAction {MoreAccurateClock = 0x0,LessAccurateClock = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum Packing {Sequential = 0x0,Interleaved = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum ClockAccuracy {Ppm500 = 0x0,Ppm250 = 0x1,Ppm150 = 0x2,Ppm100 = 0x3,Ppm75 = 0x4,Ppm50 = 0x5,Ppm30 = 0x6,Ppm20 = 0x7,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum PhyWithCodedSpecified {Le1m = 0x1,Le2m = 0x2,LeCodedS8 = 0x3,LeCodedS2 = 0x4,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum SubOcf {SetParam = 0x1,SetData = 0x2,SetScanResp = 0x3,SetRandomAddr = 0x4,SetEnable = 0x5,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum BatchScanOpcode {Enable = 0x1,SetStorageParameters = 0x2,SetScanParameters = 0x3,ReadResultParameters = 0x4,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum BatchScanDiscardRule {Oldest = 0x0,WeakestRssi = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum BatchScanDataRead {TruncatedModeData = 0x1,FullModeData = 0x2,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum ApcfOpcode {Enable = 0x0,SetFilteringParameters = 0x1,BroadcasterAddress = 0x2,ServiceUuid = 0x3,ServiceSolicitationUuid = 0x4,LocalName = 0x5,ManufacturerData = 0x6,ServiceData = 0x7,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum ApcfAction {Add = 0x0,Delete = 0x1,Clear = 0x2,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum DeliveryMode {Immediate = 0x0,Onfound = 0x1,Batched = 0x2,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum ApcfFilterType {BroadcasterAddress = 0x0,ServiceDataChange = 0x1,ServiceUuid = 0x2,ServiceSolicitationUuid = 0x3,LocalName = 0x4,ManufacturerData = 0x5,ServiceData = 0x6,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum ApcfApplicationAddressType {Public = 0x0,Random = 0x1,NotApplicable = 0x2,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum BqrReportAction {Add = 0x0,Delete = 0x1,Clear = 0x2,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum LinkType {Sco = 0x0,Acl = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum ConnectionRequestLinkType {Sco = 0x0,Acl = 0x1,Esco = 0x2,Unknown = 0xff,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum EncryptionEnabled {Off = 0x0,On = 0x1,BrEdrAesCcm = 0x2,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum Mode {Active = 0x0,Hold = 0x1,Sniff = 0x2,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum KeyType {Combination = 0x0,DebugCombination = 0x3,UnauthenticatedP192 = 0x4,AuthenticatedP192 = 0x5,Changed = 0x6,UnauthenticatedP256 = 0x7,AuthenticatedP256 = 0x8,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum ScoLinkType {Sco = 0x0,Esco = 0x2,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum ScoAirMode {UlawLog = 0x0,AlawLog = 0x1,Cvsd = 0x2,Transparent = 0x3,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum FlushablePacketType {AutomaticallyFlushableOnly = 0x0,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum AdvertisingEventType {AdvInd = 0x0,AdvDirectInd = 0x1,AdvScanInd = 0x2,AdvNonconnInd = 0x3,ScanResponse = 0x4,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum DirectAdvertisingAddressType {PublicDeviceAddress = 0x0,RandomDeviceAddress = 0x1,PublicIdentityAddress = 0x2,RandomIdentityAddress = 0x3,ControllerUnableToResolve = 0xfe,NoAddress = 0xff,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum DirectAdvertisingEventType {AdvDirectInd = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum DirectAddressType {RandomDeviceAddress = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum DataStatus {Complete = 0x0,Continuing = 0x1,Truncated = 0x2,Reserved = 0x3,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum ChannelSelectionAlgorithm {Algorithm1 = 0x0,Algorithm2 = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum PathLossZone {Low = 0x0,Mid = 0x1,High = 0x2,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum AdvtInfoPresent {AdvtInfoPresent = 0x0,NoAdvtInfoPresent = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum QualityReportId {MonitorMode = 0x1,ApproachLsto = 0x2,A2dpAudioChoppy = 0x3,ScoVoiceChoppy = 0x4,RootInflammation = 0x5,LmpLlMessageTrace = 0x11,BtSchedulingTrace = 0x12,ControllerDbgInfo = 0x13,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum BqrPacketType {TypeId = 0x1,TypeNull = 0x2,TypePoll = 0x3,TypeFhs = 0x4,TypeHv1 = 0x5,TypeHv2 = 0x6,TypeHv3 = 0x7,TypeDv = 0x8,TypeEv3 = 0x9,TypeEv4 = 0xa,TypeEv5 = 0xb,Type2ev3 = 0xc,Type2ev5 = 0xd,Type3ev3 = 0xe,Type3ev5 = 0xf,TypeDm1 = 0x10,TypeDh1 = 0x11,TypeDm3 = 0x12,TypeDh3 = 0x13,TypeDm5 = 0x14,TypeDh5 = 0x15,TypeAux1 = 0x16,Type2dh1 = 0x17,Type2dh3 = 0x18,Type2dh5 = 0x19,Type3dh1 = 0x1a,Type3dh3 = 0x1b,Type3dh5 = 0x1c,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum IsoPacketBoundaryFlag {FirstFragment = 0x0,ContinuationFragment = 0x1,CompleteSdu = 0x2,LastFragment = 0x3,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum TimeStampFlag {NotPresent = 0x0,Present = 0x1,}

#[derive(FromPrimitive, ToPrimitive, Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub enum IsoPacketStatusFlag {Valid = 0x0,PossiblyInvalid = 0x1,LostData = 0x2,}

#[derive(Debug, Clone)] pub struct GapData{pub data_type: GapDataType, pub data: Vec::<u8>, }
impl GapData{fn conforms(bytes: &[u8]) -> bool { true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 1 { return Err(Error::InvalidLengthError{    obj: "GapData".to_string(),    field: "data_size".to_string(),    wanted: 1,    got: bytes.len()});}let data_size = u8::from_le_bytes([bytes[0]]);if bytes.len() < 2 { return Err(Error::InvalidLengthError{    obj: "GapData".to_string(),    field: "data_type".to_string(),    wanted: 2,    got: bytes.len()});}let data_type = u8::from_le_bytes([bytes[1]]);let data_type = GapDataType::from_u8(data_type).unwrap();let want_ = 2 + (data_size as usize) - ((1*8) / 8);if bytes.len() < want_ { return Err(Error::InvalidLengthError{    obj: "GapData".to_string(),    field: "data".to_string(),    wanted: want_,    got: bytes.len()});}if ((data_size as usize) < ((1*8) / 8)) { return Err(Error::ImpossibleStructError);}let data: Vec::<u8> = bytes[2..(2 + data_size as usize) - ((1*8) / 8)].to_vec().chunks_exact(1).into_iter().map(|i| u8::from_le_bytes([i[0]])).collect();Ok(Self {data_type, data, })}
fn write_to(&self, buffer: &mut [u8]) {let data_bytes = self.data.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8);let data_bytes = data_bytes + (1*8) / 8;let data_size = u8::try_from(data_bytes).expect("payload size did not fit");buffer[0..1].copy_from_slice(&data_size.to_le_bytes()[0..1]);let data_type = self.data_type.to_u8().unwrap();buffer[1..2].copy_from_slice(&data_type.to_le_bytes()[0..1]);for (i, e) in self.data.iter().enumerate() {buffer[2+i..2+i+1].copy_from_slice(&e.to_le_bytes())}}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 2;let ret = ret + (self.data.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8));ret}}


#[derive(Debug, Clone)] pub struct Lap{pub lap: u8, pub fixed_scalar0: u16, }
impl Lap{fn conforms(bytes: &[u8]) -> bool {let fixed_scalar0 = u16::from_le_bytes([bytes[1],bytes[2]]);if fixed_scalar0 != 40587 { return false; }  true}pub fn parse(bytes: &[u8]) -> Result<Self> {let lap = u8::from_le_bytes([bytes[0]]);let lap = lap & 0x3f;if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "Lap".to_string(),    field: "fixed_scalar0".to_string(),    wanted: 3,    got: bytes.len()});}let fixed_scalar0 = u16::from_le_bytes([bytes[1],bytes[2]]);Ok(Self {lap, fixed_scalar0: 40587, })}
fn write_to(&self, buffer: &mut [u8]) {let lap = self.lap;let lap = lap & 0x3f;buffer[0..1].copy_from_slice(&lap.to_le_bytes()[0..1]);let fixed_scalar0: u16 = 40587;buffer[1..3].copy_from_slice(&fixed_scalar0.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}}


#[derive(Debug, Clone)] pub struct ScoCodingFormat{pub coding_format: ScoCodingFormatValues, pub company_id: u16, pub vendor_specific_codec_id: u16, }
impl ScoCodingFormat{fn conforms(bytes: &[u8]) -> bool { true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 1 { return Err(Error::InvalidLengthError{    obj: "ScoCodingFormat".to_string(),    field: "coding_format".to_string(),    wanted: 1,    got: bytes.len()});}let coding_format = u8::from_le_bytes([bytes[0]]);let coding_format = ScoCodingFormatValues::from_u8(coding_format).unwrap();if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "ScoCodingFormat".to_string(),    field: "company_id".to_string(),    wanted: 3,    got: bytes.len()});}let company_id = u16::from_le_bytes([bytes[1],bytes[2]]);if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ScoCodingFormat".to_string(),    field: "vendor_specific_codec_id".to_string(),    wanted: 5,    got: bytes.len()});}let vendor_specific_codec_id = u16::from_le_bytes([bytes[3],bytes[4]]);Ok(Self {coding_format, company_id, vendor_specific_codec_id, })}
fn write_to(&self, buffer: &mut [u8]) {let coding_format = self.coding_format.to_u8().unwrap();buffer[0..1].copy_from_slice(&coding_format.to_le_bytes()[0..1]);let company_id = self.company_id;buffer[1..3].copy_from_slice(&company_id.to_le_bytes()[0..2]);let vendor_specific_codec_id = self.vendor_specific_codec_id;buffer[3..5].copy_from_slice(&vendor_specific_codec_id.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 5;ret}}


#[derive(Debug, Clone)] pub struct KeyAndAddress{pub address: Address, pub link_key: [u8; 16], }
impl KeyAndAddress{fn conforms(bytes: &[u8]) -> bool { true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "KeyAndAddress".to_string(),    field: "address".to_string(),    wanted: 6,    got: bytes.len()});}let address = bytes[0..6].try_into().unwrap();if bytes.len() < 22 { return Err(Error::InvalidLengthError{    obj: "KeyAndAddress".to_string(),    field: "link_key".to_string(),    wanted: 22,    got: bytes.len()});}let link_key = bytes[6..22].try_into().unwrap();Ok(Self {address, link_key, })}
fn write_to(&self, buffer: &mut [u8]) {let address: [u8; 6] = self.address.into();buffer[0..6].copy_from_slice(&address);&buffer[6..22].copy_from_slice(&self.link_key);}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 22;ret}}


#[derive(Debug, Clone)] pub struct CompletedPackets{pub connection_handle: u16, pub host_num_of_completed_packets: u16, }
impl CompletedPackets{fn conforms(bytes: &[u8]) -> bool { true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 2 { return Err(Error::InvalidLengthError{    obj: "CompletedPackets".to_string(),    field: "connection_handle".to_string(),    wanted: 2,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[0],bytes[1]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "CompletedPackets".to_string(),    field: "host_num_of_completed_packets".to_string(),    wanted: 4,    got: bytes.len()});}let host_num_of_completed_packets = u16::from_le_bytes([bytes[2],bytes[3]]);Ok(Self {connection_handle, host_num_of_completed_packets, })}
fn write_to(&self, buffer: &mut [u8]) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[0..2].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let host_num_of_completed_packets = self.host_num_of_completed_packets;buffer[2..4].copy_from_slice(&host_num_of_completed_packets.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}}


#[derive(Debug, Clone)] pub struct LocalVersionInformation{pub hci_version: HciVersion, pub hci_revision: u16, pub lmp_version: LmpVersion, pub manufacturer_name: u16, pub lmp_subversion: u16, }
impl LocalVersionInformation{fn conforms(bytes: &[u8]) -> bool { true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 1 { return Err(Error::InvalidLengthError{    obj: "LocalVersionInformation".to_string(),    field: "hci_version".to_string(),    wanted: 1,    got: bytes.len()});}let hci_version = u8::from_le_bytes([bytes[0]]);let hci_version = HciVersion::from_u8(hci_version).unwrap();if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "LocalVersionInformation".to_string(),    field: "hci_revision".to_string(),    wanted: 3,    got: bytes.len()});}let hci_revision = u16::from_le_bytes([bytes[1],bytes[2]]);if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LocalVersionInformation".to_string(),    field: "lmp_version".to_string(),    wanted: 4,    got: bytes.len()});}let lmp_version = u8::from_le_bytes([bytes[3]]);let lmp_version = LmpVersion::from_u8(lmp_version).unwrap();if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LocalVersionInformation".to_string(),    field: "manufacturer_name".to_string(),    wanted: 6,    got: bytes.len()});}let manufacturer_name = u16::from_le_bytes([bytes[4],bytes[5]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LocalVersionInformation".to_string(),    field: "lmp_subversion".to_string(),    wanted: 8,    got: bytes.len()});}let lmp_subversion = u16::from_le_bytes([bytes[6],bytes[7]]);Ok(Self {hci_version, hci_revision, lmp_version, manufacturer_name, lmp_subversion, })}
fn write_to(&self, buffer: &mut [u8]) {let hci_version = self.hci_version.to_u8().unwrap();buffer[0..1].copy_from_slice(&hci_version.to_le_bytes()[0..1]);let hci_revision = self.hci_revision;buffer[1..3].copy_from_slice(&hci_revision.to_le_bytes()[0..2]);let lmp_version = self.lmp_version.to_u8().unwrap();buffer[3..4].copy_from_slice(&lmp_version.to_le_bytes()[0..1]);let manufacturer_name = self.manufacturer_name;buffer[4..6].copy_from_slice(&manufacturer_name.to_le_bytes()[0..2]);let lmp_subversion = self.lmp_subversion;buffer[6..8].copy_from_slice(&lmp_subversion.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 8;ret}}


#[derive(Debug, Clone)] pub struct CodecConfiguration{pub codec_id: u8, pub br_edr: u8, pub br_edr_sco_and_esco: u8, pub le_cis: u8, pub le_bis: u8, }
impl CodecConfiguration{fn conforms(bytes: &[u8]) -> bool { true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 1 { return Err(Error::InvalidLengthError{    obj: "CodecConfiguration".to_string(),    field: "codec_id".to_string(),    wanted: 1,    got: bytes.len()});}let codec_id = u8::from_le_bytes([bytes[0]]);let br_edr = u8::from_le_bytes([bytes[1]]);let br_edr = br_edr & 0x1;let br_edr_sco_and_esco = u8::from_le_bytes([bytes[1]]);let br_edr_sco_and_esco = br_edr_sco_and_esco >> 1;let br_edr_sco_and_esco = br_edr_sco_and_esco & 0x1;let le_cis = u8::from_le_bytes([bytes[1]]);let le_cis = le_cis >> 2;let le_cis = le_cis & 0x1;let le_bis = u8::from_le_bytes([bytes[1]]);let le_bis = le_bis >> 3;let le_bis = le_bis & 0x1;Ok(Self {codec_id, br_edr, br_edr_sco_and_esco, le_cis, le_bis, })}
fn write_to(&self, buffer: &mut [u8]) {let codec_id = self.codec_id;buffer[0..1].copy_from_slice(&codec_id.to_le_bytes()[0..1]);let br_edr = self.br_edr;let br_edr = br_edr & 0x1;buffer[1..2].copy_from_slice(&br_edr.to_le_bytes()[0..1]);let br_edr_sco_and_esco = self.br_edr_sco_and_esco;let br_edr_sco_and_esco = br_edr_sco_and_esco & 0x1;let br_edr_sco_and_esco = (br_edr_sco_and_esco << 1) | ((buffer[1] as u8) & 0x1);buffer[1..2].copy_from_slice(&br_edr_sco_and_esco.to_le_bytes()[0..1]);let le_cis = self.le_cis;let le_cis = le_cis & 0x1;let le_cis = (le_cis << 2) | ((buffer[1] as u8) & 0x3);buffer[1..2].copy_from_slice(&le_cis.to_le_bytes()[0..1]);let le_bis = self.le_bis;let le_bis = le_bis & 0x1;let le_bis = (le_bis << 3) | ((buffer[1] as u8) & 0x7);buffer[1..2].copy_from_slice(&le_bis.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}}


#[derive(Debug, Clone)] pub struct VendorCodecConfiguration{pub company_id: u16, pub codec_vendor_id: u16, pub br_edr: u8, pub br_edr_sco_and_esco: u8, pub le_cis: u8, pub le_bis: u8, }
impl VendorCodecConfiguration{fn conforms(bytes: &[u8]) -> bool { true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 2 { return Err(Error::InvalidLengthError{    obj: "VendorCodecConfiguration".to_string(),    field: "company_id".to_string(),    wanted: 2,    got: bytes.len()});}let company_id = u16::from_le_bytes([bytes[0],bytes[1]]);if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "VendorCodecConfiguration".to_string(),    field: "codec_vendor_id".to_string(),    wanted: 4,    got: bytes.len()});}let codec_vendor_id = u16::from_le_bytes([bytes[2],bytes[3]]);let br_edr = u8::from_le_bytes([bytes[4]]);let br_edr = br_edr & 0x1;let br_edr_sco_and_esco = u8::from_le_bytes([bytes[4]]);let br_edr_sco_and_esco = br_edr_sco_and_esco >> 1;let br_edr_sco_and_esco = br_edr_sco_and_esco & 0x1;let le_cis = u8::from_le_bytes([bytes[4]]);let le_cis = le_cis >> 2;let le_cis = le_cis & 0x1;let le_bis = u8::from_le_bytes([bytes[4]]);let le_bis = le_bis >> 3;let le_bis = le_bis & 0x1;Ok(Self {company_id, codec_vendor_id, br_edr, br_edr_sco_and_esco, le_cis, le_bis, })}
fn write_to(&self, buffer: &mut [u8]) {let company_id = self.company_id;buffer[0..2].copy_from_slice(&company_id.to_le_bytes()[0..2]);let codec_vendor_id = self.codec_vendor_id;buffer[2..4].copy_from_slice(&codec_vendor_id.to_le_bytes()[0..2]);let br_edr = self.br_edr;let br_edr = br_edr & 0x1;buffer[4..5].copy_from_slice(&br_edr.to_le_bytes()[0..1]);let br_edr_sco_and_esco = self.br_edr_sco_and_esco;let br_edr_sco_and_esco = br_edr_sco_and_esco & 0x1;let br_edr_sco_and_esco = (br_edr_sco_and_esco << 1) | ((buffer[4] as u8) & 0x1);buffer[4..5].copy_from_slice(&br_edr_sco_and_esco.to_le_bytes()[0..1]);let le_cis = self.le_cis;let le_cis = le_cis & 0x1;let le_cis = (le_cis << 2) | ((buffer[4] as u8) & 0x3);buffer[4..5].copy_from_slice(&le_cis.to_le_bytes()[0..1]);let le_bis = self.le_bis;let le_bis = le_bis & 0x1;let le_bis = (le_bis << 3) | ((buffer[4] as u8) & 0x7);buffer[4..5].copy_from_slice(&le_bis.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 5;ret}}


#[derive(Debug, Clone)] pub struct CodecCapability{pub capability: Vec::<u8>, }
impl CodecCapability{fn conforms(bytes: &[u8]) -> bool { true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 1 { return Err(Error::InvalidLengthError{    obj: "CodecCapability".to_string(),    field: "capability_size".to_string(),    wanted: 1,    got: bytes.len()});}let capability_size = u8::from_le_bytes([bytes[0]]);let want_ = 1 + (capability_size as usize);if bytes.len() < want_ { return Err(Error::InvalidLengthError{    obj: "CodecCapability".to_string(),    field: "capability".to_string(),    wanted: want_,    got: bytes.len()});}let capability: Vec::<u8> = bytes[1..(1 + capability_size as usize)].to_vec().chunks_exact(1).into_iter().map(|i| u8::from_le_bytes([i[0]])).collect();Ok(Self {capability, })}
fn write_to(&self, buffer: &mut [u8]) {let capability_bytes = self.capability.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8);let capability_size = u8::try_from(capability_bytes).expect("payload size did not fit");buffer[0..1].copy_from_slice(&capability_size.to_le_bytes()[0..1]);for (i, e) in self.capability.iter().enumerate() {buffer[1+i..1+i+1].copy_from_slice(&e.to_le_bytes())}}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 1;let ret = ret + (self.capability.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8));ret}}


#[derive(Debug, Clone)] pub struct LeBufferSize{pub le_data_packet_length: u16, pub total_num_le_packets: u8, }
impl LeBufferSize{fn conforms(bytes: &[u8]) -> bool { true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 2 { return Err(Error::InvalidLengthError{    obj: "LeBufferSize".to_string(),    field: "le_data_packet_length".to_string(),    wanted: 2,    got: bytes.len()});}let le_data_packet_length = u16::from_le_bytes([bytes[0],bytes[1]]);if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "LeBufferSize".to_string(),    field: "total_num_le_packets".to_string(),    wanted: 3,    got: bytes.len()});}let total_num_le_packets = u8::from_le_bytes([bytes[2]]);Ok(Self {le_data_packet_length, total_num_le_packets, })}
fn write_to(&self, buffer: &mut [u8]) {let le_data_packet_length = self.le_data_packet_length;buffer[0..2].copy_from_slice(&le_data_packet_length.to_le_bytes()[0..2]);let total_num_le_packets = self.total_num_le_packets;buffer[2..3].copy_from_slice(&total_num_le_packets.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}}


#[derive(Debug, Clone)] pub struct LeMaximumDataLength{pub supported_max_tx_octets: u16, pub supported_max_tx_time: u16, pub supported_max_rx_octets: u16, pub supported_max_rx_time: u16, }
impl LeMaximumDataLength{fn conforms(bytes: &[u8]) -> bool { true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 2 { return Err(Error::InvalidLengthError{    obj: "LeMaximumDataLength".to_string(),    field: "supported_max_tx_octets".to_string(),    wanted: 2,    got: bytes.len()});}let supported_max_tx_octets = u16::from_le_bytes([bytes[0],bytes[1]]);if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeMaximumDataLength".to_string(),    field: "supported_max_tx_time".to_string(),    wanted: 4,    got: bytes.len()});}let supported_max_tx_time = u16::from_le_bytes([bytes[2],bytes[3]]);if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeMaximumDataLength".to_string(),    field: "supported_max_rx_octets".to_string(),    wanted: 6,    got: bytes.len()});}let supported_max_rx_octets = u16::from_le_bytes([bytes[4],bytes[5]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeMaximumDataLength".to_string(),    field: "supported_max_rx_time".to_string(),    wanted: 8,    got: bytes.len()});}let supported_max_rx_time = u16::from_le_bytes([bytes[6],bytes[7]]);Ok(Self {supported_max_tx_octets, supported_max_tx_time, supported_max_rx_octets, supported_max_rx_time, })}
fn write_to(&self, buffer: &mut [u8]) {let supported_max_tx_octets = self.supported_max_tx_octets;buffer[0..2].copy_from_slice(&supported_max_tx_octets.to_le_bytes()[0..2]);let supported_max_tx_time = self.supported_max_tx_time;buffer[2..4].copy_from_slice(&supported_max_tx_time.to_le_bytes()[0..2]);let supported_max_rx_octets = self.supported_max_rx_octets;buffer[4..6].copy_from_slice(&supported_max_rx_octets.to_le_bytes()[0..2]);let supported_max_rx_time = self.supported_max_rx_time;buffer[6..8].copy_from_slice(&supported_max_rx_time.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 8;ret}}


#[derive(Debug, Clone)] pub struct EnabledSet{pub advertising_handle: u8, pub duration: u16, pub max_extended_advertising_events: u8, }
impl EnabledSet{fn conforms(bytes: &[u8]) -> bool { true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 1 { return Err(Error::InvalidLengthError{    obj: "EnabledSet".to_string(),    field: "advertising_handle".to_string(),    wanted: 1,    got: bytes.len()});}let advertising_handle = u8::from_le_bytes([bytes[0]]);if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "EnabledSet".to_string(),    field: "duration".to_string(),    wanted: 3,    got: bytes.len()});}let duration = u16::from_le_bytes([bytes[1],bytes[2]]);if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "EnabledSet".to_string(),    field: "max_extended_advertising_events".to_string(),    wanted: 4,    got: bytes.len()});}let max_extended_advertising_events = u8::from_le_bytes([bytes[3]]);Ok(Self {advertising_handle, duration, max_extended_advertising_events, })}
fn write_to(&self, buffer: &mut [u8]) {let advertising_handle = self.advertising_handle;buffer[0..1].copy_from_slice(&advertising_handle.to_le_bytes()[0..1]);let duration = self.duration;buffer[1..3].copy_from_slice(&duration.to_le_bytes()[0..2]);let max_extended_advertising_events = self.max_extended_advertising_events;buffer[3..4].copy_from_slice(&max_extended_advertising_events.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}}


#[derive(Debug, Clone)] pub struct DisabledSet{pub advertising_handle: u8, pub fixed_scalar7: u16, pub fixed_scalar8: u8, }
impl DisabledSet{fn conforms(bytes: &[u8]) -> bool {let fixed_scalar7 = u16::from_le_bytes([bytes[1],bytes[2]]);if fixed_scalar7 != 0 { return false; } let fixed_scalar8 = u8::from_le_bytes([bytes[3]]);if fixed_scalar8 != 0 { return false; }  true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 1 { return Err(Error::InvalidLengthError{    obj: "DisabledSet".to_string(),    field: "advertising_handle".to_string(),    wanted: 1,    got: bytes.len()});}let advertising_handle = u8::from_le_bytes([bytes[0]]);if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "DisabledSet".to_string(),    field: "fixed_scalar7".to_string(),    wanted: 3,    got: bytes.len()});}let fixed_scalar7 = u16::from_le_bytes([bytes[1],bytes[2]]);if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "DisabledSet".to_string(),    field: "fixed_scalar8".to_string(),    wanted: 4,    got: bytes.len()});}let fixed_scalar8 = u8::from_le_bytes([bytes[3]]);Ok(Self {advertising_handle, fixed_scalar7: 0, fixed_scalar8: 0, })}
fn write_to(&self, buffer: &mut [u8]) {let advertising_handle = self.advertising_handle;buffer[0..1].copy_from_slice(&advertising_handle.to_le_bytes()[0..1]);let fixed_scalar7: u16 = 0;buffer[1..3].copy_from_slice(&fixed_scalar7.to_le_bytes()[0..2]);let fixed_scalar8: u8 = 0;buffer[3..4].copy_from_slice(&fixed_scalar8.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}}


#[derive(Debug, Clone)] pub struct PhyScanParameters{pub le_scan_type: LeScanType, pub le_scan_interval: u16, pub le_scan_window: u16, }
impl PhyScanParameters{fn conforms(bytes: &[u8]) -> bool { true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 1 { return Err(Error::InvalidLengthError{    obj: "PhyScanParameters".to_string(),    field: "le_scan_type".to_string(),    wanted: 1,    got: bytes.len()});}let le_scan_type = u8::from_le_bytes([bytes[0]]);let le_scan_type = LeScanType::from_u8(le_scan_type).unwrap();if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "PhyScanParameters".to_string(),    field: "le_scan_interval".to_string(),    wanted: 3,    got: bytes.len()});}let le_scan_interval = u16::from_le_bytes([bytes[1],bytes[2]]);if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "PhyScanParameters".to_string(),    field: "le_scan_window".to_string(),    wanted: 5,    got: bytes.len()});}let le_scan_window = u16::from_le_bytes([bytes[3],bytes[4]]);Ok(Self {le_scan_type, le_scan_interval, le_scan_window, })}
fn write_to(&self, buffer: &mut [u8]) {let le_scan_type = self.le_scan_type.to_u8().unwrap();buffer[0..1].copy_from_slice(&le_scan_type.to_le_bytes()[0..1]);let le_scan_interval = self.le_scan_interval;buffer[1..3].copy_from_slice(&le_scan_interval.to_le_bytes()[0..2]);let le_scan_window = self.le_scan_window;buffer[3..5].copy_from_slice(&le_scan_window.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 5;ret}}


#[derive(Debug, Clone)] pub struct LeCreateConnPhyScanParameters{pub scan_interval: u16, pub scan_window: u16, pub conn_interval_min: u16, pub conn_interval_max: u16, pub conn_latency: u16, pub supervision_timeout: u16, pub min_ce_length: u16, pub max_ce_length: u16, }
impl LeCreateConnPhyScanParameters{fn conforms(bytes: &[u8]) -> bool { true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 2 { return Err(Error::InvalidLengthError{    obj: "LeCreateConnPhyScanParameters".to_string(),    field: "scan_interval".to_string(),    wanted: 2,    got: bytes.len()});}let scan_interval = u16::from_le_bytes([bytes[0],bytes[1]]);if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeCreateConnPhyScanParameters".to_string(),    field: "scan_window".to_string(),    wanted: 4,    got: bytes.len()});}let scan_window = u16::from_le_bytes([bytes[2],bytes[3]]);if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeCreateConnPhyScanParameters".to_string(),    field: "conn_interval_min".to_string(),    wanted: 6,    got: bytes.len()});}let conn_interval_min = u16::from_le_bytes([bytes[4],bytes[5]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeCreateConnPhyScanParameters".to_string(),    field: "conn_interval_max".to_string(),    wanted: 8,    got: bytes.len()});}let conn_interval_max = u16::from_le_bytes([bytes[6],bytes[7]]);if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeCreateConnPhyScanParameters".to_string(),    field: "conn_latency".to_string(),    wanted: 10,    got: bytes.len()});}let conn_latency = u16::from_le_bytes([bytes[8],bytes[9]]);if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "LeCreateConnPhyScanParameters".to_string(),    field: "supervision_timeout".to_string(),    wanted: 12,    got: bytes.len()});}let supervision_timeout = u16::from_le_bytes([bytes[10],bytes[11]]);if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "LeCreateConnPhyScanParameters".to_string(),    field: "min_ce_length".to_string(),    wanted: 14,    got: bytes.len()});}let min_ce_length = u16::from_le_bytes([bytes[12],bytes[13]]);if bytes.len() < 16 { return Err(Error::InvalidLengthError{    obj: "LeCreateConnPhyScanParameters".to_string(),    field: "max_ce_length".to_string(),    wanted: 16,    got: bytes.len()});}let max_ce_length = u16::from_le_bytes([bytes[14],bytes[15]]);Ok(Self {scan_interval, scan_window, conn_interval_min, conn_interval_max, conn_latency, supervision_timeout, min_ce_length, max_ce_length, })}
fn write_to(&self, buffer: &mut [u8]) {let scan_interval = self.scan_interval;buffer[0..2].copy_from_slice(&scan_interval.to_le_bytes()[0..2]);let scan_window = self.scan_window;buffer[2..4].copy_from_slice(&scan_window.to_le_bytes()[0..2]);let conn_interval_min = self.conn_interval_min;buffer[4..6].copy_from_slice(&conn_interval_min.to_le_bytes()[0..2]);let conn_interval_max = self.conn_interval_max;buffer[6..8].copy_from_slice(&conn_interval_max.to_le_bytes()[0..2]);let conn_latency = self.conn_latency;buffer[8..10].copy_from_slice(&conn_latency.to_le_bytes()[0..2]);let supervision_timeout = self.supervision_timeout;buffer[10..12].copy_from_slice(&supervision_timeout.to_le_bytes()[0..2]);let min_ce_length = self.min_ce_length;buffer[12..14].copy_from_slice(&min_ce_length.to_le_bytes()[0..2]);let max_ce_length = self.max_ce_length;buffer[14..16].copy_from_slice(&max_ce_length.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 16;ret}}


#[derive(Debug, Clone)] pub struct CisParametersConfig{pub cis_id: u8, pub max_sdu_m_to_s: u16, pub max_sdu_s_to_m: u16, pub phy_m_to_s: u8, pub phy_s_to_m: u8, pub rtn_m_to_s: u8, pub rtn_s_to_m: u8, }
impl CisParametersConfig{fn conforms(bytes: &[u8]) -> bool { true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 1 { return Err(Error::InvalidLengthError{    obj: "CisParametersConfig".to_string(),    field: "cis_id".to_string(),    wanted: 1,    got: bytes.len()});}let cis_id = u8::from_le_bytes([bytes[0]]);if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "CisParametersConfig".to_string(),    field: "max_sdu_m_to_s".to_string(),    wanted: 3,    got: bytes.len()});}let max_sdu_m_to_s = u16::from_le_bytes([bytes[1],bytes[2]]);let max_sdu_m_to_s = max_sdu_m_to_s & 0xfff;if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "CisParametersConfig".to_string(),    field: "max_sdu_s_to_m".to_string(),    wanted: 5,    got: bytes.len()});}let max_sdu_s_to_m = u16::from_le_bytes([bytes[3],bytes[4]]);let max_sdu_s_to_m = max_sdu_s_to_m & 0xfff;let phy_m_to_s = u8::from_le_bytes([bytes[5]]);let phy_m_to_s = phy_m_to_s & 0x7;let phy_s_to_m = u8::from_le_bytes([bytes[6]]);let phy_s_to_m = phy_s_to_m & 0x7;let rtn_m_to_s = u8::from_le_bytes([bytes[7]]);let rtn_m_to_s = rtn_m_to_s & 0xf;let rtn_s_to_m = u8::from_le_bytes([bytes[8]]);let rtn_s_to_m = rtn_s_to_m & 0xf;Ok(Self {cis_id, max_sdu_m_to_s, max_sdu_s_to_m, phy_m_to_s, phy_s_to_m, rtn_m_to_s, rtn_s_to_m, })}
fn write_to(&self, buffer: &mut [u8]) {let cis_id = self.cis_id;buffer[0..1].copy_from_slice(&cis_id.to_le_bytes()[0..1]);let max_sdu_m_to_s = self.max_sdu_m_to_s;let max_sdu_m_to_s = max_sdu_m_to_s & 0xfff;buffer[1..3].copy_from_slice(&max_sdu_m_to_s.to_le_bytes()[0..2]);let max_sdu_s_to_m = self.max_sdu_s_to_m;let max_sdu_s_to_m = max_sdu_s_to_m & 0xfff;buffer[3..5].copy_from_slice(&max_sdu_s_to_m.to_le_bytes()[0..2]);let phy_m_to_s = self.phy_m_to_s;let phy_m_to_s = phy_m_to_s & 0x7;buffer[5..6].copy_from_slice(&phy_m_to_s.to_le_bytes()[0..1]);let phy_s_to_m = self.phy_s_to_m;let phy_s_to_m = phy_s_to_m & 0x7;buffer[6..7].copy_from_slice(&phy_s_to_m.to_le_bytes()[0..1]);let rtn_m_to_s = self.rtn_m_to_s;let rtn_m_to_s = rtn_m_to_s & 0xf;buffer[7..8].copy_from_slice(&rtn_m_to_s.to_le_bytes()[0..1]);let rtn_s_to_m = self.rtn_s_to_m;let rtn_s_to_m = rtn_s_to_m & 0xf;buffer[8..9].copy_from_slice(&rtn_s_to_m.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 9;ret}}


#[derive(Debug, Clone)] pub struct LeCisParametersTestConfig{pub cis_id: u8, pub nse: u8, pub max_sdu_m_to_s: u16, pub max_sdu_s_to_m: u16, pub max_pdu_m_to_s: u16, pub max_pdu_s_to_m: u16, pub phy_m_to_s: u8, pub phy_s_to_m: u8, pub bn_m_to_s: u8, pub bn_s_to_m: u8, }
impl LeCisParametersTestConfig{fn conforms(bytes: &[u8]) -> bool { true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 1 { return Err(Error::InvalidLengthError{    obj: "LeCisParametersTestConfig".to_string(),    field: "cis_id".to_string(),    wanted: 1,    got: bytes.len()});}let cis_id = u8::from_le_bytes([bytes[0]]);if bytes.len() < 2 { return Err(Error::InvalidLengthError{    obj: "LeCisParametersTestConfig".to_string(),    field: "nse".to_string(),    wanted: 2,    got: bytes.len()});}let nse = u8::from_le_bytes([bytes[1]]);if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeCisParametersTestConfig".to_string(),    field: "max_sdu_m_to_s".to_string(),    wanted: 4,    got: bytes.len()});}let max_sdu_m_to_s = u16::from_le_bytes([bytes[2],bytes[3]]);if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeCisParametersTestConfig".to_string(),    field: "max_sdu_s_to_m".to_string(),    wanted: 6,    got: bytes.len()});}let max_sdu_s_to_m = u16::from_le_bytes([bytes[4],bytes[5]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeCisParametersTestConfig".to_string(),    field: "max_pdu_m_to_s".to_string(),    wanted: 8,    got: bytes.len()});}let max_pdu_m_to_s = u16::from_le_bytes([bytes[6],bytes[7]]);if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeCisParametersTestConfig".to_string(),    field: "max_pdu_s_to_m".to_string(),    wanted: 10,    got: bytes.len()});}let max_pdu_s_to_m = u16::from_le_bytes([bytes[8],bytes[9]]);if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "LeCisParametersTestConfig".to_string(),    field: "phy_m_to_s".to_string(),    wanted: 11,    got: bytes.len()});}let phy_m_to_s = u8::from_le_bytes([bytes[10]]);if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "LeCisParametersTestConfig".to_string(),    field: "phy_s_to_m".to_string(),    wanted: 12,    got: bytes.len()});}let phy_s_to_m = u8::from_le_bytes([bytes[11]]);if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "LeCisParametersTestConfig".to_string(),    field: "bn_m_to_s".to_string(),    wanted: 13,    got: bytes.len()});}let bn_m_to_s = u8::from_le_bytes([bytes[12]]);if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "LeCisParametersTestConfig".to_string(),    field: "bn_s_to_m".to_string(),    wanted: 14,    got: bytes.len()});}let bn_s_to_m = u8::from_le_bytes([bytes[13]]);Ok(Self {cis_id, nse, max_sdu_m_to_s, max_sdu_s_to_m, max_pdu_m_to_s, max_pdu_s_to_m, phy_m_to_s, phy_s_to_m, bn_m_to_s, bn_s_to_m, })}
fn write_to(&self, buffer: &mut [u8]) {let cis_id = self.cis_id;buffer[0..1].copy_from_slice(&cis_id.to_le_bytes()[0..1]);let nse = self.nse;buffer[1..2].copy_from_slice(&nse.to_le_bytes()[0..1]);let max_sdu_m_to_s = self.max_sdu_m_to_s;buffer[2..4].copy_from_slice(&max_sdu_m_to_s.to_le_bytes()[0..2]);let max_sdu_s_to_m = self.max_sdu_s_to_m;buffer[4..6].copy_from_slice(&max_sdu_s_to_m.to_le_bytes()[0..2]);let max_pdu_m_to_s = self.max_pdu_m_to_s;buffer[6..8].copy_from_slice(&max_pdu_m_to_s.to_le_bytes()[0..2]);let max_pdu_s_to_m = self.max_pdu_s_to_m;buffer[8..10].copy_from_slice(&max_pdu_s_to_m.to_le_bytes()[0..2]);let phy_m_to_s = self.phy_m_to_s;buffer[10..11].copy_from_slice(&phy_m_to_s.to_le_bytes()[0..1]);let phy_s_to_m = self.phy_s_to_m;buffer[11..12].copy_from_slice(&phy_s_to_m.to_le_bytes()[0..1]);let bn_m_to_s = self.bn_m_to_s;buffer[12..13].copy_from_slice(&bn_m_to_s.to_le_bytes()[0..1]);let bn_s_to_m = self.bn_s_to_m;buffer[13..14].copy_from_slice(&bn_s_to_m.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 14;ret}}


#[derive(Debug, Clone)] pub struct CreateCisConfig{pub cis_connection_handle: u16, pub acl_connection_handle: u16, }
impl CreateCisConfig{fn conforms(bytes: &[u8]) -> bool { true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 2 { return Err(Error::InvalidLengthError{    obj: "CreateCisConfig".to_string(),    field: "cis_connection_handle".to_string(),    wanted: 2,    got: bytes.len()});}let cis_connection_handle = u16::from_le_bytes([bytes[0],bytes[1]]);let cis_connection_handle = cis_connection_handle & 0xfff;if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "CreateCisConfig".to_string(),    field: "acl_connection_handle".to_string(),    wanted: 4,    got: bytes.len()});}let acl_connection_handle = u16::from_le_bytes([bytes[2],bytes[3]]);let acl_connection_handle = acl_connection_handle & 0xfff;Ok(Self {cis_connection_handle, acl_connection_handle, })}
fn write_to(&self, buffer: &mut [u8]) {let cis_connection_handle = self.cis_connection_handle;let cis_connection_handle = cis_connection_handle & 0xfff;buffer[0..2].copy_from_slice(&cis_connection_handle.to_le_bytes()[0..2]);let acl_connection_handle = self.acl_connection_handle;let acl_connection_handle = acl_connection_handle & 0xfff;buffer[2..4].copy_from_slice(&acl_connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}}


#[derive(Debug, Clone)] pub struct VendorCapabilities{pub is_supported: u8, pub max_advt_instances: u8, pub offloaded_resolution_of_private_address: u8, pub total_scan_results_storage: u16, pub max_irk_list_sz: u8, pub filtering_support: u8, pub max_filter: u8, pub activity_energy_info_support: u8, pub version_supported: u16, pub total_num_of_advt_tracked: u16, pub extended_scan_support: u8, pub debug_logging_supported: u8, pub le_address_generation_offloading_support: u8, pub a2dp_source_offload_capability_mask: u32, pub bluetooth_quality_report_support: u8, }
impl VendorCapabilities{fn conforms(bytes: &[u8]) -> bool { true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 1 { return Err(Error::InvalidLengthError{    obj: "VendorCapabilities".to_string(),    field: "is_supported".to_string(),    wanted: 1,    got: bytes.len()});}let is_supported = u8::from_le_bytes([bytes[0]]);if bytes.len() < 2 { return Err(Error::InvalidLengthError{    obj: "VendorCapabilities".to_string(),    field: "max_advt_instances".to_string(),    wanted: 2,    got: bytes.len()});}let max_advt_instances = u8::from_le_bytes([bytes[1]]);if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "VendorCapabilities".to_string(),    field: "offloaded_resolution_of_private_address".to_string(),    wanted: 3,    got: bytes.len()});}let offloaded_resolution_of_private_address = u8::from_le_bytes([bytes[2]]);if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "VendorCapabilities".to_string(),    field: "total_scan_results_storage".to_string(),    wanted: 5,    got: bytes.len()});}let total_scan_results_storage = u16::from_le_bytes([bytes[3],bytes[4]]);if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "VendorCapabilities".to_string(),    field: "max_irk_list_sz".to_string(),    wanted: 6,    got: bytes.len()});}let max_irk_list_sz = u8::from_le_bytes([bytes[5]]);if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "VendorCapabilities".to_string(),    field: "filtering_support".to_string(),    wanted: 7,    got: bytes.len()});}let filtering_support = u8::from_le_bytes([bytes[6]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "VendorCapabilities".to_string(),    field: "max_filter".to_string(),    wanted: 8,    got: bytes.len()});}let max_filter = u8::from_le_bytes([bytes[7]]);if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "VendorCapabilities".to_string(),    field: "activity_energy_info_support".to_string(),    wanted: 9,    got: bytes.len()});}let activity_energy_info_support = u8::from_le_bytes([bytes[8]]);if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "VendorCapabilities".to_string(),    field: "version_supported".to_string(),    wanted: 11,    got: bytes.len()});}let version_supported = u16::from_le_bytes([bytes[9],bytes[10]]);if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "VendorCapabilities".to_string(),    field: "total_num_of_advt_tracked".to_string(),    wanted: 13,    got: bytes.len()});}let total_num_of_advt_tracked = u16::from_le_bytes([bytes[11],bytes[12]]);if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "VendorCapabilities".to_string(),    field: "extended_scan_support".to_string(),    wanted: 14,    got: bytes.len()});}let extended_scan_support = u8::from_le_bytes([bytes[13]]);if bytes.len() < 15 { return Err(Error::InvalidLengthError{    obj: "VendorCapabilities".to_string(),    field: "debug_logging_supported".to_string(),    wanted: 15,    got: bytes.len()});}let debug_logging_supported = u8::from_le_bytes([bytes[14]]);if bytes.len() < 16 { return Err(Error::InvalidLengthError{    obj: "VendorCapabilities".to_string(),    field: "le_address_generation_offloading_support".to_string(),    wanted: 16,    got: bytes.len()});}let le_address_generation_offloading_support = u8::from_le_bytes([bytes[15]]);if bytes.len() < 20 { return Err(Error::InvalidLengthError{    obj: "VendorCapabilities".to_string(),    field: "a2dp_source_offload_capability_mask".to_string(),    wanted: 20,    got: bytes.len()});}let a2dp_source_offload_capability_mask = u32::from_le_bytes([bytes[16],bytes[17],bytes[18],bytes[19]]);if bytes.len() < 21 { return Err(Error::InvalidLengthError{    obj: "VendorCapabilities".to_string(),    field: "bluetooth_quality_report_support".to_string(),    wanted: 21,    got: bytes.len()});}let bluetooth_quality_report_support = u8::from_le_bytes([bytes[20]]);Ok(Self {is_supported, max_advt_instances, offloaded_resolution_of_private_address, total_scan_results_storage, max_irk_list_sz, filtering_support, max_filter, activity_energy_info_support, version_supported, total_num_of_advt_tracked, extended_scan_support, debug_logging_supported, le_address_generation_offloading_support, a2dp_source_offload_capability_mask, bluetooth_quality_report_support, })}
fn write_to(&self, buffer: &mut [u8]) {let is_supported = self.is_supported;buffer[0..1].copy_from_slice(&is_supported.to_le_bytes()[0..1]);let max_advt_instances = self.max_advt_instances;buffer[1..2].copy_from_slice(&max_advt_instances.to_le_bytes()[0..1]);let offloaded_resolution_of_private_address = self.offloaded_resolution_of_private_address;buffer[2..3].copy_from_slice(&offloaded_resolution_of_private_address.to_le_bytes()[0..1]);let total_scan_results_storage = self.total_scan_results_storage;buffer[3..5].copy_from_slice(&total_scan_results_storage.to_le_bytes()[0..2]);let max_irk_list_sz = self.max_irk_list_sz;buffer[5..6].copy_from_slice(&max_irk_list_sz.to_le_bytes()[0..1]);let filtering_support = self.filtering_support;buffer[6..7].copy_from_slice(&filtering_support.to_le_bytes()[0..1]);let max_filter = self.max_filter;buffer[7..8].copy_from_slice(&max_filter.to_le_bytes()[0..1]);let activity_energy_info_support = self.activity_energy_info_support;buffer[8..9].copy_from_slice(&activity_energy_info_support.to_le_bytes()[0..1]);let version_supported = self.version_supported;buffer[9..11].copy_from_slice(&version_supported.to_le_bytes()[0..2]);let total_num_of_advt_tracked = self.total_num_of_advt_tracked;buffer[11..13].copy_from_slice(&total_num_of_advt_tracked.to_le_bytes()[0..2]);let extended_scan_support = self.extended_scan_support;buffer[13..14].copy_from_slice(&extended_scan_support.to_le_bytes()[0..1]);let debug_logging_supported = self.debug_logging_supported;buffer[14..15].copy_from_slice(&debug_logging_supported.to_le_bytes()[0..1]);let le_address_generation_offloading_support = self.le_address_generation_offloading_support;buffer[15..16].copy_from_slice(&le_address_generation_offloading_support.to_le_bytes()[0..1]);let a2dp_source_offload_capability_mask = self.a2dp_source_offload_capability_mask;buffer[16..20].copy_from_slice(&a2dp_source_offload_capability_mask.to_le_bytes()[0..4]);let bluetooth_quality_report_support = self.bluetooth_quality_report_support;buffer[20..21].copy_from_slice(&bluetooth_quality_report_support.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 21;ret}}


#[derive(Debug, Clone)] pub struct BaseVendorCapabilities{pub max_advt_instances: u8, pub offloaded_resolution_of_private_address: u8, pub total_scan_results_storage: u16, pub max_irk_list_sz: u8, pub filtering_support: u8, pub max_filter: u8, pub activity_energy_info_support: u8, }
impl BaseVendorCapabilities{fn conforms(bytes: &[u8]) -> bool { true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 1 { return Err(Error::InvalidLengthError{    obj: "BaseVendorCapabilities".to_string(),    field: "max_advt_instances".to_string(),    wanted: 1,    got: bytes.len()});}let max_advt_instances = u8::from_le_bytes([bytes[0]]);if bytes.len() < 2 { return Err(Error::InvalidLengthError{    obj: "BaseVendorCapabilities".to_string(),    field: "offloaded_resolution_of_private_address".to_string(),    wanted: 2,    got: bytes.len()});}let offloaded_resolution_of_private_address = u8::from_le_bytes([bytes[1]]);if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "BaseVendorCapabilities".to_string(),    field: "total_scan_results_storage".to_string(),    wanted: 4,    got: bytes.len()});}let total_scan_results_storage = u16::from_le_bytes([bytes[2],bytes[3]]);if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "BaseVendorCapabilities".to_string(),    field: "max_irk_list_sz".to_string(),    wanted: 5,    got: bytes.len()});}let max_irk_list_sz = u8::from_le_bytes([bytes[4]]);if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "BaseVendorCapabilities".to_string(),    field: "filtering_support".to_string(),    wanted: 6,    got: bytes.len()});}let filtering_support = u8::from_le_bytes([bytes[5]]);if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "BaseVendorCapabilities".to_string(),    field: "max_filter".to_string(),    wanted: 7,    got: bytes.len()});}let max_filter = u8::from_le_bytes([bytes[6]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "BaseVendorCapabilities".to_string(),    field: "activity_energy_info_support".to_string(),    wanted: 8,    got: bytes.len()});}let activity_energy_info_support = u8::from_le_bytes([bytes[7]]);Ok(Self {max_advt_instances, offloaded_resolution_of_private_address, total_scan_results_storage, max_irk_list_sz, filtering_support, max_filter, activity_energy_info_support, })}
fn write_to(&self, buffer: &mut [u8]) {let max_advt_instances = self.max_advt_instances;buffer[0..1].copy_from_slice(&max_advt_instances.to_le_bytes()[0..1]);let offloaded_resolution_of_private_address = self.offloaded_resolution_of_private_address;buffer[1..2].copy_from_slice(&offloaded_resolution_of_private_address.to_le_bytes()[0..1]);let total_scan_results_storage = self.total_scan_results_storage;buffer[2..4].copy_from_slice(&total_scan_results_storage.to_le_bytes()[0..2]);let max_irk_list_sz = self.max_irk_list_sz;buffer[4..5].copy_from_slice(&max_irk_list_sz.to_le_bytes()[0..1]);let filtering_support = self.filtering_support;buffer[5..6].copy_from_slice(&filtering_support.to_le_bytes()[0..1]);let max_filter = self.max_filter;buffer[6..7].copy_from_slice(&max_filter.to_le_bytes()[0..1]);let activity_energy_info_support = self.activity_energy_info_support;buffer[7..8].copy_from_slice(&activity_energy_info_support.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 8;ret}}


#[derive(Debug, Clone)] pub struct TruncatedResult{pub bd_addr: Address, pub address_type: AddressType, pub tx_power: u8, pub rssi: u8, pub timestamp: u16, }
impl TruncatedResult{fn conforms(bytes: &[u8]) -> bool { true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "TruncatedResult".to_string(),    field: "bd_addr".to_string(),    wanted: 6,    got: bytes.len()});}let bd_addr = bytes[0..6].try_into().unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "TruncatedResult".to_string(),    field: "address_type".to_string(),    wanted: 7,    got: bytes.len()});}let address_type = u8::from_le_bytes([bytes[6]]);let address_type = AddressType::from_u8(address_type).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "TruncatedResult".to_string(),    field: "tx_power".to_string(),    wanted: 8,    got: bytes.len()});}let tx_power = u8::from_le_bytes([bytes[7]]);if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "TruncatedResult".to_string(),    field: "rssi".to_string(),    wanted: 9,    got: bytes.len()});}let rssi = u8::from_le_bytes([bytes[8]]);if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "TruncatedResult".to_string(),    field: "timestamp".to_string(),    wanted: 11,    got: bytes.len()});}let timestamp = u16::from_le_bytes([bytes[9],bytes[10]]);Ok(Self {bd_addr, address_type, tx_power, rssi, timestamp, })}
fn write_to(&self, buffer: &mut [u8]) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[0..6].copy_from_slice(&bd_addr);let address_type = self.address_type.to_u8().unwrap();buffer[6..7].copy_from_slice(&address_type.to_le_bytes()[0..1]);let tx_power = self.tx_power;buffer[7..8].copy_from_slice(&tx_power.to_le_bytes()[0..1]);let rssi = self.rssi;buffer[8..9].copy_from_slice(&rssi.to_le_bytes()[0..1]);let timestamp = self.timestamp;buffer[9..11].copy_from_slice(&timestamp.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 11;ret}}


#[derive(Debug, Clone)] pub struct FullResult{pub bd_addr: Address, pub address_type: AddressType, pub tx_power: u8, pub rssi: u8, pub timestamp: u16, pub adv_packet: Vec::<u8>, pub scan_response: Vec::<u8>, }
impl FullResult{fn conforms(bytes: &[u8]) -> bool { true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "FullResult".to_string(),    field: "bd_addr".to_string(),    wanted: 6,    got: bytes.len()});}let bd_addr = bytes[0..6].try_into().unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "FullResult".to_string(),    field: "address_type".to_string(),    wanted: 7,    got: bytes.len()});}let address_type = u8::from_le_bytes([bytes[6]]);let address_type = AddressType::from_u8(address_type).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "FullResult".to_string(),    field: "tx_power".to_string(),    wanted: 8,    got: bytes.len()});}let tx_power = u8::from_le_bytes([bytes[7]]);if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "FullResult".to_string(),    field: "rssi".to_string(),    wanted: 9,    got: bytes.len()});}let rssi = u8::from_le_bytes([bytes[8]]);if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "FullResult".to_string(),    field: "timestamp".to_string(),    wanted: 11,    got: bytes.len()});}let timestamp = u16::from_le_bytes([bytes[9],bytes[10]]);if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "FullResult".to_string(),    field: "adv_packet_size".to_string(),    wanted: 12,    got: bytes.len()});}let adv_packet_size = u8::from_le_bytes([bytes[11]]);let want_ = 12 + (adv_packet_size as usize);if bytes.len() < want_ { return Err(Error::InvalidLengthError{    obj: "FullResult".to_string(),    field: "adv_packet".to_string(),    wanted: want_,    got: bytes.len()});}let adv_packet: Vec::<u8> = bytes[12..(12 + adv_packet_size as usize)].to_vec().chunks_exact(1).into_iter().map(|i| u8::from_le_bytes([i[0]])).collect();if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "FullResult".to_string(),    field: "scan_response_size".to_string(),    wanted: 13,    got: bytes.len()});}let scan_response_size = u8::from_le_bytes([bytes[12]]);let want_ = 13 + (scan_response_size as usize);if bytes.len() < want_ { return Err(Error::InvalidLengthError{    obj: "FullResult".to_string(),    field: "scan_response".to_string(),    wanted: want_,    got: bytes.len()});}let scan_response: Vec::<u8> = bytes[13..(13 + scan_response_size as usize)].to_vec().chunks_exact(1).into_iter().map(|i| u8::from_le_bytes([i[0]])).collect();Ok(Self {bd_addr, address_type, tx_power, rssi, timestamp, adv_packet, scan_response, })}
fn write_to(&self, buffer: &mut [u8]) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[0..6].copy_from_slice(&bd_addr);let address_type = self.address_type.to_u8().unwrap();buffer[6..7].copy_from_slice(&address_type.to_le_bytes()[0..1]);let tx_power = self.tx_power;buffer[7..8].copy_from_slice(&tx_power.to_le_bytes()[0..1]);let rssi = self.rssi;buffer[8..9].copy_from_slice(&rssi.to_le_bytes()[0..1]);let timestamp = self.timestamp;buffer[9..11].copy_from_slice(&timestamp.to_le_bytes()[0..2]);let adv_packet_bytes = self.adv_packet.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8);let adv_packet_size = u8::try_from(adv_packet_bytes).expect("payload size did not fit");buffer[11..12].copy_from_slice(&adv_packet_size.to_le_bytes()[0..1]);for (i, e) in self.adv_packet.iter().enumerate() {buffer[12+i..12+i+1].copy_from_slice(&e.to_le_bytes())}let scan_response_bytes = self.scan_response.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8);let scan_response_size = u8::try_from(scan_response_bytes).expect("payload size did not fit");buffer[12..13].copy_from_slice(&scan_response_size.to_le_bytes()[0..1]);for (i, e) in self.scan_response.iter().enumerate() {buffer[13+i..13+i+1].copy_from_slice(&e.to_le_bytes())}}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 12;let ret = ret + (self.adv_packet.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8));let ret = ret + 1;let ret = ret + (self.scan_response.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8));ret}}


#[derive(Debug, Clone)] pub struct InquiryResult{pub bd_addr: Address, pub page_scan_repetition_mode: PageScanRepetitionMode, pub class_of_device: ClassOfDevice, pub clock_offset: u16, }
impl InquiryResult{fn conforms(bytes: &[u8]) -> bool { true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "InquiryResult".to_string(),    field: "bd_addr".to_string(),    wanted: 6,    got: bytes.len()});}let bd_addr = bytes[0..6].try_into().unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "InquiryResult".to_string(),    field: "page_scan_repetition_mode".to_string(),    wanted: 7,    got: bytes.len()});}let page_scan_repetition_mode = u8::from_le_bytes([bytes[6]]);let page_scan_repetition_mode = PageScanRepetitionMode::from_u8(page_scan_repetition_mode).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "InquiryResult".to_string(),    field: "class_of_device".to_string(),    wanted: 12,    got: bytes.len()});}let class_of_device = bytes[9..12].try_into().unwrap();if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "InquiryResult".to_string(),    field: "clock_offset".to_string(),    wanted: 14,    got: bytes.len()});}let clock_offset = u16::from_le_bytes([bytes[12],bytes[13]]);let clock_offset = clock_offset & 0x7fff;Ok(Self {bd_addr, page_scan_repetition_mode, class_of_device, clock_offset, })}
fn write_to(&self, buffer: &mut [u8]) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[0..6].copy_from_slice(&bd_addr);let page_scan_repetition_mode = self.page_scan_repetition_mode.to_u8().unwrap();buffer[6..7].copy_from_slice(&page_scan_repetition_mode.to_le_bytes()[0..1]);let class_of_device: [u8; 3] = self.class_of_device.into();buffer[9..12].copy_from_slice(&class_of_device);let clock_offset = self.clock_offset;let clock_offset = clock_offset & 0x7fff;buffer[12..14].copy_from_slice(&clock_offset.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 14;ret}}


#[derive(Debug, Clone)] pub struct ZeroKeyAndAddress{pub address: Address, pub fixed_scalar11: u64, pub fixed_scalar12: u64, }
impl ZeroKeyAndAddress{fn conforms(bytes: &[u8]) -> bool {let fixed_scalar11 = u64::from_le_bytes([bytes[6],bytes[7],bytes[8],bytes[9],bytes[10],bytes[11],bytes[12],bytes[13]]);if fixed_scalar11 != 0 { return false; } let fixed_scalar12 = u64::from_le_bytes([bytes[14],bytes[15],bytes[16],bytes[17],bytes[18],bytes[19],bytes[20],bytes[21]]);if fixed_scalar12 != 0 { return false; }  true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ZeroKeyAndAddress".to_string(),    field: "address".to_string(),    wanted: 6,    got: bytes.len()});}let address = bytes[0..6].try_into().unwrap();if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "ZeroKeyAndAddress".to_string(),    field: "fixed_scalar11".to_string(),    wanted: 14,    got: bytes.len()});}let fixed_scalar11 = u64::from_le_bytes([bytes[6],bytes[7],bytes[8],bytes[9],bytes[10],bytes[11],bytes[12],bytes[13]]);if bytes.len() < 22 { return Err(Error::InvalidLengthError{    obj: "ZeroKeyAndAddress".to_string(),    field: "fixed_scalar12".to_string(),    wanted: 22,    got: bytes.len()});}let fixed_scalar12 = u64::from_le_bytes([bytes[14],bytes[15],bytes[16],bytes[17],bytes[18],bytes[19],bytes[20],bytes[21]]);Ok(Self {address, fixed_scalar11: 0, fixed_scalar12: 0, })}
fn write_to(&self, buffer: &mut [u8]) {let address: [u8; 6] = self.address.into();buffer[0..6].copy_from_slice(&address);let fixed_scalar11: u64 = 0;buffer[6..14].copy_from_slice(&fixed_scalar11.to_le_bytes()[0..8]);let fixed_scalar12: u64 = 0;buffer[14..22].copy_from_slice(&fixed_scalar12.to_le_bytes()[0..8]);}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 22;ret}}


#[derive(Debug, Clone)] pub struct InquiryResultWithRssi{pub address: Address, pub page_scan_repetition_mode: PageScanRepetitionMode, pub class_of_device: ClassOfDevice, pub clock_offset: u16, pub rssi: u8, }
impl InquiryResultWithRssi{fn conforms(bytes: &[u8]) -> bool { true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "InquiryResultWithRssi".to_string(),    field: "address".to_string(),    wanted: 6,    got: bytes.len()});}let address = bytes[0..6].try_into().unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "InquiryResultWithRssi".to_string(),    field: "page_scan_repetition_mode".to_string(),    wanted: 7,    got: bytes.len()});}let page_scan_repetition_mode = u8::from_le_bytes([bytes[6]]);let page_scan_repetition_mode = PageScanRepetitionMode::from_u8(page_scan_repetition_mode).unwrap();if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "InquiryResultWithRssi".to_string(),    field: "class_of_device".to_string(),    wanted: 11,    got: bytes.len()});}let class_of_device = bytes[8..11].try_into().unwrap();if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "InquiryResultWithRssi".to_string(),    field: "clock_offset".to_string(),    wanted: 13,    got: bytes.len()});}let clock_offset = u16::from_le_bytes([bytes[11],bytes[12]]);let clock_offset = clock_offset & 0x7fff;if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "InquiryResultWithRssi".to_string(),    field: "rssi".to_string(),    wanted: 14,    got: bytes.len()});}let rssi = u8::from_le_bytes([bytes[13]]);Ok(Self {address, page_scan_repetition_mode, class_of_device, clock_offset, rssi, })}
fn write_to(&self, buffer: &mut [u8]) {let address: [u8; 6] = self.address.into();buffer[0..6].copy_from_slice(&address);let page_scan_repetition_mode = self.page_scan_repetition_mode.to_u8().unwrap();buffer[6..7].copy_from_slice(&page_scan_repetition_mode.to_le_bytes()[0..1]);let class_of_device: [u8; 3] = self.class_of_device.into();buffer[8..11].copy_from_slice(&class_of_device);let clock_offset = self.clock_offset;let clock_offset = clock_offset & 0x7fff;buffer[11..13].copy_from_slice(&clock_offset.to_le_bytes()[0..2]);let rssi = self.rssi;buffer[13..14].copy_from_slice(&rssi.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 14;ret}}


#[derive(Debug, Clone)] pub struct LeAdvertisingReport{pub event_type: AdvertisingEventType, pub address_type: AddressType, pub address: Address, pub advertising_data: Vec::<GapData>, pub rssi: u8, }
impl LeAdvertisingReport{fn conforms(bytes: &[u8]) -> bool { true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 1 { return Err(Error::InvalidLengthError{    obj: "LeAdvertisingReport".to_string(),    field: "event_type".to_string(),    wanted: 1,    got: bytes.len()});}let event_type = u8::from_le_bytes([bytes[0]]);let event_type = AdvertisingEventType::from_u8(event_type).unwrap();if bytes.len() < 2 { return Err(Error::InvalidLengthError{    obj: "LeAdvertisingReport".to_string(),    field: "address_type".to_string(),    wanted: 2,    got: bytes.len()});}let address_type = u8::from_le_bytes([bytes[1]]);let address_type = AddressType::from_u8(address_type).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeAdvertisingReport".to_string(),    field: "address".to_string(),    wanted: 8,    got: bytes.len()});}let address = bytes[2..8].try_into().unwrap();if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeAdvertisingReport".to_string(),    field: "advertising_data_size".to_string(),    wanted: 9,    got: bytes.len()});}let advertising_data_size = u8::from_le_bytes([bytes[8]]);let mut advertising_data: Vec::<GapData> = Vec::new();let mut parsable_ = &bytes[9..9 + (advertising_data_size as usize)];while parsable_.len() > 0 { match GapData::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];advertising_data.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeAdvertisingReport".to_string(),    field: "rssi".to_string(),    wanted: 10,    got: bytes.len()});}let rssi = u8::from_le_bytes([bytes[9]]);Ok(Self {event_type, address_type, address, advertising_data, rssi, })}
fn write_to(&self, buffer: &mut [u8]) {let event_type = self.event_type.to_u8().unwrap();buffer[0..1].copy_from_slice(&event_type.to_le_bytes()[0..1]);let address_type = self.address_type.to_u8().unwrap();buffer[1..2].copy_from_slice(&address_type.to_le_bytes()[0..1]);let address: [u8; 6] = self.address.into();buffer[2..8].copy_from_slice(&address);let advertising_data_bytes = self.advertising_data.iter().fold(0, |acc, x| acc + x.get_total_size());let advertising_data_size = u8::try_from(advertising_data_bytes).expect("payload size did not fit");buffer[8..9].copy_from_slice(&advertising_data_size.to_le_bytes()[0..1]);let mut vec_buffer_ = &mut buffer[9..];for e_ in &self.advertising_data { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}let rssi = self.rssi;buffer[9..10].copy_from_slice(&rssi.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 9;let ret = ret + self.advertising_data.iter().fold(0, |acc, x| acc + x.get_total_size());let ret = ret + 1;ret}}


#[derive(Debug, Clone)] pub struct LeDirectedAdvertisingReport{pub event_type: DirectAdvertisingEventType, pub address_type: DirectAdvertisingAddressType, pub address: Address, pub direct_address_type: DirectAddressType, pub direct_address: Address, pub rssi: u8, }
impl LeDirectedAdvertisingReport{fn conforms(bytes: &[u8]) -> bool { true}pub fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 1 { return Err(Error::InvalidLengthError{    obj: "LeDirectedAdvertisingReport".to_string(),    field: "event_type".to_string(),    wanted: 1,    got: bytes.len()});}let event_type = u8::from_le_bytes([bytes[0]]);let event_type = DirectAdvertisingEventType::from_u8(event_type).unwrap();if bytes.len() < 2 { return Err(Error::InvalidLengthError{    obj: "LeDirectedAdvertisingReport".to_string(),    field: "address_type".to_string(),    wanted: 2,    got: bytes.len()});}let address_type = u8::from_le_bytes([bytes[1]]);let address_type = DirectAdvertisingAddressType::from_u8(address_type).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeDirectedAdvertisingReport".to_string(),    field: "address".to_string(),    wanted: 8,    got: bytes.len()});}let address = bytes[2..8].try_into().unwrap();if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeDirectedAdvertisingReport".to_string(),    field: "direct_address_type".to_string(),    wanted: 9,    got: bytes.len()});}let direct_address_type = u8::from_le_bytes([bytes[8]]);let direct_address_type = DirectAddressType::from_u8(direct_address_type).unwrap();if bytes.len() < 15 { return Err(Error::InvalidLengthError{    obj: "LeDirectedAdvertisingReport".to_string(),    field: "direct_address".to_string(),    wanted: 15,    got: bytes.len()});}let direct_address = bytes[9..15].try_into().unwrap();if bytes.len() < 16 { return Err(Error::InvalidLengthError{    obj: "LeDirectedAdvertisingReport".to_string(),    field: "rssi".to_string(),    wanted: 16,    got: bytes.len()});}let rssi = u8::from_le_bytes([bytes[15]]);Ok(Self {event_type, address_type, address, direct_address_type, direct_address, rssi, })}
fn write_to(&self, buffer: &mut [u8]) {let event_type = self.event_type.to_u8().unwrap();buffer[0..1].copy_from_slice(&event_type.to_le_bytes()[0..1]);let address_type = self.address_type.to_u8().unwrap();buffer[1..2].copy_from_slice(&address_type.to_le_bytes()[0..1]);let address: [u8; 6] = self.address.into();buffer[2..8].copy_from_slice(&address);let direct_address_type = self.direct_address_type.to_u8().unwrap();buffer[8..9].copy_from_slice(&direct_address_type.to_le_bytes()[0..1]);let direct_address: [u8; 6] = self.direct_address.into();buffer[9..15].copy_from_slice(&direct_address);let rssi = self.rssi;buffer[15..16].copy_from_slice(&rssi.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 16;ret}}


#[derive(Debug, Clone)] pub struct LeExtendedAdvertisingReport{pub connectable: u8, pub scannable: u8, pub directed: u8, pub scan_response: u8, pub legacy: u8, pub data_status: DataStatus, pub address_type: DirectAdvertisingAddressType, pub address: Address, pub primary_phy: PrimaryPhyType, pub secondary_phy: SecondaryPhyType, pub advertising_sid: u8, pub tx_power: u8, pub rssi: u8, pub periodic_advertising_interval: u16, pub direct_address_type: DirectAdvertisingAddressType, pub direct_address: Address, pub advertising_data: Vec::<u8>, }
impl LeExtendedAdvertisingReport{fn conforms(bytes: &[u8]) -> bool { true}pub fn parse(bytes: &[u8]) -> Result<Self> {let connectable = u8::from_le_bytes([bytes[0]]);let connectable = connectable & 0x1;let scannable = u8::from_le_bytes([bytes[0]]);let scannable = scannable >> 1;let scannable = scannable & 0x1;let directed = u8::from_le_bytes([bytes[0]]);let directed = directed >> 2;let directed = directed & 0x1;let scan_response = u8::from_le_bytes([bytes[0]]);let scan_response = scan_response >> 3;let scan_response = scan_response & 0x1;let legacy = u8::from_le_bytes([bytes[0]]);let legacy = legacy >> 4;let legacy = legacy & 0x1;let data_status = u8::from_le_bytes([bytes[0]]);let data_status = data_status >> 5;let data_status = data_status & 0x3;let data_status = DataStatus::from_u8(data_status).unwrap();if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "LeExtendedAdvertisingReport".to_string(),    field: "address_type".to_string(),    wanted: 3,    got: bytes.len()});}let address_type = u8::from_le_bytes([bytes[2]]);let address_type = DirectAdvertisingAddressType::from_u8(address_type).unwrap();if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeExtendedAdvertisingReport".to_string(),    field: "address".to_string(),    wanted: 9,    got: bytes.len()});}let address = bytes[3..9].try_into().unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeExtendedAdvertisingReport".to_string(),    field: "primary_phy".to_string(),    wanted: 10,    got: bytes.len()});}let primary_phy = u8::from_le_bytes([bytes[9]]);let primary_phy = PrimaryPhyType::from_u8(primary_phy).unwrap();if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "LeExtendedAdvertisingReport".to_string(),    field: "secondary_phy".to_string(),    wanted: 11,    got: bytes.len()});}let secondary_phy = u8::from_le_bytes([bytes[10]]);let secondary_phy = SecondaryPhyType::from_u8(secondary_phy).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "LeExtendedAdvertisingReport".to_string(),    field: "advertising_sid".to_string(),    wanted: 12,    got: bytes.len()});}let advertising_sid = u8::from_le_bytes([bytes[11]]);if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "LeExtendedAdvertisingReport".to_string(),    field: "tx_power".to_string(),    wanted: 13,    got: bytes.len()});}let tx_power = u8::from_le_bytes([bytes[12]]);if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "LeExtendedAdvertisingReport".to_string(),    field: "rssi".to_string(),    wanted: 14,    got: bytes.len()});}let rssi = u8::from_le_bytes([bytes[13]]);if bytes.len() < 16 { return Err(Error::InvalidLengthError{    obj: "LeExtendedAdvertisingReport".to_string(),    field: "periodic_advertising_interval".to_string(),    wanted: 16,    got: bytes.len()});}let periodic_advertising_interval = u16::from_le_bytes([bytes[14],bytes[15]]);if bytes.len() < 17 { return Err(Error::InvalidLengthError{    obj: "LeExtendedAdvertisingReport".to_string(),    field: "direct_address_type".to_string(),    wanted: 17,    got: bytes.len()});}let direct_address_type = u8::from_le_bytes([bytes[16]]);let direct_address_type = DirectAdvertisingAddressType::from_u8(direct_address_type).unwrap();if bytes.len() < 23 { return Err(Error::InvalidLengthError{    obj: "LeExtendedAdvertisingReport".to_string(),    field: "direct_address".to_string(),    wanted: 23,    got: bytes.len()});}let direct_address = bytes[17..23].try_into().unwrap();if bytes.len() < 24 { return Err(Error::InvalidLengthError{    obj: "LeExtendedAdvertisingReport".to_string(),    field: "advertising_data_size".to_string(),    wanted: 24,    got: bytes.len()});}let advertising_data_size = u8::from_le_bytes([bytes[23]]);let want_ = 24 + (advertising_data_size as usize);if bytes.len() < want_ { return Err(Error::InvalidLengthError{    obj: "LeExtendedAdvertisingReport".to_string(),    field: "advertising_data".to_string(),    wanted: want_,    got: bytes.len()});}let advertising_data: Vec::<u8> = bytes[24..(24 + advertising_data_size as usize)].to_vec().chunks_exact(1).into_iter().map(|i| u8::from_le_bytes([i[0]])).collect();Ok(Self {connectable, scannable, directed, scan_response, legacy, data_status, address_type, address, primary_phy, secondary_phy, advertising_sid, tx_power, rssi, periodic_advertising_interval, direct_address_type, direct_address, advertising_data, })}
fn write_to(&self, buffer: &mut [u8]) {let connectable = self.connectable;let connectable = connectable & 0x1;buffer[0..1].copy_from_slice(&connectable.to_le_bytes()[0..1]);let scannable = self.scannable;let scannable = scannable & 0x1;let scannable = (scannable << 1) | ((buffer[0] as u8) & 0x1);buffer[0..1].copy_from_slice(&scannable.to_le_bytes()[0..1]);let directed = self.directed;let directed = directed & 0x1;let directed = (directed << 2) | ((buffer[0] as u8) & 0x3);buffer[0..1].copy_from_slice(&directed.to_le_bytes()[0..1]);let scan_response = self.scan_response;let scan_response = scan_response & 0x1;let scan_response = (scan_response << 3) | ((buffer[0] as u8) & 0x7);buffer[0..1].copy_from_slice(&scan_response.to_le_bytes()[0..1]);let legacy = self.legacy;let legacy = legacy & 0x1;let legacy = (legacy << 4) | ((buffer[0] as u8) & 0xf);buffer[0..1].copy_from_slice(&legacy.to_le_bytes()[0..1]);let data_status = self.data_status.to_u8().unwrap();let data_status = data_status & 0x3;let data_status = (data_status << 5) | ((buffer[0] as u8) & 0x1f);buffer[0..1].copy_from_slice(&data_status.to_le_bytes()[0..1]);let address_type = self.address_type.to_u8().unwrap();buffer[2..3].copy_from_slice(&address_type.to_le_bytes()[0..1]);let address: [u8; 6] = self.address.into();buffer[3..9].copy_from_slice(&address);let primary_phy = self.primary_phy.to_u8().unwrap();buffer[9..10].copy_from_slice(&primary_phy.to_le_bytes()[0..1]);let secondary_phy = self.secondary_phy.to_u8().unwrap();buffer[10..11].copy_from_slice(&secondary_phy.to_le_bytes()[0..1]);let advertising_sid = self.advertising_sid;buffer[11..12].copy_from_slice(&advertising_sid.to_le_bytes()[0..1]);let tx_power = self.tx_power;buffer[12..13].copy_from_slice(&tx_power.to_le_bytes()[0..1]);let rssi = self.rssi;buffer[13..14].copy_from_slice(&rssi.to_le_bytes()[0..1]);let periodic_advertising_interval = self.periodic_advertising_interval;buffer[14..16].copy_from_slice(&periodic_advertising_interval.to_le_bytes()[0..2]);let direct_address_type = self.direct_address_type.to_u8().unwrap();buffer[16..17].copy_from_slice(&direct_address_type.to_le_bytes()[0..1]);let direct_address: [u8; 6] = self.direct_address.into();buffer[17..23].copy_from_slice(&direct_address);let advertising_data_bytes = self.advertising_data.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8);let advertising_data_size = u8::try_from(advertising_data_bytes).expect("payload size did not fit");buffer[23..24].copy_from_slice(&advertising_data_size.to_le_bytes()[0..1]);for (i, e) in self.advertising_data.iter().enumerate() {buffer[24+i..24+i+1].copy_from_slice(&e.to_le_bytes())}}
fn get_total_size(&self) -> usize {let ret = 0;let ret = ret + 24;let ret = ret + (self.advertising_data.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8));ret}}


#[derive(Debug)] enum AclDataChild {Payload(Bytes),None,}
impl AclDataChild {fn get_total_size(&self) -> usize {match self {AclDataChild::Payload(p) => p.len(),AclDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum AclChild {Payload(Bytes),None,}
#[derive(Debug)] struct AclData {handle: u16, packet_boundary_flag: PacketBoundaryFlag, broadcast_flag: BroadcastFlag, child: AclDataChild,}
#[derive(Debug, Clone)] pub struct AclPacket {acl: Arc<AclData>,}
#[derive(Debug)] pub struct AclBuilder {pub handle: u16, pub packet_boundary_flag: PacketBoundaryFlag, pub broadcast_flag: BroadcastFlag, pub payload: Option<Bytes>,}
impl AclData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 2 { return Err(Error::InvalidLengthError{    obj: "Acl".to_string(),    field: "handle".to_string(),    wanted: 2,    got: bytes.len()});}let handle = u16::from_le_bytes([bytes[0],bytes[1]]);let handle = handle & 0xfff;let packet_boundary_flag = u8::from_le_bytes([bytes[1]]);let packet_boundary_flag = packet_boundary_flag >> 4;let packet_boundary_flag = packet_boundary_flag & 0x3;let packet_boundary_flag = PacketBoundaryFlag::from_u8(packet_boundary_flag).unwrap();let broadcast_flag = u8::from_le_bytes([bytes[1]]);let broadcast_flag = broadcast_flag >> 6;let broadcast_flag = broadcast_flag & 0x3;let broadcast_flag = BroadcastFlag::from_u8(broadcast_flag).unwrap();if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "Acl".to_string(),    field: "payload_size".to_string(),    wanted: 4,    got: bytes.len()});}let payload_size = u16::from_le_bytes([bytes[2],bytes[3]]);let payload: Vec::<u8> = bytes[4..(4 + payload_size as usize)].into();let child = if payload.len() > 0 {AclDataChild::Payload(Bytes::from(payload))} else {AclDataChild::None};Ok(Self {handle, packet_boundary_flag, broadcast_flag, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let handle = self.handle;let handle = handle & 0xfff;buffer[0..2].copy_from_slice(&handle.to_le_bytes()[0..2]);let packet_boundary_flag = self.packet_boundary_flag.to_u8().unwrap();let packet_boundary_flag = packet_boundary_flag & 0x3;let packet_boundary_flag = (packet_boundary_flag << 4) | ((buffer[1] as u8) & 0xf);buffer[1..2].copy_from_slice(&packet_boundary_flag.to_le_bytes()[0..1]);let broadcast_flag = self.broadcast_flag.to_u8().unwrap();let broadcast_flag = broadcast_flag & 0x3;let broadcast_flag = (broadcast_flag << 6) | ((buffer[1] as u8) & 0x3f);buffer[1..2].copy_from_slice(&broadcast_flag.to_le_bytes()[0..1]);let payload_size = u16::try_from(self.child.get_total_size()).expect("payload size did not fit");buffer[2..4].copy_from_slice(&payload_size.to_le_bytes()[0..2]);match &self.child {AclDataChild::Payload(p) => buffer[4..].copy_from_slice(&p[..]),AclDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl Packet for AclPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.acl.get_total_size(), 0); self.acl.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl AclPacket {pub fn parse(bytes: &[u8]) -> Result<Self> { Ok(Self::new(Arc::new(AclData::parse(bytes)?)))} pub fn specialize(&self) -> AclChild { match &self.acl.child {AclDataChild::Payload(p) => AclChild::Payload(p.clone()),AclDataChild::None => AclChild::None,}} fn new(root: Arc<AclData>) -> Self {let acl = root;Self {acl,}}pub fn get_handle(&self) -> u16{ self.acl.as_ref().handle}
pub fn get_packet_boundary_flag(&self) -> PacketBoundaryFlag{ self.acl.as_ref().packet_boundary_flag}
pub fn get_broadcast_flag(&self) -> BroadcastFlag{ self.acl.as_ref().broadcast_flag}
}
impl AclBuilder {pub fn build(self) -> AclPacket {let acl= Arc::new(AclData {handle: self.handle, packet_boundary_flag: self.packet_boundary_flag, broadcast_flag: self.broadcast_flag, child: match self.payload { None => AclDataChild::None,Some(bytes) => AclDataChild::Payload(bytes),},});AclPacket::new(acl)}
}


#[derive(Debug)] struct ScoData {handle: u16, packet_status_flag: PacketStatusFlag, data: Vec::<u8>, }
#[derive(Debug, Clone)] pub struct ScoPacket {sco: Arc<ScoData>,}
#[derive(Debug)] pub struct ScoBuilder {pub handle: u16, pub packet_status_flag: PacketStatusFlag, pub data: Vec::<u8>, }
impl ScoData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 2 { return Err(Error::InvalidLengthError{    obj: "Sco".to_string(),    field: "handle".to_string(),    wanted: 2,    got: bytes.len()});}let handle = u16::from_le_bytes([bytes[0],bytes[1]]);let handle = handle & 0xfff;let packet_status_flag = u8::from_le_bytes([bytes[1]]);let packet_status_flag = packet_status_flag >> 4;let packet_status_flag = packet_status_flag & 0x3;let packet_status_flag = PacketStatusFlag::from_u8(packet_status_flag).unwrap();if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "Sco".to_string(),    field: "data_size".to_string(),    wanted: 3,    got: bytes.len()});}let data_size = u8::from_le_bytes([bytes[2]]);let want_ = 3 + (data_size as usize);if bytes.len() < want_ { return Err(Error::InvalidLengthError{    obj: "Sco".to_string(),    field: "data".to_string(),    wanted: want_,    got: bytes.len()});}let data: Vec::<u8> = bytes[3..(3 + data_size as usize)].to_vec().chunks_exact(1).into_iter().map(|i| u8::from_le_bytes([i[0]])).collect();Ok(Self {handle, packet_status_flag, data, })
}
fn write_to(&self, buffer: &mut BytesMut) {let handle = self.handle;let handle = handle & 0xfff;buffer[0..2].copy_from_slice(&handle.to_le_bytes()[0..2]);let packet_status_flag = self.packet_status_flag.to_u8().unwrap();let packet_status_flag = packet_status_flag & 0x3;let packet_status_flag = (packet_status_flag << 4) | ((buffer[1] as u8) & 0xf);buffer[1..2].copy_from_slice(&packet_status_flag.to_le_bytes()[0..1]);let data_bytes = self.data.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8);let data_size = u8::try_from(data_bytes).expect("payload size did not fit");buffer[2..3].copy_from_slice(&data_size.to_le_bytes()[0..1]);for (i, e) in self.data.iter().enumerate() {buffer[3+i..3+i+1].copy_from_slice(&e.to_le_bytes())}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;let ret = ret + (self.data.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8));ret}
}
impl Packet for ScoPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.sco.get_total_size(), 0); self.sco.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ScoPacket {pub fn parse(bytes: &[u8]) -> Result<Self> { Ok(Self::new(Arc::new(ScoData::parse(bytes)?)))} fn new(root: Arc<ScoData>) -> Self {let sco = root;Self {sco,}}pub fn get_handle(&self) -> u16{ self.sco.as_ref().handle}
pub fn get_packet_status_flag(&self) -> PacketStatusFlag{ self.sco.as_ref().packet_status_flag}
pub fn get_data(&self) -> &Vec::<u8>{ &self.sco.as_ref().data}
}
impl ScoBuilder {pub fn build(self) -> ScoPacket {let sco= Arc::new(ScoData {handle: self.handle, packet_status_flag: self.packet_status_flag, data: self.data, });ScoPacket::new(sco)}
}


#[derive(Debug)] enum CommandDataChild {DiscoveryCommand(Arc<DiscoveryCommandData>),AclCommand(Arc<AclCommandData>),SecurityCommand(Arc<SecurityCommandData>),LeAdvertisingCommand(Arc<LeAdvertisingCommandData>),LeScanningCommand(Arc<LeScanningCommandData>),LeSecurityCommand(Arc<LeSecurityCommandData>),LeIsoCommand(Arc<LeIsoCommandData>),VendorCommand(Arc<VendorCommandData>),SetEventMask(Arc<SetEventMaskData>),Reset(Arc<ResetData>),SetEventFilter(Arc<SetEventFilterData>),ReadPinType(Arc<ReadPinTypeData>),WritePinType(Arc<WritePinTypeData>),WriteLocalName(Arc<WriteLocalNameData>),ReadLocalName(Arc<ReadLocalNameData>),ReadAuthenticationEnable(Arc<ReadAuthenticationEnableData>),ReadVoiceSetting(Arc<ReadVoiceSettingData>),WriteVoiceSetting(Arc<WriteVoiceSettingData>),ReadNumBroadcastRetransmits(Arc<ReadNumBroadcastRetransmitsData>),WriteNumBroadcastRetransmits(Arc<WriteNumBroadcastRetransmitsData>),ReadHoldModeActivity(Arc<ReadHoldModeActivityData>),WriteHoldModeActivity(Arc<WriteHoldModeActivityData>),ReadSynchronousFlowControlEnable(Arc<ReadSynchronousFlowControlEnableData>),WriteSynchronousFlowControlEnable(Arc<WriteSynchronousFlowControlEnableData>),SetControllerToHostFlowControl(Arc<SetControllerToHostFlowControlData>),HostBufferSize(Arc<HostBufferSizeData>),HostNumCompletedPackets(Arc<HostNumCompletedPacketsData>),SetAfhHostChannelClassification(Arc<SetAfhHostChannelClassificationData>),ReadAfhChannelAssessmentMode(Arc<ReadAfhChannelAssessmentModeData>),WriteAfhChannelAssessmentMode(Arc<WriteAfhChannelAssessmentModeData>),ReadExtendedInquiryResponse(Arc<ReadExtendedInquiryResponseData>),WriteExtendedInquiryResponse(Arc<WriteExtendedInquiryResponseData>),ReadLeHostSupport(Arc<ReadLeHostSupportData>),WriteLeHostSupport(Arc<WriteLeHostSupportData>),ReadSecureConnectionsHostSupport(Arc<ReadSecureConnectionsHostSupportData>),SetEcosystemBaseInterval(Arc<SetEcosystemBaseIntervalData>),ConfigureDataPath(Arc<ConfigureDataPathData>),ReadLocalVersionInformation(Arc<ReadLocalVersionInformationData>),ReadLocalSupportedCommands(Arc<ReadLocalSupportedCommandsData>),ReadLocalSupportedFeatures(Arc<ReadLocalSupportedFeaturesData>),ReadLocalExtendedFeatures(Arc<ReadLocalExtendedFeaturesData>),ReadBufferSize(Arc<ReadBufferSizeData>),ReadBdAddr(Arc<ReadBdAddrData>),ReadDataBlockSize(Arc<ReadDataBlockSizeData>),ReadLocalSupportedCodecsV1(Arc<ReadLocalSupportedCodecsV1Data>),ReadLocalSupportedCodecsV2(Arc<ReadLocalSupportedCodecsV2Data>),ReadLocalSupportedCodecCapabilities(Arc<ReadLocalSupportedCodecCapabilitiesData>),ReadLocalSupportedControllerDelay(Arc<ReadLocalSupportedControllerDelayData>),ReadLoopbackMode(Arc<ReadLoopbackModeData>),WriteLoopbackMode(Arc<WriteLoopbackModeData>),EnableDeviceUnderTestMode(Arc<EnableDeviceUnderTestModeData>),WriteSecureConnectionsTestMode(Arc<WriteSecureConnectionsTestModeData>),LeSetEventMask(Arc<LeSetEventMaskData>),LeReadBufferSizeV1(Arc<LeReadBufferSizeV1Data>),LeReadLocalSupportedFeatures(Arc<LeReadLocalSupportedFeaturesData>),LeReadConnectListSize(Arc<LeReadConnectListSizeData>),LeReadSupportedStates(Arc<LeReadSupportedStatesData>),LeReceiverTest(Arc<LeReceiverTestData>),LeTransmitterTest(Arc<LeTransmitterTestData>),LeTestEnd(Arc<LeTestEndData>),LeReadResolvingListSize(Arc<LeReadResolvingListSizeData>),LeReadMaximumDataLength(Arc<LeReadMaximumDataLengthData>),LeEnhancedReceiverTest(Arc<LeEnhancedReceiverTestData>),LeEnhancedTransmitterTest(Arc<LeEnhancedTransmitterTestData>),LeReadMaximumAdvertisingDataLength(Arc<LeReadMaximumAdvertisingDataLengthData>),LeReadNumberOfSupportedAdvertisingSets(Arc<LeReadNumberOfSupportedAdvertisingSetsData>),LeReadPeriodicAdvertiserListSize(Arc<LeReadPeriodicAdvertiserListSizeData>),LeSetPeriodicAdvertisingReceiveEnable(Arc<LeSetPeriodicAdvertisingReceiveEnableData>),LePeriodicAdvertisingSyncTransfer(Arc<LePeriodicAdvertisingSyncTransferData>),LePeriodicAdvertisingSetInfoTransfer(Arc<LePeriodicAdvertisingSetInfoTransferData>),LeSetPeriodicAdvertisingSyncTransferParameters(Arc<LeSetPeriodicAdvertisingSyncTransferParametersData>),LeSetDefaultPeriodicAdvertisingSyncTransferParameters(Arc<LeSetDefaultPeriodicAdvertisingSyncTransferParametersData>),LeModifySleepClockAccuracy(Arc<LeModifySleepClockAccuracyData>),LeReadBufferSizeV2(Arc<LeReadBufferSizeV2Data>),LeRequestPeerSca(Arc<LeRequestPeerScaData>),LeSetHostFeature(Arc<LeSetHostFeatureData>),LeEnhancedReadTransmitPowerLevel(Arc<LeEnhancedReadTransmitPowerLevelData>),LeReadRemoteTransmitPowerLevel(Arc<LeReadRemoteTransmitPowerLevelData>),LeSetPathLossReportingParameters(Arc<LeSetPathLossReportingParametersData>),LeSetPathLossReportingEnable(Arc<LeSetPathLossReportingEnableData>),LeSetTransmitPowerReportingEnable(Arc<LeSetTransmitPowerReportingEnableData>),EnhancedFlush(Arc<EnhancedFlushData>),Payload(Bytes),None,}
impl CommandDataChild {fn get_total_size(&self) -> usize {match self {CommandDataChild::DiscoveryCommand(value) => value.get_total_size(),CommandDataChild::AclCommand(value) => value.get_total_size(),CommandDataChild::SecurityCommand(value) => value.get_total_size(),CommandDataChild::LeAdvertisingCommand(value) => value.get_total_size(),CommandDataChild::LeScanningCommand(value) => value.get_total_size(),CommandDataChild::LeSecurityCommand(value) => value.get_total_size(),CommandDataChild::LeIsoCommand(value) => value.get_total_size(),CommandDataChild::VendorCommand(value) => value.get_total_size(),CommandDataChild::SetEventMask(value) => value.get_total_size(),CommandDataChild::Reset(value) => value.get_total_size(),CommandDataChild::SetEventFilter(value) => value.get_total_size(),CommandDataChild::ReadPinType(value) => value.get_total_size(),CommandDataChild::WritePinType(value) => value.get_total_size(),CommandDataChild::WriteLocalName(value) => value.get_total_size(),CommandDataChild::ReadLocalName(value) => value.get_total_size(),CommandDataChild::ReadAuthenticationEnable(value) => value.get_total_size(),CommandDataChild::ReadVoiceSetting(value) => value.get_total_size(),CommandDataChild::WriteVoiceSetting(value) => value.get_total_size(),CommandDataChild::ReadNumBroadcastRetransmits(value) => value.get_total_size(),CommandDataChild::WriteNumBroadcastRetransmits(value) => value.get_total_size(),CommandDataChild::ReadHoldModeActivity(value) => value.get_total_size(),CommandDataChild::WriteHoldModeActivity(value) => value.get_total_size(),CommandDataChild::ReadSynchronousFlowControlEnable(value) => value.get_total_size(),CommandDataChild::WriteSynchronousFlowControlEnable(value) => value.get_total_size(),CommandDataChild::SetControllerToHostFlowControl(value) => value.get_total_size(),CommandDataChild::HostBufferSize(value) => value.get_total_size(),CommandDataChild::HostNumCompletedPackets(value) => value.get_total_size(),CommandDataChild::SetAfhHostChannelClassification(value) => value.get_total_size(),CommandDataChild::ReadAfhChannelAssessmentMode(value) => value.get_total_size(),CommandDataChild::WriteAfhChannelAssessmentMode(value) => value.get_total_size(),CommandDataChild::ReadExtendedInquiryResponse(value) => value.get_total_size(),CommandDataChild::WriteExtendedInquiryResponse(value) => value.get_total_size(),CommandDataChild::ReadLeHostSupport(value) => value.get_total_size(),CommandDataChild::WriteLeHostSupport(value) => value.get_total_size(),CommandDataChild::ReadSecureConnectionsHostSupport(value) => value.get_total_size(),CommandDataChild::SetEcosystemBaseInterval(value) => value.get_total_size(),CommandDataChild::ConfigureDataPath(value) => value.get_total_size(),CommandDataChild::ReadLocalVersionInformation(value) => value.get_total_size(),CommandDataChild::ReadLocalSupportedCommands(value) => value.get_total_size(),CommandDataChild::ReadLocalSupportedFeatures(value) => value.get_total_size(),CommandDataChild::ReadLocalExtendedFeatures(value) => value.get_total_size(),CommandDataChild::ReadBufferSize(value) => value.get_total_size(),CommandDataChild::ReadBdAddr(value) => value.get_total_size(),CommandDataChild::ReadDataBlockSize(value) => value.get_total_size(),CommandDataChild::ReadLocalSupportedCodecsV1(value) => value.get_total_size(),CommandDataChild::ReadLocalSupportedCodecsV2(value) => value.get_total_size(),CommandDataChild::ReadLocalSupportedCodecCapabilities(value) => value.get_total_size(),CommandDataChild::ReadLocalSupportedControllerDelay(value) => value.get_total_size(),CommandDataChild::ReadLoopbackMode(value) => value.get_total_size(),CommandDataChild::WriteLoopbackMode(value) => value.get_total_size(),CommandDataChild::EnableDeviceUnderTestMode(value) => value.get_total_size(),CommandDataChild::WriteSecureConnectionsTestMode(value) => value.get_total_size(),CommandDataChild::LeSetEventMask(value) => value.get_total_size(),CommandDataChild::LeReadBufferSizeV1(value) => value.get_total_size(),CommandDataChild::LeReadLocalSupportedFeatures(value) => value.get_total_size(),CommandDataChild::LeReadConnectListSize(value) => value.get_total_size(),CommandDataChild::LeReadSupportedStates(value) => value.get_total_size(),CommandDataChild::LeReceiverTest(value) => value.get_total_size(),CommandDataChild::LeTransmitterTest(value) => value.get_total_size(),CommandDataChild::LeTestEnd(value) => value.get_total_size(),CommandDataChild::LeReadResolvingListSize(value) => value.get_total_size(),CommandDataChild::LeReadMaximumDataLength(value) => value.get_total_size(),CommandDataChild::LeEnhancedReceiverTest(value) => value.get_total_size(),CommandDataChild::LeEnhancedTransmitterTest(value) => value.get_total_size(),CommandDataChild::LeReadMaximumAdvertisingDataLength(value) => value.get_total_size(),CommandDataChild::LeReadNumberOfSupportedAdvertisingSets(value) => value.get_total_size(),CommandDataChild::LeReadPeriodicAdvertiserListSize(value) => value.get_total_size(),CommandDataChild::LeSetPeriodicAdvertisingReceiveEnable(value) => value.get_total_size(),CommandDataChild::LePeriodicAdvertisingSyncTransfer(value) => value.get_total_size(),CommandDataChild::LePeriodicAdvertisingSetInfoTransfer(value) => value.get_total_size(),CommandDataChild::LeSetPeriodicAdvertisingSyncTransferParameters(value) => value.get_total_size(),CommandDataChild::LeSetDefaultPeriodicAdvertisingSyncTransferParameters(value) => value.get_total_size(),CommandDataChild::LeModifySleepClockAccuracy(value) => value.get_total_size(),CommandDataChild::LeReadBufferSizeV2(value) => value.get_total_size(),CommandDataChild::LeRequestPeerSca(value) => value.get_total_size(),CommandDataChild::LeSetHostFeature(value) => value.get_total_size(),CommandDataChild::LeEnhancedReadTransmitPowerLevel(value) => value.get_total_size(),CommandDataChild::LeReadRemoteTransmitPowerLevel(value) => value.get_total_size(),CommandDataChild::LeSetPathLossReportingParameters(value) => value.get_total_size(),CommandDataChild::LeSetPathLossReportingEnable(value) => value.get_total_size(),CommandDataChild::LeSetTransmitPowerReportingEnable(value) => value.get_total_size(),CommandDataChild::EnhancedFlush(value) => value.get_total_size(),CommandDataChild::Payload(p) => p.len(),CommandDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum CommandChild {DiscoveryCommand(DiscoveryCommandPacket),AclCommand(AclCommandPacket),SecurityCommand(SecurityCommandPacket),LeAdvertisingCommand(LeAdvertisingCommandPacket),LeScanningCommand(LeScanningCommandPacket),LeSecurityCommand(LeSecurityCommandPacket),LeIsoCommand(LeIsoCommandPacket),VendorCommand(VendorCommandPacket),SetEventMask(SetEventMaskPacket),Reset(ResetPacket),SetEventFilter(SetEventFilterPacket),ReadPinType(ReadPinTypePacket),WritePinType(WritePinTypePacket),WriteLocalName(WriteLocalNamePacket),ReadLocalName(ReadLocalNamePacket),ReadAuthenticationEnable(ReadAuthenticationEnablePacket),ReadVoiceSetting(ReadVoiceSettingPacket),WriteVoiceSetting(WriteVoiceSettingPacket),ReadNumBroadcastRetransmits(ReadNumBroadcastRetransmitsPacket),WriteNumBroadcastRetransmits(WriteNumBroadcastRetransmitsPacket),ReadHoldModeActivity(ReadHoldModeActivityPacket),WriteHoldModeActivity(WriteHoldModeActivityPacket),ReadSynchronousFlowControlEnable(ReadSynchronousFlowControlEnablePacket),WriteSynchronousFlowControlEnable(WriteSynchronousFlowControlEnablePacket),SetControllerToHostFlowControl(SetControllerToHostFlowControlPacket),HostBufferSize(HostBufferSizePacket),HostNumCompletedPackets(HostNumCompletedPacketsPacket),SetAfhHostChannelClassification(SetAfhHostChannelClassificationPacket),ReadAfhChannelAssessmentMode(ReadAfhChannelAssessmentModePacket),WriteAfhChannelAssessmentMode(WriteAfhChannelAssessmentModePacket),ReadExtendedInquiryResponse(ReadExtendedInquiryResponsePacket),WriteExtendedInquiryResponse(WriteExtendedInquiryResponsePacket),ReadLeHostSupport(ReadLeHostSupportPacket),WriteLeHostSupport(WriteLeHostSupportPacket),ReadSecureConnectionsHostSupport(ReadSecureConnectionsHostSupportPacket),SetEcosystemBaseInterval(SetEcosystemBaseIntervalPacket),ConfigureDataPath(ConfigureDataPathPacket),ReadLocalVersionInformation(ReadLocalVersionInformationPacket),ReadLocalSupportedCommands(ReadLocalSupportedCommandsPacket),ReadLocalSupportedFeatures(ReadLocalSupportedFeaturesPacket),ReadLocalExtendedFeatures(ReadLocalExtendedFeaturesPacket),ReadBufferSize(ReadBufferSizePacket),ReadBdAddr(ReadBdAddrPacket),ReadDataBlockSize(ReadDataBlockSizePacket),ReadLocalSupportedCodecsV1(ReadLocalSupportedCodecsV1Packet),ReadLocalSupportedCodecsV2(ReadLocalSupportedCodecsV2Packet),ReadLocalSupportedCodecCapabilities(ReadLocalSupportedCodecCapabilitiesPacket),ReadLocalSupportedControllerDelay(ReadLocalSupportedControllerDelayPacket),ReadLoopbackMode(ReadLoopbackModePacket),WriteLoopbackMode(WriteLoopbackModePacket),EnableDeviceUnderTestMode(EnableDeviceUnderTestModePacket),WriteSecureConnectionsTestMode(WriteSecureConnectionsTestModePacket),LeSetEventMask(LeSetEventMaskPacket),LeReadBufferSizeV1(LeReadBufferSizeV1Packet),LeReadLocalSupportedFeatures(LeReadLocalSupportedFeaturesPacket),LeReadConnectListSize(LeReadConnectListSizePacket),LeReadSupportedStates(LeReadSupportedStatesPacket),LeReceiverTest(LeReceiverTestPacket),LeTransmitterTest(LeTransmitterTestPacket),LeTestEnd(LeTestEndPacket),LeReadResolvingListSize(LeReadResolvingListSizePacket),LeReadMaximumDataLength(LeReadMaximumDataLengthPacket),LeEnhancedReceiverTest(LeEnhancedReceiverTestPacket),LeEnhancedTransmitterTest(LeEnhancedTransmitterTestPacket),LeReadMaximumAdvertisingDataLength(LeReadMaximumAdvertisingDataLengthPacket),LeReadNumberOfSupportedAdvertisingSets(LeReadNumberOfSupportedAdvertisingSetsPacket),LeReadPeriodicAdvertiserListSize(LeReadPeriodicAdvertiserListSizePacket),LeSetPeriodicAdvertisingReceiveEnable(LeSetPeriodicAdvertisingReceiveEnablePacket),LePeriodicAdvertisingSyncTransfer(LePeriodicAdvertisingSyncTransferPacket),LePeriodicAdvertisingSetInfoTransfer(LePeriodicAdvertisingSetInfoTransferPacket),LeSetPeriodicAdvertisingSyncTransferParameters(LeSetPeriodicAdvertisingSyncTransferParametersPacket),LeSetDefaultPeriodicAdvertisingSyncTransferParameters(LeSetDefaultPeriodicAdvertisingSyncTransferParametersPacket),LeModifySleepClockAccuracy(LeModifySleepClockAccuracyPacket),LeReadBufferSizeV2(LeReadBufferSizeV2Packet),LeRequestPeerSca(LeRequestPeerScaPacket),LeSetHostFeature(LeSetHostFeaturePacket),LeEnhancedReadTransmitPowerLevel(LeEnhancedReadTransmitPowerLevelPacket),LeReadRemoteTransmitPowerLevel(LeReadRemoteTransmitPowerLevelPacket),LeSetPathLossReportingParameters(LeSetPathLossReportingParametersPacket),LeSetPathLossReportingEnable(LeSetPathLossReportingEnablePacket),LeSetTransmitPowerReportingEnable(LeSetTransmitPowerReportingEnablePacket),EnhancedFlush(EnhancedFlushPacket),Payload(Bytes),None,}
#[derive(Debug)] struct CommandData {op_code: OpCode, child: CommandDataChild,}
#[derive(Debug, Clone)] pub struct CommandPacket {command: Arc<CommandData>,}
#[derive(Debug)] pub struct CommandBuilder {pub op_code: OpCode, pub payload: Option<Bytes>,}
impl CommandData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 2 { return Err(Error::InvalidLengthError{    obj: "Command".to_string(),    field: "op_code".to_string(),    wanted: 2,    got: bytes.len()});}let op_code = u16::from_le_bytes([bytes[0],bytes[1]]);let op_code = OpCode::from_u16(op_code).unwrap();if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "Command".to_string(),    field: "payload_size".to_string(),    wanted: 3,    got: bytes.len()});}let payload_size = u8::from_le_bytes([bytes[2]]);let payload: Vec::<u8> = bytes[3..(3 + payload_size as usize)].into();let child = match op_code {OpCode::Inquiry if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::Inquiry)?))}
OpCode::InquiryCancel if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::InquiryCancel)?))}
OpCode::PeriodicInquiryMode if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::PeriodicInquiryMode)?))}
OpCode::ExitPeriodicInquiryMode if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::ExitPeriodicInquiryMode)?))}
OpCode::CreateConnection if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::CreateConnection)?))}
OpCode::Disconnect if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::Disconnect)?))}
OpCode::CreateConnectionCancel if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::CreateConnectionCancel)?))}
OpCode::AcceptConnectionRequest if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::AcceptConnectionRequest)?))}
OpCode::RejectConnectionRequest if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::RejectConnectionRequest)?))}
OpCode::LinkKeyRequestReply if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::LinkKeyRequestReply)?))}
OpCode::LinkKeyRequestNegativeReply if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::LinkKeyRequestNegativeReply)?))}
OpCode::PinCodeRequestReply if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::PinCodeRequestReply)?))}
OpCode::PinCodeRequestNegativeReply if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::PinCodeRequestNegativeReply)?))}
OpCode::ChangeConnectionPacketType if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::ChangeConnectionPacketType)?))}
OpCode::AuthenticationRequested if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::AuthenticationRequested)?))}
OpCode::SetConnectionEncryption if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::SetConnectionEncryption)?))}
OpCode::ChangeConnectionLinkKey if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::ChangeConnectionLinkKey)?))}
OpCode::CentralLinkKey if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::CentralLinkKey)?))}
OpCode::RemoteNameRequest if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::RemoteNameRequest)?))}
OpCode::RemoteNameRequestCancel if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::RemoteNameRequestCancel)?))}
OpCode::ReadRemoteSupportedFeatures if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::ReadRemoteSupportedFeatures)?))}
OpCode::ReadRemoteExtendedFeatures if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::ReadRemoteExtendedFeatures)?))}
OpCode::ReadRemoteVersionInformation if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::ReadRemoteVersionInformation)?))}
OpCode::ReadClockOffset if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::ReadClockOffset)?))}
OpCode::ReadLmpHandle if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::ReadLmpHandle)?))}
OpCode::SetupSynchronousConnection if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::SetupSynchronousConnection)?))}
OpCode::AcceptSynchronousConnection if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::AcceptSynchronousConnection)?))}
OpCode::RejectSynchronousConnection if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::RejectSynchronousConnection)?))}
OpCode::IoCapabilityRequestReply if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::IoCapabilityRequestReply)?))}
OpCode::UserConfirmationRequestReply if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::UserConfirmationRequestReply)?))}
OpCode::UserConfirmationRequestNegativeReply if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::UserConfirmationRequestNegativeReply)?))}
OpCode::UserPasskeyRequestReply if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::UserPasskeyRequestReply)?))}
OpCode::UserPasskeyRequestNegativeReply if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::UserPasskeyRequestNegativeReply)?))}
OpCode::RemoteOobDataRequestReply if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::RemoteOobDataRequestReply)?))}
OpCode::RemoteOobDataRequestNegativeReply if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::RemoteOobDataRequestNegativeReply)?))}
OpCode::IoCapabilityRequestNegativeReply if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::IoCapabilityRequestNegativeReply)?))}
OpCode::EnhancedSetupSynchronousConnection if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::EnhancedSetupSynchronousConnection)?))}
OpCode::EnhancedAcceptSynchronousConnection if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::EnhancedAcceptSynchronousConnection)?))}
OpCode::RemoteOobExtendedDataRequestReply if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::RemoteOobExtendedDataRequestReply)?))}
OpCode::HoldMode if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::HoldMode)?))}
OpCode::SniffMode if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::SniffMode)?))}
OpCode::ExitSniffMode if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::ExitSniffMode)?))}
OpCode::QosSetup if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::QosSetup)?))}
OpCode::RoleDiscovery if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::RoleDiscovery)?))}
OpCode::SwitchRole if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::SwitchRole)?))}
OpCode::ReadLinkPolicySettings if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::ReadLinkPolicySettings)?))}
OpCode::Flush if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::Flush)?))}
OpCode::WriteLinkPolicySettings if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::WriteLinkPolicySettings)?))}
OpCode::ReadDefaultLinkPolicySettings if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::ReadDefaultLinkPolicySettings)?))}
OpCode::WriteDefaultLinkPolicySettings if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::WriteDefaultLinkPolicySettings)?))}
OpCode::FlowSpecification if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::FlowSpecification)?))}
OpCode::SniffSubrating if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::SniffSubrating)?))}
OpCode::SetEventMask if SetEventMaskData::conforms(&bytes[..]) => {CommandDataChild::SetEventMask(Arc::new(SetEventMaskData::parse(&bytes[..])?))}
OpCode::Reset if ResetData::conforms(&bytes[..]) => {CommandDataChild::Reset(Arc::new(ResetData::parse(&bytes[..])?))}
OpCode::SetEventFilter if SetEventFilterData::conforms(&bytes[..]) => {CommandDataChild::SetEventFilter(Arc::new(SetEventFilterData::parse(&bytes[..])?))}
OpCode::ReadPinType if ReadPinTypeData::conforms(&bytes[..]) => {CommandDataChild::ReadPinType(Arc::new(ReadPinTypeData::parse(&bytes[..])?))}
OpCode::WritePinType if WritePinTypeData::conforms(&bytes[..]) => {CommandDataChild::WritePinType(Arc::new(WritePinTypeData::parse(&bytes[..])?))}
OpCode::ReadStoredLinkKey if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::ReadStoredLinkKey)?))}
OpCode::WriteStoredLinkKey if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::WriteStoredLinkKey)?))}
OpCode::DeleteStoredLinkKey if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::DeleteStoredLinkKey)?))}
OpCode::WriteLocalName if WriteLocalNameData::conforms(&bytes[..]) => {CommandDataChild::WriteLocalName(Arc::new(WriteLocalNameData::parse(&bytes[..])?))}
OpCode::ReadLocalName if ReadLocalNameData::conforms(&bytes[..]) => {CommandDataChild::ReadLocalName(Arc::new(ReadLocalNameData::parse(&bytes[..])?))}
OpCode::ReadConnectionAcceptTimeout if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::ReadConnectionAcceptTimeout)?))}
OpCode::WriteConnectionAcceptTimeout if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::WriteConnectionAcceptTimeout)?))}
OpCode::ReadPageTimeout if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::ReadPageTimeout)?))}
OpCode::WritePageTimeout if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::WritePageTimeout)?))}
OpCode::ReadScanEnable if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::ReadScanEnable)?))}
OpCode::WriteScanEnable if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::WriteScanEnable)?))}
OpCode::ReadPageScanActivity if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::ReadPageScanActivity)?))}
OpCode::WritePageScanActivity if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::WritePageScanActivity)?))}
OpCode::ReadInquiryScanActivity if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::ReadInquiryScanActivity)?))}
OpCode::WriteInquiryScanActivity if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::WriteInquiryScanActivity)?))}
OpCode::ReadAuthenticationEnable if ReadAuthenticationEnableData::conforms(&bytes[..]) => {CommandDataChild::ReadAuthenticationEnable(Arc::new(ReadAuthenticationEnableData::parse(&bytes[..])?))}
OpCode::WriteAuthenticationEnable if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::WriteAuthenticationEnable)?))}
OpCode::ReadClassOfDevice if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::ReadClassOfDevice)?))}
OpCode::WriteClassOfDevice if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::WriteClassOfDevice)?))}
OpCode::ReadVoiceSetting if ReadVoiceSettingData::conforms(&bytes[..]) => {CommandDataChild::ReadVoiceSetting(Arc::new(ReadVoiceSettingData::parse(&bytes[..])?))}
OpCode::WriteVoiceSetting if WriteVoiceSettingData::conforms(&bytes[..]) => {CommandDataChild::WriteVoiceSetting(Arc::new(WriteVoiceSettingData::parse(&bytes[..])?))}
OpCode::ReadAutomaticFlushTimeout if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::ReadAutomaticFlushTimeout)?))}
OpCode::WriteAutomaticFlushTimeout if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::WriteAutomaticFlushTimeout)?))}
OpCode::ReadNumBroadcastRetransmits if ReadNumBroadcastRetransmitsData::conforms(&bytes[..]) => {CommandDataChild::ReadNumBroadcastRetransmits(Arc::new(ReadNumBroadcastRetransmitsData::parse(&bytes[..])?))}
OpCode::WriteNumBroadcastRetransmits if WriteNumBroadcastRetransmitsData::conforms(&bytes[..]) => {CommandDataChild::WriteNumBroadcastRetransmits(Arc::new(WriteNumBroadcastRetransmitsData::parse(&bytes[..])?))}
OpCode::ReadHoldModeActivity if ReadHoldModeActivityData::conforms(&bytes[..]) => {CommandDataChild::ReadHoldModeActivity(Arc::new(ReadHoldModeActivityData::parse(&bytes[..])?))}
OpCode::WriteHoldModeActivity if WriteHoldModeActivityData::conforms(&bytes[..]) => {CommandDataChild::WriteHoldModeActivity(Arc::new(WriteHoldModeActivityData::parse(&bytes[..])?))}
OpCode::ReadTransmitPowerLevel if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::ReadTransmitPowerLevel)?))}
OpCode::ReadSynchronousFlowControlEnable if ReadSynchronousFlowControlEnableData::conforms(&bytes[..]) => {CommandDataChild::ReadSynchronousFlowControlEnable(Arc::new(ReadSynchronousFlowControlEnableData::parse(&bytes[..])?))}
OpCode::WriteSynchronousFlowControlEnable if WriteSynchronousFlowControlEnableData::conforms(&bytes[..]) => {CommandDataChild::WriteSynchronousFlowControlEnable(Arc::new(WriteSynchronousFlowControlEnableData::parse(&bytes[..])?))}
OpCode::SetControllerToHostFlowControl if SetControllerToHostFlowControlData::conforms(&bytes[..]) => {CommandDataChild::SetControllerToHostFlowControl(Arc::new(SetControllerToHostFlowControlData::parse(&bytes[..])?))}
OpCode::HostBufferSize if HostBufferSizeData::conforms(&bytes[..]) => {CommandDataChild::HostBufferSize(Arc::new(HostBufferSizeData::parse(&bytes[..])?))}
OpCode::HostNumCompletedPackets if HostNumCompletedPacketsData::conforms(&bytes[..]) => {CommandDataChild::HostNumCompletedPackets(Arc::new(HostNumCompletedPacketsData::parse(&bytes[..])?))}
OpCode::ReadLinkSupervisionTimeout if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::ReadLinkSupervisionTimeout)?))}
OpCode::WriteLinkSupervisionTimeout if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::WriteLinkSupervisionTimeout)?))}
OpCode::ReadNumberOfSupportedIac if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::ReadNumberOfSupportedIac)?))}
OpCode::ReadCurrentIacLap if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::ReadCurrentIacLap)?))}
OpCode::WriteCurrentIacLap if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::WriteCurrentIacLap)?))}
OpCode::SetAfhHostChannelClassification if SetAfhHostChannelClassificationData::conforms(&bytes[..]) => {CommandDataChild::SetAfhHostChannelClassification(Arc::new(SetAfhHostChannelClassificationData::parse(&bytes[..])?))}
OpCode::ReadInquiryScanType if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::ReadInquiryScanType)?))}
OpCode::WriteInquiryScanType if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::WriteInquiryScanType)?))}
OpCode::ReadInquiryMode if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::ReadInquiryMode)?))}
OpCode::WriteInquiryMode if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::WriteInquiryMode)?))}
OpCode::ReadPageScanType if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::ReadPageScanType)?))}
OpCode::WritePageScanType if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::WritePageScanType)?))}
OpCode::ReadAfhChannelAssessmentMode if ReadAfhChannelAssessmentModeData::conforms(&bytes[..]) => {CommandDataChild::ReadAfhChannelAssessmentMode(Arc::new(ReadAfhChannelAssessmentModeData::parse(&bytes[..])?))}
OpCode::WriteAfhChannelAssessmentMode if WriteAfhChannelAssessmentModeData::conforms(&bytes[..]) => {CommandDataChild::WriteAfhChannelAssessmentMode(Arc::new(WriteAfhChannelAssessmentModeData::parse(&bytes[..])?))}
OpCode::ReadExtendedInquiryResponse if ReadExtendedInquiryResponseData::conforms(&bytes[..]) => {CommandDataChild::ReadExtendedInquiryResponse(Arc::new(ReadExtendedInquiryResponseData::parse(&bytes[..])?))}
OpCode::WriteExtendedInquiryResponse if WriteExtendedInquiryResponseData::conforms(&bytes[..]) => {CommandDataChild::WriteExtendedInquiryResponse(Arc::new(WriteExtendedInquiryResponseData::parse(&bytes[..])?))}
OpCode::RefreshEncryptionKey if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::RefreshEncryptionKey)?))}
OpCode::ReadSimplePairingMode if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::ReadSimplePairingMode)?))}
OpCode::WriteSimplePairingMode if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::WriteSimplePairingMode)?))}
OpCode::ReadLocalOobData if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::ReadLocalOobData)?))}
OpCode::ReadInquiryResponseTransmitPowerLevel if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::ReadInquiryResponseTransmitPowerLevel)?))}
OpCode::WriteInquiryTransmitPowerLevel if DiscoveryCommandData::conforms(&bytes[..]) => {CommandDataChild::DiscoveryCommand(Arc::new(DiscoveryCommandData::parse(&bytes[..], OpCode::WriteInquiryTransmitPowerLevel)?))}
OpCode::SendKeypressNotification if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::SendKeypressNotification)?))}
OpCode::ReadLeHostSupport if ReadLeHostSupportData::conforms(&bytes[..]) => {CommandDataChild::ReadLeHostSupport(Arc::new(ReadLeHostSupportData::parse(&bytes[..])?))}
OpCode::WriteLeHostSupport if WriteLeHostSupportData::conforms(&bytes[..]) => {CommandDataChild::WriteLeHostSupport(Arc::new(WriteLeHostSupportData::parse(&bytes[..])?))}
OpCode::ReadSecureConnectionsHostSupport if ReadSecureConnectionsHostSupportData::conforms(&bytes[..]) => {CommandDataChild::ReadSecureConnectionsHostSupport(Arc::new(ReadSecureConnectionsHostSupportData::parse(&bytes[..])?))}
OpCode::WriteSecureConnectionsHostSupport if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::WriteSecureConnectionsHostSupport)?))}
OpCode::ReadLocalOobExtendedData if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::ReadLocalOobExtendedData)?))}
OpCode::SetEcosystemBaseInterval if SetEcosystemBaseIntervalData::conforms(&bytes[..]) => {CommandDataChild::SetEcosystemBaseInterval(Arc::new(SetEcosystemBaseIntervalData::parse(&bytes[..])?))}
OpCode::ConfigureDataPath if ConfigureDataPathData::conforms(&bytes[..]) => {CommandDataChild::ConfigureDataPath(Arc::new(ConfigureDataPathData::parse(&bytes[..])?))}
OpCode::ReadLocalVersionInformation if ReadLocalVersionInformationData::conforms(&bytes[..]) => {CommandDataChild::ReadLocalVersionInformation(Arc::new(ReadLocalVersionInformationData::parse(&bytes[..])?))}
OpCode::ReadLocalSupportedCommands if ReadLocalSupportedCommandsData::conforms(&bytes[..]) => {CommandDataChild::ReadLocalSupportedCommands(Arc::new(ReadLocalSupportedCommandsData::parse(&bytes[..])?))}
OpCode::ReadLocalSupportedFeatures if ReadLocalSupportedFeaturesData::conforms(&bytes[..]) => {CommandDataChild::ReadLocalSupportedFeatures(Arc::new(ReadLocalSupportedFeaturesData::parse(&bytes[..])?))}
OpCode::ReadLocalExtendedFeatures if ReadLocalExtendedFeaturesData::conforms(&bytes[..]) => {CommandDataChild::ReadLocalExtendedFeatures(Arc::new(ReadLocalExtendedFeaturesData::parse(&bytes[..])?))}
OpCode::ReadBufferSize if ReadBufferSizeData::conforms(&bytes[..]) => {CommandDataChild::ReadBufferSize(Arc::new(ReadBufferSizeData::parse(&bytes[..])?))}
OpCode::ReadBdAddr if ReadBdAddrData::conforms(&bytes[..]) => {CommandDataChild::ReadBdAddr(Arc::new(ReadBdAddrData::parse(&bytes[..])?))}
OpCode::ReadDataBlockSize if ReadDataBlockSizeData::conforms(&bytes[..]) => {CommandDataChild::ReadDataBlockSize(Arc::new(ReadDataBlockSizeData::parse(&bytes[..])?))}
OpCode::ReadLocalSupportedCodecsV1 if ReadLocalSupportedCodecsV1Data::conforms(&bytes[..]) => {CommandDataChild::ReadLocalSupportedCodecsV1(Arc::new(ReadLocalSupportedCodecsV1Data::parse(&bytes[..])?))}
OpCode::ReadLocalSupportedCodecsV2 if ReadLocalSupportedCodecsV2Data::conforms(&bytes[..]) => {CommandDataChild::ReadLocalSupportedCodecsV2(Arc::new(ReadLocalSupportedCodecsV2Data::parse(&bytes[..])?))}
OpCode::ReadLocalSupportedCodecCapabilities if ReadLocalSupportedCodecCapabilitiesData::conforms(&bytes[..]) => {CommandDataChild::ReadLocalSupportedCodecCapabilities(Arc::new(ReadLocalSupportedCodecCapabilitiesData::parse(&bytes[..])?))}
OpCode::ReadLocalSupportedControllerDelay if ReadLocalSupportedControllerDelayData::conforms(&bytes[..]) => {CommandDataChild::ReadLocalSupportedControllerDelay(Arc::new(ReadLocalSupportedControllerDelayData::parse(&bytes[..])?))}
OpCode::ReadFailedContactCounter if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::ReadFailedContactCounter)?))}
OpCode::ResetFailedContactCounter if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::ResetFailedContactCounter)?))}
OpCode::ReadLinkQuality if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::ReadLinkQuality)?))}
OpCode::ReadRssi if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::ReadRssi)?))}
OpCode::ReadAfhChannelMap if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::ReadAfhChannelMap)?))}
OpCode::ReadClock if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::ReadClock)?))}
OpCode::ReadEncryptionKeySize if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::ReadEncryptionKeySize)?))}
OpCode::ReadLoopbackMode if ReadLoopbackModeData::conforms(&bytes[..]) => {CommandDataChild::ReadLoopbackMode(Arc::new(ReadLoopbackModeData::parse(&bytes[..])?))}
OpCode::WriteLoopbackMode if WriteLoopbackModeData::conforms(&bytes[..]) => {CommandDataChild::WriteLoopbackMode(Arc::new(WriteLoopbackModeData::parse(&bytes[..])?))}
OpCode::EnableDeviceUnderTestMode if EnableDeviceUnderTestModeData::conforms(&bytes[..]) => {CommandDataChild::EnableDeviceUnderTestMode(Arc::new(EnableDeviceUnderTestModeData::parse(&bytes[..])?))}
OpCode::WriteSimplePairingDebugMode if SecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::SecurityCommand(Arc::new(SecurityCommandData::parse(&bytes[..], OpCode::WriteSimplePairingDebugMode)?))}
OpCode::WriteSecureConnectionsTestMode if WriteSecureConnectionsTestModeData::conforms(&bytes[..]) => {CommandDataChild::WriteSecureConnectionsTestMode(Arc::new(WriteSecureConnectionsTestModeData::parse(&bytes[..])?))}
OpCode::LeSetEventMask if LeSetEventMaskData::conforms(&bytes[..]) => {CommandDataChild::LeSetEventMask(Arc::new(LeSetEventMaskData::parse(&bytes[..])?))}
OpCode::LeReadBufferSizeV1 if LeReadBufferSizeV1Data::conforms(&bytes[..]) => {CommandDataChild::LeReadBufferSizeV1(Arc::new(LeReadBufferSizeV1Data::parse(&bytes[..])?))}
OpCode::LeReadLocalSupportedFeatures if LeReadLocalSupportedFeaturesData::conforms(&bytes[..]) => {CommandDataChild::LeReadLocalSupportedFeatures(Arc::new(LeReadLocalSupportedFeaturesData::parse(&bytes[..])?))}
OpCode::LeSetRandomAddress if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeSetRandomAddress)?))}
OpCode::LeSetAdvertisingParameters if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeSetAdvertisingParameters)?))}
OpCode::LeReadAdvertisingPhysicalChannelTxPower if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeReadAdvertisingPhysicalChannelTxPower)?))}
OpCode::LeSetAdvertisingData if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeSetAdvertisingData)?))}
OpCode::LeSetScanResponseData if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeSetScanResponseData)?))}
OpCode::LeSetAdvertisingEnable if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeSetAdvertisingEnable)?))}
OpCode::LeSetScanParameters if LeScanningCommandData::conforms(&bytes[..]) => {CommandDataChild::LeScanningCommand(Arc::new(LeScanningCommandData::parse(&bytes[..], OpCode::LeSetScanParameters)?))}
OpCode::LeSetScanEnable if LeScanningCommandData::conforms(&bytes[..]) => {CommandDataChild::LeScanningCommand(Arc::new(LeScanningCommandData::parse(&bytes[..], OpCode::LeSetScanEnable)?))}
OpCode::LeCreateConnection if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::LeCreateConnection)?))}
OpCode::LeCreateConnectionCancel if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::LeCreateConnectionCancel)?))}
OpCode::LeReadConnectListSize if LeReadConnectListSizeData::conforms(&bytes[..]) => {CommandDataChild::LeReadConnectListSize(Arc::new(LeReadConnectListSizeData::parse(&bytes[..])?))}
OpCode::LeClearConnectList if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::LeClearConnectList)?))}
OpCode::LeAddDeviceToConnectList if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::LeAddDeviceToConnectList)?))}
OpCode::LeRemoveDeviceFromConnectList if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::LeRemoveDeviceFromConnectList)?))}
OpCode::LeConnectionUpdate if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::LeConnectionUpdate)?))}
OpCode::LeSetHostChannelClassification if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::LeSetHostChannelClassification)?))}
OpCode::LeReadChannelMap if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::LeReadChannelMap)?))}
OpCode::LeReadRemoteFeatures if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::LeReadRemoteFeatures)?))}
OpCode::LeEncrypt if LeSecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::LeSecurityCommand(Arc::new(LeSecurityCommandData::parse(&bytes[..], OpCode::LeEncrypt)?))}
OpCode::LeRand if LeSecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::LeSecurityCommand(Arc::new(LeSecurityCommandData::parse(&bytes[..], OpCode::LeRand)?))}
OpCode::LeStartEncryption if LeSecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::LeSecurityCommand(Arc::new(LeSecurityCommandData::parse(&bytes[..], OpCode::LeStartEncryption)?))}
OpCode::LeLongTermKeyRequestReply if LeSecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::LeSecurityCommand(Arc::new(LeSecurityCommandData::parse(&bytes[..], OpCode::LeLongTermKeyRequestReply)?))}
OpCode::LeLongTermKeyRequestNegativeReply if LeSecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::LeSecurityCommand(Arc::new(LeSecurityCommandData::parse(&bytes[..], OpCode::LeLongTermKeyRequestNegativeReply)?))}
OpCode::LeReadSupportedStates if LeReadSupportedStatesData::conforms(&bytes[..]) => {CommandDataChild::LeReadSupportedStates(Arc::new(LeReadSupportedStatesData::parse(&bytes[..])?))}
OpCode::LeReceiverTest if LeReceiverTestData::conforms(&bytes[..]) => {CommandDataChild::LeReceiverTest(Arc::new(LeReceiverTestData::parse(&bytes[..])?))}
OpCode::LeTransmitterTest if LeTransmitterTestData::conforms(&bytes[..]) => {CommandDataChild::LeTransmitterTest(Arc::new(LeTransmitterTestData::parse(&bytes[..])?))}
OpCode::LeTestEnd if LeTestEndData::conforms(&bytes[..]) => {CommandDataChild::LeTestEnd(Arc::new(LeTestEndData::parse(&bytes[..])?))}
OpCode::LeRemoteConnectionParameterRequestReply if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::LeRemoteConnectionParameterRequestReply)?))}
OpCode::LeRemoteConnectionParameterRequestNegativeReply if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::LeRemoteConnectionParameterRequestNegativeReply)?))}
OpCode::LeSetDataLength if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::LeSetDataLength)?))}
OpCode::LeReadSuggestedDefaultDataLength if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::LeReadSuggestedDefaultDataLength)?))}
OpCode::LeWriteSuggestedDefaultDataLength if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::LeWriteSuggestedDefaultDataLength)?))}
OpCode::LeReadLocalP256PublicKeyCommand if LeSecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::LeSecurityCommand(Arc::new(LeSecurityCommandData::parse(&bytes[..], OpCode::LeReadLocalP256PublicKeyCommand)?))}
OpCode::LeGenerateDhkeyCommandV1 if LeSecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::LeSecurityCommand(Arc::new(LeSecurityCommandData::parse(&bytes[..], OpCode::LeGenerateDhkeyCommandV1)?))}
OpCode::LeAddDeviceToResolvingList if LeSecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::LeSecurityCommand(Arc::new(LeSecurityCommandData::parse(&bytes[..], OpCode::LeAddDeviceToResolvingList)?))}
OpCode::LeRemoveDeviceFromResolvingList if LeSecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::LeSecurityCommand(Arc::new(LeSecurityCommandData::parse(&bytes[..], OpCode::LeRemoveDeviceFromResolvingList)?))}
OpCode::LeClearResolvingList if LeSecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::LeSecurityCommand(Arc::new(LeSecurityCommandData::parse(&bytes[..], OpCode::LeClearResolvingList)?))}
OpCode::LeReadResolvingListSize if LeReadResolvingListSizeData::conforms(&bytes[..]) => {CommandDataChild::LeReadResolvingListSize(Arc::new(LeReadResolvingListSizeData::parse(&bytes[..])?))}
OpCode::LeReadPeerResolvableAddress if LeSecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::LeSecurityCommand(Arc::new(LeSecurityCommandData::parse(&bytes[..], OpCode::LeReadPeerResolvableAddress)?))}
OpCode::LeReadLocalResolvableAddress if LeSecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::LeSecurityCommand(Arc::new(LeSecurityCommandData::parse(&bytes[..], OpCode::LeReadLocalResolvableAddress)?))}
OpCode::LeSetAddressResolutionEnable if LeSecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::LeSecurityCommand(Arc::new(LeSecurityCommandData::parse(&bytes[..], OpCode::LeSetAddressResolutionEnable)?))}
OpCode::LeSetResolvablePrivateAddressTimeout if LeSecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::LeSecurityCommand(Arc::new(LeSecurityCommandData::parse(&bytes[..], OpCode::LeSetResolvablePrivateAddressTimeout)?))}
OpCode::LeReadMaximumDataLength if LeReadMaximumDataLengthData::conforms(&bytes[..]) => {CommandDataChild::LeReadMaximumDataLength(Arc::new(LeReadMaximumDataLengthData::parse(&bytes[..])?))}
OpCode::LeReadPhy if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::LeReadPhy)?))}
OpCode::LeSetDefaultPhy if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::LeSetDefaultPhy)?))}
OpCode::LeSetPhy if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::LeSetPhy)?))}
OpCode::LeEnhancedReceiverTest if LeEnhancedReceiverTestData::conforms(&bytes[..]) => {CommandDataChild::LeEnhancedReceiverTest(Arc::new(LeEnhancedReceiverTestData::parse(&bytes[..])?))}
OpCode::LeEnhancedTransmitterTest if LeEnhancedTransmitterTestData::conforms(&bytes[..]) => {CommandDataChild::LeEnhancedTransmitterTest(Arc::new(LeEnhancedTransmitterTestData::parse(&bytes[..])?))}
OpCode::LeSetExtendedAdvertisingRandomAddress if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeSetExtendedAdvertisingRandomAddress)?))}
OpCode::LeSetExtendedAdvertisingParameters if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeSetExtendedAdvertisingParameters)?))}
OpCode::LeSetExtendedAdvertisingParameters if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeSetExtendedAdvertisingParameters)?))}
OpCode::LeSetExtendedAdvertisingData if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeSetExtendedAdvertisingData)?))}
OpCode::LeSetExtendedAdvertisingData if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeSetExtendedAdvertisingData)?))}
OpCode::LeSetExtendedAdvertisingScanResponse if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeSetExtendedAdvertisingScanResponse)?))}
OpCode::LeSetExtendedAdvertisingScanResponse if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeSetExtendedAdvertisingScanResponse)?))}
OpCode::LeSetExtendedAdvertisingEnable if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeSetExtendedAdvertisingEnable)?))}
OpCode::LeSetExtendedAdvertisingEnable if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeSetExtendedAdvertisingEnable)?))}
OpCode::LeSetExtendedAdvertisingEnable if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeSetExtendedAdvertisingEnable)?))}
OpCode::LeReadMaximumAdvertisingDataLength if LeReadMaximumAdvertisingDataLengthData::conforms(&bytes[..]) => {CommandDataChild::LeReadMaximumAdvertisingDataLength(Arc::new(LeReadMaximumAdvertisingDataLengthData::parse(&bytes[..])?))}
OpCode::LeReadNumberOfSupportedAdvertisingSets if LeReadNumberOfSupportedAdvertisingSetsData::conforms(&bytes[..]) => {CommandDataChild::LeReadNumberOfSupportedAdvertisingSets(Arc::new(LeReadNumberOfSupportedAdvertisingSetsData::parse(&bytes[..])?))}
OpCode::LeRemoveAdvertisingSet if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeRemoveAdvertisingSet)?))}
OpCode::LeClearAdvertisingSets if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeClearAdvertisingSets)?))}
OpCode::LeSetPeriodicAdvertisingParam if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeSetPeriodicAdvertisingParam)?))}
OpCode::LeSetPeriodicAdvertisingData if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeSetPeriodicAdvertisingData)?))}
OpCode::LeSetPeriodicAdvertisingEnable if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeSetPeriodicAdvertisingEnable)?))}
OpCode::LeSetExtendedScanParameters if LeScanningCommandData::conforms(&bytes[..]) => {CommandDataChild::LeScanningCommand(Arc::new(LeScanningCommandData::parse(&bytes[..], OpCode::LeSetExtendedScanParameters)?))}
OpCode::LeSetExtendedScanEnable if LeScanningCommandData::conforms(&bytes[..]) => {CommandDataChild::LeScanningCommand(Arc::new(LeScanningCommandData::parse(&bytes[..], OpCode::LeSetExtendedScanEnable)?))}
OpCode::LeExtendedCreateConnection if AclCommandData::conforms(&bytes[..]) => {CommandDataChild::AclCommand(Arc::new(AclCommandData::parse(&bytes[..], OpCode::LeExtendedCreateConnection)?))}
OpCode::LePeriodicAdvertisingCreateSync if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LePeriodicAdvertisingCreateSync)?))}
OpCode::LePeriodicAdvertisingCreateSyncCancel if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LePeriodicAdvertisingCreateSyncCancel)?))}
OpCode::LePeriodicAdvertisingTerminateSync if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LePeriodicAdvertisingTerminateSync)?))}
OpCode::LeAddDeviceToPeriodicAdvertisingList if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeAddDeviceToPeriodicAdvertisingList)?))}
OpCode::LeRemoveDeviceFromPeriodicAdvertisingList if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeRemoveDeviceFromPeriodicAdvertisingList)?))}
OpCode::LeClearPeriodicAdvertisingList if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeClearPeriodicAdvertisingList)?))}
OpCode::LeReadPeriodicAdvertisingListSize if LeReadPeriodicAdvertiserListSizeData::conforms(&bytes[..]) => {CommandDataChild::LeReadPeriodicAdvertiserListSize(Arc::new(LeReadPeriodicAdvertiserListSizeData::parse(&bytes[..])?))}
OpCode::LeReadTransmitPower if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeReadTransmitPower)?))}
OpCode::LeReadRfPathCompensationPower if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeReadRfPathCompensationPower)?))}
OpCode::LeWriteRfPathCompensationPower if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeWriteRfPathCompensationPower)?))}
OpCode::LeSetPrivacyMode if LeSecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::LeSecurityCommand(Arc::new(LeSecurityCommandData::parse(&bytes[..], OpCode::LeSetPrivacyMode)?))}
OpCode::LeSetPeriodicAdvertisingReceiveEnable if LeSetPeriodicAdvertisingReceiveEnableData::conforms(&bytes[..]) => {CommandDataChild::LeSetPeriodicAdvertisingReceiveEnable(Arc::new(LeSetPeriodicAdvertisingReceiveEnableData::parse(&bytes[..])?))}
OpCode::LePeriodicAdvertisingSyncTransfer if LePeriodicAdvertisingSyncTransferData::conforms(&bytes[..]) => {CommandDataChild::LePeriodicAdvertisingSyncTransfer(Arc::new(LePeriodicAdvertisingSyncTransferData::parse(&bytes[..])?))}
OpCode::LePeriodicAdvertisingSetInfoTransfer if LePeriodicAdvertisingSetInfoTransferData::conforms(&bytes[..]) => {CommandDataChild::LePeriodicAdvertisingSetInfoTransfer(Arc::new(LePeriodicAdvertisingSetInfoTransferData::parse(&bytes[..])?))}
OpCode::LeSetPeriodicAdvertisingSyncTransferParameters if LeSetPeriodicAdvertisingSyncTransferParametersData::conforms(&bytes[..]) => {CommandDataChild::LeSetPeriodicAdvertisingSyncTransferParameters(Arc::new(LeSetPeriodicAdvertisingSyncTransferParametersData::parse(&bytes[..])?))}
OpCode::LeSetDefaultPeriodicAdvertisingSyncTransferParameters if LeSetDefaultPeriodicAdvertisingSyncTransferParametersData::conforms(&bytes[..]) => {CommandDataChild::LeSetDefaultPeriodicAdvertisingSyncTransferParameters(Arc::new(LeSetDefaultPeriodicAdvertisingSyncTransferParametersData::parse(&bytes[..])?))}
OpCode::LeGenerateDhkeyCommand if LeSecurityCommandData::conforms(&bytes[..]) => {CommandDataChild::LeSecurityCommand(Arc::new(LeSecurityCommandData::parse(&bytes[..], OpCode::LeGenerateDhkeyCommand)?))}
OpCode::LeModifySleepClockAccuracy if LeModifySleepClockAccuracyData::conforms(&bytes[..]) => {CommandDataChild::LeModifySleepClockAccuracy(Arc::new(LeModifySleepClockAccuracyData::parse(&bytes[..])?))}
OpCode::LeReadBufferSizeV2 if LeReadBufferSizeV2Data::conforms(&bytes[..]) => {CommandDataChild::LeReadBufferSizeV2(Arc::new(LeReadBufferSizeV2Data::parse(&bytes[..])?))}
OpCode::LeReadIsoTxSync if LeIsoCommandData::conforms(&bytes[..]) => {CommandDataChild::LeIsoCommand(Arc::new(LeIsoCommandData::parse(&bytes[..], OpCode::LeReadIsoTxSync)?))}
OpCode::LeSetCigParameters if LeIsoCommandData::conforms(&bytes[..]) => {CommandDataChild::LeIsoCommand(Arc::new(LeIsoCommandData::parse(&bytes[..], OpCode::LeSetCigParameters)?))}
OpCode::LeSetCigParametersTest if LeIsoCommandData::conforms(&bytes[..]) => {CommandDataChild::LeIsoCommand(Arc::new(LeIsoCommandData::parse(&bytes[..], OpCode::LeSetCigParametersTest)?))}
OpCode::LeSetupIsoDataPath if LeIsoCommandData::conforms(&bytes[..]) => {CommandDataChild::LeIsoCommand(Arc::new(LeIsoCommandData::parse(&bytes[..], OpCode::LeSetupIsoDataPath)?))}
OpCode::LeCreateCis if LeIsoCommandData::conforms(&bytes[..]) => {CommandDataChild::LeIsoCommand(Arc::new(LeIsoCommandData::parse(&bytes[..], OpCode::LeCreateCis)?))}
OpCode::LeRemoveCig if LeIsoCommandData::conforms(&bytes[..]) => {CommandDataChild::LeIsoCommand(Arc::new(LeIsoCommandData::parse(&bytes[..], OpCode::LeRemoveCig)?))}
OpCode::LeAcceptCisRequest if LeIsoCommandData::conforms(&bytes[..]) => {CommandDataChild::LeIsoCommand(Arc::new(LeIsoCommandData::parse(&bytes[..], OpCode::LeAcceptCisRequest)?))}
OpCode::LeRejectCisRequest if LeIsoCommandData::conforms(&bytes[..]) => {CommandDataChild::LeIsoCommand(Arc::new(LeIsoCommandData::parse(&bytes[..], OpCode::LeRejectCisRequest)?))}
OpCode::LeCreateBig if LeIsoCommandData::conforms(&bytes[..]) => {CommandDataChild::LeIsoCommand(Arc::new(LeIsoCommandData::parse(&bytes[..], OpCode::LeCreateBig)?))}
OpCode::LeTerminateBig if LeIsoCommandData::conforms(&bytes[..]) => {CommandDataChild::LeIsoCommand(Arc::new(LeIsoCommandData::parse(&bytes[..], OpCode::LeTerminateBig)?))}
OpCode::LeBigCreateSync if LeIsoCommandData::conforms(&bytes[..]) => {CommandDataChild::LeIsoCommand(Arc::new(LeIsoCommandData::parse(&bytes[..], OpCode::LeBigCreateSync)?))}
OpCode::LeBigTerminateSync if LeIsoCommandData::conforms(&bytes[..]) => {CommandDataChild::LeIsoCommand(Arc::new(LeIsoCommandData::parse(&bytes[..], OpCode::LeBigTerminateSync)?))}
OpCode::LeRequestPeerSca if LeRequestPeerScaData::conforms(&bytes[..]) => {CommandDataChild::LeRequestPeerSca(Arc::new(LeRequestPeerScaData::parse(&bytes[..])?))}
OpCode::LeRemoveIsoDataPath if LeIsoCommandData::conforms(&bytes[..]) => {CommandDataChild::LeIsoCommand(Arc::new(LeIsoCommandData::parse(&bytes[..], OpCode::LeRemoveIsoDataPath)?))}
OpCode::LeGetVendorCapabilities if VendorCommandData::conforms(&bytes[..]) => {CommandDataChild::VendorCommand(Arc::new(VendorCommandData::parse(&bytes[..], OpCode::LeGetVendorCapabilities)?))}
OpCode::LeSetTransmitPowerReportingEnable if LeSetTransmitPowerReportingEnableData::conforms(&bytes[..]) => {CommandDataChild::LeSetTransmitPowerReportingEnable(Arc::new(LeSetTransmitPowerReportingEnableData::parse(&bytes[..])?))}
OpCode::LeSetHostFeature if LeSetHostFeatureData::conforms(&bytes[..]) => {CommandDataChild::LeSetHostFeature(Arc::new(LeSetHostFeatureData::parse(&bytes[..])?))}
OpCode::LeReadIsoLinkQuality if LeIsoCommandData::conforms(&bytes[..]) => {CommandDataChild::LeIsoCommand(Arc::new(LeIsoCommandData::parse(&bytes[..], OpCode::LeReadIsoLinkQuality)?))}
OpCode::LeEnhancedReadTransmitPowerLevel if LeEnhancedReadTransmitPowerLevelData::conforms(&bytes[..]) => {CommandDataChild::LeEnhancedReadTransmitPowerLevel(Arc::new(LeEnhancedReadTransmitPowerLevelData::parse(&bytes[..])?))}
OpCode::LeReadRemoteTransmitPowerLevel if LeReadRemoteTransmitPowerLevelData::conforms(&bytes[..]) => {CommandDataChild::LeReadRemoteTransmitPowerLevel(Arc::new(LeReadRemoteTransmitPowerLevelData::parse(&bytes[..])?))}
OpCode::LeSetPathLossReportingParameters if LeSetPathLossReportingParametersData::conforms(&bytes[..]) => {CommandDataChild::LeSetPathLossReportingParameters(Arc::new(LeSetPathLossReportingParametersData::parse(&bytes[..])?))}
OpCode::LeSetPathLossReportingEnable if LeSetPathLossReportingEnableData::conforms(&bytes[..]) => {CommandDataChild::LeSetPathLossReportingEnable(Arc::new(LeSetPathLossReportingEnableData::parse(&bytes[..])?))}
OpCode::LeMultiAdvt if LeAdvertisingCommandData::conforms(&bytes[..]) => {CommandDataChild::LeAdvertisingCommand(Arc::new(LeAdvertisingCommandData::parse(&bytes[..], OpCode::LeMultiAdvt)?))}
OpCode::LeBatchScan if LeScanningCommandData::conforms(&bytes[..]) => {CommandDataChild::LeScanningCommand(Arc::new(LeScanningCommandData::parse(&bytes[..], OpCode::LeBatchScan)?))}
OpCode::LeAdvFilter if LeScanningCommandData::conforms(&bytes[..]) => {CommandDataChild::LeScanningCommand(Arc::new(LeScanningCommandData::parse(&bytes[..], OpCode::LeAdvFilter)?))}
OpCode::LeEnergyInfo if VendorCommandData::conforms(&bytes[..]) => {CommandDataChild::VendorCommand(Arc::new(VendorCommandData::parse(&bytes[..], OpCode::LeEnergyInfo)?))}
OpCode::LeExtendedScanParams if LeScanningCommandData::conforms(&bytes[..]) => {CommandDataChild::LeScanningCommand(Arc::new(LeScanningCommandData::parse(&bytes[..], OpCode::LeExtendedScanParams)?))}
OpCode::ControllerDebugInfo if VendorCommandData::conforms(&bytes[..]) => {CommandDataChild::VendorCommand(Arc::new(VendorCommandData::parse(&bytes[..], OpCode::ControllerDebugInfo)?))}
OpCode::ControllerA2dpOpcode if VendorCommandData::conforms(&bytes[..]) => {CommandDataChild::VendorCommand(Arc::new(VendorCommandData::parse(&bytes[..], OpCode::ControllerA2dpOpcode)?))}
OpCode::ControllerBqr if VendorCommandData::conforms(&bytes[..]) => {CommandDataChild::VendorCommand(Arc::new(VendorCommandData::parse(&bytes[..], OpCode::ControllerBqr)?))}
OpCode::EnhancedFlush if EnhancedFlushData::conforms(&bytes[..]) => {CommandDataChild::EnhancedFlush(Arc::new(EnhancedFlushData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "op_code".to_string(), value: v as u64}),};
Ok(Self {op_code, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let op_code = self.op_code.to_u16().unwrap();buffer[0..2].copy_from_slice(&op_code.to_le_bytes()[0..2]);let payload_size = u8::try_from(self.child.get_total_size()).expect("payload size did not fit");buffer[2..3].copy_from_slice(&payload_size.to_le_bytes()[0..1]);match &self.child {CommandDataChild::DiscoveryCommand(value) => value.write_to(buffer),CommandDataChild::AclCommand(value) => value.write_to(buffer),CommandDataChild::SecurityCommand(value) => value.write_to(buffer),CommandDataChild::LeAdvertisingCommand(value) => value.write_to(buffer),CommandDataChild::LeScanningCommand(value) => value.write_to(buffer),CommandDataChild::LeSecurityCommand(value) => value.write_to(buffer),CommandDataChild::LeIsoCommand(value) => value.write_to(buffer),CommandDataChild::VendorCommand(value) => value.write_to(buffer),CommandDataChild::SetEventMask(value) => value.write_to(buffer),CommandDataChild::Reset(value) => value.write_to(buffer),CommandDataChild::SetEventFilter(value) => value.write_to(buffer),CommandDataChild::ReadPinType(value) => value.write_to(buffer),CommandDataChild::WritePinType(value) => value.write_to(buffer),CommandDataChild::WriteLocalName(value) => value.write_to(buffer),CommandDataChild::ReadLocalName(value) => value.write_to(buffer),CommandDataChild::ReadAuthenticationEnable(value) => value.write_to(buffer),CommandDataChild::ReadVoiceSetting(value) => value.write_to(buffer),CommandDataChild::WriteVoiceSetting(value) => value.write_to(buffer),CommandDataChild::ReadNumBroadcastRetransmits(value) => value.write_to(buffer),CommandDataChild::WriteNumBroadcastRetransmits(value) => value.write_to(buffer),CommandDataChild::ReadHoldModeActivity(value) => value.write_to(buffer),CommandDataChild::WriteHoldModeActivity(value) => value.write_to(buffer),CommandDataChild::ReadSynchronousFlowControlEnable(value) => value.write_to(buffer),CommandDataChild::WriteSynchronousFlowControlEnable(value) => value.write_to(buffer),CommandDataChild::SetControllerToHostFlowControl(value) => value.write_to(buffer),CommandDataChild::HostBufferSize(value) => value.write_to(buffer),CommandDataChild::HostNumCompletedPackets(value) => value.write_to(buffer),CommandDataChild::SetAfhHostChannelClassification(value) => value.write_to(buffer),CommandDataChild::ReadAfhChannelAssessmentMode(value) => value.write_to(buffer),CommandDataChild::WriteAfhChannelAssessmentMode(value) => value.write_to(buffer),CommandDataChild::ReadExtendedInquiryResponse(value) => value.write_to(buffer),CommandDataChild::WriteExtendedInquiryResponse(value) => value.write_to(buffer),CommandDataChild::ReadLeHostSupport(value) => value.write_to(buffer),CommandDataChild::WriteLeHostSupport(value) => value.write_to(buffer),CommandDataChild::ReadSecureConnectionsHostSupport(value) => value.write_to(buffer),CommandDataChild::SetEcosystemBaseInterval(value) => value.write_to(buffer),CommandDataChild::ConfigureDataPath(value) => value.write_to(buffer),CommandDataChild::ReadLocalVersionInformation(value) => value.write_to(buffer),CommandDataChild::ReadLocalSupportedCommands(value) => value.write_to(buffer),CommandDataChild::ReadLocalSupportedFeatures(value) => value.write_to(buffer),CommandDataChild::ReadLocalExtendedFeatures(value) => value.write_to(buffer),CommandDataChild::ReadBufferSize(value) => value.write_to(buffer),CommandDataChild::ReadBdAddr(value) => value.write_to(buffer),CommandDataChild::ReadDataBlockSize(value) => value.write_to(buffer),CommandDataChild::ReadLocalSupportedCodecsV1(value) => value.write_to(buffer),CommandDataChild::ReadLocalSupportedCodecsV2(value) => value.write_to(buffer),CommandDataChild::ReadLocalSupportedCodecCapabilities(value) => value.write_to(buffer),CommandDataChild::ReadLocalSupportedControllerDelay(value) => value.write_to(buffer),CommandDataChild::ReadLoopbackMode(value) => value.write_to(buffer),CommandDataChild::WriteLoopbackMode(value) => value.write_to(buffer),CommandDataChild::EnableDeviceUnderTestMode(value) => value.write_to(buffer),CommandDataChild::WriteSecureConnectionsTestMode(value) => value.write_to(buffer),CommandDataChild::LeSetEventMask(value) => value.write_to(buffer),CommandDataChild::LeReadBufferSizeV1(value) => value.write_to(buffer),CommandDataChild::LeReadLocalSupportedFeatures(value) => value.write_to(buffer),CommandDataChild::LeReadConnectListSize(value) => value.write_to(buffer),CommandDataChild::LeReadSupportedStates(value) => value.write_to(buffer),CommandDataChild::LeReceiverTest(value) => value.write_to(buffer),CommandDataChild::LeTransmitterTest(value) => value.write_to(buffer),CommandDataChild::LeTestEnd(value) => value.write_to(buffer),CommandDataChild::LeReadResolvingListSize(value) => value.write_to(buffer),CommandDataChild::LeReadMaximumDataLength(value) => value.write_to(buffer),CommandDataChild::LeEnhancedReceiverTest(value) => value.write_to(buffer),CommandDataChild::LeEnhancedTransmitterTest(value) => value.write_to(buffer),CommandDataChild::LeReadMaximumAdvertisingDataLength(value) => value.write_to(buffer),CommandDataChild::LeReadNumberOfSupportedAdvertisingSets(value) => value.write_to(buffer),CommandDataChild::LeReadPeriodicAdvertiserListSize(value) => value.write_to(buffer),CommandDataChild::LeSetPeriodicAdvertisingReceiveEnable(value) => value.write_to(buffer),CommandDataChild::LePeriodicAdvertisingSyncTransfer(value) => value.write_to(buffer),CommandDataChild::LePeriodicAdvertisingSetInfoTransfer(value) => value.write_to(buffer),CommandDataChild::LeSetPeriodicAdvertisingSyncTransferParameters(value) => value.write_to(buffer),CommandDataChild::LeSetDefaultPeriodicAdvertisingSyncTransferParameters(value) => value.write_to(buffer),CommandDataChild::LeModifySleepClockAccuracy(value) => value.write_to(buffer),CommandDataChild::LeReadBufferSizeV2(value) => value.write_to(buffer),CommandDataChild::LeRequestPeerSca(value) => value.write_to(buffer),CommandDataChild::LeSetHostFeature(value) => value.write_to(buffer),CommandDataChild::LeEnhancedReadTransmitPowerLevel(value) => value.write_to(buffer),CommandDataChild::LeReadRemoteTransmitPowerLevel(value) => value.write_to(buffer),CommandDataChild::LeSetPathLossReportingParameters(value) => value.write_to(buffer),CommandDataChild::LeSetPathLossReportingEnable(value) => value.write_to(buffer),CommandDataChild::LeSetTransmitPowerReportingEnable(value) => value.write_to(buffer),CommandDataChild::EnhancedFlush(value) => value.write_to(buffer),CommandDataChild::Payload(p) => buffer[3..].copy_from_slice(&p[..]),CommandDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for CommandPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl CommandPacket {pub fn parse(bytes: &[u8]) -> Result<Self> { Ok(Self::new(Arc::new(CommandData::parse(bytes)?)))} pub fn specialize(&self) -> CommandChild { match &self.command.child {CommandDataChild::DiscoveryCommand(_) => CommandChild::DiscoveryCommand(DiscoveryCommandPacket::new(self.command.clone())),CommandDataChild::AclCommand(_) => CommandChild::AclCommand(AclCommandPacket::new(self.command.clone())),CommandDataChild::SecurityCommand(_) => CommandChild::SecurityCommand(SecurityCommandPacket::new(self.command.clone())),CommandDataChild::LeAdvertisingCommand(_) => CommandChild::LeAdvertisingCommand(LeAdvertisingCommandPacket::new(self.command.clone())),CommandDataChild::LeScanningCommand(_) => CommandChild::LeScanningCommand(LeScanningCommandPacket::new(self.command.clone())),CommandDataChild::LeSecurityCommand(_) => CommandChild::LeSecurityCommand(LeSecurityCommandPacket::new(self.command.clone())),CommandDataChild::LeIsoCommand(_) => CommandChild::LeIsoCommand(LeIsoCommandPacket::new(self.command.clone())),CommandDataChild::VendorCommand(_) => CommandChild::VendorCommand(VendorCommandPacket::new(self.command.clone())),CommandDataChild::SetEventMask(_) => CommandChild::SetEventMask(SetEventMaskPacket::new(self.command.clone())),CommandDataChild::Reset(_) => CommandChild::Reset(ResetPacket::new(self.command.clone())),CommandDataChild::SetEventFilter(_) => CommandChild::SetEventFilter(SetEventFilterPacket::new(self.command.clone())),CommandDataChild::ReadPinType(_) => CommandChild::ReadPinType(ReadPinTypePacket::new(self.command.clone())),CommandDataChild::WritePinType(_) => CommandChild::WritePinType(WritePinTypePacket::new(self.command.clone())),CommandDataChild::WriteLocalName(_) => CommandChild::WriteLocalName(WriteLocalNamePacket::new(self.command.clone())),CommandDataChild::ReadLocalName(_) => CommandChild::ReadLocalName(ReadLocalNamePacket::new(self.command.clone())),CommandDataChild::ReadAuthenticationEnable(_) => CommandChild::ReadAuthenticationEnable(ReadAuthenticationEnablePacket::new(self.command.clone())),CommandDataChild::ReadVoiceSetting(_) => CommandChild::ReadVoiceSetting(ReadVoiceSettingPacket::new(self.command.clone())),CommandDataChild::WriteVoiceSetting(_) => CommandChild::WriteVoiceSetting(WriteVoiceSettingPacket::new(self.command.clone())),CommandDataChild::ReadNumBroadcastRetransmits(_) => CommandChild::ReadNumBroadcastRetransmits(ReadNumBroadcastRetransmitsPacket::new(self.command.clone())),CommandDataChild::WriteNumBroadcastRetransmits(_) => CommandChild::WriteNumBroadcastRetransmits(WriteNumBroadcastRetransmitsPacket::new(self.command.clone())),CommandDataChild::ReadHoldModeActivity(_) => CommandChild::ReadHoldModeActivity(ReadHoldModeActivityPacket::new(self.command.clone())),CommandDataChild::WriteHoldModeActivity(_) => CommandChild::WriteHoldModeActivity(WriteHoldModeActivityPacket::new(self.command.clone())),CommandDataChild::ReadSynchronousFlowControlEnable(_) => CommandChild::ReadSynchronousFlowControlEnable(ReadSynchronousFlowControlEnablePacket::new(self.command.clone())),CommandDataChild::WriteSynchronousFlowControlEnable(_) => CommandChild::WriteSynchronousFlowControlEnable(WriteSynchronousFlowControlEnablePacket::new(self.command.clone())),CommandDataChild::SetControllerToHostFlowControl(_) => CommandChild::SetControllerToHostFlowControl(SetControllerToHostFlowControlPacket::new(self.command.clone())),CommandDataChild::HostBufferSize(_) => CommandChild::HostBufferSize(HostBufferSizePacket::new(self.command.clone())),CommandDataChild::HostNumCompletedPackets(_) => CommandChild::HostNumCompletedPackets(HostNumCompletedPacketsPacket::new(self.command.clone())),CommandDataChild::SetAfhHostChannelClassification(_) => CommandChild::SetAfhHostChannelClassification(SetAfhHostChannelClassificationPacket::new(self.command.clone())),CommandDataChild::ReadAfhChannelAssessmentMode(_) => CommandChild::ReadAfhChannelAssessmentMode(ReadAfhChannelAssessmentModePacket::new(self.command.clone())),CommandDataChild::WriteAfhChannelAssessmentMode(_) => CommandChild::WriteAfhChannelAssessmentMode(WriteAfhChannelAssessmentModePacket::new(self.command.clone())),CommandDataChild::ReadExtendedInquiryResponse(_) => CommandChild::ReadExtendedInquiryResponse(ReadExtendedInquiryResponsePacket::new(self.command.clone())),CommandDataChild::WriteExtendedInquiryResponse(_) => CommandChild::WriteExtendedInquiryResponse(WriteExtendedInquiryResponsePacket::new(self.command.clone())),CommandDataChild::ReadLeHostSupport(_) => CommandChild::ReadLeHostSupport(ReadLeHostSupportPacket::new(self.command.clone())),CommandDataChild::WriteLeHostSupport(_) => CommandChild::WriteLeHostSupport(WriteLeHostSupportPacket::new(self.command.clone())),CommandDataChild::ReadSecureConnectionsHostSupport(_) => CommandChild::ReadSecureConnectionsHostSupport(ReadSecureConnectionsHostSupportPacket::new(self.command.clone())),CommandDataChild::SetEcosystemBaseInterval(_) => CommandChild::SetEcosystemBaseInterval(SetEcosystemBaseIntervalPacket::new(self.command.clone())),CommandDataChild::ConfigureDataPath(_) => CommandChild::ConfigureDataPath(ConfigureDataPathPacket::new(self.command.clone())),CommandDataChild::ReadLocalVersionInformation(_) => CommandChild::ReadLocalVersionInformation(ReadLocalVersionInformationPacket::new(self.command.clone())),CommandDataChild::ReadLocalSupportedCommands(_) => CommandChild::ReadLocalSupportedCommands(ReadLocalSupportedCommandsPacket::new(self.command.clone())),CommandDataChild::ReadLocalSupportedFeatures(_) => CommandChild::ReadLocalSupportedFeatures(ReadLocalSupportedFeaturesPacket::new(self.command.clone())),CommandDataChild::ReadLocalExtendedFeatures(_) => CommandChild::ReadLocalExtendedFeatures(ReadLocalExtendedFeaturesPacket::new(self.command.clone())),CommandDataChild::ReadBufferSize(_) => CommandChild::ReadBufferSize(ReadBufferSizePacket::new(self.command.clone())),CommandDataChild::ReadBdAddr(_) => CommandChild::ReadBdAddr(ReadBdAddrPacket::new(self.command.clone())),CommandDataChild::ReadDataBlockSize(_) => CommandChild::ReadDataBlockSize(ReadDataBlockSizePacket::new(self.command.clone())),CommandDataChild::ReadLocalSupportedCodecsV1(_) => CommandChild::ReadLocalSupportedCodecsV1(ReadLocalSupportedCodecsV1Packet::new(self.command.clone())),CommandDataChild::ReadLocalSupportedCodecsV2(_) => CommandChild::ReadLocalSupportedCodecsV2(ReadLocalSupportedCodecsV2Packet::new(self.command.clone())),CommandDataChild::ReadLocalSupportedCodecCapabilities(_) => CommandChild::ReadLocalSupportedCodecCapabilities(ReadLocalSupportedCodecCapabilitiesPacket::new(self.command.clone())),CommandDataChild::ReadLocalSupportedControllerDelay(_) => CommandChild::ReadLocalSupportedControllerDelay(ReadLocalSupportedControllerDelayPacket::new(self.command.clone())),CommandDataChild::ReadLoopbackMode(_) => CommandChild::ReadLoopbackMode(ReadLoopbackModePacket::new(self.command.clone())),CommandDataChild::WriteLoopbackMode(_) => CommandChild::WriteLoopbackMode(WriteLoopbackModePacket::new(self.command.clone())),CommandDataChild::EnableDeviceUnderTestMode(_) => CommandChild::EnableDeviceUnderTestMode(EnableDeviceUnderTestModePacket::new(self.command.clone())),CommandDataChild::WriteSecureConnectionsTestMode(_) => CommandChild::WriteSecureConnectionsTestMode(WriteSecureConnectionsTestModePacket::new(self.command.clone())),CommandDataChild::LeSetEventMask(_) => CommandChild::LeSetEventMask(LeSetEventMaskPacket::new(self.command.clone())),CommandDataChild::LeReadBufferSizeV1(_) => CommandChild::LeReadBufferSizeV1(LeReadBufferSizeV1Packet::new(self.command.clone())),CommandDataChild::LeReadLocalSupportedFeatures(_) => CommandChild::LeReadLocalSupportedFeatures(LeReadLocalSupportedFeaturesPacket::new(self.command.clone())),CommandDataChild::LeReadConnectListSize(_) => CommandChild::LeReadConnectListSize(LeReadConnectListSizePacket::new(self.command.clone())),CommandDataChild::LeReadSupportedStates(_) => CommandChild::LeReadSupportedStates(LeReadSupportedStatesPacket::new(self.command.clone())),CommandDataChild::LeReceiverTest(_) => CommandChild::LeReceiverTest(LeReceiverTestPacket::new(self.command.clone())),CommandDataChild::LeTransmitterTest(_) => CommandChild::LeTransmitterTest(LeTransmitterTestPacket::new(self.command.clone())),CommandDataChild::LeTestEnd(_) => CommandChild::LeTestEnd(LeTestEndPacket::new(self.command.clone())),CommandDataChild::LeReadResolvingListSize(_) => CommandChild::LeReadResolvingListSize(LeReadResolvingListSizePacket::new(self.command.clone())),CommandDataChild::LeReadMaximumDataLength(_) => CommandChild::LeReadMaximumDataLength(LeReadMaximumDataLengthPacket::new(self.command.clone())),CommandDataChild::LeEnhancedReceiverTest(_) => CommandChild::LeEnhancedReceiverTest(LeEnhancedReceiverTestPacket::new(self.command.clone())),CommandDataChild::LeEnhancedTransmitterTest(_) => CommandChild::LeEnhancedTransmitterTest(LeEnhancedTransmitterTestPacket::new(self.command.clone())),CommandDataChild::LeReadMaximumAdvertisingDataLength(_) => CommandChild::LeReadMaximumAdvertisingDataLength(LeReadMaximumAdvertisingDataLengthPacket::new(self.command.clone())),CommandDataChild::LeReadNumberOfSupportedAdvertisingSets(_) => CommandChild::LeReadNumberOfSupportedAdvertisingSets(LeReadNumberOfSupportedAdvertisingSetsPacket::new(self.command.clone())),CommandDataChild::LeReadPeriodicAdvertiserListSize(_) => CommandChild::LeReadPeriodicAdvertiserListSize(LeReadPeriodicAdvertiserListSizePacket::new(self.command.clone())),CommandDataChild::LeSetPeriodicAdvertisingReceiveEnable(_) => CommandChild::LeSetPeriodicAdvertisingReceiveEnable(LeSetPeriodicAdvertisingReceiveEnablePacket::new(self.command.clone())),CommandDataChild::LePeriodicAdvertisingSyncTransfer(_) => CommandChild::LePeriodicAdvertisingSyncTransfer(LePeriodicAdvertisingSyncTransferPacket::new(self.command.clone())),CommandDataChild::LePeriodicAdvertisingSetInfoTransfer(_) => CommandChild::LePeriodicAdvertisingSetInfoTransfer(LePeriodicAdvertisingSetInfoTransferPacket::new(self.command.clone())),CommandDataChild::LeSetPeriodicAdvertisingSyncTransferParameters(_) => CommandChild::LeSetPeriodicAdvertisingSyncTransferParameters(LeSetPeriodicAdvertisingSyncTransferParametersPacket::new(self.command.clone())),CommandDataChild::LeSetDefaultPeriodicAdvertisingSyncTransferParameters(_) => CommandChild::LeSetDefaultPeriodicAdvertisingSyncTransferParameters(LeSetDefaultPeriodicAdvertisingSyncTransferParametersPacket::new(self.command.clone())),CommandDataChild::LeModifySleepClockAccuracy(_) => CommandChild::LeModifySleepClockAccuracy(LeModifySleepClockAccuracyPacket::new(self.command.clone())),CommandDataChild::LeReadBufferSizeV2(_) => CommandChild::LeReadBufferSizeV2(LeReadBufferSizeV2Packet::new(self.command.clone())),CommandDataChild::LeRequestPeerSca(_) => CommandChild::LeRequestPeerSca(LeRequestPeerScaPacket::new(self.command.clone())),CommandDataChild::LeSetHostFeature(_) => CommandChild::LeSetHostFeature(LeSetHostFeaturePacket::new(self.command.clone())),CommandDataChild::LeEnhancedReadTransmitPowerLevel(_) => CommandChild::LeEnhancedReadTransmitPowerLevel(LeEnhancedReadTransmitPowerLevelPacket::new(self.command.clone())),CommandDataChild::LeReadRemoteTransmitPowerLevel(_) => CommandChild::LeReadRemoteTransmitPowerLevel(LeReadRemoteTransmitPowerLevelPacket::new(self.command.clone())),CommandDataChild::LeSetPathLossReportingParameters(_) => CommandChild::LeSetPathLossReportingParameters(LeSetPathLossReportingParametersPacket::new(self.command.clone())),CommandDataChild::LeSetPathLossReportingEnable(_) => CommandChild::LeSetPathLossReportingEnable(LeSetPathLossReportingEnablePacket::new(self.command.clone())),CommandDataChild::LeSetTransmitPowerReportingEnable(_) => CommandChild::LeSetTransmitPowerReportingEnable(LeSetTransmitPowerReportingEnablePacket::new(self.command.clone())),CommandDataChild::EnhancedFlush(_) => CommandChild::EnhancedFlush(EnhancedFlushPacket::new(self.command.clone())),CommandDataChild::Payload(p) => CommandChild::Payload(p.clone()),CommandDataChild::None => CommandChild::None,}} fn new(root: Arc<CommandData>) -> Self {let command = root;Self {command,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl CommandBuilder {pub fn build(self) -> CommandPacket {let command= Arc::new(CommandData {op_code: self.op_code, child: match self.payload { None => CommandDataChild::None,Some(bytes) => CommandDataChild::Payload(bytes),},});CommandPacket::new(command)}
}


#[derive(Debug)] enum DiscoveryCommandDataChild {Inquiry(Arc<InquiryData>),InquiryCancel(Arc<InquiryCancelData>),PeriodicInquiryMode(Arc<PeriodicInquiryModeData>),ExitPeriodicInquiryMode(Arc<ExitPeriodicInquiryModeData>),RemoteNameRequest(Arc<RemoteNameRequestData>),RemoteNameRequestCancel(Arc<RemoteNameRequestCancelData>),ReadPageTimeout(Arc<ReadPageTimeoutData>),WritePageTimeout(Arc<WritePageTimeoutData>),ReadScanEnable(Arc<ReadScanEnableData>),WriteScanEnable(Arc<WriteScanEnableData>),ReadPageScanActivity(Arc<ReadPageScanActivityData>),WritePageScanActivity(Arc<WritePageScanActivityData>),ReadInquiryScanActivity(Arc<ReadInquiryScanActivityData>),WriteInquiryScanActivity(Arc<WriteInquiryScanActivityData>),ReadClassOfDevice(Arc<ReadClassOfDeviceData>),WriteClassOfDevice(Arc<WriteClassOfDeviceData>),ReadNumberOfSupportedIac(Arc<ReadNumberOfSupportedIacData>),ReadCurrentIacLap(Arc<ReadCurrentIacLapData>),WriteCurrentIacLap(Arc<WriteCurrentIacLapData>),ReadInquiryScanType(Arc<ReadInquiryScanTypeData>),WriteInquiryScanType(Arc<WriteInquiryScanTypeData>),ReadInquiryMode(Arc<ReadInquiryModeData>),WriteInquiryMode(Arc<WriteInquiryModeData>),ReadPageScanType(Arc<ReadPageScanTypeData>),WritePageScanType(Arc<WritePageScanTypeData>),ReadInquiryResponseTransmitPowerLevel(Arc<ReadInquiryResponseTransmitPowerLevelData>),WriteInquiryTransmitPowerLevel(Arc<WriteInquiryTransmitPowerLevelData>),Payload(Bytes),None,}
impl DiscoveryCommandDataChild {fn get_total_size(&self) -> usize {match self {DiscoveryCommandDataChild::Inquiry(value) => value.get_total_size(),DiscoveryCommandDataChild::InquiryCancel(value) => value.get_total_size(),DiscoveryCommandDataChild::PeriodicInquiryMode(value) => value.get_total_size(),DiscoveryCommandDataChild::ExitPeriodicInquiryMode(value) => value.get_total_size(),DiscoveryCommandDataChild::RemoteNameRequest(value) => value.get_total_size(),DiscoveryCommandDataChild::RemoteNameRequestCancel(value) => value.get_total_size(),DiscoveryCommandDataChild::ReadPageTimeout(value) => value.get_total_size(),DiscoveryCommandDataChild::WritePageTimeout(value) => value.get_total_size(),DiscoveryCommandDataChild::ReadScanEnable(value) => value.get_total_size(),DiscoveryCommandDataChild::WriteScanEnable(value) => value.get_total_size(),DiscoveryCommandDataChild::ReadPageScanActivity(value) => value.get_total_size(),DiscoveryCommandDataChild::WritePageScanActivity(value) => value.get_total_size(),DiscoveryCommandDataChild::ReadInquiryScanActivity(value) => value.get_total_size(),DiscoveryCommandDataChild::WriteInquiryScanActivity(value) => value.get_total_size(),DiscoveryCommandDataChild::ReadClassOfDevice(value) => value.get_total_size(),DiscoveryCommandDataChild::WriteClassOfDevice(value) => value.get_total_size(),DiscoveryCommandDataChild::ReadNumberOfSupportedIac(value) => value.get_total_size(),DiscoveryCommandDataChild::ReadCurrentIacLap(value) => value.get_total_size(),DiscoveryCommandDataChild::WriteCurrentIacLap(value) => value.get_total_size(),DiscoveryCommandDataChild::ReadInquiryScanType(value) => value.get_total_size(),DiscoveryCommandDataChild::WriteInquiryScanType(value) => value.get_total_size(),DiscoveryCommandDataChild::ReadInquiryMode(value) => value.get_total_size(),DiscoveryCommandDataChild::WriteInquiryMode(value) => value.get_total_size(),DiscoveryCommandDataChild::ReadPageScanType(value) => value.get_total_size(),DiscoveryCommandDataChild::WritePageScanType(value) => value.get_total_size(),DiscoveryCommandDataChild::ReadInquiryResponseTransmitPowerLevel(value) => value.get_total_size(),DiscoveryCommandDataChild::WriteInquiryTransmitPowerLevel(value) => value.get_total_size(),DiscoveryCommandDataChild::Payload(p) => p.len(),DiscoveryCommandDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum DiscoveryCommandChild {Inquiry(InquiryPacket),InquiryCancel(InquiryCancelPacket),PeriodicInquiryMode(PeriodicInquiryModePacket),ExitPeriodicInquiryMode(ExitPeriodicInquiryModePacket),RemoteNameRequest(RemoteNameRequestPacket),RemoteNameRequestCancel(RemoteNameRequestCancelPacket),ReadPageTimeout(ReadPageTimeoutPacket),WritePageTimeout(WritePageTimeoutPacket),ReadScanEnable(ReadScanEnablePacket),WriteScanEnable(WriteScanEnablePacket),ReadPageScanActivity(ReadPageScanActivityPacket),WritePageScanActivity(WritePageScanActivityPacket),ReadInquiryScanActivity(ReadInquiryScanActivityPacket),WriteInquiryScanActivity(WriteInquiryScanActivityPacket),ReadClassOfDevice(ReadClassOfDevicePacket),WriteClassOfDevice(WriteClassOfDevicePacket),ReadNumberOfSupportedIac(ReadNumberOfSupportedIacPacket),ReadCurrentIacLap(ReadCurrentIacLapPacket),WriteCurrentIacLap(WriteCurrentIacLapPacket),ReadInquiryScanType(ReadInquiryScanTypePacket),WriteInquiryScanType(WriteInquiryScanTypePacket),ReadInquiryMode(ReadInquiryModePacket),WriteInquiryMode(WriteInquiryModePacket),ReadPageScanType(ReadPageScanTypePacket),WritePageScanType(WritePageScanTypePacket),ReadInquiryResponseTransmitPowerLevel(ReadInquiryResponseTransmitPowerLevelPacket),WriteInquiryTransmitPowerLevel(WriteInquiryTransmitPowerLevelPacket),Payload(Bytes),None,}
#[derive(Debug)] struct DiscoveryCommandData {child: DiscoveryCommandDataChild,}
#[derive(Debug, Clone)] pub struct DiscoveryCommandPacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,}
#[derive(Debug)] pub struct DiscoveryCommandBuilder {pub op_code: OpCode, pub payload: Option<Bytes>,}
impl DiscoveryCommandData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8], op_code: OpCode) -> Result<Self> {let payload: Vec::<u8> = bytes[3..].into();let child = match op_code {OpCode::Inquiry if InquiryData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::Inquiry(Arc::new(InquiryData::parse(&bytes[..])?))}
OpCode::InquiryCancel if InquiryCancelData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::InquiryCancel(Arc::new(InquiryCancelData::parse(&bytes[..])?))}
OpCode::PeriodicInquiryMode if PeriodicInquiryModeData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::PeriodicInquiryMode(Arc::new(PeriodicInquiryModeData::parse(&bytes[..])?))}
OpCode::ExitPeriodicInquiryMode if ExitPeriodicInquiryModeData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::ExitPeriodicInquiryMode(Arc::new(ExitPeriodicInquiryModeData::parse(&bytes[..])?))}
OpCode::RemoteNameRequest if RemoteNameRequestData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::RemoteNameRequest(Arc::new(RemoteNameRequestData::parse(&bytes[..])?))}
OpCode::RemoteNameRequestCancel if RemoteNameRequestCancelData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::RemoteNameRequestCancel(Arc::new(RemoteNameRequestCancelData::parse(&bytes[..])?))}
OpCode::ReadPageTimeout if ReadPageTimeoutData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::ReadPageTimeout(Arc::new(ReadPageTimeoutData::parse(&bytes[..])?))}
OpCode::WritePageTimeout if WritePageTimeoutData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::WritePageTimeout(Arc::new(WritePageTimeoutData::parse(&bytes[..])?))}
OpCode::ReadScanEnable if ReadScanEnableData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::ReadScanEnable(Arc::new(ReadScanEnableData::parse(&bytes[..])?))}
OpCode::WriteScanEnable if WriteScanEnableData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::WriteScanEnable(Arc::new(WriteScanEnableData::parse(&bytes[..])?))}
OpCode::ReadPageScanActivity if ReadPageScanActivityData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::ReadPageScanActivity(Arc::new(ReadPageScanActivityData::parse(&bytes[..])?))}
OpCode::WritePageScanActivity if WritePageScanActivityData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::WritePageScanActivity(Arc::new(WritePageScanActivityData::parse(&bytes[..])?))}
OpCode::ReadInquiryScanActivity if ReadInquiryScanActivityData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::ReadInquiryScanActivity(Arc::new(ReadInquiryScanActivityData::parse(&bytes[..])?))}
OpCode::WriteInquiryScanActivity if WriteInquiryScanActivityData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::WriteInquiryScanActivity(Arc::new(WriteInquiryScanActivityData::parse(&bytes[..])?))}
OpCode::ReadClassOfDevice if ReadClassOfDeviceData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::ReadClassOfDevice(Arc::new(ReadClassOfDeviceData::parse(&bytes[..])?))}
OpCode::WriteClassOfDevice if WriteClassOfDeviceData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::WriteClassOfDevice(Arc::new(WriteClassOfDeviceData::parse(&bytes[..])?))}
OpCode::ReadNumberOfSupportedIac if ReadNumberOfSupportedIacData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::ReadNumberOfSupportedIac(Arc::new(ReadNumberOfSupportedIacData::parse(&bytes[..])?))}
OpCode::ReadCurrentIacLap if ReadCurrentIacLapData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::ReadCurrentIacLap(Arc::new(ReadCurrentIacLapData::parse(&bytes[..])?))}
OpCode::WriteCurrentIacLap if WriteCurrentIacLapData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::WriteCurrentIacLap(Arc::new(WriteCurrentIacLapData::parse(&bytes[..])?))}
OpCode::ReadInquiryScanType if ReadInquiryScanTypeData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::ReadInquiryScanType(Arc::new(ReadInquiryScanTypeData::parse(&bytes[..])?))}
OpCode::WriteInquiryScanType if WriteInquiryScanTypeData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::WriteInquiryScanType(Arc::new(WriteInquiryScanTypeData::parse(&bytes[..])?))}
OpCode::ReadInquiryMode if ReadInquiryModeData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::ReadInquiryMode(Arc::new(ReadInquiryModeData::parse(&bytes[..])?))}
OpCode::WriteInquiryMode if WriteInquiryModeData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::WriteInquiryMode(Arc::new(WriteInquiryModeData::parse(&bytes[..])?))}
OpCode::ReadPageScanType if ReadPageScanTypeData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::ReadPageScanType(Arc::new(ReadPageScanTypeData::parse(&bytes[..])?))}
OpCode::WritePageScanType if WritePageScanTypeData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::WritePageScanType(Arc::new(WritePageScanTypeData::parse(&bytes[..])?))}
OpCode::ReadInquiryResponseTransmitPowerLevel if ReadInquiryResponseTransmitPowerLevelData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::ReadInquiryResponseTransmitPowerLevel(Arc::new(ReadInquiryResponseTransmitPowerLevelData::parse(&bytes[..])?))}
OpCode::WriteInquiryTransmitPowerLevel if WriteInquiryTransmitPowerLevelData::conforms(&bytes[..]) => {DiscoveryCommandDataChild::WriteInquiryTransmitPowerLevel(Arc::new(WriteInquiryTransmitPowerLevelData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "op_code".to_string(), value: v as u64}),};
Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {DiscoveryCommandDataChild::Inquiry(value) => value.write_to(buffer),DiscoveryCommandDataChild::InquiryCancel(value) => value.write_to(buffer),DiscoveryCommandDataChild::PeriodicInquiryMode(value) => value.write_to(buffer),DiscoveryCommandDataChild::ExitPeriodicInquiryMode(value) => value.write_to(buffer),DiscoveryCommandDataChild::RemoteNameRequest(value) => value.write_to(buffer),DiscoveryCommandDataChild::RemoteNameRequestCancel(value) => value.write_to(buffer),DiscoveryCommandDataChild::ReadPageTimeout(value) => value.write_to(buffer),DiscoveryCommandDataChild::WritePageTimeout(value) => value.write_to(buffer),DiscoveryCommandDataChild::ReadScanEnable(value) => value.write_to(buffer),DiscoveryCommandDataChild::WriteScanEnable(value) => value.write_to(buffer),DiscoveryCommandDataChild::ReadPageScanActivity(value) => value.write_to(buffer),DiscoveryCommandDataChild::WritePageScanActivity(value) => value.write_to(buffer),DiscoveryCommandDataChild::ReadInquiryScanActivity(value) => value.write_to(buffer),DiscoveryCommandDataChild::WriteInquiryScanActivity(value) => value.write_to(buffer),DiscoveryCommandDataChild::ReadClassOfDevice(value) => value.write_to(buffer),DiscoveryCommandDataChild::WriteClassOfDevice(value) => value.write_to(buffer),DiscoveryCommandDataChild::ReadNumberOfSupportedIac(value) => value.write_to(buffer),DiscoveryCommandDataChild::ReadCurrentIacLap(value) => value.write_to(buffer),DiscoveryCommandDataChild::WriteCurrentIacLap(value) => value.write_to(buffer),DiscoveryCommandDataChild::ReadInquiryScanType(value) => value.write_to(buffer),DiscoveryCommandDataChild::WriteInquiryScanType(value) => value.write_to(buffer),DiscoveryCommandDataChild::ReadInquiryMode(value) => value.write_to(buffer),DiscoveryCommandDataChild::WriteInquiryMode(value) => value.write_to(buffer),DiscoveryCommandDataChild::ReadPageScanType(value) => value.write_to(buffer),DiscoveryCommandDataChild::WritePageScanType(value) => value.write_to(buffer),DiscoveryCommandDataChild::ReadInquiryResponseTransmitPowerLevel(value) => value.write_to(buffer),DiscoveryCommandDataChild::WriteInquiryTransmitPowerLevel(value) => value.write_to(buffer),DiscoveryCommandDataChild::Payload(p) => buffer[3..].copy_from_slice(&p[..]),DiscoveryCommandDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for DiscoveryCommandPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl DiscoveryCommandPacket { pub fn specialize(&self) -> DiscoveryCommandChild { match &self.discovery_command.child {DiscoveryCommandDataChild::Inquiry(_) => DiscoveryCommandChild::Inquiry(InquiryPacket::new(self.command.clone())),DiscoveryCommandDataChild::InquiryCancel(_) => DiscoveryCommandChild::InquiryCancel(InquiryCancelPacket::new(self.command.clone())),DiscoveryCommandDataChild::PeriodicInquiryMode(_) => DiscoveryCommandChild::PeriodicInquiryMode(PeriodicInquiryModePacket::new(self.command.clone())),DiscoveryCommandDataChild::ExitPeriodicInquiryMode(_) => DiscoveryCommandChild::ExitPeriodicInquiryMode(ExitPeriodicInquiryModePacket::new(self.command.clone())),DiscoveryCommandDataChild::RemoteNameRequest(_) => DiscoveryCommandChild::RemoteNameRequest(RemoteNameRequestPacket::new(self.command.clone())),DiscoveryCommandDataChild::RemoteNameRequestCancel(_) => DiscoveryCommandChild::RemoteNameRequestCancel(RemoteNameRequestCancelPacket::new(self.command.clone())),DiscoveryCommandDataChild::ReadPageTimeout(_) => DiscoveryCommandChild::ReadPageTimeout(ReadPageTimeoutPacket::new(self.command.clone())),DiscoveryCommandDataChild::WritePageTimeout(_) => DiscoveryCommandChild::WritePageTimeout(WritePageTimeoutPacket::new(self.command.clone())),DiscoveryCommandDataChild::ReadScanEnable(_) => DiscoveryCommandChild::ReadScanEnable(ReadScanEnablePacket::new(self.command.clone())),DiscoveryCommandDataChild::WriteScanEnable(_) => DiscoveryCommandChild::WriteScanEnable(WriteScanEnablePacket::new(self.command.clone())),DiscoveryCommandDataChild::ReadPageScanActivity(_) => DiscoveryCommandChild::ReadPageScanActivity(ReadPageScanActivityPacket::new(self.command.clone())),DiscoveryCommandDataChild::WritePageScanActivity(_) => DiscoveryCommandChild::WritePageScanActivity(WritePageScanActivityPacket::new(self.command.clone())),DiscoveryCommandDataChild::ReadInquiryScanActivity(_) => DiscoveryCommandChild::ReadInquiryScanActivity(ReadInquiryScanActivityPacket::new(self.command.clone())),DiscoveryCommandDataChild::WriteInquiryScanActivity(_) => DiscoveryCommandChild::WriteInquiryScanActivity(WriteInquiryScanActivityPacket::new(self.command.clone())),DiscoveryCommandDataChild::ReadClassOfDevice(_) => DiscoveryCommandChild::ReadClassOfDevice(ReadClassOfDevicePacket::new(self.command.clone())),DiscoveryCommandDataChild::WriteClassOfDevice(_) => DiscoveryCommandChild::WriteClassOfDevice(WriteClassOfDevicePacket::new(self.command.clone())),DiscoveryCommandDataChild::ReadNumberOfSupportedIac(_) => DiscoveryCommandChild::ReadNumberOfSupportedIac(ReadNumberOfSupportedIacPacket::new(self.command.clone())),DiscoveryCommandDataChild::ReadCurrentIacLap(_) => DiscoveryCommandChild::ReadCurrentIacLap(ReadCurrentIacLapPacket::new(self.command.clone())),DiscoveryCommandDataChild::WriteCurrentIacLap(_) => DiscoveryCommandChild::WriteCurrentIacLap(WriteCurrentIacLapPacket::new(self.command.clone())),DiscoveryCommandDataChild::ReadInquiryScanType(_) => DiscoveryCommandChild::ReadInquiryScanType(ReadInquiryScanTypePacket::new(self.command.clone())),DiscoveryCommandDataChild::WriteInquiryScanType(_) => DiscoveryCommandChild::WriteInquiryScanType(WriteInquiryScanTypePacket::new(self.command.clone())),DiscoveryCommandDataChild::ReadInquiryMode(_) => DiscoveryCommandChild::ReadInquiryMode(ReadInquiryModePacket::new(self.command.clone())),DiscoveryCommandDataChild::WriteInquiryMode(_) => DiscoveryCommandChild::WriteInquiryMode(WriteInquiryModePacket::new(self.command.clone())),DiscoveryCommandDataChild::ReadPageScanType(_) => DiscoveryCommandChild::ReadPageScanType(ReadPageScanTypePacket::new(self.command.clone())),DiscoveryCommandDataChild::WritePageScanType(_) => DiscoveryCommandChild::WritePageScanType(WritePageScanTypePacket::new(self.command.clone())),DiscoveryCommandDataChild::ReadInquiryResponseTransmitPowerLevel(_) => DiscoveryCommandChild::ReadInquiryResponseTransmitPowerLevel(ReadInquiryResponseTransmitPowerLevelPacket::new(self.command.clone())),DiscoveryCommandDataChild::WriteInquiryTransmitPowerLevel(_) => DiscoveryCommandChild::WriteInquiryTransmitPowerLevel(WriteInquiryTransmitPowerLevelPacket::new(self.command.clone())),DiscoveryCommandDataChild::Payload(p) => DiscoveryCommandChild::Payload(p.clone()),DiscoveryCommandDataChild::None => DiscoveryCommandChild::None,}} fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};Self {command,discovery_command,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for DiscoveryCommandPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl DiscoveryCommandBuilder {pub fn build(self) -> DiscoveryCommandPacket {let discovery_command= Arc::new(DiscoveryCommandData {child: match self.payload { None => DiscoveryCommandDataChild::None,Some(bytes) => DiscoveryCommandDataChild::Payload(bytes),},});let command= Arc::new(CommandData {op_code: self.op_code, child: CommandDataChild::DiscoveryCommand(discovery_command),});DiscoveryCommandPacket::new(command)}
}
impl Into<CommandPacket> for DiscoveryCommandBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] enum AclCommandDataChild {ConnectionManagementCommand(Arc<ConnectionManagementCommandData>),ScoConnectionCommand(Arc<ScoConnectionCommandData>),LeConnectionManagementCommand(Arc<LeConnectionManagementCommandData>),Disconnect(Arc<DisconnectData>),ReadRemoteVersionInformation(Arc<ReadRemoteVersionInformationData>),ReadRssi(Arc<ReadRssiData>),Payload(Bytes),None,}
impl AclCommandDataChild {fn get_total_size(&self) -> usize {match self {AclCommandDataChild::ConnectionManagementCommand(value) => value.get_total_size(),AclCommandDataChild::ScoConnectionCommand(value) => value.get_total_size(),AclCommandDataChild::LeConnectionManagementCommand(value) => value.get_total_size(),AclCommandDataChild::Disconnect(value) => value.get_total_size(),AclCommandDataChild::ReadRemoteVersionInformation(value) => value.get_total_size(),AclCommandDataChild::ReadRssi(value) => value.get_total_size(),AclCommandDataChild::Payload(p) => p.len(),AclCommandDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum AclCommandChild {ConnectionManagementCommand(ConnectionManagementCommandPacket),ScoConnectionCommand(ScoConnectionCommandPacket),LeConnectionManagementCommand(LeConnectionManagementCommandPacket),Disconnect(DisconnectPacket),ReadRemoteVersionInformation(ReadRemoteVersionInformationPacket),ReadRssi(ReadRssiPacket),Payload(Bytes),None,}
#[derive(Debug)] struct AclCommandData {child: AclCommandDataChild,}
#[derive(Debug, Clone)] pub struct AclCommandPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,}
#[derive(Debug)] pub struct AclCommandBuilder {pub op_code: OpCode, pub payload: Option<Bytes>,}
impl AclCommandData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8], op_code: OpCode) -> Result<Self> {let payload: Vec::<u8> = bytes[3..].into();let child = match op_code {OpCode::CreateConnection if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::CreateConnection)?))}
OpCode::Disconnect if DisconnectData::conforms(&bytes[..]) => {AclCommandDataChild::Disconnect(Arc::new(DisconnectData::parse(&bytes[..])?))}
OpCode::CreateConnectionCancel if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::CreateConnectionCancel)?))}
OpCode::AcceptConnectionRequest if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::AcceptConnectionRequest)?))}
OpCode::RejectConnectionRequest if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::RejectConnectionRequest)?))}
OpCode::ChangeConnectionPacketType if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::ChangeConnectionPacketType)?))}
OpCode::AuthenticationRequested if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::AuthenticationRequested)?))}
OpCode::SetConnectionEncryption if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::SetConnectionEncryption)?))}
OpCode::ChangeConnectionLinkKey if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::ChangeConnectionLinkKey)?))}
OpCode::CentralLinkKey if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::CentralLinkKey)?))}
OpCode::ReadRemoteSupportedFeatures if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::ReadRemoteSupportedFeatures)?))}
OpCode::ReadRemoteExtendedFeatures if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::ReadRemoteExtendedFeatures)?))}
OpCode::ReadRemoteVersionInformation if ReadRemoteVersionInformationData::conforms(&bytes[..]) => {AclCommandDataChild::ReadRemoteVersionInformation(Arc::new(ReadRemoteVersionInformationData::parse(&bytes[..])?))}
OpCode::ReadClockOffset if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::ReadClockOffset)?))}
OpCode::ReadLmpHandle if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::ReadLmpHandle)?))}
OpCode::SetupSynchronousConnection if ScoConnectionCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ScoConnectionCommand(Arc::new(ScoConnectionCommandData::parse(&bytes[..], OpCode::SetupSynchronousConnection)?))}
OpCode::AcceptSynchronousConnection if ScoConnectionCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ScoConnectionCommand(Arc::new(ScoConnectionCommandData::parse(&bytes[..], OpCode::AcceptSynchronousConnection)?))}
OpCode::RejectSynchronousConnection if ScoConnectionCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ScoConnectionCommand(Arc::new(ScoConnectionCommandData::parse(&bytes[..], OpCode::RejectSynchronousConnection)?))}
OpCode::EnhancedSetupSynchronousConnection if ScoConnectionCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ScoConnectionCommand(Arc::new(ScoConnectionCommandData::parse(&bytes[..], OpCode::EnhancedSetupSynchronousConnection)?))}
OpCode::EnhancedAcceptSynchronousConnection if ScoConnectionCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ScoConnectionCommand(Arc::new(ScoConnectionCommandData::parse(&bytes[..], OpCode::EnhancedAcceptSynchronousConnection)?))}
OpCode::HoldMode if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::HoldMode)?))}
OpCode::SniffMode if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::SniffMode)?))}
OpCode::ExitSniffMode if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::ExitSniffMode)?))}
OpCode::QosSetup if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::QosSetup)?))}
OpCode::RoleDiscovery if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::RoleDiscovery)?))}
OpCode::SwitchRole if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::SwitchRole)?))}
OpCode::ReadLinkPolicySettings if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::ReadLinkPolicySettings)?))}
OpCode::Flush if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::Flush)?))}
OpCode::WriteLinkPolicySettings if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::WriteLinkPolicySettings)?))}
OpCode::ReadDefaultLinkPolicySettings if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::ReadDefaultLinkPolicySettings)?))}
OpCode::WriteDefaultLinkPolicySettings if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::WriteDefaultLinkPolicySettings)?))}
OpCode::FlowSpecification if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::FlowSpecification)?))}
OpCode::SniffSubrating if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::SniffSubrating)?))}
OpCode::ReadConnectionAcceptTimeout if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::ReadConnectionAcceptTimeout)?))}
OpCode::WriteConnectionAcceptTimeout if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::WriteConnectionAcceptTimeout)?))}
OpCode::ReadAutomaticFlushTimeout if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::ReadAutomaticFlushTimeout)?))}
OpCode::WriteAutomaticFlushTimeout if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::WriteAutomaticFlushTimeout)?))}
OpCode::ReadTransmitPowerLevel if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::ReadTransmitPowerLevel)?))}
OpCode::ReadLinkSupervisionTimeout if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::ReadLinkSupervisionTimeout)?))}
OpCode::WriteLinkSupervisionTimeout if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::WriteLinkSupervisionTimeout)?))}
OpCode::ReadFailedContactCounter if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::ReadFailedContactCounter)?))}
OpCode::ResetFailedContactCounter if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::ResetFailedContactCounter)?))}
OpCode::ReadLinkQuality if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::ReadLinkQuality)?))}
OpCode::ReadRssi if ReadRssiData::conforms(&bytes[..]) => {AclCommandDataChild::ReadRssi(Arc::new(ReadRssiData::parse(&bytes[..])?))}
OpCode::ReadAfhChannelMap if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::ReadAfhChannelMap)?))}
OpCode::ReadClock if ConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::ConnectionManagementCommand(Arc::new(ConnectionManagementCommandData::parse(&bytes[..], OpCode::ReadClock)?))}
OpCode::LeCreateConnection if LeConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::LeConnectionManagementCommand(Arc::new(LeConnectionManagementCommandData::parse(&bytes[..], OpCode::LeCreateConnection)?))}
OpCode::LeCreateConnectionCancel if LeConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::LeConnectionManagementCommand(Arc::new(LeConnectionManagementCommandData::parse(&bytes[..], OpCode::LeCreateConnectionCancel)?))}
OpCode::LeClearConnectList if LeConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::LeConnectionManagementCommand(Arc::new(LeConnectionManagementCommandData::parse(&bytes[..], OpCode::LeClearConnectList)?))}
OpCode::LeAddDeviceToConnectList if LeConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::LeConnectionManagementCommand(Arc::new(LeConnectionManagementCommandData::parse(&bytes[..], OpCode::LeAddDeviceToConnectList)?))}
OpCode::LeRemoveDeviceFromConnectList if LeConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::LeConnectionManagementCommand(Arc::new(LeConnectionManagementCommandData::parse(&bytes[..], OpCode::LeRemoveDeviceFromConnectList)?))}
OpCode::LeConnectionUpdate if LeConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::LeConnectionManagementCommand(Arc::new(LeConnectionManagementCommandData::parse(&bytes[..], OpCode::LeConnectionUpdate)?))}
OpCode::LeSetHostChannelClassification if LeConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::LeConnectionManagementCommand(Arc::new(LeConnectionManagementCommandData::parse(&bytes[..], OpCode::LeSetHostChannelClassification)?))}
OpCode::LeReadChannelMap if LeConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::LeConnectionManagementCommand(Arc::new(LeConnectionManagementCommandData::parse(&bytes[..], OpCode::LeReadChannelMap)?))}
OpCode::LeReadRemoteFeatures if LeConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::LeConnectionManagementCommand(Arc::new(LeConnectionManagementCommandData::parse(&bytes[..], OpCode::LeReadRemoteFeatures)?))}
OpCode::LeRemoteConnectionParameterRequestReply if LeConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::LeConnectionManagementCommand(Arc::new(LeConnectionManagementCommandData::parse(&bytes[..], OpCode::LeRemoteConnectionParameterRequestReply)?))}
OpCode::LeRemoteConnectionParameterRequestNegativeReply if LeConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::LeConnectionManagementCommand(Arc::new(LeConnectionManagementCommandData::parse(&bytes[..], OpCode::LeRemoteConnectionParameterRequestNegativeReply)?))}
OpCode::LeSetDataLength if LeConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::LeConnectionManagementCommand(Arc::new(LeConnectionManagementCommandData::parse(&bytes[..], OpCode::LeSetDataLength)?))}
OpCode::LeReadSuggestedDefaultDataLength if LeConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::LeConnectionManagementCommand(Arc::new(LeConnectionManagementCommandData::parse(&bytes[..], OpCode::LeReadSuggestedDefaultDataLength)?))}
OpCode::LeWriteSuggestedDefaultDataLength if LeConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::LeConnectionManagementCommand(Arc::new(LeConnectionManagementCommandData::parse(&bytes[..], OpCode::LeWriteSuggestedDefaultDataLength)?))}
OpCode::LeReadPhy if LeConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::LeConnectionManagementCommand(Arc::new(LeConnectionManagementCommandData::parse(&bytes[..], OpCode::LeReadPhy)?))}
OpCode::LeSetDefaultPhy if LeConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::LeConnectionManagementCommand(Arc::new(LeConnectionManagementCommandData::parse(&bytes[..], OpCode::LeSetDefaultPhy)?))}
OpCode::LeSetPhy if LeConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::LeConnectionManagementCommand(Arc::new(LeConnectionManagementCommandData::parse(&bytes[..], OpCode::LeSetPhy)?))}
OpCode::LeExtendedCreateConnection if LeConnectionManagementCommandData::conforms(&bytes[..]) => {AclCommandDataChild::LeConnectionManagementCommand(Arc::new(LeConnectionManagementCommandData::parse(&bytes[..], OpCode::LeExtendedCreateConnection)?))}
v => return Err(Error::ConstraintOutOfBounds{field: "op_code".to_string(), value: v as u64}),};
Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {AclCommandDataChild::ConnectionManagementCommand(value) => value.write_to(buffer),AclCommandDataChild::ScoConnectionCommand(value) => value.write_to(buffer),AclCommandDataChild::LeConnectionManagementCommand(value) => value.write_to(buffer),AclCommandDataChild::Disconnect(value) => value.write_to(buffer),AclCommandDataChild::ReadRemoteVersionInformation(value) => value.write_to(buffer),AclCommandDataChild::ReadRssi(value) => value.write_to(buffer),AclCommandDataChild::Payload(p) => buffer[3..].copy_from_slice(&p[..]),AclCommandDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for AclCommandPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl AclCommandPacket { pub fn specialize(&self) -> AclCommandChild { match &self.acl_command.child {AclCommandDataChild::ConnectionManagementCommand(_) => AclCommandChild::ConnectionManagementCommand(ConnectionManagementCommandPacket::new(self.command.clone())),AclCommandDataChild::ScoConnectionCommand(_) => AclCommandChild::ScoConnectionCommand(ScoConnectionCommandPacket::new(self.command.clone())),AclCommandDataChild::LeConnectionManagementCommand(_) => AclCommandChild::LeConnectionManagementCommand(LeConnectionManagementCommandPacket::new(self.command.clone())),AclCommandDataChild::Disconnect(_) => AclCommandChild::Disconnect(DisconnectPacket::new(self.command.clone())),AclCommandDataChild::ReadRemoteVersionInformation(_) => AclCommandChild::ReadRemoteVersionInformation(ReadRemoteVersionInformationPacket::new(self.command.clone())),AclCommandDataChild::ReadRssi(_) => AclCommandChild::ReadRssi(ReadRssiPacket::new(self.command.clone())),AclCommandDataChild::Payload(p) => AclCommandChild::Payload(p.clone()),AclCommandDataChild::None => AclCommandChild::None,}} fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};Self {command,acl_command,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for AclCommandPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl AclCommandBuilder {pub fn build(self) -> AclCommandPacket {let acl_command= Arc::new(AclCommandData {child: match self.payload { None => AclCommandDataChild::None,Some(bytes) => AclCommandDataChild::Payload(bytes),},});let command= Arc::new(CommandData {op_code: self.op_code, child: CommandDataChild::AclCommand(acl_command),});AclCommandPacket::new(command)}
}
impl Into<CommandPacket> for AclCommandBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] enum ConnectionManagementCommandDataChild {CreateConnection(Arc<CreateConnectionData>),CreateConnectionCancel(Arc<CreateConnectionCancelData>),AcceptConnectionRequest(Arc<AcceptConnectionRequestData>),RejectConnectionRequest(Arc<RejectConnectionRequestData>),ChangeConnectionPacketType(Arc<ChangeConnectionPacketTypeData>),AuthenticationRequested(Arc<AuthenticationRequestedData>),SetConnectionEncryption(Arc<SetConnectionEncryptionData>),ChangeConnectionLinkKey(Arc<ChangeConnectionLinkKeyData>),CentralLinkKey(Arc<CentralLinkKeyData>),ReadRemoteSupportedFeatures(Arc<ReadRemoteSupportedFeaturesData>),ReadRemoteExtendedFeatures(Arc<ReadRemoteExtendedFeaturesData>),ReadClockOffset(Arc<ReadClockOffsetData>),ReadLmpHandle(Arc<ReadLmpHandleData>),HoldMode(Arc<HoldModeData>),SniffMode(Arc<SniffModeData>),ExitSniffMode(Arc<ExitSniffModeData>),QosSetup(Arc<QosSetupData>),RoleDiscovery(Arc<RoleDiscoveryData>),SwitchRole(Arc<SwitchRoleData>),ReadLinkPolicySettings(Arc<ReadLinkPolicySettingsData>),WriteLinkPolicySettings(Arc<WriteLinkPolicySettingsData>),ReadDefaultLinkPolicySettings(Arc<ReadDefaultLinkPolicySettingsData>),WriteDefaultLinkPolicySettings(Arc<WriteDefaultLinkPolicySettingsData>),FlowSpecification(Arc<FlowSpecificationData>),SniffSubrating(Arc<SniffSubratingData>),Flush(Arc<FlushData>),ReadConnectionAcceptTimeout(Arc<ReadConnectionAcceptTimeoutData>),WriteConnectionAcceptTimeout(Arc<WriteConnectionAcceptTimeoutData>),ReadAutomaticFlushTimeout(Arc<ReadAutomaticFlushTimeoutData>),WriteAutomaticFlushTimeout(Arc<WriteAutomaticFlushTimeoutData>),ReadTransmitPowerLevel(Arc<ReadTransmitPowerLevelData>),ReadLinkSupervisionTimeout(Arc<ReadLinkSupervisionTimeoutData>),WriteLinkSupervisionTimeout(Arc<WriteLinkSupervisionTimeoutData>),ReadFailedContactCounter(Arc<ReadFailedContactCounterData>),ResetFailedContactCounter(Arc<ResetFailedContactCounterData>),ReadLinkQuality(Arc<ReadLinkQualityData>),ReadAfhChannelMap(Arc<ReadAfhChannelMapData>),ReadClock(Arc<ReadClockData>),Payload(Bytes),None,}
impl ConnectionManagementCommandDataChild {fn get_total_size(&self) -> usize {match self {ConnectionManagementCommandDataChild::CreateConnection(value) => value.get_total_size(),ConnectionManagementCommandDataChild::CreateConnectionCancel(value) => value.get_total_size(),ConnectionManagementCommandDataChild::AcceptConnectionRequest(value) => value.get_total_size(),ConnectionManagementCommandDataChild::RejectConnectionRequest(value) => value.get_total_size(),ConnectionManagementCommandDataChild::ChangeConnectionPacketType(value) => value.get_total_size(),ConnectionManagementCommandDataChild::AuthenticationRequested(value) => value.get_total_size(),ConnectionManagementCommandDataChild::SetConnectionEncryption(value) => value.get_total_size(),ConnectionManagementCommandDataChild::ChangeConnectionLinkKey(value) => value.get_total_size(),ConnectionManagementCommandDataChild::CentralLinkKey(value) => value.get_total_size(),ConnectionManagementCommandDataChild::ReadRemoteSupportedFeatures(value) => value.get_total_size(),ConnectionManagementCommandDataChild::ReadRemoteExtendedFeatures(value) => value.get_total_size(),ConnectionManagementCommandDataChild::ReadClockOffset(value) => value.get_total_size(),ConnectionManagementCommandDataChild::ReadLmpHandle(value) => value.get_total_size(),ConnectionManagementCommandDataChild::HoldMode(value) => value.get_total_size(),ConnectionManagementCommandDataChild::SniffMode(value) => value.get_total_size(),ConnectionManagementCommandDataChild::ExitSniffMode(value) => value.get_total_size(),ConnectionManagementCommandDataChild::QosSetup(value) => value.get_total_size(),ConnectionManagementCommandDataChild::RoleDiscovery(value) => value.get_total_size(),ConnectionManagementCommandDataChild::SwitchRole(value) => value.get_total_size(),ConnectionManagementCommandDataChild::ReadLinkPolicySettings(value) => value.get_total_size(),ConnectionManagementCommandDataChild::WriteLinkPolicySettings(value) => value.get_total_size(),ConnectionManagementCommandDataChild::ReadDefaultLinkPolicySettings(value) => value.get_total_size(),ConnectionManagementCommandDataChild::WriteDefaultLinkPolicySettings(value) => value.get_total_size(),ConnectionManagementCommandDataChild::FlowSpecification(value) => value.get_total_size(),ConnectionManagementCommandDataChild::SniffSubrating(value) => value.get_total_size(),ConnectionManagementCommandDataChild::Flush(value) => value.get_total_size(),ConnectionManagementCommandDataChild::ReadConnectionAcceptTimeout(value) => value.get_total_size(),ConnectionManagementCommandDataChild::WriteConnectionAcceptTimeout(value) => value.get_total_size(),ConnectionManagementCommandDataChild::ReadAutomaticFlushTimeout(value) => value.get_total_size(),ConnectionManagementCommandDataChild::WriteAutomaticFlushTimeout(value) => value.get_total_size(),ConnectionManagementCommandDataChild::ReadTransmitPowerLevel(value) => value.get_total_size(),ConnectionManagementCommandDataChild::ReadLinkSupervisionTimeout(value) => value.get_total_size(),ConnectionManagementCommandDataChild::WriteLinkSupervisionTimeout(value) => value.get_total_size(),ConnectionManagementCommandDataChild::ReadFailedContactCounter(value) => value.get_total_size(),ConnectionManagementCommandDataChild::ResetFailedContactCounter(value) => value.get_total_size(),ConnectionManagementCommandDataChild::ReadLinkQuality(value) => value.get_total_size(),ConnectionManagementCommandDataChild::ReadAfhChannelMap(value) => value.get_total_size(),ConnectionManagementCommandDataChild::ReadClock(value) => value.get_total_size(),ConnectionManagementCommandDataChild::Payload(p) => p.len(),ConnectionManagementCommandDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum ConnectionManagementCommandChild {CreateConnection(CreateConnectionPacket),CreateConnectionCancel(CreateConnectionCancelPacket),AcceptConnectionRequest(AcceptConnectionRequestPacket),RejectConnectionRequest(RejectConnectionRequestPacket),ChangeConnectionPacketType(ChangeConnectionPacketTypePacket),AuthenticationRequested(AuthenticationRequestedPacket),SetConnectionEncryption(SetConnectionEncryptionPacket),ChangeConnectionLinkKey(ChangeConnectionLinkKeyPacket),CentralLinkKey(CentralLinkKeyPacket),ReadRemoteSupportedFeatures(ReadRemoteSupportedFeaturesPacket),ReadRemoteExtendedFeatures(ReadRemoteExtendedFeaturesPacket),ReadClockOffset(ReadClockOffsetPacket),ReadLmpHandle(ReadLmpHandlePacket),HoldMode(HoldModePacket),SniffMode(SniffModePacket),ExitSniffMode(ExitSniffModePacket),QosSetup(QosSetupPacket),RoleDiscovery(RoleDiscoveryPacket),SwitchRole(SwitchRolePacket),ReadLinkPolicySettings(ReadLinkPolicySettingsPacket),WriteLinkPolicySettings(WriteLinkPolicySettingsPacket),ReadDefaultLinkPolicySettings(ReadDefaultLinkPolicySettingsPacket),WriteDefaultLinkPolicySettings(WriteDefaultLinkPolicySettingsPacket),FlowSpecification(FlowSpecificationPacket),SniffSubrating(SniffSubratingPacket),Flush(FlushPacket),ReadConnectionAcceptTimeout(ReadConnectionAcceptTimeoutPacket),WriteConnectionAcceptTimeout(WriteConnectionAcceptTimeoutPacket),ReadAutomaticFlushTimeout(ReadAutomaticFlushTimeoutPacket),WriteAutomaticFlushTimeout(WriteAutomaticFlushTimeoutPacket),ReadTransmitPowerLevel(ReadTransmitPowerLevelPacket),ReadLinkSupervisionTimeout(ReadLinkSupervisionTimeoutPacket),WriteLinkSupervisionTimeout(WriteLinkSupervisionTimeoutPacket),ReadFailedContactCounter(ReadFailedContactCounterPacket),ResetFailedContactCounter(ResetFailedContactCounterPacket),ReadLinkQuality(ReadLinkQualityPacket),ReadAfhChannelMap(ReadAfhChannelMapPacket),ReadClock(ReadClockPacket),Payload(Bytes),None,}
#[derive(Debug)] struct ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild,}
#[derive(Debug, Clone)] pub struct ConnectionManagementCommandPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,}
#[derive(Debug)] pub struct ConnectionManagementCommandBuilder {pub op_code: OpCode, pub payload: Option<Bytes>,}
impl ConnectionManagementCommandData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8], op_code: OpCode) -> Result<Self> {let payload: Vec::<u8> = bytes[3..].into();let child = match op_code {OpCode::CreateConnection if CreateConnectionData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::CreateConnection(Arc::new(CreateConnectionData::parse(&bytes[..])?))}
OpCode::CreateConnectionCancel if CreateConnectionCancelData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::CreateConnectionCancel(Arc::new(CreateConnectionCancelData::parse(&bytes[..])?))}
OpCode::AcceptConnectionRequest if AcceptConnectionRequestData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::AcceptConnectionRequest(Arc::new(AcceptConnectionRequestData::parse(&bytes[..])?))}
OpCode::RejectConnectionRequest if RejectConnectionRequestData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::RejectConnectionRequest(Arc::new(RejectConnectionRequestData::parse(&bytes[..])?))}
OpCode::ChangeConnectionPacketType if ChangeConnectionPacketTypeData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::ChangeConnectionPacketType(Arc::new(ChangeConnectionPacketTypeData::parse(&bytes[..])?))}
OpCode::AuthenticationRequested if AuthenticationRequestedData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::AuthenticationRequested(Arc::new(AuthenticationRequestedData::parse(&bytes[..])?))}
OpCode::SetConnectionEncryption if SetConnectionEncryptionData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::SetConnectionEncryption(Arc::new(SetConnectionEncryptionData::parse(&bytes[..])?))}
OpCode::ChangeConnectionLinkKey if ChangeConnectionLinkKeyData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::ChangeConnectionLinkKey(Arc::new(ChangeConnectionLinkKeyData::parse(&bytes[..])?))}
OpCode::CentralLinkKey if CentralLinkKeyData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::CentralLinkKey(Arc::new(CentralLinkKeyData::parse(&bytes[..])?))}
OpCode::ReadRemoteSupportedFeatures if ReadRemoteSupportedFeaturesData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::ReadRemoteSupportedFeatures(Arc::new(ReadRemoteSupportedFeaturesData::parse(&bytes[..])?))}
OpCode::ReadRemoteExtendedFeatures if ReadRemoteExtendedFeaturesData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::ReadRemoteExtendedFeatures(Arc::new(ReadRemoteExtendedFeaturesData::parse(&bytes[..])?))}
OpCode::ReadClockOffset if ReadClockOffsetData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::ReadClockOffset(Arc::new(ReadClockOffsetData::parse(&bytes[..])?))}
OpCode::ReadLmpHandle if ReadLmpHandleData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::ReadLmpHandle(Arc::new(ReadLmpHandleData::parse(&bytes[..])?))}
OpCode::HoldMode if HoldModeData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::HoldMode(Arc::new(HoldModeData::parse(&bytes[..])?))}
OpCode::SniffMode if SniffModeData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::SniffMode(Arc::new(SniffModeData::parse(&bytes[..])?))}
OpCode::ExitSniffMode if ExitSniffModeData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::ExitSniffMode(Arc::new(ExitSniffModeData::parse(&bytes[..])?))}
OpCode::QosSetup if QosSetupData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::QosSetup(Arc::new(QosSetupData::parse(&bytes[..])?))}
OpCode::RoleDiscovery if RoleDiscoveryData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::RoleDiscovery(Arc::new(RoleDiscoveryData::parse(&bytes[..])?))}
OpCode::SwitchRole if SwitchRoleData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::SwitchRole(Arc::new(SwitchRoleData::parse(&bytes[..])?))}
OpCode::ReadLinkPolicySettings if ReadLinkPolicySettingsData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::ReadLinkPolicySettings(Arc::new(ReadLinkPolicySettingsData::parse(&bytes[..])?))}
OpCode::Flush if FlushData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::Flush(Arc::new(FlushData::parse(&bytes[..])?))}
OpCode::WriteLinkPolicySettings if WriteLinkPolicySettingsData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::WriteLinkPolicySettings(Arc::new(WriteLinkPolicySettingsData::parse(&bytes[..])?))}
OpCode::ReadDefaultLinkPolicySettings if ReadDefaultLinkPolicySettingsData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::ReadDefaultLinkPolicySettings(Arc::new(ReadDefaultLinkPolicySettingsData::parse(&bytes[..])?))}
OpCode::WriteDefaultLinkPolicySettings if WriteDefaultLinkPolicySettingsData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::WriteDefaultLinkPolicySettings(Arc::new(WriteDefaultLinkPolicySettingsData::parse(&bytes[..])?))}
OpCode::FlowSpecification if FlowSpecificationData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::FlowSpecification(Arc::new(FlowSpecificationData::parse(&bytes[..])?))}
OpCode::SniffSubrating if SniffSubratingData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::SniffSubrating(Arc::new(SniffSubratingData::parse(&bytes[..])?))}
OpCode::ReadConnectionAcceptTimeout if ReadConnectionAcceptTimeoutData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::ReadConnectionAcceptTimeout(Arc::new(ReadConnectionAcceptTimeoutData::parse(&bytes[..])?))}
OpCode::WriteConnectionAcceptTimeout if WriteConnectionAcceptTimeoutData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::WriteConnectionAcceptTimeout(Arc::new(WriteConnectionAcceptTimeoutData::parse(&bytes[..])?))}
OpCode::ReadAutomaticFlushTimeout if ReadAutomaticFlushTimeoutData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::ReadAutomaticFlushTimeout(Arc::new(ReadAutomaticFlushTimeoutData::parse(&bytes[..])?))}
OpCode::WriteAutomaticFlushTimeout if WriteAutomaticFlushTimeoutData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::WriteAutomaticFlushTimeout(Arc::new(WriteAutomaticFlushTimeoutData::parse(&bytes[..])?))}
OpCode::ReadTransmitPowerLevel if ReadTransmitPowerLevelData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::ReadTransmitPowerLevel(Arc::new(ReadTransmitPowerLevelData::parse(&bytes[..])?))}
OpCode::ReadLinkSupervisionTimeout if ReadLinkSupervisionTimeoutData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::ReadLinkSupervisionTimeout(Arc::new(ReadLinkSupervisionTimeoutData::parse(&bytes[..])?))}
OpCode::WriteLinkSupervisionTimeout if WriteLinkSupervisionTimeoutData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::WriteLinkSupervisionTimeout(Arc::new(WriteLinkSupervisionTimeoutData::parse(&bytes[..])?))}
OpCode::ReadFailedContactCounter if ReadFailedContactCounterData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::ReadFailedContactCounter(Arc::new(ReadFailedContactCounterData::parse(&bytes[..])?))}
OpCode::ResetFailedContactCounter if ResetFailedContactCounterData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::ResetFailedContactCounter(Arc::new(ResetFailedContactCounterData::parse(&bytes[..])?))}
OpCode::ReadLinkQuality if ReadLinkQualityData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::ReadLinkQuality(Arc::new(ReadLinkQualityData::parse(&bytes[..])?))}
OpCode::ReadAfhChannelMap if ReadAfhChannelMapData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::ReadAfhChannelMap(Arc::new(ReadAfhChannelMapData::parse(&bytes[..])?))}
OpCode::ReadClock if ReadClockData::conforms(&bytes[..]) => {ConnectionManagementCommandDataChild::ReadClock(Arc::new(ReadClockData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "op_code".to_string(), value: v as u64}),};
Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {ConnectionManagementCommandDataChild::CreateConnection(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::CreateConnectionCancel(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::AcceptConnectionRequest(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::RejectConnectionRequest(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::ChangeConnectionPacketType(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::AuthenticationRequested(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::SetConnectionEncryption(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::ChangeConnectionLinkKey(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::CentralLinkKey(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::ReadRemoteSupportedFeatures(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::ReadRemoteExtendedFeatures(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::ReadClockOffset(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::ReadLmpHandle(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::HoldMode(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::SniffMode(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::ExitSniffMode(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::QosSetup(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::RoleDiscovery(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::SwitchRole(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::ReadLinkPolicySettings(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::WriteLinkPolicySettings(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::ReadDefaultLinkPolicySettings(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::WriteDefaultLinkPolicySettings(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::FlowSpecification(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::SniffSubrating(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::Flush(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::ReadConnectionAcceptTimeout(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::WriteConnectionAcceptTimeout(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::ReadAutomaticFlushTimeout(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::WriteAutomaticFlushTimeout(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::ReadTransmitPowerLevel(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::ReadLinkSupervisionTimeout(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::WriteLinkSupervisionTimeout(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::ReadFailedContactCounter(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::ResetFailedContactCounter(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::ReadLinkQuality(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::ReadAfhChannelMap(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::ReadClock(value) => value.write_to(buffer),ConnectionManagementCommandDataChild::Payload(p) => buffer[3..].copy_from_slice(&p[..]),ConnectionManagementCommandDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for ConnectionManagementCommandPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ConnectionManagementCommandPacket { pub fn specialize(&self) -> ConnectionManagementCommandChild { match &self.connection_management_command.child {ConnectionManagementCommandDataChild::CreateConnection(_) => ConnectionManagementCommandChild::CreateConnection(CreateConnectionPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::CreateConnectionCancel(_) => ConnectionManagementCommandChild::CreateConnectionCancel(CreateConnectionCancelPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::AcceptConnectionRequest(_) => ConnectionManagementCommandChild::AcceptConnectionRequest(AcceptConnectionRequestPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::RejectConnectionRequest(_) => ConnectionManagementCommandChild::RejectConnectionRequest(RejectConnectionRequestPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::ChangeConnectionPacketType(_) => ConnectionManagementCommandChild::ChangeConnectionPacketType(ChangeConnectionPacketTypePacket::new(self.command.clone())),ConnectionManagementCommandDataChild::AuthenticationRequested(_) => ConnectionManagementCommandChild::AuthenticationRequested(AuthenticationRequestedPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::SetConnectionEncryption(_) => ConnectionManagementCommandChild::SetConnectionEncryption(SetConnectionEncryptionPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::ChangeConnectionLinkKey(_) => ConnectionManagementCommandChild::ChangeConnectionLinkKey(ChangeConnectionLinkKeyPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::CentralLinkKey(_) => ConnectionManagementCommandChild::CentralLinkKey(CentralLinkKeyPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::ReadRemoteSupportedFeatures(_) => ConnectionManagementCommandChild::ReadRemoteSupportedFeatures(ReadRemoteSupportedFeaturesPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::ReadRemoteExtendedFeatures(_) => ConnectionManagementCommandChild::ReadRemoteExtendedFeatures(ReadRemoteExtendedFeaturesPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::ReadClockOffset(_) => ConnectionManagementCommandChild::ReadClockOffset(ReadClockOffsetPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::ReadLmpHandle(_) => ConnectionManagementCommandChild::ReadLmpHandle(ReadLmpHandlePacket::new(self.command.clone())),ConnectionManagementCommandDataChild::HoldMode(_) => ConnectionManagementCommandChild::HoldMode(HoldModePacket::new(self.command.clone())),ConnectionManagementCommandDataChild::SniffMode(_) => ConnectionManagementCommandChild::SniffMode(SniffModePacket::new(self.command.clone())),ConnectionManagementCommandDataChild::ExitSniffMode(_) => ConnectionManagementCommandChild::ExitSniffMode(ExitSniffModePacket::new(self.command.clone())),ConnectionManagementCommandDataChild::QosSetup(_) => ConnectionManagementCommandChild::QosSetup(QosSetupPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::RoleDiscovery(_) => ConnectionManagementCommandChild::RoleDiscovery(RoleDiscoveryPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::SwitchRole(_) => ConnectionManagementCommandChild::SwitchRole(SwitchRolePacket::new(self.command.clone())),ConnectionManagementCommandDataChild::ReadLinkPolicySettings(_) => ConnectionManagementCommandChild::ReadLinkPolicySettings(ReadLinkPolicySettingsPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::WriteLinkPolicySettings(_) => ConnectionManagementCommandChild::WriteLinkPolicySettings(WriteLinkPolicySettingsPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::ReadDefaultLinkPolicySettings(_) => ConnectionManagementCommandChild::ReadDefaultLinkPolicySettings(ReadDefaultLinkPolicySettingsPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::WriteDefaultLinkPolicySettings(_) => ConnectionManagementCommandChild::WriteDefaultLinkPolicySettings(WriteDefaultLinkPolicySettingsPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::FlowSpecification(_) => ConnectionManagementCommandChild::FlowSpecification(FlowSpecificationPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::SniffSubrating(_) => ConnectionManagementCommandChild::SniffSubrating(SniffSubratingPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::Flush(_) => ConnectionManagementCommandChild::Flush(FlushPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::ReadConnectionAcceptTimeout(_) => ConnectionManagementCommandChild::ReadConnectionAcceptTimeout(ReadConnectionAcceptTimeoutPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::WriteConnectionAcceptTimeout(_) => ConnectionManagementCommandChild::WriteConnectionAcceptTimeout(WriteConnectionAcceptTimeoutPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::ReadAutomaticFlushTimeout(_) => ConnectionManagementCommandChild::ReadAutomaticFlushTimeout(ReadAutomaticFlushTimeoutPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::WriteAutomaticFlushTimeout(_) => ConnectionManagementCommandChild::WriteAutomaticFlushTimeout(WriteAutomaticFlushTimeoutPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::ReadTransmitPowerLevel(_) => ConnectionManagementCommandChild::ReadTransmitPowerLevel(ReadTransmitPowerLevelPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::ReadLinkSupervisionTimeout(_) => ConnectionManagementCommandChild::ReadLinkSupervisionTimeout(ReadLinkSupervisionTimeoutPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::WriteLinkSupervisionTimeout(_) => ConnectionManagementCommandChild::WriteLinkSupervisionTimeout(WriteLinkSupervisionTimeoutPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::ReadFailedContactCounter(_) => ConnectionManagementCommandChild::ReadFailedContactCounter(ReadFailedContactCounterPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::ResetFailedContactCounter(_) => ConnectionManagementCommandChild::ResetFailedContactCounter(ResetFailedContactCounterPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::ReadLinkQuality(_) => ConnectionManagementCommandChild::ReadLinkQuality(ReadLinkQualityPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::ReadAfhChannelMap(_) => ConnectionManagementCommandChild::ReadAfhChannelMap(ReadAfhChannelMapPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::ReadClock(_) => ConnectionManagementCommandChild::ReadClock(ReadClockPacket::new(self.command.clone())),ConnectionManagementCommandDataChild::Payload(p) => ConnectionManagementCommandChild::Payload(p.clone()),ConnectionManagementCommandDataChild::None => ConnectionManagementCommandChild::None,}} fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};Self {command,acl_command,connection_management_command,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ConnectionManagementCommandPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for ConnectionManagementCommandPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl ConnectionManagementCommandBuilder {pub fn build(self) -> ConnectionManagementCommandPacket {let connection_management_command= Arc::new(ConnectionManagementCommandData {child: match self.payload { None => ConnectionManagementCommandDataChild::None,Some(bytes) => ConnectionManagementCommandDataChild::Payload(bytes),},});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: self.op_code, child: CommandDataChild::AclCommand(acl_command),});ConnectionManagementCommandPacket::new(command)}
}
impl Into<CommandPacket> for ConnectionManagementCommandBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for ConnectionManagementCommandBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}


#[derive(Debug)] enum SecurityCommandDataChild {LinkKeyRequestReply(Arc<LinkKeyRequestReplyData>),LinkKeyRequestNegativeReply(Arc<LinkKeyRequestNegativeReplyData>),PinCodeRequestReply(Arc<PinCodeRequestReplyData>),PinCodeRequestNegativeReply(Arc<PinCodeRequestNegativeReplyData>),IoCapabilityRequestReply(Arc<IoCapabilityRequestReplyData>),UserConfirmationRequestReply(Arc<UserConfirmationRequestReplyData>),UserConfirmationRequestNegativeReply(Arc<UserConfirmationRequestNegativeReplyData>),UserPasskeyRequestReply(Arc<UserPasskeyRequestReplyData>),UserPasskeyRequestNegativeReply(Arc<UserPasskeyRequestNegativeReplyData>),RemoteOobDataRequestReply(Arc<RemoteOobDataRequestReplyData>),RemoteOobDataRequestNegativeReply(Arc<RemoteOobDataRequestNegativeReplyData>),IoCapabilityRequestNegativeReply(Arc<IoCapabilityRequestNegativeReplyData>),RemoteOobExtendedDataRequestReply(Arc<RemoteOobExtendedDataRequestReplyData>),ReadStoredLinkKey(Arc<ReadStoredLinkKeyData>),WriteStoredLinkKey(Arc<WriteStoredLinkKeyData>),DeleteStoredLinkKey(Arc<DeleteStoredLinkKeyData>),WriteAuthenticationEnable(Arc<WriteAuthenticationEnableData>),RefreshEncryptionKey(Arc<RefreshEncryptionKeyData>),ReadSimplePairingMode(Arc<ReadSimplePairingModeData>),WriteSimplePairingMode(Arc<WriteSimplePairingModeData>),ReadLocalOobData(Arc<ReadLocalOobDataData>),SendKeypressNotification(Arc<SendKeypressNotificationData>),WriteSecureConnectionsHostSupport(Arc<WriteSecureConnectionsHostSupportData>),ReadLocalOobExtendedData(Arc<ReadLocalOobExtendedDataData>),ReadEncryptionKeySize(Arc<ReadEncryptionKeySizeData>),WriteSimplePairingDebugMode(Arc<WriteSimplePairingDebugModeData>),Payload(Bytes),None,}
impl SecurityCommandDataChild {fn get_total_size(&self) -> usize {match self {SecurityCommandDataChild::LinkKeyRequestReply(value) => value.get_total_size(),SecurityCommandDataChild::LinkKeyRequestNegativeReply(value) => value.get_total_size(),SecurityCommandDataChild::PinCodeRequestReply(value) => value.get_total_size(),SecurityCommandDataChild::PinCodeRequestNegativeReply(value) => value.get_total_size(),SecurityCommandDataChild::IoCapabilityRequestReply(value) => value.get_total_size(),SecurityCommandDataChild::UserConfirmationRequestReply(value) => value.get_total_size(),SecurityCommandDataChild::UserConfirmationRequestNegativeReply(value) => value.get_total_size(),SecurityCommandDataChild::UserPasskeyRequestReply(value) => value.get_total_size(),SecurityCommandDataChild::UserPasskeyRequestNegativeReply(value) => value.get_total_size(),SecurityCommandDataChild::RemoteOobDataRequestReply(value) => value.get_total_size(),SecurityCommandDataChild::RemoteOobDataRequestNegativeReply(value) => value.get_total_size(),SecurityCommandDataChild::IoCapabilityRequestNegativeReply(value) => value.get_total_size(),SecurityCommandDataChild::RemoteOobExtendedDataRequestReply(value) => value.get_total_size(),SecurityCommandDataChild::ReadStoredLinkKey(value) => value.get_total_size(),SecurityCommandDataChild::WriteStoredLinkKey(value) => value.get_total_size(),SecurityCommandDataChild::DeleteStoredLinkKey(value) => value.get_total_size(),SecurityCommandDataChild::WriteAuthenticationEnable(value) => value.get_total_size(),SecurityCommandDataChild::RefreshEncryptionKey(value) => value.get_total_size(),SecurityCommandDataChild::ReadSimplePairingMode(value) => value.get_total_size(),SecurityCommandDataChild::WriteSimplePairingMode(value) => value.get_total_size(),SecurityCommandDataChild::ReadLocalOobData(value) => value.get_total_size(),SecurityCommandDataChild::SendKeypressNotification(value) => value.get_total_size(),SecurityCommandDataChild::WriteSecureConnectionsHostSupport(value) => value.get_total_size(),SecurityCommandDataChild::ReadLocalOobExtendedData(value) => value.get_total_size(),SecurityCommandDataChild::ReadEncryptionKeySize(value) => value.get_total_size(),SecurityCommandDataChild::WriteSimplePairingDebugMode(value) => value.get_total_size(),SecurityCommandDataChild::Payload(p) => p.len(),SecurityCommandDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum SecurityCommandChild {LinkKeyRequestReply(LinkKeyRequestReplyPacket),LinkKeyRequestNegativeReply(LinkKeyRequestNegativeReplyPacket),PinCodeRequestReply(PinCodeRequestReplyPacket),PinCodeRequestNegativeReply(PinCodeRequestNegativeReplyPacket),IoCapabilityRequestReply(IoCapabilityRequestReplyPacket),UserConfirmationRequestReply(UserConfirmationRequestReplyPacket),UserConfirmationRequestNegativeReply(UserConfirmationRequestNegativeReplyPacket),UserPasskeyRequestReply(UserPasskeyRequestReplyPacket),UserPasskeyRequestNegativeReply(UserPasskeyRequestNegativeReplyPacket),RemoteOobDataRequestReply(RemoteOobDataRequestReplyPacket),RemoteOobDataRequestNegativeReply(RemoteOobDataRequestNegativeReplyPacket),IoCapabilityRequestNegativeReply(IoCapabilityRequestNegativeReplyPacket),RemoteOobExtendedDataRequestReply(RemoteOobExtendedDataRequestReplyPacket),ReadStoredLinkKey(ReadStoredLinkKeyPacket),WriteStoredLinkKey(WriteStoredLinkKeyPacket),DeleteStoredLinkKey(DeleteStoredLinkKeyPacket),WriteAuthenticationEnable(WriteAuthenticationEnablePacket),RefreshEncryptionKey(RefreshEncryptionKeyPacket),ReadSimplePairingMode(ReadSimplePairingModePacket),WriteSimplePairingMode(WriteSimplePairingModePacket),ReadLocalOobData(ReadLocalOobDataPacket),SendKeypressNotification(SendKeypressNotificationPacket),WriteSecureConnectionsHostSupport(WriteSecureConnectionsHostSupportPacket),ReadLocalOobExtendedData(ReadLocalOobExtendedDataPacket),ReadEncryptionKeySize(ReadEncryptionKeySizePacket),WriteSimplePairingDebugMode(WriteSimplePairingDebugModePacket),Payload(Bytes),None,}
#[derive(Debug)] struct SecurityCommandData {child: SecurityCommandDataChild,}
#[derive(Debug, Clone)] pub struct SecurityCommandPacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,}
#[derive(Debug)] pub struct SecurityCommandBuilder {pub op_code: OpCode, pub payload: Option<Bytes>,}
impl SecurityCommandData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8], op_code: OpCode) -> Result<Self> {let payload: Vec::<u8> = bytes[3..].into();let child = match op_code {OpCode::LinkKeyRequestReply if LinkKeyRequestReplyData::conforms(&bytes[..]) => {SecurityCommandDataChild::LinkKeyRequestReply(Arc::new(LinkKeyRequestReplyData::parse(&bytes[..])?))}
OpCode::LinkKeyRequestNegativeReply if LinkKeyRequestNegativeReplyData::conforms(&bytes[..]) => {SecurityCommandDataChild::LinkKeyRequestNegativeReply(Arc::new(LinkKeyRequestNegativeReplyData::parse(&bytes[..])?))}
OpCode::PinCodeRequestReply if PinCodeRequestReplyData::conforms(&bytes[..]) => {SecurityCommandDataChild::PinCodeRequestReply(Arc::new(PinCodeRequestReplyData::parse(&bytes[..])?))}
OpCode::PinCodeRequestNegativeReply if PinCodeRequestNegativeReplyData::conforms(&bytes[..]) => {SecurityCommandDataChild::PinCodeRequestNegativeReply(Arc::new(PinCodeRequestNegativeReplyData::parse(&bytes[..])?))}
OpCode::IoCapabilityRequestReply if IoCapabilityRequestReplyData::conforms(&bytes[..]) => {SecurityCommandDataChild::IoCapabilityRequestReply(Arc::new(IoCapabilityRequestReplyData::parse(&bytes[..])?))}
OpCode::UserConfirmationRequestReply if UserConfirmationRequestReplyData::conforms(&bytes[..]) => {SecurityCommandDataChild::UserConfirmationRequestReply(Arc::new(UserConfirmationRequestReplyData::parse(&bytes[..])?))}
OpCode::UserConfirmationRequestNegativeReply if UserConfirmationRequestNegativeReplyData::conforms(&bytes[..]) => {SecurityCommandDataChild::UserConfirmationRequestNegativeReply(Arc::new(UserConfirmationRequestNegativeReplyData::parse(&bytes[..])?))}
OpCode::UserPasskeyRequestReply if UserPasskeyRequestReplyData::conforms(&bytes[..]) => {SecurityCommandDataChild::UserPasskeyRequestReply(Arc::new(UserPasskeyRequestReplyData::parse(&bytes[..])?))}
OpCode::UserPasskeyRequestNegativeReply if UserPasskeyRequestNegativeReplyData::conforms(&bytes[..]) => {SecurityCommandDataChild::UserPasskeyRequestNegativeReply(Arc::new(UserPasskeyRequestNegativeReplyData::parse(&bytes[..])?))}
OpCode::RemoteOobDataRequestReply if RemoteOobDataRequestReplyData::conforms(&bytes[..]) => {SecurityCommandDataChild::RemoteOobDataRequestReply(Arc::new(RemoteOobDataRequestReplyData::parse(&bytes[..])?))}
OpCode::RemoteOobDataRequestNegativeReply if RemoteOobDataRequestNegativeReplyData::conforms(&bytes[..]) => {SecurityCommandDataChild::RemoteOobDataRequestNegativeReply(Arc::new(RemoteOobDataRequestNegativeReplyData::parse(&bytes[..])?))}
OpCode::IoCapabilityRequestNegativeReply if IoCapabilityRequestNegativeReplyData::conforms(&bytes[..]) => {SecurityCommandDataChild::IoCapabilityRequestNegativeReply(Arc::new(IoCapabilityRequestNegativeReplyData::parse(&bytes[..])?))}
OpCode::RemoteOobExtendedDataRequestReply if RemoteOobExtendedDataRequestReplyData::conforms(&bytes[..]) => {SecurityCommandDataChild::RemoteOobExtendedDataRequestReply(Arc::new(RemoteOobExtendedDataRequestReplyData::parse(&bytes[..])?))}
OpCode::ReadStoredLinkKey if ReadStoredLinkKeyData::conforms(&bytes[..]) => {SecurityCommandDataChild::ReadStoredLinkKey(Arc::new(ReadStoredLinkKeyData::parse(&bytes[..])?))}
OpCode::WriteStoredLinkKey if WriteStoredLinkKeyData::conforms(&bytes[..]) => {SecurityCommandDataChild::WriteStoredLinkKey(Arc::new(WriteStoredLinkKeyData::parse(&bytes[..])?))}
OpCode::DeleteStoredLinkKey if DeleteStoredLinkKeyData::conforms(&bytes[..]) => {SecurityCommandDataChild::DeleteStoredLinkKey(Arc::new(DeleteStoredLinkKeyData::parse(&bytes[..])?))}
OpCode::WriteAuthenticationEnable if WriteAuthenticationEnableData::conforms(&bytes[..]) => {SecurityCommandDataChild::WriteAuthenticationEnable(Arc::new(WriteAuthenticationEnableData::parse(&bytes[..])?))}
OpCode::RefreshEncryptionKey if RefreshEncryptionKeyData::conforms(&bytes[..]) => {SecurityCommandDataChild::RefreshEncryptionKey(Arc::new(RefreshEncryptionKeyData::parse(&bytes[..])?))}
OpCode::ReadSimplePairingMode if ReadSimplePairingModeData::conforms(&bytes[..]) => {SecurityCommandDataChild::ReadSimplePairingMode(Arc::new(ReadSimplePairingModeData::parse(&bytes[..])?))}
OpCode::WriteSimplePairingMode if WriteSimplePairingModeData::conforms(&bytes[..]) => {SecurityCommandDataChild::WriteSimplePairingMode(Arc::new(WriteSimplePairingModeData::parse(&bytes[..])?))}
OpCode::ReadLocalOobData if ReadLocalOobDataData::conforms(&bytes[..]) => {SecurityCommandDataChild::ReadLocalOobData(Arc::new(ReadLocalOobDataData::parse(&bytes[..])?))}
OpCode::SendKeypressNotification if SendKeypressNotificationData::conforms(&bytes[..]) => {SecurityCommandDataChild::SendKeypressNotification(Arc::new(SendKeypressNotificationData::parse(&bytes[..])?))}
OpCode::WriteSecureConnectionsHostSupport if WriteSecureConnectionsHostSupportData::conforms(&bytes[..]) => {SecurityCommandDataChild::WriteSecureConnectionsHostSupport(Arc::new(WriteSecureConnectionsHostSupportData::parse(&bytes[..])?))}
OpCode::ReadLocalOobExtendedData if ReadLocalOobExtendedDataData::conforms(&bytes[..]) => {SecurityCommandDataChild::ReadLocalOobExtendedData(Arc::new(ReadLocalOobExtendedDataData::parse(&bytes[..])?))}
OpCode::ReadEncryptionKeySize if ReadEncryptionKeySizeData::conforms(&bytes[..]) => {SecurityCommandDataChild::ReadEncryptionKeySize(Arc::new(ReadEncryptionKeySizeData::parse(&bytes[..])?))}
OpCode::WriteSimplePairingDebugMode if WriteSimplePairingDebugModeData::conforms(&bytes[..]) => {SecurityCommandDataChild::WriteSimplePairingDebugMode(Arc::new(WriteSimplePairingDebugModeData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "op_code".to_string(), value: v as u64}),};
Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {SecurityCommandDataChild::LinkKeyRequestReply(value) => value.write_to(buffer),SecurityCommandDataChild::LinkKeyRequestNegativeReply(value) => value.write_to(buffer),SecurityCommandDataChild::PinCodeRequestReply(value) => value.write_to(buffer),SecurityCommandDataChild::PinCodeRequestNegativeReply(value) => value.write_to(buffer),SecurityCommandDataChild::IoCapabilityRequestReply(value) => value.write_to(buffer),SecurityCommandDataChild::UserConfirmationRequestReply(value) => value.write_to(buffer),SecurityCommandDataChild::UserConfirmationRequestNegativeReply(value) => value.write_to(buffer),SecurityCommandDataChild::UserPasskeyRequestReply(value) => value.write_to(buffer),SecurityCommandDataChild::UserPasskeyRequestNegativeReply(value) => value.write_to(buffer),SecurityCommandDataChild::RemoteOobDataRequestReply(value) => value.write_to(buffer),SecurityCommandDataChild::RemoteOobDataRequestNegativeReply(value) => value.write_to(buffer),SecurityCommandDataChild::IoCapabilityRequestNegativeReply(value) => value.write_to(buffer),SecurityCommandDataChild::RemoteOobExtendedDataRequestReply(value) => value.write_to(buffer),SecurityCommandDataChild::ReadStoredLinkKey(value) => value.write_to(buffer),SecurityCommandDataChild::WriteStoredLinkKey(value) => value.write_to(buffer),SecurityCommandDataChild::DeleteStoredLinkKey(value) => value.write_to(buffer),SecurityCommandDataChild::WriteAuthenticationEnable(value) => value.write_to(buffer),SecurityCommandDataChild::RefreshEncryptionKey(value) => value.write_to(buffer),SecurityCommandDataChild::ReadSimplePairingMode(value) => value.write_to(buffer),SecurityCommandDataChild::WriteSimplePairingMode(value) => value.write_to(buffer),SecurityCommandDataChild::ReadLocalOobData(value) => value.write_to(buffer),SecurityCommandDataChild::SendKeypressNotification(value) => value.write_to(buffer),SecurityCommandDataChild::WriteSecureConnectionsHostSupport(value) => value.write_to(buffer),SecurityCommandDataChild::ReadLocalOobExtendedData(value) => value.write_to(buffer),SecurityCommandDataChild::ReadEncryptionKeySize(value) => value.write_to(buffer),SecurityCommandDataChild::WriteSimplePairingDebugMode(value) => value.write_to(buffer),SecurityCommandDataChild::Payload(p) => buffer[3..].copy_from_slice(&p[..]),SecurityCommandDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for SecurityCommandPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SecurityCommandPacket { pub fn specialize(&self) -> SecurityCommandChild { match &self.security_command.child {SecurityCommandDataChild::LinkKeyRequestReply(_) => SecurityCommandChild::LinkKeyRequestReply(LinkKeyRequestReplyPacket::new(self.command.clone())),SecurityCommandDataChild::LinkKeyRequestNegativeReply(_) => SecurityCommandChild::LinkKeyRequestNegativeReply(LinkKeyRequestNegativeReplyPacket::new(self.command.clone())),SecurityCommandDataChild::PinCodeRequestReply(_) => SecurityCommandChild::PinCodeRequestReply(PinCodeRequestReplyPacket::new(self.command.clone())),SecurityCommandDataChild::PinCodeRequestNegativeReply(_) => SecurityCommandChild::PinCodeRequestNegativeReply(PinCodeRequestNegativeReplyPacket::new(self.command.clone())),SecurityCommandDataChild::IoCapabilityRequestReply(_) => SecurityCommandChild::IoCapabilityRequestReply(IoCapabilityRequestReplyPacket::new(self.command.clone())),SecurityCommandDataChild::UserConfirmationRequestReply(_) => SecurityCommandChild::UserConfirmationRequestReply(UserConfirmationRequestReplyPacket::new(self.command.clone())),SecurityCommandDataChild::UserConfirmationRequestNegativeReply(_) => SecurityCommandChild::UserConfirmationRequestNegativeReply(UserConfirmationRequestNegativeReplyPacket::new(self.command.clone())),SecurityCommandDataChild::UserPasskeyRequestReply(_) => SecurityCommandChild::UserPasskeyRequestReply(UserPasskeyRequestReplyPacket::new(self.command.clone())),SecurityCommandDataChild::UserPasskeyRequestNegativeReply(_) => SecurityCommandChild::UserPasskeyRequestNegativeReply(UserPasskeyRequestNegativeReplyPacket::new(self.command.clone())),SecurityCommandDataChild::RemoteOobDataRequestReply(_) => SecurityCommandChild::RemoteOobDataRequestReply(RemoteOobDataRequestReplyPacket::new(self.command.clone())),SecurityCommandDataChild::RemoteOobDataRequestNegativeReply(_) => SecurityCommandChild::RemoteOobDataRequestNegativeReply(RemoteOobDataRequestNegativeReplyPacket::new(self.command.clone())),SecurityCommandDataChild::IoCapabilityRequestNegativeReply(_) => SecurityCommandChild::IoCapabilityRequestNegativeReply(IoCapabilityRequestNegativeReplyPacket::new(self.command.clone())),SecurityCommandDataChild::RemoteOobExtendedDataRequestReply(_) => SecurityCommandChild::RemoteOobExtendedDataRequestReply(RemoteOobExtendedDataRequestReplyPacket::new(self.command.clone())),SecurityCommandDataChild::ReadStoredLinkKey(_) => SecurityCommandChild::ReadStoredLinkKey(ReadStoredLinkKeyPacket::new(self.command.clone())),SecurityCommandDataChild::WriteStoredLinkKey(_) => SecurityCommandChild::WriteStoredLinkKey(WriteStoredLinkKeyPacket::new(self.command.clone())),SecurityCommandDataChild::DeleteStoredLinkKey(_) => SecurityCommandChild::DeleteStoredLinkKey(DeleteStoredLinkKeyPacket::new(self.command.clone())),SecurityCommandDataChild::WriteAuthenticationEnable(_) => SecurityCommandChild::WriteAuthenticationEnable(WriteAuthenticationEnablePacket::new(self.command.clone())),SecurityCommandDataChild::RefreshEncryptionKey(_) => SecurityCommandChild::RefreshEncryptionKey(RefreshEncryptionKeyPacket::new(self.command.clone())),SecurityCommandDataChild::ReadSimplePairingMode(_) => SecurityCommandChild::ReadSimplePairingMode(ReadSimplePairingModePacket::new(self.command.clone())),SecurityCommandDataChild::WriteSimplePairingMode(_) => SecurityCommandChild::WriteSimplePairingMode(WriteSimplePairingModePacket::new(self.command.clone())),SecurityCommandDataChild::ReadLocalOobData(_) => SecurityCommandChild::ReadLocalOobData(ReadLocalOobDataPacket::new(self.command.clone())),SecurityCommandDataChild::SendKeypressNotification(_) => SecurityCommandChild::SendKeypressNotification(SendKeypressNotificationPacket::new(self.command.clone())),SecurityCommandDataChild::WriteSecureConnectionsHostSupport(_) => SecurityCommandChild::WriteSecureConnectionsHostSupport(WriteSecureConnectionsHostSupportPacket::new(self.command.clone())),SecurityCommandDataChild::ReadLocalOobExtendedData(_) => SecurityCommandChild::ReadLocalOobExtendedData(ReadLocalOobExtendedDataPacket::new(self.command.clone())),SecurityCommandDataChild::ReadEncryptionKeySize(_) => SecurityCommandChild::ReadEncryptionKeySize(ReadEncryptionKeySizePacket::new(self.command.clone())),SecurityCommandDataChild::WriteSimplePairingDebugMode(_) => SecurityCommandChild::WriteSimplePairingDebugMode(WriteSimplePairingDebugModePacket::new(self.command.clone())),SecurityCommandDataChild::Payload(p) => SecurityCommandChild::Payload(p.clone()),SecurityCommandDataChild::None => SecurityCommandChild::None,}} fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};Self {command,security_command,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for SecurityCommandPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl SecurityCommandBuilder {pub fn build(self) -> SecurityCommandPacket {let security_command= Arc::new(SecurityCommandData {child: match self.payload { None => SecurityCommandDataChild::None,Some(bytes) => SecurityCommandDataChild::Payload(bytes),},});let command= Arc::new(CommandData {op_code: self.op_code, child: CommandDataChild::SecurityCommand(security_command),});SecurityCommandPacket::new(command)}
}
impl Into<CommandPacket> for SecurityCommandBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] enum ScoConnectionCommandDataChild {SetupSynchronousConnection(Arc<SetupSynchronousConnectionData>),AcceptSynchronousConnection(Arc<AcceptSynchronousConnectionData>),RejectSynchronousConnection(Arc<RejectSynchronousConnectionData>),EnhancedSetupSynchronousConnection(Arc<EnhancedSetupSynchronousConnectionData>),EnhancedAcceptSynchronousConnection(Arc<EnhancedAcceptSynchronousConnectionData>),Payload(Bytes),None,}
impl ScoConnectionCommandDataChild {fn get_total_size(&self) -> usize {match self {ScoConnectionCommandDataChild::SetupSynchronousConnection(value) => value.get_total_size(),ScoConnectionCommandDataChild::AcceptSynchronousConnection(value) => value.get_total_size(),ScoConnectionCommandDataChild::RejectSynchronousConnection(value) => value.get_total_size(),ScoConnectionCommandDataChild::EnhancedSetupSynchronousConnection(value) => value.get_total_size(),ScoConnectionCommandDataChild::EnhancedAcceptSynchronousConnection(value) => value.get_total_size(),ScoConnectionCommandDataChild::Payload(p) => p.len(),ScoConnectionCommandDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum ScoConnectionCommandChild {SetupSynchronousConnection(SetupSynchronousConnectionPacket),AcceptSynchronousConnection(AcceptSynchronousConnectionPacket),RejectSynchronousConnection(RejectSynchronousConnectionPacket),EnhancedSetupSynchronousConnection(EnhancedSetupSynchronousConnectionPacket),EnhancedAcceptSynchronousConnection(EnhancedAcceptSynchronousConnectionPacket),Payload(Bytes),None,}
#[derive(Debug)] struct ScoConnectionCommandData {child: ScoConnectionCommandDataChild,}
#[derive(Debug, Clone)] pub struct ScoConnectionCommandPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,sco_connection_command: Arc<ScoConnectionCommandData>,}
#[derive(Debug)] pub struct ScoConnectionCommandBuilder {pub op_code: OpCode, pub payload: Option<Bytes>,}
impl ScoConnectionCommandData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8], op_code: OpCode) -> Result<Self> {let payload: Vec::<u8> = bytes[3..].into();let child = match op_code {OpCode::SetupSynchronousConnection if SetupSynchronousConnectionData::conforms(&bytes[..]) => {ScoConnectionCommandDataChild::SetupSynchronousConnection(Arc::new(SetupSynchronousConnectionData::parse(&bytes[..])?))}
OpCode::AcceptSynchronousConnection if AcceptSynchronousConnectionData::conforms(&bytes[..]) => {ScoConnectionCommandDataChild::AcceptSynchronousConnection(Arc::new(AcceptSynchronousConnectionData::parse(&bytes[..])?))}
OpCode::RejectSynchronousConnection if RejectSynchronousConnectionData::conforms(&bytes[..]) => {ScoConnectionCommandDataChild::RejectSynchronousConnection(Arc::new(RejectSynchronousConnectionData::parse(&bytes[..])?))}
OpCode::EnhancedSetupSynchronousConnection if EnhancedSetupSynchronousConnectionData::conforms(&bytes[..]) => {ScoConnectionCommandDataChild::EnhancedSetupSynchronousConnection(Arc::new(EnhancedSetupSynchronousConnectionData::parse(&bytes[..])?))}
OpCode::EnhancedAcceptSynchronousConnection if EnhancedAcceptSynchronousConnectionData::conforms(&bytes[..]) => {ScoConnectionCommandDataChild::EnhancedAcceptSynchronousConnection(Arc::new(EnhancedAcceptSynchronousConnectionData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "op_code".to_string(), value: v as u64}),};
Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {ScoConnectionCommandDataChild::SetupSynchronousConnection(value) => value.write_to(buffer),ScoConnectionCommandDataChild::AcceptSynchronousConnection(value) => value.write_to(buffer),ScoConnectionCommandDataChild::RejectSynchronousConnection(value) => value.write_to(buffer),ScoConnectionCommandDataChild::EnhancedSetupSynchronousConnection(value) => value.write_to(buffer),ScoConnectionCommandDataChild::EnhancedAcceptSynchronousConnection(value) => value.write_to(buffer),ScoConnectionCommandDataChild::Payload(p) => buffer[3..].copy_from_slice(&p[..]),ScoConnectionCommandDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for ScoConnectionCommandPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ScoConnectionCommandPacket { pub fn specialize(&self) -> ScoConnectionCommandChild { match &self.sco_connection_command.child {ScoConnectionCommandDataChild::SetupSynchronousConnection(_) => ScoConnectionCommandChild::SetupSynchronousConnection(SetupSynchronousConnectionPacket::new(self.command.clone())),ScoConnectionCommandDataChild::AcceptSynchronousConnection(_) => ScoConnectionCommandChild::AcceptSynchronousConnection(AcceptSynchronousConnectionPacket::new(self.command.clone())),ScoConnectionCommandDataChild::RejectSynchronousConnection(_) => ScoConnectionCommandChild::RejectSynchronousConnection(RejectSynchronousConnectionPacket::new(self.command.clone())),ScoConnectionCommandDataChild::EnhancedSetupSynchronousConnection(_) => ScoConnectionCommandChild::EnhancedSetupSynchronousConnection(EnhancedSetupSynchronousConnectionPacket::new(self.command.clone())),ScoConnectionCommandDataChild::EnhancedAcceptSynchronousConnection(_) => ScoConnectionCommandChild::EnhancedAcceptSynchronousConnection(EnhancedAcceptSynchronousConnectionPacket::new(self.command.clone())),ScoConnectionCommandDataChild::Payload(p) => ScoConnectionCommandChild::Payload(p.clone()),ScoConnectionCommandDataChild::None => ScoConnectionCommandChild::None,}} fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let sco_connection_command = match &acl_command.child {AclCommandDataChild::ScoConnectionCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ScoConnectionCommand"),};Self {command,acl_command,sco_connection_command,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ScoConnectionCommandPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for ScoConnectionCommandPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl ScoConnectionCommandBuilder {pub fn build(self) -> ScoConnectionCommandPacket {let sco_connection_command= Arc::new(ScoConnectionCommandData {child: match self.payload { None => ScoConnectionCommandDataChild::None,Some(bytes) => ScoConnectionCommandDataChild::Payload(bytes),},});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ScoConnectionCommand(sco_connection_command),});let command= Arc::new(CommandData {op_code: self.op_code, child: CommandDataChild::AclCommand(acl_command),});ScoConnectionCommandPacket::new(command)}
}
impl Into<CommandPacket> for ScoConnectionCommandBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for ScoConnectionCommandBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}


#[derive(Debug)] enum LeAdvertisingCommandDataChild {LeSetRandomAddress(Arc<LeSetRandomAddressData>),LeSetAdvertisingParameters(Arc<LeSetAdvertisingParametersData>),LeReadAdvertisingPhysicalChannelTxPower(Arc<LeReadAdvertisingPhysicalChannelTxPowerData>),LeSetAdvertisingData(Arc<LeSetAdvertisingDataData>),LeSetScanResponseData(Arc<LeSetScanResponseDataData>),LeSetAdvertisingEnable(Arc<LeSetAdvertisingEnableData>),LeSetExtendedAdvertisingRandomAddress(Arc<LeSetExtendedAdvertisingRandomAddressData>),LeSetExtendedAdvertisingLegacyParameters(Arc<LeSetExtendedAdvertisingLegacyParametersData>),LeSetExtendedAdvertisingParameters(Arc<LeSetExtendedAdvertisingParametersData>),LeSetExtendedAdvertisingData(Arc<LeSetExtendedAdvertisingDataData>),LeSetExtendedAdvertisingDataRaw(Arc<LeSetExtendedAdvertisingDataRawData>),LeSetExtendedAdvertisingScanResponse(Arc<LeSetExtendedAdvertisingScanResponseData>),LeSetExtendedAdvertisingScanResponseRaw(Arc<LeSetExtendedAdvertisingScanResponseRawData>),LeSetExtendedAdvertisingEnableDisableAll(Arc<LeSetExtendedAdvertisingEnableDisableAllData>),LeSetExtendedAdvertisingDisable(Arc<LeSetExtendedAdvertisingDisableData>),LeSetExtendedAdvertisingEnable(Arc<LeSetExtendedAdvertisingEnableData>),LeRemoveAdvertisingSet(Arc<LeRemoveAdvertisingSetData>),LeClearAdvertisingSets(Arc<LeClearAdvertisingSetsData>),LeSetPeriodicAdvertisingParam(Arc<LeSetPeriodicAdvertisingParamData>),LeSetPeriodicAdvertisingData(Arc<LeSetPeriodicAdvertisingDataData>),LeSetPeriodicAdvertisingEnable(Arc<LeSetPeriodicAdvertisingEnableData>),LePeriodicAdvertisingCreateSync(Arc<LePeriodicAdvertisingCreateSyncData>),LePeriodicAdvertisingCreateSyncCancel(Arc<LePeriodicAdvertisingCreateSyncCancelData>),LePeriodicAdvertisingTerminateSync(Arc<LePeriodicAdvertisingTerminateSyncData>),LeAddDeviceToPeriodicAdvertisingList(Arc<LeAddDeviceToPeriodicAdvertisingListData>),LeRemoveDeviceFromPeriodicAdvertisingList(Arc<LeRemoveDeviceFromPeriodicAdvertisingListData>),LeClearPeriodicAdvertisingList(Arc<LeClearPeriodicAdvertisingListData>),LeReadTransmitPower(Arc<LeReadTransmitPowerData>),LeReadRfPathCompensationPower(Arc<LeReadRfPathCompensationPowerData>),LeWriteRfPathCompensationPower(Arc<LeWriteRfPathCompensationPowerData>),LeMultiAdvt(Arc<LeMultiAdvtData>),Payload(Bytes),None,}
impl LeAdvertisingCommandDataChild {fn get_total_size(&self) -> usize {match self {LeAdvertisingCommandDataChild::LeSetRandomAddress(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeSetAdvertisingParameters(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeReadAdvertisingPhysicalChannelTxPower(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeSetAdvertisingData(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeSetScanResponseData(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeSetAdvertisingEnable(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingRandomAddress(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingLegacyParameters(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingParameters(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingData(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingDataRaw(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingScanResponse(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingScanResponseRaw(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingEnableDisableAll(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingDisable(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingEnable(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeRemoveAdvertisingSet(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeClearAdvertisingSets(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeSetPeriodicAdvertisingParam(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeSetPeriodicAdvertisingData(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeSetPeriodicAdvertisingEnable(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LePeriodicAdvertisingCreateSync(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LePeriodicAdvertisingCreateSyncCancel(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LePeriodicAdvertisingTerminateSync(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeAddDeviceToPeriodicAdvertisingList(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeRemoveDeviceFromPeriodicAdvertisingList(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeClearPeriodicAdvertisingList(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeReadTransmitPower(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeReadRfPathCompensationPower(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeWriteRfPathCompensationPower(value) => value.get_total_size(),LeAdvertisingCommandDataChild::LeMultiAdvt(value) => value.get_total_size(),LeAdvertisingCommandDataChild::Payload(p) => p.len(),LeAdvertisingCommandDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LeAdvertisingCommandChild {LeSetRandomAddress(LeSetRandomAddressPacket),LeSetAdvertisingParameters(LeSetAdvertisingParametersPacket),LeReadAdvertisingPhysicalChannelTxPower(LeReadAdvertisingPhysicalChannelTxPowerPacket),LeSetAdvertisingData(LeSetAdvertisingDataPacket),LeSetScanResponseData(LeSetScanResponseDataPacket),LeSetAdvertisingEnable(LeSetAdvertisingEnablePacket),LeSetExtendedAdvertisingRandomAddress(LeSetExtendedAdvertisingRandomAddressPacket),LeSetExtendedAdvertisingLegacyParameters(LeSetExtendedAdvertisingLegacyParametersPacket),LeSetExtendedAdvertisingParameters(LeSetExtendedAdvertisingParametersPacket),LeSetExtendedAdvertisingData(LeSetExtendedAdvertisingDataPacket),LeSetExtendedAdvertisingDataRaw(LeSetExtendedAdvertisingDataRawPacket),LeSetExtendedAdvertisingScanResponse(LeSetExtendedAdvertisingScanResponsePacket),LeSetExtendedAdvertisingScanResponseRaw(LeSetExtendedAdvertisingScanResponseRawPacket),LeSetExtendedAdvertisingEnableDisableAll(LeSetExtendedAdvertisingEnableDisableAllPacket),LeSetExtendedAdvertisingDisable(LeSetExtendedAdvertisingDisablePacket),LeSetExtendedAdvertisingEnable(LeSetExtendedAdvertisingEnablePacket),LeRemoveAdvertisingSet(LeRemoveAdvertisingSetPacket),LeClearAdvertisingSets(LeClearAdvertisingSetsPacket),LeSetPeriodicAdvertisingParam(LeSetPeriodicAdvertisingParamPacket),LeSetPeriodicAdvertisingData(LeSetPeriodicAdvertisingDataPacket),LeSetPeriodicAdvertisingEnable(LeSetPeriodicAdvertisingEnablePacket),LePeriodicAdvertisingCreateSync(LePeriodicAdvertisingCreateSyncPacket),LePeriodicAdvertisingCreateSyncCancel(LePeriodicAdvertisingCreateSyncCancelPacket),LePeriodicAdvertisingTerminateSync(LePeriodicAdvertisingTerminateSyncPacket),LeAddDeviceToPeriodicAdvertisingList(LeAddDeviceToPeriodicAdvertisingListPacket),LeRemoveDeviceFromPeriodicAdvertisingList(LeRemoveDeviceFromPeriodicAdvertisingListPacket),LeClearPeriodicAdvertisingList(LeClearPeriodicAdvertisingListPacket),LeReadTransmitPower(LeReadTransmitPowerPacket),LeReadRfPathCompensationPower(LeReadRfPathCompensationPowerPacket),LeWriteRfPathCompensationPower(LeWriteRfPathCompensationPowerPacket),LeMultiAdvt(LeMultiAdvtPacket),Payload(Bytes),None,}
#[derive(Debug)] struct LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild,}
#[derive(Debug, Clone)] pub struct LeAdvertisingCommandPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,}
#[derive(Debug)] pub struct LeAdvertisingCommandBuilder {pub op_code: OpCode, pub payload: Option<Bytes>,}
impl LeAdvertisingCommandData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8], op_code: OpCode) -> Result<Self> {let payload: Vec::<u8> = bytes[3..].into();let child = match op_code {OpCode::LeSetRandomAddress if LeSetRandomAddressData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeSetRandomAddress(Arc::new(LeSetRandomAddressData::parse(&bytes[..])?))}
OpCode::LeSetAdvertisingParameters if LeSetAdvertisingParametersData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeSetAdvertisingParameters(Arc::new(LeSetAdvertisingParametersData::parse(&bytes[..])?))}
OpCode::LeReadAdvertisingPhysicalChannelTxPower if LeReadAdvertisingPhysicalChannelTxPowerData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeReadAdvertisingPhysicalChannelTxPower(Arc::new(LeReadAdvertisingPhysicalChannelTxPowerData::parse(&bytes[..])?))}
OpCode::LeSetAdvertisingData if LeSetAdvertisingDataData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeSetAdvertisingData(Arc::new(LeSetAdvertisingDataData::parse(&bytes[..])?))}
OpCode::LeSetScanResponseData if LeSetScanResponseDataData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeSetScanResponseData(Arc::new(LeSetScanResponseDataData::parse(&bytes[..])?))}
OpCode::LeSetAdvertisingEnable if LeSetAdvertisingEnableData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeSetAdvertisingEnable(Arc::new(LeSetAdvertisingEnableData::parse(&bytes[..])?))}
OpCode::LeSetExtendedAdvertisingRandomAddress if LeSetExtendedAdvertisingRandomAddressData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingRandomAddress(Arc::new(LeSetExtendedAdvertisingRandomAddressData::parse(&bytes[..])?))}
OpCode::LeSetExtendedAdvertisingParameters if LeSetExtendedAdvertisingLegacyParametersData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingLegacyParameters(Arc::new(LeSetExtendedAdvertisingLegacyParametersData::parse(&bytes[..])?))}
OpCode::LeSetExtendedAdvertisingParameters if LeSetExtendedAdvertisingParametersData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingParameters(Arc::new(LeSetExtendedAdvertisingParametersData::parse(&bytes[..])?))}
OpCode::LeSetExtendedAdvertisingData if LeSetExtendedAdvertisingDataData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingData(Arc::new(LeSetExtendedAdvertisingDataData::parse(&bytes[..])?))}
OpCode::LeSetExtendedAdvertisingData if LeSetExtendedAdvertisingDataRawData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingDataRaw(Arc::new(LeSetExtendedAdvertisingDataRawData::parse(&bytes[..])?))}
OpCode::LeSetExtendedAdvertisingScanResponse if LeSetExtendedAdvertisingScanResponseData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingScanResponse(Arc::new(LeSetExtendedAdvertisingScanResponseData::parse(&bytes[..])?))}
OpCode::LeSetExtendedAdvertisingScanResponse if LeSetExtendedAdvertisingScanResponseRawData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingScanResponseRaw(Arc::new(LeSetExtendedAdvertisingScanResponseRawData::parse(&bytes[..])?))}
OpCode::LeSetExtendedAdvertisingEnable if LeSetExtendedAdvertisingEnableDisableAllData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingEnableDisableAll(Arc::new(LeSetExtendedAdvertisingEnableDisableAllData::parse(&bytes[..])?))}
OpCode::LeSetExtendedAdvertisingEnable if LeSetExtendedAdvertisingDisableData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingDisable(Arc::new(LeSetExtendedAdvertisingDisableData::parse(&bytes[..])?))}
OpCode::LeSetExtendedAdvertisingEnable if LeSetExtendedAdvertisingEnableData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingEnable(Arc::new(LeSetExtendedAdvertisingEnableData::parse(&bytes[..])?))}
OpCode::LeRemoveAdvertisingSet if LeRemoveAdvertisingSetData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeRemoveAdvertisingSet(Arc::new(LeRemoveAdvertisingSetData::parse(&bytes[..])?))}
OpCode::LeClearAdvertisingSets if LeClearAdvertisingSetsData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeClearAdvertisingSets(Arc::new(LeClearAdvertisingSetsData::parse(&bytes[..])?))}
OpCode::LeSetPeriodicAdvertisingParam if LeSetPeriodicAdvertisingParamData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeSetPeriodicAdvertisingParam(Arc::new(LeSetPeriodicAdvertisingParamData::parse(&bytes[..])?))}
OpCode::LeSetPeriodicAdvertisingData if LeSetPeriodicAdvertisingDataData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeSetPeriodicAdvertisingData(Arc::new(LeSetPeriodicAdvertisingDataData::parse(&bytes[..])?))}
OpCode::LeSetPeriodicAdvertisingEnable if LeSetPeriodicAdvertisingEnableData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeSetPeriodicAdvertisingEnable(Arc::new(LeSetPeriodicAdvertisingEnableData::parse(&bytes[..])?))}
OpCode::LePeriodicAdvertisingCreateSync if LePeriodicAdvertisingCreateSyncData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LePeriodicAdvertisingCreateSync(Arc::new(LePeriodicAdvertisingCreateSyncData::parse(&bytes[..])?))}
OpCode::LePeriodicAdvertisingCreateSyncCancel if LePeriodicAdvertisingCreateSyncCancelData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LePeriodicAdvertisingCreateSyncCancel(Arc::new(LePeriodicAdvertisingCreateSyncCancelData::parse(&bytes[..])?))}
OpCode::LePeriodicAdvertisingTerminateSync if LePeriodicAdvertisingTerminateSyncData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LePeriodicAdvertisingTerminateSync(Arc::new(LePeriodicAdvertisingTerminateSyncData::parse(&bytes[..])?))}
OpCode::LeAddDeviceToPeriodicAdvertisingList if LeAddDeviceToPeriodicAdvertisingListData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeAddDeviceToPeriodicAdvertisingList(Arc::new(LeAddDeviceToPeriodicAdvertisingListData::parse(&bytes[..])?))}
OpCode::LeRemoveDeviceFromPeriodicAdvertisingList if LeRemoveDeviceFromPeriodicAdvertisingListData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeRemoveDeviceFromPeriodicAdvertisingList(Arc::new(LeRemoveDeviceFromPeriodicAdvertisingListData::parse(&bytes[..])?))}
OpCode::LeClearPeriodicAdvertisingList if LeClearPeriodicAdvertisingListData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeClearPeriodicAdvertisingList(Arc::new(LeClearPeriodicAdvertisingListData::parse(&bytes[..])?))}
OpCode::LeReadTransmitPower if LeReadTransmitPowerData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeReadTransmitPower(Arc::new(LeReadTransmitPowerData::parse(&bytes[..])?))}
OpCode::LeReadRfPathCompensationPower if LeReadRfPathCompensationPowerData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeReadRfPathCompensationPower(Arc::new(LeReadRfPathCompensationPowerData::parse(&bytes[..])?))}
OpCode::LeWriteRfPathCompensationPower if LeWriteRfPathCompensationPowerData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeWriteRfPathCompensationPower(Arc::new(LeWriteRfPathCompensationPowerData::parse(&bytes[..])?))}
OpCode::LeMultiAdvt if LeMultiAdvtData::conforms(&bytes[..]) => {LeAdvertisingCommandDataChild::LeMultiAdvt(Arc::new(LeMultiAdvtData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "op_code".to_string(), value: v as u64}),};
Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {LeAdvertisingCommandDataChild::LeSetRandomAddress(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeSetAdvertisingParameters(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeReadAdvertisingPhysicalChannelTxPower(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeSetAdvertisingData(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeSetScanResponseData(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeSetAdvertisingEnable(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingRandomAddress(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingLegacyParameters(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingParameters(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingData(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingDataRaw(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingScanResponse(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingScanResponseRaw(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingEnableDisableAll(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingDisable(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingEnable(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeRemoveAdvertisingSet(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeClearAdvertisingSets(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeSetPeriodicAdvertisingParam(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeSetPeriodicAdvertisingData(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeSetPeriodicAdvertisingEnable(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LePeriodicAdvertisingCreateSync(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LePeriodicAdvertisingCreateSyncCancel(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LePeriodicAdvertisingTerminateSync(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeAddDeviceToPeriodicAdvertisingList(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeRemoveDeviceFromPeriodicAdvertisingList(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeClearPeriodicAdvertisingList(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeReadTransmitPower(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeReadRfPathCompensationPower(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeWriteRfPathCompensationPower(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::LeMultiAdvt(value) => value.write_to(buffer),LeAdvertisingCommandDataChild::Payload(p) => buffer[3..].copy_from_slice(&p[..]),LeAdvertisingCommandDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeAdvertisingCommandPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAdvertisingCommandPacket { pub fn specialize(&self) -> LeAdvertisingCommandChild { match &self.le_advertising_command.child {LeAdvertisingCommandDataChild::LeSetRandomAddress(_) => LeAdvertisingCommandChild::LeSetRandomAddress(LeSetRandomAddressPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeSetAdvertisingParameters(_) => LeAdvertisingCommandChild::LeSetAdvertisingParameters(LeSetAdvertisingParametersPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeReadAdvertisingPhysicalChannelTxPower(_) => LeAdvertisingCommandChild::LeReadAdvertisingPhysicalChannelTxPower(LeReadAdvertisingPhysicalChannelTxPowerPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeSetAdvertisingData(_) => LeAdvertisingCommandChild::LeSetAdvertisingData(LeSetAdvertisingDataPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeSetScanResponseData(_) => LeAdvertisingCommandChild::LeSetScanResponseData(LeSetScanResponseDataPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeSetAdvertisingEnable(_) => LeAdvertisingCommandChild::LeSetAdvertisingEnable(LeSetAdvertisingEnablePacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingRandomAddress(_) => LeAdvertisingCommandChild::LeSetExtendedAdvertisingRandomAddress(LeSetExtendedAdvertisingRandomAddressPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingLegacyParameters(_) => LeAdvertisingCommandChild::LeSetExtendedAdvertisingLegacyParameters(LeSetExtendedAdvertisingLegacyParametersPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingParameters(_) => LeAdvertisingCommandChild::LeSetExtendedAdvertisingParameters(LeSetExtendedAdvertisingParametersPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingData(_) => LeAdvertisingCommandChild::LeSetExtendedAdvertisingData(LeSetExtendedAdvertisingDataPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingDataRaw(_) => LeAdvertisingCommandChild::LeSetExtendedAdvertisingDataRaw(LeSetExtendedAdvertisingDataRawPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingScanResponse(_) => LeAdvertisingCommandChild::LeSetExtendedAdvertisingScanResponse(LeSetExtendedAdvertisingScanResponsePacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingScanResponseRaw(_) => LeAdvertisingCommandChild::LeSetExtendedAdvertisingScanResponseRaw(LeSetExtendedAdvertisingScanResponseRawPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingEnableDisableAll(_) => LeAdvertisingCommandChild::LeSetExtendedAdvertisingEnableDisableAll(LeSetExtendedAdvertisingEnableDisableAllPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingDisable(_) => LeAdvertisingCommandChild::LeSetExtendedAdvertisingDisable(LeSetExtendedAdvertisingDisablePacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingEnable(_) => LeAdvertisingCommandChild::LeSetExtendedAdvertisingEnable(LeSetExtendedAdvertisingEnablePacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeRemoveAdvertisingSet(_) => LeAdvertisingCommandChild::LeRemoveAdvertisingSet(LeRemoveAdvertisingSetPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeClearAdvertisingSets(_) => LeAdvertisingCommandChild::LeClearAdvertisingSets(LeClearAdvertisingSetsPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeSetPeriodicAdvertisingParam(_) => LeAdvertisingCommandChild::LeSetPeriodicAdvertisingParam(LeSetPeriodicAdvertisingParamPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeSetPeriodicAdvertisingData(_) => LeAdvertisingCommandChild::LeSetPeriodicAdvertisingData(LeSetPeriodicAdvertisingDataPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeSetPeriodicAdvertisingEnable(_) => LeAdvertisingCommandChild::LeSetPeriodicAdvertisingEnable(LeSetPeriodicAdvertisingEnablePacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LePeriodicAdvertisingCreateSync(_) => LeAdvertisingCommandChild::LePeriodicAdvertisingCreateSync(LePeriodicAdvertisingCreateSyncPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LePeriodicAdvertisingCreateSyncCancel(_) => LeAdvertisingCommandChild::LePeriodicAdvertisingCreateSyncCancel(LePeriodicAdvertisingCreateSyncCancelPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LePeriodicAdvertisingTerminateSync(_) => LeAdvertisingCommandChild::LePeriodicAdvertisingTerminateSync(LePeriodicAdvertisingTerminateSyncPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeAddDeviceToPeriodicAdvertisingList(_) => LeAdvertisingCommandChild::LeAddDeviceToPeriodicAdvertisingList(LeAddDeviceToPeriodicAdvertisingListPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeRemoveDeviceFromPeriodicAdvertisingList(_) => LeAdvertisingCommandChild::LeRemoveDeviceFromPeriodicAdvertisingList(LeRemoveDeviceFromPeriodicAdvertisingListPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeClearPeriodicAdvertisingList(_) => LeAdvertisingCommandChild::LeClearPeriodicAdvertisingList(LeClearPeriodicAdvertisingListPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeReadTransmitPower(_) => LeAdvertisingCommandChild::LeReadTransmitPower(LeReadTransmitPowerPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeReadRfPathCompensationPower(_) => LeAdvertisingCommandChild::LeReadRfPathCompensationPower(LeReadRfPathCompensationPowerPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeWriteRfPathCompensationPower(_) => LeAdvertisingCommandChild::LeWriteRfPathCompensationPower(LeWriteRfPathCompensationPowerPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::LeMultiAdvt(_) => LeAdvertisingCommandChild::LeMultiAdvt(LeMultiAdvtPacket::new(self.command.clone())),LeAdvertisingCommandDataChild::Payload(p) => LeAdvertisingCommandChild::Payload(p.clone()),LeAdvertisingCommandDataChild::None => LeAdvertisingCommandChild::None,}} fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};Self {command,le_advertising_command,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeAdvertisingCommandPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl LeAdvertisingCommandBuilder {pub fn build(self) -> LeAdvertisingCommandPacket {let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: match self.payload { None => LeAdvertisingCommandDataChild::None,Some(bytes) => LeAdvertisingCommandDataChild::Payload(bytes),},});let command= Arc::new(CommandData {op_code: self.op_code, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeAdvertisingCommandPacket::new(command)}
}
impl Into<CommandPacket> for LeAdvertisingCommandBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] enum LeScanningCommandDataChild {LeSetScanParameters(Arc<LeSetScanParametersData>),LeSetScanEnable(Arc<LeSetScanEnableData>),LeSetExtendedScanParameters(Arc<LeSetExtendedScanParametersData>),LeSetExtendedScanEnable(Arc<LeSetExtendedScanEnableData>),LeBatchScan(Arc<LeBatchScanData>),LeAdvFilter(Arc<LeAdvFilterData>),LeExtendedScanParams(Arc<LeExtendedScanParamsData>),Payload(Bytes),None,}
impl LeScanningCommandDataChild {fn get_total_size(&self) -> usize {match self {LeScanningCommandDataChild::LeSetScanParameters(value) => value.get_total_size(),LeScanningCommandDataChild::LeSetScanEnable(value) => value.get_total_size(),LeScanningCommandDataChild::LeSetExtendedScanParameters(value) => value.get_total_size(),LeScanningCommandDataChild::LeSetExtendedScanEnable(value) => value.get_total_size(),LeScanningCommandDataChild::LeBatchScan(value) => value.get_total_size(),LeScanningCommandDataChild::LeAdvFilter(value) => value.get_total_size(),LeScanningCommandDataChild::LeExtendedScanParams(value) => value.get_total_size(),LeScanningCommandDataChild::Payload(p) => p.len(),LeScanningCommandDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LeScanningCommandChild {LeSetScanParameters(LeSetScanParametersPacket),LeSetScanEnable(LeSetScanEnablePacket),LeSetExtendedScanParameters(LeSetExtendedScanParametersPacket),LeSetExtendedScanEnable(LeSetExtendedScanEnablePacket),LeBatchScan(LeBatchScanPacket),LeAdvFilter(LeAdvFilterPacket),LeExtendedScanParams(LeExtendedScanParamsPacket),Payload(Bytes),None,}
#[derive(Debug)] struct LeScanningCommandData {child: LeScanningCommandDataChild,}
#[derive(Debug, Clone)] pub struct LeScanningCommandPacket {command: Arc<CommandData>,le_scanning_command: Arc<LeScanningCommandData>,}
#[derive(Debug)] pub struct LeScanningCommandBuilder {pub op_code: OpCode, pub payload: Option<Bytes>,}
impl LeScanningCommandData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8], op_code: OpCode) -> Result<Self> {let payload: Vec::<u8> = bytes[3..].into();let child = match op_code {OpCode::LeSetScanParameters if LeSetScanParametersData::conforms(&bytes[..]) => {LeScanningCommandDataChild::LeSetScanParameters(Arc::new(LeSetScanParametersData::parse(&bytes[..])?))}
OpCode::LeSetScanEnable if LeSetScanEnableData::conforms(&bytes[..]) => {LeScanningCommandDataChild::LeSetScanEnable(Arc::new(LeSetScanEnableData::parse(&bytes[..])?))}
OpCode::LeSetExtendedScanParameters if LeSetExtendedScanParametersData::conforms(&bytes[..]) => {LeScanningCommandDataChild::LeSetExtendedScanParameters(Arc::new(LeSetExtendedScanParametersData::parse(&bytes[..])?))}
OpCode::LeSetExtendedScanEnable if LeSetExtendedScanEnableData::conforms(&bytes[..]) => {LeScanningCommandDataChild::LeSetExtendedScanEnable(Arc::new(LeSetExtendedScanEnableData::parse(&bytes[..])?))}
OpCode::LeBatchScan if LeBatchScanData::conforms(&bytes[..]) => {LeScanningCommandDataChild::LeBatchScan(Arc::new(LeBatchScanData::parse(&bytes[..])?))}
OpCode::LeAdvFilter if LeAdvFilterData::conforms(&bytes[..]) => {LeScanningCommandDataChild::LeAdvFilter(Arc::new(LeAdvFilterData::parse(&bytes[..])?))}
OpCode::LeExtendedScanParams if LeExtendedScanParamsData::conforms(&bytes[..]) => {LeScanningCommandDataChild::LeExtendedScanParams(Arc::new(LeExtendedScanParamsData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "op_code".to_string(), value: v as u64}),};
Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {LeScanningCommandDataChild::LeSetScanParameters(value) => value.write_to(buffer),LeScanningCommandDataChild::LeSetScanEnable(value) => value.write_to(buffer),LeScanningCommandDataChild::LeSetExtendedScanParameters(value) => value.write_to(buffer),LeScanningCommandDataChild::LeSetExtendedScanEnable(value) => value.write_to(buffer),LeScanningCommandDataChild::LeBatchScan(value) => value.write_to(buffer),LeScanningCommandDataChild::LeAdvFilter(value) => value.write_to(buffer),LeScanningCommandDataChild::LeExtendedScanParams(value) => value.write_to(buffer),LeScanningCommandDataChild::Payload(p) => buffer[3..].copy_from_slice(&p[..]),LeScanningCommandDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeScanningCommandPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeScanningCommandPacket { pub fn specialize(&self) -> LeScanningCommandChild { match &self.le_scanning_command.child {LeScanningCommandDataChild::LeSetScanParameters(_) => LeScanningCommandChild::LeSetScanParameters(LeSetScanParametersPacket::new(self.command.clone())),LeScanningCommandDataChild::LeSetScanEnable(_) => LeScanningCommandChild::LeSetScanEnable(LeSetScanEnablePacket::new(self.command.clone())),LeScanningCommandDataChild::LeSetExtendedScanParameters(_) => LeScanningCommandChild::LeSetExtendedScanParameters(LeSetExtendedScanParametersPacket::new(self.command.clone())),LeScanningCommandDataChild::LeSetExtendedScanEnable(_) => LeScanningCommandChild::LeSetExtendedScanEnable(LeSetExtendedScanEnablePacket::new(self.command.clone())),LeScanningCommandDataChild::LeBatchScan(_) => LeScanningCommandChild::LeBatchScan(LeBatchScanPacket::new(self.command.clone())),LeScanningCommandDataChild::LeAdvFilter(_) => LeScanningCommandChild::LeAdvFilter(LeAdvFilterPacket::new(self.command.clone())),LeScanningCommandDataChild::LeExtendedScanParams(_) => LeScanningCommandChild::LeExtendedScanParams(LeExtendedScanParamsPacket::new(self.command.clone())),LeScanningCommandDataChild::Payload(p) => LeScanningCommandChild::Payload(p.clone()),LeScanningCommandDataChild::None => LeScanningCommandChild::None,}} fn new(root: Arc<CommandData>) -> Self {let command = root;let le_scanning_command = match &command.child {CommandDataChild::LeScanningCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanningCommand"),};Self {command,le_scanning_command,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeScanningCommandPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl LeScanningCommandBuilder {pub fn build(self) -> LeScanningCommandPacket {let le_scanning_command= Arc::new(LeScanningCommandData {child: match self.payload { None => LeScanningCommandDataChild::None,Some(bytes) => LeScanningCommandDataChild::Payload(bytes),},});let command= Arc::new(CommandData {op_code: self.op_code, child: CommandDataChild::LeScanningCommand(le_scanning_command),});LeScanningCommandPacket::new(command)}
}
impl Into<CommandPacket> for LeScanningCommandBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] enum LeConnectionManagementCommandDataChild {LeCreateConnection(Arc<LeCreateConnectionData>),LeCreateConnectionCancel(Arc<LeCreateConnectionCancelData>),LeClearConnectList(Arc<LeClearConnectListData>),LeAddDeviceToConnectList(Arc<LeAddDeviceToConnectListData>),LeRemoveDeviceFromConnectList(Arc<LeRemoveDeviceFromConnectListData>),LeConnectionUpdate(Arc<LeConnectionUpdateData>),LeSetHostChannelClassification(Arc<LeSetHostChannelClassificationData>),LeReadChannelMap(Arc<LeReadChannelMapData>),LeReadRemoteFeatures(Arc<LeReadRemoteFeaturesData>),LeRemoteConnectionParameterRequestReply(Arc<LeRemoteConnectionParameterRequestReplyData>),LeRemoteConnectionParameterRequestNegativeReply(Arc<LeRemoteConnectionParameterRequestNegativeReplyData>),LeSetDataLength(Arc<LeSetDataLengthData>),LeReadSuggestedDefaultDataLength(Arc<LeReadSuggestedDefaultDataLengthData>),LeWriteSuggestedDefaultDataLength(Arc<LeWriteSuggestedDefaultDataLengthData>),LeReadPhy(Arc<LeReadPhyData>),LeSetDefaultPhy(Arc<LeSetDefaultPhyData>),LeSetPhy(Arc<LeSetPhyData>),LeExtendedCreateConnection(Arc<LeExtendedCreateConnectionData>),Payload(Bytes),None,}
impl LeConnectionManagementCommandDataChild {fn get_total_size(&self) -> usize {match self {LeConnectionManagementCommandDataChild::LeCreateConnection(value) => value.get_total_size(),LeConnectionManagementCommandDataChild::LeCreateConnectionCancel(value) => value.get_total_size(),LeConnectionManagementCommandDataChild::LeClearConnectList(value) => value.get_total_size(),LeConnectionManagementCommandDataChild::LeAddDeviceToConnectList(value) => value.get_total_size(),LeConnectionManagementCommandDataChild::LeRemoveDeviceFromConnectList(value) => value.get_total_size(),LeConnectionManagementCommandDataChild::LeConnectionUpdate(value) => value.get_total_size(),LeConnectionManagementCommandDataChild::LeSetHostChannelClassification(value) => value.get_total_size(),LeConnectionManagementCommandDataChild::LeReadChannelMap(value) => value.get_total_size(),LeConnectionManagementCommandDataChild::LeReadRemoteFeatures(value) => value.get_total_size(),LeConnectionManagementCommandDataChild::LeRemoteConnectionParameterRequestReply(value) => value.get_total_size(),LeConnectionManagementCommandDataChild::LeRemoteConnectionParameterRequestNegativeReply(value) => value.get_total_size(),LeConnectionManagementCommandDataChild::LeSetDataLength(value) => value.get_total_size(),LeConnectionManagementCommandDataChild::LeReadSuggestedDefaultDataLength(value) => value.get_total_size(),LeConnectionManagementCommandDataChild::LeWriteSuggestedDefaultDataLength(value) => value.get_total_size(),LeConnectionManagementCommandDataChild::LeReadPhy(value) => value.get_total_size(),LeConnectionManagementCommandDataChild::LeSetDefaultPhy(value) => value.get_total_size(),LeConnectionManagementCommandDataChild::LeSetPhy(value) => value.get_total_size(),LeConnectionManagementCommandDataChild::LeExtendedCreateConnection(value) => value.get_total_size(),LeConnectionManagementCommandDataChild::Payload(p) => p.len(),LeConnectionManagementCommandDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LeConnectionManagementCommandChild {LeCreateConnection(LeCreateConnectionPacket),LeCreateConnectionCancel(LeCreateConnectionCancelPacket),LeClearConnectList(LeClearConnectListPacket),LeAddDeviceToConnectList(LeAddDeviceToConnectListPacket),LeRemoveDeviceFromConnectList(LeRemoveDeviceFromConnectListPacket),LeConnectionUpdate(LeConnectionUpdatePacket),LeSetHostChannelClassification(LeSetHostChannelClassificationPacket),LeReadChannelMap(LeReadChannelMapPacket),LeReadRemoteFeatures(LeReadRemoteFeaturesPacket),LeRemoteConnectionParameterRequestReply(LeRemoteConnectionParameterRequestReplyPacket),LeRemoteConnectionParameterRequestNegativeReply(LeRemoteConnectionParameterRequestNegativeReplyPacket),LeSetDataLength(LeSetDataLengthPacket),LeReadSuggestedDefaultDataLength(LeReadSuggestedDefaultDataLengthPacket),LeWriteSuggestedDefaultDataLength(LeWriteSuggestedDefaultDataLengthPacket),LeReadPhy(LeReadPhyPacket),LeSetDefaultPhy(LeSetDefaultPhyPacket),LeSetPhy(LeSetPhyPacket),LeExtendedCreateConnection(LeExtendedCreateConnectionPacket),Payload(Bytes),None,}
#[derive(Debug)] struct LeConnectionManagementCommandData {child: LeConnectionManagementCommandDataChild,}
#[derive(Debug, Clone)] pub struct LeConnectionManagementCommandPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,le_connection_management_command: Arc<LeConnectionManagementCommandData>,}
#[derive(Debug)] pub struct LeConnectionManagementCommandBuilder {pub op_code: OpCode, pub payload: Option<Bytes>,}
impl LeConnectionManagementCommandData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8], op_code: OpCode) -> Result<Self> {let payload: Vec::<u8> = bytes[3..].into();let child = match op_code {OpCode::LeCreateConnection if LeCreateConnectionData::conforms(&bytes[..]) => {LeConnectionManagementCommandDataChild::LeCreateConnection(Arc::new(LeCreateConnectionData::parse(&bytes[..])?))}
OpCode::LeCreateConnectionCancel if LeCreateConnectionCancelData::conforms(&bytes[..]) => {LeConnectionManagementCommandDataChild::LeCreateConnectionCancel(Arc::new(LeCreateConnectionCancelData::parse(&bytes[..])?))}
OpCode::LeClearConnectList if LeClearConnectListData::conforms(&bytes[..]) => {LeConnectionManagementCommandDataChild::LeClearConnectList(Arc::new(LeClearConnectListData::parse(&bytes[..])?))}
OpCode::LeAddDeviceToConnectList if LeAddDeviceToConnectListData::conforms(&bytes[..]) => {LeConnectionManagementCommandDataChild::LeAddDeviceToConnectList(Arc::new(LeAddDeviceToConnectListData::parse(&bytes[..])?))}
OpCode::LeRemoveDeviceFromConnectList if LeRemoveDeviceFromConnectListData::conforms(&bytes[..]) => {LeConnectionManagementCommandDataChild::LeRemoveDeviceFromConnectList(Arc::new(LeRemoveDeviceFromConnectListData::parse(&bytes[..])?))}
OpCode::LeConnectionUpdate if LeConnectionUpdateData::conforms(&bytes[..]) => {LeConnectionManagementCommandDataChild::LeConnectionUpdate(Arc::new(LeConnectionUpdateData::parse(&bytes[..])?))}
OpCode::LeSetHostChannelClassification if LeSetHostChannelClassificationData::conforms(&bytes[..]) => {LeConnectionManagementCommandDataChild::LeSetHostChannelClassification(Arc::new(LeSetHostChannelClassificationData::parse(&bytes[..])?))}
OpCode::LeReadChannelMap if LeReadChannelMapData::conforms(&bytes[..]) => {LeConnectionManagementCommandDataChild::LeReadChannelMap(Arc::new(LeReadChannelMapData::parse(&bytes[..])?))}
OpCode::LeReadRemoteFeatures if LeReadRemoteFeaturesData::conforms(&bytes[..]) => {LeConnectionManagementCommandDataChild::LeReadRemoteFeatures(Arc::new(LeReadRemoteFeaturesData::parse(&bytes[..])?))}
OpCode::LeRemoteConnectionParameterRequestReply if LeRemoteConnectionParameterRequestReplyData::conforms(&bytes[..]) => {LeConnectionManagementCommandDataChild::LeRemoteConnectionParameterRequestReply(Arc::new(LeRemoteConnectionParameterRequestReplyData::parse(&bytes[..])?))}
OpCode::LeRemoteConnectionParameterRequestNegativeReply if LeRemoteConnectionParameterRequestNegativeReplyData::conforms(&bytes[..]) => {LeConnectionManagementCommandDataChild::LeRemoteConnectionParameterRequestNegativeReply(Arc::new(LeRemoteConnectionParameterRequestNegativeReplyData::parse(&bytes[..])?))}
OpCode::LeSetDataLength if LeSetDataLengthData::conforms(&bytes[..]) => {LeConnectionManagementCommandDataChild::LeSetDataLength(Arc::new(LeSetDataLengthData::parse(&bytes[..])?))}
OpCode::LeReadSuggestedDefaultDataLength if LeReadSuggestedDefaultDataLengthData::conforms(&bytes[..]) => {LeConnectionManagementCommandDataChild::LeReadSuggestedDefaultDataLength(Arc::new(LeReadSuggestedDefaultDataLengthData::parse(&bytes[..])?))}
OpCode::LeWriteSuggestedDefaultDataLength if LeWriteSuggestedDefaultDataLengthData::conforms(&bytes[..]) => {LeConnectionManagementCommandDataChild::LeWriteSuggestedDefaultDataLength(Arc::new(LeWriteSuggestedDefaultDataLengthData::parse(&bytes[..])?))}
OpCode::LeReadPhy if LeReadPhyData::conforms(&bytes[..]) => {LeConnectionManagementCommandDataChild::LeReadPhy(Arc::new(LeReadPhyData::parse(&bytes[..])?))}
OpCode::LeSetDefaultPhy if LeSetDefaultPhyData::conforms(&bytes[..]) => {LeConnectionManagementCommandDataChild::LeSetDefaultPhy(Arc::new(LeSetDefaultPhyData::parse(&bytes[..])?))}
OpCode::LeSetPhy if LeSetPhyData::conforms(&bytes[..]) => {LeConnectionManagementCommandDataChild::LeSetPhy(Arc::new(LeSetPhyData::parse(&bytes[..])?))}
OpCode::LeExtendedCreateConnection if LeExtendedCreateConnectionData::conforms(&bytes[..]) => {LeConnectionManagementCommandDataChild::LeExtendedCreateConnection(Arc::new(LeExtendedCreateConnectionData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "op_code".to_string(), value: v as u64}),};
Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {LeConnectionManagementCommandDataChild::LeCreateConnection(value) => value.write_to(buffer),LeConnectionManagementCommandDataChild::LeCreateConnectionCancel(value) => value.write_to(buffer),LeConnectionManagementCommandDataChild::LeClearConnectList(value) => value.write_to(buffer),LeConnectionManagementCommandDataChild::LeAddDeviceToConnectList(value) => value.write_to(buffer),LeConnectionManagementCommandDataChild::LeRemoveDeviceFromConnectList(value) => value.write_to(buffer),LeConnectionManagementCommandDataChild::LeConnectionUpdate(value) => value.write_to(buffer),LeConnectionManagementCommandDataChild::LeSetHostChannelClassification(value) => value.write_to(buffer),LeConnectionManagementCommandDataChild::LeReadChannelMap(value) => value.write_to(buffer),LeConnectionManagementCommandDataChild::LeReadRemoteFeatures(value) => value.write_to(buffer),LeConnectionManagementCommandDataChild::LeRemoteConnectionParameterRequestReply(value) => value.write_to(buffer),LeConnectionManagementCommandDataChild::LeRemoteConnectionParameterRequestNegativeReply(value) => value.write_to(buffer),LeConnectionManagementCommandDataChild::LeSetDataLength(value) => value.write_to(buffer),LeConnectionManagementCommandDataChild::LeReadSuggestedDefaultDataLength(value) => value.write_to(buffer),LeConnectionManagementCommandDataChild::LeWriteSuggestedDefaultDataLength(value) => value.write_to(buffer),LeConnectionManagementCommandDataChild::LeReadPhy(value) => value.write_to(buffer),LeConnectionManagementCommandDataChild::LeSetDefaultPhy(value) => value.write_to(buffer),LeConnectionManagementCommandDataChild::LeSetPhy(value) => value.write_to(buffer),LeConnectionManagementCommandDataChild::LeExtendedCreateConnection(value) => value.write_to(buffer),LeConnectionManagementCommandDataChild::Payload(p) => buffer[3..].copy_from_slice(&p[..]),LeConnectionManagementCommandDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeConnectionManagementCommandPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeConnectionManagementCommandPacket { pub fn specialize(&self) -> LeConnectionManagementCommandChild { match &self.le_connection_management_command.child {LeConnectionManagementCommandDataChild::LeCreateConnection(_) => LeConnectionManagementCommandChild::LeCreateConnection(LeCreateConnectionPacket::new(self.command.clone())),LeConnectionManagementCommandDataChild::LeCreateConnectionCancel(_) => LeConnectionManagementCommandChild::LeCreateConnectionCancel(LeCreateConnectionCancelPacket::new(self.command.clone())),LeConnectionManagementCommandDataChild::LeClearConnectList(_) => LeConnectionManagementCommandChild::LeClearConnectList(LeClearConnectListPacket::new(self.command.clone())),LeConnectionManagementCommandDataChild::LeAddDeviceToConnectList(_) => LeConnectionManagementCommandChild::LeAddDeviceToConnectList(LeAddDeviceToConnectListPacket::new(self.command.clone())),LeConnectionManagementCommandDataChild::LeRemoveDeviceFromConnectList(_) => LeConnectionManagementCommandChild::LeRemoveDeviceFromConnectList(LeRemoveDeviceFromConnectListPacket::new(self.command.clone())),LeConnectionManagementCommandDataChild::LeConnectionUpdate(_) => LeConnectionManagementCommandChild::LeConnectionUpdate(LeConnectionUpdatePacket::new(self.command.clone())),LeConnectionManagementCommandDataChild::LeSetHostChannelClassification(_) => LeConnectionManagementCommandChild::LeSetHostChannelClassification(LeSetHostChannelClassificationPacket::new(self.command.clone())),LeConnectionManagementCommandDataChild::LeReadChannelMap(_) => LeConnectionManagementCommandChild::LeReadChannelMap(LeReadChannelMapPacket::new(self.command.clone())),LeConnectionManagementCommandDataChild::LeReadRemoteFeatures(_) => LeConnectionManagementCommandChild::LeReadRemoteFeatures(LeReadRemoteFeaturesPacket::new(self.command.clone())),LeConnectionManagementCommandDataChild::LeRemoteConnectionParameterRequestReply(_) => LeConnectionManagementCommandChild::LeRemoteConnectionParameterRequestReply(LeRemoteConnectionParameterRequestReplyPacket::new(self.command.clone())),LeConnectionManagementCommandDataChild::LeRemoteConnectionParameterRequestNegativeReply(_) => LeConnectionManagementCommandChild::LeRemoteConnectionParameterRequestNegativeReply(LeRemoteConnectionParameterRequestNegativeReplyPacket::new(self.command.clone())),LeConnectionManagementCommandDataChild::LeSetDataLength(_) => LeConnectionManagementCommandChild::LeSetDataLength(LeSetDataLengthPacket::new(self.command.clone())),LeConnectionManagementCommandDataChild::LeReadSuggestedDefaultDataLength(_) => LeConnectionManagementCommandChild::LeReadSuggestedDefaultDataLength(LeReadSuggestedDefaultDataLengthPacket::new(self.command.clone())),LeConnectionManagementCommandDataChild::LeWriteSuggestedDefaultDataLength(_) => LeConnectionManagementCommandChild::LeWriteSuggestedDefaultDataLength(LeWriteSuggestedDefaultDataLengthPacket::new(self.command.clone())),LeConnectionManagementCommandDataChild::LeReadPhy(_) => LeConnectionManagementCommandChild::LeReadPhy(LeReadPhyPacket::new(self.command.clone())),LeConnectionManagementCommandDataChild::LeSetDefaultPhy(_) => LeConnectionManagementCommandChild::LeSetDefaultPhy(LeSetDefaultPhyPacket::new(self.command.clone())),LeConnectionManagementCommandDataChild::LeSetPhy(_) => LeConnectionManagementCommandChild::LeSetPhy(LeSetPhyPacket::new(self.command.clone())),LeConnectionManagementCommandDataChild::LeExtendedCreateConnection(_) => LeConnectionManagementCommandChild::LeExtendedCreateConnection(LeExtendedCreateConnectionPacket::new(self.command.clone())),LeConnectionManagementCommandDataChild::Payload(p) => LeConnectionManagementCommandChild::Payload(p.clone()),LeConnectionManagementCommandDataChild::None => LeConnectionManagementCommandChild::None,}} fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let le_connection_management_command = match &acl_command.child {AclCommandDataChild::LeConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeConnectionManagementCommand"),};Self {command,acl_command,le_connection_management_command,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeConnectionManagementCommandPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for LeConnectionManagementCommandPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl LeConnectionManagementCommandBuilder {pub fn build(self) -> LeConnectionManagementCommandPacket {let le_connection_management_command= Arc::new(LeConnectionManagementCommandData {child: match self.payload { None => LeConnectionManagementCommandDataChild::None,Some(bytes) => LeConnectionManagementCommandDataChild::Payload(bytes),},});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::LeConnectionManagementCommand(le_connection_management_command),});let command= Arc::new(CommandData {op_code: self.op_code, child: CommandDataChild::AclCommand(acl_command),});LeConnectionManagementCommandPacket::new(command)}
}
impl Into<CommandPacket> for LeConnectionManagementCommandBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for LeConnectionManagementCommandBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}


#[derive(Debug)] enum LeSecurityCommandDataChild {LeEncrypt(Arc<LeEncryptData>),LeRand(Arc<LeRandData>),LeStartEncryption(Arc<LeStartEncryptionData>),LeLongTermKeyRequestReply(Arc<LeLongTermKeyRequestReplyData>),LeLongTermKeyRequestNegativeReply(Arc<LeLongTermKeyRequestNegativeReplyData>),LeReadLocalP256PublicKeyCommand(Arc<LeReadLocalP256PublicKeyCommandData>),LeGenerateDhkeyV1Command(Arc<LeGenerateDhkeyV1CommandData>),LeAddDeviceToResolvingList(Arc<LeAddDeviceToResolvingListData>),LeRemoveDeviceFromResolvingList(Arc<LeRemoveDeviceFromResolvingListData>),LeClearResolvingList(Arc<LeClearResolvingListData>),LeReadPeerResolvableAddress(Arc<LeReadPeerResolvableAddressData>),LeReadLocalResolvableAddress(Arc<LeReadLocalResolvableAddressData>),LeSetAddressResolutionEnable(Arc<LeSetAddressResolutionEnableData>),LeSetResolvablePrivateAddressTimeout(Arc<LeSetResolvablePrivateAddressTimeoutData>),LeSetPrivacyMode(Arc<LeSetPrivacyModeData>),LeGenerateDhkeyCommand(Arc<LeGenerateDhkeyCommandData>),Payload(Bytes),None,}
impl LeSecurityCommandDataChild {fn get_total_size(&self) -> usize {match self {LeSecurityCommandDataChild::LeEncrypt(value) => value.get_total_size(),LeSecurityCommandDataChild::LeRand(value) => value.get_total_size(),LeSecurityCommandDataChild::LeStartEncryption(value) => value.get_total_size(),LeSecurityCommandDataChild::LeLongTermKeyRequestReply(value) => value.get_total_size(),LeSecurityCommandDataChild::LeLongTermKeyRequestNegativeReply(value) => value.get_total_size(),LeSecurityCommandDataChild::LeReadLocalP256PublicKeyCommand(value) => value.get_total_size(),LeSecurityCommandDataChild::LeGenerateDhkeyV1Command(value) => value.get_total_size(),LeSecurityCommandDataChild::LeAddDeviceToResolvingList(value) => value.get_total_size(),LeSecurityCommandDataChild::LeRemoveDeviceFromResolvingList(value) => value.get_total_size(),LeSecurityCommandDataChild::LeClearResolvingList(value) => value.get_total_size(),LeSecurityCommandDataChild::LeReadPeerResolvableAddress(value) => value.get_total_size(),LeSecurityCommandDataChild::LeReadLocalResolvableAddress(value) => value.get_total_size(),LeSecurityCommandDataChild::LeSetAddressResolutionEnable(value) => value.get_total_size(),LeSecurityCommandDataChild::LeSetResolvablePrivateAddressTimeout(value) => value.get_total_size(),LeSecurityCommandDataChild::LeSetPrivacyMode(value) => value.get_total_size(),LeSecurityCommandDataChild::LeGenerateDhkeyCommand(value) => value.get_total_size(),LeSecurityCommandDataChild::Payload(p) => p.len(),LeSecurityCommandDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LeSecurityCommandChild {LeEncrypt(LeEncryptPacket),LeRand(LeRandPacket),LeStartEncryption(LeStartEncryptionPacket),LeLongTermKeyRequestReply(LeLongTermKeyRequestReplyPacket),LeLongTermKeyRequestNegativeReply(LeLongTermKeyRequestNegativeReplyPacket),LeReadLocalP256PublicKeyCommand(LeReadLocalP256PublicKeyCommandPacket),LeGenerateDhkeyV1Command(LeGenerateDhkeyV1CommandPacket),LeAddDeviceToResolvingList(LeAddDeviceToResolvingListPacket),LeRemoveDeviceFromResolvingList(LeRemoveDeviceFromResolvingListPacket),LeClearResolvingList(LeClearResolvingListPacket),LeReadPeerResolvableAddress(LeReadPeerResolvableAddressPacket),LeReadLocalResolvableAddress(LeReadLocalResolvableAddressPacket),LeSetAddressResolutionEnable(LeSetAddressResolutionEnablePacket),LeSetResolvablePrivateAddressTimeout(LeSetResolvablePrivateAddressTimeoutPacket),LeSetPrivacyMode(LeSetPrivacyModePacket),LeGenerateDhkeyCommand(LeGenerateDhkeyCommandPacket),Payload(Bytes),None,}
#[derive(Debug)] struct LeSecurityCommandData {child: LeSecurityCommandDataChild,}
#[derive(Debug, Clone)] pub struct LeSecurityCommandPacket {command: Arc<CommandData>,le_security_command: Arc<LeSecurityCommandData>,}
#[derive(Debug)] pub struct LeSecurityCommandBuilder {pub op_code: OpCode, pub payload: Option<Bytes>,}
impl LeSecurityCommandData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8], op_code: OpCode) -> Result<Self> {let payload: Vec::<u8> = bytes[3..].into();let child = match op_code {OpCode::LeEncrypt if LeEncryptData::conforms(&bytes[..]) => {LeSecurityCommandDataChild::LeEncrypt(Arc::new(LeEncryptData::parse(&bytes[..])?))}
OpCode::LeRand if LeRandData::conforms(&bytes[..]) => {LeSecurityCommandDataChild::LeRand(Arc::new(LeRandData::parse(&bytes[..])?))}
OpCode::LeStartEncryption if LeStartEncryptionData::conforms(&bytes[..]) => {LeSecurityCommandDataChild::LeStartEncryption(Arc::new(LeStartEncryptionData::parse(&bytes[..])?))}
OpCode::LeLongTermKeyRequestReply if LeLongTermKeyRequestReplyData::conforms(&bytes[..]) => {LeSecurityCommandDataChild::LeLongTermKeyRequestReply(Arc::new(LeLongTermKeyRequestReplyData::parse(&bytes[..])?))}
OpCode::LeLongTermKeyRequestNegativeReply if LeLongTermKeyRequestNegativeReplyData::conforms(&bytes[..]) => {LeSecurityCommandDataChild::LeLongTermKeyRequestNegativeReply(Arc::new(LeLongTermKeyRequestNegativeReplyData::parse(&bytes[..])?))}
OpCode::LeReadLocalP256PublicKeyCommand if LeReadLocalP256PublicKeyCommandData::conforms(&bytes[..]) => {LeSecurityCommandDataChild::LeReadLocalP256PublicKeyCommand(Arc::new(LeReadLocalP256PublicKeyCommandData::parse(&bytes[..])?))}
OpCode::LeGenerateDhkeyCommandV1 if LeGenerateDhkeyV1CommandData::conforms(&bytes[..]) => {LeSecurityCommandDataChild::LeGenerateDhkeyV1Command(Arc::new(LeGenerateDhkeyV1CommandData::parse(&bytes[..])?))}
OpCode::LeAddDeviceToResolvingList if LeAddDeviceToResolvingListData::conforms(&bytes[..]) => {LeSecurityCommandDataChild::LeAddDeviceToResolvingList(Arc::new(LeAddDeviceToResolvingListData::parse(&bytes[..])?))}
OpCode::LeRemoveDeviceFromResolvingList if LeRemoveDeviceFromResolvingListData::conforms(&bytes[..]) => {LeSecurityCommandDataChild::LeRemoveDeviceFromResolvingList(Arc::new(LeRemoveDeviceFromResolvingListData::parse(&bytes[..])?))}
OpCode::LeClearResolvingList if LeClearResolvingListData::conforms(&bytes[..]) => {LeSecurityCommandDataChild::LeClearResolvingList(Arc::new(LeClearResolvingListData::parse(&bytes[..])?))}
OpCode::LeReadPeerResolvableAddress if LeReadPeerResolvableAddressData::conforms(&bytes[..]) => {LeSecurityCommandDataChild::LeReadPeerResolvableAddress(Arc::new(LeReadPeerResolvableAddressData::parse(&bytes[..])?))}
OpCode::LeReadLocalResolvableAddress if LeReadLocalResolvableAddressData::conforms(&bytes[..]) => {LeSecurityCommandDataChild::LeReadLocalResolvableAddress(Arc::new(LeReadLocalResolvableAddressData::parse(&bytes[..])?))}
OpCode::LeSetAddressResolutionEnable if LeSetAddressResolutionEnableData::conforms(&bytes[..]) => {LeSecurityCommandDataChild::LeSetAddressResolutionEnable(Arc::new(LeSetAddressResolutionEnableData::parse(&bytes[..])?))}
OpCode::LeSetResolvablePrivateAddressTimeout if LeSetResolvablePrivateAddressTimeoutData::conforms(&bytes[..]) => {LeSecurityCommandDataChild::LeSetResolvablePrivateAddressTimeout(Arc::new(LeSetResolvablePrivateAddressTimeoutData::parse(&bytes[..])?))}
OpCode::LeSetPrivacyMode if LeSetPrivacyModeData::conforms(&bytes[..]) => {LeSecurityCommandDataChild::LeSetPrivacyMode(Arc::new(LeSetPrivacyModeData::parse(&bytes[..])?))}
OpCode::LeGenerateDhkeyCommand if LeGenerateDhkeyCommandData::conforms(&bytes[..]) => {LeSecurityCommandDataChild::LeGenerateDhkeyCommand(Arc::new(LeGenerateDhkeyCommandData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "op_code".to_string(), value: v as u64}),};
Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {LeSecurityCommandDataChild::LeEncrypt(value) => value.write_to(buffer),LeSecurityCommandDataChild::LeRand(value) => value.write_to(buffer),LeSecurityCommandDataChild::LeStartEncryption(value) => value.write_to(buffer),LeSecurityCommandDataChild::LeLongTermKeyRequestReply(value) => value.write_to(buffer),LeSecurityCommandDataChild::LeLongTermKeyRequestNegativeReply(value) => value.write_to(buffer),LeSecurityCommandDataChild::LeReadLocalP256PublicKeyCommand(value) => value.write_to(buffer),LeSecurityCommandDataChild::LeGenerateDhkeyV1Command(value) => value.write_to(buffer),LeSecurityCommandDataChild::LeAddDeviceToResolvingList(value) => value.write_to(buffer),LeSecurityCommandDataChild::LeRemoveDeviceFromResolvingList(value) => value.write_to(buffer),LeSecurityCommandDataChild::LeClearResolvingList(value) => value.write_to(buffer),LeSecurityCommandDataChild::LeReadPeerResolvableAddress(value) => value.write_to(buffer),LeSecurityCommandDataChild::LeReadLocalResolvableAddress(value) => value.write_to(buffer),LeSecurityCommandDataChild::LeSetAddressResolutionEnable(value) => value.write_to(buffer),LeSecurityCommandDataChild::LeSetResolvablePrivateAddressTimeout(value) => value.write_to(buffer),LeSecurityCommandDataChild::LeSetPrivacyMode(value) => value.write_to(buffer),LeSecurityCommandDataChild::LeGenerateDhkeyCommand(value) => value.write_to(buffer),LeSecurityCommandDataChild::Payload(p) => buffer[3..].copy_from_slice(&p[..]),LeSecurityCommandDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeSecurityCommandPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSecurityCommandPacket { pub fn specialize(&self) -> LeSecurityCommandChild { match &self.le_security_command.child {LeSecurityCommandDataChild::LeEncrypt(_) => LeSecurityCommandChild::LeEncrypt(LeEncryptPacket::new(self.command.clone())),LeSecurityCommandDataChild::LeRand(_) => LeSecurityCommandChild::LeRand(LeRandPacket::new(self.command.clone())),LeSecurityCommandDataChild::LeStartEncryption(_) => LeSecurityCommandChild::LeStartEncryption(LeStartEncryptionPacket::new(self.command.clone())),LeSecurityCommandDataChild::LeLongTermKeyRequestReply(_) => LeSecurityCommandChild::LeLongTermKeyRequestReply(LeLongTermKeyRequestReplyPacket::new(self.command.clone())),LeSecurityCommandDataChild::LeLongTermKeyRequestNegativeReply(_) => LeSecurityCommandChild::LeLongTermKeyRequestNegativeReply(LeLongTermKeyRequestNegativeReplyPacket::new(self.command.clone())),LeSecurityCommandDataChild::LeReadLocalP256PublicKeyCommand(_) => LeSecurityCommandChild::LeReadLocalP256PublicKeyCommand(LeReadLocalP256PublicKeyCommandPacket::new(self.command.clone())),LeSecurityCommandDataChild::LeGenerateDhkeyV1Command(_) => LeSecurityCommandChild::LeGenerateDhkeyV1Command(LeGenerateDhkeyV1CommandPacket::new(self.command.clone())),LeSecurityCommandDataChild::LeAddDeviceToResolvingList(_) => LeSecurityCommandChild::LeAddDeviceToResolvingList(LeAddDeviceToResolvingListPacket::new(self.command.clone())),LeSecurityCommandDataChild::LeRemoveDeviceFromResolvingList(_) => LeSecurityCommandChild::LeRemoveDeviceFromResolvingList(LeRemoveDeviceFromResolvingListPacket::new(self.command.clone())),LeSecurityCommandDataChild::LeClearResolvingList(_) => LeSecurityCommandChild::LeClearResolvingList(LeClearResolvingListPacket::new(self.command.clone())),LeSecurityCommandDataChild::LeReadPeerResolvableAddress(_) => LeSecurityCommandChild::LeReadPeerResolvableAddress(LeReadPeerResolvableAddressPacket::new(self.command.clone())),LeSecurityCommandDataChild::LeReadLocalResolvableAddress(_) => LeSecurityCommandChild::LeReadLocalResolvableAddress(LeReadLocalResolvableAddressPacket::new(self.command.clone())),LeSecurityCommandDataChild::LeSetAddressResolutionEnable(_) => LeSecurityCommandChild::LeSetAddressResolutionEnable(LeSetAddressResolutionEnablePacket::new(self.command.clone())),LeSecurityCommandDataChild::LeSetResolvablePrivateAddressTimeout(_) => LeSecurityCommandChild::LeSetResolvablePrivateAddressTimeout(LeSetResolvablePrivateAddressTimeoutPacket::new(self.command.clone())),LeSecurityCommandDataChild::LeSetPrivacyMode(_) => LeSecurityCommandChild::LeSetPrivacyMode(LeSetPrivacyModePacket::new(self.command.clone())),LeSecurityCommandDataChild::LeGenerateDhkeyCommand(_) => LeSecurityCommandChild::LeGenerateDhkeyCommand(LeGenerateDhkeyCommandPacket::new(self.command.clone())),LeSecurityCommandDataChild::Payload(p) => LeSecurityCommandChild::Payload(p.clone()),LeSecurityCommandDataChild::None => LeSecurityCommandChild::None,}} fn new(root: Arc<CommandData>) -> Self {let command = root;let le_security_command = match &command.child {CommandDataChild::LeSecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSecurityCommand"),};Self {command,le_security_command,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeSecurityCommandPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl LeSecurityCommandBuilder {pub fn build(self) -> LeSecurityCommandPacket {let le_security_command= Arc::new(LeSecurityCommandData {child: match self.payload { None => LeSecurityCommandDataChild::None,Some(bytes) => LeSecurityCommandDataChild::Payload(bytes),},});let command= Arc::new(CommandData {op_code: self.op_code, child: CommandDataChild::LeSecurityCommand(le_security_command),});LeSecurityCommandPacket::new(command)}
}
impl Into<CommandPacket> for LeSecurityCommandBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] enum LeIsoCommandDataChild {LeReadIsoTxSync(Arc<LeReadIsoTxSyncData>),LeSetCigParameters(Arc<LeSetCigParametersData>),LeSetCigParametersTest(Arc<LeSetCigParametersTestData>),LeCreateCis(Arc<LeCreateCisData>),LeRemoveCig(Arc<LeRemoveCigData>),LeAcceptCisRequest(Arc<LeAcceptCisRequestData>),LeRejectCisRequest(Arc<LeRejectCisRequestData>),LeCreateBig(Arc<LeCreateBigData>),LeTerminateBig(Arc<LeTerminateBigData>),LeBigCreateSync(Arc<LeBigCreateSyncData>),LeBigTerminateSync(Arc<LeBigTerminateSyncData>),LeSetupIsoDataPath(Arc<LeSetupIsoDataPathData>),LeRemoveIsoDataPath(Arc<LeRemoveIsoDataPathData>),LeReadIsoLinkQuality(Arc<LeReadIsoLinkQualityData>),Payload(Bytes),None,}
impl LeIsoCommandDataChild {fn get_total_size(&self) -> usize {match self {LeIsoCommandDataChild::LeReadIsoTxSync(value) => value.get_total_size(),LeIsoCommandDataChild::LeSetCigParameters(value) => value.get_total_size(),LeIsoCommandDataChild::LeSetCigParametersTest(value) => value.get_total_size(),LeIsoCommandDataChild::LeCreateCis(value) => value.get_total_size(),LeIsoCommandDataChild::LeRemoveCig(value) => value.get_total_size(),LeIsoCommandDataChild::LeAcceptCisRequest(value) => value.get_total_size(),LeIsoCommandDataChild::LeRejectCisRequest(value) => value.get_total_size(),LeIsoCommandDataChild::LeCreateBig(value) => value.get_total_size(),LeIsoCommandDataChild::LeTerminateBig(value) => value.get_total_size(),LeIsoCommandDataChild::LeBigCreateSync(value) => value.get_total_size(),LeIsoCommandDataChild::LeBigTerminateSync(value) => value.get_total_size(),LeIsoCommandDataChild::LeSetupIsoDataPath(value) => value.get_total_size(),LeIsoCommandDataChild::LeRemoveIsoDataPath(value) => value.get_total_size(),LeIsoCommandDataChild::LeReadIsoLinkQuality(value) => value.get_total_size(),LeIsoCommandDataChild::Payload(p) => p.len(),LeIsoCommandDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LeIsoCommandChild {LeReadIsoTxSync(LeReadIsoTxSyncPacket),LeSetCigParameters(LeSetCigParametersPacket),LeSetCigParametersTest(LeSetCigParametersTestPacket),LeCreateCis(LeCreateCisPacket),LeRemoveCig(LeRemoveCigPacket),LeAcceptCisRequest(LeAcceptCisRequestPacket),LeRejectCisRequest(LeRejectCisRequestPacket),LeCreateBig(LeCreateBigPacket),LeTerminateBig(LeTerminateBigPacket),LeBigCreateSync(LeBigCreateSyncPacket),LeBigTerminateSync(LeBigTerminateSyncPacket),LeSetupIsoDataPath(LeSetupIsoDataPathPacket),LeRemoveIsoDataPath(LeRemoveIsoDataPathPacket),LeReadIsoLinkQuality(LeReadIsoLinkQualityPacket),Payload(Bytes),None,}
#[derive(Debug)] struct LeIsoCommandData {child: LeIsoCommandDataChild,}
#[derive(Debug, Clone)] pub struct LeIsoCommandPacket {command: Arc<CommandData>,le_iso_command: Arc<LeIsoCommandData>,}
#[derive(Debug)] pub struct LeIsoCommandBuilder {pub op_code: OpCode, pub payload: Option<Bytes>,}
impl LeIsoCommandData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8], op_code: OpCode) -> Result<Self> {let payload: Vec::<u8> = bytes[3..].into();let child = match op_code {OpCode::LeReadIsoTxSync if LeReadIsoTxSyncData::conforms(&bytes[..]) => {LeIsoCommandDataChild::LeReadIsoTxSync(Arc::new(LeReadIsoTxSyncData::parse(&bytes[..])?))}
OpCode::LeSetCigParameters if LeSetCigParametersData::conforms(&bytes[..]) => {LeIsoCommandDataChild::LeSetCigParameters(Arc::new(LeSetCigParametersData::parse(&bytes[..])?))}
OpCode::LeSetCigParametersTest if LeSetCigParametersTestData::conforms(&bytes[..]) => {LeIsoCommandDataChild::LeSetCigParametersTest(Arc::new(LeSetCigParametersTestData::parse(&bytes[..])?))}
OpCode::LeSetupIsoDataPath if LeSetupIsoDataPathData::conforms(&bytes[..]) => {LeIsoCommandDataChild::LeSetupIsoDataPath(Arc::new(LeSetupIsoDataPathData::parse(&bytes[..])?))}
OpCode::LeCreateCis if LeCreateCisData::conforms(&bytes[..]) => {LeIsoCommandDataChild::LeCreateCis(Arc::new(LeCreateCisData::parse(&bytes[..])?))}
OpCode::LeRemoveCig if LeRemoveCigData::conforms(&bytes[..]) => {LeIsoCommandDataChild::LeRemoveCig(Arc::new(LeRemoveCigData::parse(&bytes[..])?))}
OpCode::LeAcceptCisRequest if LeAcceptCisRequestData::conforms(&bytes[..]) => {LeIsoCommandDataChild::LeAcceptCisRequest(Arc::new(LeAcceptCisRequestData::parse(&bytes[..])?))}
OpCode::LeRejectCisRequest if LeRejectCisRequestData::conforms(&bytes[..]) => {LeIsoCommandDataChild::LeRejectCisRequest(Arc::new(LeRejectCisRequestData::parse(&bytes[..])?))}
OpCode::LeCreateBig if LeCreateBigData::conforms(&bytes[..]) => {LeIsoCommandDataChild::LeCreateBig(Arc::new(LeCreateBigData::parse(&bytes[..])?))}
OpCode::LeTerminateBig if LeTerminateBigData::conforms(&bytes[..]) => {LeIsoCommandDataChild::LeTerminateBig(Arc::new(LeTerminateBigData::parse(&bytes[..])?))}
OpCode::LeBigCreateSync if LeBigCreateSyncData::conforms(&bytes[..]) => {LeIsoCommandDataChild::LeBigCreateSync(Arc::new(LeBigCreateSyncData::parse(&bytes[..])?))}
OpCode::LeBigTerminateSync if LeBigTerminateSyncData::conforms(&bytes[..]) => {LeIsoCommandDataChild::LeBigTerminateSync(Arc::new(LeBigTerminateSyncData::parse(&bytes[..])?))}
OpCode::LeRemoveIsoDataPath if LeRemoveIsoDataPathData::conforms(&bytes[..]) => {LeIsoCommandDataChild::LeRemoveIsoDataPath(Arc::new(LeRemoveIsoDataPathData::parse(&bytes[..])?))}
OpCode::LeReadIsoLinkQuality if LeReadIsoLinkQualityData::conforms(&bytes[..]) => {LeIsoCommandDataChild::LeReadIsoLinkQuality(Arc::new(LeReadIsoLinkQualityData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "op_code".to_string(), value: v as u64}),};
Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {LeIsoCommandDataChild::LeReadIsoTxSync(value) => value.write_to(buffer),LeIsoCommandDataChild::LeSetCigParameters(value) => value.write_to(buffer),LeIsoCommandDataChild::LeSetCigParametersTest(value) => value.write_to(buffer),LeIsoCommandDataChild::LeCreateCis(value) => value.write_to(buffer),LeIsoCommandDataChild::LeRemoveCig(value) => value.write_to(buffer),LeIsoCommandDataChild::LeAcceptCisRequest(value) => value.write_to(buffer),LeIsoCommandDataChild::LeRejectCisRequest(value) => value.write_to(buffer),LeIsoCommandDataChild::LeCreateBig(value) => value.write_to(buffer),LeIsoCommandDataChild::LeTerminateBig(value) => value.write_to(buffer),LeIsoCommandDataChild::LeBigCreateSync(value) => value.write_to(buffer),LeIsoCommandDataChild::LeBigTerminateSync(value) => value.write_to(buffer),LeIsoCommandDataChild::LeSetupIsoDataPath(value) => value.write_to(buffer),LeIsoCommandDataChild::LeRemoveIsoDataPath(value) => value.write_to(buffer),LeIsoCommandDataChild::LeReadIsoLinkQuality(value) => value.write_to(buffer),LeIsoCommandDataChild::Payload(p) => buffer[3..].copy_from_slice(&p[..]),LeIsoCommandDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeIsoCommandPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeIsoCommandPacket { pub fn specialize(&self) -> LeIsoCommandChild { match &self.le_iso_command.child {LeIsoCommandDataChild::LeReadIsoTxSync(_) => LeIsoCommandChild::LeReadIsoTxSync(LeReadIsoTxSyncPacket::new(self.command.clone())),LeIsoCommandDataChild::LeSetCigParameters(_) => LeIsoCommandChild::LeSetCigParameters(LeSetCigParametersPacket::new(self.command.clone())),LeIsoCommandDataChild::LeSetCigParametersTest(_) => LeIsoCommandChild::LeSetCigParametersTest(LeSetCigParametersTestPacket::new(self.command.clone())),LeIsoCommandDataChild::LeCreateCis(_) => LeIsoCommandChild::LeCreateCis(LeCreateCisPacket::new(self.command.clone())),LeIsoCommandDataChild::LeRemoveCig(_) => LeIsoCommandChild::LeRemoveCig(LeRemoveCigPacket::new(self.command.clone())),LeIsoCommandDataChild::LeAcceptCisRequest(_) => LeIsoCommandChild::LeAcceptCisRequest(LeAcceptCisRequestPacket::new(self.command.clone())),LeIsoCommandDataChild::LeRejectCisRequest(_) => LeIsoCommandChild::LeRejectCisRequest(LeRejectCisRequestPacket::new(self.command.clone())),LeIsoCommandDataChild::LeCreateBig(_) => LeIsoCommandChild::LeCreateBig(LeCreateBigPacket::new(self.command.clone())),LeIsoCommandDataChild::LeTerminateBig(_) => LeIsoCommandChild::LeTerminateBig(LeTerminateBigPacket::new(self.command.clone())),LeIsoCommandDataChild::LeBigCreateSync(_) => LeIsoCommandChild::LeBigCreateSync(LeBigCreateSyncPacket::new(self.command.clone())),LeIsoCommandDataChild::LeBigTerminateSync(_) => LeIsoCommandChild::LeBigTerminateSync(LeBigTerminateSyncPacket::new(self.command.clone())),LeIsoCommandDataChild::LeSetupIsoDataPath(_) => LeIsoCommandChild::LeSetupIsoDataPath(LeSetupIsoDataPathPacket::new(self.command.clone())),LeIsoCommandDataChild::LeRemoveIsoDataPath(_) => LeIsoCommandChild::LeRemoveIsoDataPath(LeRemoveIsoDataPathPacket::new(self.command.clone())),LeIsoCommandDataChild::LeReadIsoLinkQuality(_) => LeIsoCommandChild::LeReadIsoLinkQuality(LeReadIsoLinkQualityPacket::new(self.command.clone())),LeIsoCommandDataChild::Payload(p) => LeIsoCommandChild::Payload(p.clone()),LeIsoCommandDataChild::None => LeIsoCommandChild::None,}} fn new(root: Arc<CommandData>) -> Self {let command = root;let le_iso_command = match &command.child {CommandDataChild::LeIsoCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeIsoCommand"),};Self {command,le_iso_command,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeIsoCommandPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl LeIsoCommandBuilder {pub fn build(self) -> LeIsoCommandPacket {let le_iso_command= Arc::new(LeIsoCommandData {child: match self.payload { None => LeIsoCommandDataChild::None,Some(bytes) => LeIsoCommandDataChild::Payload(bytes),},});let command= Arc::new(CommandData {op_code: self.op_code, child: CommandDataChild::LeIsoCommand(le_iso_command),});LeIsoCommandPacket::new(command)}
}
impl Into<CommandPacket> for LeIsoCommandBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] enum VendorCommandDataChild {LeGetVendorCapabilities(Arc<LeGetVendorCapabilitiesData>),LeEnergyInfo(Arc<LeEnergyInfoData>),ControllerDebugInfo(Arc<ControllerDebugInfoData>),ControllerA2DPOpcode(Arc<ControllerA2DPOpcodeData>),ControllerBqr(Arc<ControllerBqrData>),Payload(Bytes),None,}
impl VendorCommandDataChild {fn get_total_size(&self) -> usize {match self {VendorCommandDataChild::LeGetVendorCapabilities(value) => value.get_total_size(),VendorCommandDataChild::LeEnergyInfo(value) => value.get_total_size(),VendorCommandDataChild::ControllerDebugInfo(value) => value.get_total_size(),VendorCommandDataChild::ControllerA2DPOpcode(value) => value.get_total_size(),VendorCommandDataChild::ControllerBqr(value) => value.get_total_size(),VendorCommandDataChild::Payload(p) => p.len(),VendorCommandDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum VendorCommandChild {LeGetVendorCapabilities(LeGetVendorCapabilitiesPacket),LeEnergyInfo(LeEnergyInfoPacket),ControllerDebugInfo(ControllerDebugInfoPacket),ControllerA2DPOpcode(ControllerA2DPOpcodePacket),ControllerBqr(ControllerBqrPacket),Payload(Bytes),None,}
#[derive(Debug)] struct VendorCommandData {child: VendorCommandDataChild,}
#[derive(Debug, Clone)] pub struct VendorCommandPacket {command: Arc<CommandData>,vendor_command: Arc<VendorCommandData>,}
#[derive(Debug)] pub struct VendorCommandBuilder {pub op_code: OpCode, pub payload: Option<Bytes>,}
impl VendorCommandData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8], op_code: OpCode) -> Result<Self> {let payload: Vec::<u8> = bytes[3..].into();let child = match op_code {OpCode::LeGetVendorCapabilities if LeGetVendorCapabilitiesData::conforms(&bytes[..]) => {VendorCommandDataChild::LeGetVendorCapabilities(Arc::new(LeGetVendorCapabilitiesData::parse(&bytes[..])?))}
OpCode::LeEnergyInfo if LeEnergyInfoData::conforms(&bytes[..]) => {VendorCommandDataChild::LeEnergyInfo(Arc::new(LeEnergyInfoData::parse(&bytes[..])?))}
OpCode::ControllerDebugInfo if ControllerDebugInfoData::conforms(&bytes[..]) => {VendorCommandDataChild::ControllerDebugInfo(Arc::new(ControllerDebugInfoData::parse(&bytes[..])?))}
OpCode::ControllerA2dpOpcode if ControllerA2DPOpcodeData::conforms(&bytes[..]) => {VendorCommandDataChild::ControllerA2DPOpcode(Arc::new(ControllerA2DPOpcodeData::parse(&bytes[..])?))}
OpCode::ControllerBqr if ControllerBqrData::conforms(&bytes[..]) => {VendorCommandDataChild::ControllerBqr(Arc::new(ControllerBqrData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "op_code".to_string(), value: v as u64}),};
Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {VendorCommandDataChild::LeGetVendorCapabilities(value) => value.write_to(buffer),VendorCommandDataChild::LeEnergyInfo(value) => value.write_to(buffer),VendorCommandDataChild::ControllerDebugInfo(value) => value.write_to(buffer),VendorCommandDataChild::ControllerA2DPOpcode(value) => value.write_to(buffer),VendorCommandDataChild::ControllerBqr(value) => value.write_to(buffer),VendorCommandDataChild::Payload(p) => buffer[3..].copy_from_slice(&p[..]),VendorCommandDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for VendorCommandPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl VendorCommandPacket { pub fn specialize(&self) -> VendorCommandChild { match &self.vendor_command.child {VendorCommandDataChild::LeGetVendorCapabilities(_) => VendorCommandChild::LeGetVendorCapabilities(LeGetVendorCapabilitiesPacket::new(self.command.clone())),VendorCommandDataChild::LeEnergyInfo(_) => VendorCommandChild::LeEnergyInfo(LeEnergyInfoPacket::new(self.command.clone())),VendorCommandDataChild::ControllerDebugInfo(_) => VendorCommandChild::ControllerDebugInfo(ControllerDebugInfoPacket::new(self.command.clone())),VendorCommandDataChild::ControllerA2DPOpcode(_) => VendorCommandChild::ControllerA2DPOpcode(ControllerA2DPOpcodePacket::new(self.command.clone())),VendorCommandDataChild::ControllerBqr(_) => VendorCommandChild::ControllerBqr(ControllerBqrPacket::new(self.command.clone())),VendorCommandDataChild::Payload(p) => VendorCommandChild::Payload(p.clone()),VendorCommandDataChild::None => VendorCommandChild::None,}} fn new(root: Arc<CommandData>) -> Self {let command = root;let vendor_command = match &command.child {CommandDataChild::VendorCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not VendorCommand"),};Self {command,vendor_command,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for VendorCommandPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl VendorCommandBuilder {pub fn build(self) -> VendorCommandPacket {let vendor_command= Arc::new(VendorCommandData {child: match self.payload { None => VendorCommandDataChild::None,Some(bytes) => VendorCommandDataChild::Payload(bytes),},});let command= Arc::new(CommandData {op_code: self.op_code, child: CommandDataChild::VendorCommand(vendor_command),});VendorCommandPacket::new(command)}
}
impl Into<CommandPacket> for VendorCommandBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] enum EventDataChild {CommandComplete(Arc<CommandCompleteData>),CommandStatus(Arc<CommandStatusData>),InquiryComplete(Arc<InquiryCompleteData>),InquiryResult(Arc<InquiryResultData>),ConnectionComplete(Arc<ConnectionCompleteData>),ConnectionRequest(Arc<ConnectionRequestData>),DisconnectionComplete(Arc<DisconnectionCompleteData>),AuthenticationComplete(Arc<AuthenticationCompleteData>),RemoteNameRequestComplete(Arc<RemoteNameRequestCompleteData>),EncryptionChange(Arc<EncryptionChangeData>),ChangeConnectionLinkKeyComplete(Arc<ChangeConnectionLinkKeyCompleteData>),CentralLinkKeyComplete(Arc<CentralLinkKeyCompleteData>),ReadRemoteSupportedFeaturesComplete(Arc<ReadRemoteSupportedFeaturesCompleteData>),ReadRemoteVersionInformationComplete(Arc<ReadRemoteVersionInformationCompleteData>),QosSetupComplete(Arc<QosSetupCompleteData>),HardwareError(Arc<HardwareErrorData>),FlushOccurred(Arc<FlushOccurredData>),RoleChange(Arc<RoleChangeData>),NumberOfCompletedPackets(Arc<NumberOfCompletedPacketsData>),ModeChange(Arc<ModeChangeData>),ReturnLinkKeys(Arc<ReturnLinkKeysData>),PinCodeRequest(Arc<PinCodeRequestData>),LinkKeyRequest(Arc<LinkKeyRequestData>),LinkKeyNotification(Arc<LinkKeyNotificationData>),LoopbackCommand(Arc<LoopbackCommandData>),DataBufferOverflow(Arc<DataBufferOverflowData>),MaxSlotsChange(Arc<MaxSlotsChangeData>),ReadClockOffsetComplete(Arc<ReadClockOffsetCompleteData>),ConnectionPacketTypeChanged(Arc<ConnectionPacketTypeChangedData>),QosViolation(Arc<QosViolationData>),PageScanRepetitionModeChange(Arc<PageScanRepetitionModeChangeData>),FlowSpecificationComplete(Arc<FlowSpecificationCompleteData>),InquiryResultWithRssi(Arc<InquiryResultWithRssiData>),ReadRemoteExtendedFeaturesComplete(Arc<ReadRemoteExtendedFeaturesCompleteData>),SynchronousConnectionComplete(Arc<SynchronousConnectionCompleteData>),SynchronousConnectionChanged(Arc<SynchronousConnectionChangedData>),SniffSubratingEvent(Arc<SniffSubratingEventData>),ExtendedInquiryResult(Arc<ExtendedInquiryResultData>),EncryptionKeyRefreshComplete(Arc<EncryptionKeyRefreshCompleteData>),IoCapabilityRequest(Arc<IoCapabilityRequestData>),IoCapabilityResponse(Arc<IoCapabilityResponseData>),UserConfirmationRequest(Arc<UserConfirmationRequestData>),UserPasskeyRequest(Arc<UserPasskeyRequestData>),RemoteOobDataRequest(Arc<RemoteOobDataRequestData>),SimplePairingComplete(Arc<SimplePairingCompleteData>),LinkSupervisionTimeoutChanged(Arc<LinkSupervisionTimeoutChangedData>),EnhancedFlushComplete(Arc<EnhancedFlushCompleteData>),UserPasskeyNotification(Arc<UserPasskeyNotificationData>),KeypressNotification(Arc<KeypressNotificationData>),RemoteHostSupportedFeaturesNotification(Arc<RemoteHostSupportedFeaturesNotificationData>),LeMetaEvent(Arc<LeMetaEventData>),NumberOfCompletedDataBlocks(Arc<NumberOfCompletedDataBlocksData>),VendorSpecificEvent(Arc<VendorSpecificEventData>),Payload(Bytes),None,}
impl EventDataChild {fn get_total_size(&self) -> usize {match self {EventDataChild::CommandComplete(value) => value.get_total_size(),EventDataChild::CommandStatus(value) => value.get_total_size(),EventDataChild::InquiryComplete(value) => value.get_total_size(),EventDataChild::InquiryResult(value) => value.get_total_size(),EventDataChild::ConnectionComplete(value) => value.get_total_size(),EventDataChild::ConnectionRequest(value) => value.get_total_size(),EventDataChild::DisconnectionComplete(value) => value.get_total_size(),EventDataChild::AuthenticationComplete(value) => value.get_total_size(),EventDataChild::RemoteNameRequestComplete(value) => value.get_total_size(),EventDataChild::EncryptionChange(value) => value.get_total_size(),EventDataChild::ChangeConnectionLinkKeyComplete(value) => value.get_total_size(),EventDataChild::CentralLinkKeyComplete(value) => value.get_total_size(),EventDataChild::ReadRemoteSupportedFeaturesComplete(value) => value.get_total_size(),EventDataChild::ReadRemoteVersionInformationComplete(value) => value.get_total_size(),EventDataChild::QosSetupComplete(value) => value.get_total_size(),EventDataChild::HardwareError(value) => value.get_total_size(),EventDataChild::FlushOccurred(value) => value.get_total_size(),EventDataChild::RoleChange(value) => value.get_total_size(),EventDataChild::NumberOfCompletedPackets(value) => value.get_total_size(),EventDataChild::ModeChange(value) => value.get_total_size(),EventDataChild::ReturnLinkKeys(value) => value.get_total_size(),EventDataChild::PinCodeRequest(value) => value.get_total_size(),EventDataChild::LinkKeyRequest(value) => value.get_total_size(),EventDataChild::LinkKeyNotification(value) => value.get_total_size(),EventDataChild::LoopbackCommand(value) => value.get_total_size(),EventDataChild::DataBufferOverflow(value) => value.get_total_size(),EventDataChild::MaxSlotsChange(value) => value.get_total_size(),EventDataChild::ReadClockOffsetComplete(value) => value.get_total_size(),EventDataChild::ConnectionPacketTypeChanged(value) => value.get_total_size(),EventDataChild::QosViolation(value) => value.get_total_size(),EventDataChild::PageScanRepetitionModeChange(value) => value.get_total_size(),EventDataChild::FlowSpecificationComplete(value) => value.get_total_size(),EventDataChild::InquiryResultWithRssi(value) => value.get_total_size(),EventDataChild::ReadRemoteExtendedFeaturesComplete(value) => value.get_total_size(),EventDataChild::SynchronousConnectionComplete(value) => value.get_total_size(),EventDataChild::SynchronousConnectionChanged(value) => value.get_total_size(),EventDataChild::SniffSubratingEvent(value) => value.get_total_size(),EventDataChild::ExtendedInquiryResult(value) => value.get_total_size(),EventDataChild::EncryptionKeyRefreshComplete(value) => value.get_total_size(),EventDataChild::IoCapabilityRequest(value) => value.get_total_size(),EventDataChild::IoCapabilityResponse(value) => value.get_total_size(),EventDataChild::UserConfirmationRequest(value) => value.get_total_size(),EventDataChild::UserPasskeyRequest(value) => value.get_total_size(),EventDataChild::RemoteOobDataRequest(value) => value.get_total_size(),EventDataChild::SimplePairingComplete(value) => value.get_total_size(),EventDataChild::LinkSupervisionTimeoutChanged(value) => value.get_total_size(),EventDataChild::EnhancedFlushComplete(value) => value.get_total_size(),EventDataChild::UserPasskeyNotification(value) => value.get_total_size(),EventDataChild::KeypressNotification(value) => value.get_total_size(),EventDataChild::RemoteHostSupportedFeaturesNotification(value) => value.get_total_size(),EventDataChild::LeMetaEvent(value) => value.get_total_size(),EventDataChild::NumberOfCompletedDataBlocks(value) => value.get_total_size(),EventDataChild::VendorSpecificEvent(value) => value.get_total_size(),EventDataChild::Payload(p) => p.len(),EventDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum EventChild {CommandComplete(CommandCompletePacket),CommandStatus(CommandStatusPacket),InquiryComplete(InquiryCompletePacket),InquiryResult(InquiryResultPacket),ConnectionComplete(ConnectionCompletePacket),ConnectionRequest(ConnectionRequestPacket),DisconnectionComplete(DisconnectionCompletePacket),AuthenticationComplete(AuthenticationCompletePacket),RemoteNameRequestComplete(RemoteNameRequestCompletePacket),EncryptionChange(EncryptionChangePacket),ChangeConnectionLinkKeyComplete(ChangeConnectionLinkKeyCompletePacket),CentralLinkKeyComplete(CentralLinkKeyCompletePacket),ReadRemoteSupportedFeaturesComplete(ReadRemoteSupportedFeaturesCompletePacket),ReadRemoteVersionInformationComplete(ReadRemoteVersionInformationCompletePacket),QosSetupComplete(QosSetupCompletePacket),HardwareError(HardwareErrorPacket),FlushOccurred(FlushOccurredPacket),RoleChange(RoleChangePacket),NumberOfCompletedPackets(NumberOfCompletedPacketsPacket),ModeChange(ModeChangePacket),ReturnLinkKeys(ReturnLinkKeysPacket),PinCodeRequest(PinCodeRequestPacket),LinkKeyRequest(LinkKeyRequestPacket),LinkKeyNotification(LinkKeyNotificationPacket),LoopbackCommand(LoopbackCommandPacket),DataBufferOverflow(DataBufferOverflowPacket),MaxSlotsChange(MaxSlotsChangePacket),ReadClockOffsetComplete(ReadClockOffsetCompletePacket),ConnectionPacketTypeChanged(ConnectionPacketTypeChangedPacket),QosViolation(QosViolationPacket),PageScanRepetitionModeChange(PageScanRepetitionModeChangePacket),FlowSpecificationComplete(FlowSpecificationCompletePacket),InquiryResultWithRssi(InquiryResultWithRssiPacket),ReadRemoteExtendedFeaturesComplete(ReadRemoteExtendedFeaturesCompletePacket),SynchronousConnectionComplete(SynchronousConnectionCompletePacket),SynchronousConnectionChanged(SynchronousConnectionChangedPacket),SniffSubratingEvent(SniffSubratingEventPacket),ExtendedInquiryResult(ExtendedInquiryResultPacket),EncryptionKeyRefreshComplete(EncryptionKeyRefreshCompletePacket),IoCapabilityRequest(IoCapabilityRequestPacket),IoCapabilityResponse(IoCapabilityResponsePacket),UserConfirmationRequest(UserConfirmationRequestPacket),UserPasskeyRequest(UserPasskeyRequestPacket),RemoteOobDataRequest(RemoteOobDataRequestPacket),SimplePairingComplete(SimplePairingCompletePacket),LinkSupervisionTimeoutChanged(LinkSupervisionTimeoutChangedPacket),EnhancedFlushComplete(EnhancedFlushCompletePacket),UserPasskeyNotification(UserPasskeyNotificationPacket),KeypressNotification(KeypressNotificationPacket),RemoteHostSupportedFeaturesNotification(RemoteHostSupportedFeaturesNotificationPacket),LeMetaEvent(LeMetaEventPacket),NumberOfCompletedDataBlocks(NumberOfCompletedDataBlocksPacket),VendorSpecificEvent(VendorSpecificEventPacket),Payload(Bytes),None,}
#[derive(Debug)] struct EventData {event_code: EventCode, child: EventDataChild,}
#[derive(Debug, Clone)] pub struct EventPacket {event: Arc<EventData>,}
#[derive(Debug)] pub struct EventBuilder {pub event_code: EventCode, pub payload: Option<Bytes>,}
impl EventData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 1 { return Err(Error::InvalidLengthError{    obj: "Event".to_string(),    field: "event_code".to_string(),    wanted: 1,    got: bytes.len()});}let event_code = u8::from_le_bytes([bytes[0]]);let event_code = EventCode::from_u8(event_code).unwrap();if bytes.len() < 2 { return Err(Error::InvalidLengthError{    obj: "Event".to_string(),    field: "payload_size".to_string(),    wanted: 2,    got: bytes.len()});}let payload_size = u8::from_le_bytes([bytes[1]]);let payload: Vec::<u8> = bytes[2..(2 + payload_size as usize)].into();let child = match event_code {EventCode::CommandComplete if CommandCompleteData::conforms(&bytes[..]) => {EventDataChild::CommandComplete(Arc::new(CommandCompleteData::parse(&bytes[..])?))}
EventCode::CommandStatus if CommandStatusData::conforms(&bytes[..]) => {EventDataChild::CommandStatus(Arc::new(CommandStatusData::parse(&bytes[..])?))}
EventCode::InquiryComplete if InquiryCompleteData::conforms(&bytes[..]) => {EventDataChild::InquiryComplete(Arc::new(InquiryCompleteData::parse(&bytes[..])?))}
EventCode::InquiryResult if InquiryResultData::conforms(&bytes[..]) => {EventDataChild::InquiryResult(Arc::new(InquiryResultData::parse(&bytes[..])?))}
EventCode::ConnectionComplete if ConnectionCompleteData::conforms(&bytes[..]) => {EventDataChild::ConnectionComplete(Arc::new(ConnectionCompleteData::parse(&bytes[..])?))}
EventCode::ConnectionRequest if ConnectionRequestData::conforms(&bytes[..]) => {EventDataChild::ConnectionRequest(Arc::new(ConnectionRequestData::parse(&bytes[..])?))}
EventCode::DisconnectionComplete if DisconnectionCompleteData::conforms(&bytes[..]) => {EventDataChild::DisconnectionComplete(Arc::new(DisconnectionCompleteData::parse(&bytes[..])?))}
EventCode::AuthenticationComplete if AuthenticationCompleteData::conforms(&bytes[..]) => {EventDataChild::AuthenticationComplete(Arc::new(AuthenticationCompleteData::parse(&bytes[..])?))}
EventCode::RemoteNameRequestComplete if RemoteNameRequestCompleteData::conforms(&bytes[..]) => {EventDataChild::RemoteNameRequestComplete(Arc::new(RemoteNameRequestCompleteData::parse(&bytes[..])?))}
EventCode::EncryptionChange if EncryptionChangeData::conforms(&bytes[..]) => {EventDataChild::EncryptionChange(Arc::new(EncryptionChangeData::parse(&bytes[..])?))}
EventCode::ChangeConnectionLinkKeyComplete if ChangeConnectionLinkKeyCompleteData::conforms(&bytes[..]) => {EventDataChild::ChangeConnectionLinkKeyComplete(Arc::new(ChangeConnectionLinkKeyCompleteData::parse(&bytes[..])?))}
EventCode::CentralLinkKeyComplete if CentralLinkKeyCompleteData::conforms(&bytes[..]) => {EventDataChild::CentralLinkKeyComplete(Arc::new(CentralLinkKeyCompleteData::parse(&bytes[..])?))}
EventCode::ReadRemoteSupportedFeaturesComplete if ReadRemoteSupportedFeaturesCompleteData::conforms(&bytes[..]) => {EventDataChild::ReadRemoteSupportedFeaturesComplete(Arc::new(ReadRemoteSupportedFeaturesCompleteData::parse(&bytes[..])?))}
EventCode::ReadRemoteVersionInformationComplete if ReadRemoteVersionInformationCompleteData::conforms(&bytes[..]) => {EventDataChild::ReadRemoteVersionInformationComplete(Arc::new(ReadRemoteVersionInformationCompleteData::parse(&bytes[..])?))}
EventCode::QosSetupComplete if QosSetupCompleteData::conforms(&bytes[..]) => {EventDataChild::QosSetupComplete(Arc::new(QosSetupCompleteData::parse(&bytes[..])?))}
EventCode::HardwareError if HardwareErrorData::conforms(&bytes[..]) => {EventDataChild::HardwareError(Arc::new(HardwareErrorData::parse(&bytes[..])?))}
EventCode::FlushOccurred if FlushOccurredData::conforms(&bytes[..]) => {EventDataChild::FlushOccurred(Arc::new(FlushOccurredData::parse(&bytes[..])?))}
EventCode::RoleChange if RoleChangeData::conforms(&bytes[..]) => {EventDataChild::RoleChange(Arc::new(RoleChangeData::parse(&bytes[..])?))}
EventCode::NumberOfCompletedPackets if NumberOfCompletedPacketsData::conforms(&bytes[..]) => {EventDataChild::NumberOfCompletedPackets(Arc::new(NumberOfCompletedPacketsData::parse(&bytes[..])?))}
EventCode::ModeChange if ModeChangeData::conforms(&bytes[..]) => {EventDataChild::ModeChange(Arc::new(ModeChangeData::parse(&bytes[..])?))}
EventCode::ReturnLinkKeys if ReturnLinkKeysData::conforms(&bytes[..]) => {EventDataChild::ReturnLinkKeys(Arc::new(ReturnLinkKeysData::parse(&bytes[..])?))}
EventCode::PinCodeRequest if PinCodeRequestData::conforms(&bytes[..]) => {EventDataChild::PinCodeRequest(Arc::new(PinCodeRequestData::parse(&bytes[..])?))}
EventCode::LinkKeyRequest if LinkKeyRequestData::conforms(&bytes[..]) => {EventDataChild::LinkKeyRequest(Arc::new(LinkKeyRequestData::parse(&bytes[..])?))}
EventCode::LinkKeyNotification if LinkKeyNotificationData::conforms(&bytes[..]) => {EventDataChild::LinkKeyNotification(Arc::new(LinkKeyNotificationData::parse(&bytes[..])?))}
EventCode::LoopbackCommand if LoopbackCommandData::conforms(&bytes[..]) => {EventDataChild::LoopbackCommand(Arc::new(LoopbackCommandData::parse(&bytes[..])?))}
EventCode::DataBufferOverflow if DataBufferOverflowData::conforms(&bytes[..]) => {EventDataChild::DataBufferOverflow(Arc::new(DataBufferOverflowData::parse(&bytes[..])?))}
EventCode::MaxSlotsChange if MaxSlotsChangeData::conforms(&bytes[..]) => {EventDataChild::MaxSlotsChange(Arc::new(MaxSlotsChangeData::parse(&bytes[..])?))}
EventCode::ReadClockOffsetComplete if ReadClockOffsetCompleteData::conforms(&bytes[..]) => {EventDataChild::ReadClockOffsetComplete(Arc::new(ReadClockOffsetCompleteData::parse(&bytes[..])?))}
EventCode::ConnectionPacketTypeChanged if ConnectionPacketTypeChangedData::conforms(&bytes[..]) => {EventDataChild::ConnectionPacketTypeChanged(Arc::new(ConnectionPacketTypeChangedData::parse(&bytes[..])?))}
EventCode::QosViolation if QosViolationData::conforms(&bytes[..]) => {EventDataChild::QosViolation(Arc::new(QosViolationData::parse(&bytes[..])?))}
EventCode::PageScanRepetitionModeChange if PageScanRepetitionModeChangeData::conforms(&bytes[..]) => {EventDataChild::PageScanRepetitionModeChange(Arc::new(PageScanRepetitionModeChangeData::parse(&bytes[..])?))}
EventCode::FlowSpecificationComplete if FlowSpecificationCompleteData::conforms(&bytes[..]) => {EventDataChild::FlowSpecificationComplete(Arc::new(FlowSpecificationCompleteData::parse(&bytes[..])?))}
EventCode::InquiryResultWithRssi if InquiryResultWithRssiData::conforms(&bytes[..]) => {EventDataChild::InquiryResultWithRssi(Arc::new(InquiryResultWithRssiData::parse(&bytes[..])?))}
EventCode::ReadRemoteExtendedFeaturesComplete if ReadRemoteExtendedFeaturesCompleteData::conforms(&bytes[..]) => {EventDataChild::ReadRemoteExtendedFeaturesComplete(Arc::new(ReadRemoteExtendedFeaturesCompleteData::parse(&bytes[..])?))}
EventCode::SynchronousConnectionComplete if SynchronousConnectionCompleteData::conforms(&bytes[..]) => {EventDataChild::SynchronousConnectionComplete(Arc::new(SynchronousConnectionCompleteData::parse(&bytes[..])?))}
EventCode::SynchronousConnectionChanged if SynchronousConnectionChangedData::conforms(&bytes[..]) => {EventDataChild::SynchronousConnectionChanged(Arc::new(SynchronousConnectionChangedData::parse(&bytes[..])?))}
EventCode::SniffSubrating if SniffSubratingEventData::conforms(&bytes[..]) => {EventDataChild::SniffSubratingEvent(Arc::new(SniffSubratingEventData::parse(&bytes[..])?))}
EventCode::ExtendedInquiryResult if ExtendedInquiryResultData::conforms(&bytes[..]) => {EventDataChild::ExtendedInquiryResult(Arc::new(ExtendedInquiryResultData::parse(&bytes[..])?))}
EventCode::EncryptionKeyRefreshComplete if EncryptionKeyRefreshCompleteData::conforms(&bytes[..]) => {EventDataChild::EncryptionKeyRefreshComplete(Arc::new(EncryptionKeyRefreshCompleteData::parse(&bytes[..])?))}
EventCode::IoCapabilityRequest if IoCapabilityRequestData::conforms(&bytes[..]) => {EventDataChild::IoCapabilityRequest(Arc::new(IoCapabilityRequestData::parse(&bytes[..])?))}
EventCode::IoCapabilityResponse if IoCapabilityResponseData::conforms(&bytes[..]) => {EventDataChild::IoCapabilityResponse(Arc::new(IoCapabilityResponseData::parse(&bytes[..])?))}
EventCode::UserConfirmationRequest if UserConfirmationRequestData::conforms(&bytes[..]) => {EventDataChild::UserConfirmationRequest(Arc::new(UserConfirmationRequestData::parse(&bytes[..])?))}
EventCode::UserPasskeyRequest if UserPasskeyRequestData::conforms(&bytes[..]) => {EventDataChild::UserPasskeyRequest(Arc::new(UserPasskeyRequestData::parse(&bytes[..])?))}
EventCode::RemoteOobDataRequest if RemoteOobDataRequestData::conforms(&bytes[..]) => {EventDataChild::RemoteOobDataRequest(Arc::new(RemoteOobDataRequestData::parse(&bytes[..])?))}
EventCode::SimplePairingComplete if SimplePairingCompleteData::conforms(&bytes[..]) => {EventDataChild::SimplePairingComplete(Arc::new(SimplePairingCompleteData::parse(&bytes[..])?))}
EventCode::LinkSupervisionTimeoutChanged if LinkSupervisionTimeoutChangedData::conforms(&bytes[..]) => {EventDataChild::LinkSupervisionTimeoutChanged(Arc::new(LinkSupervisionTimeoutChangedData::parse(&bytes[..])?))}
EventCode::KeypressNotification if KeypressNotificationData::conforms(&bytes[..]) => {EventDataChild::KeypressNotification(Arc::new(KeypressNotificationData::parse(&bytes[..])?))}
EventCode::RemoteHostSupportedFeaturesNotification if RemoteHostSupportedFeaturesNotificationData::conforms(&bytes[..]) => {EventDataChild::RemoteHostSupportedFeaturesNotification(Arc::new(RemoteHostSupportedFeaturesNotificationData::parse(&bytes[..])?))}
EventCode::LeMetaEvent if LeMetaEventData::conforms(&bytes[..]) => {EventDataChild::LeMetaEvent(Arc::new(LeMetaEventData::parse(&bytes[..])?))}
EventCode::NumberOfCompletedDataBlocks if NumberOfCompletedDataBlocksData::conforms(&bytes[..]) => {EventDataChild::NumberOfCompletedDataBlocks(Arc::new(NumberOfCompletedDataBlocksData::parse(&bytes[..])?))}
EventCode::EnhancedFlushComplete if EnhancedFlushCompleteData::conforms(&bytes[..]) => {EventDataChild::EnhancedFlushComplete(Arc::new(EnhancedFlushCompleteData::parse(&bytes[..])?))}
EventCode::UserPasskeyNotification if UserPasskeyNotificationData::conforms(&bytes[..]) => {EventDataChild::UserPasskeyNotification(Arc::new(UserPasskeyNotificationData::parse(&bytes[..])?))}
EventCode::VendorSpecific if VendorSpecificEventData::conforms(&bytes[..]) => {EventDataChild::VendorSpecificEvent(Arc::new(VendorSpecificEventData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "event_code".to_string(), value: v as u64}),};
Ok(Self {event_code, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let event_code = self.event_code.to_u8().unwrap();buffer[0..1].copy_from_slice(&event_code.to_le_bytes()[0..1]);let payload_size = u8::try_from(self.child.get_total_size()).expect("payload size did not fit");buffer[1..2].copy_from_slice(&payload_size.to_le_bytes()[0..1]);match &self.child {EventDataChild::CommandComplete(value) => value.write_to(buffer),EventDataChild::CommandStatus(value) => value.write_to(buffer),EventDataChild::InquiryComplete(value) => value.write_to(buffer),EventDataChild::InquiryResult(value) => value.write_to(buffer),EventDataChild::ConnectionComplete(value) => value.write_to(buffer),EventDataChild::ConnectionRequest(value) => value.write_to(buffer),EventDataChild::DisconnectionComplete(value) => value.write_to(buffer),EventDataChild::AuthenticationComplete(value) => value.write_to(buffer),EventDataChild::RemoteNameRequestComplete(value) => value.write_to(buffer),EventDataChild::EncryptionChange(value) => value.write_to(buffer),EventDataChild::ChangeConnectionLinkKeyComplete(value) => value.write_to(buffer),EventDataChild::CentralLinkKeyComplete(value) => value.write_to(buffer),EventDataChild::ReadRemoteSupportedFeaturesComplete(value) => value.write_to(buffer),EventDataChild::ReadRemoteVersionInformationComplete(value) => value.write_to(buffer),EventDataChild::QosSetupComplete(value) => value.write_to(buffer),EventDataChild::HardwareError(value) => value.write_to(buffer),EventDataChild::FlushOccurred(value) => value.write_to(buffer),EventDataChild::RoleChange(value) => value.write_to(buffer),EventDataChild::NumberOfCompletedPackets(value) => value.write_to(buffer),EventDataChild::ModeChange(value) => value.write_to(buffer),EventDataChild::ReturnLinkKeys(value) => value.write_to(buffer),EventDataChild::PinCodeRequest(value) => value.write_to(buffer),EventDataChild::LinkKeyRequest(value) => value.write_to(buffer),EventDataChild::LinkKeyNotification(value) => value.write_to(buffer),EventDataChild::LoopbackCommand(value) => value.write_to(buffer),EventDataChild::DataBufferOverflow(value) => value.write_to(buffer),EventDataChild::MaxSlotsChange(value) => value.write_to(buffer),EventDataChild::ReadClockOffsetComplete(value) => value.write_to(buffer),EventDataChild::ConnectionPacketTypeChanged(value) => value.write_to(buffer),EventDataChild::QosViolation(value) => value.write_to(buffer),EventDataChild::PageScanRepetitionModeChange(value) => value.write_to(buffer),EventDataChild::FlowSpecificationComplete(value) => value.write_to(buffer),EventDataChild::InquiryResultWithRssi(value) => value.write_to(buffer),EventDataChild::ReadRemoteExtendedFeaturesComplete(value) => value.write_to(buffer),EventDataChild::SynchronousConnectionComplete(value) => value.write_to(buffer),EventDataChild::SynchronousConnectionChanged(value) => value.write_to(buffer),EventDataChild::SniffSubratingEvent(value) => value.write_to(buffer),EventDataChild::ExtendedInquiryResult(value) => value.write_to(buffer),EventDataChild::EncryptionKeyRefreshComplete(value) => value.write_to(buffer),EventDataChild::IoCapabilityRequest(value) => value.write_to(buffer),EventDataChild::IoCapabilityResponse(value) => value.write_to(buffer),EventDataChild::UserConfirmationRequest(value) => value.write_to(buffer),EventDataChild::UserPasskeyRequest(value) => value.write_to(buffer),EventDataChild::RemoteOobDataRequest(value) => value.write_to(buffer),EventDataChild::SimplePairingComplete(value) => value.write_to(buffer),EventDataChild::LinkSupervisionTimeoutChanged(value) => value.write_to(buffer),EventDataChild::EnhancedFlushComplete(value) => value.write_to(buffer),EventDataChild::UserPasskeyNotification(value) => value.write_to(buffer),EventDataChild::KeypressNotification(value) => value.write_to(buffer),EventDataChild::RemoteHostSupportedFeaturesNotification(value) => value.write_to(buffer),EventDataChild::LeMetaEvent(value) => value.write_to(buffer),EventDataChild::NumberOfCompletedDataBlocks(value) => value.write_to(buffer),EventDataChild::VendorSpecificEvent(value) => value.write_to(buffer),EventDataChild::Payload(p) => buffer[2..].copy_from_slice(&p[..]),EventDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for EventPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl EventPacket {pub fn parse(bytes: &[u8]) -> Result<Self> { Ok(Self::new(Arc::new(EventData::parse(bytes)?)))} pub fn specialize(&self) -> EventChild { match &self.event.child {EventDataChild::CommandComplete(_) => EventChild::CommandComplete(CommandCompletePacket::new(self.event.clone())),EventDataChild::CommandStatus(_) => EventChild::CommandStatus(CommandStatusPacket::new(self.event.clone())),EventDataChild::InquiryComplete(_) => EventChild::InquiryComplete(InquiryCompletePacket::new(self.event.clone())),EventDataChild::InquiryResult(_) => EventChild::InquiryResult(InquiryResultPacket::new(self.event.clone())),EventDataChild::ConnectionComplete(_) => EventChild::ConnectionComplete(ConnectionCompletePacket::new(self.event.clone())),EventDataChild::ConnectionRequest(_) => EventChild::ConnectionRequest(ConnectionRequestPacket::new(self.event.clone())),EventDataChild::DisconnectionComplete(_) => EventChild::DisconnectionComplete(DisconnectionCompletePacket::new(self.event.clone())),EventDataChild::AuthenticationComplete(_) => EventChild::AuthenticationComplete(AuthenticationCompletePacket::new(self.event.clone())),EventDataChild::RemoteNameRequestComplete(_) => EventChild::RemoteNameRequestComplete(RemoteNameRequestCompletePacket::new(self.event.clone())),EventDataChild::EncryptionChange(_) => EventChild::EncryptionChange(EncryptionChangePacket::new(self.event.clone())),EventDataChild::ChangeConnectionLinkKeyComplete(_) => EventChild::ChangeConnectionLinkKeyComplete(ChangeConnectionLinkKeyCompletePacket::new(self.event.clone())),EventDataChild::CentralLinkKeyComplete(_) => EventChild::CentralLinkKeyComplete(CentralLinkKeyCompletePacket::new(self.event.clone())),EventDataChild::ReadRemoteSupportedFeaturesComplete(_) => EventChild::ReadRemoteSupportedFeaturesComplete(ReadRemoteSupportedFeaturesCompletePacket::new(self.event.clone())),EventDataChild::ReadRemoteVersionInformationComplete(_) => EventChild::ReadRemoteVersionInformationComplete(ReadRemoteVersionInformationCompletePacket::new(self.event.clone())),EventDataChild::QosSetupComplete(_) => EventChild::QosSetupComplete(QosSetupCompletePacket::new(self.event.clone())),EventDataChild::HardwareError(_) => EventChild::HardwareError(HardwareErrorPacket::new(self.event.clone())),EventDataChild::FlushOccurred(_) => EventChild::FlushOccurred(FlushOccurredPacket::new(self.event.clone())),EventDataChild::RoleChange(_) => EventChild::RoleChange(RoleChangePacket::new(self.event.clone())),EventDataChild::NumberOfCompletedPackets(_) => EventChild::NumberOfCompletedPackets(NumberOfCompletedPacketsPacket::new(self.event.clone())),EventDataChild::ModeChange(_) => EventChild::ModeChange(ModeChangePacket::new(self.event.clone())),EventDataChild::ReturnLinkKeys(_) => EventChild::ReturnLinkKeys(ReturnLinkKeysPacket::new(self.event.clone())),EventDataChild::PinCodeRequest(_) => EventChild::PinCodeRequest(PinCodeRequestPacket::new(self.event.clone())),EventDataChild::LinkKeyRequest(_) => EventChild::LinkKeyRequest(LinkKeyRequestPacket::new(self.event.clone())),EventDataChild::LinkKeyNotification(_) => EventChild::LinkKeyNotification(LinkKeyNotificationPacket::new(self.event.clone())),EventDataChild::LoopbackCommand(_) => EventChild::LoopbackCommand(LoopbackCommandPacket::new(self.event.clone())),EventDataChild::DataBufferOverflow(_) => EventChild::DataBufferOverflow(DataBufferOverflowPacket::new(self.event.clone())),EventDataChild::MaxSlotsChange(_) => EventChild::MaxSlotsChange(MaxSlotsChangePacket::new(self.event.clone())),EventDataChild::ReadClockOffsetComplete(_) => EventChild::ReadClockOffsetComplete(ReadClockOffsetCompletePacket::new(self.event.clone())),EventDataChild::ConnectionPacketTypeChanged(_) => EventChild::ConnectionPacketTypeChanged(ConnectionPacketTypeChangedPacket::new(self.event.clone())),EventDataChild::QosViolation(_) => EventChild::QosViolation(QosViolationPacket::new(self.event.clone())),EventDataChild::PageScanRepetitionModeChange(_) => EventChild::PageScanRepetitionModeChange(PageScanRepetitionModeChangePacket::new(self.event.clone())),EventDataChild::FlowSpecificationComplete(_) => EventChild::FlowSpecificationComplete(FlowSpecificationCompletePacket::new(self.event.clone())),EventDataChild::InquiryResultWithRssi(_) => EventChild::InquiryResultWithRssi(InquiryResultWithRssiPacket::new(self.event.clone())),EventDataChild::ReadRemoteExtendedFeaturesComplete(_) => EventChild::ReadRemoteExtendedFeaturesComplete(ReadRemoteExtendedFeaturesCompletePacket::new(self.event.clone())),EventDataChild::SynchronousConnectionComplete(_) => EventChild::SynchronousConnectionComplete(SynchronousConnectionCompletePacket::new(self.event.clone())),EventDataChild::SynchronousConnectionChanged(_) => EventChild::SynchronousConnectionChanged(SynchronousConnectionChangedPacket::new(self.event.clone())),EventDataChild::SniffSubratingEvent(_) => EventChild::SniffSubratingEvent(SniffSubratingEventPacket::new(self.event.clone())),EventDataChild::ExtendedInquiryResult(_) => EventChild::ExtendedInquiryResult(ExtendedInquiryResultPacket::new(self.event.clone())),EventDataChild::EncryptionKeyRefreshComplete(_) => EventChild::EncryptionKeyRefreshComplete(EncryptionKeyRefreshCompletePacket::new(self.event.clone())),EventDataChild::IoCapabilityRequest(_) => EventChild::IoCapabilityRequest(IoCapabilityRequestPacket::new(self.event.clone())),EventDataChild::IoCapabilityResponse(_) => EventChild::IoCapabilityResponse(IoCapabilityResponsePacket::new(self.event.clone())),EventDataChild::UserConfirmationRequest(_) => EventChild::UserConfirmationRequest(UserConfirmationRequestPacket::new(self.event.clone())),EventDataChild::UserPasskeyRequest(_) => EventChild::UserPasskeyRequest(UserPasskeyRequestPacket::new(self.event.clone())),EventDataChild::RemoteOobDataRequest(_) => EventChild::RemoteOobDataRequest(RemoteOobDataRequestPacket::new(self.event.clone())),EventDataChild::SimplePairingComplete(_) => EventChild::SimplePairingComplete(SimplePairingCompletePacket::new(self.event.clone())),EventDataChild::LinkSupervisionTimeoutChanged(_) => EventChild::LinkSupervisionTimeoutChanged(LinkSupervisionTimeoutChangedPacket::new(self.event.clone())),EventDataChild::EnhancedFlushComplete(_) => EventChild::EnhancedFlushComplete(EnhancedFlushCompletePacket::new(self.event.clone())),EventDataChild::UserPasskeyNotification(_) => EventChild::UserPasskeyNotification(UserPasskeyNotificationPacket::new(self.event.clone())),EventDataChild::KeypressNotification(_) => EventChild::KeypressNotification(KeypressNotificationPacket::new(self.event.clone())),EventDataChild::RemoteHostSupportedFeaturesNotification(_) => EventChild::RemoteHostSupportedFeaturesNotification(RemoteHostSupportedFeaturesNotificationPacket::new(self.event.clone())),EventDataChild::LeMetaEvent(_) => EventChild::LeMetaEvent(LeMetaEventPacket::new(self.event.clone())),EventDataChild::NumberOfCompletedDataBlocks(_) => EventChild::NumberOfCompletedDataBlocks(NumberOfCompletedDataBlocksPacket::new(self.event.clone())),EventDataChild::VendorSpecificEvent(_) => EventChild::VendorSpecificEvent(VendorSpecificEventPacket::new(self.event.clone())),EventDataChild::Payload(p) => EventChild::Payload(p.clone()),EventDataChild::None => EventChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;Self {event,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
}
impl EventBuilder {pub fn build(self) -> EventPacket {let event= Arc::new(EventData {event_code: self.event_code, child: match self.payload { None => EventDataChild::None,Some(bytes) => EventDataChild::Payload(bytes),},});EventPacket::new(event)}
}


#[derive(Debug)] enum CommandCompleteDataChild {NoCommandComplete(Arc<NoCommandCompleteData>),InquiryCancelComplete(Arc<InquiryCancelCompleteData>),PeriodicInquiryModeComplete(Arc<PeriodicInquiryModeCompleteData>),ExitPeriodicInquiryModeComplete(Arc<ExitPeriodicInquiryModeCompleteData>),CreateConnectionCancelComplete(Arc<CreateConnectionCancelCompleteData>),LinkKeyRequestReplyComplete(Arc<LinkKeyRequestReplyCompleteData>),LinkKeyRequestNegativeReplyComplete(Arc<LinkKeyRequestNegativeReplyCompleteData>),PinCodeRequestReplyComplete(Arc<PinCodeRequestReplyCompleteData>),PinCodeRequestNegativeReplyComplete(Arc<PinCodeRequestNegativeReplyCompleteData>),RemoteNameRequestCancelComplete(Arc<RemoteNameRequestCancelCompleteData>),ReadLmpHandleComplete(Arc<ReadLmpHandleCompleteData>),IoCapabilityRequestReplyComplete(Arc<IoCapabilityRequestReplyCompleteData>),UserConfirmationRequestReplyComplete(Arc<UserConfirmationRequestReplyCompleteData>),UserConfirmationRequestNegativeReplyComplete(Arc<UserConfirmationRequestNegativeReplyCompleteData>),UserPasskeyRequestReplyComplete(Arc<UserPasskeyRequestReplyCompleteData>),UserPasskeyRequestNegativeReplyComplete(Arc<UserPasskeyRequestNegativeReplyCompleteData>),RemoteOobDataRequestReplyComplete(Arc<RemoteOobDataRequestReplyCompleteData>),RemoteOobDataRequestNegativeReplyComplete(Arc<RemoteOobDataRequestNegativeReplyCompleteData>),IoCapabilityRequestNegativeReplyComplete(Arc<IoCapabilityRequestNegativeReplyCompleteData>),RemoteOobExtendedDataRequestReplyComplete(Arc<RemoteOobExtendedDataRequestReplyCompleteData>),RoleDiscoveryComplete(Arc<RoleDiscoveryCompleteData>),ReadLinkPolicySettingsComplete(Arc<ReadLinkPolicySettingsCompleteData>),WriteLinkPolicySettingsComplete(Arc<WriteLinkPolicySettingsCompleteData>),ReadDefaultLinkPolicySettingsComplete(Arc<ReadDefaultLinkPolicySettingsCompleteData>),WriteDefaultLinkPolicySettingsComplete(Arc<WriteDefaultLinkPolicySettingsCompleteData>),SniffSubratingComplete(Arc<SniffSubratingCompleteData>),SetEventMaskComplete(Arc<SetEventMaskCompleteData>),ResetComplete(Arc<ResetCompleteData>),SetEventFilterComplete(Arc<SetEventFilterCompleteData>),FlushComplete(Arc<FlushCompleteData>),ReadPinTypeComplete(Arc<ReadPinTypeCompleteData>),WritePinTypeComplete(Arc<WritePinTypeCompleteData>),ReadStoredLinkKeyComplete(Arc<ReadStoredLinkKeyCompleteData>),WriteStoredLinkKeyComplete(Arc<WriteStoredLinkKeyCompleteData>),DeleteStoredLinkKeyComplete(Arc<DeleteStoredLinkKeyCompleteData>),WriteLocalNameComplete(Arc<WriteLocalNameCompleteData>),ReadLocalNameComplete(Arc<ReadLocalNameCompleteData>),ReadConnectionAcceptTimeoutComplete(Arc<ReadConnectionAcceptTimeoutCompleteData>),WriteConnectionAcceptTimeoutComplete(Arc<WriteConnectionAcceptTimeoutCompleteData>),ReadPageTimeoutComplete(Arc<ReadPageTimeoutCompleteData>),WritePageTimeoutComplete(Arc<WritePageTimeoutCompleteData>),ReadScanEnableComplete(Arc<ReadScanEnableCompleteData>),WriteScanEnableComplete(Arc<WriteScanEnableCompleteData>),ReadPageScanActivityComplete(Arc<ReadPageScanActivityCompleteData>),WritePageScanActivityComplete(Arc<WritePageScanActivityCompleteData>),ReadInquiryScanActivityComplete(Arc<ReadInquiryScanActivityCompleteData>),WriteInquiryScanActivityComplete(Arc<WriteInquiryScanActivityCompleteData>),ReadAuthenticationEnableComplete(Arc<ReadAuthenticationEnableCompleteData>),WriteAuthenticationEnableComplete(Arc<WriteAuthenticationEnableCompleteData>),ReadClassOfDeviceComplete(Arc<ReadClassOfDeviceCompleteData>),WriteClassOfDeviceComplete(Arc<WriteClassOfDeviceCompleteData>),ReadVoiceSettingComplete(Arc<ReadVoiceSettingCompleteData>),WriteVoiceSettingComplete(Arc<WriteVoiceSettingCompleteData>),ReadAutomaticFlushTimeoutComplete(Arc<ReadAutomaticFlushTimeoutCompleteData>),WriteAutomaticFlushTimeoutComplete(Arc<WriteAutomaticFlushTimeoutCompleteData>),ReadNumBroadcastRetransmitsComplete(Arc<ReadNumBroadcastRetransmitsCompleteData>),WriteNumBroadcastRetransmitsComplete(Arc<WriteNumBroadcastRetransmitsCompleteData>),ReadHoldModeActivityComplete(Arc<ReadHoldModeActivityCompleteData>),WriteHoldModeActivityComplete(Arc<WriteHoldModeActivityCompleteData>),ReadTransmitPowerLevelComplete(Arc<ReadTransmitPowerLevelCompleteData>),ReadSynchronousFlowControlEnableComplete(Arc<ReadSynchronousFlowControlEnableCompleteData>),WriteSynchronousFlowControlEnableComplete(Arc<WriteSynchronousFlowControlEnableCompleteData>),SetControllerToHostFlowControlComplete(Arc<SetControllerToHostFlowControlCompleteData>),HostBufferSizeComplete(Arc<HostBufferSizeCompleteData>),HostNumCompletedPacketsError(Arc<HostNumCompletedPacketsErrorData>),ReadLinkSupervisionTimeoutComplete(Arc<ReadLinkSupervisionTimeoutCompleteData>),WriteLinkSupervisionTimeoutComplete(Arc<WriteLinkSupervisionTimeoutCompleteData>),ReadNumberOfSupportedIacComplete(Arc<ReadNumberOfSupportedIacCompleteData>),ReadCurrentIacLapComplete(Arc<ReadCurrentIacLapCompleteData>),WriteCurrentIacLapComplete(Arc<WriteCurrentIacLapCompleteData>),SetAfhHostChannelClassificationComplete(Arc<SetAfhHostChannelClassificationCompleteData>),ReadInquiryScanTypeComplete(Arc<ReadInquiryScanTypeCompleteData>),WriteInquiryScanTypeComplete(Arc<WriteInquiryScanTypeCompleteData>),ReadInquiryModeComplete(Arc<ReadInquiryModeCompleteData>),WriteInquiryModeComplete(Arc<WriteInquiryModeCompleteData>),ReadPageScanTypeComplete(Arc<ReadPageScanTypeCompleteData>),WritePageScanTypeComplete(Arc<WritePageScanTypeCompleteData>),ReadAfhChannelAssessmentModeComplete(Arc<ReadAfhChannelAssessmentModeCompleteData>),WriteAfhChannelAssessmentModeComplete(Arc<WriteAfhChannelAssessmentModeCompleteData>),ReadExtendedInquiryResponseComplete(Arc<ReadExtendedInquiryResponseCompleteData>),WriteExtendedInquiryResponseComplete(Arc<WriteExtendedInquiryResponseCompleteData>),ReadSimplePairingModeComplete(Arc<ReadSimplePairingModeCompleteData>),WriteSimplePairingModeComplete(Arc<WriteSimplePairingModeCompleteData>),ReadLocalOobDataComplete(Arc<ReadLocalOobDataCompleteData>),ReadInquiryResponseTransmitPowerLevelComplete(Arc<ReadInquiryResponseTransmitPowerLevelCompleteData>),WriteInquiryResponseTransmitPowerLevelComplete(Arc<WriteInquiryResponseTransmitPowerLevelCompleteData>),SendKeypressNotificationComplete(Arc<SendKeypressNotificationCompleteData>),ReadLeHostSupportComplete(Arc<ReadLeHostSupportCompleteData>),WriteLeHostSupportComplete(Arc<WriteLeHostSupportCompleteData>),ReadSecureConnectionsHostSupportComplete(Arc<ReadSecureConnectionsHostSupportCompleteData>),WriteSecureConnectionsHostSupportComplete(Arc<WriteSecureConnectionsHostSupportCompleteData>),ReadLocalOobExtendedDataComplete(Arc<ReadLocalOobExtendedDataCompleteData>),SetEcosystemBaseIntervalComplete(Arc<SetEcosystemBaseIntervalCompleteData>),ConfigureDataPathComplete(Arc<ConfigureDataPathCompleteData>),ReadLocalVersionInformationComplete(Arc<ReadLocalVersionInformationCompleteData>),ReadLocalSupportedCommandsComplete(Arc<ReadLocalSupportedCommandsCompleteData>),ReadLocalSupportedFeaturesComplete(Arc<ReadLocalSupportedFeaturesCompleteData>),ReadLocalExtendedFeaturesComplete(Arc<ReadLocalExtendedFeaturesCompleteData>),ReadBufferSizeComplete(Arc<ReadBufferSizeCompleteData>),ReadBdAddrComplete(Arc<ReadBdAddrCompleteData>),ReadDataBlockSizeComplete(Arc<ReadDataBlockSizeCompleteData>),ReadLocalSupportedCodecsV1Complete(Arc<ReadLocalSupportedCodecsV1CompleteData>),ReadLocalSupportedCodecsV2Complete(Arc<ReadLocalSupportedCodecsV2CompleteData>),ReadLocalSupportedCodecCapabilitiesComplete(Arc<ReadLocalSupportedCodecCapabilitiesCompleteData>),ReadLocalSupportedControllerDelayComplete(Arc<ReadLocalSupportedControllerDelayCompleteData>),ReadFailedContactCounterComplete(Arc<ReadFailedContactCounterCompleteData>),ResetFailedContactCounterComplete(Arc<ResetFailedContactCounterCompleteData>),ReadLinkQualityComplete(Arc<ReadLinkQualityCompleteData>),ReadRssiComplete(Arc<ReadRssiCompleteData>),ReadAfhChannelMapComplete(Arc<ReadAfhChannelMapCompleteData>),ReadClockComplete(Arc<ReadClockCompleteData>),ReadEncryptionKeySizeComplete(Arc<ReadEncryptionKeySizeCompleteData>),ReadLoopbackModeComplete(Arc<ReadLoopbackModeCompleteData>),WriteLoopbackModeComplete(Arc<WriteLoopbackModeCompleteData>),EnableDeviceUnderTestModeComplete(Arc<EnableDeviceUnderTestModeCompleteData>),WriteSimplePairingDebugModeComplete(Arc<WriteSimplePairingDebugModeCompleteData>),WriteSecureConnectionsTestModeComplete(Arc<WriteSecureConnectionsTestModeCompleteData>),LeSetEventMaskComplete(Arc<LeSetEventMaskCompleteData>),LeReadBufferSizeV1Complete(Arc<LeReadBufferSizeV1CompleteData>),LeReadLocalSupportedFeaturesComplete(Arc<LeReadLocalSupportedFeaturesCompleteData>),LeSetRandomAddressComplete(Arc<LeSetRandomAddressCompleteData>),LeSetAdvertisingParametersComplete(Arc<LeSetAdvertisingParametersCompleteData>),LeReadAdvertisingPhysicalChannelTxPowerComplete(Arc<LeReadAdvertisingPhysicalChannelTxPowerCompleteData>),LeSetAdvertisingDataComplete(Arc<LeSetAdvertisingDataCompleteData>),LeSetScanResponseDataComplete(Arc<LeSetScanResponseDataCompleteData>),LeSetAdvertisingEnableComplete(Arc<LeSetAdvertisingEnableCompleteData>),LeSetScanParametersComplete(Arc<LeSetScanParametersCompleteData>),LeSetScanEnableComplete(Arc<LeSetScanEnableCompleteData>),LeCreateConnectionCancelComplete(Arc<LeCreateConnectionCancelCompleteData>),LeReadConnectListSizeComplete(Arc<LeReadConnectListSizeCompleteData>),LeClearConnectListComplete(Arc<LeClearConnectListCompleteData>),LeAddDeviceToConnectListComplete(Arc<LeAddDeviceToConnectListCompleteData>),LeRemoveDeviceFromConnectListComplete(Arc<LeRemoveDeviceFromConnectListCompleteData>),LeSetHostChannelClassificationComplete(Arc<LeSetHostChannelClassificationCompleteData>),LeReadChannelMapComplete(Arc<LeReadChannelMapCompleteData>),LeEncryptComplete(Arc<LeEncryptCompleteData>),LeRandComplete(Arc<LeRandCompleteData>),LeLongTermKeyRequestReplyComplete(Arc<LeLongTermKeyRequestReplyCompleteData>),LeLongTermKeyRequestNegativeReplyComplete(Arc<LeLongTermKeyRequestNegativeReplyCompleteData>),LeReadSupportedStatesComplete(Arc<LeReadSupportedStatesCompleteData>),LeReceiverTestComplete(Arc<LeReceiverTestCompleteData>),LeTransmitterTestComplete(Arc<LeTransmitterTestCompleteData>),LeTestEndComplete(Arc<LeTestEndCompleteData>),LeRemoteConnectionParameterRequestReplyComplete(Arc<LeRemoteConnectionParameterRequestReplyCompleteData>),LeRemoteConnectionParameterRequestNegativeReplyComplete(Arc<LeRemoteConnectionParameterRequestNegativeReplyCompleteData>),LeSetDataLengthComplete(Arc<LeSetDataLengthCompleteData>),LeReadSuggestedDefaultDataLengthComplete(Arc<LeReadSuggestedDefaultDataLengthCompleteData>),LeWriteSuggestedDefaultDataLengthComplete(Arc<LeWriteSuggestedDefaultDataLengthCompleteData>),LeAddDeviceToResolvingListComplete(Arc<LeAddDeviceToResolvingListCompleteData>),LeRemoveDeviceFromResolvingListComplete(Arc<LeRemoveDeviceFromResolvingListCompleteData>),LeClearResolvingListComplete(Arc<LeClearResolvingListCompleteData>),LeReadResolvingListSizeComplete(Arc<LeReadResolvingListSizeCompleteData>),LeReadPeerResolvableAddressComplete(Arc<LeReadPeerResolvableAddressCompleteData>),LeReadLocalResolvableAddressComplete(Arc<LeReadLocalResolvableAddressCompleteData>),LeSetAddressResolutionEnableComplete(Arc<LeSetAddressResolutionEnableCompleteData>),LeSetResolvablePrivateAddressTimeoutComplete(Arc<LeSetResolvablePrivateAddressTimeoutCompleteData>),LeReadMaximumDataLengthComplete(Arc<LeReadMaximumDataLengthCompleteData>),LeReadPhyComplete(Arc<LeReadPhyCompleteData>),LeSetDefaultPhyComplete(Arc<LeSetDefaultPhyCompleteData>),LeEnhancedReceiverTestComplete(Arc<LeEnhancedReceiverTestCompleteData>),LeEnhancedTransmitterTestComplete(Arc<LeEnhancedTransmitterTestCompleteData>),LeSetExtendedAdvertisingRandomAddressComplete(Arc<LeSetExtendedAdvertisingRandomAddressCompleteData>),LeSetExtendedAdvertisingParametersComplete(Arc<LeSetExtendedAdvertisingParametersCompleteData>),LeSetExtendedAdvertisingDataComplete(Arc<LeSetExtendedAdvertisingDataCompleteData>),LeSetExtendedAdvertisingScanResponseComplete(Arc<LeSetExtendedAdvertisingScanResponseCompleteData>),LeSetExtendedAdvertisingEnableComplete(Arc<LeSetExtendedAdvertisingEnableCompleteData>),LeReadMaximumAdvertisingDataLengthComplete(Arc<LeReadMaximumAdvertisingDataLengthCompleteData>),LeReadNumberOfSupportedAdvertisingSetsComplete(Arc<LeReadNumberOfSupportedAdvertisingSetsCompleteData>),LeRemoveAdvertisingSetComplete(Arc<LeRemoveAdvertisingSetCompleteData>),LeClearAdvertisingSetsComplete(Arc<LeClearAdvertisingSetsCompleteData>),LeSetPeriodicAdvertisingParamComplete(Arc<LeSetPeriodicAdvertisingParamCompleteData>),LeSetPeriodicAdvertisingDataComplete(Arc<LeSetPeriodicAdvertisingDataCompleteData>),LeSetPeriodicAdvertisingEnableComplete(Arc<LeSetPeriodicAdvertisingEnableCompleteData>),LeSetExtendedScanParametersComplete(Arc<LeSetExtendedScanParametersCompleteData>),LeSetExtendedScanEnableComplete(Arc<LeSetExtendedScanEnableCompleteData>),LePeriodicAdvertisingCreateSyncCancelComplete(Arc<LePeriodicAdvertisingCreateSyncCancelCompleteData>),LePeriodicAdvertisingTerminateSyncComplete(Arc<LePeriodicAdvertisingTerminateSyncCompleteData>),LeAddDeviceToPeriodicAdvertisingListComplete(Arc<LeAddDeviceToPeriodicAdvertisingListCompleteData>),LeRemoveDeviceFromPeriodicAdvertisingListComplete(Arc<LeRemoveDeviceFromPeriodicAdvertisingListCompleteData>),LeClearPeriodicAdvertisingListComplete(Arc<LeClearPeriodicAdvertisingListCompleteData>),LeReadPeriodicAdvertiserListSizeComplete(Arc<LeReadPeriodicAdvertiserListSizeCompleteData>),LeReadTransmitPowerComplete(Arc<LeReadTransmitPowerCompleteData>),LeReadRfPathCompensationPowerComplete(Arc<LeReadRfPathCompensationPowerCompleteData>),LeWriteRfPathCompensationPowerComplete(Arc<LeWriteRfPathCompensationPowerCompleteData>),LeSetPrivacyModeComplete(Arc<LeSetPrivacyModeCompleteData>),LeSetPeriodicAdvertisingReceiveEnableComplete(Arc<LeSetPeriodicAdvertisingReceiveEnableCompleteData>),LePeriodicAdvertisingSyncTransferComplete(Arc<LePeriodicAdvertisingSyncTransferCompleteData>),LePeriodicAdvertisingSetInfoTransferComplete(Arc<LePeriodicAdvertisingSetInfoTransferCompleteData>),LeSetPeriodicAdvertisingSyncTransferParametersComplete(Arc<LeSetPeriodicAdvertisingSyncTransferParametersCompleteData>),LeSetDefaultPeriodicAdvertisingSyncTransferParametersComplete(Arc<LeSetDefaultPeriodicAdvertisingSyncTransferParametersCompleteData>),LeModifySleepClockAccuracyComplete(Arc<LeModifySleepClockAccuracyCompleteData>),LeReadBufferSizeV2Complete(Arc<LeReadBufferSizeV2CompleteData>),LeReadIsoTxSyncComplete(Arc<LeReadIsoTxSyncCompleteData>),LeSetCigParametersComplete(Arc<LeSetCigParametersCompleteData>),LeSetCigParametersTestComplete(Arc<LeSetCigParametersTestCompleteData>),LeRemoveCigComplete(Arc<LeRemoveCigCompleteData>),LeRejectCisRequestComplete(Arc<LeRejectCisRequestCompleteData>),LeBigTerminateSyncComplete(Arc<LeBigTerminateSyncCompleteData>),LeSetupIsoDataPathComplete(Arc<LeSetupIsoDataPathCompleteData>),LeRemoveIsoDataPathComplete(Arc<LeRemoveIsoDataPathCompleteData>),LeSetHostFeatureComplete(Arc<LeSetHostFeatureCompleteData>),LeReadIsoLinkQualityComplete(Arc<LeReadIsoLinkQualityCompleteData>),LeEnhancedReadTransmitPowerLevelComplete(Arc<LeEnhancedReadTransmitPowerLevelCompleteData>),LeSetPathLossReportingParametersComplete(Arc<LeSetPathLossReportingParametersCompleteData>),LeSetPathLossReportingEnableComplete(Arc<LeSetPathLossReportingEnableCompleteData>),LeSetTransmitPowerReportingEnableComplete(Arc<LeSetTransmitPowerReportingEnableCompleteData>),LeGetVendorCapabilitiesComplete(Arc<LeGetVendorCapabilitiesCompleteData>),LeMultiAdvtComplete(Arc<LeMultiAdvtCompleteData>),LeBatchScanComplete(Arc<LeBatchScanCompleteData>),LeAdvFilterComplete(Arc<LeAdvFilterCompleteData>),LeEnergyInfoComplete(Arc<LeEnergyInfoCompleteData>),LeExtendedScanParamsComplete(Arc<LeExtendedScanParamsCompleteData>),ControllerDebugInfoComplete(Arc<ControllerDebugInfoCompleteData>),ControllerA2DPOpcodeComplete(Arc<ControllerA2DPOpcodeCompleteData>),ControllerBqrComplete(Arc<ControllerBqrCompleteData>),Payload(Bytes),None,}
impl CommandCompleteDataChild {fn get_total_size(&self) -> usize {match self {CommandCompleteDataChild::NoCommandComplete(value) => value.get_total_size(),CommandCompleteDataChild::InquiryCancelComplete(value) => value.get_total_size(),CommandCompleteDataChild::PeriodicInquiryModeComplete(value) => value.get_total_size(),CommandCompleteDataChild::ExitPeriodicInquiryModeComplete(value) => value.get_total_size(),CommandCompleteDataChild::CreateConnectionCancelComplete(value) => value.get_total_size(),CommandCompleteDataChild::LinkKeyRequestReplyComplete(value) => value.get_total_size(),CommandCompleteDataChild::LinkKeyRequestNegativeReplyComplete(value) => value.get_total_size(),CommandCompleteDataChild::PinCodeRequestReplyComplete(value) => value.get_total_size(),CommandCompleteDataChild::PinCodeRequestNegativeReplyComplete(value) => value.get_total_size(),CommandCompleteDataChild::RemoteNameRequestCancelComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadLmpHandleComplete(value) => value.get_total_size(),CommandCompleteDataChild::IoCapabilityRequestReplyComplete(value) => value.get_total_size(),CommandCompleteDataChild::UserConfirmationRequestReplyComplete(value) => value.get_total_size(),CommandCompleteDataChild::UserConfirmationRequestNegativeReplyComplete(value) => value.get_total_size(),CommandCompleteDataChild::UserPasskeyRequestReplyComplete(value) => value.get_total_size(),CommandCompleteDataChild::UserPasskeyRequestNegativeReplyComplete(value) => value.get_total_size(),CommandCompleteDataChild::RemoteOobDataRequestReplyComplete(value) => value.get_total_size(),CommandCompleteDataChild::RemoteOobDataRequestNegativeReplyComplete(value) => value.get_total_size(),CommandCompleteDataChild::IoCapabilityRequestNegativeReplyComplete(value) => value.get_total_size(),CommandCompleteDataChild::RemoteOobExtendedDataRequestReplyComplete(value) => value.get_total_size(),CommandCompleteDataChild::RoleDiscoveryComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadLinkPolicySettingsComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteLinkPolicySettingsComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadDefaultLinkPolicySettingsComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteDefaultLinkPolicySettingsComplete(value) => value.get_total_size(),CommandCompleteDataChild::SniffSubratingComplete(value) => value.get_total_size(),CommandCompleteDataChild::SetEventMaskComplete(value) => value.get_total_size(),CommandCompleteDataChild::ResetComplete(value) => value.get_total_size(),CommandCompleteDataChild::SetEventFilterComplete(value) => value.get_total_size(),CommandCompleteDataChild::FlushComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadPinTypeComplete(value) => value.get_total_size(),CommandCompleteDataChild::WritePinTypeComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadStoredLinkKeyComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteStoredLinkKeyComplete(value) => value.get_total_size(),CommandCompleteDataChild::DeleteStoredLinkKeyComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteLocalNameComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadLocalNameComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadConnectionAcceptTimeoutComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteConnectionAcceptTimeoutComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadPageTimeoutComplete(value) => value.get_total_size(),CommandCompleteDataChild::WritePageTimeoutComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadScanEnableComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteScanEnableComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadPageScanActivityComplete(value) => value.get_total_size(),CommandCompleteDataChild::WritePageScanActivityComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadInquiryScanActivityComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteInquiryScanActivityComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadAuthenticationEnableComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteAuthenticationEnableComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadClassOfDeviceComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteClassOfDeviceComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadVoiceSettingComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteVoiceSettingComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadAutomaticFlushTimeoutComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteAutomaticFlushTimeoutComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadNumBroadcastRetransmitsComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteNumBroadcastRetransmitsComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadHoldModeActivityComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteHoldModeActivityComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadTransmitPowerLevelComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadSynchronousFlowControlEnableComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteSynchronousFlowControlEnableComplete(value) => value.get_total_size(),CommandCompleteDataChild::SetControllerToHostFlowControlComplete(value) => value.get_total_size(),CommandCompleteDataChild::HostBufferSizeComplete(value) => value.get_total_size(),CommandCompleteDataChild::HostNumCompletedPacketsError(value) => value.get_total_size(),CommandCompleteDataChild::ReadLinkSupervisionTimeoutComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteLinkSupervisionTimeoutComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadNumberOfSupportedIacComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadCurrentIacLapComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteCurrentIacLapComplete(value) => value.get_total_size(),CommandCompleteDataChild::SetAfhHostChannelClassificationComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadInquiryScanTypeComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteInquiryScanTypeComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadInquiryModeComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteInquiryModeComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadPageScanTypeComplete(value) => value.get_total_size(),CommandCompleteDataChild::WritePageScanTypeComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadAfhChannelAssessmentModeComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteAfhChannelAssessmentModeComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadExtendedInquiryResponseComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteExtendedInquiryResponseComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadSimplePairingModeComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteSimplePairingModeComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadLocalOobDataComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadInquiryResponseTransmitPowerLevelComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteInquiryResponseTransmitPowerLevelComplete(value) => value.get_total_size(),CommandCompleteDataChild::SendKeypressNotificationComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadLeHostSupportComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteLeHostSupportComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadSecureConnectionsHostSupportComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteSecureConnectionsHostSupportComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadLocalOobExtendedDataComplete(value) => value.get_total_size(),CommandCompleteDataChild::SetEcosystemBaseIntervalComplete(value) => value.get_total_size(),CommandCompleteDataChild::ConfigureDataPathComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadLocalVersionInformationComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadLocalSupportedCommandsComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadLocalSupportedFeaturesComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadLocalExtendedFeaturesComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadBufferSizeComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadBdAddrComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadDataBlockSizeComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadLocalSupportedCodecsV1Complete(value) => value.get_total_size(),CommandCompleteDataChild::ReadLocalSupportedCodecsV2Complete(value) => value.get_total_size(),CommandCompleteDataChild::ReadLocalSupportedCodecCapabilitiesComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadLocalSupportedControllerDelayComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadFailedContactCounterComplete(value) => value.get_total_size(),CommandCompleteDataChild::ResetFailedContactCounterComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadLinkQualityComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadRssiComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadAfhChannelMapComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadClockComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadEncryptionKeySizeComplete(value) => value.get_total_size(),CommandCompleteDataChild::ReadLoopbackModeComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteLoopbackModeComplete(value) => value.get_total_size(),CommandCompleteDataChild::EnableDeviceUnderTestModeComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteSimplePairingDebugModeComplete(value) => value.get_total_size(),CommandCompleteDataChild::WriteSecureConnectionsTestModeComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetEventMaskComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeReadBufferSizeV1Complete(value) => value.get_total_size(),CommandCompleteDataChild::LeReadLocalSupportedFeaturesComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetRandomAddressComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetAdvertisingParametersComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeReadAdvertisingPhysicalChannelTxPowerComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetAdvertisingDataComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetScanResponseDataComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetAdvertisingEnableComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetScanParametersComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetScanEnableComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeCreateConnectionCancelComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeReadConnectListSizeComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeClearConnectListComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeAddDeviceToConnectListComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeRemoveDeviceFromConnectListComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetHostChannelClassificationComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeReadChannelMapComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeEncryptComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeRandComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeLongTermKeyRequestReplyComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeLongTermKeyRequestNegativeReplyComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeReadSupportedStatesComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeReceiverTestComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeTransmitterTestComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeTestEndComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeRemoteConnectionParameterRequestReplyComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeRemoteConnectionParameterRequestNegativeReplyComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetDataLengthComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeReadSuggestedDefaultDataLengthComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeWriteSuggestedDefaultDataLengthComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeAddDeviceToResolvingListComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeRemoveDeviceFromResolvingListComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeClearResolvingListComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeReadResolvingListSizeComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeReadPeerResolvableAddressComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeReadLocalResolvableAddressComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetAddressResolutionEnableComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetResolvablePrivateAddressTimeoutComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeReadMaximumDataLengthComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeReadPhyComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetDefaultPhyComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeEnhancedReceiverTestComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeEnhancedTransmitterTestComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetExtendedAdvertisingRandomAddressComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetExtendedAdvertisingParametersComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetExtendedAdvertisingDataComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetExtendedAdvertisingScanResponseComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetExtendedAdvertisingEnableComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeReadMaximumAdvertisingDataLengthComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeReadNumberOfSupportedAdvertisingSetsComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeRemoveAdvertisingSetComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeClearAdvertisingSetsComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetPeriodicAdvertisingParamComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetPeriodicAdvertisingDataComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetPeriodicAdvertisingEnableComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetExtendedScanParametersComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetExtendedScanEnableComplete(value) => value.get_total_size(),CommandCompleteDataChild::LePeriodicAdvertisingCreateSyncCancelComplete(value) => value.get_total_size(),CommandCompleteDataChild::LePeriodicAdvertisingTerminateSyncComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeAddDeviceToPeriodicAdvertisingListComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeRemoveDeviceFromPeriodicAdvertisingListComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeClearPeriodicAdvertisingListComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeReadPeriodicAdvertiserListSizeComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeReadTransmitPowerComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeReadRfPathCompensationPowerComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeWriteRfPathCompensationPowerComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetPrivacyModeComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetPeriodicAdvertisingReceiveEnableComplete(value) => value.get_total_size(),CommandCompleteDataChild::LePeriodicAdvertisingSyncTransferComplete(value) => value.get_total_size(),CommandCompleteDataChild::LePeriodicAdvertisingSetInfoTransferComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetPeriodicAdvertisingSyncTransferParametersComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetDefaultPeriodicAdvertisingSyncTransferParametersComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeModifySleepClockAccuracyComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeReadBufferSizeV2Complete(value) => value.get_total_size(),CommandCompleteDataChild::LeReadIsoTxSyncComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetCigParametersComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetCigParametersTestComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeRemoveCigComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeRejectCisRequestComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeBigTerminateSyncComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetupIsoDataPathComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeRemoveIsoDataPathComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetHostFeatureComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeReadIsoLinkQualityComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeEnhancedReadTransmitPowerLevelComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetPathLossReportingParametersComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetPathLossReportingEnableComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeSetTransmitPowerReportingEnableComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeGetVendorCapabilitiesComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeMultiAdvtComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeBatchScanComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeAdvFilterComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeEnergyInfoComplete(value) => value.get_total_size(),CommandCompleteDataChild::LeExtendedScanParamsComplete(value) => value.get_total_size(),CommandCompleteDataChild::ControllerDebugInfoComplete(value) => value.get_total_size(),CommandCompleteDataChild::ControllerA2DPOpcodeComplete(value) => value.get_total_size(),CommandCompleteDataChild::ControllerBqrComplete(value) => value.get_total_size(),CommandCompleteDataChild::Payload(p) => p.len(),CommandCompleteDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum CommandCompleteChild {NoCommandComplete(NoCommandCompletePacket),InquiryCancelComplete(InquiryCancelCompletePacket),PeriodicInquiryModeComplete(PeriodicInquiryModeCompletePacket),ExitPeriodicInquiryModeComplete(ExitPeriodicInquiryModeCompletePacket),CreateConnectionCancelComplete(CreateConnectionCancelCompletePacket),LinkKeyRequestReplyComplete(LinkKeyRequestReplyCompletePacket),LinkKeyRequestNegativeReplyComplete(LinkKeyRequestNegativeReplyCompletePacket),PinCodeRequestReplyComplete(PinCodeRequestReplyCompletePacket),PinCodeRequestNegativeReplyComplete(PinCodeRequestNegativeReplyCompletePacket),RemoteNameRequestCancelComplete(RemoteNameRequestCancelCompletePacket),ReadLmpHandleComplete(ReadLmpHandleCompletePacket),IoCapabilityRequestReplyComplete(IoCapabilityRequestReplyCompletePacket),UserConfirmationRequestReplyComplete(UserConfirmationRequestReplyCompletePacket),UserConfirmationRequestNegativeReplyComplete(UserConfirmationRequestNegativeReplyCompletePacket),UserPasskeyRequestReplyComplete(UserPasskeyRequestReplyCompletePacket),UserPasskeyRequestNegativeReplyComplete(UserPasskeyRequestNegativeReplyCompletePacket),RemoteOobDataRequestReplyComplete(RemoteOobDataRequestReplyCompletePacket),RemoteOobDataRequestNegativeReplyComplete(RemoteOobDataRequestNegativeReplyCompletePacket),IoCapabilityRequestNegativeReplyComplete(IoCapabilityRequestNegativeReplyCompletePacket),RemoteOobExtendedDataRequestReplyComplete(RemoteOobExtendedDataRequestReplyCompletePacket),RoleDiscoveryComplete(RoleDiscoveryCompletePacket),ReadLinkPolicySettingsComplete(ReadLinkPolicySettingsCompletePacket),WriteLinkPolicySettingsComplete(WriteLinkPolicySettingsCompletePacket),ReadDefaultLinkPolicySettingsComplete(ReadDefaultLinkPolicySettingsCompletePacket),WriteDefaultLinkPolicySettingsComplete(WriteDefaultLinkPolicySettingsCompletePacket),SniffSubratingComplete(SniffSubratingCompletePacket),SetEventMaskComplete(SetEventMaskCompletePacket),ResetComplete(ResetCompletePacket),SetEventFilterComplete(SetEventFilterCompletePacket),FlushComplete(FlushCompletePacket),ReadPinTypeComplete(ReadPinTypeCompletePacket),WritePinTypeComplete(WritePinTypeCompletePacket),ReadStoredLinkKeyComplete(ReadStoredLinkKeyCompletePacket),WriteStoredLinkKeyComplete(WriteStoredLinkKeyCompletePacket),DeleteStoredLinkKeyComplete(DeleteStoredLinkKeyCompletePacket),WriteLocalNameComplete(WriteLocalNameCompletePacket),ReadLocalNameComplete(ReadLocalNameCompletePacket),ReadConnectionAcceptTimeoutComplete(ReadConnectionAcceptTimeoutCompletePacket),WriteConnectionAcceptTimeoutComplete(WriteConnectionAcceptTimeoutCompletePacket),ReadPageTimeoutComplete(ReadPageTimeoutCompletePacket),WritePageTimeoutComplete(WritePageTimeoutCompletePacket),ReadScanEnableComplete(ReadScanEnableCompletePacket),WriteScanEnableComplete(WriteScanEnableCompletePacket),ReadPageScanActivityComplete(ReadPageScanActivityCompletePacket),WritePageScanActivityComplete(WritePageScanActivityCompletePacket),ReadInquiryScanActivityComplete(ReadInquiryScanActivityCompletePacket),WriteInquiryScanActivityComplete(WriteInquiryScanActivityCompletePacket),ReadAuthenticationEnableComplete(ReadAuthenticationEnableCompletePacket),WriteAuthenticationEnableComplete(WriteAuthenticationEnableCompletePacket),ReadClassOfDeviceComplete(ReadClassOfDeviceCompletePacket),WriteClassOfDeviceComplete(WriteClassOfDeviceCompletePacket),ReadVoiceSettingComplete(ReadVoiceSettingCompletePacket),WriteVoiceSettingComplete(WriteVoiceSettingCompletePacket),ReadAutomaticFlushTimeoutComplete(ReadAutomaticFlushTimeoutCompletePacket),WriteAutomaticFlushTimeoutComplete(WriteAutomaticFlushTimeoutCompletePacket),ReadNumBroadcastRetransmitsComplete(ReadNumBroadcastRetransmitsCompletePacket),WriteNumBroadcastRetransmitsComplete(WriteNumBroadcastRetransmitsCompletePacket),ReadHoldModeActivityComplete(ReadHoldModeActivityCompletePacket),WriteHoldModeActivityComplete(WriteHoldModeActivityCompletePacket),ReadTransmitPowerLevelComplete(ReadTransmitPowerLevelCompletePacket),ReadSynchronousFlowControlEnableComplete(ReadSynchronousFlowControlEnableCompletePacket),WriteSynchronousFlowControlEnableComplete(WriteSynchronousFlowControlEnableCompletePacket),SetControllerToHostFlowControlComplete(SetControllerToHostFlowControlCompletePacket),HostBufferSizeComplete(HostBufferSizeCompletePacket),HostNumCompletedPacketsError(HostNumCompletedPacketsErrorPacket),ReadLinkSupervisionTimeoutComplete(ReadLinkSupervisionTimeoutCompletePacket),WriteLinkSupervisionTimeoutComplete(WriteLinkSupervisionTimeoutCompletePacket),ReadNumberOfSupportedIacComplete(ReadNumberOfSupportedIacCompletePacket),ReadCurrentIacLapComplete(ReadCurrentIacLapCompletePacket),WriteCurrentIacLapComplete(WriteCurrentIacLapCompletePacket),SetAfhHostChannelClassificationComplete(SetAfhHostChannelClassificationCompletePacket),ReadInquiryScanTypeComplete(ReadInquiryScanTypeCompletePacket),WriteInquiryScanTypeComplete(WriteInquiryScanTypeCompletePacket),ReadInquiryModeComplete(ReadInquiryModeCompletePacket),WriteInquiryModeComplete(WriteInquiryModeCompletePacket),ReadPageScanTypeComplete(ReadPageScanTypeCompletePacket),WritePageScanTypeComplete(WritePageScanTypeCompletePacket),ReadAfhChannelAssessmentModeComplete(ReadAfhChannelAssessmentModeCompletePacket),WriteAfhChannelAssessmentModeComplete(WriteAfhChannelAssessmentModeCompletePacket),ReadExtendedInquiryResponseComplete(ReadExtendedInquiryResponseCompletePacket),WriteExtendedInquiryResponseComplete(WriteExtendedInquiryResponseCompletePacket),ReadSimplePairingModeComplete(ReadSimplePairingModeCompletePacket),WriteSimplePairingModeComplete(WriteSimplePairingModeCompletePacket),ReadLocalOobDataComplete(ReadLocalOobDataCompletePacket),ReadInquiryResponseTransmitPowerLevelComplete(ReadInquiryResponseTransmitPowerLevelCompletePacket),WriteInquiryResponseTransmitPowerLevelComplete(WriteInquiryResponseTransmitPowerLevelCompletePacket),SendKeypressNotificationComplete(SendKeypressNotificationCompletePacket),ReadLeHostSupportComplete(ReadLeHostSupportCompletePacket),WriteLeHostSupportComplete(WriteLeHostSupportCompletePacket),ReadSecureConnectionsHostSupportComplete(ReadSecureConnectionsHostSupportCompletePacket),WriteSecureConnectionsHostSupportComplete(WriteSecureConnectionsHostSupportCompletePacket),ReadLocalOobExtendedDataComplete(ReadLocalOobExtendedDataCompletePacket),SetEcosystemBaseIntervalComplete(SetEcosystemBaseIntervalCompletePacket),ConfigureDataPathComplete(ConfigureDataPathCompletePacket),ReadLocalVersionInformationComplete(ReadLocalVersionInformationCompletePacket),ReadLocalSupportedCommandsComplete(ReadLocalSupportedCommandsCompletePacket),ReadLocalSupportedFeaturesComplete(ReadLocalSupportedFeaturesCompletePacket),ReadLocalExtendedFeaturesComplete(ReadLocalExtendedFeaturesCompletePacket),ReadBufferSizeComplete(ReadBufferSizeCompletePacket),ReadBdAddrComplete(ReadBdAddrCompletePacket),ReadDataBlockSizeComplete(ReadDataBlockSizeCompletePacket),ReadLocalSupportedCodecsV1Complete(ReadLocalSupportedCodecsV1CompletePacket),ReadLocalSupportedCodecsV2Complete(ReadLocalSupportedCodecsV2CompletePacket),ReadLocalSupportedCodecCapabilitiesComplete(ReadLocalSupportedCodecCapabilitiesCompletePacket),ReadLocalSupportedControllerDelayComplete(ReadLocalSupportedControllerDelayCompletePacket),ReadFailedContactCounterComplete(ReadFailedContactCounterCompletePacket),ResetFailedContactCounterComplete(ResetFailedContactCounterCompletePacket),ReadLinkQualityComplete(ReadLinkQualityCompletePacket),ReadRssiComplete(ReadRssiCompletePacket),ReadAfhChannelMapComplete(ReadAfhChannelMapCompletePacket),ReadClockComplete(ReadClockCompletePacket),ReadEncryptionKeySizeComplete(ReadEncryptionKeySizeCompletePacket),ReadLoopbackModeComplete(ReadLoopbackModeCompletePacket),WriteLoopbackModeComplete(WriteLoopbackModeCompletePacket),EnableDeviceUnderTestModeComplete(EnableDeviceUnderTestModeCompletePacket),WriteSimplePairingDebugModeComplete(WriteSimplePairingDebugModeCompletePacket),WriteSecureConnectionsTestModeComplete(WriteSecureConnectionsTestModeCompletePacket),LeSetEventMaskComplete(LeSetEventMaskCompletePacket),LeReadBufferSizeV1Complete(LeReadBufferSizeV1CompletePacket),LeReadLocalSupportedFeaturesComplete(LeReadLocalSupportedFeaturesCompletePacket),LeSetRandomAddressComplete(LeSetRandomAddressCompletePacket),LeSetAdvertisingParametersComplete(LeSetAdvertisingParametersCompletePacket),LeReadAdvertisingPhysicalChannelTxPowerComplete(LeReadAdvertisingPhysicalChannelTxPowerCompletePacket),LeSetAdvertisingDataComplete(LeSetAdvertisingDataCompletePacket),LeSetScanResponseDataComplete(LeSetScanResponseDataCompletePacket),LeSetAdvertisingEnableComplete(LeSetAdvertisingEnableCompletePacket),LeSetScanParametersComplete(LeSetScanParametersCompletePacket),LeSetScanEnableComplete(LeSetScanEnableCompletePacket),LeCreateConnectionCancelComplete(LeCreateConnectionCancelCompletePacket),LeReadConnectListSizeComplete(LeReadConnectListSizeCompletePacket),LeClearConnectListComplete(LeClearConnectListCompletePacket),LeAddDeviceToConnectListComplete(LeAddDeviceToConnectListCompletePacket),LeRemoveDeviceFromConnectListComplete(LeRemoveDeviceFromConnectListCompletePacket),LeSetHostChannelClassificationComplete(LeSetHostChannelClassificationCompletePacket),LeReadChannelMapComplete(LeReadChannelMapCompletePacket),LeEncryptComplete(LeEncryptCompletePacket),LeRandComplete(LeRandCompletePacket),LeLongTermKeyRequestReplyComplete(LeLongTermKeyRequestReplyCompletePacket),LeLongTermKeyRequestNegativeReplyComplete(LeLongTermKeyRequestNegativeReplyCompletePacket),LeReadSupportedStatesComplete(LeReadSupportedStatesCompletePacket),LeReceiverTestComplete(LeReceiverTestCompletePacket),LeTransmitterTestComplete(LeTransmitterTestCompletePacket),LeTestEndComplete(LeTestEndCompletePacket),LeRemoteConnectionParameterRequestReplyComplete(LeRemoteConnectionParameterRequestReplyCompletePacket),LeRemoteConnectionParameterRequestNegativeReplyComplete(LeRemoteConnectionParameterRequestNegativeReplyCompletePacket),LeSetDataLengthComplete(LeSetDataLengthCompletePacket),LeReadSuggestedDefaultDataLengthComplete(LeReadSuggestedDefaultDataLengthCompletePacket),LeWriteSuggestedDefaultDataLengthComplete(LeWriteSuggestedDefaultDataLengthCompletePacket),LeAddDeviceToResolvingListComplete(LeAddDeviceToResolvingListCompletePacket),LeRemoveDeviceFromResolvingListComplete(LeRemoveDeviceFromResolvingListCompletePacket),LeClearResolvingListComplete(LeClearResolvingListCompletePacket),LeReadResolvingListSizeComplete(LeReadResolvingListSizeCompletePacket),LeReadPeerResolvableAddressComplete(LeReadPeerResolvableAddressCompletePacket),LeReadLocalResolvableAddressComplete(LeReadLocalResolvableAddressCompletePacket),LeSetAddressResolutionEnableComplete(LeSetAddressResolutionEnableCompletePacket),LeSetResolvablePrivateAddressTimeoutComplete(LeSetResolvablePrivateAddressTimeoutCompletePacket),LeReadMaximumDataLengthComplete(LeReadMaximumDataLengthCompletePacket),LeReadPhyComplete(LeReadPhyCompletePacket),LeSetDefaultPhyComplete(LeSetDefaultPhyCompletePacket),LeEnhancedReceiverTestComplete(LeEnhancedReceiverTestCompletePacket),LeEnhancedTransmitterTestComplete(LeEnhancedTransmitterTestCompletePacket),LeSetExtendedAdvertisingRandomAddressComplete(LeSetExtendedAdvertisingRandomAddressCompletePacket),LeSetExtendedAdvertisingParametersComplete(LeSetExtendedAdvertisingParametersCompletePacket),LeSetExtendedAdvertisingDataComplete(LeSetExtendedAdvertisingDataCompletePacket),LeSetExtendedAdvertisingScanResponseComplete(LeSetExtendedAdvertisingScanResponseCompletePacket),LeSetExtendedAdvertisingEnableComplete(LeSetExtendedAdvertisingEnableCompletePacket),LeReadMaximumAdvertisingDataLengthComplete(LeReadMaximumAdvertisingDataLengthCompletePacket),LeReadNumberOfSupportedAdvertisingSetsComplete(LeReadNumberOfSupportedAdvertisingSetsCompletePacket),LeRemoveAdvertisingSetComplete(LeRemoveAdvertisingSetCompletePacket),LeClearAdvertisingSetsComplete(LeClearAdvertisingSetsCompletePacket),LeSetPeriodicAdvertisingParamComplete(LeSetPeriodicAdvertisingParamCompletePacket),LeSetPeriodicAdvertisingDataComplete(LeSetPeriodicAdvertisingDataCompletePacket),LeSetPeriodicAdvertisingEnableComplete(LeSetPeriodicAdvertisingEnableCompletePacket),LeSetExtendedScanParametersComplete(LeSetExtendedScanParametersCompletePacket),LeSetExtendedScanEnableComplete(LeSetExtendedScanEnableCompletePacket),LePeriodicAdvertisingCreateSyncCancelComplete(LePeriodicAdvertisingCreateSyncCancelCompletePacket),LePeriodicAdvertisingTerminateSyncComplete(LePeriodicAdvertisingTerminateSyncCompletePacket),LeAddDeviceToPeriodicAdvertisingListComplete(LeAddDeviceToPeriodicAdvertisingListCompletePacket),LeRemoveDeviceFromPeriodicAdvertisingListComplete(LeRemoveDeviceFromPeriodicAdvertisingListCompletePacket),LeClearPeriodicAdvertisingListComplete(LeClearPeriodicAdvertisingListCompletePacket),LeReadPeriodicAdvertiserListSizeComplete(LeReadPeriodicAdvertiserListSizeCompletePacket),LeReadTransmitPowerComplete(LeReadTransmitPowerCompletePacket),LeReadRfPathCompensationPowerComplete(LeReadRfPathCompensationPowerCompletePacket),LeWriteRfPathCompensationPowerComplete(LeWriteRfPathCompensationPowerCompletePacket),LeSetPrivacyModeComplete(LeSetPrivacyModeCompletePacket),LeSetPeriodicAdvertisingReceiveEnableComplete(LeSetPeriodicAdvertisingReceiveEnableCompletePacket),LePeriodicAdvertisingSyncTransferComplete(LePeriodicAdvertisingSyncTransferCompletePacket),LePeriodicAdvertisingSetInfoTransferComplete(LePeriodicAdvertisingSetInfoTransferCompletePacket),LeSetPeriodicAdvertisingSyncTransferParametersComplete(LeSetPeriodicAdvertisingSyncTransferParametersCompletePacket),LeSetDefaultPeriodicAdvertisingSyncTransferParametersComplete(LeSetDefaultPeriodicAdvertisingSyncTransferParametersCompletePacket),LeModifySleepClockAccuracyComplete(LeModifySleepClockAccuracyCompletePacket),LeReadBufferSizeV2Complete(LeReadBufferSizeV2CompletePacket),LeReadIsoTxSyncComplete(LeReadIsoTxSyncCompletePacket),LeSetCigParametersComplete(LeSetCigParametersCompletePacket),LeSetCigParametersTestComplete(LeSetCigParametersTestCompletePacket),LeRemoveCigComplete(LeRemoveCigCompletePacket),LeRejectCisRequestComplete(LeRejectCisRequestCompletePacket),LeBigTerminateSyncComplete(LeBigTerminateSyncCompletePacket),LeSetupIsoDataPathComplete(LeSetupIsoDataPathCompletePacket),LeRemoveIsoDataPathComplete(LeRemoveIsoDataPathCompletePacket),LeSetHostFeatureComplete(LeSetHostFeatureCompletePacket),LeReadIsoLinkQualityComplete(LeReadIsoLinkQualityCompletePacket),LeEnhancedReadTransmitPowerLevelComplete(LeEnhancedReadTransmitPowerLevelCompletePacket),LeSetPathLossReportingParametersComplete(LeSetPathLossReportingParametersCompletePacket),LeSetPathLossReportingEnableComplete(LeSetPathLossReportingEnableCompletePacket),LeSetTransmitPowerReportingEnableComplete(LeSetTransmitPowerReportingEnableCompletePacket),LeGetVendorCapabilitiesComplete(LeGetVendorCapabilitiesCompletePacket),LeMultiAdvtComplete(LeMultiAdvtCompletePacket),LeBatchScanComplete(LeBatchScanCompletePacket),LeAdvFilterComplete(LeAdvFilterCompletePacket),LeEnergyInfoComplete(LeEnergyInfoCompletePacket),LeExtendedScanParamsComplete(LeExtendedScanParamsCompletePacket),ControllerDebugInfoComplete(ControllerDebugInfoCompletePacket),ControllerA2DPOpcodeComplete(ControllerA2DPOpcodeCompletePacket),ControllerBqrComplete(ControllerBqrCompletePacket),Payload(Bytes),None,}
#[derive(Debug)] struct CommandCompleteData {num_hci_command_packets: u8, command_op_code: OpCode, child: CommandCompleteDataChild,}
#[derive(Debug, Clone)] pub struct CommandCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,}
#[derive(Debug)] pub struct CommandCompleteBuilder {pub num_hci_command_packets: u8, pub command_op_code: OpCode, pub payload: Option<Bytes>,}
impl CommandCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "CommandComplete".to_string(),    field: "num_hci_command_packets".to_string(),    wanted: 3,    got: bytes.len()});}let num_hci_command_packets = u8::from_le_bytes([bytes[2]]);if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "CommandComplete".to_string(),    field: "command_op_code".to_string(),    wanted: 5,    got: bytes.len()});}let command_op_code = u16::from_le_bytes([bytes[3],bytes[4]]);let command_op_code = OpCode::from_u16(command_op_code).unwrap();let payload: Vec::<u8> = bytes[5..].into();let child = match command_op_code {OpCode::None if NoCommandCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::NoCommandComplete(Arc::new(NoCommandCompleteData::parse(&bytes[..])?))}
OpCode::InquiryCancel if InquiryCancelCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::InquiryCancelComplete(Arc::new(InquiryCancelCompleteData::parse(&bytes[..])?))}
OpCode::PeriodicInquiryMode if PeriodicInquiryModeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::PeriodicInquiryModeComplete(Arc::new(PeriodicInquiryModeCompleteData::parse(&bytes[..])?))}
OpCode::ExitPeriodicInquiryMode if ExitPeriodicInquiryModeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ExitPeriodicInquiryModeComplete(Arc::new(ExitPeriodicInquiryModeCompleteData::parse(&bytes[..])?))}
OpCode::CreateConnectionCancel if CreateConnectionCancelCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::CreateConnectionCancelComplete(Arc::new(CreateConnectionCancelCompleteData::parse(&bytes[..])?))}
OpCode::LinkKeyRequestReply if LinkKeyRequestReplyCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LinkKeyRequestReplyComplete(Arc::new(LinkKeyRequestReplyCompleteData::parse(&bytes[..])?))}
OpCode::RemoteOobDataRequestReply if RemoteOobDataRequestReplyCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::RemoteOobDataRequestReplyComplete(Arc::new(RemoteOobDataRequestReplyCompleteData::parse(&bytes[..])?))}
OpCode::LinkKeyRequestNegativeReply if LinkKeyRequestNegativeReplyCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LinkKeyRequestNegativeReplyComplete(Arc::new(LinkKeyRequestNegativeReplyCompleteData::parse(&bytes[..])?))}
OpCode::PinCodeRequestReply if PinCodeRequestReplyCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::PinCodeRequestReplyComplete(Arc::new(PinCodeRequestReplyCompleteData::parse(&bytes[..])?))}
OpCode::PinCodeRequestNegativeReply if PinCodeRequestNegativeReplyCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::PinCodeRequestNegativeReplyComplete(Arc::new(PinCodeRequestNegativeReplyCompleteData::parse(&bytes[..])?))}
OpCode::RemoteNameRequestCancel if RemoteNameRequestCancelCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::RemoteNameRequestCancelComplete(Arc::new(RemoteNameRequestCancelCompleteData::parse(&bytes[..])?))}
OpCode::ReadLmpHandle if ReadLmpHandleCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadLmpHandleComplete(Arc::new(ReadLmpHandleCompleteData::parse(&bytes[..])?))}
OpCode::IoCapabilityRequestReply if IoCapabilityRequestReplyCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::IoCapabilityRequestReplyComplete(Arc::new(IoCapabilityRequestReplyCompleteData::parse(&bytes[..])?))}
OpCode::UserConfirmationRequestReply if UserConfirmationRequestReplyCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::UserConfirmationRequestReplyComplete(Arc::new(UserConfirmationRequestReplyCompleteData::parse(&bytes[..])?))}
OpCode::UserConfirmationRequestNegativeReply if UserConfirmationRequestNegativeReplyCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::UserConfirmationRequestNegativeReplyComplete(Arc::new(UserConfirmationRequestNegativeReplyCompleteData::parse(&bytes[..])?))}
OpCode::UserPasskeyRequestReply if UserPasskeyRequestReplyCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::UserPasskeyRequestReplyComplete(Arc::new(UserPasskeyRequestReplyCompleteData::parse(&bytes[..])?))}
OpCode::UserPasskeyRequestNegativeReply if UserPasskeyRequestNegativeReplyCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::UserPasskeyRequestNegativeReplyComplete(Arc::new(UserPasskeyRequestNegativeReplyCompleteData::parse(&bytes[..])?))}
OpCode::RemoteOobDataRequestNegativeReply if RemoteOobDataRequestNegativeReplyCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::RemoteOobDataRequestNegativeReplyComplete(Arc::new(RemoteOobDataRequestNegativeReplyCompleteData::parse(&bytes[..])?))}
OpCode::IoCapabilityRequestNegativeReply if IoCapabilityRequestNegativeReplyCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::IoCapabilityRequestNegativeReplyComplete(Arc::new(IoCapabilityRequestNegativeReplyCompleteData::parse(&bytes[..])?))}
OpCode::RemoteOobExtendedDataRequestReply if RemoteOobExtendedDataRequestReplyCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::RemoteOobExtendedDataRequestReplyComplete(Arc::new(RemoteOobExtendedDataRequestReplyCompleteData::parse(&bytes[..])?))}
OpCode::RoleDiscovery if RoleDiscoveryCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::RoleDiscoveryComplete(Arc::new(RoleDiscoveryCompleteData::parse(&bytes[..])?))}
OpCode::ReadLinkPolicySettings if ReadLinkPolicySettingsCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadLinkPolicySettingsComplete(Arc::new(ReadLinkPolicySettingsCompleteData::parse(&bytes[..])?))}
OpCode::WriteLinkPolicySettings if WriteLinkPolicySettingsCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteLinkPolicySettingsComplete(Arc::new(WriteLinkPolicySettingsCompleteData::parse(&bytes[..])?))}
OpCode::ReadDefaultLinkPolicySettings if ReadDefaultLinkPolicySettingsCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadDefaultLinkPolicySettingsComplete(Arc::new(ReadDefaultLinkPolicySettingsCompleteData::parse(&bytes[..])?))}
OpCode::WriteDefaultLinkPolicySettings if WriteDefaultLinkPolicySettingsCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteDefaultLinkPolicySettingsComplete(Arc::new(WriteDefaultLinkPolicySettingsCompleteData::parse(&bytes[..])?))}
OpCode::SniffSubrating if SniffSubratingCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::SniffSubratingComplete(Arc::new(SniffSubratingCompleteData::parse(&bytes[..])?))}
OpCode::SetEventMask if SetEventMaskCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::SetEventMaskComplete(Arc::new(SetEventMaskCompleteData::parse(&bytes[..])?))}
OpCode::Reset if ResetCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ResetComplete(Arc::new(ResetCompleteData::parse(&bytes[..])?))}
OpCode::SetEventFilter if SetEventFilterCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::SetEventFilterComplete(Arc::new(SetEventFilterCompleteData::parse(&bytes[..])?))}
OpCode::Flush if FlushCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::FlushComplete(Arc::new(FlushCompleteData::parse(&bytes[..])?))}
OpCode::ReadPinType if ReadPinTypeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadPinTypeComplete(Arc::new(ReadPinTypeCompleteData::parse(&bytes[..])?))}
OpCode::WritePinType if WritePinTypeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WritePinTypeComplete(Arc::new(WritePinTypeCompleteData::parse(&bytes[..])?))}
OpCode::ReadStoredLinkKey if ReadStoredLinkKeyCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadStoredLinkKeyComplete(Arc::new(ReadStoredLinkKeyCompleteData::parse(&bytes[..])?))}
OpCode::WriteStoredLinkKey if WriteStoredLinkKeyCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteStoredLinkKeyComplete(Arc::new(WriteStoredLinkKeyCompleteData::parse(&bytes[..])?))}
OpCode::DeleteStoredLinkKey if DeleteStoredLinkKeyCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::DeleteStoredLinkKeyComplete(Arc::new(DeleteStoredLinkKeyCompleteData::parse(&bytes[..])?))}
OpCode::WriteLocalName if WriteLocalNameCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteLocalNameComplete(Arc::new(WriteLocalNameCompleteData::parse(&bytes[..])?))}
OpCode::ReadLocalName if ReadLocalNameCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadLocalNameComplete(Arc::new(ReadLocalNameCompleteData::parse(&bytes[..])?))}
OpCode::ReadConnectionAcceptTimeout if ReadConnectionAcceptTimeoutCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadConnectionAcceptTimeoutComplete(Arc::new(ReadConnectionAcceptTimeoutCompleteData::parse(&bytes[..])?))}
OpCode::WriteConnectionAcceptTimeout if WriteConnectionAcceptTimeoutCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteConnectionAcceptTimeoutComplete(Arc::new(WriteConnectionAcceptTimeoutCompleteData::parse(&bytes[..])?))}
OpCode::ReadPageTimeout if ReadPageTimeoutCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadPageTimeoutComplete(Arc::new(ReadPageTimeoutCompleteData::parse(&bytes[..])?))}
OpCode::WritePageTimeout if WritePageTimeoutCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WritePageTimeoutComplete(Arc::new(WritePageTimeoutCompleteData::parse(&bytes[..])?))}
OpCode::ReadScanEnable if ReadScanEnableCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadScanEnableComplete(Arc::new(ReadScanEnableCompleteData::parse(&bytes[..])?))}
OpCode::WriteScanEnable if WriteScanEnableCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteScanEnableComplete(Arc::new(WriteScanEnableCompleteData::parse(&bytes[..])?))}
OpCode::ReadPageScanActivity if ReadPageScanActivityCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadPageScanActivityComplete(Arc::new(ReadPageScanActivityCompleteData::parse(&bytes[..])?))}
OpCode::WritePageScanActivity if WritePageScanActivityCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WritePageScanActivityComplete(Arc::new(WritePageScanActivityCompleteData::parse(&bytes[..])?))}
OpCode::ReadInquiryScanActivity if ReadInquiryScanActivityCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadInquiryScanActivityComplete(Arc::new(ReadInquiryScanActivityCompleteData::parse(&bytes[..])?))}
OpCode::WriteInquiryScanActivity if WriteInquiryScanActivityCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteInquiryScanActivityComplete(Arc::new(WriteInquiryScanActivityCompleteData::parse(&bytes[..])?))}
OpCode::ReadAuthenticationEnable if ReadAuthenticationEnableCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadAuthenticationEnableComplete(Arc::new(ReadAuthenticationEnableCompleteData::parse(&bytes[..])?))}
OpCode::WriteAuthenticationEnable if WriteAuthenticationEnableCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteAuthenticationEnableComplete(Arc::new(WriteAuthenticationEnableCompleteData::parse(&bytes[..])?))}
OpCode::ReadClassOfDevice if ReadClassOfDeviceCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadClassOfDeviceComplete(Arc::new(ReadClassOfDeviceCompleteData::parse(&bytes[..])?))}
OpCode::WriteClassOfDevice if WriteClassOfDeviceCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteClassOfDeviceComplete(Arc::new(WriteClassOfDeviceCompleteData::parse(&bytes[..])?))}
OpCode::ReadVoiceSetting if ReadVoiceSettingCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadVoiceSettingComplete(Arc::new(ReadVoiceSettingCompleteData::parse(&bytes[..])?))}
OpCode::WriteVoiceSetting if WriteVoiceSettingCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteVoiceSettingComplete(Arc::new(WriteVoiceSettingCompleteData::parse(&bytes[..])?))}
OpCode::ReadAutomaticFlushTimeout if ReadAutomaticFlushTimeoutCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadAutomaticFlushTimeoutComplete(Arc::new(ReadAutomaticFlushTimeoutCompleteData::parse(&bytes[..])?))}
OpCode::WriteAutomaticFlushTimeout if WriteAutomaticFlushTimeoutCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteAutomaticFlushTimeoutComplete(Arc::new(WriteAutomaticFlushTimeoutCompleteData::parse(&bytes[..])?))}
OpCode::ReadNumBroadcastRetransmits if ReadNumBroadcastRetransmitsCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadNumBroadcastRetransmitsComplete(Arc::new(ReadNumBroadcastRetransmitsCompleteData::parse(&bytes[..])?))}
OpCode::WriteNumBroadcastRetransmits if WriteNumBroadcastRetransmitsCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteNumBroadcastRetransmitsComplete(Arc::new(WriteNumBroadcastRetransmitsCompleteData::parse(&bytes[..])?))}
OpCode::ReadHoldModeActivity if ReadHoldModeActivityCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadHoldModeActivityComplete(Arc::new(ReadHoldModeActivityCompleteData::parse(&bytes[..])?))}
OpCode::WriteHoldModeActivity if WriteHoldModeActivityCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteHoldModeActivityComplete(Arc::new(WriteHoldModeActivityCompleteData::parse(&bytes[..])?))}
OpCode::ReadTransmitPowerLevel if ReadTransmitPowerLevelCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadTransmitPowerLevelComplete(Arc::new(ReadTransmitPowerLevelCompleteData::parse(&bytes[..])?))}
OpCode::ReadSynchronousFlowControlEnable if ReadSynchronousFlowControlEnableCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadSynchronousFlowControlEnableComplete(Arc::new(ReadSynchronousFlowControlEnableCompleteData::parse(&bytes[..])?))}
OpCode::WriteSynchronousFlowControlEnable if WriteSynchronousFlowControlEnableCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteSynchronousFlowControlEnableComplete(Arc::new(WriteSynchronousFlowControlEnableCompleteData::parse(&bytes[..])?))}
OpCode::SetControllerToHostFlowControl if SetControllerToHostFlowControlCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::SetControllerToHostFlowControlComplete(Arc::new(SetControllerToHostFlowControlCompleteData::parse(&bytes[..])?))}
OpCode::HostBufferSize if HostBufferSizeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::HostBufferSizeComplete(Arc::new(HostBufferSizeCompleteData::parse(&bytes[..])?))}
OpCode::HostNumCompletedPackets if HostNumCompletedPacketsErrorData::conforms(&bytes[..]) => {CommandCompleteDataChild::HostNumCompletedPacketsError(Arc::new(HostNumCompletedPacketsErrorData::parse(&bytes[..])?))}
OpCode::ReadLinkSupervisionTimeout if ReadLinkSupervisionTimeoutCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadLinkSupervisionTimeoutComplete(Arc::new(ReadLinkSupervisionTimeoutCompleteData::parse(&bytes[..])?))}
OpCode::WriteLinkSupervisionTimeout if WriteLinkSupervisionTimeoutCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteLinkSupervisionTimeoutComplete(Arc::new(WriteLinkSupervisionTimeoutCompleteData::parse(&bytes[..])?))}
OpCode::ReadNumberOfSupportedIac if ReadNumberOfSupportedIacCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadNumberOfSupportedIacComplete(Arc::new(ReadNumberOfSupportedIacCompleteData::parse(&bytes[..])?))}
OpCode::ReadCurrentIacLap if ReadCurrentIacLapCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadCurrentIacLapComplete(Arc::new(ReadCurrentIacLapCompleteData::parse(&bytes[..])?))}
OpCode::WriteCurrentIacLap if WriteCurrentIacLapCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteCurrentIacLapComplete(Arc::new(WriteCurrentIacLapCompleteData::parse(&bytes[..])?))}
OpCode::SetAfhHostChannelClassification if SetAfhHostChannelClassificationCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::SetAfhHostChannelClassificationComplete(Arc::new(SetAfhHostChannelClassificationCompleteData::parse(&bytes[..])?))}
OpCode::ReadInquiryScanType if ReadInquiryScanTypeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadInquiryScanTypeComplete(Arc::new(ReadInquiryScanTypeCompleteData::parse(&bytes[..])?))}
OpCode::WriteInquiryScanType if WriteInquiryScanTypeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteInquiryScanTypeComplete(Arc::new(WriteInquiryScanTypeCompleteData::parse(&bytes[..])?))}
OpCode::ReadInquiryMode if ReadInquiryModeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadInquiryModeComplete(Arc::new(ReadInquiryModeCompleteData::parse(&bytes[..])?))}
OpCode::WriteInquiryMode if WriteInquiryModeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteInquiryModeComplete(Arc::new(WriteInquiryModeCompleteData::parse(&bytes[..])?))}
OpCode::ReadPageScanType if ReadPageScanTypeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadPageScanTypeComplete(Arc::new(ReadPageScanTypeCompleteData::parse(&bytes[..])?))}
OpCode::WritePageScanType if WritePageScanTypeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WritePageScanTypeComplete(Arc::new(WritePageScanTypeCompleteData::parse(&bytes[..])?))}
OpCode::ReadAfhChannelAssessmentMode if ReadAfhChannelAssessmentModeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadAfhChannelAssessmentModeComplete(Arc::new(ReadAfhChannelAssessmentModeCompleteData::parse(&bytes[..])?))}
OpCode::WriteAfhChannelAssessmentMode if WriteAfhChannelAssessmentModeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteAfhChannelAssessmentModeComplete(Arc::new(WriteAfhChannelAssessmentModeCompleteData::parse(&bytes[..])?))}
OpCode::ReadExtendedInquiryResponse if ReadExtendedInquiryResponseCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadExtendedInquiryResponseComplete(Arc::new(ReadExtendedInquiryResponseCompleteData::parse(&bytes[..])?))}
OpCode::WriteExtendedInquiryResponse if WriteExtendedInquiryResponseCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteExtendedInquiryResponseComplete(Arc::new(WriteExtendedInquiryResponseCompleteData::parse(&bytes[..])?))}
OpCode::ReadSimplePairingMode if ReadSimplePairingModeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadSimplePairingModeComplete(Arc::new(ReadSimplePairingModeCompleteData::parse(&bytes[..])?))}
OpCode::WriteSimplePairingMode if WriteSimplePairingModeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteSimplePairingModeComplete(Arc::new(WriteSimplePairingModeCompleteData::parse(&bytes[..])?))}
OpCode::ReadLocalOobData if ReadLocalOobDataCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadLocalOobDataComplete(Arc::new(ReadLocalOobDataCompleteData::parse(&bytes[..])?))}
OpCode::ReadInquiryResponseTransmitPowerLevel if ReadInquiryResponseTransmitPowerLevelCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadInquiryResponseTransmitPowerLevelComplete(Arc::new(ReadInquiryResponseTransmitPowerLevelCompleteData::parse(&bytes[..])?))}
OpCode::WriteLeHostSupport if WriteLeHostSupportCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteLeHostSupportComplete(Arc::new(WriteLeHostSupportCompleteData::parse(&bytes[..])?))}
OpCode::WriteInquiryTransmitPowerLevel if WriteInquiryResponseTransmitPowerLevelCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteInquiryResponseTransmitPowerLevelComplete(Arc::new(WriteInquiryResponseTransmitPowerLevelCompleteData::parse(&bytes[..])?))}
OpCode::SendKeypressNotification if SendKeypressNotificationCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::SendKeypressNotificationComplete(Arc::new(SendKeypressNotificationCompleteData::parse(&bytes[..])?))}
OpCode::ReadLeHostSupport if ReadLeHostSupportCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadLeHostSupportComplete(Arc::new(ReadLeHostSupportCompleteData::parse(&bytes[..])?))}
OpCode::ReadSecureConnectionsHostSupport if ReadSecureConnectionsHostSupportCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadSecureConnectionsHostSupportComplete(Arc::new(ReadSecureConnectionsHostSupportCompleteData::parse(&bytes[..])?))}
OpCode::WriteSecureConnectionsHostSupport if WriteSecureConnectionsHostSupportCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteSecureConnectionsHostSupportComplete(Arc::new(WriteSecureConnectionsHostSupportCompleteData::parse(&bytes[..])?))}
OpCode::ReadLocalOobExtendedData if ReadLocalOobExtendedDataCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadLocalOobExtendedDataComplete(Arc::new(ReadLocalOobExtendedDataCompleteData::parse(&bytes[..])?))}
OpCode::SetEcosystemBaseInterval if SetEcosystemBaseIntervalCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::SetEcosystemBaseIntervalComplete(Arc::new(SetEcosystemBaseIntervalCompleteData::parse(&bytes[..])?))}
OpCode::ConfigureDataPath if ConfigureDataPathCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ConfigureDataPathComplete(Arc::new(ConfigureDataPathCompleteData::parse(&bytes[..])?))}
OpCode::ReadLocalVersionInformation if ReadLocalVersionInformationCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadLocalVersionInformationComplete(Arc::new(ReadLocalVersionInformationCompleteData::parse(&bytes[..])?))}
OpCode::ReadLocalSupportedCommands if ReadLocalSupportedCommandsCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadLocalSupportedCommandsComplete(Arc::new(ReadLocalSupportedCommandsCompleteData::parse(&bytes[..])?))}
OpCode::ReadLocalSupportedFeatures if ReadLocalSupportedFeaturesCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadLocalSupportedFeaturesComplete(Arc::new(ReadLocalSupportedFeaturesCompleteData::parse(&bytes[..])?))}
OpCode::ReadLocalExtendedFeatures if ReadLocalExtendedFeaturesCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadLocalExtendedFeaturesComplete(Arc::new(ReadLocalExtendedFeaturesCompleteData::parse(&bytes[..])?))}
OpCode::ReadBufferSize if ReadBufferSizeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadBufferSizeComplete(Arc::new(ReadBufferSizeCompleteData::parse(&bytes[..])?))}
OpCode::ReadBdAddr if ReadBdAddrCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadBdAddrComplete(Arc::new(ReadBdAddrCompleteData::parse(&bytes[..])?))}
OpCode::ReadDataBlockSize if ReadDataBlockSizeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadDataBlockSizeComplete(Arc::new(ReadDataBlockSizeCompleteData::parse(&bytes[..])?))}
OpCode::ReadLocalSupportedCodecsV1 if ReadLocalSupportedCodecsV1CompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadLocalSupportedCodecsV1Complete(Arc::new(ReadLocalSupportedCodecsV1CompleteData::parse(&bytes[..])?))}
OpCode::ReadLocalSupportedCodecsV2 if ReadLocalSupportedCodecsV2CompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadLocalSupportedCodecsV2Complete(Arc::new(ReadLocalSupportedCodecsV2CompleteData::parse(&bytes[..])?))}
OpCode::ReadLocalSupportedCodecCapabilities if ReadLocalSupportedCodecCapabilitiesCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadLocalSupportedCodecCapabilitiesComplete(Arc::new(ReadLocalSupportedCodecCapabilitiesCompleteData::parse(&bytes[..])?))}
OpCode::ReadLocalSupportedControllerDelay if ReadLocalSupportedControllerDelayCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadLocalSupportedControllerDelayComplete(Arc::new(ReadLocalSupportedControllerDelayCompleteData::parse(&bytes[..])?))}
OpCode::ReadFailedContactCounter if ReadFailedContactCounterCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadFailedContactCounterComplete(Arc::new(ReadFailedContactCounterCompleteData::parse(&bytes[..])?))}
OpCode::ResetFailedContactCounter if ResetFailedContactCounterCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ResetFailedContactCounterComplete(Arc::new(ResetFailedContactCounterCompleteData::parse(&bytes[..])?))}
OpCode::ReadLinkQuality if ReadLinkQualityCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadLinkQualityComplete(Arc::new(ReadLinkQualityCompleteData::parse(&bytes[..])?))}
OpCode::ReadRssi if ReadRssiCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadRssiComplete(Arc::new(ReadRssiCompleteData::parse(&bytes[..])?))}
OpCode::ReadAfhChannelMap if ReadAfhChannelMapCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadAfhChannelMapComplete(Arc::new(ReadAfhChannelMapCompleteData::parse(&bytes[..])?))}
OpCode::ReadClock if ReadClockCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadClockComplete(Arc::new(ReadClockCompleteData::parse(&bytes[..])?))}
OpCode::ReadEncryptionKeySize if ReadEncryptionKeySizeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadEncryptionKeySizeComplete(Arc::new(ReadEncryptionKeySizeCompleteData::parse(&bytes[..])?))}
OpCode::ReadLoopbackMode if ReadLoopbackModeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ReadLoopbackModeComplete(Arc::new(ReadLoopbackModeCompleteData::parse(&bytes[..])?))}
OpCode::WriteLoopbackMode if WriteLoopbackModeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteLoopbackModeComplete(Arc::new(WriteLoopbackModeCompleteData::parse(&bytes[..])?))}
OpCode::EnableDeviceUnderTestMode if EnableDeviceUnderTestModeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::EnableDeviceUnderTestModeComplete(Arc::new(EnableDeviceUnderTestModeCompleteData::parse(&bytes[..])?))}
OpCode::WriteSimplePairingDebugMode if WriteSimplePairingDebugModeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteSimplePairingDebugModeComplete(Arc::new(WriteSimplePairingDebugModeCompleteData::parse(&bytes[..])?))}
OpCode::WriteSecureConnectionsTestMode if WriteSecureConnectionsTestModeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::WriteSecureConnectionsTestModeComplete(Arc::new(WriteSecureConnectionsTestModeCompleteData::parse(&bytes[..])?))}
OpCode::LeSetEventMask if LeSetEventMaskCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetEventMaskComplete(Arc::new(LeSetEventMaskCompleteData::parse(&bytes[..])?))}
OpCode::LeReadBufferSizeV1 if LeReadBufferSizeV1CompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeReadBufferSizeV1Complete(Arc::new(LeReadBufferSizeV1CompleteData::parse(&bytes[..])?))}
OpCode::LeReadLocalSupportedFeatures if LeReadLocalSupportedFeaturesCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeReadLocalSupportedFeaturesComplete(Arc::new(LeReadLocalSupportedFeaturesCompleteData::parse(&bytes[..])?))}
OpCode::LeSetRandomAddress if LeSetRandomAddressCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetRandomAddressComplete(Arc::new(LeSetRandomAddressCompleteData::parse(&bytes[..])?))}
OpCode::LeSetAdvertisingParameters if LeSetAdvertisingParametersCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetAdvertisingParametersComplete(Arc::new(LeSetAdvertisingParametersCompleteData::parse(&bytes[..])?))}
OpCode::LeReadAdvertisingPhysicalChannelTxPower if LeReadAdvertisingPhysicalChannelTxPowerCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeReadAdvertisingPhysicalChannelTxPowerComplete(Arc::new(LeReadAdvertisingPhysicalChannelTxPowerCompleteData::parse(&bytes[..])?))}
OpCode::LeSetAdvertisingData if LeSetAdvertisingDataCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetAdvertisingDataComplete(Arc::new(LeSetAdvertisingDataCompleteData::parse(&bytes[..])?))}
OpCode::LeSetScanResponseData if LeSetScanResponseDataCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetScanResponseDataComplete(Arc::new(LeSetScanResponseDataCompleteData::parse(&bytes[..])?))}
OpCode::LeSetAdvertisingEnable if LeSetAdvertisingEnableCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetAdvertisingEnableComplete(Arc::new(LeSetAdvertisingEnableCompleteData::parse(&bytes[..])?))}
OpCode::LeSetScanParameters if LeSetScanParametersCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetScanParametersComplete(Arc::new(LeSetScanParametersCompleteData::parse(&bytes[..])?))}
OpCode::LeSetScanEnable if LeSetScanEnableCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetScanEnableComplete(Arc::new(LeSetScanEnableCompleteData::parse(&bytes[..])?))}
OpCode::LeCreateConnectionCancel if LeCreateConnectionCancelCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeCreateConnectionCancelComplete(Arc::new(LeCreateConnectionCancelCompleteData::parse(&bytes[..])?))}
OpCode::LeReadConnectListSize if LeReadConnectListSizeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeReadConnectListSizeComplete(Arc::new(LeReadConnectListSizeCompleteData::parse(&bytes[..])?))}
OpCode::LeClearConnectList if LeClearConnectListCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeClearConnectListComplete(Arc::new(LeClearConnectListCompleteData::parse(&bytes[..])?))}
OpCode::LeAddDeviceToConnectList if LeAddDeviceToConnectListCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeAddDeviceToConnectListComplete(Arc::new(LeAddDeviceToConnectListCompleteData::parse(&bytes[..])?))}
OpCode::LeRemoveDeviceFromConnectList if LeRemoveDeviceFromConnectListCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeRemoveDeviceFromConnectListComplete(Arc::new(LeRemoveDeviceFromConnectListCompleteData::parse(&bytes[..])?))}
OpCode::LeSetHostChannelClassification if LeSetHostChannelClassificationCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetHostChannelClassificationComplete(Arc::new(LeSetHostChannelClassificationCompleteData::parse(&bytes[..])?))}
OpCode::LeReadChannelMap if LeReadChannelMapCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeReadChannelMapComplete(Arc::new(LeReadChannelMapCompleteData::parse(&bytes[..])?))}
OpCode::LeEncrypt if LeEncryptCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeEncryptComplete(Arc::new(LeEncryptCompleteData::parse(&bytes[..])?))}
OpCode::LeRand if LeRandCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeRandComplete(Arc::new(LeRandCompleteData::parse(&bytes[..])?))}
OpCode::LeLongTermKeyRequestReply if LeLongTermKeyRequestReplyCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeLongTermKeyRequestReplyComplete(Arc::new(LeLongTermKeyRequestReplyCompleteData::parse(&bytes[..])?))}
OpCode::LeLongTermKeyRequestNegativeReply if LeLongTermKeyRequestNegativeReplyCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeLongTermKeyRequestNegativeReplyComplete(Arc::new(LeLongTermKeyRequestNegativeReplyCompleteData::parse(&bytes[..])?))}
OpCode::LeReadSupportedStates if LeReadSupportedStatesCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeReadSupportedStatesComplete(Arc::new(LeReadSupportedStatesCompleteData::parse(&bytes[..])?))}
OpCode::LeReceiverTest if LeReceiverTestCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeReceiverTestComplete(Arc::new(LeReceiverTestCompleteData::parse(&bytes[..])?))}
OpCode::LeTransmitterTest if LeTransmitterTestCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeTransmitterTestComplete(Arc::new(LeTransmitterTestCompleteData::parse(&bytes[..])?))}
OpCode::LeTestEnd if LeTestEndCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeTestEndComplete(Arc::new(LeTestEndCompleteData::parse(&bytes[..])?))}
OpCode::LeRemoteConnectionParameterRequestReply if LeRemoteConnectionParameterRequestReplyCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeRemoteConnectionParameterRequestReplyComplete(Arc::new(LeRemoteConnectionParameterRequestReplyCompleteData::parse(&bytes[..])?))}
OpCode::LeRemoteConnectionParameterRequestNegativeReply if LeRemoteConnectionParameterRequestNegativeReplyCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeRemoteConnectionParameterRequestNegativeReplyComplete(Arc::new(LeRemoteConnectionParameterRequestNegativeReplyCompleteData::parse(&bytes[..])?))}
OpCode::LeSetDataLength if LeSetDataLengthCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetDataLengthComplete(Arc::new(LeSetDataLengthCompleteData::parse(&bytes[..])?))}
OpCode::LeReadSuggestedDefaultDataLength if LeReadSuggestedDefaultDataLengthCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeReadSuggestedDefaultDataLengthComplete(Arc::new(LeReadSuggestedDefaultDataLengthCompleteData::parse(&bytes[..])?))}
OpCode::LeWriteSuggestedDefaultDataLength if LeWriteSuggestedDefaultDataLengthCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeWriteSuggestedDefaultDataLengthComplete(Arc::new(LeWriteSuggestedDefaultDataLengthCompleteData::parse(&bytes[..])?))}
OpCode::LeAddDeviceToResolvingList if LeAddDeviceToResolvingListCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeAddDeviceToResolvingListComplete(Arc::new(LeAddDeviceToResolvingListCompleteData::parse(&bytes[..])?))}
OpCode::LeRemoveDeviceFromResolvingList if LeRemoveDeviceFromResolvingListCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeRemoveDeviceFromResolvingListComplete(Arc::new(LeRemoveDeviceFromResolvingListCompleteData::parse(&bytes[..])?))}
OpCode::LeClearResolvingList if LeClearResolvingListCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeClearResolvingListComplete(Arc::new(LeClearResolvingListCompleteData::parse(&bytes[..])?))}
OpCode::LeReadResolvingListSize if LeReadResolvingListSizeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeReadResolvingListSizeComplete(Arc::new(LeReadResolvingListSizeCompleteData::parse(&bytes[..])?))}
OpCode::LeReadPeerResolvableAddress if LeReadPeerResolvableAddressCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeReadPeerResolvableAddressComplete(Arc::new(LeReadPeerResolvableAddressCompleteData::parse(&bytes[..])?))}
OpCode::LeReadLocalResolvableAddress if LeReadLocalResolvableAddressCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeReadLocalResolvableAddressComplete(Arc::new(LeReadLocalResolvableAddressCompleteData::parse(&bytes[..])?))}
OpCode::LeSetAddressResolutionEnable if LeSetAddressResolutionEnableCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetAddressResolutionEnableComplete(Arc::new(LeSetAddressResolutionEnableCompleteData::parse(&bytes[..])?))}
OpCode::LeSetResolvablePrivateAddressTimeout if LeSetResolvablePrivateAddressTimeoutCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetResolvablePrivateAddressTimeoutComplete(Arc::new(LeSetResolvablePrivateAddressTimeoutCompleteData::parse(&bytes[..])?))}
OpCode::LeReadMaximumDataLength if LeReadMaximumDataLengthCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeReadMaximumDataLengthComplete(Arc::new(LeReadMaximumDataLengthCompleteData::parse(&bytes[..])?))}
OpCode::LeReadPhy if LeReadPhyCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeReadPhyComplete(Arc::new(LeReadPhyCompleteData::parse(&bytes[..])?))}
OpCode::LeSetDefaultPhy if LeSetDefaultPhyCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetDefaultPhyComplete(Arc::new(LeSetDefaultPhyCompleteData::parse(&bytes[..])?))}
OpCode::LeEnhancedReceiverTest if LeEnhancedReceiverTestCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeEnhancedReceiverTestComplete(Arc::new(LeEnhancedReceiverTestCompleteData::parse(&bytes[..])?))}
OpCode::LeEnhancedTransmitterTest if LeEnhancedTransmitterTestCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeEnhancedTransmitterTestComplete(Arc::new(LeEnhancedTransmitterTestCompleteData::parse(&bytes[..])?))}
OpCode::LeSetExtendedAdvertisingRandomAddress if LeSetExtendedAdvertisingRandomAddressCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetExtendedAdvertisingRandomAddressComplete(Arc::new(LeSetExtendedAdvertisingRandomAddressCompleteData::parse(&bytes[..])?))}
OpCode::LeSetExtendedAdvertisingParameters if LeSetExtendedAdvertisingParametersCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetExtendedAdvertisingParametersComplete(Arc::new(LeSetExtendedAdvertisingParametersCompleteData::parse(&bytes[..])?))}
OpCode::LeSetExtendedAdvertisingData if LeSetExtendedAdvertisingDataCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetExtendedAdvertisingDataComplete(Arc::new(LeSetExtendedAdvertisingDataCompleteData::parse(&bytes[..])?))}
OpCode::LeSetExtendedAdvertisingScanResponse if LeSetExtendedAdvertisingScanResponseCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetExtendedAdvertisingScanResponseComplete(Arc::new(LeSetExtendedAdvertisingScanResponseCompleteData::parse(&bytes[..])?))}
OpCode::LeSetExtendedAdvertisingEnable if LeSetExtendedAdvertisingEnableCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetExtendedAdvertisingEnableComplete(Arc::new(LeSetExtendedAdvertisingEnableCompleteData::parse(&bytes[..])?))}
OpCode::LeReadMaximumAdvertisingDataLength if LeReadMaximumAdvertisingDataLengthCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeReadMaximumAdvertisingDataLengthComplete(Arc::new(LeReadMaximumAdvertisingDataLengthCompleteData::parse(&bytes[..])?))}
OpCode::LeReadNumberOfSupportedAdvertisingSets if LeReadNumberOfSupportedAdvertisingSetsCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeReadNumberOfSupportedAdvertisingSetsComplete(Arc::new(LeReadNumberOfSupportedAdvertisingSetsCompleteData::parse(&bytes[..])?))}
OpCode::LeRemoveAdvertisingSet if LeRemoveAdvertisingSetCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeRemoveAdvertisingSetComplete(Arc::new(LeRemoveAdvertisingSetCompleteData::parse(&bytes[..])?))}
OpCode::LeClearAdvertisingSets if LeClearAdvertisingSetsCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeClearAdvertisingSetsComplete(Arc::new(LeClearAdvertisingSetsCompleteData::parse(&bytes[..])?))}
OpCode::LeSetPeriodicAdvertisingParam if LeSetPeriodicAdvertisingParamCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetPeriodicAdvertisingParamComplete(Arc::new(LeSetPeriodicAdvertisingParamCompleteData::parse(&bytes[..])?))}
OpCode::LeSetPeriodicAdvertisingData if LeSetPeriodicAdvertisingDataCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetPeriodicAdvertisingDataComplete(Arc::new(LeSetPeriodicAdvertisingDataCompleteData::parse(&bytes[..])?))}
OpCode::LeSetPeriodicAdvertisingEnable if LeSetPeriodicAdvertisingEnableCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetPeriodicAdvertisingEnableComplete(Arc::new(LeSetPeriodicAdvertisingEnableCompleteData::parse(&bytes[..])?))}
OpCode::LeSetExtendedScanParameters if LeSetExtendedScanParametersCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetExtendedScanParametersComplete(Arc::new(LeSetExtendedScanParametersCompleteData::parse(&bytes[..])?))}
OpCode::LeSetExtendedScanEnable if LeSetExtendedScanEnableCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetExtendedScanEnableComplete(Arc::new(LeSetExtendedScanEnableCompleteData::parse(&bytes[..])?))}
OpCode::LePeriodicAdvertisingCreateSyncCancel if LePeriodicAdvertisingCreateSyncCancelCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LePeriodicAdvertisingCreateSyncCancelComplete(Arc::new(LePeriodicAdvertisingCreateSyncCancelCompleteData::parse(&bytes[..])?))}
OpCode::LePeriodicAdvertisingTerminateSync if LePeriodicAdvertisingTerminateSyncCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LePeriodicAdvertisingTerminateSyncComplete(Arc::new(LePeriodicAdvertisingTerminateSyncCompleteData::parse(&bytes[..])?))}
OpCode::LeAddDeviceToPeriodicAdvertisingList if LeAddDeviceToPeriodicAdvertisingListCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeAddDeviceToPeriodicAdvertisingListComplete(Arc::new(LeAddDeviceToPeriodicAdvertisingListCompleteData::parse(&bytes[..])?))}
OpCode::LeRemoveDeviceFromPeriodicAdvertisingList if LeRemoveDeviceFromPeriodicAdvertisingListCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeRemoveDeviceFromPeriodicAdvertisingListComplete(Arc::new(LeRemoveDeviceFromPeriodicAdvertisingListCompleteData::parse(&bytes[..])?))}
OpCode::LeClearPeriodicAdvertisingList if LeClearPeriodicAdvertisingListCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeClearPeriodicAdvertisingListComplete(Arc::new(LeClearPeriodicAdvertisingListCompleteData::parse(&bytes[..])?))}
OpCode::LeReadPeriodicAdvertisingListSize if LeReadPeriodicAdvertiserListSizeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeReadPeriodicAdvertiserListSizeComplete(Arc::new(LeReadPeriodicAdvertiserListSizeCompleteData::parse(&bytes[..])?))}
OpCode::LeReadTransmitPower if LeReadTransmitPowerCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeReadTransmitPowerComplete(Arc::new(LeReadTransmitPowerCompleteData::parse(&bytes[..])?))}
OpCode::LeReadRfPathCompensationPower if LeReadRfPathCompensationPowerCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeReadRfPathCompensationPowerComplete(Arc::new(LeReadRfPathCompensationPowerCompleteData::parse(&bytes[..])?))}
OpCode::LeWriteRfPathCompensationPower if LeWriteRfPathCompensationPowerCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeWriteRfPathCompensationPowerComplete(Arc::new(LeWriteRfPathCompensationPowerCompleteData::parse(&bytes[..])?))}
OpCode::LeSetPrivacyMode if LeSetPrivacyModeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetPrivacyModeComplete(Arc::new(LeSetPrivacyModeCompleteData::parse(&bytes[..])?))}
OpCode::LeSetPeriodicAdvertisingReceiveEnable if LeSetPeriodicAdvertisingReceiveEnableCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetPeriodicAdvertisingReceiveEnableComplete(Arc::new(LeSetPeriodicAdvertisingReceiveEnableCompleteData::parse(&bytes[..])?))}
OpCode::LePeriodicAdvertisingSyncTransfer if LePeriodicAdvertisingSyncTransferCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LePeriodicAdvertisingSyncTransferComplete(Arc::new(LePeriodicAdvertisingSyncTransferCompleteData::parse(&bytes[..])?))}
OpCode::LePeriodicAdvertisingSetInfoTransfer if LePeriodicAdvertisingSetInfoTransferCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LePeriodicAdvertisingSetInfoTransferComplete(Arc::new(LePeriodicAdvertisingSetInfoTransferCompleteData::parse(&bytes[..])?))}
OpCode::LeSetPeriodicAdvertisingSyncTransferParameters if LeSetPeriodicAdvertisingSyncTransferParametersCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetPeriodicAdvertisingSyncTransferParametersComplete(Arc::new(LeSetPeriodicAdvertisingSyncTransferParametersCompleteData::parse(&bytes[..])?))}
OpCode::LeSetDefaultPeriodicAdvertisingSyncTransferParameters if LeSetDefaultPeriodicAdvertisingSyncTransferParametersCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetDefaultPeriodicAdvertisingSyncTransferParametersComplete(Arc::new(LeSetDefaultPeriodicAdvertisingSyncTransferParametersCompleteData::parse(&bytes[..])?))}
OpCode::LeModifySleepClockAccuracy if LeModifySleepClockAccuracyCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeModifySleepClockAccuracyComplete(Arc::new(LeModifySleepClockAccuracyCompleteData::parse(&bytes[..])?))}
OpCode::LeReadBufferSizeV2 if LeReadBufferSizeV2CompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeReadBufferSizeV2Complete(Arc::new(LeReadBufferSizeV2CompleteData::parse(&bytes[..])?))}
OpCode::LeReadIsoTxSync if LeReadIsoTxSyncCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeReadIsoTxSyncComplete(Arc::new(LeReadIsoTxSyncCompleteData::parse(&bytes[..])?))}
OpCode::LeSetCigParameters if LeSetCigParametersCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetCigParametersComplete(Arc::new(LeSetCigParametersCompleteData::parse(&bytes[..])?))}
OpCode::LeSetCigParametersTest if LeSetCigParametersTestCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetCigParametersTestComplete(Arc::new(LeSetCigParametersTestCompleteData::parse(&bytes[..])?))}
OpCode::LeRemoveCig if LeRemoveCigCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeRemoveCigComplete(Arc::new(LeRemoveCigCompleteData::parse(&bytes[..])?))}
OpCode::LeRejectCisRequest if LeRejectCisRequestCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeRejectCisRequestComplete(Arc::new(LeRejectCisRequestCompleteData::parse(&bytes[..])?))}
OpCode::LeBigTerminateSync if LeBigTerminateSyncCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeBigTerminateSyncComplete(Arc::new(LeBigTerminateSyncCompleteData::parse(&bytes[..])?))}
OpCode::LeSetupIsoDataPath if LeSetupIsoDataPathCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetupIsoDataPathComplete(Arc::new(LeSetupIsoDataPathCompleteData::parse(&bytes[..])?))}
OpCode::LeSetTransmitPowerReportingEnable if LeSetTransmitPowerReportingEnableCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetTransmitPowerReportingEnableComplete(Arc::new(LeSetTransmitPowerReportingEnableCompleteData::parse(&bytes[..])?))}
OpCode::LeRemoveIsoDataPath if LeRemoveIsoDataPathCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeRemoveIsoDataPathComplete(Arc::new(LeRemoveIsoDataPathCompleteData::parse(&bytes[..])?))}
OpCode::LeSetHostFeature if LeSetHostFeatureCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetHostFeatureComplete(Arc::new(LeSetHostFeatureCompleteData::parse(&bytes[..])?))}
OpCode::LeReadIsoLinkQuality if LeReadIsoLinkQualityCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeReadIsoLinkQualityComplete(Arc::new(LeReadIsoLinkQualityCompleteData::parse(&bytes[..])?))}
OpCode::LeEnhancedReadTransmitPowerLevel if LeEnhancedReadTransmitPowerLevelCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeEnhancedReadTransmitPowerLevelComplete(Arc::new(LeEnhancedReadTransmitPowerLevelCompleteData::parse(&bytes[..])?))}
OpCode::LeSetPathLossReportingParameters if LeSetPathLossReportingParametersCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetPathLossReportingParametersComplete(Arc::new(LeSetPathLossReportingParametersCompleteData::parse(&bytes[..])?))}
OpCode::LeSetPathLossReportingEnable if LeSetPathLossReportingEnableCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeSetPathLossReportingEnableComplete(Arc::new(LeSetPathLossReportingEnableCompleteData::parse(&bytes[..])?))}
OpCode::LeGetVendorCapabilities if LeGetVendorCapabilitiesCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeGetVendorCapabilitiesComplete(Arc::new(LeGetVendorCapabilitiesCompleteData::parse(&bytes[..])?))}
OpCode::LeMultiAdvt if LeMultiAdvtCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeMultiAdvtComplete(Arc::new(LeMultiAdvtCompleteData::parse(&bytes[..])?))}
OpCode::LeBatchScan if LeBatchScanCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeBatchScanComplete(Arc::new(LeBatchScanCompleteData::parse(&bytes[..])?))}
OpCode::LeAdvFilter if LeAdvFilterCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeAdvFilterComplete(Arc::new(LeAdvFilterCompleteData::parse(&bytes[..])?))}
OpCode::LeEnergyInfo if LeEnergyInfoCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeEnergyInfoComplete(Arc::new(LeEnergyInfoCompleteData::parse(&bytes[..])?))}
OpCode::LeExtendedScanParams if LeExtendedScanParamsCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::LeExtendedScanParamsComplete(Arc::new(LeExtendedScanParamsCompleteData::parse(&bytes[..])?))}
OpCode::ControllerDebugInfo if ControllerDebugInfoCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ControllerDebugInfoComplete(Arc::new(ControllerDebugInfoCompleteData::parse(&bytes[..])?))}
OpCode::ControllerA2dpOpcode if ControllerA2DPOpcodeCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ControllerA2DPOpcodeComplete(Arc::new(ControllerA2DPOpcodeCompleteData::parse(&bytes[..])?))}
OpCode::ControllerBqr if ControllerBqrCompleteData::conforms(&bytes[..]) => {CommandCompleteDataChild::ControllerBqrComplete(Arc::new(ControllerBqrCompleteData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "command_op_code".to_string(), value: v as u64}),};
Ok(Self {num_hci_command_packets, command_op_code, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let num_hci_command_packets = self.num_hci_command_packets;buffer[2..3].copy_from_slice(&num_hci_command_packets.to_le_bytes()[0..1]);let command_op_code = self.command_op_code.to_u16().unwrap();buffer[3..5].copy_from_slice(&command_op_code.to_le_bytes()[0..2]);match &self.child {CommandCompleteDataChild::NoCommandComplete(value) => value.write_to(buffer),CommandCompleteDataChild::InquiryCancelComplete(value) => value.write_to(buffer),CommandCompleteDataChild::PeriodicInquiryModeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ExitPeriodicInquiryModeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::CreateConnectionCancelComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LinkKeyRequestReplyComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LinkKeyRequestNegativeReplyComplete(value) => value.write_to(buffer),CommandCompleteDataChild::PinCodeRequestReplyComplete(value) => value.write_to(buffer),CommandCompleteDataChild::PinCodeRequestNegativeReplyComplete(value) => value.write_to(buffer),CommandCompleteDataChild::RemoteNameRequestCancelComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadLmpHandleComplete(value) => value.write_to(buffer),CommandCompleteDataChild::IoCapabilityRequestReplyComplete(value) => value.write_to(buffer),CommandCompleteDataChild::UserConfirmationRequestReplyComplete(value) => value.write_to(buffer),CommandCompleteDataChild::UserConfirmationRequestNegativeReplyComplete(value) => value.write_to(buffer),CommandCompleteDataChild::UserPasskeyRequestReplyComplete(value) => value.write_to(buffer),CommandCompleteDataChild::UserPasskeyRequestNegativeReplyComplete(value) => value.write_to(buffer),CommandCompleteDataChild::RemoteOobDataRequestReplyComplete(value) => value.write_to(buffer),CommandCompleteDataChild::RemoteOobDataRequestNegativeReplyComplete(value) => value.write_to(buffer),CommandCompleteDataChild::IoCapabilityRequestNegativeReplyComplete(value) => value.write_to(buffer),CommandCompleteDataChild::RemoteOobExtendedDataRequestReplyComplete(value) => value.write_to(buffer),CommandCompleteDataChild::RoleDiscoveryComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadLinkPolicySettingsComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteLinkPolicySettingsComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadDefaultLinkPolicySettingsComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteDefaultLinkPolicySettingsComplete(value) => value.write_to(buffer),CommandCompleteDataChild::SniffSubratingComplete(value) => value.write_to(buffer),CommandCompleteDataChild::SetEventMaskComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ResetComplete(value) => value.write_to(buffer),CommandCompleteDataChild::SetEventFilterComplete(value) => value.write_to(buffer),CommandCompleteDataChild::FlushComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadPinTypeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WritePinTypeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadStoredLinkKeyComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteStoredLinkKeyComplete(value) => value.write_to(buffer),CommandCompleteDataChild::DeleteStoredLinkKeyComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteLocalNameComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadLocalNameComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadConnectionAcceptTimeoutComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteConnectionAcceptTimeoutComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadPageTimeoutComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WritePageTimeoutComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadScanEnableComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteScanEnableComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadPageScanActivityComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WritePageScanActivityComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadInquiryScanActivityComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteInquiryScanActivityComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadAuthenticationEnableComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteAuthenticationEnableComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadClassOfDeviceComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteClassOfDeviceComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadVoiceSettingComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteVoiceSettingComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadAutomaticFlushTimeoutComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteAutomaticFlushTimeoutComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadNumBroadcastRetransmitsComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteNumBroadcastRetransmitsComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadHoldModeActivityComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteHoldModeActivityComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadTransmitPowerLevelComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadSynchronousFlowControlEnableComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteSynchronousFlowControlEnableComplete(value) => value.write_to(buffer),CommandCompleteDataChild::SetControllerToHostFlowControlComplete(value) => value.write_to(buffer),CommandCompleteDataChild::HostBufferSizeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::HostNumCompletedPacketsError(value) => value.write_to(buffer),CommandCompleteDataChild::ReadLinkSupervisionTimeoutComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteLinkSupervisionTimeoutComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadNumberOfSupportedIacComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadCurrentIacLapComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteCurrentIacLapComplete(value) => value.write_to(buffer),CommandCompleteDataChild::SetAfhHostChannelClassificationComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadInquiryScanTypeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteInquiryScanTypeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadInquiryModeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteInquiryModeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadPageScanTypeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WritePageScanTypeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadAfhChannelAssessmentModeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteAfhChannelAssessmentModeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadExtendedInquiryResponseComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteExtendedInquiryResponseComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadSimplePairingModeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteSimplePairingModeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadLocalOobDataComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadInquiryResponseTransmitPowerLevelComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteInquiryResponseTransmitPowerLevelComplete(value) => value.write_to(buffer),CommandCompleteDataChild::SendKeypressNotificationComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadLeHostSupportComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteLeHostSupportComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadSecureConnectionsHostSupportComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteSecureConnectionsHostSupportComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadLocalOobExtendedDataComplete(value) => value.write_to(buffer),CommandCompleteDataChild::SetEcosystemBaseIntervalComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ConfigureDataPathComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadLocalVersionInformationComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadLocalSupportedCommandsComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadLocalSupportedFeaturesComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadLocalExtendedFeaturesComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadBufferSizeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadBdAddrComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadDataBlockSizeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadLocalSupportedCodecsV1Complete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadLocalSupportedCodecsV2Complete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadLocalSupportedCodecCapabilitiesComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadLocalSupportedControllerDelayComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadFailedContactCounterComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ResetFailedContactCounterComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadLinkQualityComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadRssiComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadAfhChannelMapComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadClockComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadEncryptionKeySizeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ReadLoopbackModeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteLoopbackModeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::EnableDeviceUnderTestModeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteSimplePairingDebugModeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::WriteSecureConnectionsTestModeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetEventMaskComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeReadBufferSizeV1Complete(value) => value.write_to(buffer),CommandCompleteDataChild::LeReadLocalSupportedFeaturesComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetRandomAddressComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetAdvertisingParametersComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeReadAdvertisingPhysicalChannelTxPowerComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetAdvertisingDataComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetScanResponseDataComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetAdvertisingEnableComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetScanParametersComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetScanEnableComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeCreateConnectionCancelComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeReadConnectListSizeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeClearConnectListComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeAddDeviceToConnectListComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeRemoveDeviceFromConnectListComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetHostChannelClassificationComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeReadChannelMapComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeEncryptComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeRandComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeLongTermKeyRequestReplyComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeLongTermKeyRequestNegativeReplyComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeReadSupportedStatesComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeReceiverTestComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeTransmitterTestComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeTestEndComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeRemoteConnectionParameterRequestReplyComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeRemoteConnectionParameterRequestNegativeReplyComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetDataLengthComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeReadSuggestedDefaultDataLengthComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeWriteSuggestedDefaultDataLengthComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeAddDeviceToResolvingListComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeRemoveDeviceFromResolvingListComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeClearResolvingListComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeReadResolvingListSizeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeReadPeerResolvableAddressComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeReadLocalResolvableAddressComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetAddressResolutionEnableComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetResolvablePrivateAddressTimeoutComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeReadMaximumDataLengthComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeReadPhyComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetDefaultPhyComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeEnhancedReceiverTestComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeEnhancedTransmitterTestComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetExtendedAdvertisingRandomAddressComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetExtendedAdvertisingParametersComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetExtendedAdvertisingDataComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetExtendedAdvertisingScanResponseComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetExtendedAdvertisingEnableComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeReadMaximumAdvertisingDataLengthComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeReadNumberOfSupportedAdvertisingSetsComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeRemoveAdvertisingSetComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeClearAdvertisingSetsComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetPeriodicAdvertisingParamComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetPeriodicAdvertisingDataComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetPeriodicAdvertisingEnableComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetExtendedScanParametersComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetExtendedScanEnableComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LePeriodicAdvertisingCreateSyncCancelComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LePeriodicAdvertisingTerminateSyncComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeAddDeviceToPeriodicAdvertisingListComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeRemoveDeviceFromPeriodicAdvertisingListComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeClearPeriodicAdvertisingListComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeReadPeriodicAdvertiserListSizeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeReadTransmitPowerComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeReadRfPathCompensationPowerComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeWriteRfPathCompensationPowerComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetPrivacyModeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetPeriodicAdvertisingReceiveEnableComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LePeriodicAdvertisingSyncTransferComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LePeriodicAdvertisingSetInfoTransferComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetPeriodicAdvertisingSyncTransferParametersComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetDefaultPeriodicAdvertisingSyncTransferParametersComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeModifySleepClockAccuracyComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeReadBufferSizeV2Complete(value) => value.write_to(buffer),CommandCompleteDataChild::LeReadIsoTxSyncComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetCigParametersComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetCigParametersTestComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeRemoveCigComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeRejectCisRequestComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeBigTerminateSyncComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetupIsoDataPathComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeRemoveIsoDataPathComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetHostFeatureComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeReadIsoLinkQualityComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeEnhancedReadTransmitPowerLevelComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetPathLossReportingParametersComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetPathLossReportingEnableComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeSetTransmitPowerReportingEnableComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeGetVendorCapabilitiesComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeMultiAdvtComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeBatchScanComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeAdvFilterComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeEnergyInfoComplete(value) => value.write_to(buffer),CommandCompleteDataChild::LeExtendedScanParamsComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ControllerDebugInfoComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ControllerA2DPOpcodeComplete(value) => value.write_to(buffer),CommandCompleteDataChild::ControllerBqrComplete(value) => value.write_to(buffer),CommandCompleteDataChild::Payload(p) => buffer[5..].copy_from_slice(&p[..]),CommandCompleteDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for CommandCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl CommandCompletePacket { pub fn specialize(&self) -> CommandCompleteChild { match &self.command_complete.child {CommandCompleteDataChild::NoCommandComplete(_) => CommandCompleteChild::NoCommandComplete(NoCommandCompletePacket::new(self.event.clone())),CommandCompleteDataChild::InquiryCancelComplete(_) => CommandCompleteChild::InquiryCancelComplete(InquiryCancelCompletePacket::new(self.event.clone())),CommandCompleteDataChild::PeriodicInquiryModeComplete(_) => CommandCompleteChild::PeriodicInquiryModeComplete(PeriodicInquiryModeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ExitPeriodicInquiryModeComplete(_) => CommandCompleteChild::ExitPeriodicInquiryModeComplete(ExitPeriodicInquiryModeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::CreateConnectionCancelComplete(_) => CommandCompleteChild::CreateConnectionCancelComplete(CreateConnectionCancelCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LinkKeyRequestReplyComplete(_) => CommandCompleteChild::LinkKeyRequestReplyComplete(LinkKeyRequestReplyCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LinkKeyRequestNegativeReplyComplete(_) => CommandCompleteChild::LinkKeyRequestNegativeReplyComplete(LinkKeyRequestNegativeReplyCompletePacket::new(self.event.clone())),CommandCompleteDataChild::PinCodeRequestReplyComplete(_) => CommandCompleteChild::PinCodeRequestReplyComplete(PinCodeRequestReplyCompletePacket::new(self.event.clone())),CommandCompleteDataChild::PinCodeRequestNegativeReplyComplete(_) => CommandCompleteChild::PinCodeRequestNegativeReplyComplete(PinCodeRequestNegativeReplyCompletePacket::new(self.event.clone())),CommandCompleteDataChild::RemoteNameRequestCancelComplete(_) => CommandCompleteChild::RemoteNameRequestCancelComplete(RemoteNameRequestCancelCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadLmpHandleComplete(_) => CommandCompleteChild::ReadLmpHandleComplete(ReadLmpHandleCompletePacket::new(self.event.clone())),CommandCompleteDataChild::IoCapabilityRequestReplyComplete(_) => CommandCompleteChild::IoCapabilityRequestReplyComplete(IoCapabilityRequestReplyCompletePacket::new(self.event.clone())),CommandCompleteDataChild::UserConfirmationRequestReplyComplete(_) => CommandCompleteChild::UserConfirmationRequestReplyComplete(UserConfirmationRequestReplyCompletePacket::new(self.event.clone())),CommandCompleteDataChild::UserConfirmationRequestNegativeReplyComplete(_) => CommandCompleteChild::UserConfirmationRequestNegativeReplyComplete(UserConfirmationRequestNegativeReplyCompletePacket::new(self.event.clone())),CommandCompleteDataChild::UserPasskeyRequestReplyComplete(_) => CommandCompleteChild::UserPasskeyRequestReplyComplete(UserPasskeyRequestReplyCompletePacket::new(self.event.clone())),CommandCompleteDataChild::UserPasskeyRequestNegativeReplyComplete(_) => CommandCompleteChild::UserPasskeyRequestNegativeReplyComplete(UserPasskeyRequestNegativeReplyCompletePacket::new(self.event.clone())),CommandCompleteDataChild::RemoteOobDataRequestReplyComplete(_) => CommandCompleteChild::RemoteOobDataRequestReplyComplete(RemoteOobDataRequestReplyCompletePacket::new(self.event.clone())),CommandCompleteDataChild::RemoteOobDataRequestNegativeReplyComplete(_) => CommandCompleteChild::RemoteOobDataRequestNegativeReplyComplete(RemoteOobDataRequestNegativeReplyCompletePacket::new(self.event.clone())),CommandCompleteDataChild::IoCapabilityRequestNegativeReplyComplete(_) => CommandCompleteChild::IoCapabilityRequestNegativeReplyComplete(IoCapabilityRequestNegativeReplyCompletePacket::new(self.event.clone())),CommandCompleteDataChild::RemoteOobExtendedDataRequestReplyComplete(_) => CommandCompleteChild::RemoteOobExtendedDataRequestReplyComplete(RemoteOobExtendedDataRequestReplyCompletePacket::new(self.event.clone())),CommandCompleteDataChild::RoleDiscoveryComplete(_) => CommandCompleteChild::RoleDiscoveryComplete(RoleDiscoveryCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadLinkPolicySettingsComplete(_) => CommandCompleteChild::ReadLinkPolicySettingsComplete(ReadLinkPolicySettingsCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteLinkPolicySettingsComplete(_) => CommandCompleteChild::WriteLinkPolicySettingsComplete(WriteLinkPolicySettingsCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadDefaultLinkPolicySettingsComplete(_) => CommandCompleteChild::ReadDefaultLinkPolicySettingsComplete(ReadDefaultLinkPolicySettingsCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteDefaultLinkPolicySettingsComplete(_) => CommandCompleteChild::WriteDefaultLinkPolicySettingsComplete(WriteDefaultLinkPolicySettingsCompletePacket::new(self.event.clone())),CommandCompleteDataChild::SniffSubratingComplete(_) => CommandCompleteChild::SniffSubratingComplete(SniffSubratingCompletePacket::new(self.event.clone())),CommandCompleteDataChild::SetEventMaskComplete(_) => CommandCompleteChild::SetEventMaskComplete(SetEventMaskCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ResetComplete(_) => CommandCompleteChild::ResetComplete(ResetCompletePacket::new(self.event.clone())),CommandCompleteDataChild::SetEventFilterComplete(_) => CommandCompleteChild::SetEventFilterComplete(SetEventFilterCompletePacket::new(self.event.clone())),CommandCompleteDataChild::FlushComplete(_) => CommandCompleteChild::FlushComplete(FlushCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadPinTypeComplete(_) => CommandCompleteChild::ReadPinTypeComplete(ReadPinTypeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WritePinTypeComplete(_) => CommandCompleteChild::WritePinTypeComplete(WritePinTypeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadStoredLinkKeyComplete(_) => CommandCompleteChild::ReadStoredLinkKeyComplete(ReadStoredLinkKeyCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteStoredLinkKeyComplete(_) => CommandCompleteChild::WriteStoredLinkKeyComplete(WriteStoredLinkKeyCompletePacket::new(self.event.clone())),CommandCompleteDataChild::DeleteStoredLinkKeyComplete(_) => CommandCompleteChild::DeleteStoredLinkKeyComplete(DeleteStoredLinkKeyCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteLocalNameComplete(_) => CommandCompleteChild::WriteLocalNameComplete(WriteLocalNameCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadLocalNameComplete(_) => CommandCompleteChild::ReadLocalNameComplete(ReadLocalNameCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadConnectionAcceptTimeoutComplete(_) => CommandCompleteChild::ReadConnectionAcceptTimeoutComplete(ReadConnectionAcceptTimeoutCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteConnectionAcceptTimeoutComplete(_) => CommandCompleteChild::WriteConnectionAcceptTimeoutComplete(WriteConnectionAcceptTimeoutCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadPageTimeoutComplete(_) => CommandCompleteChild::ReadPageTimeoutComplete(ReadPageTimeoutCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WritePageTimeoutComplete(_) => CommandCompleteChild::WritePageTimeoutComplete(WritePageTimeoutCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadScanEnableComplete(_) => CommandCompleteChild::ReadScanEnableComplete(ReadScanEnableCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteScanEnableComplete(_) => CommandCompleteChild::WriteScanEnableComplete(WriteScanEnableCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadPageScanActivityComplete(_) => CommandCompleteChild::ReadPageScanActivityComplete(ReadPageScanActivityCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WritePageScanActivityComplete(_) => CommandCompleteChild::WritePageScanActivityComplete(WritePageScanActivityCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadInquiryScanActivityComplete(_) => CommandCompleteChild::ReadInquiryScanActivityComplete(ReadInquiryScanActivityCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteInquiryScanActivityComplete(_) => CommandCompleteChild::WriteInquiryScanActivityComplete(WriteInquiryScanActivityCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadAuthenticationEnableComplete(_) => CommandCompleteChild::ReadAuthenticationEnableComplete(ReadAuthenticationEnableCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteAuthenticationEnableComplete(_) => CommandCompleteChild::WriteAuthenticationEnableComplete(WriteAuthenticationEnableCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadClassOfDeviceComplete(_) => CommandCompleteChild::ReadClassOfDeviceComplete(ReadClassOfDeviceCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteClassOfDeviceComplete(_) => CommandCompleteChild::WriteClassOfDeviceComplete(WriteClassOfDeviceCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadVoiceSettingComplete(_) => CommandCompleteChild::ReadVoiceSettingComplete(ReadVoiceSettingCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteVoiceSettingComplete(_) => CommandCompleteChild::WriteVoiceSettingComplete(WriteVoiceSettingCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadAutomaticFlushTimeoutComplete(_) => CommandCompleteChild::ReadAutomaticFlushTimeoutComplete(ReadAutomaticFlushTimeoutCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteAutomaticFlushTimeoutComplete(_) => CommandCompleteChild::WriteAutomaticFlushTimeoutComplete(WriteAutomaticFlushTimeoutCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadNumBroadcastRetransmitsComplete(_) => CommandCompleteChild::ReadNumBroadcastRetransmitsComplete(ReadNumBroadcastRetransmitsCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteNumBroadcastRetransmitsComplete(_) => CommandCompleteChild::WriteNumBroadcastRetransmitsComplete(WriteNumBroadcastRetransmitsCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadHoldModeActivityComplete(_) => CommandCompleteChild::ReadHoldModeActivityComplete(ReadHoldModeActivityCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteHoldModeActivityComplete(_) => CommandCompleteChild::WriteHoldModeActivityComplete(WriteHoldModeActivityCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadTransmitPowerLevelComplete(_) => CommandCompleteChild::ReadTransmitPowerLevelComplete(ReadTransmitPowerLevelCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadSynchronousFlowControlEnableComplete(_) => CommandCompleteChild::ReadSynchronousFlowControlEnableComplete(ReadSynchronousFlowControlEnableCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteSynchronousFlowControlEnableComplete(_) => CommandCompleteChild::WriteSynchronousFlowControlEnableComplete(WriteSynchronousFlowControlEnableCompletePacket::new(self.event.clone())),CommandCompleteDataChild::SetControllerToHostFlowControlComplete(_) => CommandCompleteChild::SetControllerToHostFlowControlComplete(SetControllerToHostFlowControlCompletePacket::new(self.event.clone())),CommandCompleteDataChild::HostBufferSizeComplete(_) => CommandCompleteChild::HostBufferSizeComplete(HostBufferSizeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::HostNumCompletedPacketsError(_) => CommandCompleteChild::HostNumCompletedPacketsError(HostNumCompletedPacketsErrorPacket::new(self.event.clone())),CommandCompleteDataChild::ReadLinkSupervisionTimeoutComplete(_) => CommandCompleteChild::ReadLinkSupervisionTimeoutComplete(ReadLinkSupervisionTimeoutCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteLinkSupervisionTimeoutComplete(_) => CommandCompleteChild::WriteLinkSupervisionTimeoutComplete(WriteLinkSupervisionTimeoutCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadNumberOfSupportedIacComplete(_) => CommandCompleteChild::ReadNumberOfSupportedIacComplete(ReadNumberOfSupportedIacCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadCurrentIacLapComplete(_) => CommandCompleteChild::ReadCurrentIacLapComplete(ReadCurrentIacLapCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteCurrentIacLapComplete(_) => CommandCompleteChild::WriteCurrentIacLapComplete(WriteCurrentIacLapCompletePacket::new(self.event.clone())),CommandCompleteDataChild::SetAfhHostChannelClassificationComplete(_) => CommandCompleteChild::SetAfhHostChannelClassificationComplete(SetAfhHostChannelClassificationCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadInquiryScanTypeComplete(_) => CommandCompleteChild::ReadInquiryScanTypeComplete(ReadInquiryScanTypeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteInquiryScanTypeComplete(_) => CommandCompleteChild::WriteInquiryScanTypeComplete(WriteInquiryScanTypeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadInquiryModeComplete(_) => CommandCompleteChild::ReadInquiryModeComplete(ReadInquiryModeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteInquiryModeComplete(_) => CommandCompleteChild::WriteInquiryModeComplete(WriteInquiryModeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadPageScanTypeComplete(_) => CommandCompleteChild::ReadPageScanTypeComplete(ReadPageScanTypeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WritePageScanTypeComplete(_) => CommandCompleteChild::WritePageScanTypeComplete(WritePageScanTypeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadAfhChannelAssessmentModeComplete(_) => CommandCompleteChild::ReadAfhChannelAssessmentModeComplete(ReadAfhChannelAssessmentModeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteAfhChannelAssessmentModeComplete(_) => CommandCompleteChild::WriteAfhChannelAssessmentModeComplete(WriteAfhChannelAssessmentModeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadExtendedInquiryResponseComplete(_) => CommandCompleteChild::ReadExtendedInquiryResponseComplete(ReadExtendedInquiryResponseCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteExtendedInquiryResponseComplete(_) => CommandCompleteChild::WriteExtendedInquiryResponseComplete(WriteExtendedInquiryResponseCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadSimplePairingModeComplete(_) => CommandCompleteChild::ReadSimplePairingModeComplete(ReadSimplePairingModeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteSimplePairingModeComplete(_) => CommandCompleteChild::WriteSimplePairingModeComplete(WriteSimplePairingModeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadLocalOobDataComplete(_) => CommandCompleteChild::ReadLocalOobDataComplete(ReadLocalOobDataCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadInquiryResponseTransmitPowerLevelComplete(_) => CommandCompleteChild::ReadInquiryResponseTransmitPowerLevelComplete(ReadInquiryResponseTransmitPowerLevelCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteInquiryResponseTransmitPowerLevelComplete(_) => CommandCompleteChild::WriteInquiryResponseTransmitPowerLevelComplete(WriteInquiryResponseTransmitPowerLevelCompletePacket::new(self.event.clone())),CommandCompleteDataChild::SendKeypressNotificationComplete(_) => CommandCompleteChild::SendKeypressNotificationComplete(SendKeypressNotificationCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadLeHostSupportComplete(_) => CommandCompleteChild::ReadLeHostSupportComplete(ReadLeHostSupportCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteLeHostSupportComplete(_) => CommandCompleteChild::WriteLeHostSupportComplete(WriteLeHostSupportCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadSecureConnectionsHostSupportComplete(_) => CommandCompleteChild::ReadSecureConnectionsHostSupportComplete(ReadSecureConnectionsHostSupportCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteSecureConnectionsHostSupportComplete(_) => CommandCompleteChild::WriteSecureConnectionsHostSupportComplete(WriteSecureConnectionsHostSupportCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadLocalOobExtendedDataComplete(_) => CommandCompleteChild::ReadLocalOobExtendedDataComplete(ReadLocalOobExtendedDataCompletePacket::new(self.event.clone())),CommandCompleteDataChild::SetEcosystemBaseIntervalComplete(_) => CommandCompleteChild::SetEcosystemBaseIntervalComplete(SetEcosystemBaseIntervalCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ConfigureDataPathComplete(_) => CommandCompleteChild::ConfigureDataPathComplete(ConfigureDataPathCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadLocalVersionInformationComplete(_) => CommandCompleteChild::ReadLocalVersionInformationComplete(ReadLocalVersionInformationCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadLocalSupportedCommandsComplete(_) => CommandCompleteChild::ReadLocalSupportedCommandsComplete(ReadLocalSupportedCommandsCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadLocalSupportedFeaturesComplete(_) => CommandCompleteChild::ReadLocalSupportedFeaturesComplete(ReadLocalSupportedFeaturesCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadLocalExtendedFeaturesComplete(_) => CommandCompleteChild::ReadLocalExtendedFeaturesComplete(ReadLocalExtendedFeaturesCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadBufferSizeComplete(_) => CommandCompleteChild::ReadBufferSizeComplete(ReadBufferSizeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadBdAddrComplete(_) => CommandCompleteChild::ReadBdAddrComplete(ReadBdAddrCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadDataBlockSizeComplete(_) => CommandCompleteChild::ReadDataBlockSizeComplete(ReadDataBlockSizeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadLocalSupportedCodecsV1Complete(_) => CommandCompleteChild::ReadLocalSupportedCodecsV1Complete(ReadLocalSupportedCodecsV1CompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadLocalSupportedCodecsV2Complete(_) => CommandCompleteChild::ReadLocalSupportedCodecsV2Complete(ReadLocalSupportedCodecsV2CompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadLocalSupportedCodecCapabilitiesComplete(_) => CommandCompleteChild::ReadLocalSupportedCodecCapabilitiesComplete(ReadLocalSupportedCodecCapabilitiesCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadLocalSupportedControllerDelayComplete(_) => CommandCompleteChild::ReadLocalSupportedControllerDelayComplete(ReadLocalSupportedControllerDelayCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadFailedContactCounterComplete(_) => CommandCompleteChild::ReadFailedContactCounterComplete(ReadFailedContactCounterCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ResetFailedContactCounterComplete(_) => CommandCompleteChild::ResetFailedContactCounterComplete(ResetFailedContactCounterCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadLinkQualityComplete(_) => CommandCompleteChild::ReadLinkQualityComplete(ReadLinkQualityCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadRssiComplete(_) => CommandCompleteChild::ReadRssiComplete(ReadRssiCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadAfhChannelMapComplete(_) => CommandCompleteChild::ReadAfhChannelMapComplete(ReadAfhChannelMapCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadClockComplete(_) => CommandCompleteChild::ReadClockComplete(ReadClockCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadEncryptionKeySizeComplete(_) => CommandCompleteChild::ReadEncryptionKeySizeComplete(ReadEncryptionKeySizeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ReadLoopbackModeComplete(_) => CommandCompleteChild::ReadLoopbackModeComplete(ReadLoopbackModeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteLoopbackModeComplete(_) => CommandCompleteChild::WriteLoopbackModeComplete(WriteLoopbackModeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::EnableDeviceUnderTestModeComplete(_) => CommandCompleteChild::EnableDeviceUnderTestModeComplete(EnableDeviceUnderTestModeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteSimplePairingDebugModeComplete(_) => CommandCompleteChild::WriteSimplePairingDebugModeComplete(WriteSimplePairingDebugModeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::WriteSecureConnectionsTestModeComplete(_) => CommandCompleteChild::WriteSecureConnectionsTestModeComplete(WriteSecureConnectionsTestModeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetEventMaskComplete(_) => CommandCompleteChild::LeSetEventMaskComplete(LeSetEventMaskCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeReadBufferSizeV1Complete(_) => CommandCompleteChild::LeReadBufferSizeV1Complete(LeReadBufferSizeV1CompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeReadLocalSupportedFeaturesComplete(_) => CommandCompleteChild::LeReadLocalSupportedFeaturesComplete(LeReadLocalSupportedFeaturesCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetRandomAddressComplete(_) => CommandCompleteChild::LeSetRandomAddressComplete(LeSetRandomAddressCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetAdvertisingParametersComplete(_) => CommandCompleteChild::LeSetAdvertisingParametersComplete(LeSetAdvertisingParametersCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeReadAdvertisingPhysicalChannelTxPowerComplete(_) => CommandCompleteChild::LeReadAdvertisingPhysicalChannelTxPowerComplete(LeReadAdvertisingPhysicalChannelTxPowerCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetAdvertisingDataComplete(_) => CommandCompleteChild::LeSetAdvertisingDataComplete(LeSetAdvertisingDataCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetScanResponseDataComplete(_) => CommandCompleteChild::LeSetScanResponseDataComplete(LeSetScanResponseDataCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetAdvertisingEnableComplete(_) => CommandCompleteChild::LeSetAdvertisingEnableComplete(LeSetAdvertisingEnableCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetScanParametersComplete(_) => CommandCompleteChild::LeSetScanParametersComplete(LeSetScanParametersCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetScanEnableComplete(_) => CommandCompleteChild::LeSetScanEnableComplete(LeSetScanEnableCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeCreateConnectionCancelComplete(_) => CommandCompleteChild::LeCreateConnectionCancelComplete(LeCreateConnectionCancelCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeReadConnectListSizeComplete(_) => CommandCompleteChild::LeReadConnectListSizeComplete(LeReadConnectListSizeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeClearConnectListComplete(_) => CommandCompleteChild::LeClearConnectListComplete(LeClearConnectListCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeAddDeviceToConnectListComplete(_) => CommandCompleteChild::LeAddDeviceToConnectListComplete(LeAddDeviceToConnectListCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeRemoveDeviceFromConnectListComplete(_) => CommandCompleteChild::LeRemoveDeviceFromConnectListComplete(LeRemoveDeviceFromConnectListCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetHostChannelClassificationComplete(_) => CommandCompleteChild::LeSetHostChannelClassificationComplete(LeSetHostChannelClassificationCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeReadChannelMapComplete(_) => CommandCompleteChild::LeReadChannelMapComplete(LeReadChannelMapCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeEncryptComplete(_) => CommandCompleteChild::LeEncryptComplete(LeEncryptCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeRandComplete(_) => CommandCompleteChild::LeRandComplete(LeRandCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeLongTermKeyRequestReplyComplete(_) => CommandCompleteChild::LeLongTermKeyRequestReplyComplete(LeLongTermKeyRequestReplyCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeLongTermKeyRequestNegativeReplyComplete(_) => CommandCompleteChild::LeLongTermKeyRequestNegativeReplyComplete(LeLongTermKeyRequestNegativeReplyCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeReadSupportedStatesComplete(_) => CommandCompleteChild::LeReadSupportedStatesComplete(LeReadSupportedStatesCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeReceiverTestComplete(_) => CommandCompleteChild::LeReceiverTestComplete(LeReceiverTestCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeTransmitterTestComplete(_) => CommandCompleteChild::LeTransmitterTestComplete(LeTransmitterTestCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeTestEndComplete(_) => CommandCompleteChild::LeTestEndComplete(LeTestEndCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeRemoteConnectionParameterRequestReplyComplete(_) => CommandCompleteChild::LeRemoteConnectionParameterRequestReplyComplete(LeRemoteConnectionParameterRequestReplyCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeRemoteConnectionParameterRequestNegativeReplyComplete(_) => CommandCompleteChild::LeRemoteConnectionParameterRequestNegativeReplyComplete(LeRemoteConnectionParameterRequestNegativeReplyCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetDataLengthComplete(_) => CommandCompleteChild::LeSetDataLengthComplete(LeSetDataLengthCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeReadSuggestedDefaultDataLengthComplete(_) => CommandCompleteChild::LeReadSuggestedDefaultDataLengthComplete(LeReadSuggestedDefaultDataLengthCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeWriteSuggestedDefaultDataLengthComplete(_) => CommandCompleteChild::LeWriteSuggestedDefaultDataLengthComplete(LeWriteSuggestedDefaultDataLengthCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeAddDeviceToResolvingListComplete(_) => CommandCompleteChild::LeAddDeviceToResolvingListComplete(LeAddDeviceToResolvingListCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeRemoveDeviceFromResolvingListComplete(_) => CommandCompleteChild::LeRemoveDeviceFromResolvingListComplete(LeRemoveDeviceFromResolvingListCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeClearResolvingListComplete(_) => CommandCompleteChild::LeClearResolvingListComplete(LeClearResolvingListCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeReadResolvingListSizeComplete(_) => CommandCompleteChild::LeReadResolvingListSizeComplete(LeReadResolvingListSizeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeReadPeerResolvableAddressComplete(_) => CommandCompleteChild::LeReadPeerResolvableAddressComplete(LeReadPeerResolvableAddressCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeReadLocalResolvableAddressComplete(_) => CommandCompleteChild::LeReadLocalResolvableAddressComplete(LeReadLocalResolvableAddressCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetAddressResolutionEnableComplete(_) => CommandCompleteChild::LeSetAddressResolutionEnableComplete(LeSetAddressResolutionEnableCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetResolvablePrivateAddressTimeoutComplete(_) => CommandCompleteChild::LeSetResolvablePrivateAddressTimeoutComplete(LeSetResolvablePrivateAddressTimeoutCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeReadMaximumDataLengthComplete(_) => CommandCompleteChild::LeReadMaximumDataLengthComplete(LeReadMaximumDataLengthCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeReadPhyComplete(_) => CommandCompleteChild::LeReadPhyComplete(LeReadPhyCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetDefaultPhyComplete(_) => CommandCompleteChild::LeSetDefaultPhyComplete(LeSetDefaultPhyCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeEnhancedReceiverTestComplete(_) => CommandCompleteChild::LeEnhancedReceiverTestComplete(LeEnhancedReceiverTestCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeEnhancedTransmitterTestComplete(_) => CommandCompleteChild::LeEnhancedTransmitterTestComplete(LeEnhancedTransmitterTestCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetExtendedAdvertisingRandomAddressComplete(_) => CommandCompleteChild::LeSetExtendedAdvertisingRandomAddressComplete(LeSetExtendedAdvertisingRandomAddressCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetExtendedAdvertisingParametersComplete(_) => CommandCompleteChild::LeSetExtendedAdvertisingParametersComplete(LeSetExtendedAdvertisingParametersCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetExtendedAdvertisingDataComplete(_) => CommandCompleteChild::LeSetExtendedAdvertisingDataComplete(LeSetExtendedAdvertisingDataCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetExtendedAdvertisingScanResponseComplete(_) => CommandCompleteChild::LeSetExtendedAdvertisingScanResponseComplete(LeSetExtendedAdvertisingScanResponseCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetExtendedAdvertisingEnableComplete(_) => CommandCompleteChild::LeSetExtendedAdvertisingEnableComplete(LeSetExtendedAdvertisingEnableCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeReadMaximumAdvertisingDataLengthComplete(_) => CommandCompleteChild::LeReadMaximumAdvertisingDataLengthComplete(LeReadMaximumAdvertisingDataLengthCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeReadNumberOfSupportedAdvertisingSetsComplete(_) => CommandCompleteChild::LeReadNumberOfSupportedAdvertisingSetsComplete(LeReadNumberOfSupportedAdvertisingSetsCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeRemoveAdvertisingSetComplete(_) => CommandCompleteChild::LeRemoveAdvertisingSetComplete(LeRemoveAdvertisingSetCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeClearAdvertisingSetsComplete(_) => CommandCompleteChild::LeClearAdvertisingSetsComplete(LeClearAdvertisingSetsCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetPeriodicAdvertisingParamComplete(_) => CommandCompleteChild::LeSetPeriodicAdvertisingParamComplete(LeSetPeriodicAdvertisingParamCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetPeriodicAdvertisingDataComplete(_) => CommandCompleteChild::LeSetPeriodicAdvertisingDataComplete(LeSetPeriodicAdvertisingDataCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetPeriodicAdvertisingEnableComplete(_) => CommandCompleteChild::LeSetPeriodicAdvertisingEnableComplete(LeSetPeriodicAdvertisingEnableCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetExtendedScanParametersComplete(_) => CommandCompleteChild::LeSetExtendedScanParametersComplete(LeSetExtendedScanParametersCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetExtendedScanEnableComplete(_) => CommandCompleteChild::LeSetExtendedScanEnableComplete(LeSetExtendedScanEnableCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LePeriodicAdvertisingCreateSyncCancelComplete(_) => CommandCompleteChild::LePeriodicAdvertisingCreateSyncCancelComplete(LePeriodicAdvertisingCreateSyncCancelCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LePeriodicAdvertisingTerminateSyncComplete(_) => CommandCompleteChild::LePeriodicAdvertisingTerminateSyncComplete(LePeriodicAdvertisingTerminateSyncCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeAddDeviceToPeriodicAdvertisingListComplete(_) => CommandCompleteChild::LeAddDeviceToPeriodicAdvertisingListComplete(LeAddDeviceToPeriodicAdvertisingListCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeRemoveDeviceFromPeriodicAdvertisingListComplete(_) => CommandCompleteChild::LeRemoveDeviceFromPeriodicAdvertisingListComplete(LeRemoveDeviceFromPeriodicAdvertisingListCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeClearPeriodicAdvertisingListComplete(_) => CommandCompleteChild::LeClearPeriodicAdvertisingListComplete(LeClearPeriodicAdvertisingListCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeReadPeriodicAdvertiserListSizeComplete(_) => CommandCompleteChild::LeReadPeriodicAdvertiserListSizeComplete(LeReadPeriodicAdvertiserListSizeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeReadTransmitPowerComplete(_) => CommandCompleteChild::LeReadTransmitPowerComplete(LeReadTransmitPowerCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeReadRfPathCompensationPowerComplete(_) => CommandCompleteChild::LeReadRfPathCompensationPowerComplete(LeReadRfPathCompensationPowerCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeWriteRfPathCompensationPowerComplete(_) => CommandCompleteChild::LeWriteRfPathCompensationPowerComplete(LeWriteRfPathCompensationPowerCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetPrivacyModeComplete(_) => CommandCompleteChild::LeSetPrivacyModeComplete(LeSetPrivacyModeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetPeriodicAdvertisingReceiveEnableComplete(_) => CommandCompleteChild::LeSetPeriodicAdvertisingReceiveEnableComplete(LeSetPeriodicAdvertisingReceiveEnableCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LePeriodicAdvertisingSyncTransferComplete(_) => CommandCompleteChild::LePeriodicAdvertisingSyncTransferComplete(LePeriodicAdvertisingSyncTransferCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LePeriodicAdvertisingSetInfoTransferComplete(_) => CommandCompleteChild::LePeriodicAdvertisingSetInfoTransferComplete(LePeriodicAdvertisingSetInfoTransferCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetPeriodicAdvertisingSyncTransferParametersComplete(_) => CommandCompleteChild::LeSetPeriodicAdvertisingSyncTransferParametersComplete(LeSetPeriodicAdvertisingSyncTransferParametersCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetDefaultPeriodicAdvertisingSyncTransferParametersComplete(_) => CommandCompleteChild::LeSetDefaultPeriodicAdvertisingSyncTransferParametersComplete(LeSetDefaultPeriodicAdvertisingSyncTransferParametersCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeModifySleepClockAccuracyComplete(_) => CommandCompleteChild::LeModifySleepClockAccuracyComplete(LeModifySleepClockAccuracyCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeReadBufferSizeV2Complete(_) => CommandCompleteChild::LeReadBufferSizeV2Complete(LeReadBufferSizeV2CompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeReadIsoTxSyncComplete(_) => CommandCompleteChild::LeReadIsoTxSyncComplete(LeReadIsoTxSyncCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetCigParametersComplete(_) => CommandCompleteChild::LeSetCigParametersComplete(LeSetCigParametersCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetCigParametersTestComplete(_) => CommandCompleteChild::LeSetCigParametersTestComplete(LeSetCigParametersTestCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeRemoveCigComplete(_) => CommandCompleteChild::LeRemoveCigComplete(LeRemoveCigCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeRejectCisRequestComplete(_) => CommandCompleteChild::LeRejectCisRequestComplete(LeRejectCisRequestCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeBigTerminateSyncComplete(_) => CommandCompleteChild::LeBigTerminateSyncComplete(LeBigTerminateSyncCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetupIsoDataPathComplete(_) => CommandCompleteChild::LeSetupIsoDataPathComplete(LeSetupIsoDataPathCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeRemoveIsoDataPathComplete(_) => CommandCompleteChild::LeRemoveIsoDataPathComplete(LeRemoveIsoDataPathCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetHostFeatureComplete(_) => CommandCompleteChild::LeSetHostFeatureComplete(LeSetHostFeatureCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeReadIsoLinkQualityComplete(_) => CommandCompleteChild::LeReadIsoLinkQualityComplete(LeReadIsoLinkQualityCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeEnhancedReadTransmitPowerLevelComplete(_) => CommandCompleteChild::LeEnhancedReadTransmitPowerLevelComplete(LeEnhancedReadTransmitPowerLevelCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetPathLossReportingParametersComplete(_) => CommandCompleteChild::LeSetPathLossReportingParametersComplete(LeSetPathLossReportingParametersCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetPathLossReportingEnableComplete(_) => CommandCompleteChild::LeSetPathLossReportingEnableComplete(LeSetPathLossReportingEnableCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeSetTransmitPowerReportingEnableComplete(_) => CommandCompleteChild::LeSetTransmitPowerReportingEnableComplete(LeSetTransmitPowerReportingEnableCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeGetVendorCapabilitiesComplete(_) => CommandCompleteChild::LeGetVendorCapabilitiesComplete(LeGetVendorCapabilitiesCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeMultiAdvtComplete(_) => CommandCompleteChild::LeMultiAdvtComplete(LeMultiAdvtCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeBatchScanComplete(_) => CommandCompleteChild::LeBatchScanComplete(LeBatchScanCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeAdvFilterComplete(_) => CommandCompleteChild::LeAdvFilterComplete(LeAdvFilterCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeEnergyInfoComplete(_) => CommandCompleteChild::LeEnergyInfoComplete(LeEnergyInfoCompletePacket::new(self.event.clone())),CommandCompleteDataChild::LeExtendedScanParamsComplete(_) => CommandCompleteChild::LeExtendedScanParamsComplete(LeExtendedScanParamsCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ControllerDebugInfoComplete(_) => CommandCompleteChild::ControllerDebugInfoComplete(ControllerDebugInfoCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ControllerA2DPOpcodeComplete(_) => CommandCompleteChild::ControllerA2DPOpcodeComplete(ControllerA2DPOpcodeCompletePacket::new(self.event.clone())),CommandCompleteDataChild::ControllerBqrComplete(_) => CommandCompleteChild::ControllerBqrComplete(ControllerBqrCompletePacket::new(self.event.clone())),CommandCompleteDataChild::Payload(p) => CommandCompleteChild::Payload(p.clone()),CommandCompleteDataChild::None => CommandCompleteChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};Self {event,command_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
}
impl Into<EventPacket> for CommandCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl CommandCompleteBuilder {pub fn build(self) -> CommandCompletePacket {let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: self.command_op_code, child: match self.payload { None => CommandCompleteDataChild::None,Some(bytes) => CommandCompleteDataChild::Payload(bytes),},});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});CommandCompletePacket::new(event)}
}
impl Into<EventPacket> for CommandCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] enum CommandStatusDataChild {InquiryStatus(Arc<InquiryStatusData>),CreateConnectionStatus(Arc<CreateConnectionStatusData>),DisconnectStatus(Arc<DisconnectStatusData>),AcceptConnectionRequestStatus(Arc<AcceptConnectionRequestStatusData>),RejectConnectionRequestStatus(Arc<RejectConnectionRequestStatusData>),ChangeConnectionPacketTypeStatus(Arc<ChangeConnectionPacketTypeStatusData>),AuthenticationRequestedStatus(Arc<AuthenticationRequestedStatusData>),SetConnectionEncryptionStatus(Arc<SetConnectionEncryptionStatusData>),ChangeConnectionLinkKeyStatus(Arc<ChangeConnectionLinkKeyStatusData>),CentralLinkKeyStatus(Arc<CentralLinkKeyStatusData>),RemoteNameRequestStatus(Arc<RemoteNameRequestStatusData>),ReadRemoteSupportedFeaturesStatus(Arc<ReadRemoteSupportedFeaturesStatusData>),ReadRemoteExtendedFeaturesStatus(Arc<ReadRemoteExtendedFeaturesStatusData>),ReadRemoteVersionInformationStatus(Arc<ReadRemoteVersionInformationStatusData>),ReadClockOffsetStatus(Arc<ReadClockOffsetStatusData>),SetupSynchronousConnectionStatus(Arc<SetupSynchronousConnectionStatusData>),AcceptSynchronousConnectionStatus(Arc<AcceptSynchronousConnectionStatusData>),RejectSynchronousConnectionStatus(Arc<RejectSynchronousConnectionStatusData>),EnhancedSetupSynchronousConnectionStatus(Arc<EnhancedSetupSynchronousConnectionStatusData>),EnhancedAcceptSynchronousConnectionStatus(Arc<EnhancedAcceptSynchronousConnectionStatusData>),HoldModeStatus(Arc<HoldModeStatusData>),SniffModeStatus(Arc<SniffModeStatusData>),ExitSniffModeStatus(Arc<ExitSniffModeStatusData>),QosSetupStatus(Arc<QosSetupStatusData>),SwitchRoleStatus(Arc<SwitchRoleStatusData>),FlowSpecificationStatus(Arc<FlowSpecificationStatusData>),RefreshEncryptionKeyStatus(Arc<RefreshEncryptionKeyStatusData>),LeCreateConnectionStatus(Arc<LeCreateConnectionStatusData>),LeConnectionUpdateStatus(Arc<LeConnectionUpdateStatusData>),LeReadRemoteFeaturesStatus(Arc<LeReadRemoteFeaturesStatusData>),LeStartEncryptionStatus(Arc<LeStartEncryptionStatusData>),LeReadLocalP256PublicKeyCommandStatus(Arc<LeReadLocalP256PublicKeyCommandStatusData>),LeGenerateDhkeyV1CommandStatus(Arc<LeGenerateDhkeyV1CommandStatusData>),LeSetPhyStatus(Arc<LeSetPhyStatusData>),LeExtendedCreateConnectionStatus(Arc<LeExtendedCreateConnectionStatusData>),LePeriodicAdvertisingCreateSyncStatus(Arc<LePeriodicAdvertisingCreateSyncStatusData>),LeGenerateDhkeyCommandStatus(Arc<LeGenerateDhkeyCommandStatusData>),LeCreateCisStatus(Arc<LeCreateCisStatusData>),LeAcceptCisRequestStatus(Arc<LeAcceptCisRequestStatusData>),LeCreateBigStatus(Arc<LeCreateBigStatusData>),LeTerminateBigStatus(Arc<LeTerminateBigStatusData>),LeBigCreateSyncStatus(Arc<LeBigCreateSyncStatusData>),LeRequestPeerScaStatus(Arc<LeRequestPeerScaStatusData>),LeReadRemoteTransmitPowerLevelStatus(Arc<LeReadRemoteTransmitPowerLevelStatusData>),EnhancedFlushStatus(Arc<EnhancedFlushStatusData>),Payload(Bytes),None,}
impl CommandStatusDataChild {fn get_total_size(&self) -> usize {match self {CommandStatusDataChild::InquiryStatus(value) => value.get_total_size(),CommandStatusDataChild::CreateConnectionStatus(value) => value.get_total_size(),CommandStatusDataChild::DisconnectStatus(value) => value.get_total_size(),CommandStatusDataChild::AcceptConnectionRequestStatus(value) => value.get_total_size(),CommandStatusDataChild::RejectConnectionRequestStatus(value) => value.get_total_size(),CommandStatusDataChild::ChangeConnectionPacketTypeStatus(value) => value.get_total_size(),CommandStatusDataChild::AuthenticationRequestedStatus(value) => value.get_total_size(),CommandStatusDataChild::SetConnectionEncryptionStatus(value) => value.get_total_size(),CommandStatusDataChild::ChangeConnectionLinkKeyStatus(value) => value.get_total_size(),CommandStatusDataChild::CentralLinkKeyStatus(value) => value.get_total_size(),CommandStatusDataChild::RemoteNameRequestStatus(value) => value.get_total_size(),CommandStatusDataChild::ReadRemoteSupportedFeaturesStatus(value) => value.get_total_size(),CommandStatusDataChild::ReadRemoteExtendedFeaturesStatus(value) => value.get_total_size(),CommandStatusDataChild::ReadRemoteVersionInformationStatus(value) => value.get_total_size(),CommandStatusDataChild::ReadClockOffsetStatus(value) => value.get_total_size(),CommandStatusDataChild::SetupSynchronousConnectionStatus(value) => value.get_total_size(),CommandStatusDataChild::AcceptSynchronousConnectionStatus(value) => value.get_total_size(),CommandStatusDataChild::RejectSynchronousConnectionStatus(value) => value.get_total_size(),CommandStatusDataChild::EnhancedSetupSynchronousConnectionStatus(value) => value.get_total_size(),CommandStatusDataChild::EnhancedAcceptSynchronousConnectionStatus(value) => value.get_total_size(),CommandStatusDataChild::HoldModeStatus(value) => value.get_total_size(),CommandStatusDataChild::SniffModeStatus(value) => value.get_total_size(),CommandStatusDataChild::ExitSniffModeStatus(value) => value.get_total_size(),CommandStatusDataChild::QosSetupStatus(value) => value.get_total_size(),CommandStatusDataChild::SwitchRoleStatus(value) => value.get_total_size(),CommandStatusDataChild::FlowSpecificationStatus(value) => value.get_total_size(),CommandStatusDataChild::RefreshEncryptionKeyStatus(value) => value.get_total_size(),CommandStatusDataChild::LeCreateConnectionStatus(value) => value.get_total_size(),CommandStatusDataChild::LeConnectionUpdateStatus(value) => value.get_total_size(),CommandStatusDataChild::LeReadRemoteFeaturesStatus(value) => value.get_total_size(),CommandStatusDataChild::LeStartEncryptionStatus(value) => value.get_total_size(),CommandStatusDataChild::LeReadLocalP256PublicKeyCommandStatus(value) => value.get_total_size(),CommandStatusDataChild::LeGenerateDhkeyV1CommandStatus(value) => value.get_total_size(),CommandStatusDataChild::LeSetPhyStatus(value) => value.get_total_size(),CommandStatusDataChild::LeExtendedCreateConnectionStatus(value) => value.get_total_size(),CommandStatusDataChild::LePeriodicAdvertisingCreateSyncStatus(value) => value.get_total_size(),CommandStatusDataChild::LeGenerateDhkeyCommandStatus(value) => value.get_total_size(),CommandStatusDataChild::LeCreateCisStatus(value) => value.get_total_size(),CommandStatusDataChild::LeAcceptCisRequestStatus(value) => value.get_total_size(),CommandStatusDataChild::LeCreateBigStatus(value) => value.get_total_size(),CommandStatusDataChild::LeTerminateBigStatus(value) => value.get_total_size(),CommandStatusDataChild::LeBigCreateSyncStatus(value) => value.get_total_size(),CommandStatusDataChild::LeRequestPeerScaStatus(value) => value.get_total_size(),CommandStatusDataChild::LeReadRemoteTransmitPowerLevelStatus(value) => value.get_total_size(),CommandStatusDataChild::EnhancedFlushStatus(value) => value.get_total_size(),CommandStatusDataChild::Payload(p) => p.len(),CommandStatusDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum CommandStatusChild {InquiryStatus(InquiryStatusPacket),CreateConnectionStatus(CreateConnectionStatusPacket),DisconnectStatus(DisconnectStatusPacket),AcceptConnectionRequestStatus(AcceptConnectionRequestStatusPacket),RejectConnectionRequestStatus(RejectConnectionRequestStatusPacket),ChangeConnectionPacketTypeStatus(ChangeConnectionPacketTypeStatusPacket),AuthenticationRequestedStatus(AuthenticationRequestedStatusPacket),SetConnectionEncryptionStatus(SetConnectionEncryptionStatusPacket),ChangeConnectionLinkKeyStatus(ChangeConnectionLinkKeyStatusPacket),CentralLinkKeyStatus(CentralLinkKeyStatusPacket),RemoteNameRequestStatus(RemoteNameRequestStatusPacket),ReadRemoteSupportedFeaturesStatus(ReadRemoteSupportedFeaturesStatusPacket),ReadRemoteExtendedFeaturesStatus(ReadRemoteExtendedFeaturesStatusPacket),ReadRemoteVersionInformationStatus(ReadRemoteVersionInformationStatusPacket),ReadClockOffsetStatus(ReadClockOffsetStatusPacket),SetupSynchronousConnectionStatus(SetupSynchronousConnectionStatusPacket),AcceptSynchronousConnectionStatus(AcceptSynchronousConnectionStatusPacket),RejectSynchronousConnectionStatus(RejectSynchronousConnectionStatusPacket),EnhancedSetupSynchronousConnectionStatus(EnhancedSetupSynchronousConnectionStatusPacket),EnhancedAcceptSynchronousConnectionStatus(EnhancedAcceptSynchronousConnectionStatusPacket),HoldModeStatus(HoldModeStatusPacket),SniffModeStatus(SniffModeStatusPacket),ExitSniffModeStatus(ExitSniffModeStatusPacket),QosSetupStatus(QosSetupStatusPacket),SwitchRoleStatus(SwitchRoleStatusPacket),FlowSpecificationStatus(FlowSpecificationStatusPacket),RefreshEncryptionKeyStatus(RefreshEncryptionKeyStatusPacket),LeCreateConnectionStatus(LeCreateConnectionStatusPacket),LeConnectionUpdateStatus(LeConnectionUpdateStatusPacket),LeReadRemoteFeaturesStatus(LeReadRemoteFeaturesStatusPacket),LeStartEncryptionStatus(LeStartEncryptionStatusPacket),LeReadLocalP256PublicKeyCommandStatus(LeReadLocalP256PublicKeyCommandStatusPacket),LeGenerateDhkeyV1CommandStatus(LeGenerateDhkeyV1CommandStatusPacket),LeSetPhyStatus(LeSetPhyStatusPacket),LeExtendedCreateConnectionStatus(LeExtendedCreateConnectionStatusPacket),LePeriodicAdvertisingCreateSyncStatus(LePeriodicAdvertisingCreateSyncStatusPacket),LeGenerateDhkeyCommandStatus(LeGenerateDhkeyCommandStatusPacket),LeCreateCisStatus(LeCreateCisStatusPacket),LeAcceptCisRequestStatus(LeAcceptCisRequestStatusPacket),LeCreateBigStatus(LeCreateBigStatusPacket),LeTerminateBigStatus(LeTerminateBigStatusPacket),LeBigCreateSyncStatus(LeBigCreateSyncStatusPacket),LeRequestPeerScaStatus(LeRequestPeerScaStatusPacket),LeReadRemoteTransmitPowerLevelStatus(LeReadRemoteTransmitPowerLevelStatusPacket),EnhancedFlushStatus(EnhancedFlushStatusPacket),Payload(Bytes),None,}
#[derive(Debug)] struct CommandStatusData {status: ErrorCode, num_hci_command_packets: u8, command_op_code: OpCode, child: CommandStatusDataChild,}
#[derive(Debug, Clone)] pub struct CommandStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,}
#[derive(Debug)] pub struct CommandStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, pub command_op_code: OpCode, pub payload: Option<Bytes>,}
impl CommandStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "CommandStatus".to_string(),    field: "status".to_string(),    wanted: 3,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[2]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "CommandStatus".to_string(),    field: "num_hci_command_packets".to_string(),    wanted: 4,    got: bytes.len()});}let num_hci_command_packets = u8::from_le_bytes([bytes[3]]);if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "CommandStatus".to_string(),    field: "command_op_code".to_string(),    wanted: 6,    got: bytes.len()});}let command_op_code = u16::from_le_bytes([bytes[4],bytes[5]]);let command_op_code = OpCode::from_u16(command_op_code).unwrap();let payload: Vec::<u8> = bytes[6..].into();let child = match command_op_code {OpCode::Inquiry if InquiryStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::InquiryStatus(Arc::new(InquiryStatusData::parse(&bytes[..])?))}
OpCode::CreateConnection if CreateConnectionStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::CreateConnectionStatus(Arc::new(CreateConnectionStatusData::parse(&bytes[..])?))}
OpCode::Disconnect if DisconnectStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::DisconnectStatus(Arc::new(DisconnectStatusData::parse(&bytes[..])?))}
OpCode::AcceptConnectionRequest if AcceptConnectionRequestStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::AcceptConnectionRequestStatus(Arc::new(AcceptConnectionRequestStatusData::parse(&bytes[..])?))}
OpCode::RejectConnectionRequest if RejectConnectionRequestStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::RejectConnectionRequestStatus(Arc::new(RejectConnectionRequestStatusData::parse(&bytes[..])?))}
OpCode::ChangeConnectionPacketType if ChangeConnectionPacketTypeStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::ChangeConnectionPacketTypeStatus(Arc::new(ChangeConnectionPacketTypeStatusData::parse(&bytes[..])?))}
OpCode::AuthenticationRequested if AuthenticationRequestedStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::AuthenticationRequestedStatus(Arc::new(AuthenticationRequestedStatusData::parse(&bytes[..])?))}
OpCode::SetConnectionEncryption if SetConnectionEncryptionStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::SetConnectionEncryptionStatus(Arc::new(SetConnectionEncryptionStatusData::parse(&bytes[..])?))}
OpCode::ChangeConnectionLinkKey if ChangeConnectionLinkKeyStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::ChangeConnectionLinkKeyStatus(Arc::new(ChangeConnectionLinkKeyStatusData::parse(&bytes[..])?))}
OpCode::CentralLinkKey if CentralLinkKeyStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::CentralLinkKeyStatus(Arc::new(CentralLinkKeyStatusData::parse(&bytes[..])?))}
OpCode::RemoteNameRequest if RemoteNameRequestStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::RemoteNameRequestStatus(Arc::new(RemoteNameRequestStatusData::parse(&bytes[..])?))}
OpCode::ReadRemoteSupportedFeatures if ReadRemoteSupportedFeaturesStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::ReadRemoteSupportedFeaturesStatus(Arc::new(ReadRemoteSupportedFeaturesStatusData::parse(&bytes[..])?))}
OpCode::ReadRemoteExtendedFeatures if ReadRemoteExtendedFeaturesStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::ReadRemoteExtendedFeaturesStatus(Arc::new(ReadRemoteExtendedFeaturesStatusData::parse(&bytes[..])?))}
OpCode::ReadRemoteVersionInformation if ReadRemoteVersionInformationStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::ReadRemoteVersionInformationStatus(Arc::new(ReadRemoteVersionInformationStatusData::parse(&bytes[..])?))}
OpCode::ReadClockOffset if ReadClockOffsetStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::ReadClockOffsetStatus(Arc::new(ReadClockOffsetStatusData::parse(&bytes[..])?))}
OpCode::SetupSynchronousConnection if SetupSynchronousConnectionStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::SetupSynchronousConnectionStatus(Arc::new(SetupSynchronousConnectionStatusData::parse(&bytes[..])?))}
OpCode::AcceptSynchronousConnection if AcceptSynchronousConnectionStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::AcceptSynchronousConnectionStatus(Arc::new(AcceptSynchronousConnectionStatusData::parse(&bytes[..])?))}
OpCode::RejectSynchronousConnection if RejectSynchronousConnectionStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::RejectSynchronousConnectionStatus(Arc::new(RejectSynchronousConnectionStatusData::parse(&bytes[..])?))}
OpCode::EnhancedSetupSynchronousConnection if EnhancedSetupSynchronousConnectionStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::EnhancedSetupSynchronousConnectionStatus(Arc::new(EnhancedSetupSynchronousConnectionStatusData::parse(&bytes[..])?))}
OpCode::EnhancedAcceptSynchronousConnection if EnhancedAcceptSynchronousConnectionStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::EnhancedAcceptSynchronousConnectionStatus(Arc::new(EnhancedAcceptSynchronousConnectionStatusData::parse(&bytes[..])?))}
OpCode::HoldMode if HoldModeStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::HoldModeStatus(Arc::new(HoldModeStatusData::parse(&bytes[..])?))}
OpCode::SniffMode if SniffModeStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::SniffModeStatus(Arc::new(SniffModeStatusData::parse(&bytes[..])?))}
OpCode::ExitSniffMode if ExitSniffModeStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::ExitSniffModeStatus(Arc::new(ExitSniffModeStatusData::parse(&bytes[..])?))}
OpCode::QosSetup if QosSetupStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::QosSetupStatus(Arc::new(QosSetupStatusData::parse(&bytes[..])?))}
OpCode::SwitchRole if SwitchRoleStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::SwitchRoleStatus(Arc::new(SwitchRoleStatusData::parse(&bytes[..])?))}
OpCode::FlowSpecification if FlowSpecificationStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::FlowSpecificationStatus(Arc::new(FlowSpecificationStatusData::parse(&bytes[..])?))}
OpCode::RefreshEncryptionKey if RefreshEncryptionKeyStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::RefreshEncryptionKeyStatus(Arc::new(RefreshEncryptionKeyStatusData::parse(&bytes[..])?))}
OpCode::LeCreateConnection if LeCreateConnectionStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::LeCreateConnectionStatus(Arc::new(LeCreateConnectionStatusData::parse(&bytes[..])?))}
OpCode::LeConnectionUpdate if LeConnectionUpdateStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::LeConnectionUpdateStatus(Arc::new(LeConnectionUpdateStatusData::parse(&bytes[..])?))}
OpCode::LeReadRemoteFeatures if LeReadRemoteFeaturesStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::LeReadRemoteFeaturesStatus(Arc::new(LeReadRemoteFeaturesStatusData::parse(&bytes[..])?))}
OpCode::LeStartEncryption if LeStartEncryptionStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::LeStartEncryptionStatus(Arc::new(LeStartEncryptionStatusData::parse(&bytes[..])?))}
OpCode::LeReadLocalP256PublicKeyCommand if LeReadLocalP256PublicKeyCommandStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::LeReadLocalP256PublicKeyCommandStatus(Arc::new(LeReadLocalP256PublicKeyCommandStatusData::parse(&bytes[..])?))}
OpCode::LeGenerateDhkeyCommandV1 if LeGenerateDhkeyV1CommandStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::LeGenerateDhkeyV1CommandStatus(Arc::new(LeGenerateDhkeyV1CommandStatusData::parse(&bytes[..])?))}
OpCode::LeSetPhy if LeSetPhyStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::LeSetPhyStatus(Arc::new(LeSetPhyStatusData::parse(&bytes[..])?))}
OpCode::LeExtendedCreateConnection if LeExtendedCreateConnectionStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::LeExtendedCreateConnectionStatus(Arc::new(LeExtendedCreateConnectionStatusData::parse(&bytes[..])?))}
OpCode::LePeriodicAdvertisingCreateSync if LePeriodicAdvertisingCreateSyncStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::LePeriodicAdvertisingCreateSyncStatus(Arc::new(LePeriodicAdvertisingCreateSyncStatusData::parse(&bytes[..])?))}
OpCode::LeGenerateDhkeyCommand if LeGenerateDhkeyCommandStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::LeGenerateDhkeyCommandStatus(Arc::new(LeGenerateDhkeyCommandStatusData::parse(&bytes[..])?))}
OpCode::LeCreateCis if LeCreateCisStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::LeCreateCisStatus(Arc::new(LeCreateCisStatusData::parse(&bytes[..])?))}
OpCode::LeAcceptCisRequest if LeAcceptCisRequestStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::LeAcceptCisRequestStatus(Arc::new(LeAcceptCisRequestStatusData::parse(&bytes[..])?))}
OpCode::LeCreateBig if LeCreateBigStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::LeCreateBigStatus(Arc::new(LeCreateBigStatusData::parse(&bytes[..])?))}
OpCode::LeTerminateBig if LeTerminateBigStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::LeTerminateBigStatus(Arc::new(LeTerminateBigStatusData::parse(&bytes[..])?))}
OpCode::LeBigCreateSync if LeBigCreateSyncStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::LeBigCreateSyncStatus(Arc::new(LeBigCreateSyncStatusData::parse(&bytes[..])?))}
OpCode::LeRequestPeerSca if LeRequestPeerScaStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::LeRequestPeerScaStatus(Arc::new(LeRequestPeerScaStatusData::parse(&bytes[..])?))}
OpCode::LeReadRemoteTransmitPowerLevel if LeReadRemoteTransmitPowerLevelStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::LeReadRemoteTransmitPowerLevelStatus(Arc::new(LeReadRemoteTransmitPowerLevelStatusData::parse(&bytes[..])?))}
OpCode::EnhancedFlush if EnhancedFlushStatusData::conforms(&bytes[..]) => {CommandStatusDataChild::EnhancedFlushStatus(Arc::new(EnhancedFlushStatusData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "command_op_code".to_string(), value: v as u64}),};
Ok(Self {status, num_hci_command_packets, command_op_code, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[2..3].copy_from_slice(&status.to_le_bytes()[0..1]);let num_hci_command_packets = self.num_hci_command_packets;buffer[3..4].copy_from_slice(&num_hci_command_packets.to_le_bytes()[0..1]);let command_op_code = self.command_op_code.to_u16().unwrap();buffer[4..6].copy_from_slice(&command_op_code.to_le_bytes()[0..2]);match &self.child {CommandStatusDataChild::InquiryStatus(value) => value.write_to(buffer),CommandStatusDataChild::CreateConnectionStatus(value) => value.write_to(buffer),CommandStatusDataChild::DisconnectStatus(value) => value.write_to(buffer),CommandStatusDataChild::AcceptConnectionRequestStatus(value) => value.write_to(buffer),CommandStatusDataChild::RejectConnectionRequestStatus(value) => value.write_to(buffer),CommandStatusDataChild::ChangeConnectionPacketTypeStatus(value) => value.write_to(buffer),CommandStatusDataChild::AuthenticationRequestedStatus(value) => value.write_to(buffer),CommandStatusDataChild::SetConnectionEncryptionStatus(value) => value.write_to(buffer),CommandStatusDataChild::ChangeConnectionLinkKeyStatus(value) => value.write_to(buffer),CommandStatusDataChild::CentralLinkKeyStatus(value) => value.write_to(buffer),CommandStatusDataChild::RemoteNameRequestStatus(value) => value.write_to(buffer),CommandStatusDataChild::ReadRemoteSupportedFeaturesStatus(value) => value.write_to(buffer),CommandStatusDataChild::ReadRemoteExtendedFeaturesStatus(value) => value.write_to(buffer),CommandStatusDataChild::ReadRemoteVersionInformationStatus(value) => value.write_to(buffer),CommandStatusDataChild::ReadClockOffsetStatus(value) => value.write_to(buffer),CommandStatusDataChild::SetupSynchronousConnectionStatus(value) => value.write_to(buffer),CommandStatusDataChild::AcceptSynchronousConnectionStatus(value) => value.write_to(buffer),CommandStatusDataChild::RejectSynchronousConnectionStatus(value) => value.write_to(buffer),CommandStatusDataChild::EnhancedSetupSynchronousConnectionStatus(value) => value.write_to(buffer),CommandStatusDataChild::EnhancedAcceptSynchronousConnectionStatus(value) => value.write_to(buffer),CommandStatusDataChild::HoldModeStatus(value) => value.write_to(buffer),CommandStatusDataChild::SniffModeStatus(value) => value.write_to(buffer),CommandStatusDataChild::ExitSniffModeStatus(value) => value.write_to(buffer),CommandStatusDataChild::QosSetupStatus(value) => value.write_to(buffer),CommandStatusDataChild::SwitchRoleStatus(value) => value.write_to(buffer),CommandStatusDataChild::FlowSpecificationStatus(value) => value.write_to(buffer),CommandStatusDataChild::RefreshEncryptionKeyStatus(value) => value.write_to(buffer),CommandStatusDataChild::LeCreateConnectionStatus(value) => value.write_to(buffer),CommandStatusDataChild::LeConnectionUpdateStatus(value) => value.write_to(buffer),CommandStatusDataChild::LeReadRemoteFeaturesStatus(value) => value.write_to(buffer),CommandStatusDataChild::LeStartEncryptionStatus(value) => value.write_to(buffer),CommandStatusDataChild::LeReadLocalP256PublicKeyCommandStatus(value) => value.write_to(buffer),CommandStatusDataChild::LeGenerateDhkeyV1CommandStatus(value) => value.write_to(buffer),CommandStatusDataChild::LeSetPhyStatus(value) => value.write_to(buffer),CommandStatusDataChild::LeExtendedCreateConnectionStatus(value) => value.write_to(buffer),CommandStatusDataChild::LePeriodicAdvertisingCreateSyncStatus(value) => value.write_to(buffer),CommandStatusDataChild::LeGenerateDhkeyCommandStatus(value) => value.write_to(buffer),CommandStatusDataChild::LeCreateCisStatus(value) => value.write_to(buffer),CommandStatusDataChild::LeAcceptCisRequestStatus(value) => value.write_to(buffer),CommandStatusDataChild::LeCreateBigStatus(value) => value.write_to(buffer),CommandStatusDataChild::LeTerminateBigStatus(value) => value.write_to(buffer),CommandStatusDataChild::LeBigCreateSyncStatus(value) => value.write_to(buffer),CommandStatusDataChild::LeRequestPeerScaStatus(value) => value.write_to(buffer),CommandStatusDataChild::LeReadRemoteTransmitPowerLevelStatus(value) => value.write_to(buffer),CommandStatusDataChild::EnhancedFlushStatus(value) => value.write_to(buffer),CommandStatusDataChild::Payload(p) => buffer[6..].copy_from_slice(&p[..]),CommandStatusDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl Packet for CommandStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl CommandStatusPacket { pub fn specialize(&self) -> CommandStatusChild { match &self.command_status.child {CommandStatusDataChild::InquiryStatus(_) => CommandStatusChild::InquiryStatus(InquiryStatusPacket::new(self.event.clone())),CommandStatusDataChild::CreateConnectionStatus(_) => CommandStatusChild::CreateConnectionStatus(CreateConnectionStatusPacket::new(self.event.clone())),CommandStatusDataChild::DisconnectStatus(_) => CommandStatusChild::DisconnectStatus(DisconnectStatusPacket::new(self.event.clone())),CommandStatusDataChild::AcceptConnectionRequestStatus(_) => CommandStatusChild::AcceptConnectionRequestStatus(AcceptConnectionRequestStatusPacket::new(self.event.clone())),CommandStatusDataChild::RejectConnectionRequestStatus(_) => CommandStatusChild::RejectConnectionRequestStatus(RejectConnectionRequestStatusPacket::new(self.event.clone())),CommandStatusDataChild::ChangeConnectionPacketTypeStatus(_) => CommandStatusChild::ChangeConnectionPacketTypeStatus(ChangeConnectionPacketTypeStatusPacket::new(self.event.clone())),CommandStatusDataChild::AuthenticationRequestedStatus(_) => CommandStatusChild::AuthenticationRequestedStatus(AuthenticationRequestedStatusPacket::new(self.event.clone())),CommandStatusDataChild::SetConnectionEncryptionStatus(_) => CommandStatusChild::SetConnectionEncryptionStatus(SetConnectionEncryptionStatusPacket::new(self.event.clone())),CommandStatusDataChild::ChangeConnectionLinkKeyStatus(_) => CommandStatusChild::ChangeConnectionLinkKeyStatus(ChangeConnectionLinkKeyStatusPacket::new(self.event.clone())),CommandStatusDataChild::CentralLinkKeyStatus(_) => CommandStatusChild::CentralLinkKeyStatus(CentralLinkKeyStatusPacket::new(self.event.clone())),CommandStatusDataChild::RemoteNameRequestStatus(_) => CommandStatusChild::RemoteNameRequestStatus(RemoteNameRequestStatusPacket::new(self.event.clone())),CommandStatusDataChild::ReadRemoteSupportedFeaturesStatus(_) => CommandStatusChild::ReadRemoteSupportedFeaturesStatus(ReadRemoteSupportedFeaturesStatusPacket::new(self.event.clone())),CommandStatusDataChild::ReadRemoteExtendedFeaturesStatus(_) => CommandStatusChild::ReadRemoteExtendedFeaturesStatus(ReadRemoteExtendedFeaturesStatusPacket::new(self.event.clone())),CommandStatusDataChild::ReadRemoteVersionInformationStatus(_) => CommandStatusChild::ReadRemoteVersionInformationStatus(ReadRemoteVersionInformationStatusPacket::new(self.event.clone())),CommandStatusDataChild::ReadClockOffsetStatus(_) => CommandStatusChild::ReadClockOffsetStatus(ReadClockOffsetStatusPacket::new(self.event.clone())),CommandStatusDataChild::SetupSynchronousConnectionStatus(_) => CommandStatusChild::SetupSynchronousConnectionStatus(SetupSynchronousConnectionStatusPacket::new(self.event.clone())),CommandStatusDataChild::AcceptSynchronousConnectionStatus(_) => CommandStatusChild::AcceptSynchronousConnectionStatus(AcceptSynchronousConnectionStatusPacket::new(self.event.clone())),CommandStatusDataChild::RejectSynchronousConnectionStatus(_) => CommandStatusChild::RejectSynchronousConnectionStatus(RejectSynchronousConnectionStatusPacket::new(self.event.clone())),CommandStatusDataChild::EnhancedSetupSynchronousConnectionStatus(_) => CommandStatusChild::EnhancedSetupSynchronousConnectionStatus(EnhancedSetupSynchronousConnectionStatusPacket::new(self.event.clone())),CommandStatusDataChild::EnhancedAcceptSynchronousConnectionStatus(_) => CommandStatusChild::EnhancedAcceptSynchronousConnectionStatus(EnhancedAcceptSynchronousConnectionStatusPacket::new(self.event.clone())),CommandStatusDataChild::HoldModeStatus(_) => CommandStatusChild::HoldModeStatus(HoldModeStatusPacket::new(self.event.clone())),CommandStatusDataChild::SniffModeStatus(_) => CommandStatusChild::SniffModeStatus(SniffModeStatusPacket::new(self.event.clone())),CommandStatusDataChild::ExitSniffModeStatus(_) => CommandStatusChild::ExitSniffModeStatus(ExitSniffModeStatusPacket::new(self.event.clone())),CommandStatusDataChild::QosSetupStatus(_) => CommandStatusChild::QosSetupStatus(QosSetupStatusPacket::new(self.event.clone())),CommandStatusDataChild::SwitchRoleStatus(_) => CommandStatusChild::SwitchRoleStatus(SwitchRoleStatusPacket::new(self.event.clone())),CommandStatusDataChild::FlowSpecificationStatus(_) => CommandStatusChild::FlowSpecificationStatus(FlowSpecificationStatusPacket::new(self.event.clone())),CommandStatusDataChild::RefreshEncryptionKeyStatus(_) => CommandStatusChild::RefreshEncryptionKeyStatus(RefreshEncryptionKeyStatusPacket::new(self.event.clone())),CommandStatusDataChild::LeCreateConnectionStatus(_) => CommandStatusChild::LeCreateConnectionStatus(LeCreateConnectionStatusPacket::new(self.event.clone())),CommandStatusDataChild::LeConnectionUpdateStatus(_) => CommandStatusChild::LeConnectionUpdateStatus(LeConnectionUpdateStatusPacket::new(self.event.clone())),CommandStatusDataChild::LeReadRemoteFeaturesStatus(_) => CommandStatusChild::LeReadRemoteFeaturesStatus(LeReadRemoteFeaturesStatusPacket::new(self.event.clone())),CommandStatusDataChild::LeStartEncryptionStatus(_) => CommandStatusChild::LeStartEncryptionStatus(LeStartEncryptionStatusPacket::new(self.event.clone())),CommandStatusDataChild::LeReadLocalP256PublicKeyCommandStatus(_) => CommandStatusChild::LeReadLocalP256PublicKeyCommandStatus(LeReadLocalP256PublicKeyCommandStatusPacket::new(self.event.clone())),CommandStatusDataChild::LeGenerateDhkeyV1CommandStatus(_) => CommandStatusChild::LeGenerateDhkeyV1CommandStatus(LeGenerateDhkeyV1CommandStatusPacket::new(self.event.clone())),CommandStatusDataChild::LeSetPhyStatus(_) => CommandStatusChild::LeSetPhyStatus(LeSetPhyStatusPacket::new(self.event.clone())),CommandStatusDataChild::LeExtendedCreateConnectionStatus(_) => CommandStatusChild::LeExtendedCreateConnectionStatus(LeExtendedCreateConnectionStatusPacket::new(self.event.clone())),CommandStatusDataChild::LePeriodicAdvertisingCreateSyncStatus(_) => CommandStatusChild::LePeriodicAdvertisingCreateSyncStatus(LePeriodicAdvertisingCreateSyncStatusPacket::new(self.event.clone())),CommandStatusDataChild::LeGenerateDhkeyCommandStatus(_) => CommandStatusChild::LeGenerateDhkeyCommandStatus(LeGenerateDhkeyCommandStatusPacket::new(self.event.clone())),CommandStatusDataChild::LeCreateCisStatus(_) => CommandStatusChild::LeCreateCisStatus(LeCreateCisStatusPacket::new(self.event.clone())),CommandStatusDataChild::LeAcceptCisRequestStatus(_) => CommandStatusChild::LeAcceptCisRequestStatus(LeAcceptCisRequestStatusPacket::new(self.event.clone())),CommandStatusDataChild::LeCreateBigStatus(_) => CommandStatusChild::LeCreateBigStatus(LeCreateBigStatusPacket::new(self.event.clone())),CommandStatusDataChild::LeTerminateBigStatus(_) => CommandStatusChild::LeTerminateBigStatus(LeTerminateBigStatusPacket::new(self.event.clone())),CommandStatusDataChild::LeBigCreateSyncStatus(_) => CommandStatusChild::LeBigCreateSyncStatus(LeBigCreateSyncStatusPacket::new(self.event.clone())),CommandStatusDataChild::LeRequestPeerScaStatus(_) => CommandStatusChild::LeRequestPeerScaStatus(LeRequestPeerScaStatusPacket::new(self.event.clone())),CommandStatusDataChild::LeReadRemoteTransmitPowerLevelStatus(_) => CommandStatusChild::LeReadRemoteTransmitPowerLevelStatus(LeReadRemoteTransmitPowerLevelStatusPacket::new(self.event.clone())),CommandStatusDataChild::EnhancedFlushStatus(_) => CommandStatusChild::EnhancedFlushStatus(EnhancedFlushStatusPacket::new(self.event.clone())),CommandStatusDataChild::Payload(p) => CommandStatusChild::Payload(p.clone()),CommandStatusDataChild::None => CommandStatusChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};Self {event,command_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for CommandStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl CommandStatusBuilder {pub fn build(self) -> CommandStatusPacket {let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: self.command_op_code, child: match self.payload { None => CommandStatusDataChild::None,Some(bytes) => CommandStatusDataChild::Payload(bytes),},});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});CommandStatusPacket::new(event)}
}
impl Into<EventPacket> for CommandStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct NoCommandCompleteData {}
#[derive(Debug, Clone)] pub struct NoCommandCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,no_command_complete: Arc<NoCommandCompleteData>,}
#[derive(Debug)] pub struct NoCommandCompleteBuilder {pub num_hci_command_packets: u8, }
impl NoCommandCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for NoCommandCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl NoCommandCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let no_command_complete = match &command_complete.child {CommandCompleteDataChild::NoCommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not NoCommandComplete"),};Self {event,command_complete,no_command_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
}
impl Into<EventPacket> for NoCommandCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for NoCommandCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl NoCommandCompleteBuilder {pub fn build(self) -> NoCommandCompletePacket {let no_command_complete= Arc::new(NoCommandCompleteData {});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::None, child: CommandCompleteDataChild::NoCommandComplete(no_command_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});NoCommandCompletePacket::new(event)}
}
impl Into<EventPacket> for NoCommandCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for NoCommandCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct InquiryData {lap: Lap, inquiry_length: u8, num_responses: u8, }
#[derive(Debug, Clone)] pub struct InquiryPacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,inquiry: Arc<InquiryData>,}
#[derive(Debug)] pub struct InquiryBuilder {pub lap: Lap, pub inquiry_length: u8, pub num_responses: u8, }
impl InquiryData {fn conforms(bytes: &[u8]) -> bool {if !Lap::conforms(&bytes[3..6]) { return false; } true}fn parse(bytes: &[u8]) -> Result<Self> {let lap = Lap::parse(&bytes[3..6]).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "Inquiry".to_string(),    field: "inquiry_length".to_string(),    wanted: 7,    got: bytes.len()});}let inquiry_length = u8::from_le_bytes([bytes[6]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "Inquiry".to_string(),    field: "num_responses".to_string(),    wanted: 8,    got: bytes.len()});}let num_responses = u8::from_le_bytes([bytes[7]]);Ok(Self {lap, inquiry_length, num_responses, })
}
fn write_to(&self, buffer: &mut BytesMut) {let lap = &mut buffer[3..6];self.lap.write_to(lap);let inquiry_length = self.inquiry_length;buffer[6..7].copy_from_slice(&inquiry_length.to_le_bytes()[0..1]);let num_responses = self.num_responses;buffer[7..8].copy_from_slice(&num_responses.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 5;ret}
}
impl CommandExpectations for InquiryPacket { type ResponseType = InquiryStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { InquiryStatusPacket::new(pkt.event.clone()) }}impl Packet for InquiryPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl InquiryPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let inquiry = match &discovery_command.child {DiscoveryCommandDataChild::Inquiry(value) => (*value).clone(),_ => panic!("inconsistent state - child was not Inquiry"),};Self {command,discovery_command,inquiry,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_lap(&self) -> &Lap{ &self.inquiry.as_ref().lap}
pub fn get_inquiry_length(&self) -> u8{ self.inquiry.as_ref().inquiry_length}
pub fn get_num_responses(&self) -> u8{ self.inquiry.as_ref().num_responses}
}
impl Into<CommandPacket> for InquiryPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for InquiryPacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for InquiryBuilder { type ResponseType = InquiryStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { InquiryStatusPacket::new(pkt.event.clone()) }}impl InquiryBuilder {pub fn build(self) -> InquiryPacket {let inquiry= Arc::new(InquiryData {lap: self.lap, inquiry_length: self.inquiry_length, num_responses: self.num_responses, });let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::Inquiry(inquiry),});let command= Arc::new(CommandData {op_code: OpCode::Inquiry, child: CommandDataChild::DiscoveryCommand(discovery_command),});InquiryPacket::new(command)}
}
impl Into<CommandPacket> for InquiryBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for InquiryBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}
macro_rules! inquiry_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::DiscoveryCommand(discovery_command_packet) => {match discovery_command_packet.specialize() {/* (2) */
DiscoveryCommandChild::Inquiry(packet) => {let rebuilder = InquiryBuilder {lap : packet.get_lap().clone(),inquiry_length : packet.get_inquiry_length(),num_responses : packet.get_num_responses(),};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse inquiry{:02x?}", discovery_command_packet); }}}_ => {println!("Couldn't parse discovery_command{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}inquiry_builder_tests! { inquiry_builder_test_00: b"\x01\x04\x05\x33\x8b\x9e\xaa\xbb",}


#[derive(Debug)] struct InquiryStatusData {}
#[derive(Debug, Clone)] pub struct InquiryStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,inquiry_status: Arc<InquiryStatusData>,}
#[derive(Debug)] pub struct InquiryStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl InquiryStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for InquiryStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl InquiryStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let inquiry_status = match &command_status.child {CommandStatusDataChild::InquiryStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not InquiryStatus"),};Self {event,command_status,inquiry_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for InquiryStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for InquiryStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl InquiryStatusBuilder {pub fn build(self) -> InquiryStatusPacket {let inquiry_status= Arc::new(InquiryStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::Inquiry, child: CommandStatusDataChild::InquiryStatus(inquiry_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});InquiryStatusPacket::new(event)}
}
impl Into<EventPacket> for InquiryStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for InquiryStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}
macro_rules! inquiry_status_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandStatus(command_status_packet) => {match command_status_packet.specialize() {/* (2) */
CommandStatusChild::InquiryStatus(packet) => {let rebuilder = InquiryStatusBuilder {status : packet.get_status(),num_hci_command_packets : packet.get_num_hci_command_packets(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse inquiry_status{:02x?}", command_status_packet); }}}_ => {println!("Couldn't parse command_status{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}inquiry_status_builder_tests! { inquiry_status_builder_test_00: b"\x0f\x04\x00\x01\x01\x04",}


#[derive(Debug)] struct InquiryCancelData {}
#[derive(Debug, Clone)] pub struct InquiryCancelPacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,inquiry_cancel: Arc<InquiryCancelData>,}
#[derive(Debug)] pub struct InquiryCancelBuilder {}
impl InquiryCancelData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for InquiryCancelPacket { type ResponseType = InquiryCancelCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { InquiryCancelCompletePacket::new(pkt.event.clone()) }}impl Packet for InquiryCancelPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl InquiryCancelPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let inquiry_cancel = match &discovery_command.child {DiscoveryCommandDataChild::InquiryCancel(value) => (*value).clone(),_ => panic!("inconsistent state - child was not InquiryCancel"),};Self {command,discovery_command,inquiry_cancel,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for InquiryCancelPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for InquiryCancelPacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for InquiryCancelBuilder { type ResponseType = InquiryCancelCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { InquiryCancelCompletePacket::new(pkt.event.clone()) }}impl InquiryCancelBuilder {pub fn build(self) -> InquiryCancelPacket {let inquiry_cancel= Arc::new(InquiryCancelData {});let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::InquiryCancel(inquiry_cancel),});let command= Arc::new(CommandData {op_code: OpCode::InquiryCancel, child: CommandDataChild::DiscoveryCommand(discovery_command),});InquiryCancelPacket::new(command)}
}
impl Into<CommandPacket> for InquiryCancelBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for InquiryCancelBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}
macro_rules! inquiry_cancel_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::DiscoveryCommand(discovery_command_packet) => {match discovery_command_packet.specialize() {/* (2) */
DiscoveryCommandChild::InquiryCancel(packet) => {let rebuilder = InquiryCancelBuilder {};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse inquiry_cancel{:02x?}", discovery_command_packet); }}}_ => {println!("Couldn't parse discovery_command{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}inquiry_cancel_builder_tests! { inquiry_cancel_builder_test_00: b"\x02\x04\x00",}


#[derive(Debug)] struct InquiryCancelCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct InquiryCancelCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,inquiry_cancel_complete: Arc<InquiryCancelCompleteData>,}
#[derive(Debug)] pub struct InquiryCancelCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl InquiryCancelCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "InquiryCancelComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for InquiryCancelCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl InquiryCancelCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let inquiry_cancel_complete = match &command_complete.child {CommandCompleteDataChild::InquiryCancelComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not InquiryCancelComplete"),};Self {event,command_complete,inquiry_cancel_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.inquiry_cancel_complete.as_ref().status}
}
impl Into<EventPacket> for InquiryCancelCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for InquiryCancelCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl InquiryCancelCompleteBuilder {pub fn build(self) -> InquiryCancelCompletePacket {let inquiry_cancel_complete= Arc::new(InquiryCancelCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::InquiryCancel, child: CommandCompleteDataChild::InquiryCancelComplete(inquiry_cancel_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});InquiryCancelCompletePacket::new(event)}
}
impl Into<EventPacket> for InquiryCancelCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for InquiryCancelCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! inquiry_cancel_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::InquiryCancelComplete(packet) => {let rebuilder = InquiryCancelCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse inquiry_cancel_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}inquiry_cancel_complete_builder_tests! { inquiry_cancel_complete_builder_test_00: b"\x0e\x04\x01\x02\x04\x00",}


#[derive(Debug)] struct PeriodicInquiryModeData {max_period_length: u16, min_period_length: u16, lap: Lap, inquiry_length: u8, num_responses: u8, }
#[derive(Debug, Clone)] pub struct PeriodicInquiryModePacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,periodic_inquiry_mode: Arc<PeriodicInquiryModeData>,}
#[derive(Debug)] pub struct PeriodicInquiryModeBuilder {pub max_period_length: u16, pub min_period_length: u16, pub lap: Lap, pub inquiry_length: u8, pub num_responses: u8, }
impl PeriodicInquiryModeData {fn conforms(bytes: &[u8]) -> bool {if !Lap::conforms(&bytes[7..10]) { return false; } true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "PeriodicInquiryMode".to_string(),    field: "max_period_length".to_string(),    wanted: 5,    got: bytes.len()});}let max_period_length = u16::from_le_bytes([bytes[3],bytes[4]]);if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "PeriodicInquiryMode".to_string(),    field: "min_period_length".to_string(),    wanted: 7,    got: bytes.len()});}let min_period_length = u16::from_le_bytes([bytes[5],bytes[6]]);let lap = Lap::parse(&bytes[7..10]).unwrap();if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "PeriodicInquiryMode".to_string(),    field: "inquiry_length".to_string(),    wanted: 11,    got: bytes.len()});}let inquiry_length = u8::from_le_bytes([bytes[10]]);if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "PeriodicInquiryMode".to_string(),    field: "num_responses".to_string(),    wanted: 12,    got: bytes.len()});}let num_responses = u8::from_le_bytes([bytes[11]]);Ok(Self {max_period_length, min_period_length, lap, inquiry_length, num_responses, })
}
fn write_to(&self, buffer: &mut BytesMut) {let max_period_length = self.max_period_length;buffer[3..5].copy_from_slice(&max_period_length.to_le_bytes()[0..2]);let min_period_length = self.min_period_length;buffer[5..7].copy_from_slice(&min_period_length.to_le_bytes()[0..2]);let lap = &mut buffer[7..10];self.lap.write_to(lap);let inquiry_length = self.inquiry_length;buffer[10..11].copy_from_slice(&inquiry_length.to_le_bytes()[0..1]);let num_responses = self.num_responses;buffer[11..12].copy_from_slice(&num_responses.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 9;ret}
}
impl CommandExpectations for PeriodicInquiryModePacket { type ResponseType = PeriodicInquiryModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { PeriodicInquiryModeCompletePacket::new(pkt.event.clone()) }}impl Packet for PeriodicInquiryModePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl PeriodicInquiryModePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let periodic_inquiry_mode = match &discovery_command.child {DiscoveryCommandDataChild::PeriodicInquiryMode(value) => (*value).clone(),_ => panic!("inconsistent state - child was not PeriodicInquiryMode"),};Self {command,discovery_command,periodic_inquiry_mode,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_max_period_length(&self) -> u16{ self.periodic_inquiry_mode.as_ref().max_period_length}
pub fn get_min_period_length(&self) -> u16{ self.periodic_inquiry_mode.as_ref().min_period_length}
pub fn get_lap(&self) -> &Lap{ &self.periodic_inquiry_mode.as_ref().lap}
pub fn get_inquiry_length(&self) -> u8{ self.periodic_inquiry_mode.as_ref().inquiry_length}
pub fn get_num_responses(&self) -> u8{ self.periodic_inquiry_mode.as_ref().num_responses}
}
impl Into<CommandPacket> for PeriodicInquiryModePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for PeriodicInquiryModePacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for PeriodicInquiryModeBuilder { type ResponseType = PeriodicInquiryModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { PeriodicInquiryModeCompletePacket::new(pkt.event.clone()) }}impl PeriodicInquiryModeBuilder {pub fn build(self) -> PeriodicInquiryModePacket {let periodic_inquiry_mode= Arc::new(PeriodicInquiryModeData {max_period_length: self.max_period_length, min_period_length: self.min_period_length, lap: self.lap, inquiry_length: self.inquiry_length, num_responses: self.num_responses, });let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::PeriodicInquiryMode(periodic_inquiry_mode),});let command= Arc::new(CommandData {op_code: OpCode::PeriodicInquiryMode, child: CommandDataChild::DiscoveryCommand(discovery_command),});PeriodicInquiryModePacket::new(command)}
}
impl Into<CommandPacket> for PeriodicInquiryModeBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for PeriodicInquiryModeBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}
macro_rules! periodic_inquiry_mode_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::DiscoveryCommand(discovery_command_packet) => {match discovery_command_packet.specialize() {/* (2) */
DiscoveryCommandChild::PeriodicInquiryMode(packet) => {let rebuilder = PeriodicInquiryModeBuilder {max_period_length : packet.get_max_period_length(),min_period_length : packet.get_min_period_length(),lap : packet.get_lap().clone(),inquiry_length : packet.get_inquiry_length(),num_responses : packet.get_num_responses(),};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse periodic_inquiry_mode{:02x?}", discovery_command_packet); }}}_ => {println!("Couldn't parse discovery_command{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}periodic_inquiry_mode_builder_tests! { periodic_inquiry_mode_builder_test_00: b"\x03\x04\x09\x12\x34\x56\x78\x11\x8b\x9e\x9a\xbc",}


#[derive(Debug)] struct PeriodicInquiryModeCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct PeriodicInquiryModeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,periodic_inquiry_mode_complete: Arc<PeriodicInquiryModeCompleteData>,}
#[derive(Debug)] pub struct PeriodicInquiryModeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl PeriodicInquiryModeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "PeriodicInquiryModeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for PeriodicInquiryModeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl PeriodicInquiryModeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let periodic_inquiry_mode_complete = match &command_complete.child {CommandCompleteDataChild::PeriodicInquiryModeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not PeriodicInquiryModeComplete"),};Self {event,command_complete,periodic_inquiry_mode_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.periodic_inquiry_mode_complete.as_ref().status}
}
impl Into<EventPacket> for PeriodicInquiryModeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for PeriodicInquiryModeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl PeriodicInquiryModeCompleteBuilder {pub fn build(self) -> PeriodicInquiryModeCompletePacket {let periodic_inquiry_mode_complete= Arc::new(PeriodicInquiryModeCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::PeriodicInquiryMode, child: CommandCompleteDataChild::PeriodicInquiryModeComplete(periodic_inquiry_mode_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});PeriodicInquiryModeCompletePacket::new(event)}
}
impl Into<EventPacket> for PeriodicInquiryModeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for PeriodicInquiryModeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! periodic_inquiry_mode_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::PeriodicInquiryModeComplete(packet) => {let rebuilder = PeriodicInquiryModeCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse periodic_inquiry_mode_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}periodic_inquiry_mode_complete_builder_tests! { periodic_inquiry_mode_complete_builder_test_00: b"\x0e\x04\x01\x03\x04\x00",}


#[derive(Debug)] struct ExitPeriodicInquiryModeData {}
#[derive(Debug, Clone)] pub struct ExitPeriodicInquiryModePacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,exit_periodic_inquiry_mode: Arc<ExitPeriodicInquiryModeData>,}
#[derive(Debug)] pub struct ExitPeriodicInquiryModeBuilder {}
impl ExitPeriodicInquiryModeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ExitPeriodicInquiryModePacket { type ResponseType = ExitPeriodicInquiryModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ExitPeriodicInquiryModeCompletePacket::new(pkt.event.clone()) }}impl Packet for ExitPeriodicInquiryModePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ExitPeriodicInquiryModePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let exit_periodic_inquiry_mode = match &discovery_command.child {DiscoveryCommandDataChild::ExitPeriodicInquiryMode(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ExitPeriodicInquiryMode"),};Self {command,discovery_command,exit_periodic_inquiry_mode,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ExitPeriodicInquiryModePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for ExitPeriodicInquiryModePacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for ExitPeriodicInquiryModeBuilder { type ResponseType = ExitPeriodicInquiryModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ExitPeriodicInquiryModeCompletePacket::new(pkt.event.clone()) }}impl ExitPeriodicInquiryModeBuilder {pub fn build(self) -> ExitPeriodicInquiryModePacket {let exit_periodic_inquiry_mode= Arc::new(ExitPeriodicInquiryModeData {});let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::ExitPeriodicInquiryMode(exit_periodic_inquiry_mode),});let command= Arc::new(CommandData {op_code: OpCode::ExitPeriodicInquiryMode, child: CommandDataChild::DiscoveryCommand(discovery_command),});ExitPeriodicInquiryModePacket::new(command)}
}
impl Into<CommandPacket> for ExitPeriodicInquiryModeBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for ExitPeriodicInquiryModeBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}
macro_rules! exit_periodic_inquiry_mode_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::DiscoveryCommand(discovery_command_packet) => {match discovery_command_packet.specialize() {/* (2) */
DiscoveryCommandChild::ExitPeriodicInquiryMode(packet) => {let rebuilder = ExitPeriodicInquiryModeBuilder {};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse exit_periodic_inquiry_mode{:02x?}", discovery_command_packet); }}}_ => {println!("Couldn't parse discovery_command{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}exit_periodic_inquiry_mode_builder_tests! { exit_periodic_inquiry_mode_builder_test_00: b"\x04\x04\x00",}


#[derive(Debug)] struct ExitPeriodicInquiryModeCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct ExitPeriodicInquiryModeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,exit_periodic_inquiry_mode_complete: Arc<ExitPeriodicInquiryModeCompleteData>,}
#[derive(Debug)] pub struct ExitPeriodicInquiryModeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl ExitPeriodicInquiryModeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ExitPeriodicInquiryModeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for ExitPeriodicInquiryModeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ExitPeriodicInquiryModeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let exit_periodic_inquiry_mode_complete = match &command_complete.child {CommandCompleteDataChild::ExitPeriodicInquiryModeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ExitPeriodicInquiryModeComplete"),};Self {event,command_complete,exit_periodic_inquiry_mode_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.exit_periodic_inquiry_mode_complete.as_ref().status}
}
impl Into<EventPacket> for ExitPeriodicInquiryModeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ExitPeriodicInquiryModeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ExitPeriodicInquiryModeCompleteBuilder {pub fn build(self) -> ExitPeriodicInquiryModeCompletePacket {let exit_periodic_inquiry_mode_complete= Arc::new(ExitPeriodicInquiryModeCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ExitPeriodicInquiryMode, child: CommandCompleteDataChild::ExitPeriodicInquiryModeComplete(exit_periodic_inquiry_mode_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ExitPeriodicInquiryModeCompletePacket::new(event)}
}
impl Into<EventPacket> for ExitPeriodicInquiryModeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ExitPeriodicInquiryModeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! exit_periodic_inquiry_mode_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::ExitPeriodicInquiryModeComplete(packet) => {let rebuilder = ExitPeriodicInquiryModeCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse exit_periodic_inquiry_mode_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}exit_periodic_inquiry_mode_complete_builder_tests! { exit_periodic_inquiry_mode_complete_builder_test_00: b"\x0e\x04\x01\x04\x04\x00",}


#[derive(Debug)] struct CreateConnectionData {bd_addr: Address, packet_type: u16, page_scan_repetition_mode: PageScanRepetitionMode, clock_offset: u16, clock_offset_valid: ClockOffsetValid, allow_role_switch: CreateConnectionRoleSwitch, }
#[derive(Debug, Clone)] pub struct CreateConnectionPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,create_connection: Arc<CreateConnectionData>,}
#[derive(Debug)] pub struct CreateConnectionBuilder {pub bd_addr: Address, pub packet_type: u16, pub page_scan_repetition_mode: PageScanRepetitionMode, pub clock_offset: u16, pub clock_offset_valid: ClockOffsetValid, pub allow_role_switch: CreateConnectionRoleSwitch, }
impl CreateConnectionData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "CreateConnection".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "CreateConnection".to_string(),    field: "packet_type".to_string(),    wanted: 11,    got: bytes.len()});}let packet_type = u16::from_le_bytes([bytes[9],bytes[10]]);if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "CreateConnection".to_string(),    field: "page_scan_repetition_mode".to_string(),    wanted: 12,    got: bytes.len()});}let page_scan_repetition_mode = u8::from_le_bytes([bytes[11]]);let page_scan_repetition_mode = PageScanRepetitionMode::from_u8(page_scan_repetition_mode).unwrap();if bytes.len() < 15 { return Err(Error::InvalidLengthError{    obj: "CreateConnection".to_string(),    field: "clock_offset".to_string(),    wanted: 15,    got: bytes.len()});}let clock_offset = u16::from_le_bytes([bytes[13],bytes[14]]);let clock_offset = clock_offset & 0x7fff;let clock_offset_valid = u8::from_le_bytes([bytes[14]]);let clock_offset_valid = clock_offset_valid >> 7;let clock_offset_valid = clock_offset_valid & 0x1;let clock_offset_valid = ClockOffsetValid::from_u8(clock_offset_valid).unwrap();if bytes.len() < 16 { return Err(Error::InvalidLengthError{    obj: "CreateConnection".to_string(),    field: "allow_role_switch".to_string(),    wanted: 16,    got: bytes.len()});}let allow_role_switch = u8::from_le_bytes([bytes[15]]);let allow_role_switch = CreateConnectionRoleSwitch::from_u8(allow_role_switch).unwrap();Ok(Self {bd_addr, packet_type, page_scan_repetition_mode, clock_offset, clock_offset_valid, allow_role_switch, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);let packet_type = self.packet_type;buffer[9..11].copy_from_slice(&packet_type.to_le_bytes()[0..2]);let page_scan_repetition_mode = self.page_scan_repetition_mode.to_u8().unwrap();buffer[11..12].copy_from_slice(&page_scan_repetition_mode.to_le_bytes()[0..1]);let clock_offset = self.clock_offset;let clock_offset = clock_offset & 0x7fff;buffer[13..15].copy_from_slice(&clock_offset.to_le_bytes()[0..2]);let clock_offset_valid = self.clock_offset_valid.to_u8().unwrap();let clock_offset_valid = clock_offset_valid & 0x1;let clock_offset_valid = (clock_offset_valid << 7) | ((buffer[14] as u8) & 0x7f);buffer[14..15].copy_from_slice(&clock_offset_valid.to_le_bytes()[0..1]);let allow_role_switch = self.allow_role_switch.to_u8().unwrap();buffer[15..16].copy_from_slice(&allow_role_switch.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 13;ret}
}
impl CommandExpectations for CreateConnectionPacket { type ResponseType = CreateConnectionStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { CreateConnectionStatusPacket::new(pkt.event.clone()) }}impl Packet for CreateConnectionPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl CreateConnectionPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let create_connection = match &connection_management_command.child {ConnectionManagementCommandDataChild::CreateConnection(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CreateConnection"),};Self {command,acl_command,connection_management_command,create_connection,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.create_connection.as_ref().bd_addr}
pub fn get_packet_type(&self) -> u16{ self.create_connection.as_ref().packet_type}
pub fn get_page_scan_repetition_mode(&self) -> PageScanRepetitionMode{ self.create_connection.as_ref().page_scan_repetition_mode}
pub fn get_clock_offset(&self) -> u16{ self.create_connection.as_ref().clock_offset}
pub fn get_clock_offset_valid(&self) -> ClockOffsetValid{ self.create_connection.as_ref().clock_offset_valid}
pub fn get_allow_role_switch(&self) -> CreateConnectionRoleSwitch{ self.create_connection.as_ref().allow_role_switch}
}
impl Into<CommandPacket> for CreateConnectionPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for CreateConnectionPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for CreateConnectionPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for CreateConnectionBuilder { type ResponseType = CreateConnectionStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { CreateConnectionStatusPacket::new(pkt.event.clone()) }}impl CreateConnectionBuilder {pub fn build(self) -> CreateConnectionPacket {let create_connection= Arc::new(CreateConnectionData {bd_addr: self.bd_addr, packet_type: self.packet_type, page_scan_repetition_mode: self.page_scan_repetition_mode, clock_offset: self.clock_offset, clock_offset_valid: self.clock_offset_valid, allow_role_switch: self.allow_role_switch, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::CreateConnection(create_connection),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::CreateConnection, child: CommandDataChild::AclCommand(acl_command),});CreateConnectionPacket::new(command)}
}
impl Into<CommandPacket> for CreateConnectionBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for CreateConnectionBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for CreateConnectionBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct CreateConnectionStatusData {}
#[derive(Debug, Clone)] pub struct CreateConnectionStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,create_connection_status: Arc<CreateConnectionStatusData>,}
#[derive(Debug)] pub struct CreateConnectionStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl CreateConnectionStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for CreateConnectionStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl CreateConnectionStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let create_connection_status = match &command_status.child {CommandStatusDataChild::CreateConnectionStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CreateConnectionStatus"),};Self {event,command_status,create_connection_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for CreateConnectionStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for CreateConnectionStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl CreateConnectionStatusBuilder {pub fn build(self) -> CreateConnectionStatusPacket {let create_connection_status= Arc::new(CreateConnectionStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::CreateConnection, child: CommandStatusDataChild::CreateConnectionStatus(create_connection_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});CreateConnectionStatusPacket::new(event)}
}
impl Into<EventPacket> for CreateConnectionStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for CreateConnectionStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct DisconnectData {connection_handle: u16, reason: DisconnectReason, }
#[derive(Debug, Clone)] pub struct DisconnectPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,disconnect: Arc<DisconnectData>,}
#[derive(Debug)] pub struct DisconnectBuilder {pub connection_handle: u16, pub reason: DisconnectReason, }
impl DisconnectData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "Disconnect".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "Disconnect".to_string(),    field: "reason".to_string(),    wanted: 6,    got: bytes.len()});}let reason = u8::from_le_bytes([bytes[5]]);let reason = DisconnectReason::from_u8(reason).unwrap();Ok(Self {connection_handle, reason, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let reason = self.reason.to_u8().unwrap();buffer[5..6].copy_from_slice(&reason.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl CommandExpectations for DisconnectPacket { type ResponseType = DisconnectStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { DisconnectStatusPacket::new(pkt.event.clone()) }}impl Packet for DisconnectPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl DisconnectPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let disconnect = match &acl_command.child {AclCommandDataChild::Disconnect(value) => (*value).clone(),_ => panic!("inconsistent state - child was not Disconnect"),};Self {command,acl_command,disconnect,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.disconnect.as_ref().connection_handle}
pub fn get_reason(&self) -> DisconnectReason{ self.disconnect.as_ref().reason}
}
impl Into<CommandPacket> for DisconnectPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for DisconnectPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl CommandExpectations for DisconnectBuilder { type ResponseType = DisconnectStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { DisconnectStatusPacket::new(pkt.event.clone()) }}impl DisconnectBuilder {pub fn build(self) -> DisconnectPacket {let disconnect= Arc::new(DisconnectData {connection_handle: self.connection_handle, reason: self.reason, });let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::Disconnect(disconnect),});let command= Arc::new(CommandData {op_code: OpCode::Disconnect, child: CommandDataChild::AclCommand(acl_command),});DisconnectPacket::new(command)}
}
impl Into<CommandPacket> for DisconnectBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for DisconnectBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}


#[derive(Debug)] struct DisconnectStatusData {}
#[derive(Debug, Clone)] pub struct DisconnectStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,disconnect_status: Arc<DisconnectStatusData>,}
#[derive(Debug)] pub struct DisconnectStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl DisconnectStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for DisconnectStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl DisconnectStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let disconnect_status = match &command_status.child {CommandStatusDataChild::DisconnectStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DisconnectStatus"),};Self {event,command_status,disconnect_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for DisconnectStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for DisconnectStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl DisconnectStatusBuilder {pub fn build(self) -> DisconnectStatusPacket {let disconnect_status= Arc::new(DisconnectStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::Disconnect, child: CommandStatusDataChild::DisconnectStatus(disconnect_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});DisconnectStatusPacket::new(event)}
}
impl Into<EventPacket> for DisconnectStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for DisconnectStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct CreateConnectionCancelData {bd_addr: Address, }
#[derive(Debug, Clone)] pub struct CreateConnectionCancelPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,create_connection_cancel: Arc<CreateConnectionCancelData>,}
#[derive(Debug)] pub struct CreateConnectionCancelBuilder {pub bd_addr: Address, }
impl CreateConnectionCancelData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "CreateConnectionCancel".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();Ok(Self {bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl CommandExpectations for CreateConnectionCancelPacket { type ResponseType = CreateConnectionCancelCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { CreateConnectionCancelCompletePacket::new(pkt.event.clone()) }}impl Packet for CreateConnectionCancelPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl CreateConnectionCancelPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let create_connection_cancel = match &connection_management_command.child {ConnectionManagementCommandDataChild::CreateConnectionCancel(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CreateConnectionCancel"),};Self {command,acl_command,connection_management_command,create_connection_cancel,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.create_connection_cancel.as_ref().bd_addr}
}
impl Into<CommandPacket> for CreateConnectionCancelPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for CreateConnectionCancelPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for CreateConnectionCancelPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for CreateConnectionCancelBuilder { type ResponseType = CreateConnectionCancelCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { CreateConnectionCancelCompletePacket::new(pkt.event.clone()) }}impl CreateConnectionCancelBuilder {pub fn build(self) -> CreateConnectionCancelPacket {let create_connection_cancel= Arc::new(CreateConnectionCancelData {bd_addr: self.bd_addr, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::CreateConnectionCancel(create_connection_cancel),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::CreateConnectionCancel, child: CommandDataChild::AclCommand(acl_command),});CreateConnectionCancelPacket::new(command)}
}
impl Into<CommandPacket> for CreateConnectionCancelBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for CreateConnectionCancelBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for CreateConnectionCancelBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct CreateConnectionCancelCompleteData {status: ErrorCode, bd_addr: Address, }
#[derive(Debug, Clone)] pub struct CreateConnectionCancelCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,create_connection_cancel_complete: Arc<CreateConnectionCancelCompleteData>,}
#[derive(Debug)] pub struct CreateConnectionCancelCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub bd_addr: Address, }
impl CreateConnectionCancelCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "CreateConnectionCancelComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "CreateConnectionCancelComplete".to_string(),    field: "bd_addr".to_string(),    wanted: 12,    got: bytes.len()});}let bd_addr = bytes[6..12].try_into().unwrap();Ok(Self {status, bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let bd_addr: [u8; 6] = self.bd_addr.into();buffer[6..12].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for CreateConnectionCancelCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl CreateConnectionCancelCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let create_connection_cancel_complete = match &command_complete.child {CommandCompleteDataChild::CreateConnectionCancelComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CreateConnectionCancelComplete"),};Self {event,command_complete,create_connection_cancel_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.create_connection_cancel_complete.as_ref().status}
pub fn get_bd_addr(&self) -> Address{ self.create_connection_cancel_complete.as_ref().bd_addr}
}
impl Into<EventPacket> for CreateConnectionCancelCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for CreateConnectionCancelCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl CreateConnectionCancelCompleteBuilder {pub fn build(self) -> CreateConnectionCancelCompletePacket {let create_connection_cancel_complete= Arc::new(CreateConnectionCancelCompleteData {status: self.status, bd_addr: self.bd_addr, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::CreateConnectionCancel, child: CommandCompleteDataChild::CreateConnectionCancelComplete(create_connection_cancel_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});CreateConnectionCancelCompletePacket::new(event)}
}
impl Into<EventPacket> for CreateConnectionCancelCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for CreateConnectionCancelCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct AcceptConnectionRequestData {bd_addr: Address, role: AcceptConnectionRequestRole, }
#[derive(Debug, Clone)] pub struct AcceptConnectionRequestPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,accept_connection_request: Arc<AcceptConnectionRequestData>,}
#[derive(Debug)] pub struct AcceptConnectionRequestBuilder {pub bd_addr: Address, pub role: AcceptConnectionRequestRole, }
impl AcceptConnectionRequestData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "AcceptConnectionRequest".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "AcceptConnectionRequest".to_string(),    field: "role".to_string(),    wanted: 10,    got: bytes.len()});}let role = u8::from_le_bytes([bytes[9]]);let role = AcceptConnectionRequestRole::from_u8(role).unwrap();Ok(Self {bd_addr, role, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);let role = self.role.to_u8().unwrap();buffer[9..10].copy_from_slice(&role.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl CommandExpectations for AcceptConnectionRequestPacket { type ResponseType = AcceptConnectionRequestStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { AcceptConnectionRequestStatusPacket::new(pkt.event.clone()) }}impl Packet for AcceptConnectionRequestPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl AcceptConnectionRequestPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let accept_connection_request = match &connection_management_command.child {ConnectionManagementCommandDataChild::AcceptConnectionRequest(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AcceptConnectionRequest"),};Self {command,acl_command,connection_management_command,accept_connection_request,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.accept_connection_request.as_ref().bd_addr}
pub fn get_role(&self) -> AcceptConnectionRequestRole{ self.accept_connection_request.as_ref().role}
}
impl Into<CommandPacket> for AcceptConnectionRequestPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for AcceptConnectionRequestPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for AcceptConnectionRequestPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for AcceptConnectionRequestBuilder { type ResponseType = AcceptConnectionRequestStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { AcceptConnectionRequestStatusPacket::new(pkt.event.clone()) }}impl AcceptConnectionRequestBuilder {pub fn build(self) -> AcceptConnectionRequestPacket {let accept_connection_request= Arc::new(AcceptConnectionRequestData {bd_addr: self.bd_addr, role: self.role, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::AcceptConnectionRequest(accept_connection_request),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::AcceptConnectionRequest, child: CommandDataChild::AclCommand(acl_command),});AcceptConnectionRequestPacket::new(command)}
}
impl Into<CommandPacket> for AcceptConnectionRequestBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for AcceptConnectionRequestBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for AcceptConnectionRequestBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct AcceptConnectionRequestStatusData {}
#[derive(Debug, Clone)] pub struct AcceptConnectionRequestStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,accept_connection_request_status: Arc<AcceptConnectionRequestStatusData>,}
#[derive(Debug)] pub struct AcceptConnectionRequestStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl AcceptConnectionRequestStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for AcceptConnectionRequestStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl AcceptConnectionRequestStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let accept_connection_request_status = match &command_status.child {CommandStatusDataChild::AcceptConnectionRequestStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AcceptConnectionRequestStatus"),};Self {event,command_status,accept_connection_request_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for AcceptConnectionRequestStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for AcceptConnectionRequestStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl AcceptConnectionRequestStatusBuilder {pub fn build(self) -> AcceptConnectionRequestStatusPacket {let accept_connection_request_status= Arc::new(AcceptConnectionRequestStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::AcceptConnectionRequest, child: CommandStatusDataChild::AcceptConnectionRequestStatus(accept_connection_request_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});AcceptConnectionRequestStatusPacket::new(event)}
}
impl Into<EventPacket> for AcceptConnectionRequestStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for AcceptConnectionRequestStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct RejectConnectionRequestData {bd_addr: Address, reason: RejectConnectionReason, }
#[derive(Debug, Clone)] pub struct RejectConnectionRequestPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,reject_connection_request: Arc<RejectConnectionRequestData>,}
#[derive(Debug)] pub struct RejectConnectionRequestBuilder {pub bd_addr: Address, pub reason: RejectConnectionReason, }
impl RejectConnectionRequestData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "RejectConnectionRequest".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "RejectConnectionRequest".to_string(),    field: "reason".to_string(),    wanted: 10,    got: bytes.len()});}let reason = u8::from_le_bytes([bytes[9]]);let reason = RejectConnectionReason::from_u8(reason).unwrap();Ok(Self {bd_addr, reason, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);let reason = self.reason.to_u8().unwrap();buffer[9..10].copy_from_slice(&reason.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl CommandExpectations for RejectConnectionRequestPacket { type ResponseType = RejectConnectionRequestStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { RejectConnectionRequestStatusPacket::new(pkt.event.clone()) }}impl Packet for RejectConnectionRequestPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl RejectConnectionRequestPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let reject_connection_request = match &connection_management_command.child {ConnectionManagementCommandDataChild::RejectConnectionRequest(value) => (*value).clone(),_ => panic!("inconsistent state - child was not RejectConnectionRequest"),};Self {command,acl_command,connection_management_command,reject_connection_request,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.reject_connection_request.as_ref().bd_addr}
pub fn get_reason(&self) -> RejectConnectionReason{ self.reject_connection_request.as_ref().reason}
}
impl Into<CommandPacket> for RejectConnectionRequestPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for RejectConnectionRequestPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for RejectConnectionRequestPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for RejectConnectionRequestBuilder { type ResponseType = RejectConnectionRequestStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { RejectConnectionRequestStatusPacket::new(pkt.event.clone()) }}impl RejectConnectionRequestBuilder {pub fn build(self) -> RejectConnectionRequestPacket {let reject_connection_request= Arc::new(RejectConnectionRequestData {bd_addr: self.bd_addr, reason: self.reason, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::RejectConnectionRequest(reject_connection_request),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::RejectConnectionRequest, child: CommandDataChild::AclCommand(acl_command),});RejectConnectionRequestPacket::new(command)}
}
impl Into<CommandPacket> for RejectConnectionRequestBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for RejectConnectionRequestBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for RejectConnectionRequestBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct RejectConnectionRequestStatusData {}
#[derive(Debug, Clone)] pub struct RejectConnectionRequestStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,reject_connection_request_status: Arc<RejectConnectionRequestStatusData>,}
#[derive(Debug)] pub struct RejectConnectionRequestStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl RejectConnectionRequestStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for RejectConnectionRequestStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl RejectConnectionRequestStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let reject_connection_request_status = match &command_status.child {CommandStatusDataChild::RejectConnectionRequestStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not RejectConnectionRequestStatus"),};Self {event,command_status,reject_connection_request_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for RejectConnectionRequestStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for RejectConnectionRequestStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl RejectConnectionRequestStatusBuilder {pub fn build(self) -> RejectConnectionRequestStatusPacket {let reject_connection_request_status= Arc::new(RejectConnectionRequestStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::RejectConnectionRequest, child: CommandStatusDataChild::RejectConnectionRequestStatus(reject_connection_request_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});RejectConnectionRequestStatusPacket::new(event)}
}
impl Into<EventPacket> for RejectConnectionRequestStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for RejectConnectionRequestStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct LinkKeyRequestReplyData {bd_addr: Address, link_key: [u8; 16], }
#[derive(Debug, Clone)] pub struct LinkKeyRequestReplyPacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,link_key_request_reply: Arc<LinkKeyRequestReplyData>,}
#[derive(Debug)] pub struct LinkKeyRequestReplyBuilder {pub bd_addr: Address, pub link_key: [u8; 16], }
impl LinkKeyRequestReplyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LinkKeyRequestReply".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();if bytes.len() < 25 { return Err(Error::InvalidLengthError{    obj: "LinkKeyRequestReply".to_string(),    field: "link_key".to_string(),    wanted: 25,    got: bytes.len()});}let link_key = bytes[9..25].try_into().unwrap();Ok(Self {bd_addr, link_key, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);&buffer[9..25].copy_from_slice(&self.link_key);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 22;ret}
}
impl CommandExpectations for LinkKeyRequestReplyPacket { type ResponseType = LinkKeyRequestReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LinkKeyRequestReplyCompletePacket::new(pkt.event.clone()) }}impl Packet for LinkKeyRequestReplyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LinkKeyRequestReplyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let link_key_request_reply = match &security_command.child {SecurityCommandDataChild::LinkKeyRequestReply(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LinkKeyRequestReply"),};Self {command,security_command,link_key_request_reply,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.link_key_request_reply.as_ref().bd_addr}
pub fn get_link_key(&self) -> &[u8; 16]{ &self.link_key_request_reply.as_ref().link_key}
}
impl Into<CommandPacket> for LinkKeyRequestReplyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for LinkKeyRequestReplyPacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for LinkKeyRequestReplyBuilder { type ResponseType = LinkKeyRequestReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LinkKeyRequestReplyCompletePacket::new(pkt.event.clone()) }}impl LinkKeyRequestReplyBuilder {pub fn build(self) -> LinkKeyRequestReplyPacket {let link_key_request_reply= Arc::new(LinkKeyRequestReplyData {bd_addr: self.bd_addr, link_key: self.link_key, });let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::LinkKeyRequestReply(link_key_request_reply),});let command= Arc::new(CommandData {op_code: OpCode::LinkKeyRequestReply, child: CommandDataChild::SecurityCommand(security_command),});LinkKeyRequestReplyPacket::new(command)}
}
impl Into<CommandPacket> for LinkKeyRequestReplyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for LinkKeyRequestReplyBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct LinkKeyRequestReplyCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LinkKeyRequestReplyCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,link_key_request_reply_complete: Arc<LinkKeyRequestReplyCompleteData>,}
#[derive(Debug)] pub struct LinkKeyRequestReplyCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LinkKeyRequestReplyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LinkKeyRequestReplyComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LinkKeyRequestReplyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LinkKeyRequestReplyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let link_key_request_reply_complete = match &command_complete.child {CommandCompleteDataChild::LinkKeyRequestReplyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LinkKeyRequestReplyComplete"),};Self {event,command_complete,link_key_request_reply_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.link_key_request_reply_complete.as_ref().status}
}
impl Into<EventPacket> for LinkKeyRequestReplyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LinkKeyRequestReplyCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LinkKeyRequestReplyCompleteBuilder {pub fn build(self) -> LinkKeyRequestReplyCompletePacket {let link_key_request_reply_complete= Arc::new(LinkKeyRequestReplyCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LinkKeyRequestReply, child: CommandCompleteDataChild::LinkKeyRequestReplyComplete(link_key_request_reply_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LinkKeyRequestReplyCompletePacket::new(event)}
}
impl Into<EventPacket> for LinkKeyRequestReplyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LinkKeyRequestReplyCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LinkKeyRequestNegativeReplyData {bd_addr: Address, }
#[derive(Debug, Clone)] pub struct LinkKeyRequestNegativeReplyPacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,link_key_request_negative_reply: Arc<LinkKeyRequestNegativeReplyData>,}
#[derive(Debug)] pub struct LinkKeyRequestNegativeReplyBuilder {pub bd_addr: Address, }
impl LinkKeyRequestNegativeReplyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LinkKeyRequestNegativeReply".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();Ok(Self {bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl CommandExpectations for LinkKeyRequestNegativeReplyPacket { type ResponseType = LinkKeyRequestNegativeReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LinkKeyRequestNegativeReplyCompletePacket::new(pkt.event.clone()) }}impl Packet for LinkKeyRequestNegativeReplyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LinkKeyRequestNegativeReplyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let link_key_request_negative_reply = match &security_command.child {SecurityCommandDataChild::LinkKeyRequestNegativeReply(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LinkKeyRequestNegativeReply"),};Self {command,security_command,link_key_request_negative_reply,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.link_key_request_negative_reply.as_ref().bd_addr}
}
impl Into<CommandPacket> for LinkKeyRequestNegativeReplyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for LinkKeyRequestNegativeReplyPacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for LinkKeyRequestNegativeReplyBuilder { type ResponseType = LinkKeyRequestNegativeReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LinkKeyRequestNegativeReplyCompletePacket::new(pkt.event.clone()) }}impl LinkKeyRequestNegativeReplyBuilder {pub fn build(self) -> LinkKeyRequestNegativeReplyPacket {let link_key_request_negative_reply= Arc::new(LinkKeyRequestNegativeReplyData {bd_addr: self.bd_addr, });let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::LinkKeyRequestNegativeReply(link_key_request_negative_reply),});let command= Arc::new(CommandData {op_code: OpCode::LinkKeyRequestNegativeReply, child: CommandDataChild::SecurityCommand(security_command),});LinkKeyRequestNegativeReplyPacket::new(command)}
}
impl Into<CommandPacket> for LinkKeyRequestNegativeReplyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for LinkKeyRequestNegativeReplyBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct LinkKeyRequestNegativeReplyCompleteData {status: ErrorCode, bd_addr: Address, }
#[derive(Debug, Clone)] pub struct LinkKeyRequestNegativeReplyCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,link_key_request_negative_reply_complete: Arc<LinkKeyRequestNegativeReplyCompleteData>,}
#[derive(Debug)] pub struct LinkKeyRequestNegativeReplyCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub bd_addr: Address, }
impl LinkKeyRequestNegativeReplyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LinkKeyRequestNegativeReplyComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "LinkKeyRequestNegativeReplyComplete".to_string(),    field: "bd_addr".to_string(),    wanted: 12,    got: bytes.len()});}let bd_addr = bytes[6..12].try_into().unwrap();Ok(Self {status, bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let bd_addr: [u8; 6] = self.bd_addr.into();buffer[6..12].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for LinkKeyRequestNegativeReplyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LinkKeyRequestNegativeReplyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let link_key_request_negative_reply_complete = match &command_complete.child {CommandCompleteDataChild::LinkKeyRequestNegativeReplyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LinkKeyRequestNegativeReplyComplete"),};Self {event,command_complete,link_key_request_negative_reply_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.link_key_request_negative_reply_complete.as_ref().status}
pub fn get_bd_addr(&self) -> Address{ self.link_key_request_negative_reply_complete.as_ref().bd_addr}
}
impl Into<EventPacket> for LinkKeyRequestNegativeReplyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LinkKeyRequestNegativeReplyCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LinkKeyRequestNegativeReplyCompleteBuilder {pub fn build(self) -> LinkKeyRequestNegativeReplyCompletePacket {let link_key_request_negative_reply_complete= Arc::new(LinkKeyRequestNegativeReplyCompleteData {status: self.status, bd_addr: self.bd_addr, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LinkKeyRequestNegativeReply, child: CommandCompleteDataChild::LinkKeyRequestNegativeReplyComplete(link_key_request_negative_reply_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LinkKeyRequestNegativeReplyCompletePacket::new(event)}
}
impl Into<EventPacket> for LinkKeyRequestNegativeReplyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LinkKeyRequestNegativeReplyCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct PinCodeRequestReplyData {bd_addr: Address, pin_code_length: u8, pin_code: [u8; 16], }
#[derive(Debug, Clone)] pub struct PinCodeRequestReplyPacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,pin_code_request_reply: Arc<PinCodeRequestReplyData>,}
#[derive(Debug)] pub struct PinCodeRequestReplyBuilder {pub bd_addr: Address, pub pin_code_length: u8, pub pin_code: [u8; 16], }
impl PinCodeRequestReplyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "PinCodeRequestReply".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();let pin_code_length = u8::from_le_bytes([bytes[9]]);let pin_code_length = pin_code_length & 0x1f;if bytes.len() < 26 { return Err(Error::InvalidLengthError{    obj: "PinCodeRequestReply".to_string(),    field: "pin_code".to_string(),    wanted: 26,    got: bytes.len()});}let pin_code = bytes[10..26].try_into().unwrap();Ok(Self {bd_addr, pin_code_length, pin_code, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);let pin_code_length = self.pin_code_length;let pin_code_length = pin_code_length & 0x1f;buffer[9..10].copy_from_slice(&pin_code_length.to_le_bytes()[0..1]);&buffer[10..26].copy_from_slice(&self.pin_code);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 23;ret}
}
impl CommandExpectations for PinCodeRequestReplyPacket { type ResponseType = PinCodeRequestReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { PinCodeRequestReplyCompletePacket::new(pkt.event.clone()) }}impl Packet for PinCodeRequestReplyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl PinCodeRequestReplyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let pin_code_request_reply = match &security_command.child {SecurityCommandDataChild::PinCodeRequestReply(value) => (*value).clone(),_ => panic!("inconsistent state - child was not PinCodeRequestReply"),};Self {command,security_command,pin_code_request_reply,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.pin_code_request_reply.as_ref().bd_addr}
pub fn get_pin_code_length(&self) -> u8{ self.pin_code_request_reply.as_ref().pin_code_length}
pub fn get_pin_code(&self) -> &[u8; 16]{ &self.pin_code_request_reply.as_ref().pin_code}
}
impl Into<CommandPacket> for PinCodeRequestReplyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for PinCodeRequestReplyPacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for PinCodeRequestReplyBuilder { type ResponseType = PinCodeRequestReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { PinCodeRequestReplyCompletePacket::new(pkt.event.clone()) }}impl PinCodeRequestReplyBuilder {pub fn build(self) -> PinCodeRequestReplyPacket {let pin_code_request_reply= Arc::new(PinCodeRequestReplyData {bd_addr: self.bd_addr, pin_code_length: self.pin_code_length, pin_code: self.pin_code, });let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::PinCodeRequestReply(pin_code_request_reply),});let command= Arc::new(CommandData {op_code: OpCode::PinCodeRequestReply, child: CommandDataChild::SecurityCommand(security_command),});PinCodeRequestReplyPacket::new(command)}
}
impl Into<CommandPacket> for PinCodeRequestReplyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for PinCodeRequestReplyBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct PinCodeRequestReplyCompleteData {status: ErrorCode, bd_addr: Address, }
#[derive(Debug, Clone)] pub struct PinCodeRequestReplyCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,pin_code_request_reply_complete: Arc<PinCodeRequestReplyCompleteData>,}
#[derive(Debug)] pub struct PinCodeRequestReplyCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub bd_addr: Address, }
impl PinCodeRequestReplyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "PinCodeRequestReplyComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "PinCodeRequestReplyComplete".to_string(),    field: "bd_addr".to_string(),    wanted: 12,    got: bytes.len()});}let bd_addr = bytes[6..12].try_into().unwrap();Ok(Self {status, bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let bd_addr: [u8; 6] = self.bd_addr.into();buffer[6..12].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for PinCodeRequestReplyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl PinCodeRequestReplyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let pin_code_request_reply_complete = match &command_complete.child {CommandCompleteDataChild::PinCodeRequestReplyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not PinCodeRequestReplyComplete"),};Self {event,command_complete,pin_code_request_reply_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.pin_code_request_reply_complete.as_ref().status}
pub fn get_bd_addr(&self) -> Address{ self.pin_code_request_reply_complete.as_ref().bd_addr}
}
impl Into<EventPacket> for PinCodeRequestReplyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for PinCodeRequestReplyCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl PinCodeRequestReplyCompleteBuilder {pub fn build(self) -> PinCodeRequestReplyCompletePacket {let pin_code_request_reply_complete= Arc::new(PinCodeRequestReplyCompleteData {status: self.status, bd_addr: self.bd_addr, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::PinCodeRequestReply, child: CommandCompleteDataChild::PinCodeRequestReplyComplete(pin_code_request_reply_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});PinCodeRequestReplyCompletePacket::new(event)}
}
impl Into<EventPacket> for PinCodeRequestReplyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for PinCodeRequestReplyCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct PinCodeRequestNegativeReplyData {bd_addr: Address, }
#[derive(Debug, Clone)] pub struct PinCodeRequestNegativeReplyPacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,pin_code_request_negative_reply: Arc<PinCodeRequestNegativeReplyData>,}
#[derive(Debug)] pub struct PinCodeRequestNegativeReplyBuilder {pub bd_addr: Address, }
impl PinCodeRequestNegativeReplyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "PinCodeRequestNegativeReply".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();Ok(Self {bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl CommandExpectations for PinCodeRequestNegativeReplyPacket { type ResponseType = PinCodeRequestNegativeReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { PinCodeRequestNegativeReplyCompletePacket::new(pkt.event.clone()) }}impl Packet for PinCodeRequestNegativeReplyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl PinCodeRequestNegativeReplyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let pin_code_request_negative_reply = match &security_command.child {SecurityCommandDataChild::PinCodeRequestNegativeReply(value) => (*value).clone(),_ => panic!("inconsistent state - child was not PinCodeRequestNegativeReply"),};Self {command,security_command,pin_code_request_negative_reply,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.pin_code_request_negative_reply.as_ref().bd_addr}
}
impl Into<CommandPacket> for PinCodeRequestNegativeReplyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for PinCodeRequestNegativeReplyPacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for PinCodeRequestNegativeReplyBuilder { type ResponseType = PinCodeRequestNegativeReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { PinCodeRequestNegativeReplyCompletePacket::new(pkt.event.clone()) }}impl PinCodeRequestNegativeReplyBuilder {pub fn build(self) -> PinCodeRequestNegativeReplyPacket {let pin_code_request_negative_reply= Arc::new(PinCodeRequestNegativeReplyData {bd_addr: self.bd_addr, });let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::PinCodeRequestNegativeReply(pin_code_request_negative_reply),});let command= Arc::new(CommandData {op_code: OpCode::PinCodeRequestNegativeReply, child: CommandDataChild::SecurityCommand(security_command),});PinCodeRequestNegativeReplyPacket::new(command)}
}
impl Into<CommandPacket> for PinCodeRequestNegativeReplyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for PinCodeRequestNegativeReplyBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct PinCodeRequestNegativeReplyCompleteData {status: ErrorCode, bd_addr: Address, }
#[derive(Debug, Clone)] pub struct PinCodeRequestNegativeReplyCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,pin_code_request_negative_reply_complete: Arc<PinCodeRequestNegativeReplyCompleteData>,}
#[derive(Debug)] pub struct PinCodeRequestNegativeReplyCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub bd_addr: Address, }
impl PinCodeRequestNegativeReplyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "PinCodeRequestNegativeReplyComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "PinCodeRequestNegativeReplyComplete".to_string(),    field: "bd_addr".to_string(),    wanted: 12,    got: bytes.len()});}let bd_addr = bytes[6..12].try_into().unwrap();Ok(Self {status, bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let bd_addr: [u8; 6] = self.bd_addr.into();buffer[6..12].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for PinCodeRequestNegativeReplyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl PinCodeRequestNegativeReplyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let pin_code_request_negative_reply_complete = match &command_complete.child {CommandCompleteDataChild::PinCodeRequestNegativeReplyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not PinCodeRequestNegativeReplyComplete"),};Self {event,command_complete,pin_code_request_negative_reply_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.pin_code_request_negative_reply_complete.as_ref().status}
pub fn get_bd_addr(&self) -> Address{ self.pin_code_request_negative_reply_complete.as_ref().bd_addr}
}
impl Into<EventPacket> for PinCodeRequestNegativeReplyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for PinCodeRequestNegativeReplyCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl PinCodeRequestNegativeReplyCompleteBuilder {pub fn build(self) -> PinCodeRequestNegativeReplyCompletePacket {let pin_code_request_negative_reply_complete= Arc::new(PinCodeRequestNegativeReplyCompleteData {status: self.status, bd_addr: self.bd_addr, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::PinCodeRequestNegativeReply, child: CommandCompleteDataChild::PinCodeRequestNegativeReplyComplete(pin_code_request_negative_reply_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});PinCodeRequestNegativeReplyCompletePacket::new(event)}
}
impl Into<EventPacket> for PinCodeRequestNegativeReplyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for PinCodeRequestNegativeReplyCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ChangeConnectionPacketTypeData {connection_handle: u16, packet_type: u16, }
#[derive(Debug, Clone)] pub struct ChangeConnectionPacketTypePacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,change_connection_packet_type: Arc<ChangeConnectionPacketTypeData>,}
#[derive(Debug)] pub struct ChangeConnectionPacketTypeBuilder {pub connection_handle: u16, pub packet_type: u16, }
impl ChangeConnectionPacketTypeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ChangeConnectionPacketType".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ChangeConnectionPacketType".to_string(),    field: "packet_type".to_string(),    wanted: 7,    got: bytes.len()});}let packet_type = u16::from_le_bytes([bytes[5],bytes[6]]);Ok(Self {connection_handle, packet_type, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let packet_type = self.packet_type;buffer[5..7].copy_from_slice(&packet_type.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl CommandExpectations for ChangeConnectionPacketTypePacket { type ResponseType = ChangeConnectionPacketTypeStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ChangeConnectionPacketTypeStatusPacket::new(pkt.event.clone()) }}impl Packet for ChangeConnectionPacketTypePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ChangeConnectionPacketTypePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let change_connection_packet_type = match &connection_management_command.child {ConnectionManagementCommandDataChild::ChangeConnectionPacketType(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ChangeConnectionPacketType"),};Self {command,acl_command,connection_management_command,change_connection_packet_type,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.change_connection_packet_type.as_ref().connection_handle}
pub fn get_packet_type(&self) -> u16{ self.change_connection_packet_type.as_ref().packet_type}
}
impl Into<CommandPacket> for ChangeConnectionPacketTypePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for ChangeConnectionPacketTypePacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for ChangeConnectionPacketTypePacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for ChangeConnectionPacketTypeBuilder { type ResponseType = ChangeConnectionPacketTypeStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ChangeConnectionPacketTypeStatusPacket::new(pkt.event.clone()) }}impl ChangeConnectionPacketTypeBuilder {pub fn build(self) -> ChangeConnectionPacketTypePacket {let change_connection_packet_type= Arc::new(ChangeConnectionPacketTypeData {connection_handle: self.connection_handle, packet_type: self.packet_type, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::ChangeConnectionPacketType(change_connection_packet_type),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::ChangeConnectionPacketType, child: CommandDataChild::AclCommand(acl_command),});ChangeConnectionPacketTypePacket::new(command)}
}
impl Into<CommandPacket> for ChangeConnectionPacketTypeBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for ChangeConnectionPacketTypeBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for ChangeConnectionPacketTypeBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct ChangeConnectionPacketTypeStatusData {}
#[derive(Debug, Clone)] pub struct ChangeConnectionPacketTypeStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,change_connection_packet_type_status: Arc<ChangeConnectionPacketTypeStatusData>,}
#[derive(Debug)] pub struct ChangeConnectionPacketTypeStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl ChangeConnectionPacketTypeStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for ChangeConnectionPacketTypeStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ChangeConnectionPacketTypeStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let change_connection_packet_type_status = match &command_status.child {CommandStatusDataChild::ChangeConnectionPacketTypeStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ChangeConnectionPacketTypeStatus"),};Self {event,command_status,change_connection_packet_type_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for ChangeConnectionPacketTypeStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for ChangeConnectionPacketTypeStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl ChangeConnectionPacketTypeStatusBuilder {pub fn build(self) -> ChangeConnectionPacketTypeStatusPacket {let change_connection_packet_type_status= Arc::new(ChangeConnectionPacketTypeStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ChangeConnectionPacketType, child: CommandStatusDataChild::ChangeConnectionPacketTypeStatus(change_connection_packet_type_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});ChangeConnectionPacketTypeStatusPacket::new(event)}
}
impl Into<EventPacket> for ChangeConnectionPacketTypeStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for ChangeConnectionPacketTypeStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct AuthenticationRequestedData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct AuthenticationRequestedPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,authentication_requested: Arc<AuthenticationRequestedData>,}
#[derive(Debug)] pub struct AuthenticationRequestedBuilder {pub connection_handle: u16, }
impl AuthenticationRequestedData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "AuthenticationRequested".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for AuthenticationRequestedPacket { type ResponseType = AuthenticationRequestedStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { AuthenticationRequestedStatusPacket::new(pkt.event.clone()) }}impl Packet for AuthenticationRequestedPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl AuthenticationRequestedPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let authentication_requested = match &connection_management_command.child {ConnectionManagementCommandDataChild::AuthenticationRequested(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AuthenticationRequested"),};Self {command,acl_command,connection_management_command,authentication_requested,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.authentication_requested.as_ref().connection_handle}
}
impl Into<CommandPacket> for AuthenticationRequestedPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for AuthenticationRequestedPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for AuthenticationRequestedPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for AuthenticationRequestedBuilder { type ResponseType = AuthenticationRequestedStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { AuthenticationRequestedStatusPacket::new(pkt.event.clone()) }}impl AuthenticationRequestedBuilder {pub fn build(self) -> AuthenticationRequestedPacket {let authentication_requested= Arc::new(AuthenticationRequestedData {connection_handle: self.connection_handle, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::AuthenticationRequested(authentication_requested),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::AuthenticationRequested, child: CommandDataChild::AclCommand(acl_command),});AuthenticationRequestedPacket::new(command)}
}
impl Into<CommandPacket> for AuthenticationRequestedBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for AuthenticationRequestedBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for AuthenticationRequestedBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct AuthenticationRequestedStatusData {}
#[derive(Debug, Clone)] pub struct AuthenticationRequestedStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,authentication_requested_status: Arc<AuthenticationRequestedStatusData>,}
#[derive(Debug)] pub struct AuthenticationRequestedStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl AuthenticationRequestedStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for AuthenticationRequestedStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl AuthenticationRequestedStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let authentication_requested_status = match &command_status.child {CommandStatusDataChild::AuthenticationRequestedStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AuthenticationRequestedStatus"),};Self {event,command_status,authentication_requested_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for AuthenticationRequestedStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for AuthenticationRequestedStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl AuthenticationRequestedStatusBuilder {pub fn build(self) -> AuthenticationRequestedStatusPacket {let authentication_requested_status= Arc::new(AuthenticationRequestedStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::AuthenticationRequested, child: CommandStatusDataChild::AuthenticationRequestedStatus(authentication_requested_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});AuthenticationRequestedStatusPacket::new(event)}
}
impl Into<EventPacket> for AuthenticationRequestedStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for AuthenticationRequestedStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct SetConnectionEncryptionData {connection_handle: u16, encryption_enable: Enable, }
#[derive(Debug, Clone)] pub struct SetConnectionEncryptionPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,set_connection_encryption: Arc<SetConnectionEncryptionData>,}
#[derive(Debug)] pub struct SetConnectionEncryptionBuilder {pub connection_handle: u16, pub encryption_enable: Enable, }
impl SetConnectionEncryptionData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "SetConnectionEncryption".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "SetConnectionEncryption".to_string(),    field: "encryption_enable".to_string(),    wanted: 6,    got: bytes.len()});}let encryption_enable = u8::from_le_bytes([bytes[5]]);let encryption_enable = Enable::from_u8(encryption_enable).unwrap();Ok(Self {connection_handle, encryption_enable, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let encryption_enable = self.encryption_enable.to_u8().unwrap();buffer[5..6].copy_from_slice(&encryption_enable.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl CommandExpectations for SetConnectionEncryptionPacket { type ResponseType = SetConnectionEncryptionStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { SetConnectionEncryptionStatusPacket::new(pkt.event.clone()) }}impl Packet for SetConnectionEncryptionPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SetConnectionEncryptionPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let set_connection_encryption = match &connection_management_command.child {ConnectionManagementCommandDataChild::SetConnectionEncryption(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetConnectionEncryption"),};Self {command,acl_command,connection_management_command,set_connection_encryption,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.set_connection_encryption.as_ref().connection_handle}
pub fn get_encryption_enable(&self) -> Enable{ self.set_connection_encryption.as_ref().encryption_enable}
}
impl Into<CommandPacket> for SetConnectionEncryptionPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for SetConnectionEncryptionPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for SetConnectionEncryptionPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for SetConnectionEncryptionBuilder { type ResponseType = SetConnectionEncryptionStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { SetConnectionEncryptionStatusPacket::new(pkt.event.clone()) }}impl SetConnectionEncryptionBuilder {pub fn build(self) -> SetConnectionEncryptionPacket {let set_connection_encryption= Arc::new(SetConnectionEncryptionData {connection_handle: self.connection_handle, encryption_enable: self.encryption_enable, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::SetConnectionEncryption(set_connection_encryption),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::SetConnectionEncryption, child: CommandDataChild::AclCommand(acl_command),});SetConnectionEncryptionPacket::new(command)}
}
impl Into<CommandPacket> for SetConnectionEncryptionBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for SetConnectionEncryptionBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for SetConnectionEncryptionBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct SetConnectionEncryptionStatusData {}
#[derive(Debug, Clone)] pub struct SetConnectionEncryptionStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,set_connection_encryption_status: Arc<SetConnectionEncryptionStatusData>,}
#[derive(Debug)] pub struct SetConnectionEncryptionStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl SetConnectionEncryptionStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for SetConnectionEncryptionStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SetConnectionEncryptionStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let set_connection_encryption_status = match &command_status.child {CommandStatusDataChild::SetConnectionEncryptionStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetConnectionEncryptionStatus"),};Self {event,command_status,set_connection_encryption_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for SetConnectionEncryptionStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for SetConnectionEncryptionStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl SetConnectionEncryptionStatusBuilder {pub fn build(self) -> SetConnectionEncryptionStatusPacket {let set_connection_encryption_status= Arc::new(SetConnectionEncryptionStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::SetConnectionEncryption, child: CommandStatusDataChild::SetConnectionEncryptionStatus(set_connection_encryption_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});SetConnectionEncryptionStatusPacket::new(event)}
}
impl Into<EventPacket> for SetConnectionEncryptionStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for SetConnectionEncryptionStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct ChangeConnectionLinkKeyData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct ChangeConnectionLinkKeyPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,change_connection_link_key: Arc<ChangeConnectionLinkKeyData>,}
#[derive(Debug)] pub struct ChangeConnectionLinkKeyBuilder {pub connection_handle: u16, }
impl ChangeConnectionLinkKeyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ChangeConnectionLinkKey".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for ChangeConnectionLinkKeyPacket { type ResponseType = ChangeConnectionLinkKeyStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ChangeConnectionLinkKeyStatusPacket::new(pkt.event.clone()) }}impl Packet for ChangeConnectionLinkKeyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ChangeConnectionLinkKeyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let change_connection_link_key = match &connection_management_command.child {ConnectionManagementCommandDataChild::ChangeConnectionLinkKey(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ChangeConnectionLinkKey"),};Self {command,acl_command,connection_management_command,change_connection_link_key,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.change_connection_link_key.as_ref().connection_handle}
}
impl Into<CommandPacket> for ChangeConnectionLinkKeyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for ChangeConnectionLinkKeyPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for ChangeConnectionLinkKeyPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for ChangeConnectionLinkKeyBuilder { type ResponseType = ChangeConnectionLinkKeyStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ChangeConnectionLinkKeyStatusPacket::new(pkt.event.clone()) }}impl ChangeConnectionLinkKeyBuilder {pub fn build(self) -> ChangeConnectionLinkKeyPacket {let change_connection_link_key= Arc::new(ChangeConnectionLinkKeyData {connection_handle: self.connection_handle, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::ChangeConnectionLinkKey(change_connection_link_key),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::ChangeConnectionLinkKey, child: CommandDataChild::AclCommand(acl_command),});ChangeConnectionLinkKeyPacket::new(command)}
}
impl Into<CommandPacket> for ChangeConnectionLinkKeyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for ChangeConnectionLinkKeyBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for ChangeConnectionLinkKeyBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct ChangeConnectionLinkKeyStatusData {}
#[derive(Debug, Clone)] pub struct ChangeConnectionLinkKeyStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,change_connection_link_key_status: Arc<ChangeConnectionLinkKeyStatusData>,}
#[derive(Debug)] pub struct ChangeConnectionLinkKeyStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl ChangeConnectionLinkKeyStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for ChangeConnectionLinkKeyStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ChangeConnectionLinkKeyStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let change_connection_link_key_status = match &command_status.child {CommandStatusDataChild::ChangeConnectionLinkKeyStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ChangeConnectionLinkKeyStatus"),};Self {event,command_status,change_connection_link_key_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for ChangeConnectionLinkKeyStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for ChangeConnectionLinkKeyStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl ChangeConnectionLinkKeyStatusBuilder {pub fn build(self) -> ChangeConnectionLinkKeyStatusPacket {let change_connection_link_key_status= Arc::new(ChangeConnectionLinkKeyStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ChangeConnectionLinkKey, child: CommandStatusDataChild::ChangeConnectionLinkKeyStatus(change_connection_link_key_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});ChangeConnectionLinkKeyStatusPacket::new(event)}
}
impl Into<EventPacket> for ChangeConnectionLinkKeyStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for ChangeConnectionLinkKeyStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct CentralLinkKeyData {key_flag: KeyFlag, }
#[derive(Debug, Clone)] pub struct CentralLinkKeyPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,central_link_key: Arc<CentralLinkKeyData>,}
#[derive(Debug)] pub struct CentralLinkKeyBuilder {pub key_flag: KeyFlag, }
impl CentralLinkKeyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "CentralLinkKey".to_string(),    field: "key_flag".to_string(),    wanted: 4,    got: bytes.len()});}let key_flag = u8::from_le_bytes([bytes[3]]);let key_flag = KeyFlag::from_u8(key_flag).unwrap();Ok(Self {key_flag, })
}
fn write_to(&self, buffer: &mut BytesMut) {let key_flag = self.key_flag.to_u8().unwrap();buffer[3..4].copy_from_slice(&key_flag.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for CentralLinkKeyPacket { type ResponseType = CentralLinkKeyStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { CentralLinkKeyStatusPacket::new(pkt.event.clone()) }}impl Packet for CentralLinkKeyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl CentralLinkKeyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let central_link_key = match &connection_management_command.child {ConnectionManagementCommandDataChild::CentralLinkKey(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CentralLinkKey"),};Self {command,acl_command,connection_management_command,central_link_key,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_key_flag(&self) -> KeyFlag{ self.central_link_key.as_ref().key_flag}
}
impl Into<CommandPacket> for CentralLinkKeyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for CentralLinkKeyPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for CentralLinkKeyPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for CentralLinkKeyBuilder { type ResponseType = CentralLinkKeyStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { CentralLinkKeyStatusPacket::new(pkt.event.clone()) }}impl CentralLinkKeyBuilder {pub fn build(self) -> CentralLinkKeyPacket {let central_link_key= Arc::new(CentralLinkKeyData {key_flag: self.key_flag, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::CentralLinkKey(central_link_key),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::CentralLinkKey, child: CommandDataChild::AclCommand(acl_command),});CentralLinkKeyPacket::new(command)}
}
impl Into<CommandPacket> for CentralLinkKeyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for CentralLinkKeyBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for CentralLinkKeyBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct CentralLinkKeyStatusData {}
#[derive(Debug, Clone)] pub struct CentralLinkKeyStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,central_link_key_status: Arc<CentralLinkKeyStatusData>,}
#[derive(Debug)] pub struct CentralLinkKeyStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl CentralLinkKeyStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for CentralLinkKeyStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl CentralLinkKeyStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let central_link_key_status = match &command_status.child {CommandStatusDataChild::CentralLinkKeyStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CentralLinkKeyStatus"),};Self {event,command_status,central_link_key_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for CentralLinkKeyStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for CentralLinkKeyStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl CentralLinkKeyStatusBuilder {pub fn build(self) -> CentralLinkKeyStatusPacket {let central_link_key_status= Arc::new(CentralLinkKeyStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::CentralLinkKey, child: CommandStatusDataChild::CentralLinkKeyStatus(central_link_key_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});CentralLinkKeyStatusPacket::new(event)}
}
impl Into<EventPacket> for CentralLinkKeyStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for CentralLinkKeyStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct RemoteNameRequestData {bd_addr: Address, page_scan_repetition_mode: PageScanRepetitionMode, clock_offset: u16, clock_offset_valid: ClockOffsetValid, }
#[derive(Debug, Clone)] pub struct RemoteNameRequestPacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,remote_name_request: Arc<RemoteNameRequestData>,}
#[derive(Debug)] pub struct RemoteNameRequestBuilder {pub bd_addr: Address, pub page_scan_repetition_mode: PageScanRepetitionMode, pub clock_offset: u16, pub clock_offset_valid: ClockOffsetValid, }
impl RemoteNameRequestData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "RemoteNameRequest".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "RemoteNameRequest".to_string(),    field: "page_scan_repetition_mode".to_string(),    wanted: 10,    got: bytes.len()});}let page_scan_repetition_mode = u8::from_le_bytes([bytes[9]]);let page_scan_repetition_mode = PageScanRepetitionMode::from_u8(page_scan_repetition_mode).unwrap();if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "RemoteNameRequest".to_string(),    field: "clock_offset".to_string(),    wanted: 13,    got: bytes.len()});}let clock_offset = u16::from_le_bytes([bytes[11],bytes[12]]);let clock_offset = clock_offset & 0x7fff;let clock_offset_valid = u8::from_le_bytes([bytes[12]]);let clock_offset_valid = clock_offset_valid >> 7;let clock_offset_valid = clock_offset_valid & 0x1;let clock_offset_valid = ClockOffsetValid::from_u8(clock_offset_valid).unwrap();Ok(Self {bd_addr, page_scan_repetition_mode, clock_offset, clock_offset_valid, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);let page_scan_repetition_mode = self.page_scan_repetition_mode.to_u8().unwrap();buffer[9..10].copy_from_slice(&page_scan_repetition_mode.to_le_bytes()[0..1]);let clock_offset = self.clock_offset;let clock_offset = clock_offset & 0x7fff;buffer[11..13].copy_from_slice(&clock_offset.to_le_bytes()[0..2]);let clock_offset_valid = self.clock_offset_valid.to_u8().unwrap();let clock_offset_valid = clock_offset_valid & 0x1;let clock_offset_valid = (clock_offset_valid << 7) | ((buffer[12] as u8) & 0x7f);buffer[12..13].copy_from_slice(&clock_offset_valid.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 10;ret}
}
impl CommandExpectations for RemoteNameRequestPacket { type ResponseType = RemoteNameRequestStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { RemoteNameRequestStatusPacket::new(pkt.event.clone()) }}impl Packet for RemoteNameRequestPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl RemoteNameRequestPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let remote_name_request = match &discovery_command.child {DiscoveryCommandDataChild::RemoteNameRequest(value) => (*value).clone(),_ => panic!("inconsistent state - child was not RemoteNameRequest"),};Self {command,discovery_command,remote_name_request,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.remote_name_request.as_ref().bd_addr}
pub fn get_page_scan_repetition_mode(&self) -> PageScanRepetitionMode{ self.remote_name_request.as_ref().page_scan_repetition_mode}
pub fn get_clock_offset(&self) -> u16{ self.remote_name_request.as_ref().clock_offset}
pub fn get_clock_offset_valid(&self) -> ClockOffsetValid{ self.remote_name_request.as_ref().clock_offset_valid}
}
impl Into<CommandPacket> for RemoteNameRequestPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for RemoteNameRequestPacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for RemoteNameRequestBuilder { type ResponseType = RemoteNameRequestStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { RemoteNameRequestStatusPacket::new(pkt.event.clone()) }}impl RemoteNameRequestBuilder {pub fn build(self) -> RemoteNameRequestPacket {let remote_name_request= Arc::new(RemoteNameRequestData {bd_addr: self.bd_addr, page_scan_repetition_mode: self.page_scan_repetition_mode, clock_offset: self.clock_offset, clock_offset_valid: self.clock_offset_valid, });let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::RemoteNameRequest(remote_name_request),});let command= Arc::new(CommandData {op_code: OpCode::RemoteNameRequest, child: CommandDataChild::DiscoveryCommand(discovery_command),});RemoteNameRequestPacket::new(command)}
}
impl Into<CommandPacket> for RemoteNameRequestBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for RemoteNameRequestBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}


#[derive(Debug)] struct RemoteNameRequestStatusData {}
#[derive(Debug, Clone)] pub struct RemoteNameRequestStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,remote_name_request_status: Arc<RemoteNameRequestStatusData>,}
#[derive(Debug)] pub struct RemoteNameRequestStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl RemoteNameRequestStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for RemoteNameRequestStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl RemoteNameRequestStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let remote_name_request_status = match &command_status.child {CommandStatusDataChild::RemoteNameRequestStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not RemoteNameRequestStatus"),};Self {event,command_status,remote_name_request_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for RemoteNameRequestStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for RemoteNameRequestStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl RemoteNameRequestStatusBuilder {pub fn build(self) -> RemoteNameRequestStatusPacket {let remote_name_request_status= Arc::new(RemoteNameRequestStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::RemoteNameRequest, child: CommandStatusDataChild::RemoteNameRequestStatus(remote_name_request_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});RemoteNameRequestStatusPacket::new(event)}
}
impl Into<EventPacket> for RemoteNameRequestStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for RemoteNameRequestStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct RemoteNameRequestCancelData {bd_addr: Address, }
#[derive(Debug, Clone)] pub struct RemoteNameRequestCancelPacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,remote_name_request_cancel: Arc<RemoteNameRequestCancelData>,}
#[derive(Debug)] pub struct RemoteNameRequestCancelBuilder {pub bd_addr: Address, }
impl RemoteNameRequestCancelData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "RemoteNameRequestCancel".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();Ok(Self {bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl CommandExpectations for RemoteNameRequestCancelPacket { type ResponseType = RemoteNameRequestCancelCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { RemoteNameRequestCancelCompletePacket::new(pkt.event.clone()) }}impl Packet for RemoteNameRequestCancelPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl RemoteNameRequestCancelPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let remote_name_request_cancel = match &discovery_command.child {DiscoveryCommandDataChild::RemoteNameRequestCancel(value) => (*value).clone(),_ => panic!("inconsistent state - child was not RemoteNameRequestCancel"),};Self {command,discovery_command,remote_name_request_cancel,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.remote_name_request_cancel.as_ref().bd_addr}
}
impl Into<CommandPacket> for RemoteNameRequestCancelPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for RemoteNameRequestCancelPacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for RemoteNameRequestCancelBuilder { type ResponseType = RemoteNameRequestCancelCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { RemoteNameRequestCancelCompletePacket::new(pkt.event.clone()) }}impl RemoteNameRequestCancelBuilder {pub fn build(self) -> RemoteNameRequestCancelPacket {let remote_name_request_cancel= Arc::new(RemoteNameRequestCancelData {bd_addr: self.bd_addr, });let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::RemoteNameRequestCancel(remote_name_request_cancel),});let command= Arc::new(CommandData {op_code: OpCode::RemoteNameRequestCancel, child: CommandDataChild::DiscoveryCommand(discovery_command),});RemoteNameRequestCancelPacket::new(command)}
}
impl Into<CommandPacket> for RemoteNameRequestCancelBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for RemoteNameRequestCancelBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}


#[derive(Debug)] struct RemoteNameRequestCancelCompleteData {status: ErrorCode, bd_addr: Address, }
#[derive(Debug, Clone)] pub struct RemoteNameRequestCancelCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,remote_name_request_cancel_complete: Arc<RemoteNameRequestCancelCompleteData>,}
#[derive(Debug)] pub struct RemoteNameRequestCancelCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub bd_addr: Address, }
impl RemoteNameRequestCancelCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "RemoteNameRequestCancelComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "RemoteNameRequestCancelComplete".to_string(),    field: "bd_addr".to_string(),    wanted: 12,    got: bytes.len()});}let bd_addr = bytes[6..12].try_into().unwrap();Ok(Self {status, bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let bd_addr: [u8; 6] = self.bd_addr.into();buffer[6..12].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for RemoteNameRequestCancelCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl RemoteNameRequestCancelCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let remote_name_request_cancel_complete = match &command_complete.child {CommandCompleteDataChild::RemoteNameRequestCancelComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not RemoteNameRequestCancelComplete"),};Self {event,command_complete,remote_name_request_cancel_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.remote_name_request_cancel_complete.as_ref().status}
pub fn get_bd_addr(&self) -> Address{ self.remote_name_request_cancel_complete.as_ref().bd_addr}
}
impl Into<EventPacket> for RemoteNameRequestCancelCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for RemoteNameRequestCancelCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl RemoteNameRequestCancelCompleteBuilder {pub fn build(self) -> RemoteNameRequestCancelCompletePacket {let remote_name_request_cancel_complete= Arc::new(RemoteNameRequestCancelCompleteData {status: self.status, bd_addr: self.bd_addr, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::RemoteNameRequestCancel, child: CommandCompleteDataChild::RemoteNameRequestCancelComplete(remote_name_request_cancel_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});RemoteNameRequestCancelCompletePacket::new(event)}
}
impl Into<EventPacket> for RemoteNameRequestCancelCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for RemoteNameRequestCancelCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadRemoteSupportedFeaturesData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct ReadRemoteSupportedFeaturesPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,read_remote_supported_features: Arc<ReadRemoteSupportedFeaturesData>,}
#[derive(Debug)] pub struct ReadRemoteSupportedFeaturesBuilder {pub connection_handle: u16, }
impl ReadRemoteSupportedFeaturesData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ReadRemoteSupportedFeatures".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for ReadRemoteSupportedFeaturesPacket { type ResponseType = ReadRemoteSupportedFeaturesStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadRemoteSupportedFeaturesStatusPacket::new(pkt.event.clone()) }}impl Packet for ReadRemoteSupportedFeaturesPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadRemoteSupportedFeaturesPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let read_remote_supported_features = match &connection_management_command.child {ConnectionManagementCommandDataChild::ReadRemoteSupportedFeatures(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadRemoteSupportedFeatures"),};Self {command,acl_command,connection_management_command,read_remote_supported_features,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.read_remote_supported_features.as_ref().connection_handle}
}
impl Into<CommandPacket> for ReadRemoteSupportedFeaturesPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for ReadRemoteSupportedFeaturesPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for ReadRemoteSupportedFeaturesPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for ReadRemoteSupportedFeaturesBuilder { type ResponseType = ReadRemoteSupportedFeaturesStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadRemoteSupportedFeaturesStatusPacket::new(pkt.event.clone()) }}impl ReadRemoteSupportedFeaturesBuilder {pub fn build(self) -> ReadRemoteSupportedFeaturesPacket {let read_remote_supported_features= Arc::new(ReadRemoteSupportedFeaturesData {connection_handle: self.connection_handle, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::ReadRemoteSupportedFeatures(read_remote_supported_features),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::ReadRemoteSupportedFeatures, child: CommandDataChild::AclCommand(acl_command),});ReadRemoteSupportedFeaturesPacket::new(command)}
}
impl Into<CommandPacket> for ReadRemoteSupportedFeaturesBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for ReadRemoteSupportedFeaturesBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for ReadRemoteSupportedFeaturesBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadRemoteSupportedFeaturesStatusData {}
#[derive(Debug, Clone)] pub struct ReadRemoteSupportedFeaturesStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,read_remote_supported_features_status: Arc<ReadRemoteSupportedFeaturesStatusData>,}
#[derive(Debug)] pub struct ReadRemoteSupportedFeaturesStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl ReadRemoteSupportedFeaturesStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for ReadRemoteSupportedFeaturesStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadRemoteSupportedFeaturesStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let read_remote_supported_features_status = match &command_status.child {CommandStatusDataChild::ReadRemoteSupportedFeaturesStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadRemoteSupportedFeaturesStatus"),};Self {event,command_status,read_remote_supported_features_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for ReadRemoteSupportedFeaturesStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for ReadRemoteSupportedFeaturesStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl ReadRemoteSupportedFeaturesStatusBuilder {pub fn build(self) -> ReadRemoteSupportedFeaturesStatusPacket {let read_remote_supported_features_status= Arc::new(ReadRemoteSupportedFeaturesStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadRemoteSupportedFeatures, child: CommandStatusDataChild::ReadRemoteSupportedFeaturesStatus(read_remote_supported_features_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});ReadRemoteSupportedFeaturesStatusPacket::new(event)}
}
impl Into<EventPacket> for ReadRemoteSupportedFeaturesStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for ReadRemoteSupportedFeaturesStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct ReadRemoteExtendedFeaturesData {connection_handle: u16, page_number: u8, }
#[derive(Debug, Clone)] pub struct ReadRemoteExtendedFeaturesPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,read_remote_extended_features: Arc<ReadRemoteExtendedFeaturesData>,}
#[derive(Debug)] pub struct ReadRemoteExtendedFeaturesBuilder {pub connection_handle: u16, pub page_number: u8, }
impl ReadRemoteExtendedFeaturesData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ReadRemoteExtendedFeatures".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadRemoteExtendedFeatures".to_string(),    field: "page_number".to_string(),    wanted: 6,    got: bytes.len()});}let page_number = u8::from_le_bytes([bytes[5]]);Ok(Self {connection_handle, page_number, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let page_number = self.page_number;buffer[5..6].copy_from_slice(&page_number.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl CommandExpectations for ReadRemoteExtendedFeaturesPacket { type ResponseType = ReadRemoteExtendedFeaturesStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadRemoteExtendedFeaturesStatusPacket::new(pkt.event.clone()) }}impl Packet for ReadRemoteExtendedFeaturesPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadRemoteExtendedFeaturesPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let read_remote_extended_features = match &connection_management_command.child {ConnectionManagementCommandDataChild::ReadRemoteExtendedFeatures(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadRemoteExtendedFeatures"),};Self {command,acl_command,connection_management_command,read_remote_extended_features,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.read_remote_extended_features.as_ref().connection_handle}
pub fn get_page_number(&self) -> u8{ self.read_remote_extended_features.as_ref().page_number}
}
impl Into<CommandPacket> for ReadRemoteExtendedFeaturesPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for ReadRemoteExtendedFeaturesPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for ReadRemoteExtendedFeaturesPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for ReadRemoteExtendedFeaturesBuilder { type ResponseType = ReadRemoteExtendedFeaturesStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadRemoteExtendedFeaturesStatusPacket::new(pkt.event.clone()) }}impl ReadRemoteExtendedFeaturesBuilder {pub fn build(self) -> ReadRemoteExtendedFeaturesPacket {let read_remote_extended_features= Arc::new(ReadRemoteExtendedFeaturesData {connection_handle: self.connection_handle, page_number: self.page_number, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::ReadRemoteExtendedFeatures(read_remote_extended_features),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::ReadRemoteExtendedFeatures, child: CommandDataChild::AclCommand(acl_command),});ReadRemoteExtendedFeaturesPacket::new(command)}
}
impl Into<CommandPacket> for ReadRemoteExtendedFeaturesBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for ReadRemoteExtendedFeaturesBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for ReadRemoteExtendedFeaturesBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadRemoteExtendedFeaturesStatusData {}
#[derive(Debug, Clone)] pub struct ReadRemoteExtendedFeaturesStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,read_remote_extended_features_status: Arc<ReadRemoteExtendedFeaturesStatusData>,}
#[derive(Debug)] pub struct ReadRemoteExtendedFeaturesStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl ReadRemoteExtendedFeaturesStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for ReadRemoteExtendedFeaturesStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadRemoteExtendedFeaturesStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let read_remote_extended_features_status = match &command_status.child {CommandStatusDataChild::ReadRemoteExtendedFeaturesStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadRemoteExtendedFeaturesStatus"),};Self {event,command_status,read_remote_extended_features_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for ReadRemoteExtendedFeaturesStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for ReadRemoteExtendedFeaturesStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl ReadRemoteExtendedFeaturesStatusBuilder {pub fn build(self) -> ReadRemoteExtendedFeaturesStatusPacket {let read_remote_extended_features_status= Arc::new(ReadRemoteExtendedFeaturesStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadRemoteExtendedFeatures, child: CommandStatusDataChild::ReadRemoteExtendedFeaturesStatus(read_remote_extended_features_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});ReadRemoteExtendedFeaturesStatusPacket::new(event)}
}
impl Into<EventPacket> for ReadRemoteExtendedFeaturesStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for ReadRemoteExtendedFeaturesStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct ReadRemoteVersionInformationData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct ReadRemoteVersionInformationPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,read_remote_version_information: Arc<ReadRemoteVersionInformationData>,}
#[derive(Debug)] pub struct ReadRemoteVersionInformationBuilder {pub connection_handle: u16, }
impl ReadRemoteVersionInformationData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ReadRemoteVersionInformation".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for ReadRemoteVersionInformationPacket { type ResponseType = ReadRemoteVersionInformationStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadRemoteVersionInformationStatusPacket::new(pkt.event.clone()) }}impl Packet for ReadRemoteVersionInformationPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadRemoteVersionInformationPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let read_remote_version_information = match &acl_command.child {AclCommandDataChild::ReadRemoteVersionInformation(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadRemoteVersionInformation"),};Self {command,acl_command,read_remote_version_information,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.read_remote_version_information.as_ref().connection_handle}
}
impl Into<CommandPacket> for ReadRemoteVersionInformationPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for ReadRemoteVersionInformationPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl CommandExpectations for ReadRemoteVersionInformationBuilder { type ResponseType = ReadRemoteVersionInformationStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadRemoteVersionInformationStatusPacket::new(pkt.event.clone()) }}impl ReadRemoteVersionInformationBuilder {pub fn build(self) -> ReadRemoteVersionInformationPacket {let read_remote_version_information= Arc::new(ReadRemoteVersionInformationData {connection_handle: self.connection_handle, });let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ReadRemoteVersionInformation(read_remote_version_information),});let command= Arc::new(CommandData {op_code: OpCode::ReadRemoteVersionInformation, child: CommandDataChild::AclCommand(acl_command),});ReadRemoteVersionInformationPacket::new(command)}
}
impl Into<CommandPacket> for ReadRemoteVersionInformationBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for ReadRemoteVersionInformationBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadRemoteVersionInformationStatusData {}
#[derive(Debug, Clone)] pub struct ReadRemoteVersionInformationStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,read_remote_version_information_status: Arc<ReadRemoteVersionInformationStatusData>,}
#[derive(Debug)] pub struct ReadRemoteVersionInformationStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl ReadRemoteVersionInformationStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for ReadRemoteVersionInformationStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadRemoteVersionInformationStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let read_remote_version_information_status = match &command_status.child {CommandStatusDataChild::ReadRemoteVersionInformationStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadRemoteVersionInformationStatus"),};Self {event,command_status,read_remote_version_information_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for ReadRemoteVersionInformationStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for ReadRemoteVersionInformationStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl ReadRemoteVersionInformationStatusBuilder {pub fn build(self) -> ReadRemoteVersionInformationStatusPacket {let read_remote_version_information_status= Arc::new(ReadRemoteVersionInformationStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadRemoteVersionInformation, child: CommandStatusDataChild::ReadRemoteVersionInformationStatus(read_remote_version_information_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});ReadRemoteVersionInformationStatusPacket::new(event)}
}
impl Into<EventPacket> for ReadRemoteVersionInformationStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for ReadRemoteVersionInformationStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct ReadClockOffsetData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct ReadClockOffsetPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,read_clock_offset: Arc<ReadClockOffsetData>,}
#[derive(Debug)] pub struct ReadClockOffsetBuilder {pub connection_handle: u16, }
impl ReadClockOffsetData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ReadClockOffset".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for ReadClockOffsetPacket { type ResponseType = ReadClockOffsetStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadClockOffsetStatusPacket::new(pkt.event.clone()) }}impl Packet for ReadClockOffsetPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadClockOffsetPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let read_clock_offset = match &connection_management_command.child {ConnectionManagementCommandDataChild::ReadClockOffset(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadClockOffset"),};Self {command,acl_command,connection_management_command,read_clock_offset,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.read_clock_offset.as_ref().connection_handle}
}
impl Into<CommandPacket> for ReadClockOffsetPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for ReadClockOffsetPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for ReadClockOffsetPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for ReadClockOffsetBuilder { type ResponseType = ReadClockOffsetStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadClockOffsetStatusPacket::new(pkt.event.clone()) }}impl ReadClockOffsetBuilder {pub fn build(self) -> ReadClockOffsetPacket {let read_clock_offset= Arc::new(ReadClockOffsetData {connection_handle: self.connection_handle, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::ReadClockOffset(read_clock_offset),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::ReadClockOffset, child: CommandDataChild::AclCommand(acl_command),});ReadClockOffsetPacket::new(command)}
}
impl Into<CommandPacket> for ReadClockOffsetBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for ReadClockOffsetBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for ReadClockOffsetBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadClockOffsetStatusData {}
#[derive(Debug, Clone)] pub struct ReadClockOffsetStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,read_clock_offset_status: Arc<ReadClockOffsetStatusData>,}
#[derive(Debug)] pub struct ReadClockOffsetStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl ReadClockOffsetStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for ReadClockOffsetStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadClockOffsetStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let read_clock_offset_status = match &command_status.child {CommandStatusDataChild::ReadClockOffsetStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadClockOffsetStatus"),};Self {event,command_status,read_clock_offset_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for ReadClockOffsetStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for ReadClockOffsetStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl ReadClockOffsetStatusBuilder {pub fn build(self) -> ReadClockOffsetStatusPacket {let read_clock_offset_status= Arc::new(ReadClockOffsetStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadClockOffset, child: CommandStatusDataChild::ReadClockOffsetStatus(read_clock_offset_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});ReadClockOffsetStatusPacket::new(event)}
}
impl Into<EventPacket> for ReadClockOffsetStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for ReadClockOffsetStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct ReadLmpHandleData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct ReadLmpHandlePacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,read_lmp_handle: Arc<ReadLmpHandleData>,}
#[derive(Debug)] pub struct ReadLmpHandleBuilder {pub connection_handle: u16, }
impl ReadLmpHandleData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ReadLmpHandle".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for ReadLmpHandlePacket { type ResponseType = ReadLmpHandleCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLmpHandleCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadLmpHandlePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLmpHandlePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let read_lmp_handle = match &connection_management_command.child {ConnectionManagementCommandDataChild::ReadLmpHandle(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLmpHandle"),};Self {command,acl_command,connection_management_command,read_lmp_handle,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.read_lmp_handle.as_ref().connection_handle}
}
impl Into<CommandPacket> for ReadLmpHandlePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for ReadLmpHandlePacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for ReadLmpHandlePacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for ReadLmpHandleBuilder { type ResponseType = ReadLmpHandleCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLmpHandleCompletePacket::new(pkt.event.clone()) }}impl ReadLmpHandleBuilder {pub fn build(self) -> ReadLmpHandlePacket {let read_lmp_handle= Arc::new(ReadLmpHandleData {connection_handle: self.connection_handle, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::ReadLmpHandle(read_lmp_handle),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::ReadLmpHandle, child: CommandDataChild::AclCommand(acl_command),});ReadLmpHandlePacket::new(command)}
}
impl Into<CommandPacket> for ReadLmpHandleBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for ReadLmpHandleBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for ReadLmpHandleBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadLmpHandleCompleteData {status: ErrorCode, connection_handle: u16, lmp_handle: u8, }
#[derive(Debug, Clone)] pub struct ReadLmpHandleCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_lmp_handle_complete: Arc<ReadLmpHandleCompleteData>,}
#[derive(Debug)] pub struct ReadLmpHandleCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, pub lmp_handle: u8, }
impl ReadLmpHandleCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadLmpHandleComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadLmpHandleComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "ReadLmpHandleComplete".to_string(),    field: "lmp_handle".to_string(),    wanted: 9,    got: bytes.len()});}let lmp_handle = u8::from_le_bytes([bytes[8]]);Ok(Self {status, connection_handle, lmp_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let lmp_handle = self.lmp_handle;buffer[8..9].copy_from_slice(&lmp_handle.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 8;ret}
}
impl Packet for ReadLmpHandleCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLmpHandleCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_lmp_handle_complete = match &command_complete.child {CommandCompleteDataChild::ReadLmpHandleComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLmpHandleComplete"),};Self {event,command_complete,read_lmp_handle_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_lmp_handle_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.read_lmp_handle_complete.as_ref().connection_handle}
pub fn get_lmp_handle(&self) -> u8{ self.read_lmp_handle_complete.as_ref().lmp_handle}
}
impl Into<EventPacket> for ReadLmpHandleCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadLmpHandleCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadLmpHandleCompleteBuilder {pub fn build(self) -> ReadLmpHandleCompletePacket {let read_lmp_handle_complete= Arc::new(ReadLmpHandleCompleteData {status: self.status, connection_handle: self.connection_handle, lmp_handle: self.lmp_handle, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadLmpHandle, child: CommandCompleteDataChild::ReadLmpHandleComplete(read_lmp_handle_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadLmpHandleCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadLmpHandleCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadLmpHandleCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct SetupSynchronousConnectionData {connection_handle: u16, transmit_bandwidth: u32, receive_bandwidth: u32, max_latency: u16, voice_setting: u16, retransmission_effort: u8, packet_type: u16, }
#[derive(Debug, Clone)] pub struct SetupSynchronousConnectionPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,sco_connection_command: Arc<ScoConnectionCommandData>,setup_synchronous_connection: Arc<SetupSynchronousConnectionData>,}
#[derive(Debug)] pub struct SetupSynchronousConnectionBuilder {pub connection_handle: u16, pub transmit_bandwidth: u32, pub receive_bandwidth: u32, pub max_latency: u16, pub voice_setting: u16, pub retransmission_effort: u8, pub packet_type: u16, }
impl SetupSynchronousConnectionData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "SetupSynchronousConnection".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "SetupSynchronousConnection".to_string(),    field: "transmit_bandwidth".to_string(),    wanted: 9,    got: bytes.len()});}let transmit_bandwidth = u32::from_le_bytes([bytes[5],bytes[6],bytes[7],bytes[8]]);if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "SetupSynchronousConnection".to_string(),    field: "receive_bandwidth".to_string(),    wanted: 13,    got: bytes.len()});}let receive_bandwidth = u32::from_le_bytes([bytes[9],bytes[10],bytes[11],bytes[12]]);if bytes.len() < 15 { return Err(Error::InvalidLengthError{    obj: "SetupSynchronousConnection".to_string(),    field: "max_latency".to_string(),    wanted: 15,    got: bytes.len()});}let max_latency = u16::from_le_bytes([bytes[13],bytes[14]]);if bytes.len() < 17 { return Err(Error::InvalidLengthError{    obj: "SetupSynchronousConnection".to_string(),    field: "voice_setting".to_string(),    wanted: 17,    got: bytes.len()});}let voice_setting = u16::from_le_bytes([bytes[15],bytes[16]]);let voice_setting = voice_setting & 0x3ff;if bytes.len() < 18 { return Err(Error::InvalidLengthError{    obj: "SetupSynchronousConnection".to_string(),    field: "retransmission_effort".to_string(),    wanted: 18,    got: bytes.len()});}let retransmission_effort = u8::from_le_bytes([bytes[17]]);if bytes.len() < 20 { return Err(Error::InvalidLengthError{    obj: "SetupSynchronousConnection".to_string(),    field: "packet_type".to_string(),    wanted: 20,    got: bytes.len()});}let packet_type = u16::from_le_bytes([bytes[18],bytes[19]]);Ok(Self {connection_handle, transmit_bandwidth, receive_bandwidth, max_latency, voice_setting, retransmission_effort, packet_type, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let transmit_bandwidth = self.transmit_bandwidth;buffer[5..9].copy_from_slice(&transmit_bandwidth.to_le_bytes()[0..4]);let receive_bandwidth = self.receive_bandwidth;buffer[9..13].copy_from_slice(&receive_bandwidth.to_le_bytes()[0..4]);let max_latency = self.max_latency;buffer[13..15].copy_from_slice(&max_latency.to_le_bytes()[0..2]);let voice_setting = self.voice_setting;let voice_setting = voice_setting & 0x3ff;buffer[15..17].copy_from_slice(&voice_setting.to_le_bytes()[0..2]);let retransmission_effort = self.retransmission_effort;buffer[17..18].copy_from_slice(&retransmission_effort.to_le_bytes()[0..1]);let packet_type = self.packet_type;buffer[18..20].copy_from_slice(&packet_type.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 17;ret}
}
impl CommandExpectations for SetupSynchronousConnectionPacket { type ResponseType = SetupSynchronousConnectionStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { SetupSynchronousConnectionStatusPacket::new(pkt.event.clone()) }}impl Packet for SetupSynchronousConnectionPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SetupSynchronousConnectionPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let sco_connection_command = match &acl_command.child {AclCommandDataChild::ScoConnectionCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ScoConnectionCommand"),};let setup_synchronous_connection = match &sco_connection_command.child {ScoConnectionCommandDataChild::SetupSynchronousConnection(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetupSynchronousConnection"),};Self {command,acl_command,sco_connection_command,setup_synchronous_connection,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.setup_synchronous_connection.as_ref().connection_handle}
pub fn get_transmit_bandwidth(&self) -> u32{ self.setup_synchronous_connection.as_ref().transmit_bandwidth}
pub fn get_receive_bandwidth(&self) -> u32{ self.setup_synchronous_connection.as_ref().receive_bandwidth}
pub fn get_max_latency(&self) -> u16{ self.setup_synchronous_connection.as_ref().max_latency}
pub fn get_voice_setting(&self) -> u16{ self.setup_synchronous_connection.as_ref().voice_setting}
pub fn get_retransmission_effort(&self) -> u8{ self.setup_synchronous_connection.as_ref().retransmission_effort}
pub fn get_packet_type(&self) -> u16{ self.setup_synchronous_connection.as_ref().packet_type}
}
impl Into<CommandPacket> for SetupSynchronousConnectionPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for SetupSynchronousConnectionPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ScoConnectionCommandPacket> for SetupSynchronousConnectionPacket { fn into(self) -> ScoConnectionCommandPacket {ScoConnectionCommandPacket::new(self.command) }}
impl CommandExpectations for SetupSynchronousConnectionBuilder { type ResponseType = SetupSynchronousConnectionStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { SetupSynchronousConnectionStatusPacket::new(pkt.event.clone()) }}impl SetupSynchronousConnectionBuilder {pub fn build(self) -> SetupSynchronousConnectionPacket {let setup_synchronous_connection= Arc::new(SetupSynchronousConnectionData {connection_handle: self.connection_handle, transmit_bandwidth: self.transmit_bandwidth, receive_bandwidth: self.receive_bandwidth, max_latency: self.max_latency, voice_setting: self.voice_setting, retransmission_effort: self.retransmission_effort, packet_type: self.packet_type, });let sco_connection_command= Arc::new(ScoConnectionCommandData {child: ScoConnectionCommandDataChild::SetupSynchronousConnection(setup_synchronous_connection),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ScoConnectionCommand(sco_connection_command),});let command= Arc::new(CommandData {op_code: OpCode::SetupSynchronousConnection, child: CommandDataChild::AclCommand(acl_command),});SetupSynchronousConnectionPacket::new(command)}
}
impl Into<CommandPacket> for SetupSynchronousConnectionBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for SetupSynchronousConnectionBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ScoConnectionCommandPacket> for SetupSynchronousConnectionBuilder { fn into(self) -> ScoConnectionCommandPacket { self.build().into() }}


#[derive(Debug)] struct SetupSynchronousConnectionStatusData {}
#[derive(Debug, Clone)] pub struct SetupSynchronousConnectionStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,setup_synchronous_connection_status: Arc<SetupSynchronousConnectionStatusData>,}
#[derive(Debug)] pub struct SetupSynchronousConnectionStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl SetupSynchronousConnectionStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for SetupSynchronousConnectionStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SetupSynchronousConnectionStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let setup_synchronous_connection_status = match &command_status.child {CommandStatusDataChild::SetupSynchronousConnectionStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetupSynchronousConnectionStatus"),};Self {event,command_status,setup_synchronous_connection_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for SetupSynchronousConnectionStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for SetupSynchronousConnectionStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl SetupSynchronousConnectionStatusBuilder {pub fn build(self) -> SetupSynchronousConnectionStatusPacket {let setup_synchronous_connection_status= Arc::new(SetupSynchronousConnectionStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::SetupSynchronousConnection, child: CommandStatusDataChild::SetupSynchronousConnectionStatus(setup_synchronous_connection_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});SetupSynchronousConnectionStatusPacket::new(event)}
}
impl Into<EventPacket> for SetupSynchronousConnectionStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for SetupSynchronousConnectionStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct AcceptSynchronousConnectionData {bd_addr: Address, transmit_bandwidth: u32, receive_bandwidth: u32, max_latency: u16, voice_setting: u16, retransmission_effort: u8, packet_type: u16, }
#[derive(Debug, Clone)] pub struct AcceptSynchronousConnectionPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,sco_connection_command: Arc<ScoConnectionCommandData>,accept_synchronous_connection: Arc<AcceptSynchronousConnectionData>,}
#[derive(Debug)] pub struct AcceptSynchronousConnectionBuilder {pub bd_addr: Address, pub transmit_bandwidth: u32, pub receive_bandwidth: u32, pub max_latency: u16, pub voice_setting: u16, pub retransmission_effort: u8, pub packet_type: u16, }
impl AcceptSynchronousConnectionData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "AcceptSynchronousConnection".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "AcceptSynchronousConnection".to_string(),    field: "transmit_bandwidth".to_string(),    wanted: 13,    got: bytes.len()});}let transmit_bandwidth = u32::from_le_bytes([bytes[9],bytes[10],bytes[11],bytes[12]]);if bytes.len() < 17 { return Err(Error::InvalidLengthError{    obj: "AcceptSynchronousConnection".to_string(),    field: "receive_bandwidth".to_string(),    wanted: 17,    got: bytes.len()});}let receive_bandwidth = u32::from_le_bytes([bytes[13],bytes[14],bytes[15],bytes[16]]);if bytes.len() < 19 { return Err(Error::InvalidLengthError{    obj: "AcceptSynchronousConnection".to_string(),    field: "max_latency".to_string(),    wanted: 19,    got: bytes.len()});}let max_latency = u16::from_le_bytes([bytes[17],bytes[18]]);if bytes.len() < 21 { return Err(Error::InvalidLengthError{    obj: "AcceptSynchronousConnection".to_string(),    field: "voice_setting".to_string(),    wanted: 21,    got: bytes.len()});}let voice_setting = u16::from_le_bytes([bytes[19],bytes[20]]);let voice_setting = voice_setting & 0x3ff;if bytes.len() < 22 { return Err(Error::InvalidLengthError{    obj: "AcceptSynchronousConnection".to_string(),    field: "retransmission_effort".to_string(),    wanted: 22,    got: bytes.len()});}let retransmission_effort = u8::from_le_bytes([bytes[21]]);if bytes.len() < 24 { return Err(Error::InvalidLengthError{    obj: "AcceptSynchronousConnection".to_string(),    field: "packet_type".to_string(),    wanted: 24,    got: bytes.len()});}let packet_type = u16::from_le_bytes([bytes[22],bytes[23]]);Ok(Self {bd_addr, transmit_bandwidth, receive_bandwidth, max_latency, voice_setting, retransmission_effort, packet_type, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);let transmit_bandwidth = self.transmit_bandwidth;buffer[9..13].copy_from_slice(&transmit_bandwidth.to_le_bytes()[0..4]);let receive_bandwidth = self.receive_bandwidth;buffer[13..17].copy_from_slice(&receive_bandwidth.to_le_bytes()[0..4]);let max_latency = self.max_latency;buffer[17..19].copy_from_slice(&max_latency.to_le_bytes()[0..2]);let voice_setting = self.voice_setting;let voice_setting = voice_setting & 0x3ff;buffer[19..21].copy_from_slice(&voice_setting.to_le_bytes()[0..2]);let retransmission_effort = self.retransmission_effort;buffer[21..22].copy_from_slice(&retransmission_effort.to_le_bytes()[0..1]);let packet_type = self.packet_type;buffer[22..24].copy_from_slice(&packet_type.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 21;ret}
}
impl CommandExpectations for AcceptSynchronousConnectionPacket { type ResponseType = AcceptSynchronousConnectionStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { AcceptSynchronousConnectionStatusPacket::new(pkt.event.clone()) }}impl Packet for AcceptSynchronousConnectionPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl AcceptSynchronousConnectionPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let sco_connection_command = match &acl_command.child {AclCommandDataChild::ScoConnectionCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ScoConnectionCommand"),};let accept_synchronous_connection = match &sco_connection_command.child {ScoConnectionCommandDataChild::AcceptSynchronousConnection(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AcceptSynchronousConnection"),};Self {command,acl_command,sco_connection_command,accept_synchronous_connection,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.accept_synchronous_connection.as_ref().bd_addr}
pub fn get_transmit_bandwidth(&self) -> u32{ self.accept_synchronous_connection.as_ref().transmit_bandwidth}
pub fn get_receive_bandwidth(&self) -> u32{ self.accept_synchronous_connection.as_ref().receive_bandwidth}
pub fn get_max_latency(&self) -> u16{ self.accept_synchronous_connection.as_ref().max_latency}
pub fn get_voice_setting(&self) -> u16{ self.accept_synchronous_connection.as_ref().voice_setting}
pub fn get_retransmission_effort(&self) -> u8{ self.accept_synchronous_connection.as_ref().retransmission_effort}
pub fn get_packet_type(&self) -> u16{ self.accept_synchronous_connection.as_ref().packet_type}
}
impl Into<CommandPacket> for AcceptSynchronousConnectionPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for AcceptSynchronousConnectionPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ScoConnectionCommandPacket> for AcceptSynchronousConnectionPacket { fn into(self) -> ScoConnectionCommandPacket {ScoConnectionCommandPacket::new(self.command) }}
impl CommandExpectations for AcceptSynchronousConnectionBuilder { type ResponseType = AcceptSynchronousConnectionStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { AcceptSynchronousConnectionStatusPacket::new(pkt.event.clone()) }}impl AcceptSynchronousConnectionBuilder {pub fn build(self) -> AcceptSynchronousConnectionPacket {let accept_synchronous_connection= Arc::new(AcceptSynchronousConnectionData {bd_addr: self.bd_addr, transmit_bandwidth: self.transmit_bandwidth, receive_bandwidth: self.receive_bandwidth, max_latency: self.max_latency, voice_setting: self.voice_setting, retransmission_effort: self.retransmission_effort, packet_type: self.packet_type, });let sco_connection_command= Arc::new(ScoConnectionCommandData {child: ScoConnectionCommandDataChild::AcceptSynchronousConnection(accept_synchronous_connection),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ScoConnectionCommand(sco_connection_command),});let command= Arc::new(CommandData {op_code: OpCode::AcceptSynchronousConnection, child: CommandDataChild::AclCommand(acl_command),});AcceptSynchronousConnectionPacket::new(command)}
}
impl Into<CommandPacket> for AcceptSynchronousConnectionBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for AcceptSynchronousConnectionBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ScoConnectionCommandPacket> for AcceptSynchronousConnectionBuilder { fn into(self) -> ScoConnectionCommandPacket { self.build().into() }}


#[derive(Debug)] struct AcceptSynchronousConnectionStatusData {}
#[derive(Debug, Clone)] pub struct AcceptSynchronousConnectionStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,accept_synchronous_connection_status: Arc<AcceptSynchronousConnectionStatusData>,}
#[derive(Debug)] pub struct AcceptSynchronousConnectionStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl AcceptSynchronousConnectionStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for AcceptSynchronousConnectionStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl AcceptSynchronousConnectionStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let accept_synchronous_connection_status = match &command_status.child {CommandStatusDataChild::AcceptSynchronousConnectionStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AcceptSynchronousConnectionStatus"),};Self {event,command_status,accept_synchronous_connection_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for AcceptSynchronousConnectionStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for AcceptSynchronousConnectionStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl AcceptSynchronousConnectionStatusBuilder {pub fn build(self) -> AcceptSynchronousConnectionStatusPacket {let accept_synchronous_connection_status= Arc::new(AcceptSynchronousConnectionStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::AcceptSynchronousConnection, child: CommandStatusDataChild::AcceptSynchronousConnectionStatus(accept_synchronous_connection_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});AcceptSynchronousConnectionStatusPacket::new(event)}
}
impl Into<EventPacket> for AcceptSynchronousConnectionStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for AcceptSynchronousConnectionStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct RejectSynchronousConnectionData {bd_addr: Address, reason: RejectConnectionReason, }
#[derive(Debug, Clone)] pub struct RejectSynchronousConnectionPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,sco_connection_command: Arc<ScoConnectionCommandData>,reject_synchronous_connection: Arc<RejectSynchronousConnectionData>,}
#[derive(Debug)] pub struct RejectSynchronousConnectionBuilder {pub bd_addr: Address, pub reason: RejectConnectionReason, }
impl RejectSynchronousConnectionData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "RejectSynchronousConnection".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "RejectSynchronousConnection".to_string(),    field: "reason".to_string(),    wanted: 10,    got: bytes.len()});}let reason = u8::from_le_bytes([bytes[9]]);let reason = RejectConnectionReason::from_u8(reason).unwrap();Ok(Self {bd_addr, reason, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);let reason = self.reason.to_u8().unwrap();buffer[9..10].copy_from_slice(&reason.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl CommandExpectations for RejectSynchronousConnectionPacket { type ResponseType = RejectSynchronousConnectionStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { RejectSynchronousConnectionStatusPacket::new(pkt.event.clone()) }}impl Packet for RejectSynchronousConnectionPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl RejectSynchronousConnectionPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let sco_connection_command = match &acl_command.child {AclCommandDataChild::ScoConnectionCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ScoConnectionCommand"),};let reject_synchronous_connection = match &sco_connection_command.child {ScoConnectionCommandDataChild::RejectSynchronousConnection(value) => (*value).clone(),_ => panic!("inconsistent state - child was not RejectSynchronousConnection"),};Self {command,acl_command,sco_connection_command,reject_synchronous_connection,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.reject_synchronous_connection.as_ref().bd_addr}
pub fn get_reason(&self) -> RejectConnectionReason{ self.reject_synchronous_connection.as_ref().reason}
}
impl Into<CommandPacket> for RejectSynchronousConnectionPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for RejectSynchronousConnectionPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ScoConnectionCommandPacket> for RejectSynchronousConnectionPacket { fn into(self) -> ScoConnectionCommandPacket {ScoConnectionCommandPacket::new(self.command) }}
impl CommandExpectations for RejectSynchronousConnectionBuilder { type ResponseType = RejectSynchronousConnectionStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { RejectSynchronousConnectionStatusPacket::new(pkt.event.clone()) }}impl RejectSynchronousConnectionBuilder {pub fn build(self) -> RejectSynchronousConnectionPacket {let reject_synchronous_connection= Arc::new(RejectSynchronousConnectionData {bd_addr: self.bd_addr, reason: self.reason, });let sco_connection_command= Arc::new(ScoConnectionCommandData {child: ScoConnectionCommandDataChild::RejectSynchronousConnection(reject_synchronous_connection),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ScoConnectionCommand(sco_connection_command),});let command= Arc::new(CommandData {op_code: OpCode::RejectSynchronousConnection, child: CommandDataChild::AclCommand(acl_command),});RejectSynchronousConnectionPacket::new(command)}
}
impl Into<CommandPacket> for RejectSynchronousConnectionBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for RejectSynchronousConnectionBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ScoConnectionCommandPacket> for RejectSynchronousConnectionBuilder { fn into(self) -> ScoConnectionCommandPacket { self.build().into() }}


#[derive(Debug)] struct RejectSynchronousConnectionStatusData {}
#[derive(Debug, Clone)] pub struct RejectSynchronousConnectionStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,reject_synchronous_connection_status: Arc<RejectSynchronousConnectionStatusData>,}
#[derive(Debug)] pub struct RejectSynchronousConnectionStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl RejectSynchronousConnectionStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for RejectSynchronousConnectionStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl RejectSynchronousConnectionStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let reject_synchronous_connection_status = match &command_status.child {CommandStatusDataChild::RejectSynchronousConnectionStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not RejectSynchronousConnectionStatus"),};Self {event,command_status,reject_synchronous_connection_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for RejectSynchronousConnectionStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for RejectSynchronousConnectionStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl RejectSynchronousConnectionStatusBuilder {pub fn build(self) -> RejectSynchronousConnectionStatusPacket {let reject_synchronous_connection_status= Arc::new(RejectSynchronousConnectionStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::RejectSynchronousConnection, child: CommandStatusDataChild::RejectSynchronousConnectionStatus(reject_synchronous_connection_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});RejectSynchronousConnectionStatusPacket::new(event)}
}
impl Into<EventPacket> for RejectSynchronousConnectionStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for RejectSynchronousConnectionStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct IoCapabilityRequestReplyData {bd_addr: Address, io_capability: IoCapability, oob_present: OobDataPresent, authentication_requirements: AuthenticationRequirements, }
#[derive(Debug, Clone)] pub struct IoCapabilityRequestReplyPacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,io_capability_request_reply: Arc<IoCapabilityRequestReplyData>,}
#[derive(Debug)] pub struct IoCapabilityRequestReplyBuilder {pub bd_addr: Address, pub io_capability: IoCapability, pub oob_present: OobDataPresent, pub authentication_requirements: AuthenticationRequirements, }
impl IoCapabilityRequestReplyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "IoCapabilityRequestReply".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "IoCapabilityRequestReply".to_string(),    field: "io_capability".to_string(),    wanted: 10,    got: bytes.len()});}let io_capability = u8::from_le_bytes([bytes[9]]);let io_capability = IoCapability::from_u8(io_capability).unwrap();if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "IoCapabilityRequestReply".to_string(),    field: "oob_present".to_string(),    wanted: 11,    got: bytes.len()});}let oob_present = u8::from_le_bytes([bytes[10]]);let oob_present = OobDataPresent::from_u8(oob_present).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "IoCapabilityRequestReply".to_string(),    field: "authentication_requirements".to_string(),    wanted: 12,    got: bytes.len()});}let authentication_requirements = u8::from_le_bytes([bytes[11]]);let authentication_requirements = AuthenticationRequirements::from_u8(authentication_requirements).unwrap();Ok(Self {bd_addr, io_capability, oob_present, authentication_requirements, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);let io_capability = self.io_capability.to_u8().unwrap();buffer[9..10].copy_from_slice(&io_capability.to_le_bytes()[0..1]);let oob_present = self.oob_present.to_u8().unwrap();buffer[10..11].copy_from_slice(&oob_present.to_le_bytes()[0..1]);let authentication_requirements = self.authentication_requirements.to_u8().unwrap();buffer[11..12].copy_from_slice(&authentication_requirements.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 9;ret}
}
impl CommandExpectations for IoCapabilityRequestReplyPacket { type ResponseType = IoCapabilityRequestReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { IoCapabilityRequestReplyCompletePacket::new(pkt.event.clone()) }}impl Packet for IoCapabilityRequestReplyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl IoCapabilityRequestReplyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let io_capability_request_reply = match &security_command.child {SecurityCommandDataChild::IoCapabilityRequestReply(value) => (*value).clone(),_ => panic!("inconsistent state - child was not IoCapabilityRequestReply"),};Self {command,security_command,io_capability_request_reply,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.io_capability_request_reply.as_ref().bd_addr}
pub fn get_io_capability(&self) -> IoCapability{ self.io_capability_request_reply.as_ref().io_capability}
pub fn get_oob_present(&self) -> OobDataPresent{ self.io_capability_request_reply.as_ref().oob_present}
pub fn get_authentication_requirements(&self) -> AuthenticationRequirements{ self.io_capability_request_reply.as_ref().authentication_requirements}
}
impl Into<CommandPacket> for IoCapabilityRequestReplyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for IoCapabilityRequestReplyPacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for IoCapabilityRequestReplyBuilder { type ResponseType = IoCapabilityRequestReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { IoCapabilityRequestReplyCompletePacket::new(pkt.event.clone()) }}impl IoCapabilityRequestReplyBuilder {pub fn build(self) -> IoCapabilityRequestReplyPacket {let io_capability_request_reply= Arc::new(IoCapabilityRequestReplyData {bd_addr: self.bd_addr, io_capability: self.io_capability, oob_present: self.oob_present, authentication_requirements: self.authentication_requirements, });let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::IoCapabilityRequestReply(io_capability_request_reply),});let command= Arc::new(CommandData {op_code: OpCode::IoCapabilityRequestReply, child: CommandDataChild::SecurityCommand(security_command),});IoCapabilityRequestReplyPacket::new(command)}
}
impl Into<CommandPacket> for IoCapabilityRequestReplyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for IoCapabilityRequestReplyBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct IoCapabilityRequestReplyCompleteData {status: ErrorCode, bd_addr: Address, }
#[derive(Debug, Clone)] pub struct IoCapabilityRequestReplyCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,io_capability_request_reply_complete: Arc<IoCapabilityRequestReplyCompleteData>,}
#[derive(Debug)] pub struct IoCapabilityRequestReplyCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub bd_addr: Address, }
impl IoCapabilityRequestReplyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "IoCapabilityRequestReplyComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "IoCapabilityRequestReplyComplete".to_string(),    field: "bd_addr".to_string(),    wanted: 12,    got: bytes.len()});}let bd_addr = bytes[6..12].try_into().unwrap();Ok(Self {status, bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let bd_addr: [u8; 6] = self.bd_addr.into();buffer[6..12].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for IoCapabilityRequestReplyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl IoCapabilityRequestReplyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let io_capability_request_reply_complete = match &command_complete.child {CommandCompleteDataChild::IoCapabilityRequestReplyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not IoCapabilityRequestReplyComplete"),};Self {event,command_complete,io_capability_request_reply_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.io_capability_request_reply_complete.as_ref().status}
pub fn get_bd_addr(&self) -> Address{ self.io_capability_request_reply_complete.as_ref().bd_addr}
}
impl Into<EventPacket> for IoCapabilityRequestReplyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for IoCapabilityRequestReplyCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl IoCapabilityRequestReplyCompleteBuilder {pub fn build(self) -> IoCapabilityRequestReplyCompletePacket {let io_capability_request_reply_complete= Arc::new(IoCapabilityRequestReplyCompleteData {status: self.status, bd_addr: self.bd_addr, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::IoCapabilityRequestReply, child: CommandCompleteDataChild::IoCapabilityRequestReplyComplete(io_capability_request_reply_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});IoCapabilityRequestReplyCompletePacket::new(event)}
}
impl Into<EventPacket> for IoCapabilityRequestReplyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for IoCapabilityRequestReplyCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct UserConfirmationRequestReplyData {bd_addr: Address, }
#[derive(Debug, Clone)] pub struct UserConfirmationRequestReplyPacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,user_confirmation_request_reply: Arc<UserConfirmationRequestReplyData>,}
#[derive(Debug)] pub struct UserConfirmationRequestReplyBuilder {pub bd_addr: Address, }
impl UserConfirmationRequestReplyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "UserConfirmationRequestReply".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();Ok(Self {bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl CommandExpectations for UserConfirmationRequestReplyPacket { type ResponseType = UserConfirmationRequestReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { UserConfirmationRequestReplyCompletePacket::new(pkt.event.clone()) }}impl Packet for UserConfirmationRequestReplyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl UserConfirmationRequestReplyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let user_confirmation_request_reply = match &security_command.child {SecurityCommandDataChild::UserConfirmationRequestReply(value) => (*value).clone(),_ => panic!("inconsistent state - child was not UserConfirmationRequestReply"),};Self {command,security_command,user_confirmation_request_reply,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.user_confirmation_request_reply.as_ref().bd_addr}
}
impl Into<CommandPacket> for UserConfirmationRequestReplyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for UserConfirmationRequestReplyPacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for UserConfirmationRequestReplyBuilder { type ResponseType = UserConfirmationRequestReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { UserConfirmationRequestReplyCompletePacket::new(pkt.event.clone()) }}impl UserConfirmationRequestReplyBuilder {pub fn build(self) -> UserConfirmationRequestReplyPacket {let user_confirmation_request_reply= Arc::new(UserConfirmationRequestReplyData {bd_addr: self.bd_addr, });let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::UserConfirmationRequestReply(user_confirmation_request_reply),});let command= Arc::new(CommandData {op_code: OpCode::UserConfirmationRequestReply, child: CommandDataChild::SecurityCommand(security_command),});UserConfirmationRequestReplyPacket::new(command)}
}
impl Into<CommandPacket> for UserConfirmationRequestReplyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for UserConfirmationRequestReplyBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct UserConfirmationRequestReplyCompleteData {status: ErrorCode, bd_addr: Address, }
#[derive(Debug, Clone)] pub struct UserConfirmationRequestReplyCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,user_confirmation_request_reply_complete: Arc<UserConfirmationRequestReplyCompleteData>,}
#[derive(Debug)] pub struct UserConfirmationRequestReplyCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub bd_addr: Address, }
impl UserConfirmationRequestReplyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "UserConfirmationRequestReplyComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "UserConfirmationRequestReplyComplete".to_string(),    field: "bd_addr".to_string(),    wanted: 12,    got: bytes.len()});}let bd_addr = bytes[6..12].try_into().unwrap();Ok(Self {status, bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let bd_addr: [u8; 6] = self.bd_addr.into();buffer[6..12].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for UserConfirmationRequestReplyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl UserConfirmationRequestReplyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let user_confirmation_request_reply_complete = match &command_complete.child {CommandCompleteDataChild::UserConfirmationRequestReplyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not UserConfirmationRequestReplyComplete"),};Self {event,command_complete,user_confirmation_request_reply_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.user_confirmation_request_reply_complete.as_ref().status}
pub fn get_bd_addr(&self) -> Address{ self.user_confirmation_request_reply_complete.as_ref().bd_addr}
}
impl Into<EventPacket> for UserConfirmationRequestReplyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for UserConfirmationRequestReplyCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl UserConfirmationRequestReplyCompleteBuilder {pub fn build(self) -> UserConfirmationRequestReplyCompletePacket {let user_confirmation_request_reply_complete= Arc::new(UserConfirmationRequestReplyCompleteData {status: self.status, bd_addr: self.bd_addr, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::UserConfirmationRequestReply, child: CommandCompleteDataChild::UserConfirmationRequestReplyComplete(user_confirmation_request_reply_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});UserConfirmationRequestReplyCompletePacket::new(event)}
}
impl Into<EventPacket> for UserConfirmationRequestReplyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for UserConfirmationRequestReplyCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct UserConfirmationRequestNegativeReplyData {bd_addr: Address, }
#[derive(Debug, Clone)] pub struct UserConfirmationRequestNegativeReplyPacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,user_confirmation_request_negative_reply: Arc<UserConfirmationRequestNegativeReplyData>,}
#[derive(Debug)] pub struct UserConfirmationRequestNegativeReplyBuilder {pub bd_addr: Address, }
impl UserConfirmationRequestNegativeReplyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "UserConfirmationRequestNegativeReply".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();Ok(Self {bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl CommandExpectations for UserConfirmationRequestNegativeReplyPacket { type ResponseType = UserConfirmationRequestNegativeReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { UserConfirmationRequestNegativeReplyCompletePacket::new(pkt.event.clone()) }}impl Packet for UserConfirmationRequestNegativeReplyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl UserConfirmationRequestNegativeReplyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let user_confirmation_request_negative_reply = match &security_command.child {SecurityCommandDataChild::UserConfirmationRequestNegativeReply(value) => (*value).clone(),_ => panic!("inconsistent state - child was not UserConfirmationRequestNegativeReply"),};Self {command,security_command,user_confirmation_request_negative_reply,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.user_confirmation_request_negative_reply.as_ref().bd_addr}
}
impl Into<CommandPacket> for UserConfirmationRequestNegativeReplyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for UserConfirmationRequestNegativeReplyPacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for UserConfirmationRequestNegativeReplyBuilder { type ResponseType = UserConfirmationRequestNegativeReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { UserConfirmationRequestNegativeReplyCompletePacket::new(pkt.event.clone()) }}impl UserConfirmationRequestNegativeReplyBuilder {pub fn build(self) -> UserConfirmationRequestNegativeReplyPacket {let user_confirmation_request_negative_reply= Arc::new(UserConfirmationRequestNegativeReplyData {bd_addr: self.bd_addr, });let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::UserConfirmationRequestNegativeReply(user_confirmation_request_negative_reply),});let command= Arc::new(CommandData {op_code: OpCode::UserConfirmationRequestNegativeReply, child: CommandDataChild::SecurityCommand(security_command),});UserConfirmationRequestNegativeReplyPacket::new(command)}
}
impl Into<CommandPacket> for UserConfirmationRequestNegativeReplyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for UserConfirmationRequestNegativeReplyBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct UserConfirmationRequestNegativeReplyCompleteData {status: ErrorCode, bd_addr: Address, }
#[derive(Debug, Clone)] pub struct UserConfirmationRequestNegativeReplyCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,user_confirmation_request_negative_reply_complete: Arc<UserConfirmationRequestNegativeReplyCompleteData>,}
#[derive(Debug)] pub struct UserConfirmationRequestNegativeReplyCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub bd_addr: Address, }
impl UserConfirmationRequestNegativeReplyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "UserConfirmationRequestNegativeReplyComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "UserConfirmationRequestNegativeReplyComplete".to_string(),    field: "bd_addr".to_string(),    wanted: 12,    got: bytes.len()});}let bd_addr = bytes[6..12].try_into().unwrap();Ok(Self {status, bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let bd_addr: [u8; 6] = self.bd_addr.into();buffer[6..12].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for UserConfirmationRequestNegativeReplyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl UserConfirmationRequestNegativeReplyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let user_confirmation_request_negative_reply_complete = match &command_complete.child {CommandCompleteDataChild::UserConfirmationRequestNegativeReplyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not UserConfirmationRequestNegativeReplyComplete"),};Self {event,command_complete,user_confirmation_request_negative_reply_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.user_confirmation_request_negative_reply_complete.as_ref().status}
pub fn get_bd_addr(&self) -> Address{ self.user_confirmation_request_negative_reply_complete.as_ref().bd_addr}
}
impl Into<EventPacket> for UserConfirmationRequestNegativeReplyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for UserConfirmationRequestNegativeReplyCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl UserConfirmationRequestNegativeReplyCompleteBuilder {pub fn build(self) -> UserConfirmationRequestNegativeReplyCompletePacket {let user_confirmation_request_negative_reply_complete= Arc::new(UserConfirmationRequestNegativeReplyCompleteData {status: self.status, bd_addr: self.bd_addr, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::UserConfirmationRequestNegativeReply, child: CommandCompleteDataChild::UserConfirmationRequestNegativeReplyComplete(user_confirmation_request_negative_reply_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});UserConfirmationRequestNegativeReplyCompletePacket::new(event)}
}
impl Into<EventPacket> for UserConfirmationRequestNegativeReplyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for UserConfirmationRequestNegativeReplyCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct UserPasskeyRequestReplyData {bd_addr: Address, numeric_value: u32, }
#[derive(Debug, Clone)] pub struct UserPasskeyRequestReplyPacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,user_passkey_request_reply: Arc<UserPasskeyRequestReplyData>,}
#[derive(Debug)] pub struct UserPasskeyRequestReplyBuilder {pub bd_addr: Address, pub numeric_value: u32, }
impl UserPasskeyRequestReplyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "UserPasskeyRequestReply".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "UserPasskeyRequestReply".to_string(),    field: "numeric_value".to_string(),    wanted: 13,    got: bytes.len()});}let numeric_value = u32::from_le_bytes([bytes[9],bytes[10],bytes[11],bytes[12]]);Ok(Self {bd_addr, numeric_value, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);let numeric_value = self.numeric_value;buffer[9..13].copy_from_slice(&numeric_value.to_le_bytes()[0..4]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 10;ret}
}
impl CommandExpectations for UserPasskeyRequestReplyPacket { type ResponseType = UserPasskeyRequestReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { UserPasskeyRequestReplyCompletePacket::new(pkt.event.clone()) }}impl Packet for UserPasskeyRequestReplyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl UserPasskeyRequestReplyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let user_passkey_request_reply = match &security_command.child {SecurityCommandDataChild::UserPasskeyRequestReply(value) => (*value).clone(),_ => panic!("inconsistent state - child was not UserPasskeyRequestReply"),};Self {command,security_command,user_passkey_request_reply,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.user_passkey_request_reply.as_ref().bd_addr}
pub fn get_numeric_value(&self) -> u32{ self.user_passkey_request_reply.as_ref().numeric_value}
}
impl Into<CommandPacket> for UserPasskeyRequestReplyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for UserPasskeyRequestReplyPacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for UserPasskeyRequestReplyBuilder { type ResponseType = UserPasskeyRequestReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { UserPasskeyRequestReplyCompletePacket::new(pkt.event.clone()) }}impl UserPasskeyRequestReplyBuilder {pub fn build(self) -> UserPasskeyRequestReplyPacket {let user_passkey_request_reply= Arc::new(UserPasskeyRequestReplyData {bd_addr: self.bd_addr, numeric_value: self.numeric_value, });let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::UserPasskeyRequestReply(user_passkey_request_reply),});let command= Arc::new(CommandData {op_code: OpCode::UserPasskeyRequestReply, child: CommandDataChild::SecurityCommand(security_command),});UserPasskeyRequestReplyPacket::new(command)}
}
impl Into<CommandPacket> for UserPasskeyRequestReplyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for UserPasskeyRequestReplyBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct UserPasskeyRequestReplyCompleteData {status: ErrorCode, bd_addr: Address, }
#[derive(Debug, Clone)] pub struct UserPasskeyRequestReplyCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,user_passkey_request_reply_complete: Arc<UserPasskeyRequestReplyCompleteData>,}
#[derive(Debug)] pub struct UserPasskeyRequestReplyCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub bd_addr: Address, }
impl UserPasskeyRequestReplyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "UserPasskeyRequestReplyComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "UserPasskeyRequestReplyComplete".to_string(),    field: "bd_addr".to_string(),    wanted: 12,    got: bytes.len()});}let bd_addr = bytes[6..12].try_into().unwrap();Ok(Self {status, bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let bd_addr: [u8; 6] = self.bd_addr.into();buffer[6..12].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for UserPasskeyRequestReplyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl UserPasskeyRequestReplyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let user_passkey_request_reply_complete = match &command_complete.child {CommandCompleteDataChild::UserPasskeyRequestReplyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not UserPasskeyRequestReplyComplete"),};Self {event,command_complete,user_passkey_request_reply_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.user_passkey_request_reply_complete.as_ref().status}
pub fn get_bd_addr(&self) -> Address{ self.user_passkey_request_reply_complete.as_ref().bd_addr}
}
impl Into<EventPacket> for UserPasskeyRequestReplyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for UserPasskeyRequestReplyCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl UserPasskeyRequestReplyCompleteBuilder {pub fn build(self) -> UserPasskeyRequestReplyCompletePacket {let user_passkey_request_reply_complete= Arc::new(UserPasskeyRequestReplyCompleteData {status: self.status, bd_addr: self.bd_addr, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::UserPasskeyRequestReply, child: CommandCompleteDataChild::UserPasskeyRequestReplyComplete(user_passkey_request_reply_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});UserPasskeyRequestReplyCompletePacket::new(event)}
}
impl Into<EventPacket> for UserPasskeyRequestReplyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for UserPasskeyRequestReplyCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct UserPasskeyRequestNegativeReplyData {bd_addr: Address, }
#[derive(Debug, Clone)] pub struct UserPasskeyRequestNegativeReplyPacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,user_passkey_request_negative_reply: Arc<UserPasskeyRequestNegativeReplyData>,}
#[derive(Debug)] pub struct UserPasskeyRequestNegativeReplyBuilder {pub bd_addr: Address, }
impl UserPasskeyRequestNegativeReplyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "UserPasskeyRequestNegativeReply".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();Ok(Self {bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl CommandExpectations for UserPasskeyRequestNegativeReplyPacket { type ResponseType = UserPasskeyRequestNegativeReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { UserPasskeyRequestNegativeReplyCompletePacket::new(pkt.event.clone()) }}impl Packet for UserPasskeyRequestNegativeReplyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl UserPasskeyRequestNegativeReplyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let user_passkey_request_negative_reply = match &security_command.child {SecurityCommandDataChild::UserPasskeyRequestNegativeReply(value) => (*value).clone(),_ => panic!("inconsistent state - child was not UserPasskeyRequestNegativeReply"),};Self {command,security_command,user_passkey_request_negative_reply,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.user_passkey_request_negative_reply.as_ref().bd_addr}
}
impl Into<CommandPacket> for UserPasskeyRequestNegativeReplyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for UserPasskeyRequestNegativeReplyPacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for UserPasskeyRequestNegativeReplyBuilder { type ResponseType = UserPasskeyRequestNegativeReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { UserPasskeyRequestNegativeReplyCompletePacket::new(pkt.event.clone()) }}impl UserPasskeyRequestNegativeReplyBuilder {pub fn build(self) -> UserPasskeyRequestNegativeReplyPacket {let user_passkey_request_negative_reply= Arc::new(UserPasskeyRequestNegativeReplyData {bd_addr: self.bd_addr, });let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::UserPasskeyRequestNegativeReply(user_passkey_request_negative_reply),});let command= Arc::new(CommandData {op_code: OpCode::UserPasskeyRequestNegativeReply, child: CommandDataChild::SecurityCommand(security_command),});UserPasskeyRequestNegativeReplyPacket::new(command)}
}
impl Into<CommandPacket> for UserPasskeyRequestNegativeReplyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for UserPasskeyRequestNegativeReplyBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct UserPasskeyRequestNegativeReplyCompleteData {status: ErrorCode, bd_addr: Address, }
#[derive(Debug, Clone)] pub struct UserPasskeyRequestNegativeReplyCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,user_passkey_request_negative_reply_complete: Arc<UserPasskeyRequestNegativeReplyCompleteData>,}
#[derive(Debug)] pub struct UserPasskeyRequestNegativeReplyCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub bd_addr: Address, }
impl UserPasskeyRequestNegativeReplyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "UserPasskeyRequestNegativeReplyComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "UserPasskeyRequestNegativeReplyComplete".to_string(),    field: "bd_addr".to_string(),    wanted: 12,    got: bytes.len()});}let bd_addr = bytes[6..12].try_into().unwrap();Ok(Self {status, bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let bd_addr: [u8; 6] = self.bd_addr.into();buffer[6..12].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for UserPasskeyRequestNegativeReplyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl UserPasskeyRequestNegativeReplyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let user_passkey_request_negative_reply_complete = match &command_complete.child {CommandCompleteDataChild::UserPasskeyRequestNegativeReplyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not UserPasskeyRequestNegativeReplyComplete"),};Self {event,command_complete,user_passkey_request_negative_reply_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.user_passkey_request_negative_reply_complete.as_ref().status}
pub fn get_bd_addr(&self) -> Address{ self.user_passkey_request_negative_reply_complete.as_ref().bd_addr}
}
impl Into<EventPacket> for UserPasskeyRequestNegativeReplyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for UserPasskeyRequestNegativeReplyCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl UserPasskeyRequestNegativeReplyCompleteBuilder {pub fn build(self) -> UserPasskeyRequestNegativeReplyCompletePacket {let user_passkey_request_negative_reply_complete= Arc::new(UserPasskeyRequestNegativeReplyCompleteData {status: self.status, bd_addr: self.bd_addr, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::UserPasskeyRequestNegativeReply, child: CommandCompleteDataChild::UserPasskeyRequestNegativeReplyComplete(user_passkey_request_negative_reply_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});UserPasskeyRequestNegativeReplyCompletePacket::new(event)}
}
impl Into<EventPacket> for UserPasskeyRequestNegativeReplyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for UserPasskeyRequestNegativeReplyCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct RemoteOobDataRequestReplyData {bd_addr: Address, c: [u8; 16], r: [u8; 16], }
#[derive(Debug, Clone)] pub struct RemoteOobDataRequestReplyPacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,remote_oob_data_request_reply: Arc<RemoteOobDataRequestReplyData>,}
#[derive(Debug)] pub struct RemoteOobDataRequestReplyBuilder {pub bd_addr: Address, pub c: [u8; 16], pub r: [u8; 16], }
impl RemoteOobDataRequestReplyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "RemoteOobDataRequestReply".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();if bytes.len() < 25 { return Err(Error::InvalidLengthError{    obj: "RemoteOobDataRequestReply".to_string(),    field: "c".to_string(),    wanted: 25,    got: bytes.len()});}let c = bytes[9..25].try_into().unwrap();if bytes.len() < 41 { return Err(Error::InvalidLengthError{    obj: "RemoteOobDataRequestReply".to_string(),    field: "r".to_string(),    wanted: 41,    got: bytes.len()});}let r = bytes[25..41].try_into().unwrap();Ok(Self {bd_addr, c, r, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);&buffer[9..25].copy_from_slice(&self.c);&buffer[25..41].copy_from_slice(&self.r);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 38;ret}
}
impl CommandExpectations for RemoteOobDataRequestReplyPacket { type ResponseType = RemoteOobDataRequestReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { RemoteOobDataRequestReplyCompletePacket::new(pkt.event.clone()) }}impl Packet for RemoteOobDataRequestReplyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl RemoteOobDataRequestReplyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let remote_oob_data_request_reply = match &security_command.child {SecurityCommandDataChild::RemoteOobDataRequestReply(value) => (*value).clone(),_ => panic!("inconsistent state - child was not RemoteOobDataRequestReply"),};Self {command,security_command,remote_oob_data_request_reply,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.remote_oob_data_request_reply.as_ref().bd_addr}
pub fn get_c(&self) -> &[u8; 16]{ &self.remote_oob_data_request_reply.as_ref().c}
pub fn get_r(&self) -> &[u8; 16]{ &self.remote_oob_data_request_reply.as_ref().r}
}
impl Into<CommandPacket> for RemoteOobDataRequestReplyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for RemoteOobDataRequestReplyPacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for RemoteOobDataRequestReplyBuilder { type ResponseType = RemoteOobDataRequestReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { RemoteOobDataRequestReplyCompletePacket::new(pkt.event.clone()) }}impl RemoteOobDataRequestReplyBuilder {pub fn build(self) -> RemoteOobDataRequestReplyPacket {let remote_oob_data_request_reply= Arc::new(RemoteOobDataRequestReplyData {bd_addr: self.bd_addr, c: self.c, r: self.r, });let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::RemoteOobDataRequestReply(remote_oob_data_request_reply),});let command= Arc::new(CommandData {op_code: OpCode::RemoteOobDataRequestReply, child: CommandDataChild::SecurityCommand(security_command),});RemoteOobDataRequestReplyPacket::new(command)}
}
impl Into<CommandPacket> for RemoteOobDataRequestReplyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for RemoteOobDataRequestReplyBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct RemoteOobDataRequestReplyCompleteData {status: ErrorCode, bd_addr: Address, }
#[derive(Debug, Clone)] pub struct RemoteOobDataRequestReplyCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,remote_oob_data_request_reply_complete: Arc<RemoteOobDataRequestReplyCompleteData>,}
#[derive(Debug)] pub struct RemoteOobDataRequestReplyCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub bd_addr: Address, }
impl RemoteOobDataRequestReplyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "RemoteOobDataRequestReplyComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "RemoteOobDataRequestReplyComplete".to_string(),    field: "bd_addr".to_string(),    wanted: 12,    got: bytes.len()});}let bd_addr = bytes[6..12].try_into().unwrap();Ok(Self {status, bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let bd_addr: [u8; 6] = self.bd_addr.into();buffer[6..12].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for RemoteOobDataRequestReplyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl RemoteOobDataRequestReplyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let remote_oob_data_request_reply_complete = match &command_complete.child {CommandCompleteDataChild::RemoteOobDataRequestReplyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not RemoteOobDataRequestReplyComplete"),};Self {event,command_complete,remote_oob_data_request_reply_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.remote_oob_data_request_reply_complete.as_ref().status}
pub fn get_bd_addr(&self) -> Address{ self.remote_oob_data_request_reply_complete.as_ref().bd_addr}
}
impl Into<EventPacket> for RemoteOobDataRequestReplyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for RemoteOobDataRequestReplyCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl RemoteOobDataRequestReplyCompleteBuilder {pub fn build(self) -> RemoteOobDataRequestReplyCompletePacket {let remote_oob_data_request_reply_complete= Arc::new(RemoteOobDataRequestReplyCompleteData {status: self.status, bd_addr: self.bd_addr, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::RemoteOobDataRequestReply, child: CommandCompleteDataChild::RemoteOobDataRequestReplyComplete(remote_oob_data_request_reply_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});RemoteOobDataRequestReplyCompletePacket::new(event)}
}
impl Into<EventPacket> for RemoteOobDataRequestReplyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for RemoteOobDataRequestReplyCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct RemoteOobDataRequestNegativeReplyData {bd_addr: Address, }
#[derive(Debug, Clone)] pub struct RemoteOobDataRequestNegativeReplyPacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,remote_oob_data_request_negative_reply: Arc<RemoteOobDataRequestNegativeReplyData>,}
#[derive(Debug)] pub struct RemoteOobDataRequestNegativeReplyBuilder {pub bd_addr: Address, }
impl RemoteOobDataRequestNegativeReplyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "RemoteOobDataRequestNegativeReply".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();Ok(Self {bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl CommandExpectations for RemoteOobDataRequestNegativeReplyPacket { type ResponseType = RemoteOobDataRequestNegativeReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { RemoteOobDataRequestNegativeReplyCompletePacket::new(pkt.event.clone()) }}impl Packet for RemoteOobDataRequestNegativeReplyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl RemoteOobDataRequestNegativeReplyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let remote_oob_data_request_negative_reply = match &security_command.child {SecurityCommandDataChild::RemoteOobDataRequestNegativeReply(value) => (*value).clone(),_ => panic!("inconsistent state - child was not RemoteOobDataRequestNegativeReply"),};Self {command,security_command,remote_oob_data_request_negative_reply,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.remote_oob_data_request_negative_reply.as_ref().bd_addr}
}
impl Into<CommandPacket> for RemoteOobDataRequestNegativeReplyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for RemoteOobDataRequestNegativeReplyPacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for RemoteOobDataRequestNegativeReplyBuilder { type ResponseType = RemoteOobDataRequestNegativeReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { RemoteOobDataRequestNegativeReplyCompletePacket::new(pkt.event.clone()) }}impl RemoteOobDataRequestNegativeReplyBuilder {pub fn build(self) -> RemoteOobDataRequestNegativeReplyPacket {let remote_oob_data_request_negative_reply= Arc::new(RemoteOobDataRequestNegativeReplyData {bd_addr: self.bd_addr, });let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::RemoteOobDataRequestNegativeReply(remote_oob_data_request_negative_reply),});let command= Arc::new(CommandData {op_code: OpCode::RemoteOobDataRequestNegativeReply, child: CommandDataChild::SecurityCommand(security_command),});RemoteOobDataRequestNegativeReplyPacket::new(command)}
}
impl Into<CommandPacket> for RemoteOobDataRequestNegativeReplyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for RemoteOobDataRequestNegativeReplyBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct RemoteOobDataRequestNegativeReplyCompleteData {status: ErrorCode, bd_addr: Address, }
#[derive(Debug, Clone)] pub struct RemoteOobDataRequestNegativeReplyCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,remote_oob_data_request_negative_reply_complete: Arc<RemoteOobDataRequestNegativeReplyCompleteData>,}
#[derive(Debug)] pub struct RemoteOobDataRequestNegativeReplyCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub bd_addr: Address, }
impl RemoteOobDataRequestNegativeReplyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "RemoteOobDataRequestNegativeReplyComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "RemoteOobDataRequestNegativeReplyComplete".to_string(),    field: "bd_addr".to_string(),    wanted: 12,    got: bytes.len()});}let bd_addr = bytes[6..12].try_into().unwrap();Ok(Self {status, bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let bd_addr: [u8; 6] = self.bd_addr.into();buffer[6..12].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for RemoteOobDataRequestNegativeReplyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl RemoteOobDataRequestNegativeReplyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let remote_oob_data_request_negative_reply_complete = match &command_complete.child {CommandCompleteDataChild::RemoteOobDataRequestNegativeReplyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not RemoteOobDataRequestNegativeReplyComplete"),};Self {event,command_complete,remote_oob_data_request_negative_reply_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.remote_oob_data_request_negative_reply_complete.as_ref().status}
pub fn get_bd_addr(&self) -> Address{ self.remote_oob_data_request_negative_reply_complete.as_ref().bd_addr}
}
impl Into<EventPacket> for RemoteOobDataRequestNegativeReplyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for RemoteOobDataRequestNegativeReplyCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl RemoteOobDataRequestNegativeReplyCompleteBuilder {pub fn build(self) -> RemoteOobDataRequestNegativeReplyCompletePacket {let remote_oob_data_request_negative_reply_complete= Arc::new(RemoteOobDataRequestNegativeReplyCompleteData {status: self.status, bd_addr: self.bd_addr, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::RemoteOobDataRequestNegativeReply, child: CommandCompleteDataChild::RemoteOobDataRequestNegativeReplyComplete(remote_oob_data_request_negative_reply_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});RemoteOobDataRequestNegativeReplyCompletePacket::new(event)}
}
impl Into<EventPacket> for RemoteOobDataRequestNegativeReplyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for RemoteOobDataRequestNegativeReplyCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct IoCapabilityRequestNegativeReplyData {bd_addr: Address, reason: ErrorCode, }
#[derive(Debug, Clone)] pub struct IoCapabilityRequestNegativeReplyPacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,io_capability_request_negative_reply: Arc<IoCapabilityRequestNegativeReplyData>,}
#[derive(Debug)] pub struct IoCapabilityRequestNegativeReplyBuilder {pub bd_addr: Address, pub reason: ErrorCode, }
impl IoCapabilityRequestNegativeReplyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "IoCapabilityRequestNegativeReply".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "IoCapabilityRequestNegativeReply".to_string(),    field: "reason".to_string(),    wanted: 10,    got: bytes.len()});}let reason = u8::from_le_bytes([bytes[9]]);let reason = ErrorCode::from_u8(reason).unwrap();Ok(Self {bd_addr, reason, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);let reason = self.reason.to_u8().unwrap();buffer[9..10].copy_from_slice(&reason.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl CommandExpectations for IoCapabilityRequestNegativeReplyPacket { type ResponseType = IoCapabilityRequestNegativeReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { IoCapabilityRequestNegativeReplyCompletePacket::new(pkt.event.clone()) }}impl Packet for IoCapabilityRequestNegativeReplyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl IoCapabilityRequestNegativeReplyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let io_capability_request_negative_reply = match &security_command.child {SecurityCommandDataChild::IoCapabilityRequestNegativeReply(value) => (*value).clone(),_ => panic!("inconsistent state - child was not IoCapabilityRequestNegativeReply"),};Self {command,security_command,io_capability_request_negative_reply,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.io_capability_request_negative_reply.as_ref().bd_addr}
pub fn get_reason(&self) -> ErrorCode{ self.io_capability_request_negative_reply.as_ref().reason}
}
impl Into<CommandPacket> for IoCapabilityRequestNegativeReplyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for IoCapabilityRequestNegativeReplyPacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for IoCapabilityRequestNegativeReplyBuilder { type ResponseType = IoCapabilityRequestNegativeReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { IoCapabilityRequestNegativeReplyCompletePacket::new(pkt.event.clone()) }}impl IoCapabilityRequestNegativeReplyBuilder {pub fn build(self) -> IoCapabilityRequestNegativeReplyPacket {let io_capability_request_negative_reply= Arc::new(IoCapabilityRequestNegativeReplyData {bd_addr: self.bd_addr, reason: self.reason, });let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::IoCapabilityRequestNegativeReply(io_capability_request_negative_reply),});let command= Arc::new(CommandData {op_code: OpCode::IoCapabilityRequestNegativeReply, child: CommandDataChild::SecurityCommand(security_command),});IoCapabilityRequestNegativeReplyPacket::new(command)}
}
impl Into<CommandPacket> for IoCapabilityRequestNegativeReplyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for IoCapabilityRequestNegativeReplyBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct IoCapabilityRequestNegativeReplyCompleteData {status: ErrorCode, bd_addr: Address, }
#[derive(Debug, Clone)] pub struct IoCapabilityRequestNegativeReplyCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,io_capability_request_negative_reply_complete: Arc<IoCapabilityRequestNegativeReplyCompleteData>,}
#[derive(Debug)] pub struct IoCapabilityRequestNegativeReplyCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub bd_addr: Address, }
impl IoCapabilityRequestNegativeReplyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "IoCapabilityRequestNegativeReplyComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "IoCapabilityRequestNegativeReplyComplete".to_string(),    field: "bd_addr".to_string(),    wanted: 12,    got: bytes.len()});}let bd_addr = bytes[6..12].try_into().unwrap();Ok(Self {status, bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let bd_addr: [u8; 6] = self.bd_addr.into();buffer[6..12].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for IoCapabilityRequestNegativeReplyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl IoCapabilityRequestNegativeReplyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let io_capability_request_negative_reply_complete = match &command_complete.child {CommandCompleteDataChild::IoCapabilityRequestNegativeReplyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not IoCapabilityRequestNegativeReplyComplete"),};Self {event,command_complete,io_capability_request_negative_reply_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.io_capability_request_negative_reply_complete.as_ref().status}
pub fn get_bd_addr(&self) -> Address{ self.io_capability_request_negative_reply_complete.as_ref().bd_addr}
}
impl Into<EventPacket> for IoCapabilityRequestNegativeReplyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for IoCapabilityRequestNegativeReplyCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl IoCapabilityRequestNegativeReplyCompleteBuilder {pub fn build(self) -> IoCapabilityRequestNegativeReplyCompletePacket {let io_capability_request_negative_reply_complete= Arc::new(IoCapabilityRequestNegativeReplyCompleteData {status: self.status, bd_addr: self.bd_addr, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::IoCapabilityRequestNegativeReply, child: CommandCompleteDataChild::IoCapabilityRequestNegativeReplyComplete(io_capability_request_negative_reply_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});IoCapabilityRequestNegativeReplyCompletePacket::new(event)}
}
impl Into<EventPacket> for IoCapabilityRequestNegativeReplyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for IoCapabilityRequestNegativeReplyCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct EnhancedSetupSynchronousConnectionData {connection_handle: u16, transmit_bandwidth_octets_per_second: u32, receive_bandwidth_octets_per_second: u32, transmit_coding_format: ScoCodingFormat, receive_coding_format: ScoCodingFormat, transmit_codec_frame_size: u16, receive_codec_frame_size: u16, input_bandwidth_octets_per_second: u32, output_bandwidth_octets_per_second: u32, input_coding_format: ScoCodingFormat, output_coding_format: ScoCodingFormat, input_coded_data_bits: u16, output_coded_data_bits: u16, input_pcm_data_format: ScoPcmDataFormat, output_pcm_data_format: ScoPcmDataFormat, input_pcm_sample_payload_msb_position: u8, output_pcm_sample_payload_msb_position: u8, input_data_path: ScoDataPath, output_data_path: ScoDataPath, input_transport_unit_bits: u8, output_transport_unit_bits: u8, max_latency_ms: u16, packet_type: u16, retransmission_effort: RetransmissionEffort, }
#[derive(Debug, Clone)] pub struct EnhancedSetupSynchronousConnectionPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,sco_connection_command: Arc<ScoConnectionCommandData>,enhanced_setup_synchronous_connection: Arc<EnhancedSetupSynchronousConnectionData>,}
#[derive(Debug)] pub struct EnhancedSetupSynchronousConnectionBuilder {pub connection_handle: u16, pub transmit_bandwidth_octets_per_second: u32, pub receive_bandwidth_octets_per_second: u32, pub transmit_coding_format: ScoCodingFormat, pub receive_coding_format: ScoCodingFormat, pub transmit_codec_frame_size: u16, pub receive_codec_frame_size: u16, pub input_bandwidth_octets_per_second: u32, pub output_bandwidth_octets_per_second: u32, pub input_coding_format: ScoCodingFormat, pub output_coding_format: ScoCodingFormat, pub input_coded_data_bits: u16, pub output_coded_data_bits: u16, pub input_pcm_data_format: ScoPcmDataFormat, pub output_pcm_data_format: ScoPcmDataFormat, pub input_pcm_sample_payload_msb_position: u8, pub output_pcm_sample_payload_msb_position: u8, pub input_data_path: ScoDataPath, pub output_data_path: ScoDataPath, pub input_transport_unit_bits: u8, pub output_transport_unit_bits: u8, pub max_latency_ms: u16, pub packet_type: u16, pub retransmission_effort: RetransmissionEffort, }
impl EnhancedSetupSynchronousConnectionData {fn conforms(bytes: &[u8]) -> bool {if !ScoCodingFormat::conforms(&bytes[13..18]) { return false; }if !ScoCodingFormat::conforms(&bytes[18..23]) { return false; }if !ScoCodingFormat::conforms(&bytes[35..40]) { return false; }if !ScoCodingFormat::conforms(&bytes[40..45]) { return false; } true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "EnhancedSetupSynchronousConnection".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "EnhancedSetupSynchronousConnection".to_string(),    field: "transmit_bandwidth_octets_per_second".to_string(),    wanted: 9,    got: bytes.len()});}let transmit_bandwidth_octets_per_second = u32::from_le_bytes([bytes[5],bytes[6],bytes[7],bytes[8]]);if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "EnhancedSetupSynchronousConnection".to_string(),    field: "receive_bandwidth_octets_per_second".to_string(),    wanted: 13,    got: bytes.len()});}let receive_bandwidth_octets_per_second = u32::from_le_bytes([bytes[9],bytes[10],bytes[11],bytes[12]]);let transmit_coding_format = ScoCodingFormat::parse(&bytes[13..18]).unwrap();let receive_coding_format = ScoCodingFormat::parse(&bytes[18..23]).unwrap();if bytes.len() < 25 { return Err(Error::InvalidLengthError{    obj: "EnhancedSetupSynchronousConnection".to_string(),    field: "transmit_codec_frame_size".to_string(),    wanted: 25,    got: bytes.len()});}let transmit_codec_frame_size = u16::from_le_bytes([bytes[23],bytes[24]]);if bytes.len() < 27 { return Err(Error::InvalidLengthError{    obj: "EnhancedSetupSynchronousConnection".to_string(),    field: "receive_codec_frame_size".to_string(),    wanted: 27,    got: bytes.len()});}let receive_codec_frame_size = u16::from_le_bytes([bytes[25],bytes[26]]);if bytes.len() < 31 { return Err(Error::InvalidLengthError{    obj: "EnhancedSetupSynchronousConnection".to_string(),    field: "input_bandwidth_octets_per_second".to_string(),    wanted: 31,    got: bytes.len()});}let input_bandwidth_octets_per_second = u32::from_le_bytes([bytes[27],bytes[28],bytes[29],bytes[30]]);if bytes.len() < 35 { return Err(Error::InvalidLengthError{    obj: "EnhancedSetupSynchronousConnection".to_string(),    field: "output_bandwidth_octets_per_second".to_string(),    wanted: 35,    got: bytes.len()});}let output_bandwidth_octets_per_second = u32::from_le_bytes([bytes[31],bytes[32],bytes[33],bytes[34]]);let input_coding_format = ScoCodingFormat::parse(&bytes[35..40]).unwrap();let output_coding_format = ScoCodingFormat::parse(&bytes[40..45]).unwrap();if bytes.len() < 47 { return Err(Error::InvalidLengthError{    obj: "EnhancedSetupSynchronousConnection".to_string(),    field: "input_coded_data_bits".to_string(),    wanted: 47,    got: bytes.len()});}let input_coded_data_bits = u16::from_le_bytes([bytes[45],bytes[46]]);if bytes.len() < 49 { return Err(Error::InvalidLengthError{    obj: "EnhancedSetupSynchronousConnection".to_string(),    field: "output_coded_data_bits".to_string(),    wanted: 49,    got: bytes.len()});}let output_coded_data_bits = u16::from_le_bytes([bytes[47],bytes[48]]);if bytes.len() < 50 { return Err(Error::InvalidLengthError{    obj: "EnhancedSetupSynchronousConnection".to_string(),    field: "input_pcm_data_format".to_string(),    wanted: 50,    got: bytes.len()});}let input_pcm_data_format = u8::from_le_bytes([bytes[49]]);let input_pcm_data_format = ScoPcmDataFormat::from_u8(input_pcm_data_format).unwrap();if bytes.len() < 51 { return Err(Error::InvalidLengthError{    obj: "EnhancedSetupSynchronousConnection".to_string(),    field: "output_pcm_data_format".to_string(),    wanted: 51,    got: bytes.len()});}let output_pcm_data_format = u8::from_le_bytes([bytes[50]]);let output_pcm_data_format = ScoPcmDataFormat::from_u8(output_pcm_data_format).unwrap();if bytes.len() < 52 { return Err(Error::InvalidLengthError{    obj: "EnhancedSetupSynchronousConnection".to_string(),    field: "input_pcm_sample_payload_msb_position".to_string(),    wanted: 52,    got: bytes.len()});}let input_pcm_sample_payload_msb_position = u8::from_le_bytes([bytes[51]]);if bytes.len() < 53 { return Err(Error::InvalidLengthError{    obj: "EnhancedSetupSynchronousConnection".to_string(),    field: "output_pcm_sample_payload_msb_position".to_string(),    wanted: 53,    got: bytes.len()});}let output_pcm_sample_payload_msb_position = u8::from_le_bytes([bytes[52]]);if bytes.len() < 54 { return Err(Error::InvalidLengthError{    obj: "EnhancedSetupSynchronousConnection".to_string(),    field: "input_data_path".to_string(),    wanted: 54,    got: bytes.len()});}let input_data_path = u8::from_le_bytes([bytes[53]]);let input_data_path = ScoDataPath::from_u8(input_data_path).unwrap();if bytes.len() < 55 { return Err(Error::InvalidLengthError{    obj: "EnhancedSetupSynchronousConnection".to_string(),    field: "output_data_path".to_string(),    wanted: 55,    got: bytes.len()});}let output_data_path = u8::from_le_bytes([bytes[54]]);let output_data_path = ScoDataPath::from_u8(output_data_path).unwrap();if bytes.len() < 56 { return Err(Error::InvalidLengthError{    obj: "EnhancedSetupSynchronousConnection".to_string(),    field: "input_transport_unit_bits".to_string(),    wanted: 56,    got: bytes.len()});}let input_transport_unit_bits = u8::from_le_bytes([bytes[55]]);if bytes.len() < 57 { return Err(Error::InvalidLengthError{    obj: "EnhancedSetupSynchronousConnection".to_string(),    field: "output_transport_unit_bits".to_string(),    wanted: 57,    got: bytes.len()});}let output_transport_unit_bits = u8::from_le_bytes([bytes[56]]);if bytes.len() < 59 { return Err(Error::InvalidLengthError{    obj: "EnhancedSetupSynchronousConnection".to_string(),    field: "max_latency_ms".to_string(),    wanted: 59,    got: bytes.len()});}let max_latency_ms = u16::from_le_bytes([bytes[57],bytes[58]]);if bytes.len() < 61 { return Err(Error::InvalidLengthError{    obj: "EnhancedSetupSynchronousConnection".to_string(),    field: "packet_type".to_string(),    wanted: 61,    got: bytes.len()});}let packet_type = u16::from_le_bytes([bytes[59],bytes[60]]);if bytes.len() < 62 { return Err(Error::InvalidLengthError{    obj: "EnhancedSetupSynchronousConnection".to_string(),    field: "retransmission_effort".to_string(),    wanted: 62,    got: bytes.len()});}let retransmission_effort = u8::from_le_bytes([bytes[61]]);let retransmission_effort = RetransmissionEffort::from_u8(retransmission_effort).unwrap();Ok(Self {connection_handle, transmit_bandwidth_octets_per_second, receive_bandwidth_octets_per_second, transmit_coding_format, receive_coding_format, transmit_codec_frame_size, receive_codec_frame_size, input_bandwidth_octets_per_second, output_bandwidth_octets_per_second, input_coding_format, output_coding_format, input_coded_data_bits, output_coded_data_bits, input_pcm_data_format, output_pcm_data_format, input_pcm_sample_payload_msb_position, output_pcm_sample_payload_msb_position, input_data_path, output_data_path, input_transport_unit_bits, output_transport_unit_bits, max_latency_ms, packet_type, retransmission_effort, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let transmit_bandwidth_octets_per_second = self.transmit_bandwidth_octets_per_second;buffer[5..9].copy_from_slice(&transmit_bandwidth_octets_per_second.to_le_bytes()[0..4]);let receive_bandwidth_octets_per_second = self.receive_bandwidth_octets_per_second;buffer[9..13].copy_from_slice(&receive_bandwidth_octets_per_second.to_le_bytes()[0..4]);let transmit_coding_format = &mut buffer[13..18];self.transmit_coding_format.write_to(transmit_coding_format);let receive_coding_format = &mut buffer[18..23];self.receive_coding_format.write_to(receive_coding_format);let transmit_codec_frame_size = self.transmit_codec_frame_size;buffer[23..25].copy_from_slice(&transmit_codec_frame_size.to_le_bytes()[0..2]);let receive_codec_frame_size = self.receive_codec_frame_size;buffer[25..27].copy_from_slice(&receive_codec_frame_size.to_le_bytes()[0..2]);let input_bandwidth_octets_per_second = self.input_bandwidth_octets_per_second;buffer[27..31].copy_from_slice(&input_bandwidth_octets_per_second.to_le_bytes()[0..4]);let output_bandwidth_octets_per_second = self.output_bandwidth_octets_per_second;buffer[31..35].copy_from_slice(&output_bandwidth_octets_per_second.to_le_bytes()[0..4]);let input_coding_format = &mut buffer[35..40];self.input_coding_format.write_to(input_coding_format);let output_coding_format = &mut buffer[40..45];self.output_coding_format.write_to(output_coding_format);let input_coded_data_bits = self.input_coded_data_bits;buffer[45..47].copy_from_slice(&input_coded_data_bits.to_le_bytes()[0..2]);let output_coded_data_bits = self.output_coded_data_bits;buffer[47..49].copy_from_slice(&output_coded_data_bits.to_le_bytes()[0..2]);let input_pcm_data_format = self.input_pcm_data_format.to_u8().unwrap();buffer[49..50].copy_from_slice(&input_pcm_data_format.to_le_bytes()[0..1]);let output_pcm_data_format = self.output_pcm_data_format.to_u8().unwrap();buffer[50..51].copy_from_slice(&output_pcm_data_format.to_le_bytes()[0..1]);let input_pcm_sample_payload_msb_position = self.input_pcm_sample_payload_msb_position;buffer[51..52].copy_from_slice(&input_pcm_sample_payload_msb_position.to_le_bytes()[0..1]);let output_pcm_sample_payload_msb_position = self.output_pcm_sample_payload_msb_position;buffer[52..53].copy_from_slice(&output_pcm_sample_payload_msb_position.to_le_bytes()[0..1]);let input_data_path = self.input_data_path.to_u8().unwrap();buffer[53..54].copy_from_slice(&input_data_path.to_le_bytes()[0..1]);let output_data_path = self.output_data_path.to_u8().unwrap();buffer[54..55].copy_from_slice(&output_data_path.to_le_bytes()[0..1]);let input_transport_unit_bits = self.input_transport_unit_bits;buffer[55..56].copy_from_slice(&input_transport_unit_bits.to_le_bytes()[0..1]);let output_transport_unit_bits = self.output_transport_unit_bits;buffer[56..57].copy_from_slice(&output_transport_unit_bits.to_le_bytes()[0..1]);let max_latency_ms = self.max_latency_ms;buffer[57..59].copy_from_slice(&max_latency_ms.to_le_bytes()[0..2]);let packet_type = self.packet_type;buffer[59..61].copy_from_slice(&packet_type.to_le_bytes()[0..2]);let retransmission_effort = self.retransmission_effort.to_u8().unwrap();buffer[61..62].copy_from_slice(&retransmission_effort.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 59;ret}
}
impl CommandExpectations for EnhancedSetupSynchronousConnectionPacket { type ResponseType = EnhancedSetupSynchronousConnectionStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { EnhancedSetupSynchronousConnectionStatusPacket::new(pkt.event.clone()) }}impl Packet for EnhancedSetupSynchronousConnectionPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl EnhancedSetupSynchronousConnectionPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let sco_connection_command = match &acl_command.child {AclCommandDataChild::ScoConnectionCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ScoConnectionCommand"),};let enhanced_setup_synchronous_connection = match &sco_connection_command.child {ScoConnectionCommandDataChild::EnhancedSetupSynchronousConnection(value) => (*value).clone(),_ => panic!("inconsistent state - child was not EnhancedSetupSynchronousConnection"),};Self {command,acl_command,sco_connection_command,enhanced_setup_synchronous_connection,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.enhanced_setup_synchronous_connection.as_ref().connection_handle}
pub fn get_transmit_bandwidth_octets_per_second(&self) -> u32{ self.enhanced_setup_synchronous_connection.as_ref().transmit_bandwidth_octets_per_second}
pub fn get_receive_bandwidth_octets_per_second(&self) -> u32{ self.enhanced_setup_synchronous_connection.as_ref().receive_bandwidth_octets_per_second}
pub fn get_transmit_coding_format(&self) -> &ScoCodingFormat{ &self.enhanced_setup_synchronous_connection.as_ref().transmit_coding_format}
pub fn get_receive_coding_format(&self) -> &ScoCodingFormat{ &self.enhanced_setup_synchronous_connection.as_ref().receive_coding_format}
pub fn get_transmit_codec_frame_size(&self) -> u16{ self.enhanced_setup_synchronous_connection.as_ref().transmit_codec_frame_size}
pub fn get_receive_codec_frame_size(&self) -> u16{ self.enhanced_setup_synchronous_connection.as_ref().receive_codec_frame_size}
pub fn get_input_bandwidth_octets_per_second(&self) -> u32{ self.enhanced_setup_synchronous_connection.as_ref().input_bandwidth_octets_per_second}
pub fn get_output_bandwidth_octets_per_second(&self) -> u32{ self.enhanced_setup_synchronous_connection.as_ref().output_bandwidth_octets_per_second}
pub fn get_input_coding_format(&self) -> &ScoCodingFormat{ &self.enhanced_setup_synchronous_connection.as_ref().input_coding_format}
pub fn get_output_coding_format(&self) -> &ScoCodingFormat{ &self.enhanced_setup_synchronous_connection.as_ref().output_coding_format}
pub fn get_input_coded_data_bits(&self) -> u16{ self.enhanced_setup_synchronous_connection.as_ref().input_coded_data_bits}
pub fn get_output_coded_data_bits(&self) -> u16{ self.enhanced_setup_synchronous_connection.as_ref().output_coded_data_bits}
pub fn get_input_pcm_data_format(&self) -> ScoPcmDataFormat{ self.enhanced_setup_synchronous_connection.as_ref().input_pcm_data_format}
pub fn get_output_pcm_data_format(&self) -> ScoPcmDataFormat{ self.enhanced_setup_synchronous_connection.as_ref().output_pcm_data_format}
pub fn get_input_pcm_sample_payload_msb_position(&self) -> u8{ self.enhanced_setup_synchronous_connection.as_ref().input_pcm_sample_payload_msb_position}
pub fn get_output_pcm_sample_payload_msb_position(&self) -> u8{ self.enhanced_setup_synchronous_connection.as_ref().output_pcm_sample_payload_msb_position}
pub fn get_input_data_path(&self) -> ScoDataPath{ self.enhanced_setup_synchronous_connection.as_ref().input_data_path}
pub fn get_output_data_path(&self) -> ScoDataPath{ self.enhanced_setup_synchronous_connection.as_ref().output_data_path}
pub fn get_input_transport_unit_bits(&self) -> u8{ self.enhanced_setup_synchronous_connection.as_ref().input_transport_unit_bits}
pub fn get_output_transport_unit_bits(&self) -> u8{ self.enhanced_setup_synchronous_connection.as_ref().output_transport_unit_bits}
pub fn get_max_latency_ms(&self) -> u16{ self.enhanced_setup_synchronous_connection.as_ref().max_latency_ms}
pub fn get_packet_type(&self) -> u16{ self.enhanced_setup_synchronous_connection.as_ref().packet_type}
pub fn get_retransmission_effort(&self) -> RetransmissionEffort{ self.enhanced_setup_synchronous_connection.as_ref().retransmission_effort}
}
impl Into<CommandPacket> for EnhancedSetupSynchronousConnectionPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for EnhancedSetupSynchronousConnectionPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ScoConnectionCommandPacket> for EnhancedSetupSynchronousConnectionPacket { fn into(self) -> ScoConnectionCommandPacket {ScoConnectionCommandPacket::new(self.command) }}
impl CommandExpectations for EnhancedSetupSynchronousConnectionBuilder { type ResponseType = EnhancedSetupSynchronousConnectionStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { EnhancedSetupSynchronousConnectionStatusPacket::new(pkt.event.clone()) }}impl EnhancedSetupSynchronousConnectionBuilder {pub fn build(self) -> EnhancedSetupSynchronousConnectionPacket {let enhanced_setup_synchronous_connection= Arc::new(EnhancedSetupSynchronousConnectionData {connection_handle: self.connection_handle, transmit_bandwidth_octets_per_second: self.transmit_bandwidth_octets_per_second, receive_bandwidth_octets_per_second: self.receive_bandwidth_octets_per_second, transmit_coding_format: self.transmit_coding_format, receive_coding_format: self.receive_coding_format, transmit_codec_frame_size: self.transmit_codec_frame_size, receive_codec_frame_size: self.receive_codec_frame_size, input_bandwidth_octets_per_second: self.input_bandwidth_octets_per_second, output_bandwidth_octets_per_second: self.output_bandwidth_octets_per_second, input_coding_format: self.input_coding_format, output_coding_format: self.output_coding_format, input_coded_data_bits: self.input_coded_data_bits, output_coded_data_bits: self.output_coded_data_bits, input_pcm_data_format: self.input_pcm_data_format, output_pcm_data_format: self.output_pcm_data_format, input_pcm_sample_payload_msb_position: self.input_pcm_sample_payload_msb_position, output_pcm_sample_payload_msb_position: self.output_pcm_sample_payload_msb_position, input_data_path: self.input_data_path, output_data_path: self.output_data_path, input_transport_unit_bits: self.input_transport_unit_bits, output_transport_unit_bits: self.output_transport_unit_bits, max_latency_ms: self.max_latency_ms, packet_type: self.packet_type, retransmission_effort: self.retransmission_effort, });let sco_connection_command= Arc::new(ScoConnectionCommandData {child: ScoConnectionCommandDataChild::EnhancedSetupSynchronousConnection(enhanced_setup_synchronous_connection),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ScoConnectionCommand(sco_connection_command),});let command= Arc::new(CommandData {op_code: OpCode::EnhancedSetupSynchronousConnection, child: CommandDataChild::AclCommand(acl_command),});EnhancedSetupSynchronousConnectionPacket::new(command)}
}
impl Into<CommandPacket> for EnhancedSetupSynchronousConnectionBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for EnhancedSetupSynchronousConnectionBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ScoConnectionCommandPacket> for EnhancedSetupSynchronousConnectionBuilder { fn into(self) -> ScoConnectionCommandPacket { self.build().into() }}


#[derive(Debug)] struct EnhancedSetupSynchronousConnectionStatusData {}
#[derive(Debug, Clone)] pub struct EnhancedSetupSynchronousConnectionStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,enhanced_setup_synchronous_connection_status: Arc<EnhancedSetupSynchronousConnectionStatusData>,}
#[derive(Debug)] pub struct EnhancedSetupSynchronousConnectionStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl EnhancedSetupSynchronousConnectionStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for EnhancedSetupSynchronousConnectionStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl EnhancedSetupSynchronousConnectionStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let enhanced_setup_synchronous_connection_status = match &command_status.child {CommandStatusDataChild::EnhancedSetupSynchronousConnectionStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not EnhancedSetupSynchronousConnectionStatus"),};Self {event,command_status,enhanced_setup_synchronous_connection_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for EnhancedSetupSynchronousConnectionStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for EnhancedSetupSynchronousConnectionStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl EnhancedSetupSynchronousConnectionStatusBuilder {pub fn build(self) -> EnhancedSetupSynchronousConnectionStatusPacket {let enhanced_setup_synchronous_connection_status= Arc::new(EnhancedSetupSynchronousConnectionStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::EnhancedSetupSynchronousConnection, child: CommandStatusDataChild::EnhancedSetupSynchronousConnectionStatus(enhanced_setup_synchronous_connection_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});EnhancedSetupSynchronousConnectionStatusPacket::new(event)}
}
impl Into<EventPacket> for EnhancedSetupSynchronousConnectionStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for EnhancedSetupSynchronousConnectionStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct EnhancedAcceptSynchronousConnectionData {bd_addr: Address, transmit_bandwidth: u32, receive_bandwidth: u32, transmit_coding_format: ScoCodingFormat, receive_coding_format: ScoCodingFormat, transmit_codec_frame_size: u16, receive_codec_frame_size: u16, input_bandwidth: u32, output_bandwidth: u32, input_coding_format: ScoCodingFormat, output_coding_format: ScoCodingFormat, input_coded_data_bits: u16, output_coded_data_bits: u16, input_pcm_data_format: ScoPcmDataFormat, output_pcm_data_format: ScoPcmDataFormat, input_pcm_sample_payload_msb_position: u8, output_pcm_sample_payload_msb_position: u8, input_data_path: ScoDataPath, output_data_path: ScoDataPath, input_transport_unit_bits: u8, output_transport_unit_bits: u8, max_latency: u16, packet_type: u16, retransmission_effort: RetransmissionEffort, }
#[derive(Debug, Clone)] pub struct EnhancedAcceptSynchronousConnectionPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,sco_connection_command: Arc<ScoConnectionCommandData>,enhanced_accept_synchronous_connection: Arc<EnhancedAcceptSynchronousConnectionData>,}
#[derive(Debug)] pub struct EnhancedAcceptSynchronousConnectionBuilder {pub bd_addr: Address, pub transmit_bandwidth: u32, pub receive_bandwidth: u32, pub transmit_coding_format: ScoCodingFormat, pub receive_coding_format: ScoCodingFormat, pub transmit_codec_frame_size: u16, pub receive_codec_frame_size: u16, pub input_bandwidth: u32, pub output_bandwidth: u32, pub input_coding_format: ScoCodingFormat, pub output_coding_format: ScoCodingFormat, pub input_coded_data_bits: u16, pub output_coded_data_bits: u16, pub input_pcm_data_format: ScoPcmDataFormat, pub output_pcm_data_format: ScoPcmDataFormat, pub input_pcm_sample_payload_msb_position: u8, pub output_pcm_sample_payload_msb_position: u8, pub input_data_path: ScoDataPath, pub output_data_path: ScoDataPath, pub input_transport_unit_bits: u8, pub output_transport_unit_bits: u8, pub max_latency: u16, pub packet_type: u16, pub retransmission_effort: RetransmissionEffort, }
impl EnhancedAcceptSynchronousConnectionData {fn conforms(bytes: &[u8]) -> bool {if !ScoCodingFormat::conforms(&bytes[17..22]) { return false; }if !ScoCodingFormat::conforms(&bytes[22..27]) { return false; }if !ScoCodingFormat::conforms(&bytes[39..44]) { return false; }if !ScoCodingFormat::conforms(&bytes[44..49]) { return false; } true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "EnhancedAcceptSynchronousConnection".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "EnhancedAcceptSynchronousConnection".to_string(),    field: "transmit_bandwidth".to_string(),    wanted: 13,    got: bytes.len()});}let transmit_bandwidth = u32::from_le_bytes([bytes[9],bytes[10],bytes[11],bytes[12]]);if bytes.len() < 17 { return Err(Error::InvalidLengthError{    obj: "EnhancedAcceptSynchronousConnection".to_string(),    field: "receive_bandwidth".to_string(),    wanted: 17,    got: bytes.len()});}let receive_bandwidth = u32::from_le_bytes([bytes[13],bytes[14],bytes[15],bytes[16]]);let transmit_coding_format = ScoCodingFormat::parse(&bytes[17..22]).unwrap();let receive_coding_format = ScoCodingFormat::parse(&bytes[22..27]).unwrap();if bytes.len() < 29 { return Err(Error::InvalidLengthError{    obj: "EnhancedAcceptSynchronousConnection".to_string(),    field: "transmit_codec_frame_size".to_string(),    wanted: 29,    got: bytes.len()});}let transmit_codec_frame_size = u16::from_le_bytes([bytes[27],bytes[28]]);if bytes.len() < 31 { return Err(Error::InvalidLengthError{    obj: "EnhancedAcceptSynchronousConnection".to_string(),    field: "receive_codec_frame_size".to_string(),    wanted: 31,    got: bytes.len()});}let receive_codec_frame_size = u16::from_le_bytes([bytes[29],bytes[30]]);if bytes.len() < 35 { return Err(Error::InvalidLengthError{    obj: "EnhancedAcceptSynchronousConnection".to_string(),    field: "input_bandwidth".to_string(),    wanted: 35,    got: bytes.len()});}let input_bandwidth = u32::from_le_bytes([bytes[31],bytes[32],bytes[33],bytes[34]]);if bytes.len() < 39 { return Err(Error::InvalidLengthError{    obj: "EnhancedAcceptSynchronousConnection".to_string(),    field: "output_bandwidth".to_string(),    wanted: 39,    got: bytes.len()});}let output_bandwidth = u32::from_le_bytes([bytes[35],bytes[36],bytes[37],bytes[38]]);let input_coding_format = ScoCodingFormat::parse(&bytes[39..44]).unwrap();let output_coding_format = ScoCodingFormat::parse(&bytes[44..49]).unwrap();if bytes.len() < 51 { return Err(Error::InvalidLengthError{    obj: "EnhancedAcceptSynchronousConnection".to_string(),    field: "input_coded_data_bits".to_string(),    wanted: 51,    got: bytes.len()});}let input_coded_data_bits = u16::from_le_bytes([bytes[49],bytes[50]]);if bytes.len() < 53 { return Err(Error::InvalidLengthError{    obj: "EnhancedAcceptSynchronousConnection".to_string(),    field: "output_coded_data_bits".to_string(),    wanted: 53,    got: bytes.len()});}let output_coded_data_bits = u16::from_le_bytes([bytes[51],bytes[52]]);if bytes.len() < 54 { return Err(Error::InvalidLengthError{    obj: "EnhancedAcceptSynchronousConnection".to_string(),    field: "input_pcm_data_format".to_string(),    wanted: 54,    got: bytes.len()});}let input_pcm_data_format = u8::from_le_bytes([bytes[53]]);let input_pcm_data_format = ScoPcmDataFormat::from_u8(input_pcm_data_format).unwrap();if bytes.len() < 55 { return Err(Error::InvalidLengthError{    obj: "EnhancedAcceptSynchronousConnection".to_string(),    field: "output_pcm_data_format".to_string(),    wanted: 55,    got: bytes.len()});}let output_pcm_data_format = u8::from_le_bytes([bytes[54]]);let output_pcm_data_format = ScoPcmDataFormat::from_u8(output_pcm_data_format).unwrap();if bytes.len() < 56 { return Err(Error::InvalidLengthError{    obj: "EnhancedAcceptSynchronousConnection".to_string(),    field: "input_pcm_sample_payload_msb_position".to_string(),    wanted: 56,    got: bytes.len()});}let input_pcm_sample_payload_msb_position = u8::from_le_bytes([bytes[55]]);if bytes.len() < 57 { return Err(Error::InvalidLengthError{    obj: "EnhancedAcceptSynchronousConnection".to_string(),    field: "output_pcm_sample_payload_msb_position".to_string(),    wanted: 57,    got: bytes.len()});}let output_pcm_sample_payload_msb_position = u8::from_le_bytes([bytes[56]]);if bytes.len() < 58 { return Err(Error::InvalidLengthError{    obj: "EnhancedAcceptSynchronousConnection".to_string(),    field: "input_data_path".to_string(),    wanted: 58,    got: bytes.len()});}let input_data_path = u8::from_le_bytes([bytes[57]]);let input_data_path = ScoDataPath::from_u8(input_data_path).unwrap();if bytes.len() < 59 { return Err(Error::InvalidLengthError{    obj: "EnhancedAcceptSynchronousConnection".to_string(),    field: "output_data_path".to_string(),    wanted: 59,    got: bytes.len()});}let output_data_path = u8::from_le_bytes([bytes[58]]);let output_data_path = ScoDataPath::from_u8(output_data_path).unwrap();if bytes.len() < 60 { return Err(Error::InvalidLengthError{    obj: "EnhancedAcceptSynchronousConnection".to_string(),    field: "input_transport_unit_bits".to_string(),    wanted: 60,    got: bytes.len()});}let input_transport_unit_bits = u8::from_le_bytes([bytes[59]]);if bytes.len() < 61 { return Err(Error::InvalidLengthError{    obj: "EnhancedAcceptSynchronousConnection".to_string(),    field: "output_transport_unit_bits".to_string(),    wanted: 61,    got: bytes.len()});}let output_transport_unit_bits = u8::from_le_bytes([bytes[60]]);if bytes.len() < 63 { return Err(Error::InvalidLengthError{    obj: "EnhancedAcceptSynchronousConnection".to_string(),    field: "max_latency".to_string(),    wanted: 63,    got: bytes.len()});}let max_latency = u16::from_le_bytes([bytes[61],bytes[62]]);if bytes.len() < 65 { return Err(Error::InvalidLengthError{    obj: "EnhancedAcceptSynchronousConnection".to_string(),    field: "packet_type".to_string(),    wanted: 65,    got: bytes.len()});}let packet_type = u16::from_le_bytes([bytes[63],bytes[64]]);if bytes.len() < 66 { return Err(Error::InvalidLengthError{    obj: "EnhancedAcceptSynchronousConnection".to_string(),    field: "retransmission_effort".to_string(),    wanted: 66,    got: bytes.len()});}let retransmission_effort = u8::from_le_bytes([bytes[65]]);let retransmission_effort = RetransmissionEffort::from_u8(retransmission_effort).unwrap();Ok(Self {bd_addr, transmit_bandwidth, receive_bandwidth, transmit_coding_format, receive_coding_format, transmit_codec_frame_size, receive_codec_frame_size, input_bandwidth, output_bandwidth, input_coding_format, output_coding_format, input_coded_data_bits, output_coded_data_bits, input_pcm_data_format, output_pcm_data_format, input_pcm_sample_payload_msb_position, output_pcm_sample_payload_msb_position, input_data_path, output_data_path, input_transport_unit_bits, output_transport_unit_bits, max_latency, packet_type, retransmission_effort, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);let transmit_bandwidth = self.transmit_bandwidth;buffer[9..13].copy_from_slice(&transmit_bandwidth.to_le_bytes()[0..4]);let receive_bandwidth = self.receive_bandwidth;buffer[13..17].copy_from_slice(&receive_bandwidth.to_le_bytes()[0..4]);let transmit_coding_format = &mut buffer[17..22];self.transmit_coding_format.write_to(transmit_coding_format);let receive_coding_format = &mut buffer[22..27];self.receive_coding_format.write_to(receive_coding_format);let transmit_codec_frame_size = self.transmit_codec_frame_size;buffer[27..29].copy_from_slice(&transmit_codec_frame_size.to_le_bytes()[0..2]);let receive_codec_frame_size = self.receive_codec_frame_size;buffer[29..31].copy_from_slice(&receive_codec_frame_size.to_le_bytes()[0..2]);let input_bandwidth = self.input_bandwidth;buffer[31..35].copy_from_slice(&input_bandwidth.to_le_bytes()[0..4]);let output_bandwidth = self.output_bandwidth;buffer[35..39].copy_from_slice(&output_bandwidth.to_le_bytes()[0..4]);let input_coding_format = &mut buffer[39..44];self.input_coding_format.write_to(input_coding_format);let output_coding_format = &mut buffer[44..49];self.output_coding_format.write_to(output_coding_format);let input_coded_data_bits = self.input_coded_data_bits;buffer[49..51].copy_from_slice(&input_coded_data_bits.to_le_bytes()[0..2]);let output_coded_data_bits = self.output_coded_data_bits;buffer[51..53].copy_from_slice(&output_coded_data_bits.to_le_bytes()[0..2]);let input_pcm_data_format = self.input_pcm_data_format.to_u8().unwrap();buffer[53..54].copy_from_slice(&input_pcm_data_format.to_le_bytes()[0..1]);let output_pcm_data_format = self.output_pcm_data_format.to_u8().unwrap();buffer[54..55].copy_from_slice(&output_pcm_data_format.to_le_bytes()[0..1]);let input_pcm_sample_payload_msb_position = self.input_pcm_sample_payload_msb_position;buffer[55..56].copy_from_slice(&input_pcm_sample_payload_msb_position.to_le_bytes()[0..1]);let output_pcm_sample_payload_msb_position = self.output_pcm_sample_payload_msb_position;buffer[56..57].copy_from_slice(&output_pcm_sample_payload_msb_position.to_le_bytes()[0..1]);let input_data_path = self.input_data_path.to_u8().unwrap();buffer[57..58].copy_from_slice(&input_data_path.to_le_bytes()[0..1]);let output_data_path = self.output_data_path.to_u8().unwrap();buffer[58..59].copy_from_slice(&output_data_path.to_le_bytes()[0..1]);let input_transport_unit_bits = self.input_transport_unit_bits;buffer[59..60].copy_from_slice(&input_transport_unit_bits.to_le_bytes()[0..1]);let output_transport_unit_bits = self.output_transport_unit_bits;buffer[60..61].copy_from_slice(&output_transport_unit_bits.to_le_bytes()[0..1]);let max_latency = self.max_latency;buffer[61..63].copy_from_slice(&max_latency.to_le_bytes()[0..2]);let packet_type = self.packet_type;buffer[63..65].copy_from_slice(&packet_type.to_le_bytes()[0..2]);let retransmission_effort = self.retransmission_effort.to_u8().unwrap();buffer[65..66].copy_from_slice(&retransmission_effort.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 63;ret}
}
impl CommandExpectations for EnhancedAcceptSynchronousConnectionPacket { type ResponseType = EnhancedAcceptSynchronousConnectionStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { EnhancedAcceptSynchronousConnectionStatusPacket::new(pkt.event.clone()) }}impl Packet for EnhancedAcceptSynchronousConnectionPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl EnhancedAcceptSynchronousConnectionPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let sco_connection_command = match &acl_command.child {AclCommandDataChild::ScoConnectionCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ScoConnectionCommand"),};let enhanced_accept_synchronous_connection = match &sco_connection_command.child {ScoConnectionCommandDataChild::EnhancedAcceptSynchronousConnection(value) => (*value).clone(),_ => panic!("inconsistent state - child was not EnhancedAcceptSynchronousConnection"),};Self {command,acl_command,sco_connection_command,enhanced_accept_synchronous_connection,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.enhanced_accept_synchronous_connection.as_ref().bd_addr}
pub fn get_transmit_bandwidth(&self) -> u32{ self.enhanced_accept_synchronous_connection.as_ref().transmit_bandwidth}
pub fn get_receive_bandwidth(&self) -> u32{ self.enhanced_accept_synchronous_connection.as_ref().receive_bandwidth}
pub fn get_transmit_coding_format(&self) -> &ScoCodingFormat{ &self.enhanced_accept_synchronous_connection.as_ref().transmit_coding_format}
pub fn get_receive_coding_format(&self) -> &ScoCodingFormat{ &self.enhanced_accept_synchronous_connection.as_ref().receive_coding_format}
pub fn get_transmit_codec_frame_size(&self) -> u16{ self.enhanced_accept_synchronous_connection.as_ref().transmit_codec_frame_size}
pub fn get_receive_codec_frame_size(&self) -> u16{ self.enhanced_accept_synchronous_connection.as_ref().receive_codec_frame_size}
pub fn get_input_bandwidth(&self) -> u32{ self.enhanced_accept_synchronous_connection.as_ref().input_bandwidth}
pub fn get_output_bandwidth(&self) -> u32{ self.enhanced_accept_synchronous_connection.as_ref().output_bandwidth}
pub fn get_input_coding_format(&self) -> &ScoCodingFormat{ &self.enhanced_accept_synchronous_connection.as_ref().input_coding_format}
pub fn get_output_coding_format(&self) -> &ScoCodingFormat{ &self.enhanced_accept_synchronous_connection.as_ref().output_coding_format}
pub fn get_input_coded_data_bits(&self) -> u16{ self.enhanced_accept_synchronous_connection.as_ref().input_coded_data_bits}
pub fn get_output_coded_data_bits(&self) -> u16{ self.enhanced_accept_synchronous_connection.as_ref().output_coded_data_bits}
pub fn get_input_pcm_data_format(&self) -> ScoPcmDataFormat{ self.enhanced_accept_synchronous_connection.as_ref().input_pcm_data_format}
pub fn get_output_pcm_data_format(&self) -> ScoPcmDataFormat{ self.enhanced_accept_synchronous_connection.as_ref().output_pcm_data_format}
pub fn get_input_pcm_sample_payload_msb_position(&self) -> u8{ self.enhanced_accept_synchronous_connection.as_ref().input_pcm_sample_payload_msb_position}
pub fn get_output_pcm_sample_payload_msb_position(&self) -> u8{ self.enhanced_accept_synchronous_connection.as_ref().output_pcm_sample_payload_msb_position}
pub fn get_input_data_path(&self) -> ScoDataPath{ self.enhanced_accept_synchronous_connection.as_ref().input_data_path}
pub fn get_output_data_path(&self) -> ScoDataPath{ self.enhanced_accept_synchronous_connection.as_ref().output_data_path}
pub fn get_input_transport_unit_bits(&self) -> u8{ self.enhanced_accept_synchronous_connection.as_ref().input_transport_unit_bits}
pub fn get_output_transport_unit_bits(&self) -> u8{ self.enhanced_accept_synchronous_connection.as_ref().output_transport_unit_bits}
pub fn get_max_latency(&self) -> u16{ self.enhanced_accept_synchronous_connection.as_ref().max_latency}
pub fn get_packet_type(&self) -> u16{ self.enhanced_accept_synchronous_connection.as_ref().packet_type}
pub fn get_retransmission_effort(&self) -> RetransmissionEffort{ self.enhanced_accept_synchronous_connection.as_ref().retransmission_effort}
}
impl Into<CommandPacket> for EnhancedAcceptSynchronousConnectionPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for EnhancedAcceptSynchronousConnectionPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ScoConnectionCommandPacket> for EnhancedAcceptSynchronousConnectionPacket { fn into(self) -> ScoConnectionCommandPacket {ScoConnectionCommandPacket::new(self.command) }}
impl CommandExpectations for EnhancedAcceptSynchronousConnectionBuilder { type ResponseType = EnhancedAcceptSynchronousConnectionStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { EnhancedAcceptSynchronousConnectionStatusPacket::new(pkt.event.clone()) }}impl EnhancedAcceptSynchronousConnectionBuilder {pub fn build(self) -> EnhancedAcceptSynchronousConnectionPacket {let enhanced_accept_synchronous_connection= Arc::new(EnhancedAcceptSynchronousConnectionData {bd_addr: self.bd_addr, transmit_bandwidth: self.transmit_bandwidth, receive_bandwidth: self.receive_bandwidth, transmit_coding_format: self.transmit_coding_format, receive_coding_format: self.receive_coding_format, transmit_codec_frame_size: self.transmit_codec_frame_size, receive_codec_frame_size: self.receive_codec_frame_size, input_bandwidth: self.input_bandwidth, output_bandwidth: self.output_bandwidth, input_coding_format: self.input_coding_format, output_coding_format: self.output_coding_format, input_coded_data_bits: self.input_coded_data_bits, output_coded_data_bits: self.output_coded_data_bits, input_pcm_data_format: self.input_pcm_data_format, output_pcm_data_format: self.output_pcm_data_format, input_pcm_sample_payload_msb_position: self.input_pcm_sample_payload_msb_position, output_pcm_sample_payload_msb_position: self.output_pcm_sample_payload_msb_position, input_data_path: self.input_data_path, output_data_path: self.output_data_path, input_transport_unit_bits: self.input_transport_unit_bits, output_transport_unit_bits: self.output_transport_unit_bits, max_latency: self.max_latency, packet_type: self.packet_type, retransmission_effort: self.retransmission_effort, });let sco_connection_command= Arc::new(ScoConnectionCommandData {child: ScoConnectionCommandDataChild::EnhancedAcceptSynchronousConnection(enhanced_accept_synchronous_connection),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ScoConnectionCommand(sco_connection_command),});let command= Arc::new(CommandData {op_code: OpCode::EnhancedAcceptSynchronousConnection, child: CommandDataChild::AclCommand(acl_command),});EnhancedAcceptSynchronousConnectionPacket::new(command)}
}
impl Into<CommandPacket> for EnhancedAcceptSynchronousConnectionBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for EnhancedAcceptSynchronousConnectionBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ScoConnectionCommandPacket> for EnhancedAcceptSynchronousConnectionBuilder { fn into(self) -> ScoConnectionCommandPacket { self.build().into() }}


#[derive(Debug)] struct EnhancedAcceptSynchronousConnectionStatusData {}
#[derive(Debug, Clone)] pub struct EnhancedAcceptSynchronousConnectionStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,enhanced_accept_synchronous_connection_status: Arc<EnhancedAcceptSynchronousConnectionStatusData>,}
#[derive(Debug)] pub struct EnhancedAcceptSynchronousConnectionStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl EnhancedAcceptSynchronousConnectionStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for EnhancedAcceptSynchronousConnectionStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl EnhancedAcceptSynchronousConnectionStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let enhanced_accept_synchronous_connection_status = match &command_status.child {CommandStatusDataChild::EnhancedAcceptSynchronousConnectionStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not EnhancedAcceptSynchronousConnectionStatus"),};Self {event,command_status,enhanced_accept_synchronous_connection_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for EnhancedAcceptSynchronousConnectionStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for EnhancedAcceptSynchronousConnectionStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl EnhancedAcceptSynchronousConnectionStatusBuilder {pub fn build(self) -> EnhancedAcceptSynchronousConnectionStatusPacket {let enhanced_accept_synchronous_connection_status= Arc::new(EnhancedAcceptSynchronousConnectionStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::EnhancedAcceptSynchronousConnection, child: CommandStatusDataChild::EnhancedAcceptSynchronousConnectionStatus(enhanced_accept_synchronous_connection_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});EnhancedAcceptSynchronousConnectionStatusPacket::new(event)}
}
impl Into<EventPacket> for EnhancedAcceptSynchronousConnectionStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for EnhancedAcceptSynchronousConnectionStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct RemoteOobExtendedDataRequestReplyData {bd_addr: Address, c_192: [u8; 16], r_192: [u8; 16], c_256: [u8; 16], r_256: [u8; 16], }
#[derive(Debug, Clone)] pub struct RemoteOobExtendedDataRequestReplyPacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,remote_oob_extended_data_request_reply: Arc<RemoteOobExtendedDataRequestReplyData>,}
#[derive(Debug)] pub struct RemoteOobExtendedDataRequestReplyBuilder {pub bd_addr: Address, pub c_192: [u8; 16], pub r_192: [u8; 16], pub c_256: [u8; 16], pub r_256: [u8; 16], }
impl RemoteOobExtendedDataRequestReplyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "RemoteOobExtendedDataRequestReply".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();if bytes.len() < 25 { return Err(Error::InvalidLengthError{    obj: "RemoteOobExtendedDataRequestReply".to_string(),    field: "c_192".to_string(),    wanted: 25,    got: bytes.len()});}let c_192 = bytes[9..25].try_into().unwrap();if bytes.len() < 41 { return Err(Error::InvalidLengthError{    obj: "RemoteOobExtendedDataRequestReply".to_string(),    field: "r_192".to_string(),    wanted: 41,    got: bytes.len()});}let r_192 = bytes[25..41].try_into().unwrap();if bytes.len() < 57 { return Err(Error::InvalidLengthError{    obj: "RemoteOobExtendedDataRequestReply".to_string(),    field: "c_256".to_string(),    wanted: 57,    got: bytes.len()});}let c_256 = bytes[41..57].try_into().unwrap();if bytes.len() < 73 { return Err(Error::InvalidLengthError{    obj: "RemoteOobExtendedDataRequestReply".to_string(),    field: "r_256".to_string(),    wanted: 73,    got: bytes.len()});}let r_256 = bytes[57..73].try_into().unwrap();Ok(Self {bd_addr, c_192, r_192, c_256, r_256, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);&buffer[9..25].copy_from_slice(&self.c_192);&buffer[25..41].copy_from_slice(&self.r_192);&buffer[41..57].copy_from_slice(&self.c_256);&buffer[57..73].copy_from_slice(&self.r_256);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 70;ret}
}
impl CommandExpectations for RemoteOobExtendedDataRequestReplyPacket { type ResponseType = RemoteOobExtendedDataRequestReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { RemoteOobExtendedDataRequestReplyCompletePacket::new(pkt.event.clone()) }}impl Packet for RemoteOobExtendedDataRequestReplyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl RemoteOobExtendedDataRequestReplyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let remote_oob_extended_data_request_reply = match &security_command.child {SecurityCommandDataChild::RemoteOobExtendedDataRequestReply(value) => (*value).clone(),_ => panic!("inconsistent state - child was not RemoteOobExtendedDataRequestReply"),};Self {command,security_command,remote_oob_extended_data_request_reply,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.remote_oob_extended_data_request_reply.as_ref().bd_addr}
pub fn get_c_192(&self) -> &[u8; 16]{ &self.remote_oob_extended_data_request_reply.as_ref().c_192}
pub fn get_r_192(&self) -> &[u8; 16]{ &self.remote_oob_extended_data_request_reply.as_ref().r_192}
pub fn get_c_256(&self) -> &[u8; 16]{ &self.remote_oob_extended_data_request_reply.as_ref().c_256}
pub fn get_r_256(&self) -> &[u8; 16]{ &self.remote_oob_extended_data_request_reply.as_ref().r_256}
}
impl Into<CommandPacket> for RemoteOobExtendedDataRequestReplyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for RemoteOobExtendedDataRequestReplyPacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for RemoteOobExtendedDataRequestReplyBuilder { type ResponseType = RemoteOobExtendedDataRequestReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { RemoteOobExtendedDataRequestReplyCompletePacket::new(pkt.event.clone()) }}impl RemoteOobExtendedDataRequestReplyBuilder {pub fn build(self) -> RemoteOobExtendedDataRequestReplyPacket {let remote_oob_extended_data_request_reply= Arc::new(RemoteOobExtendedDataRequestReplyData {bd_addr: self.bd_addr, c_192: self.c_192, r_192: self.r_192, c_256: self.c_256, r_256: self.r_256, });let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::RemoteOobExtendedDataRequestReply(remote_oob_extended_data_request_reply),});let command= Arc::new(CommandData {op_code: OpCode::RemoteOobExtendedDataRequestReply, child: CommandDataChild::SecurityCommand(security_command),});RemoteOobExtendedDataRequestReplyPacket::new(command)}
}
impl Into<CommandPacket> for RemoteOobExtendedDataRequestReplyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for RemoteOobExtendedDataRequestReplyBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct RemoteOobExtendedDataRequestReplyCompleteData {status: ErrorCode, bd_addr: Address, }
#[derive(Debug, Clone)] pub struct RemoteOobExtendedDataRequestReplyCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,remote_oob_extended_data_request_reply_complete: Arc<RemoteOobExtendedDataRequestReplyCompleteData>,}
#[derive(Debug)] pub struct RemoteOobExtendedDataRequestReplyCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub bd_addr: Address, }
impl RemoteOobExtendedDataRequestReplyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "RemoteOobExtendedDataRequestReplyComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "RemoteOobExtendedDataRequestReplyComplete".to_string(),    field: "bd_addr".to_string(),    wanted: 12,    got: bytes.len()});}let bd_addr = bytes[6..12].try_into().unwrap();Ok(Self {status, bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let bd_addr: [u8; 6] = self.bd_addr.into();buffer[6..12].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for RemoteOobExtendedDataRequestReplyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl RemoteOobExtendedDataRequestReplyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let remote_oob_extended_data_request_reply_complete = match &command_complete.child {CommandCompleteDataChild::RemoteOobExtendedDataRequestReplyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not RemoteOobExtendedDataRequestReplyComplete"),};Self {event,command_complete,remote_oob_extended_data_request_reply_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.remote_oob_extended_data_request_reply_complete.as_ref().status}
pub fn get_bd_addr(&self) -> Address{ self.remote_oob_extended_data_request_reply_complete.as_ref().bd_addr}
}
impl Into<EventPacket> for RemoteOobExtendedDataRequestReplyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for RemoteOobExtendedDataRequestReplyCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl RemoteOobExtendedDataRequestReplyCompleteBuilder {pub fn build(self) -> RemoteOobExtendedDataRequestReplyCompletePacket {let remote_oob_extended_data_request_reply_complete= Arc::new(RemoteOobExtendedDataRequestReplyCompleteData {status: self.status, bd_addr: self.bd_addr, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::RemoteOobExtendedDataRequestReply, child: CommandCompleteDataChild::RemoteOobExtendedDataRequestReplyComplete(remote_oob_extended_data_request_reply_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});RemoteOobExtendedDataRequestReplyCompletePacket::new(event)}
}
impl Into<EventPacket> for RemoteOobExtendedDataRequestReplyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for RemoteOobExtendedDataRequestReplyCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct HoldModeData {connection_handle: u16, hold_mode_max_interval: u16, hold_mode_min_interval: u16, }
#[derive(Debug, Clone)] pub struct HoldModePacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,hold_mode: Arc<HoldModeData>,}
#[derive(Debug)] pub struct HoldModeBuilder {pub connection_handle: u16, pub hold_mode_max_interval: u16, pub hold_mode_min_interval: u16, }
impl HoldModeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "HoldMode".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "HoldMode".to_string(),    field: "hold_mode_max_interval".to_string(),    wanted: 7,    got: bytes.len()});}let hold_mode_max_interval = u16::from_le_bytes([bytes[5],bytes[6]]);if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "HoldMode".to_string(),    field: "hold_mode_min_interval".to_string(),    wanted: 9,    got: bytes.len()});}let hold_mode_min_interval = u16::from_le_bytes([bytes[7],bytes[8]]);Ok(Self {connection_handle, hold_mode_max_interval, hold_mode_min_interval, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let hold_mode_max_interval = self.hold_mode_max_interval;buffer[5..7].copy_from_slice(&hold_mode_max_interval.to_le_bytes()[0..2]);let hold_mode_min_interval = self.hold_mode_min_interval;buffer[7..9].copy_from_slice(&hold_mode_min_interval.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl CommandExpectations for HoldModePacket { type ResponseType = HoldModeStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { HoldModeStatusPacket::new(pkt.event.clone()) }}impl Packet for HoldModePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl HoldModePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let hold_mode = match &connection_management_command.child {ConnectionManagementCommandDataChild::HoldMode(value) => (*value).clone(),_ => panic!("inconsistent state - child was not HoldMode"),};Self {command,acl_command,connection_management_command,hold_mode,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.hold_mode.as_ref().connection_handle}
pub fn get_hold_mode_max_interval(&self) -> u16{ self.hold_mode.as_ref().hold_mode_max_interval}
pub fn get_hold_mode_min_interval(&self) -> u16{ self.hold_mode.as_ref().hold_mode_min_interval}
}
impl Into<CommandPacket> for HoldModePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for HoldModePacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for HoldModePacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for HoldModeBuilder { type ResponseType = HoldModeStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { HoldModeStatusPacket::new(pkt.event.clone()) }}impl HoldModeBuilder {pub fn build(self) -> HoldModePacket {let hold_mode= Arc::new(HoldModeData {connection_handle: self.connection_handle, hold_mode_max_interval: self.hold_mode_max_interval, hold_mode_min_interval: self.hold_mode_min_interval, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::HoldMode(hold_mode),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::HoldMode, child: CommandDataChild::AclCommand(acl_command),});HoldModePacket::new(command)}
}
impl Into<CommandPacket> for HoldModeBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for HoldModeBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for HoldModeBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct HoldModeStatusData {}
#[derive(Debug, Clone)] pub struct HoldModeStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,hold_mode_status: Arc<HoldModeStatusData>,}
#[derive(Debug)] pub struct HoldModeStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl HoldModeStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for HoldModeStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl HoldModeStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let hold_mode_status = match &command_status.child {CommandStatusDataChild::HoldModeStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not HoldModeStatus"),};Self {event,command_status,hold_mode_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for HoldModeStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for HoldModeStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl HoldModeStatusBuilder {pub fn build(self) -> HoldModeStatusPacket {let hold_mode_status= Arc::new(HoldModeStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::HoldMode, child: CommandStatusDataChild::HoldModeStatus(hold_mode_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});HoldModeStatusPacket::new(event)}
}
impl Into<EventPacket> for HoldModeStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for HoldModeStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct SniffModeData {connection_handle: u16, sniff_max_interval: u16, sniff_min_interval: u16, sniff_attempt: u16, sniff_timeout: u16, }
#[derive(Debug, Clone)] pub struct SniffModePacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,sniff_mode: Arc<SniffModeData>,}
#[derive(Debug)] pub struct SniffModeBuilder {pub connection_handle: u16, pub sniff_max_interval: u16, pub sniff_min_interval: u16, pub sniff_attempt: u16, pub sniff_timeout: u16, }
impl SniffModeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "SniffMode".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "SniffMode".to_string(),    field: "sniff_max_interval".to_string(),    wanted: 7,    got: bytes.len()});}let sniff_max_interval = u16::from_le_bytes([bytes[5],bytes[6]]);if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "SniffMode".to_string(),    field: "sniff_min_interval".to_string(),    wanted: 9,    got: bytes.len()});}let sniff_min_interval = u16::from_le_bytes([bytes[7],bytes[8]]);if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "SniffMode".to_string(),    field: "sniff_attempt".to_string(),    wanted: 11,    got: bytes.len()});}let sniff_attempt = u16::from_le_bytes([bytes[9],bytes[10]]);if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "SniffMode".to_string(),    field: "sniff_timeout".to_string(),    wanted: 13,    got: bytes.len()});}let sniff_timeout = u16::from_le_bytes([bytes[11],bytes[12]]);Ok(Self {connection_handle, sniff_max_interval, sniff_min_interval, sniff_attempt, sniff_timeout, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let sniff_max_interval = self.sniff_max_interval;buffer[5..7].copy_from_slice(&sniff_max_interval.to_le_bytes()[0..2]);let sniff_min_interval = self.sniff_min_interval;buffer[7..9].copy_from_slice(&sniff_min_interval.to_le_bytes()[0..2]);let sniff_attempt = self.sniff_attempt;buffer[9..11].copy_from_slice(&sniff_attempt.to_le_bytes()[0..2]);let sniff_timeout = self.sniff_timeout;buffer[11..13].copy_from_slice(&sniff_timeout.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 10;ret}
}
impl CommandExpectations for SniffModePacket { type ResponseType = SniffModeStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { SniffModeStatusPacket::new(pkt.event.clone()) }}impl Packet for SniffModePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SniffModePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let sniff_mode = match &connection_management_command.child {ConnectionManagementCommandDataChild::SniffMode(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SniffMode"),};Self {command,acl_command,connection_management_command,sniff_mode,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.sniff_mode.as_ref().connection_handle}
pub fn get_sniff_max_interval(&self) -> u16{ self.sniff_mode.as_ref().sniff_max_interval}
pub fn get_sniff_min_interval(&self) -> u16{ self.sniff_mode.as_ref().sniff_min_interval}
pub fn get_sniff_attempt(&self) -> u16{ self.sniff_mode.as_ref().sniff_attempt}
pub fn get_sniff_timeout(&self) -> u16{ self.sniff_mode.as_ref().sniff_timeout}
}
impl Into<CommandPacket> for SniffModePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for SniffModePacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for SniffModePacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for SniffModeBuilder { type ResponseType = SniffModeStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { SniffModeStatusPacket::new(pkt.event.clone()) }}impl SniffModeBuilder {pub fn build(self) -> SniffModePacket {let sniff_mode= Arc::new(SniffModeData {connection_handle: self.connection_handle, sniff_max_interval: self.sniff_max_interval, sniff_min_interval: self.sniff_min_interval, sniff_attempt: self.sniff_attempt, sniff_timeout: self.sniff_timeout, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::SniffMode(sniff_mode),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::SniffMode, child: CommandDataChild::AclCommand(acl_command),});SniffModePacket::new(command)}
}
impl Into<CommandPacket> for SniffModeBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for SniffModeBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for SniffModeBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct SniffModeStatusData {}
#[derive(Debug, Clone)] pub struct SniffModeStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,sniff_mode_status: Arc<SniffModeStatusData>,}
#[derive(Debug)] pub struct SniffModeStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl SniffModeStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for SniffModeStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SniffModeStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let sniff_mode_status = match &command_status.child {CommandStatusDataChild::SniffModeStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SniffModeStatus"),};Self {event,command_status,sniff_mode_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for SniffModeStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for SniffModeStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl SniffModeStatusBuilder {pub fn build(self) -> SniffModeStatusPacket {let sniff_mode_status= Arc::new(SniffModeStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::SniffMode, child: CommandStatusDataChild::SniffModeStatus(sniff_mode_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});SniffModeStatusPacket::new(event)}
}
impl Into<EventPacket> for SniffModeStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for SniffModeStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct ExitSniffModeData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct ExitSniffModePacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,exit_sniff_mode: Arc<ExitSniffModeData>,}
#[derive(Debug)] pub struct ExitSniffModeBuilder {pub connection_handle: u16, }
impl ExitSniffModeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ExitSniffMode".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for ExitSniffModePacket { type ResponseType = ExitSniffModeStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ExitSniffModeStatusPacket::new(pkt.event.clone()) }}impl Packet for ExitSniffModePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ExitSniffModePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let exit_sniff_mode = match &connection_management_command.child {ConnectionManagementCommandDataChild::ExitSniffMode(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ExitSniffMode"),};Self {command,acl_command,connection_management_command,exit_sniff_mode,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.exit_sniff_mode.as_ref().connection_handle}
}
impl Into<CommandPacket> for ExitSniffModePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for ExitSniffModePacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for ExitSniffModePacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for ExitSniffModeBuilder { type ResponseType = ExitSniffModeStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ExitSniffModeStatusPacket::new(pkt.event.clone()) }}impl ExitSniffModeBuilder {pub fn build(self) -> ExitSniffModePacket {let exit_sniff_mode= Arc::new(ExitSniffModeData {connection_handle: self.connection_handle, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::ExitSniffMode(exit_sniff_mode),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::ExitSniffMode, child: CommandDataChild::AclCommand(acl_command),});ExitSniffModePacket::new(command)}
}
impl Into<CommandPacket> for ExitSniffModeBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for ExitSniffModeBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for ExitSniffModeBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct ExitSniffModeStatusData {}
#[derive(Debug, Clone)] pub struct ExitSniffModeStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,exit_sniff_mode_status: Arc<ExitSniffModeStatusData>,}
#[derive(Debug)] pub struct ExitSniffModeStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl ExitSniffModeStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for ExitSniffModeStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ExitSniffModeStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let exit_sniff_mode_status = match &command_status.child {CommandStatusDataChild::ExitSniffModeStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ExitSniffModeStatus"),};Self {event,command_status,exit_sniff_mode_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for ExitSniffModeStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for ExitSniffModeStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl ExitSniffModeStatusBuilder {pub fn build(self) -> ExitSniffModeStatusPacket {let exit_sniff_mode_status= Arc::new(ExitSniffModeStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ExitSniffMode, child: CommandStatusDataChild::ExitSniffModeStatus(exit_sniff_mode_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});ExitSniffModeStatusPacket::new(event)}
}
impl Into<EventPacket> for ExitSniffModeStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for ExitSniffModeStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct QosSetupData {connection_handle: u16, service_type: ServiceType, token_rate: u32, peak_bandwidth: u32, latency: u32, delay_variation: u32, }
#[derive(Debug, Clone)] pub struct QosSetupPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,qos_setup: Arc<QosSetupData>,}
#[derive(Debug)] pub struct QosSetupBuilder {pub connection_handle: u16, pub service_type: ServiceType, pub token_rate: u32, pub peak_bandwidth: u32, pub latency: u32, pub delay_variation: u32, }
impl QosSetupData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "QosSetup".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "QosSetup".to_string(),    field: "service_type".to_string(),    wanted: 7,    got: bytes.len()});}let service_type = u8::from_le_bytes([bytes[6]]);let service_type = ServiceType::from_u8(service_type).unwrap();if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "QosSetup".to_string(),    field: "token_rate".to_string(),    wanted: 11,    got: bytes.len()});}let token_rate = u32::from_le_bytes([bytes[7],bytes[8],bytes[9],bytes[10]]);if bytes.len() < 15 { return Err(Error::InvalidLengthError{    obj: "QosSetup".to_string(),    field: "peak_bandwidth".to_string(),    wanted: 15,    got: bytes.len()});}let peak_bandwidth = u32::from_le_bytes([bytes[11],bytes[12],bytes[13],bytes[14]]);if bytes.len() < 19 { return Err(Error::InvalidLengthError{    obj: "QosSetup".to_string(),    field: "latency".to_string(),    wanted: 19,    got: bytes.len()});}let latency = u32::from_le_bytes([bytes[15],bytes[16],bytes[17],bytes[18]]);if bytes.len() < 23 { return Err(Error::InvalidLengthError{    obj: "QosSetup".to_string(),    field: "delay_variation".to_string(),    wanted: 23,    got: bytes.len()});}let delay_variation = u32::from_le_bytes([bytes[19],bytes[20],bytes[21],bytes[22]]);Ok(Self {connection_handle, service_type, token_rate, peak_bandwidth, latency, delay_variation, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let service_type = self.service_type.to_u8().unwrap();buffer[6..7].copy_from_slice(&service_type.to_le_bytes()[0..1]);let token_rate = self.token_rate;buffer[7..11].copy_from_slice(&token_rate.to_le_bytes()[0..4]);let peak_bandwidth = self.peak_bandwidth;buffer[11..15].copy_from_slice(&peak_bandwidth.to_le_bytes()[0..4]);let latency = self.latency;buffer[15..19].copy_from_slice(&latency.to_le_bytes()[0..4]);let delay_variation = self.delay_variation;buffer[19..23].copy_from_slice(&delay_variation.to_le_bytes()[0..4]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 20;ret}
}
impl CommandExpectations for QosSetupPacket { type ResponseType = QosSetupStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { QosSetupStatusPacket::new(pkt.event.clone()) }}impl Packet for QosSetupPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl QosSetupPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let qos_setup = match &connection_management_command.child {ConnectionManagementCommandDataChild::QosSetup(value) => (*value).clone(),_ => panic!("inconsistent state - child was not QosSetup"),};Self {command,acl_command,connection_management_command,qos_setup,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.qos_setup.as_ref().connection_handle}
pub fn get_service_type(&self) -> ServiceType{ self.qos_setup.as_ref().service_type}
pub fn get_token_rate(&self) -> u32{ self.qos_setup.as_ref().token_rate}
pub fn get_peak_bandwidth(&self) -> u32{ self.qos_setup.as_ref().peak_bandwidth}
pub fn get_latency(&self) -> u32{ self.qos_setup.as_ref().latency}
pub fn get_delay_variation(&self) -> u32{ self.qos_setup.as_ref().delay_variation}
}
impl Into<CommandPacket> for QosSetupPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for QosSetupPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for QosSetupPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for QosSetupBuilder { type ResponseType = QosSetupStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { QosSetupStatusPacket::new(pkt.event.clone()) }}impl QosSetupBuilder {pub fn build(self) -> QosSetupPacket {let qos_setup= Arc::new(QosSetupData {connection_handle: self.connection_handle, service_type: self.service_type, token_rate: self.token_rate, peak_bandwidth: self.peak_bandwidth, latency: self.latency, delay_variation: self.delay_variation, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::QosSetup(qos_setup),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::QosSetup, child: CommandDataChild::AclCommand(acl_command),});QosSetupPacket::new(command)}
}
impl Into<CommandPacket> for QosSetupBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for QosSetupBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for QosSetupBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct QosSetupStatusData {}
#[derive(Debug, Clone)] pub struct QosSetupStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,qos_setup_status: Arc<QosSetupStatusData>,}
#[derive(Debug)] pub struct QosSetupStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl QosSetupStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for QosSetupStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl QosSetupStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let qos_setup_status = match &command_status.child {CommandStatusDataChild::QosSetupStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not QosSetupStatus"),};Self {event,command_status,qos_setup_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for QosSetupStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for QosSetupStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl QosSetupStatusBuilder {pub fn build(self) -> QosSetupStatusPacket {let qos_setup_status= Arc::new(QosSetupStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::QosSetup, child: CommandStatusDataChild::QosSetupStatus(qos_setup_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});QosSetupStatusPacket::new(event)}
}
impl Into<EventPacket> for QosSetupStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for QosSetupStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct RoleDiscoveryData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct RoleDiscoveryPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,role_discovery: Arc<RoleDiscoveryData>,}
#[derive(Debug)] pub struct RoleDiscoveryBuilder {pub connection_handle: u16, }
impl RoleDiscoveryData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "RoleDiscovery".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for RoleDiscoveryPacket { type ResponseType = RoleDiscoveryCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { RoleDiscoveryCompletePacket::new(pkt.event.clone()) }}impl Packet for RoleDiscoveryPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl RoleDiscoveryPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let role_discovery = match &connection_management_command.child {ConnectionManagementCommandDataChild::RoleDiscovery(value) => (*value).clone(),_ => panic!("inconsistent state - child was not RoleDiscovery"),};Self {command,acl_command,connection_management_command,role_discovery,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.role_discovery.as_ref().connection_handle}
}
impl Into<CommandPacket> for RoleDiscoveryPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for RoleDiscoveryPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for RoleDiscoveryPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for RoleDiscoveryBuilder { type ResponseType = RoleDiscoveryCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { RoleDiscoveryCompletePacket::new(pkt.event.clone()) }}impl RoleDiscoveryBuilder {pub fn build(self) -> RoleDiscoveryPacket {let role_discovery= Arc::new(RoleDiscoveryData {connection_handle: self.connection_handle, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::RoleDiscovery(role_discovery),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::RoleDiscovery, child: CommandDataChild::AclCommand(acl_command),});RoleDiscoveryPacket::new(command)}
}
impl Into<CommandPacket> for RoleDiscoveryBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for RoleDiscoveryBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for RoleDiscoveryBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct RoleDiscoveryCompleteData {status: ErrorCode, connection_handle: u16, current_role: Role, }
#[derive(Debug, Clone)] pub struct RoleDiscoveryCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,role_discovery_complete: Arc<RoleDiscoveryCompleteData>,}
#[derive(Debug)] pub struct RoleDiscoveryCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, pub current_role: Role, }
impl RoleDiscoveryCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "RoleDiscoveryComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "RoleDiscoveryComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "RoleDiscoveryComplete".to_string(),    field: "current_role".to_string(),    wanted: 9,    got: bytes.len()});}let current_role = u8::from_le_bytes([bytes[8]]);let current_role = Role::from_u8(current_role).unwrap();Ok(Self {status, connection_handle, current_role, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let current_role = self.current_role.to_u8().unwrap();buffer[8..9].copy_from_slice(&current_role.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl Packet for RoleDiscoveryCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl RoleDiscoveryCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let role_discovery_complete = match &command_complete.child {CommandCompleteDataChild::RoleDiscoveryComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not RoleDiscoveryComplete"),};Self {event,command_complete,role_discovery_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.role_discovery_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.role_discovery_complete.as_ref().connection_handle}
pub fn get_current_role(&self) -> Role{ self.role_discovery_complete.as_ref().current_role}
}
impl Into<EventPacket> for RoleDiscoveryCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for RoleDiscoveryCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl RoleDiscoveryCompleteBuilder {pub fn build(self) -> RoleDiscoveryCompletePacket {let role_discovery_complete= Arc::new(RoleDiscoveryCompleteData {status: self.status, connection_handle: self.connection_handle, current_role: self.current_role, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::RoleDiscovery, child: CommandCompleteDataChild::RoleDiscoveryComplete(role_discovery_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});RoleDiscoveryCompletePacket::new(event)}
}
impl Into<EventPacket> for RoleDiscoveryCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for RoleDiscoveryCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct SwitchRoleData {bd_addr: Address, role: Role, }
#[derive(Debug, Clone)] pub struct SwitchRolePacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,switch_role: Arc<SwitchRoleData>,}
#[derive(Debug)] pub struct SwitchRoleBuilder {pub bd_addr: Address, pub role: Role, }
impl SwitchRoleData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "SwitchRole".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "SwitchRole".to_string(),    field: "role".to_string(),    wanted: 10,    got: bytes.len()});}let role = u8::from_le_bytes([bytes[9]]);let role = Role::from_u8(role).unwrap();Ok(Self {bd_addr, role, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);let role = self.role.to_u8().unwrap();buffer[9..10].copy_from_slice(&role.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl CommandExpectations for SwitchRolePacket { type ResponseType = SwitchRoleStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { SwitchRoleStatusPacket::new(pkt.event.clone()) }}impl Packet for SwitchRolePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SwitchRolePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let switch_role = match &connection_management_command.child {ConnectionManagementCommandDataChild::SwitchRole(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SwitchRole"),};Self {command,acl_command,connection_management_command,switch_role,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.switch_role.as_ref().bd_addr}
pub fn get_role(&self) -> Role{ self.switch_role.as_ref().role}
}
impl Into<CommandPacket> for SwitchRolePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for SwitchRolePacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for SwitchRolePacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for SwitchRoleBuilder { type ResponseType = SwitchRoleStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { SwitchRoleStatusPacket::new(pkt.event.clone()) }}impl SwitchRoleBuilder {pub fn build(self) -> SwitchRolePacket {let switch_role= Arc::new(SwitchRoleData {bd_addr: self.bd_addr, role: self.role, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::SwitchRole(switch_role),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::SwitchRole, child: CommandDataChild::AclCommand(acl_command),});SwitchRolePacket::new(command)}
}
impl Into<CommandPacket> for SwitchRoleBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for SwitchRoleBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for SwitchRoleBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct SwitchRoleStatusData {}
#[derive(Debug, Clone)] pub struct SwitchRoleStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,switch_role_status: Arc<SwitchRoleStatusData>,}
#[derive(Debug)] pub struct SwitchRoleStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl SwitchRoleStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for SwitchRoleStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SwitchRoleStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let switch_role_status = match &command_status.child {CommandStatusDataChild::SwitchRoleStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SwitchRoleStatus"),};Self {event,command_status,switch_role_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for SwitchRoleStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for SwitchRoleStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl SwitchRoleStatusBuilder {pub fn build(self) -> SwitchRoleStatusPacket {let switch_role_status= Arc::new(SwitchRoleStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::SwitchRole, child: CommandStatusDataChild::SwitchRoleStatus(switch_role_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});SwitchRoleStatusPacket::new(event)}
}
impl Into<EventPacket> for SwitchRoleStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for SwitchRoleStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct ReadLinkPolicySettingsData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct ReadLinkPolicySettingsPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,read_link_policy_settings: Arc<ReadLinkPolicySettingsData>,}
#[derive(Debug)] pub struct ReadLinkPolicySettingsBuilder {pub connection_handle: u16, }
impl ReadLinkPolicySettingsData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ReadLinkPolicySettings".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for ReadLinkPolicySettingsPacket { type ResponseType = ReadLinkPolicySettingsCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLinkPolicySettingsCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadLinkPolicySettingsPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLinkPolicySettingsPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let read_link_policy_settings = match &connection_management_command.child {ConnectionManagementCommandDataChild::ReadLinkPolicySettings(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLinkPolicySettings"),};Self {command,acl_command,connection_management_command,read_link_policy_settings,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.read_link_policy_settings.as_ref().connection_handle}
}
impl Into<CommandPacket> for ReadLinkPolicySettingsPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for ReadLinkPolicySettingsPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for ReadLinkPolicySettingsPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for ReadLinkPolicySettingsBuilder { type ResponseType = ReadLinkPolicySettingsCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLinkPolicySettingsCompletePacket::new(pkt.event.clone()) }}impl ReadLinkPolicySettingsBuilder {pub fn build(self) -> ReadLinkPolicySettingsPacket {let read_link_policy_settings= Arc::new(ReadLinkPolicySettingsData {connection_handle: self.connection_handle, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::ReadLinkPolicySettings(read_link_policy_settings),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::ReadLinkPolicySettings, child: CommandDataChild::AclCommand(acl_command),});ReadLinkPolicySettingsPacket::new(command)}
}
impl Into<CommandPacket> for ReadLinkPolicySettingsBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for ReadLinkPolicySettingsBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for ReadLinkPolicySettingsBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadLinkPolicySettingsCompleteData {status: ErrorCode, connection_handle: u16, link_policy_settings: u16, }
#[derive(Debug, Clone)] pub struct ReadLinkPolicySettingsCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_link_policy_settings_complete: Arc<ReadLinkPolicySettingsCompleteData>,}
#[derive(Debug)] pub struct ReadLinkPolicySettingsCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, pub link_policy_settings: u16, }
impl ReadLinkPolicySettingsCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadLinkPolicySettingsComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadLinkPolicySettingsComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "ReadLinkPolicySettingsComplete".to_string(),    field: "link_policy_settings".to_string(),    wanted: 10,    got: bytes.len()});}let link_policy_settings = u16::from_le_bytes([bytes[8],bytes[9]]);Ok(Self {status, connection_handle, link_policy_settings, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let link_policy_settings = self.link_policy_settings;buffer[8..10].copy_from_slice(&link_policy_settings.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 5;ret}
}
impl Packet for ReadLinkPolicySettingsCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLinkPolicySettingsCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_link_policy_settings_complete = match &command_complete.child {CommandCompleteDataChild::ReadLinkPolicySettingsComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLinkPolicySettingsComplete"),};Self {event,command_complete,read_link_policy_settings_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_link_policy_settings_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.read_link_policy_settings_complete.as_ref().connection_handle}
pub fn get_link_policy_settings(&self) -> u16{ self.read_link_policy_settings_complete.as_ref().link_policy_settings}
}
impl Into<EventPacket> for ReadLinkPolicySettingsCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadLinkPolicySettingsCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadLinkPolicySettingsCompleteBuilder {pub fn build(self) -> ReadLinkPolicySettingsCompletePacket {let read_link_policy_settings_complete= Arc::new(ReadLinkPolicySettingsCompleteData {status: self.status, connection_handle: self.connection_handle, link_policy_settings: self.link_policy_settings, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadLinkPolicySettings, child: CommandCompleteDataChild::ReadLinkPolicySettingsComplete(read_link_policy_settings_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadLinkPolicySettingsCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadLinkPolicySettingsCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadLinkPolicySettingsCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WriteLinkPolicySettingsData {connection_handle: u16, link_policy_settings: u16, }
#[derive(Debug, Clone)] pub struct WriteLinkPolicySettingsPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,write_link_policy_settings: Arc<WriteLinkPolicySettingsData>,}
#[derive(Debug)] pub struct WriteLinkPolicySettingsBuilder {pub connection_handle: u16, pub link_policy_settings: u16, }
impl WriteLinkPolicySettingsData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "WriteLinkPolicySettings".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "WriteLinkPolicySettings".to_string(),    field: "link_policy_settings".to_string(),    wanted: 7,    got: bytes.len()});}let link_policy_settings = u16::from_le_bytes([bytes[5],bytes[6]]);Ok(Self {connection_handle, link_policy_settings, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let link_policy_settings = self.link_policy_settings;buffer[5..7].copy_from_slice(&link_policy_settings.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl CommandExpectations for WriteLinkPolicySettingsPacket { type ResponseType = WriteLinkPolicySettingsCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteLinkPolicySettingsCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteLinkPolicySettingsPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteLinkPolicySettingsPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let write_link_policy_settings = match &connection_management_command.child {ConnectionManagementCommandDataChild::WriteLinkPolicySettings(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteLinkPolicySettings"),};Self {command,acl_command,connection_management_command,write_link_policy_settings,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.write_link_policy_settings.as_ref().connection_handle}
pub fn get_link_policy_settings(&self) -> u16{ self.write_link_policy_settings.as_ref().link_policy_settings}
}
impl Into<CommandPacket> for WriteLinkPolicySettingsPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for WriteLinkPolicySettingsPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for WriteLinkPolicySettingsPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for WriteLinkPolicySettingsBuilder { type ResponseType = WriteLinkPolicySettingsCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteLinkPolicySettingsCompletePacket::new(pkt.event.clone()) }}impl WriteLinkPolicySettingsBuilder {pub fn build(self) -> WriteLinkPolicySettingsPacket {let write_link_policy_settings= Arc::new(WriteLinkPolicySettingsData {connection_handle: self.connection_handle, link_policy_settings: self.link_policy_settings, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::WriteLinkPolicySettings(write_link_policy_settings),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::WriteLinkPolicySettings, child: CommandDataChild::AclCommand(acl_command),});WriteLinkPolicySettingsPacket::new(command)}
}
impl Into<CommandPacket> for WriteLinkPolicySettingsBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for WriteLinkPolicySettingsBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for WriteLinkPolicySettingsBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct WriteLinkPolicySettingsCompleteData {status: ErrorCode, connection_handle: u16, }
#[derive(Debug, Clone)] pub struct WriteLinkPolicySettingsCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_link_policy_settings_complete: Arc<WriteLinkPolicySettingsCompleteData>,}
#[derive(Debug)] pub struct WriteLinkPolicySettingsCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, }
impl WriteLinkPolicySettingsCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteLinkPolicySettingsComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "WriteLinkPolicySettingsComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;Ok(Self {status, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for WriteLinkPolicySettingsCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteLinkPolicySettingsCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_link_policy_settings_complete = match &command_complete.child {CommandCompleteDataChild::WriteLinkPolicySettingsComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteLinkPolicySettingsComplete"),};Self {event,command_complete,write_link_policy_settings_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_link_policy_settings_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.write_link_policy_settings_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for WriteLinkPolicySettingsCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteLinkPolicySettingsCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteLinkPolicySettingsCompleteBuilder {pub fn build(self) -> WriteLinkPolicySettingsCompletePacket {let write_link_policy_settings_complete= Arc::new(WriteLinkPolicySettingsCompleteData {status: self.status, connection_handle: self.connection_handle, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteLinkPolicySettings, child: CommandCompleteDataChild::WriteLinkPolicySettingsComplete(write_link_policy_settings_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteLinkPolicySettingsCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteLinkPolicySettingsCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteLinkPolicySettingsCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadDefaultLinkPolicySettingsData {}
#[derive(Debug, Clone)] pub struct ReadDefaultLinkPolicySettingsPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,read_default_link_policy_settings: Arc<ReadDefaultLinkPolicySettingsData>,}
#[derive(Debug)] pub struct ReadDefaultLinkPolicySettingsBuilder {}
impl ReadDefaultLinkPolicySettingsData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadDefaultLinkPolicySettingsPacket { type ResponseType = ReadDefaultLinkPolicySettingsCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadDefaultLinkPolicySettingsCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadDefaultLinkPolicySettingsPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadDefaultLinkPolicySettingsPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let read_default_link_policy_settings = match &connection_management_command.child {ConnectionManagementCommandDataChild::ReadDefaultLinkPolicySettings(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadDefaultLinkPolicySettings"),};Self {command,acl_command,connection_management_command,read_default_link_policy_settings,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadDefaultLinkPolicySettingsPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for ReadDefaultLinkPolicySettingsPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for ReadDefaultLinkPolicySettingsPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for ReadDefaultLinkPolicySettingsBuilder { type ResponseType = ReadDefaultLinkPolicySettingsCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadDefaultLinkPolicySettingsCompletePacket::new(pkt.event.clone()) }}impl ReadDefaultLinkPolicySettingsBuilder {pub fn build(self) -> ReadDefaultLinkPolicySettingsPacket {let read_default_link_policy_settings= Arc::new(ReadDefaultLinkPolicySettingsData {});let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::ReadDefaultLinkPolicySettings(read_default_link_policy_settings),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::ReadDefaultLinkPolicySettings, child: CommandDataChild::AclCommand(acl_command),});ReadDefaultLinkPolicySettingsPacket::new(command)}
}
impl Into<CommandPacket> for ReadDefaultLinkPolicySettingsBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for ReadDefaultLinkPolicySettingsBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for ReadDefaultLinkPolicySettingsBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadDefaultLinkPolicySettingsCompleteData {status: ErrorCode, default_link_policy_settings: u16, }
#[derive(Debug, Clone)] pub struct ReadDefaultLinkPolicySettingsCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_default_link_policy_settings_complete: Arc<ReadDefaultLinkPolicySettingsCompleteData>,}
#[derive(Debug)] pub struct ReadDefaultLinkPolicySettingsCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub default_link_policy_settings: u16, }
impl ReadDefaultLinkPolicySettingsCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadDefaultLinkPolicySettingsComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadDefaultLinkPolicySettingsComplete".to_string(),    field: "default_link_policy_settings".to_string(),    wanted: 8,    got: bytes.len()});}let default_link_policy_settings = u16::from_le_bytes([bytes[6],bytes[7]]);Ok(Self {status, default_link_policy_settings, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let default_link_policy_settings = self.default_link_policy_settings;buffer[6..8].copy_from_slice(&default_link_policy_settings.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for ReadDefaultLinkPolicySettingsCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadDefaultLinkPolicySettingsCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_default_link_policy_settings_complete = match &command_complete.child {CommandCompleteDataChild::ReadDefaultLinkPolicySettingsComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadDefaultLinkPolicySettingsComplete"),};Self {event,command_complete,read_default_link_policy_settings_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_default_link_policy_settings_complete.as_ref().status}
pub fn get_default_link_policy_settings(&self) -> u16{ self.read_default_link_policy_settings_complete.as_ref().default_link_policy_settings}
}
impl Into<EventPacket> for ReadDefaultLinkPolicySettingsCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadDefaultLinkPolicySettingsCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadDefaultLinkPolicySettingsCompleteBuilder {pub fn build(self) -> ReadDefaultLinkPolicySettingsCompletePacket {let read_default_link_policy_settings_complete= Arc::new(ReadDefaultLinkPolicySettingsCompleteData {status: self.status, default_link_policy_settings: self.default_link_policy_settings, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadDefaultLinkPolicySettings, child: CommandCompleteDataChild::ReadDefaultLinkPolicySettingsComplete(read_default_link_policy_settings_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadDefaultLinkPolicySettingsCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadDefaultLinkPolicySettingsCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadDefaultLinkPolicySettingsCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WriteDefaultLinkPolicySettingsData {default_link_policy_settings: u16, }
#[derive(Debug, Clone)] pub struct WriteDefaultLinkPolicySettingsPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,write_default_link_policy_settings: Arc<WriteDefaultLinkPolicySettingsData>,}
#[derive(Debug)] pub struct WriteDefaultLinkPolicySettingsBuilder {pub default_link_policy_settings: u16, }
impl WriteDefaultLinkPolicySettingsData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "WriteDefaultLinkPolicySettings".to_string(),    field: "default_link_policy_settings".to_string(),    wanted: 5,    got: bytes.len()});}let default_link_policy_settings = u16::from_le_bytes([bytes[3],bytes[4]]);Ok(Self {default_link_policy_settings, })
}
fn write_to(&self, buffer: &mut BytesMut) {let default_link_policy_settings = self.default_link_policy_settings;buffer[3..5].copy_from_slice(&default_link_policy_settings.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for WriteDefaultLinkPolicySettingsPacket { type ResponseType = WriteDefaultLinkPolicySettingsCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteDefaultLinkPolicySettingsCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteDefaultLinkPolicySettingsPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteDefaultLinkPolicySettingsPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let write_default_link_policy_settings = match &connection_management_command.child {ConnectionManagementCommandDataChild::WriteDefaultLinkPolicySettings(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteDefaultLinkPolicySettings"),};Self {command,acl_command,connection_management_command,write_default_link_policy_settings,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_default_link_policy_settings(&self) -> u16{ self.write_default_link_policy_settings.as_ref().default_link_policy_settings}
}
impl Into<CommandPacket> for WriteDefaultLinkPolicySettingsPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for WriteDefaultLinkPolicySettingsPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for WriteDefaultLinkPolicySettingsPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for WriteDefaultLinkPolicySettingsBuilder { type ResponseType = WriteDefaultLinkPolicySettingsCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteDefaultLinkPolicySettingsCompletePacket::new(pkt.event.clone()) }}impl WriteDefaultLinkPolicySettingsBuilder {pub fn build(self) -> WriteDefaultLinkPolicySettingsPacket {let write_default_link_policy_settings= Arc::new(WriteDefaultLinkPolicySettingsData {default_link_policy_settings: self.default_link_policy_settings, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::WriteDefaultLinkPolicySettings(write_default_link_policy_settings),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::WriteDefaultLinkPolicySettings, child: CommandDataChild::AclCommand(acl_command),});WriteDefaultLinkPolicySettingsPacket::new(command)}
}
impl Into<CommandPacket> for WriteDefaultLinkPolicySettingsBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for WriteDefaultLinkPolicySettingsBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for WriteDefaultLinkPolicySettingsBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct WriteDefaultLinkPolicySettingsCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WriteDefaultLinkPolicySettingsCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_default_link_policy_settings_complete: Arc<WriteDefaultLinkPolicySettingsCompleteData>,}
#[derive(Debug)] pub struct WriteDefaultLinkPolicySettingsCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WriteDefaultLinkPolicySettingsCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteDefaultLinkPolicySettingsComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WriteDefaultLinkPolicySettingsCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteDefaultLinkPolicySettingsCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_default_link_policy_settings_complete = match &command_complete.child {CommandCompleteDataChild::WriteDefaultLinkPolicySettingsComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteDefaultLinkPolicySettingsComplete"),};Self {event,command_complete,write_default_link_policy_settings_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_default_link_policy_settings_complete.as_ref().status}
}
impl Into<EventPacket> for WriteDefaultLinkPolicySettingsCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteDefaultLinkPolicySettingsCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteDefaultLinkPolicySettingsCompleteBuilder {pub fn build(self) -> WriteDefaultLinkPolicySettingsCompletePacket {let write_default_link_policy_settings_complete= Arc::new(WriteDefaultLinkPolicySettingsCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteDefaultLinkPolicySettings, child: CommandCompleteDataChild::WriteDefaultLinkPolicySettingsComplete(write_default_link_policy_settings_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteDefaultLinkPolicySettingsCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteDefaultLinkPolicySettingsCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteDefaultLinkPolicySettingsCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct FlowSpecificationData {connection_handle: u16, flow_direction: FlowDirection, service_type: ServiceType, token_rate: u32, token_bucket_size: u32, peak_bandwidth: u32, access_latency: u32, }
#[derive(Debug, Clone)] pub struct FlowSpecificationPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,flow_specification: Arc<FlowSpecificationData>,}
#[derive(Debug)] pub struct FlowSpecificationBuilder {pub connection_handle: u16, pub flow_direction: FlowDirection, pub service_type: ServiceType, pub token_rate: u32, pub token_bucket_size: u32, pub peak_bandwidth: u32, pub access_latency: u32, }
impl FlowSpecificationData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "FlowSpecification".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "FlowSpecification".to_string(),    field: "flow_direction".to_string(),    wanted: 7,    got: bytes.len()});}let flow_direction = u8::from_le_bytes([bytes[6]]);let flow_direction = FlowDirection::from_u8(flow_direction).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "FlowSpecification".to_string(),    field: "service_type".to_string(),    wanted: 8,    got: bytes.len()});}let service_type = u8::from_le_bytes([bytes[7]]);let service_type = ServiceType::from_u8(service_type).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "FlowSpecification".to_string(),    field: "token_rate".to_string(),    wanted: 12,    got: bytes.len()});}let token_rate = u32::from_le_bytes([bytes[8],bytes[9],bytes[10],bytes[11]]);if bytes.len() < 16 { return Err(Error::InvalidLengthError{    obj: "FlowSpecification".to_string(),    field: "token_bucket_size".to_string(),    wanted: 16,    got: bytes.len()});}let token_bucket_size = u32::from_le_bytes([bytes[12],bytes[13],bytes[14],bytes[15]]);if bytes.len() < 20 { return Err(Error::InvalidLengthError{    obj: "FlowSpecification".to_string(),    field: "peak_bandwidth".to_string(),    wanted: 20,    got: bytes.len()});}let peak_bandwidth = u32::from_le_bytes([bytes[16],bytes[17],bytes[18],bytes[19]]);if bytes.len() < 24 { return Err(Error::InvalidLengthError{    obj: "FlowSpecification".to_string(),    field: "access_latency".to_string(),    wanted: 24,    got: bytes.len()});}let access_latency = u32::from_le_bytes([bytes[20],bytes[21],bytes[22],bytes[23]]);Ok(Self {connection_handle, flow_direction, service_type, token_rate, token_bucket_size, peak_bandwidth, access_latency, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let flow_direction = self.flow_direction.to_u8().unwrap();buffer[6..7].copy_from_slice(&flow_direction.to_le_bytes()[0..1]);let service_type = self.service_type.to_u8().unwrap();buffer[7..8].copy_from_slice(&service_type.to_le_bytes()[0..1]);let token_rate = self.token_rate;buffer[8..12].copy_from_slice(&token_rate.to_le_bytes()[0..4]);let token_bucket_size = self.token_bucket_size;buffer[12..16].copy_from_slice(&token_bucket_size.to_le_bytes()[0..4]);let peak_bandwidth = self.peak_bandwidth;buffer[16..20].copy_from_slice(&peak_bandwidth.to_le_bytes()[0..4]);let access_latency = self.access_latency;buffer[20..24].copy_from_slice(&access_latency.to_le_bytes()[0..4]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 21;ret}
}
impl CommandExpectations for FlowSpecificationPacket { type ResponseType = FlowSpecificationStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { FlowSpecificationStatusPacket::new(pkt.event.clone()) }}impl Packet for FlowSpecificationPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl FlowSpecificationPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let flow_specification = match &connection_management_command.child {ConnectionManagementCommandDataChild::FlowSpecification(value) => (*value).clone(),_ => panic!("inconsistent state - child was not FlowSpecification"),};Self {command,acl_command,connection_management_command,flow_specification,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.flow_specification.as_ref().connection_handle}
pub fn get_flow_direction(&self) -> FlowDirection{ self.flow_specification.as_ref().flow_direction}
pub fn get_service_type(&self) -> ServiceType{ self.flow_specification.as_ref().service_type}
pub fn get_token_rate(&self) -> u32{ self.flow_specification.as_ref().token_rate}
pub fn get_token_bucket_size(&self) -> u32{ self.flow_specification.as_ref().token_bucket_size}
pub fn get_peak_bandwidth(&self) -> u32{ self.flow_specification.as_ref().peak_bandwidth}
pub fn get_access_latency(&self) -> u32{ self.flow_specification.as_ref().access_latency}
}
impl Into<CommandPacket> for FlowSpecificationPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for FlowSpecificationPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for FlowSpecificationPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for FlowSpecificationBuilder { type ResponseType = FlowSpecificationStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { FlowSpecificationStatusPacket::new(pkt.event.clone()) }}impl FlowSpecificationBuilder {pub fn build(self) -> FlowSpecificationPacket {let flow_specification= Arc::new(FlowSpecificationData {connection_handle: self.connection_handle, flow_direction: self.flow_direction, service_type: self.service_type, token_rate: self.token_rate, token_bucket_size: self.token_bucket_size, peak_bandwidth: self.peak_bandwidth, access_latency: self.access_latency, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::FlowSpecification(flow_specification),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::FlowSpecification, child: CommandDataChild::AclCommand(acl_command),});FlowSpecificationPacket::new(command)}
}
impl Into<CommandPacket> for FlowSpecificationBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for FlowSpecificationBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for FlowSpecificationBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct FlowSpecificationStatusData {}
#[derive(Debug, Clone)] pub struct FlowSpecificationStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,flow_specification_status: Arc<FlowSpecificationStatusData>,}
#[derive(Debug)] pub struct FlowSpecificationStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl FlowSpecificationStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for FlowSpecificationStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl FlowSpecificationStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let flow_specification_status = match &command_status.child {CommandStatusDataChild::FlowSpecificationStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not FlowSpecificationStatus"),};Self {event,command_status,flow_specification_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for FlowSpecificationStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for FlowSpecificationStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl FlowSpecificationStatusBuilder {pub fn build(self) -> FlowSpecificationStatusPacket {let flow_specification_status= Arc::new(FlowSpecificationStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::FlowSpecification, child: CommandStatusDataChild::FlowSpecificationStatus(flow_specification_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});FlowSpecificationStatusPacket::new(event)}
}
impl Into<EventPacket> for FlowSpecificationStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for FlowSpecificationStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct SniffSubratingData {connection_handle: u16, maximum_latency: u16, minimum_remote_timeout: u16, minimum_local_timeout: u16, }
#[derive(Debug, Clone)] pub struct SniffSubratingPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,sniff_subrating: Arc<SniffSubratingData>,}
#[derive(Debug)] pub struct SniffSubratingBuilder {pub connection_handle: u16, pub maximum_latency: u16, pub minimum_remote_timeout: u16, pub minimum_local_timeout: u16, }
impl SniffSubratingData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "SniffSubrating".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "SniffSubrating".to_string(),    field: "maximum_latency".to_string(),    wanted: 7,    got: bytes.len()});}let maximum_latency = u16::from_le_bytes([bytes[5],bytes[6]]);if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "SniffSubrating".to_string(),    field: "minimum_remote_timeout".to_string(),    wanted: 9,    got: bytes.len()});}let minimum_remote_timeout = u16::from_le_bytes([bytes[7],bytes[8]]);if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "SniffSubrating".to_string(),    field: "minimum_local_timeout".to_string(),    wanted: 11,    got: bytes.len()});}let minimum_local_timeout = u16::from_le_bytes([bytes[9],bytes[10]]);Ok(Self {connection_handle, maximum_latency, minimum_remote_timeout, minimum_local_timeout, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let maximum_latency = self.maximum_latency;buffer[5..7].copy_from_slice(&maximum_latency.to_le_bytes()[0..2]);let minimum_remote_timeout = self.minimum_remote_timeout;buffer[7..9].copy_from_slice(&minimum_remote_timeout.to_le_bytes()[0..2]);let minimum_local_timeout = self.minimum_local_timeout;buffer[9..11].copy_from_slice(&minimum_local_timeout.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 8;ret}
}
impl CommandExpectations for SniffSubratingPacket { type ResponseType = SniffSubratingCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { SniffSubratingCompletePacket::new(pkt.event.clone()) }}impl Packet for SniffSubratingPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SniffSubratingPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let sniff_subrating = match &connection_management_command.child {ConnectionManagementCommandDataChild::SniffSubrating(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SniffSubrating"),};Self {command,acl_command,connection_management_command,sniff_subrating,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.sniff_subrating.as_ref().connection_handle}
pub fn get_maximum_latency(&self) -> u16{ self.sniff_subrating.as_ref().maximum_latency}
pub fn get_minimum_remote_timeout(&self) -> u16{ self.sniff_subrating.as_ref().minimum_remote_timeout}
pub fn get_minimum_local_timeout(&self) -> u16{ self.sniff_subrating.as_ref().minimum_local_timeout}
}
impl Into<CommandPacket> for SniffSubratingPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for SniffSubratingPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for SniffSubratingPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for SniffSubratingBuilder { type ResponseType = SniffSubratingCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { SniffSubratingCompletePacket::new(pkt.event.clone()) }}impl SniffSubratingBuilder {pub fn build(self) -> SniffSubratingPacket {let sniff_subrating= Arc::new(SniffSubratingData {connection_handle: self.connection_handle, maximum_latency: self.maximum_latency, minimum_remote_timeout: self.minimum_remote_timeout, minimum_local_timeout: self.minimum_local_timeout, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::SniffSubrating(sniff_subrating),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::SniffSubrating, child: CommandDataChild::AclCommand(acl_command),});SniffSubratingPacket::new(command)}
}
impl Into<CommandPacket> for SniffSubratingBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for SniffSubratingBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for SniffSubratingBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct SniffSubratingCompleteData {status: ErrorCode, connection_handle: u16, }
#[derive(Debug, Clone)] pub struct SniffSubratingCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,sniff_subrating_complete: Arc<SniffSubratingCompleteData>,}
#[derive(Debug)] pub struct SniffSubratingCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, }
impl SniffSubratingCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "SniffSubratingComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "SniffSubratingComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;Ok(Self {status, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for SniffSubratingCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SniffSubratingCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let sniff_subrating_complete = match &command_complete.child {CommandCompleteDataChild::SniffSubratingComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SniffSubratingComplete"),};Self {event,command_complete,sniff_subrating_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.sniff_subrating_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.sniff_subrating_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for SniffSubratingCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for SniffSubratingCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl SniffSubratingCompleteBuilder {pub fn build(self) -> SniffSubratingCompletePacket {let sniff_subrating_complete= Arc::new(SniffSubratingCompleteData {status: self.status, connection_handle: self.connection_handle, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::SniffSubrating, child: CommandCompleteDataChild::SniffSubratingComplete(sniff_subrating_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});SniffSubratingCompletePacket::new(event)}
}
impl Into<EventPacket> for SniffSubratingCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for SniffSubratingCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct SetEventMaskData {event_mask: u64, }
#[derive(Debug, Clone)] pub struct SetEventMaskPacket {command: Arc<CommandData>,set_event_mask: Arc<SetEventMaskData>,}
#[derive(Debug)] pub struct SetEventMaskBuilder {pub event_mask: u64, }
impl SetEventMaskData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "SetEventMask".to_string(),    field: "event_mask".to_string(),    wanted: 11,    got: bytes.len()});}let event_mask = u64::from_le_bytes([bytes[3],bytes[4],bytes[5],bytes[6],bytes[7],bytes[8],bytes[9],bytes[10]]);Ok(Self {event_mask, })
}
fn write_to(&self, buffer: &mut BytesMut) {let event_mask = self.event_mask;buffer[3..11].copy_from_slice(&event_mask.to_le_bytes()[0..8]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 8;ret}
}
impl CommandExpectations for SetEventMaskPacket { type ResponseType = SetEventMaskCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { SetEventMaskCompletePacket::new(pkt.event.clone()) }}impl Packet for SetEventMaskPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SetEventMaskPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let set_event_mask = match &command.child {CommandDataChild::SetEventMask(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventMask"),};Self {command,set_event_mask,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_event_mask(&self) -> u64{ self.set_event_mask.as_ref().event_mask}
}
impl Into<CommandPacket> for SetEventMaskPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for SetEventMaskBuilder { type ResponseType = SetEventMaskCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { SetEventMaskCompletePacket::new(pkt.event.clone()) }}impl SetEventMaskBuilder {pub fn build(self) -> SetEventMaskPacket {let set_event_mask= Arc::new(SetEventMaskData {event_mask: self.event_mask, });let command= Arc::new(CommandData {op_code: OpCode::SetEventMask, child: CommandDataChild::SetEventMask(set_event_mask),});SetEventMaskPacket::new(command)}
}
impl Into<CommandPacket> for SetEventMaskBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct SetEventMaskCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct SetEventMaskCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,set_event_mask_complete: Arc<SetEventMaskCompleteData>,}
#[derive(Debug)] pub struct SetEventMaskCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl SetEventMaskCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "SetEventMaskComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for SetEventMaskCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SetEventMaskCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let set_event_mask_complete = match &command_complete.child {CommandCompleteDataChild::SetEventMaskComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventMaskComplete"),};Self {event,command_complete,set_event_mask_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.set_event_mask_complete.as_ref().status}
}
impl Into<EventPacket> for SetEventMaskCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for SetEventMaskCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl SetEventMaskCompleteBuilder {pub fn build(self) -> SetEventMaskCompletePacket {let set_event_mask_complete= Arc::new(SetEventMaskCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::SetEventMask, child: CommandCompleteDataChild::SetEventMaskComplete(set_event_mask_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});SetEventMaskCompletePacket::new(event)}
}
impl Into<EventPacket> for SetEventMaskCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for SetEventMaskCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ResetData {}
#[derive(Debug, Clone)] pub struct ResetPacket {command: Arc<CommandData>,reset: Arc<ResetData>,}
#[derive(Debug)] pub struct ResetBuilder {}
impl ResetData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ResetPacket { type ResponseType = ResetCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ResetCompletePacket::new(pkt.event.clone()) }}impl Packet for ResetPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ResetPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let reset = match &command.child {CommandDataChild::Reset(value) => (*value).clone(),_ => panic!("inconsistent state - child was not Reset"),};Self {command,reset,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ResetPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for ResetBuilder { type ResponseType = ResetCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ResetCompletePacket::new(pkt.event.clone()) }}impl ResetBuilder {pub fn build(self) -> ResetPacket {let reset= Arc::new(ResetData {});let command= Arc::new(CommandData {op_code: OpCode::Reset, child: CommandDataChild::Reset(reset),});ResetPacket::new(command)}
}
impl Into<CommandPacket> for ResetBuilder { fn into(self) -> CommandPacket { self.build().into() }}
macro_rules! reset_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::Reset(packet) => {let rebuilder = ResetBuilder {};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse reset{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}reset_builder_tests! { reset_builder_test_00: b"\x03\x0c\x00",}


#[derive(Debug)] struct ResetCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct ResetCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,reset_complete: Arc<ResetCompleteData>,}
#[derive(Debug)] pub struct ResetCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl ResetCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ResetComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for ResetCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ResetCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let reset_complete = match &command_complete.child {CommandCompleteDataChild::ResetComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ResetComplete"),};Self {event,command_complete,reset_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.reset_complete.as_ref().status}
}
impl Into<EventPacket> for ResetCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ResetCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ResetCompleteBuilder {pub fn build(self) -> ResetCompletePacket {let reset_complete= Arc::new(ResetCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::Reset, child: CommandCompleteDataChild::ResetComplete(reset_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ResetCompletePacket::new(event)}
}
impl Into<EventPacket> for ResetCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ResetCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! reset_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::ResetComplete(packet) => {let rebuilder = ResetCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse reset_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}reset_complete_builder_tests! { reset_complete_builder_test_00: b"\x0e\x04\x01\x03\x0c\x00",reset_complete_builder_test_01: b"\x0e\x04\x01\x03\x0c\x01",}


#[derive(Debug)] enum SetEventFilterDataChild {SetEventFilterClearAll(Arc<SetEventFilterClearAllData>),SetEventFilterInquiryResult(Arc<SetEventFilterInquiryResultData>),SetEventFilterConnectionSetup(Arc<SetEventFilterConnectionSetupData>),None,}
impl SetEventFilterDataChild {fn get_total_size(&self) -> usize {match self {SetEventFilterDataChild::SetEventFilterClearAll(value) => value.get_total_size(),SetEventFilterDataChild::SetEventFilterInquiryResult(value) => value.get_total_size(),SetEventFilterDataChild::SetEventFilterConnectionSetup(value) => value.get_total_size(),SetEventFilterDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum SetEventFilterChild {SetEventFilterClearAll(SetEventFilterClearAllPacket),SetEventFilterInquiryResult(SetEventFilterInquiryResultPacket),SetEventFilterConnectionSetup(SetEventFilterConnectionSetupPacket),None,}
#[derive(Debug)] struct SetEventFilterData {filter_type: FilterType, child: SetEventFilterDataChild,}
#[derive(Debug, Clone)] pub struct SetEventFilterPacket {command: Arc<CommandData>,set_event_filter: Arc<SetEventFilterData>,}
#[derive(Debug)] pub struct SetEventFilterBuilder {pub filter_type: FilterType, }
impl SetEventFilterData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "SetEventFilter".to_string(),    field: "filter_type".to_string(),    wanted: 4,    got: bytes.len()});}let filter_type = u8::from_le_bytes([bytes[3]]);let filter_type = FilterType::from_u8(filter_type).unwrap();let child = match filter_type {FilterType::ConnectionSetup if SetEventFilterConnectionSetupData::conforms(&bytes[..]) => {SetEventFilterDataChild::SetEventFilterConnectionSetup(Arc::new(SetEventFilterConnectionSetupData::parse(&bytes[..])?))}
FilterType::ClearAllFilters if SetEventFilterClearAllData::conforms(&bytes[..]) => {SetEventFilterDataChild::SetEventFilterClearAll(Arc::new(SetEventFilterClearAllData::parse(&bytes[..])?))}
FilterType::InquiryResult if SetEventFilterInquiryResultData::conforms(&bytes[..]) => {SetEventFilterDataChild::SetEventFilterInquiryResult(Arc::new(SetEventFilterInquiryResultData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "filter_type".to_string(), value: v as u64}),};
Ok(Self {filter_type, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let filter_type = self.filter_type.to_u8().unwrap();buffer[3..4].copy_from_slice(&filter_type.to_le_bytes()[0..1]);match &self.child {SetEventFilterDataChild::SetEventFilterClearAll(value) => value.write_to(buffer),SetEventFilterDataChild::SetEventFilterInquiryResult(value) => value.write_to(buffer),SetEventFilterDataChild::SetEventFilterConnectionSetup(value) => value.write_to(buffer),SetEventFilterDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for SetEventFilterPacket { type ResponseType = SetEventFilterCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { SetEventFilterCompletePacket::new(pkt.event.clone()) }}impl Packet for SetEventFilterPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SetEventFilterPacket { pub fn specialize(&self) -> SetEventFilterChild { match &self.set_event_filter.child {SetEventFilterDataChild::SetEventFilterClearAll(_) => SetEventFilterChild::SetEventFilterClearAll(SetEventFilterClearAllPacket::new(self.command.clone())),SetEventFilterDataChild::SetEventFilterInquiryResult(_) => SetEventFilterChild::SetEventFilterInquiryResult(SetEventFilterInquiryResultPacket::new(self.command.clone())),SetEventFilterDataChild::SetEventFilterConnectionSetup(_) => SetEventFilterChild::SetEventFilterConnectionSetup(SetEventFilterConnectionSetupPacket::new(self.command.clone())),SetEventFilterDataChild::None => SetEventFilterChild::None,}} fn new(root: Arc<CommandData>) -> Self {let command = root;let set_event_filter = match &command.child {CommandDataChild::SetEventFilter(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilter"),};Self {command,set_event_filter,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_filter_type(&self) -> FilterType{ self.set_event_filter.as_ref().filter_type}
}
impl Into<CommandPacket> for SetEventFilterPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for SetEventFilterBuilder { type ResponseType = SetEventFilterCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { SetEventFilterCompletePacket::new(pkt.event.clone()) }}impl SetEventFilterBuilder {pub fn build(self) -> SetEventFilterPacket {let set_event_filter= Arc::new(SetEventFilterData {filter_type: self.filter_type, child: SetEventFilterDataChild::None,});let command= Arc::new(CommandData {op_code: OpCode::SetEventFilter, child: CommandDataChild::SetEventFilter(set_event_filter),});SetEventFilterPacket::new(command)}
}
impl Into<CommandPacket> for SetEventFilterBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct SetEventFilterCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct SetEventFilterCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,set_event_filter_complete: Arc<SetEventFilterCompleteData>,}
#[derive(Debug)] pub struct SetEventFilterCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl SetEventFilterCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "SetEventFilterComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for SetEventFilterCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SetEventFilterCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let set_event_filter_complete = match &command_complete.child {CommandCompleteDataChild::SetEventFilterComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilterComplete"),};Self {event,command_complete,set_event_filter_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.set_event_filter_complete.as_ref().status}
}
impl Into<EventPacket> for SetEventFilterCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for SetEventFilterCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl SetEventFilterCompleteBuilder {pub fn build(self) -> SetEventFilterCompletePacket {let set_event_filter_complete= Arc::new(SetEventFilterCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::SetEventFilter, child: CommandCompleteDataChild::SetEventFilterComplete(set_event_filter_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});SetEventFilterCompletePacket::new(event)}
}
impl Into<EventPacket> for SetEventFilterCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for SetEventFilterCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct SetEventFilterClearAllData {}
#[derive(Debug, Clone)] pub struct SetEventFilterClearAllPacket {command: Arc<CommandData>,set_event_filter: Arc<SetEventFilterData>,set_event_filter_clear_all: Arc<SetEventFilterClearAllData>,}
#[derive(Debug)] pub struct SetEventFilterClearAllBuilder {}
impl SetEventFilterClearAllData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for SetEventFilterClearAllPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SetEventFilterClearAllPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let set_event_filter = match &command.child {CommandDataChild::SetEventFilter(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilter"),};let set_event_filter_clear_all = match &set_event_filter.child {SetEventFilterDataChild::SetEventFilterClearAll(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilterClearAll"),};Self {command,set_event_filter,set_event_filter_clear_all,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_filter_type(&self) -> FilterType{ self.set_event_filter.as_ref().filter_type}
}
impl Into<CommandPacket> for SetEventFilterClearAllPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SetEventFilterPacket> for SetEventFilterClearAllPacket { fn into(self) -> SetEventFilterPacket {SetEventFilterPacket::new(self.command) }}
impl SetEventFilterClearAllBuilder {pub fn build(self) -> SetEventFilterClearAllPacket {let set_event_filter_clear_all= Arc::new(SetEventFilterClearAllData {});let set_event_filter= Arc::new(SetEventFilterData {filter_type: FilterType::ClearAllFilters, child: SetEventFilterDataChild::SetEventFilterClearAll(set_event_filter_clear_all),});let command= Arc::new(CommandData {op_code: OpCode::SetEventFilter, child: CommandDataChild::SetEventFilter(set_event_filter),});SetEventFilterClearAllPacket::new(command)}
}
impl Into<CommandPacket> for SetEventFilterClearAllBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SetEventFilterPacket> for SetEventFilterClearAllBuilder { fn into(self) -> SetEventFilterPacket { self.build().into() }}


#[derive(Debug)] enum SetEventFilterInquiryResultDataChild {SetEventFilterInquiryResultAllDevices(Arc<SetEventFilterInquiryResultAllDevicesData>),SetEventFilterInquiryResultClassOfDevice(Arc<SetEventFilterInquiryResultClassOfDeviceData>),SetEventFilterInquiryResultAddress(Arc<SetEventFilterInquiryResultAddressData>),None,}
impl SetEventFilterInquiryResultDataChild {fn get_total_size(&self) -> usize {match self {SetEventFilterInquiryResultDataChild::SetEventFilterInquiryResultAllDevices(value) => value.get_total_size(),SetEventFilterInquiryResultDataChild::SetEventFilterInquiryResultClassOfDevice(value) => value.get_total_size(),SetEventFilterInquiryResultDataChild::SetEventFilterInquiryResultAddress(value) => value.get_total_size(),SetEventFilterInquiryResultDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum SetEventFilterInquiryResultChild {SetEventFilterInquiryResultAllDevices(SetEventFilterInquiryResultAllDevicesPacket),SetEventFilterInquiryResultClassOfDevice(SetEventFilterInquiryResultClassOfDevicePacket),SetEventFilterInquiryResultAddress(SetEventFilterInquiryResultAddressPacket),None,}
#[derive(Debug)] struct SetEventFilterInquiryResultData {filter_condition_type: FilterConditionType, child: SetEventFilterInquiryResultDataChild,}
#[derive(Debug, Clone)] pub struct SetEventFilterInquiryResultPacket {command: Arc<CommandData>,set_event_filter: Arc<SetEventFilterData>,set_event_filter_inquiry_result: Arc<SetEventFilterInquiryResultData>,}
#[derive(Debug)] pub struct SetEventFilterInquiryResultBuilder {pub filter_condition_type: FilterConditionType, }
impl SetEventFilterInquiryResultData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "SetEventFilterInquiryResult".to_string(),    field: "filter_condition_type".to_string(),    wanted: 5,    got: bytes.len()});}let filter_condition_type = u8::from_le_bytes([bytes[4]]);let filter_condition_type = FilterConditionType::from_u8(filter_condition_type).unwrap();let child = match filter_condition_type {FilterConditionType::Address if SetEventFilterInquiryResultAddressData::conforms(&bytes[..]) => {SetEventFilterInquiryResultDataChild::SetEventFilterInquiryResultAddress(Arc::new(SetEventFilterInquiryResultAddressData::parse(&bytes[..])?))}
FilterConditionType::AllDevices if SetEventFilterInquiryResultAllDevicesData::conforms(&bytes[..]) => {SetEventFilterInquiryResultDataChild::SetEventFilterInquiryResultAllDevices(Arc::new(SetEventFilterInquiryResultAllDevicesData::parse(&bytes[..])?))}
FilterConditionType::ClassOfDevice if SetEventFilterInquiryResultClassOfDeviceData::conforms(&bytes[..]) => {SetEventFilterInquiryResultDataChild::SetEventFilterInquiryResultClassOfDevice(Arc::new(SetEventFilterInquiryResultClassOfDeviceData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "filter_condition_type".to_string(), value: v as u64}),};
Ok(Self {filter_condition_type, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let filter_condition_type = self.filter_condition_type.to_u8().unwrap();buffer[4..5].copy_from_slice(&filter_condition_type.to_le_bytes()[0..1]);match &self.child {SetEventFilterInquiryResultDataChild::SetEventFilterInquiryResultAllDevices(value) => value.write_to(buffer),SetEventFilterInquiryResultDataChild::SetEventFilterInquiryResultClassOfDevice(value) => value.write_to(buffer),SetEventFilterInquiryResultDataChild::SetEventFilterInquiryResultAddress(value) => value.write_to(buffer),SetEventFilterInquiryResultDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for SetEventFilterInquiryResultPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SetEventFilterInquiryResultPacket { pub fn specialize(&self) -> SetEventFilterInquiryResultChild { match &self.set_event_filter_inquiry_result.child {SetEventFilterInquiryResultDataChild::SetEventFilterInquiryResultAllDevices(_) => SetEventFilterInquiryResultChild::SetEventFilterInquiryResultAllDevices(SetEventFilterInquiryResultAllDevicesPacket::new(self.command.clone())),SetEventFilterInquiryResultDataChild::SetEventFilterInquiryResultClassOfDevice(_) => SetEventFilterInquiryResultChild::SetEventFilterInquiryResultClassOfDevice(SetEventFilterInquiryResultClassOfDevicePacket::new(self.command.clone())),SetEventFilterInquiryResultDataChild::SetEventFilterInquiryResultAddress(_) => SetEventFilterInquiryResultChild::SetEventFilterInquiryResultAddress(SetEventFilterInquiryResultAddressPacket::new(self.command.clone())),SetEventFilterInquiryResultDataChild::None => SetEventFilterInquiryResultChild::None,}} fn new(root: Arc<CommandData>) -> Self {let command = root;let set_event_filter = match &command.child {CommandDataChild::SetEventFilter(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilter"),};let set_event_filter_inquiry_result = match &set_event_filter.child {SetEventFilterDataChild::SetEventFilterInquiryResult(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilterInquiryResult"),};Self {command,set_event_filter,set_event_filter_inquiry_result,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_filter_type(&self) -> FilterType{ self.set_event_filter.as_ref().filter_type}
pub fn get_filter_condition_type(&self) -> FilterConditionType{ self.set_event_filter_inquiry_result.as_ref().filter_condition_type}
}
impl Into<CommandPacket> for SetEventFilterInquiryResultPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SetEventFilterPacket> for SetEventFilterInquiryResultPacket { fn into(self) -> SetEventFilterPacket {SetEventFilterPacket::new(self.command) }}
impl SetEventFilterInquiryResultBuilder {pub fn build(self) -> SetEventFilterInquiryResultPacket {let set_event_filter_inquiry_result= Arc::new(SetEventFilterInquiryResultData {filter_condition_type: self.filter_condition_type, child: SetEventFilterInquiryResultDataChild::None,});let set_event_filter= Arc::new(SetEventFilterData {filter_type: FilterType::InquiryResult, child: SetEventFilterDataChild::SetEventFilterInquiryResult(set_event_filter_inquiry_result),});let command= Arc::new(CommandData {op_code: OpCode::SetEventFilter, child: CommandDataChild::SetEventFilter(set_event_filter),});SetEventFilterInquiryResultPacket::new(command)}
}
impl Into<CommandPacket> for SetEventFilterInquiryResultBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SetEventFilterPacket> for SetEventFilterInquiryResultBuilder { fn into(self) -> SetEventFilterPacket { self.build().into() }}


#[derive(Debug)] struct SetEventFilterInquiryResultAllDevicesData {}
#[derive(Debug, Clone)] pub struct SetEventFilterInquiryResultAllDevicesPacket {command: Arc<CommandData>,set_event_filter: Arc<SetEventFilterData>,set_event_filter_inquiry_result: Arc<SetEventFilterInquiryResultData>,set_event_filter_inquiry_result_all_devices: Arc<SetEventFilterInquiryResultAllDevicesData>,}
#[derive(Debug)] pub struct SetEventFilterInquiryResultAllDevicesBuilder {}
impl SetEventFilterInquiryResultAllDevicesData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for SetEventFilterInquiryResultAllDevicesPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SetEventFilterInquiryResultAllDevicesPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let set_event_filter = match &command.child {CommandDataChild::SetEventFilter(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilter"),};let set_event_filter_inquiry_result = match &set_event_filter.child {SetEventFilterDataChild::SetEventFilterInquiryResult(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilterInquiryResult"),};let set_event_filter_inquiry_result_all_devices = match &set_event_filter_inquiry_result.child {SetEventFilterInquiryResultDataChild::SetEventFilterInquiryResultAllDevices(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilterInquiryResultAllDevices"),};Self {command,set_event_filter,set_event_filter_inquiry_result,set_event_filter_inquiry_result_all_devices,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_filter_type(&self) -> FilterType{ self.set_event_filter.as_ref().filter_type}
pub fn get_filter_condition_type(&self) -> FilterConditionType{ self.set_event_filter_inquiry_result.as_ref().filter_condition_type}
}
impl Into<CommandPacket> for SetEventFilterInquiryResultAllDevicesPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SetEventFilterPacket> for SetEventFilterInquiryResultAllDevicesPacket { fn into(self) -> SetEventFilterPacket {SetEventFilterPacket::new(self.command) }}
impl Into<SetEventFilterInquiryResultPacket> for SetEventFilterInquiryResultAllDevicesPacket { fn into(self) -> SetEventFilterInquiryResultPacket {SetEventFilterInquiryResultPacket::new(self.command) }}
impl SetEventFilterInquiryResultAllDevicesBuilder {pub fn build(self) -> SetEventFilterInquiryResultAllDevicesPacket {let set_event_filter_inquiry_result_all_devices= Arc::new(SetEventFilterInquiryResultAllDevicesData {});let set_event_filter_inquiry_result= Arc::new(SetEventFilterInquiryResultData {filter_condition_type: FilterConditionType::AllDevices, child: SetEventFilterInquiryResultDataChild::SetEventFilterInquiryResultAllDevices(set_event_filter_inquiry_result_all_devices),});let set_event_filter= Arc::new(SetEventFilterData {filter_type: FilterType::InquiryResult, child: SetEventFilterDataChild::SetEventFilterInquiryResult(set_event_filter_inquiry_result),});let command= Arc::new(CommandData {op_code: OpCode::SetEventFilter, child: CommandDataChild::SetEventFilter(set_event_filter),});SetEventFilterInquiryResultAllDevicesPacket::new(command)}
}
impl Into<CommandPacket> for SetEventFilterInquiryResultAllDevicesBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SetEventFilterPacket> for SetEventFilterInquiryResultAllDevicesBuilder { fn into(self) -> SetEventFilterPacket { self.build().into() }}
impl Into<SetEventFilterInquiryResultPacket> for SetEventFilterInquiryResultAllDevicesBuilder { fn into(self) -> SetEventFilterInquiryResultPacket { self.build().into() }}


#[derive(Debug)] struct SetEventFilterInquiryResultClassOfDeviceData {class_of_device: ClassOfDevice, class_of_device_mask: ClassOfDevice, }
#[derive(Debug, Clone)] pub struct SetEventFilterInquiryResultClassOfDevicePacket {command: Arc<CommandData>,set_event_filter: Arc<SetEventFilterData>,set_event_filter_inquiry_result: Arc<SetEventFilterInquiryResultData>,set_event_filter_inquiry_result_class_of_device: Arc<SetEventFilterInquiryResultClassOfDeviceData>,}
#[derive(Debug)] pub struct SetEventFilterInquiryResultClassOfDeviceBuilder {pub class_of_device: ClassOfDevice, pub class_of_device_mask: ClassOfDevice, }
impl SetEventFilterInquiryResultClassOfDeviceData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "SetEventFilterInquiryResultClassOfDevice".to_string(),    field: "class_of_device".to_string(),    wanted: 8,    got: bytes.len()});}let class_of_device = bytes[5..8].try_into().unwrap();if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "SetEventFilterInquiryResultClassOfDevice".to_string(),    field: "class_of_device_mask".to_string(),    wanted: 11,    got: bytes.len()});}let class_of_device_mask = bytes[8..11].try_into().unwrap();Ok(Self {class_of_device, class_of_device_mask, })
}
fn write_to(&self, buffer: &mut BytesMut) {let class_of_device: [u8; 3] = self.class_of_device.into();buffer[5..8].copy_from_slice(&class_of_device);let class_of_device_mask: [u8; 3] = self.class_of_device_mask.into();buffer[8..11].copy_from_slice(&class_of_device_mask);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl Packet for SetEventFilterInquiryResultClassOfDevicePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SetEventFilterInquiryResultClassOfDevicePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let set_event_filter = match &command.child {CommandDataChild::SetEventFilter(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilter"),};let set_event_filter_inquiry_result = match &set_event_filter.child {SetEventFilterDataChild::SetEventFilterInquiryResult(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilterInquiryResult"),};let set_event_filter_inquiry_result_class_of_device = match &set_event_filter_inquiry_result.child {SetEventFilterInquiryResultDataChild::SetEventFilterInquiryResultClassOfDevice(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilterInquiryResultClassOfDevice"),};Self {command,set_event_filter,set_event_filter_inquiry_result,set_event_filter_inquiry_result_class_of_device,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_filter_type(&self) -> FilterType{ self.set_event_filter.as_ref().filter_type}
pub fn get_filter_condition_type(&self) -> FilterConditionType{ self.set_event_filter_inquiry_result.as_ref().filter_condition_type}
pub fn get_class_of_device(&self) -> ClassOfDevice{ self.set_event_filter_inquiry_result_class_of_device.as_ref().class_of_device}
pub fn get_class_of_device_mask(&self) -> ClassOfDevice{ self.set_event_filter_inquiry_result_class_of_device.as_ref().class_of_device_mask}
}
impl Into<CommandPacket> for SetEventFilterInquiryResultClassOfDevicePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SetEventFilterPacket> for SetEventFilterInquiryResultClassOfDevicePacket { fn into(self) -> SetEventFilterPacket {SetEventFilterPacket::new(self.command) }}
impl Into<SetEventFilterInquiryResultPacket> for SetEventFilterInquiryResultClassOfDevicePacket { fn into(self) -> SetEventFilterInquiryResultPacket {SetEventFilterInquiryResultPacket::new(self.command) }}
impl SetEventFilterInquiryResultClassOfDeviceBuilder {pub fn build(self) -> SetEventFilterInquiryResultClassOfDevicePacket {let set_event_filter_inquiry_result_class_of_device= Arc::new(SetEventFilterInquiryResultClassOfDeviceData {class_of_device: self.class_of_device, class_of_device_mask: self.class_of_device_mask, });let set_event_filter_inquiry_result= Arc::new(SetEventFilterInquiryResultData {filter_condition_type: FilterConditionType::ClassOfDevice, child: SetEventFilterInquiryResultDataChild::SetEventFilterInquiryResultClassOfDevice(set_event_filter_inquiry_result_class_of_device),});let set_event_filter= Arc::new(SetEventFilterData {filter_type: FilterType::InquiryResult, child: SetEventFilterDataChild::SetEventFilterInquiryResult(set_event_filter_inquiry_result),});let command= Arc::new(CommandData {op_code: OpCode::SetEventFilter, child: CommandDataChild::SetEventFilter(set_event_filter),});SetEventFilterInquiryResultClassOfDevicePacket::new(command)}
}
impl Into<CommandPacket> for SetEventFilterInquiryResultClassOfDeviceBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SetEventFilterPacket> for SetEventFilterInquiryResultClassOfDeviceBuilder { fn into(self) -> SetEventFilterPacket { self.build().into() }}
impl Into<SetEventFilterInquiryResultPacket> for SetEventFilterInquiryResultClassOfDeviceBuilder { fn into(self) -> SetEventFilterInquiryResultPacket { self.build().into() }}


#[derive(Debug)] struct SetEventFilterInquiryResultAddressData {address: Address, }
#[derive(Debug, Clone)] pub struct SetEventFilterInquiryResultAddressPacket {command: Arc<CommandData>,set_event_filter: Arc<SetEventFilterData>,set_event_filter_inquiry_result: Arc<SetEventFilterInquiryResultData>,set_event_filter_inquiry_result_address: Arc<SetEventFilterInquiryResultAddressData>,}
#[derive(Debug)] pub struct SetEventFilterInquiryResultAddressBuilder {pub address: Address, }
impl SetEventFilterInquiryResultAddressData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "SetEventFilterInquiryResultAddress".to_string(),    field: "address".to_string(),    wanted: 11,    got: bytes.len()});}let address = bytes[5..11].try_into().unwrap();Ok(Self {address, })
}
fn write_to(&self, buffer: &mut BytesMut) {let address: [u8; 6] = self.address.into();buffer[5..11].copy_from_slice(&address);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl Packet for SetEventFilterInquiryResultAddressPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SetEventFilterInquiryResultAddressPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let set_event_filter = match &command.child {CommandDataChild::SetEventFilter(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilter"),};let set_event_filter_inquiry_result = match &set_event_filter.child {SetEventFilterDataChild::SetEventFilterInquiryResult(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilterInquiryResult"),};let set_event_filter_inquiry_result_address = match &set_event_filter_inquiry_result.child {SetEventFilterInquiryResultDataChild::SetEventFilterInquiryResultAddress(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilterInquiryResultAddress"),};Self {command,set_event_filter,set_event_filter_inquiry_result,set_event_filter_inquiry_result_address,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_filter_type(&self) -> FilterType{ self.set_event_filter.as_ref().filter_type}
pub fn get_filter_condition_type(&self) -> FilterConditionType{ self.set_event_filter_inquiry_result.as_ref().filter_condition_type}
pub fn get_address(&self) -> Address{ self.set_event_filter_inquiry_result_address.as_ref().address}
}
impl Into<CommandPacket> for SetEventFilterInquiryResultAddressPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SetEventFilterPacket> for SetEventFilterInquiryResultAddressPacket { fn into(self) -> SetEventFilterPacket {SetEventFilterPacket::new(self.command) }}
impl Into<SetEventFilterInquiryResultPacket> for SetEventFilterInquiryResultAddressPacket { fn into(self) -> SetEventFilterInquiryResultPacket {SetEventFilterInquiryResultPacket::new(self.command) }}
impl SetEventFilterInquiryResultAddressBuilder {pub fn build(self) -> SetEventFilterInquiryResultAddressPacket {let set_event_filter_inquiry_result_address= Arc::new(SetEventFilterInquiryResultAddressData {address: self.address, });let set_event_filter_inquiry_result= Arc::new(SetEventFilterInquiryResultData {filter_condition_type: FilterConditionType::Address, child: SetEventFilterInquiryResultDataChild::SetEventFilterInquiryResultAddress(set_event_filter_inquiry_result_address),});let set_event_filter= Arc::new(SetEventFilterData {filter_type: FilterType::InquiryResult, child: SetEventFilterDataChild::SetEventFilterInquiryResult(set_event_filter_inquiry_result),});let command= Arc::new(CommandData {op_code: OpCode::SetEventFilter, child: CommandDataChild::SetEventFilter(set_event_filter),});SetEventFilterInquiryResultAddressPacket::new(command)}
}
impl Into<CommandPacket> for SetEventFilterInquiryResultAddressBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SetEventFilterPacket> for SetEventFilterInquiryResultAddressBuilder { fn into(self) -> SetEventFilterPacket { self.build().into() }}
impl Into<SetEventFilterInquiryResultPacket> for SetEventFilterInquiryResultAddressBuilder { fn into(self) -> SetEventFilterInquiryResultPacket { self.build().into() }}


#[derive(Debug)] enum SetEventFilterConnectionSetupDataChild {SetEventFilterConnectionSetupAllDevices(Arc<SetEventFilterConnectionSetupAllDevicesData>),SetEventFilterConnectionSetupClassOfDevice(Arc<SetEventFilterConnectionSetupClassOfDeviceData>),SetEventFilterConnectionSetupAddress(Arc<SetEventFilterConnectionSetupAddressData>),None,}
impl SetEventFilterConnectionSetupDataChild {fn get_total_size(&self) -> usize {match self {SetEventFilterConnectionSetupDataChild::SetEventFilterConnectionSetupAllDevices(value) => value.get_total_size(),SetEventFilterConnectionSetupDataChild::SetEventFilterConnectionSetupClassOfDevice(value) => value.get_total_size(),SetEventFilterConnectionSetupDataChild::SetEventFilterConnectionSetupAddress(value) => value.get_total_size(),SetEventFilterConnectionSetupDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum SetEventFilterConnectionSetupChild {SetEventFilterConnectionSetupAllDevices(SetEventFilterConnectionSetupAllDevicesPacket),SetEventFilterConnectionSetupClassOfDevice(SetEventFilterConnectionSetupClassOfDevicePacket),SetEventFilterConnectionSetupAddress(SetEventFilterConnectionSetupAddressPacket),None,}
#[derive(Debug)] struct SetEventFilterConnectionSetupData {filter_condition_type: FilterConditionType, child: SetEventFilterConnectionSetupDataChild,}
#[derive(Debug, Clone)] pub struct SetEventFilterConnectionSetupPacket {command: Arc<CommandData>,set_event_filter: Arc<SetEventFilterData>,set_event_filter_connection_setup: Arc<SetEventFilterConnectionSetupData>,}
#[derive(Debug)] pub struct SetEventFilterConnectionSetupBuilder {pub filter_condition_type: FilterConditionType, }
impl SetEventFilterConnectionSetupData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "SetEventFilterConnectionSetup".to_string(),    field: "filter_condition_type".to_string(),    wanted: 5,    got: bytes.len()});}let filter_condition_type = u8::from_le_bytes([bytes[4]]);let filter_condition_type = FilterConditionType::from_u8(filter_condition_type).unwrap();let child = match filter_condition_type {FilterConditionType::ClassOfDevice if SetEventFilterConnectionSetupClassOfDeviceData::conforms(&bytes[..]) => {SetEventFilterConnectionSetupDataChild::SetEventFilterConnectionSetupClassOfDevice(Arc::new(SetEventFilterConnectionSetupClassOfDeviceData::parse(&bytes[..])?))}
FilterConditionType::Address if SetEventFilterConnectionSetupAddressData::conforms(&bytes[..]) => {SetEventFilterConnectionSetupDataChild::SetEventFilterConnectionSetupAddress(Arc::new(SetEventFilterConnectionSetupAddressData::parse(&bytes[..])?))}
FilterConditionType::AllDevices if SetEventFilterConnectionSetupAllDevicesData::conforms(&bytes[..]) => {SetEventFilterConnectionSetupDataChild::SetEventFilterConnectionSetupAllDevices(Arc::new(SetEventFilterConnectionSetupAllDevicesData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "filter_condition_type".to_string(), value: v as u64}),};
Ok(Self {filter_condition_type, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let filter_condition_type = self.filter_condition_type.to_u8().unwrap();buffer[4..5].copy_from_slice(&filter_condition_type.to_le_bytes()[0..1]);match &self.child {SetEventFilterConnectionSetupDataChild::SetEventFilterConnectionSetupAllDevices(value) => value.write_to(buffer),SetEventFilterConnectionSetupDataChild::SetEventFilterConnectionSetupClassOfDevice(value) => value.write_to(buffer),SetEventFilterConnectionSetupDataChild::SetEventFilterConnectionSetupAddress(value) => value.write_to(buffer),SetEventFilterConnectionSetupDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for SetEventFilterConnectionSetupPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SetEventFilterConnectionSetupPacket { pub fn specialize(&self) -> SetEventFilterConnectionSetupChild { match &self.set_event_filter_connection_setup.child {SetEventFilterConnectionSetupDataChild::SetEventFilterConnectionSetupAllDevices(_) => SetEventFilterConnectionSetupChild::SetEventFilterConnectionSetupAllDevices(SetEventFilterConnectionSetupAllDevicesPacket::new(self.command.clone())),SetEventFilterConnectionSetupDataChild::SetEventFilterConnectionSetupClassOfDevice(_) => SetEventFilterConnectionSetupChild::SetEventFilterConnectionSetupClassOfDevice(SetEventFilterConnectionSetupClassOfDevicePacket::new(self.command.clone())),SetEventFilterConnectionSetupDataChild::SetEventFilterConnectionSetupAddress(_) => SetEventFilterConnectionSetupChild::SetEventFilterConnectionSetupAddress(SetEventFilterConnectionSetupAddressPacket::new(self.command.clone())),SetEventFilterConnectionSetupDataChild::None => SetEventFilterConnectionSetupChild::None,}} fn new(root: Arc<CommandData>) -> Self {let command = root;let set_event_filter = match &command.child {CommandDataChild::SetEventFilter(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilter"),};let set_event_filter_connection_setup = match &set_event_filter.child {SetEventFilterDataChild::SetEventFilterConnectionSetup(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilterConnectionSetup"),};Self {command,set_event_filter,set_event_filter_connection_setup,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_filter_type(&self) -> FilterType{ self.set_event_filter.as_ref().filter_type}
pub fn get_filter_condition_type(&self) -> FilterConditionType{ self.set_event_filter_connection_setup.as_ref().filter_condition_type}
}
impl Into<CommandPacket> for SetEventFilterConnectionSetupPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SetEventFilterPacket> for SetEventFilterConnectionSetupPacket { fn into(self) -> SetEventFilterPacket {SetEventFilterPacket::new(self.command) }}
impl SetEventFilterConnectionSetupBuilder {pub fn build(self) -> SetEventFilterConnectionSetupPacket {let set_event_filter_connection_setup= Arc::new(SetEventFilterConnectionSetupData {filter_condition_type: self.filter_condition_type, child: SetEventFilterConnectionSetupDataChild::None,});let set_event_filter= Arc::new(SetEventFilterData {filter_type: FilterType::ConnectionSetup, child: SetEventFilterDataChild::SetEventFilterConnectionSetup(set_event_filter_connection_setup),});let command= Arc::new(CommandData {op_code: OpCode::SetEventFilter, child: CommandDataChild::SetEventFilter(set_event_filter),});SetEventFilterConnectionSetupPacket::new(command)}
}
impl Into<CommandPacket> for SetEventFilterConnectionSetupBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SetEventFilterPacket> for SetEventFilterConnectionSetupBuilder { fn into(self) -> SetEventFilterPacket { self.build().into() }}


#[derive(Debug)] struct SetEventFilterConnectionSetupAllDevicesData {auto_accept_flag: AutoAcceptFlag, }
#[derive(Debug, Clone)] pub struct SetEventFilterConnectionSetupAllDevicesPacket {command: Arc<CommandData>,set_event_filter: Arc<SetEventFilterData>,set_event_filter_connection_setup: Arc<SetEventFilterConnectionSetupData>,set_event_filter_connection_setup_all_devices: Arc<SetEventFilterConnectionSetupAllDevicesData>,}
#[derive(Debug)] pub struct SetEventFilterConnectionSetupAllDevicesBuilder {pub auto_accept_flag: AutoAcceptFlag, }
impl SetEventFilterConnectionSetupAllDevicesData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "SetEventFilterConnectionSetupAllDevices".to_string(),    field: "auto_accept_flag".to_string(),    wanted: 6,    got: bytes.len()});}let auto_accept_flag = u8::from_le_bytes([bytes[5]]);let auto_accept_flag = AutoAcceptFlag::from_u8(auto_accept_flag).unwrap();Ok(Self {auto_accept_flag, })
}
fn write_to(&self, buffer: &mut BytesMut) {let auto_accept_flag = self.auto_accept_flag.to_u8().unwrap();buffer[5..6].copy_from_slice(&auto_accept_flag.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for SetEventFilterConnectionSetupAllDevicesPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SetEventFilterConnectionSetupAllDevicesPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let set_event_filter = match &command.child {CommandDataChild::SetEventFilter(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilter"),};let set_event_filter_connection_setup = match &set_event_filter.child {SetEventFilterDataChild::SetEventFilterConnectionSetup(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilterConnectionSetup"),};let set_event_filter_connection_setup_all_devices = match &set_event_filter_connection_setup.child {SetEventFilterConnectionSetupDataChild::SetEventFilterConnectionSetupAllDevices(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilterConnectionSetupAllDevices"),};Self {command,set_event_filter,set_event_filter_connection_setup,set_event_filter_connection_setup_all_devices,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_filter_type(&self) -> FilterType{ self.set_event_filter.as_ref().filter_type}
pub fn get_filter_condition_type(&self) -> FilterConditionType{ self.set_event_filter_connection_setup.as_ref().filter_condition_type}
pub fn get_auto_accept_flag(&self) -> AutoAcceptFlag{ self.set_event_filter_connection_setup_all_devices.as_ref().auto_accept_flag}
}
impl Into<CommandPacket> for SetEventFilterConnectionSetupAllDevicesPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SetEventFilterPacket> for SetEventFilterConnectionSetupAllDevicesPacket { fn into(self) -> SetEventFilterPacket {SetEventFilterPacket::new(self.command) }}
impl Into<SetEventFilterConnectionSetupPacket> for SetEventFilterConnectionSetupAllDevicesPacket { fn into(self) -> SetEventFilterConnectionSetupPacket {SetEventFilterConnectionSetupPacket::new(self.command) }}
impl SetEventFilterConnectionSetupAllDevicesBuilder {pub fn build(self) -> SetEventFilterConnectionSetupAllDevicesPacket {let set_event_filter_connection_setup_all_devices= Arc::new(SetEventFilterConnectionSetupAllDevicesData {auto_accept_flag: self.auto_accept_flag, });let set_event_filter_connection_setup= Arc::new(SetEventFilterConnectionSetupData {filter_condition_type: FilterConditionType::AllDevices, child: SetEventFilterConnectionSetupDataChild::SetEventFilterConnectionSetupAllDevices(set_event_filter_connection_setup_all_devices),});let set_event_filter= Arc::new(SetEventFilterData {filter_type: FilterType::ConnectionSetup, child: SetEventFilterDataChild::SetEventFilterConnectionSetup(set_event_filter_connection_setup),});let command= Arc::new(CommandData {op_code: OpCode::SetEventFilter, child: CommandDataChild::SetEventFilter(set_event_filter),});SetEventFilterConnectionSetupAllDevicesPacket::new(command)}
}
impl Into<CommandPacket> for SetEventFilterConnectionSetupAllDevicesBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SetEventFilterPacket> for SetEventFilterConnectionSetupAllDevicesBuilder { fn into(self) -> SetEventFilterPacket { self.build().into() }}
impl Into<SetEventFilterConnectionSetupPacket> for SetEventFilterConnectionSetupAllDevicesBuilder { fn into(self) -> SetEventFilterConnectionSetupPacket { self.build().into() }}


#[derive(Debug)] struct SetEventFilterConnectionSetupClassOfDeviceData {class_of_device: ClassOfDevice, class_of_device_mask: ClassOfDevice, auto_accept_flag: AutoAcceptFlag, }
#[derive(Debug, Clone)] pub struct SetEventFilterConnectionSetupClassOfDevicePacket {command: Arc<CommandData>,set_event_filter: Arc<SetEventFilterData>,set_event_filter_connection_setup: Arc<SetEventFilterConnectionSetupData>,set_event_filter_connection_setup_class_of_device: Arc<SetEventFilterConnectionSetupClassOfDeviceData>,}
#[derive(Debug)] pub struct SetEventFilterConnectionSetupClassOfDeviceBuilder {pub class_of_device: ClassOfDevice, pub class_of_device_mask: ClassOfDevice, pub auto_accept_flag: AutoAcceptFlag, }
impl SetEventFilterConnectionSetupClassOfDeviceData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "SetEventFilterConnectionSetupClassOfDevice".to_string(),    field: "class_of_device".to_string(),    wanted: 8,    got: bytes.len()});}let class_of_device = bytes[5..8].try_into().unwrap();if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "SetEventFilterConnectionSetupClassOfDevice".to_string(),    field: "class_of_device_mask".to_string(),    wanted: 11,    got: bytes.len()});}let class_of_device_mask = bytes[8..11].try_into().unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "SetEventFilterConnectionSetupClassOfDevice".to_string(),    field: "auto_accept_flag".to_string(),    wanted: 12,    got: bytes.len()});}let auto_accept_flag = u8::from_le_bytes([bytes[11]]);let auto_accept_flag = AutoAcceptFlag::from_u8(auto_accept_flag).unwrap();Ok(Self {class_of_device, class_of_device_mask, auto_accept_flag, })
}
fn write_to(&self, buffer: &mut BytesMut) {let class_of_device: [u8; 3] = self.class_of_device.into();buffer[5..8].copy_from_slice(&class_of_device);let class_of_device_mask: [u8; 3] = self.class_of_device_mask.into();buffer[8..11].copy_from_slice(&class_of_device_mask);let auto_accept_flag = self.auto_accept_flag.to_u8().unwrap();buffer[11..12].copy_from_slice(&auto_accept_flag.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for SetEventFilterConnectionSetupClassOfDevicePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SetEventFilterConnectionSetupClassOfDevicePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let set_event_filter = match &command.child {CommandDataChild::SetEventFilter(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilter"),};let set_event_filter_connection_setup = match &set_event_filter.child {SetEventFilterDataChild::SetEventFilterConnectionSetup(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilterConnectionSetup"),};let set_event_filter_connection_setup_class_of_device = match &set_event_filter_connection_setup.child {SetEventFilterConnectionSetupDataChild::SetEventFilterConnectionSetupClassOfDevice(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilterConnectionSetupClassOfDevice"),};Self {command,set_event_filter,set_event_filter_connection_setup,set_event_filter_connection_setup_class_of_device,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_filter_type(&self) -> FilterType{ self.set_event_filter.as_ref().filter_type}
pub fn get_filter_condition_type(&self) -> FilterConditionType{ self.set_event_filter_connection_setup.as_ref().filter_condition_type}
pub fn get_class_of_device(&self) -> ClassOfDevice{ self.set_event_filter_connection_setup_class_of_device.as_ref().class_of_device}
pub fn get_class_of_device_mask(&self) -> ClassOfDevice{ self.set_event_filter_connection_setup_class_of_device.as_ref().class_of_device_mask}
pub fn get_auto_accept_flag(&self) -> AutoAcceptFlag{ self.set_event_filter_connection_setup_class_of_device.as_ref().auto_accept_flag}
}
impl Into<CommandPacket> for SetEventFilterConnectionSetupClassOfDevicePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SetEventFilterPacket> for SetEventFilterConnectionSetupClassOfDevicePacket { fn into(self) -> SetEventFilterPacket {SetEventFilterPacket::new(self.command) }}
impl Into<SetEventFilterConnectionSetupPacket> for SetEventFilterConnectionSetupClassOfDevicePacket { fn into(self) -> SetEventFilterConnectionSetupPacket {SetEventFilterConnectionSetupPacket::new(self.command) }}
impl SetEventFilterConnectionSetupClassOfDeviceBuilder {pub fn build(self) -> SetEventFilterConnectionSetupClassOfDevicePacket {let set_event_filter_connection_setup_class_of_device= Arc::new(SetEventFilterConnectionSetupClassOfDeviceData {class_of_device: self.class_of_device, class_of_device_mask: self.class_of_device_mask, auto_accept_flag: self.auto_accept_flag, });let set_event_filter_connection_setup= Arc::new(SetEventFilterConnectionSetupData {filter_condition_type: FilterConditionType::ClassOfDevice, child: SetEventFilterConnectionSetupDataChild::SetEventFilterConnectionSetupClassOfDevice(set_event_filter_connection_setup_class_of_device),});let set_event_filter= Arc::new(SetEventFilterData {filter_type: FilterType::ConnectionSetup, child: SetEventFilterDataChild::SetEventFilterConnectionSetup(set_event_filter_connection_setup),});let command= Arc::new(CommandData {op_code: OpCode::SetEventFilter, child: CommandDataChild::SetEventFilter(set_event_filter),});SetEventFilterConnectionSetupClassOfDevicePacket::new(command)}
}
impl Into<CommandPacket> for SetEventFilterConnectionSetupClassOfDeviceBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SetEventFilterPacket> for SetEventFilterConnectionSetupClassOfDeviceBuilder { fn into(self) -> SetEventFilterPacket { self.build().into() }}
impl Into<SetEventFilterConnectionSetupPacket> for SetEventFilterConnectionSetupClassOfDeviceBuilder { fn into(self) -> SetEventFilterConnectionSetupPacket { self.build().into() }}


#[derive(Debug)] struct SetEventFilterConnectionSetupAddressData {address: Address, auto_accept_flag: AutoAcceptFlag, }
#[derive(Debug, Clone)] pub struct SetEventFilterConnectionSetupAddressPacket {command: Arc<CommandData>,set_event_filter: Arc<SetEventFilterData>,set_event_filter_connection_setup: Arc<SetEventFilterConnectionSetupData>,set_event_filter_connection_setup_address: Arc<SetEventFilterConnectionSetupAddressData>,}
#[derive(Debug)] pub struct SetEventFilterConnectionSetupAddressBuilder {pub address: Address, pub auto_accept_flag: AutoAcceptFlag, }
impl SetEventFilterConnectionSetupAddressData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "SetEventFilterConnectionSetupAddress".to_string(),    field: "address".to_string(),    wanted: 11,    got: bytes.len()});}let address = bytes[5..11].try_into().unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "SetEventFilterConnectionSetupAddress".to_string(),    field: "auto_accept_flag".to_string(),    wanted: 12,    got: bytes.len()});}let auto_accept_flag = u8::from_le_bytes([bytes[11]]);let auto_accept_flag = AutoAcceptFlag::from_u8(auto_accept_flag).unwrap();Ok(Self {address, auto_accept_flag, })
}
fn write_to(&self, buffer: &mut BytesMut) {let address: [u8; 6] = self.address.into();buffer[5..11].copy_from_slice(&address);let auto_accept_flag = self.auto_accept_flag.to_u8().unwrap();buffer[11..12].copy_from_slice(&auto_accept_flag.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for SetEventFilterConnectionSetupAddressPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SetEventFilterConnectionSetupAddressPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let set_event_filter = match &command.child {CommandDataChild::SetEventFilter(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilter"),};let set_event_filter_connection_setup = match &set_event_filter.child {SetEventFilterDataChild::SetEventFilterConnectionSetup(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilterConnectionSetup"),};let set_event_filter_connection_setup_address = match &set_event_filter_connection_setup.child {SetEventFilterConnectionSetupDataChild::SetEventFilterConnectionSetupAddress(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEventFilterConnectionSetupAddress"),};Self {command,set_event_filter,set_event_filter_connection_setup,set_event_filter_connection_setup_address,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_filter_type(&self) -> FilterType{ self.set_event_filter.as_ref().filter_type}
pub fn get_filter_condition_type(&self) -> FilterConditionType{ self.set_event_filter_connection_setup.as_ref().filter_condition_type}
pub fn get_address(&self) -> Address{ self.set_event_filter_connection_setup_address.as_ref().address}
pub fn get_auto_accept_flag(&self) -> AutoAcceptFlag{ self.set_event_filter_connection_setup_address.as_ref().auto_accept_flag}
}
impl Into<CommandPacket> for SetEventFilterConnectionSetupAddressPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SetEventFilterPacket> for SetEventFilterConnectionSetupAddressPacket { fn into(self) -> SetEventFilterPacket {SetEventFilterPacket::new(self.command) }}
impl Into<SetEventFilterConnectionSetupPacket> for SetEventFilterConnectionSetupAddressPacket { fn into(self) -> SetEventFilterConnectionSetupPacket {SetEventFilterConnectionSetupPacket::new(self.command) }}
impl SetEventFilterConnectionSetupAddressBuilder {pub fn build(self) -> SetEventFilterConnectionSetupAddressPacket {let set_event_filter_connection_setup_address= Arc::new(SetEventFilterConnectionSetupAddressData {address: self.address, auto_accept_flag: self.auto_accept_flag, });let set_event_filter_connection_setup= Arc::new(SetEventFilterConnectionSetupData {filter_condition_type: FilterConditionType::Address, child: SetEventFilterConnectionSetupDataChild::SetEventFilterConnectionSetupAddress(set_event_filter_connection_setup_address),});let set_event_filter= Arc::new(SetEventFilterData {filter_type: FilterType::ConnectionSetup, child: SetEventFilterDataChild::SetEventFilterConnectionSetup(set_event_filter_connection_setup),});let command= Arc::new(CommandData {op_code: OpCode::SetEventFilter, child: CommandDataChild::SetEventFilter(set_event_filter),});SetEventFilterConnectionSetupAddressPacket::new(command)}
}
impl Into<CommandPacket> for SetEventFilterConnectionSetupAddressBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SetEventFilterPacket> for SetEventFilterConnectionSetupAddressBuilder { fn into(self) -> SetEventFilterPacket { self.build().into() }}
impl Into<SetEventFilterConnectionSetupPacket> for SetEventFilterConnectionSetupAddressBuilder { fn into(self) -> SetEventFilterConnectionSetupPacket { self.build().into() }}


#[derive(Debug)] struct FlushData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct FlushPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,flush: Arc<FlushData>,}
#[derive(Debug)] pub struct FlushBuilder {pub connection_handle: u16, }
impl FlushData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "Flush".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for FlushPacket { type ResponseType = FlushCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { FlushCompletePacket::new(pkt.event.clone()) }}impl Packet for FlushPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl FlushPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let flush = match &connection_management_command.child {ConnectionManagementCommandDataChild::Flush(value) => (*value).clone(),_ => panic!("inconsistent state - child was not Flush"),};Self {command,acl_command,connection_management_command,flush,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.flush.as_ref().connection_handle}
}
impl Into<CommandPacket> for FlushPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for FlushPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for FlushPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for FlushBuilder { type ResponseType = FlushCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { FlushCompletePacket::new(pkt.event.clone()) }}impl FlushBuilder {pub fn build(self) -> FlushPacket {let flush= Arc::new(FlushData {connection_handle: self.connection_handle, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::Flush(flush),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::Flush, child: CommandDataChild::AclCommand(acl_command),});FlushPacket::new(command)}
}
impl Into<CommandPacket> for FlushBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for FlushBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for FlushBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct FlushCompleteData {status: ErrorCode, connection_handle: u16, }
#[derive(Debug, Clone)] pub struct FlushCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,flush_complete: Arc<FlushCompleteData>,}
#[derive(Debug)] pub struct FlushCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, }
impl FlushCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "FlushComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "FlushComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;Ok(Self {status, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for FlushCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl FlushCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let flush_complete = match &command_complete.child {CommandCompleteDataChild::FlushComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not FlushComplete"),};Self {event,command_complete,flush_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.flush_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.flush_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for FlushCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for FlushCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl FlushCompleteBuilder {pub fn build(self) -> FlushCompletePacket {let flush_complete= Arc::new(FlushCompleteData {status: self.status, connection_handle: self.connection_handle, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::Flush, child: CommandCompleteDataChild::FlushComplete(flush_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});FlushCompletePacket::new(event)}
}
impl Into<EventPacket> for FlushCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for FlushCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadPinTypeData {}
#[derive(Debug, Clone)] pub struct ReadPinTypePacket {command: Arc<CommandData>,read_pin_type: Arc<ReadPinTypeData>,}
#[derive(Debug)] pub struct ReadPinTypeBuilder {}
impl ReadPinTypeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadPinTypePacket { type ResponseType = ReadPinTypeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadPinTypeCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadPinTypePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadPinTypePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let read_pin_type = match &command.child {CommandDataChild::ReadPinType(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadPinType"),};Self {command,read_pin_type,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadPinTypePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for ReadPinTypeBuilder { type ResponseType = ReadPinTypeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadPinTypeCompletePacket::new(pkt.event.clone()) }}impl ReadPinTypeBuilder {pub fn build(self) -> ReadPinTypePacket {let read_pin_type= Arc::new(ReadPinTypeData {});let command= Arc::new(CommandData {op_code: OpCode::ReadPinType, child: CommandDataChild::ReadPinType(read_pin_type),});ReadPinTypePacket::new(command)}
}
impl Into<CommandPacket> for ReadPinTypeBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadPinTypeCompleteData {status: ErrorCode, pin_type: PinType, }
#[derive(Debug, Clone)] pub struct ReadPinTypeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_pin_type_complete: Arc<ReadPinTypeCompleteData>,}
#[derive(Debug)] pub struct ReadPinTypeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub pin_type: PinType, }
impl ReadPinTypeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadPinTypeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ReadPinTypeComplete".to_string(),    field: "pin_type".to_string(),    wanted: 7,    got: bytes.len()});}let pin_type = u8::from_le_bytes([bytes[6]]);let pin_type = PinType::from_u8(pin_type).unwrap();Ok(Self {status, pin_type, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let pin_type = self.pin_type.to_u8().unwrap();buffer[6..7].copy_from_slice(&pin_type.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for ReadPinTypeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadPinTypeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_pin_type_complete = match &command_complete.child {CommandCompleteDataChild::ReadPinTypeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadPinTypeComplete"),};Self {event,command_complete,read_pin_type_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_pin_type_complete.as_ref().status}
pub fn get_pin_type(&self) -> PinType{ self.read_pin_type_complete.as_ref().pin_type}
}
impl Into<EventPacket> for ReadPinTypeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadPinTypeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadPinTypeCompleteBuilder {pub fn build(self) -> ReadPinTypeCompletePacket {let read_pin_type_complete= Arc::new(ReadPinTypeCompleteData {status: self.status, pin_type: self.pin_type, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadPinType, child: CommandCompleteDataChild::ReadPinTypeComplete(read_pin_type_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadPinTypeCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadPinTypeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadPinTypeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WritePinTypeData {pin_type: PinType, }
#[derive(Debug, Clone)] pub struct WritePinTypePacket {command: Arc<CommandData>,write_pin_type: Arc<WritePinTypeData>,}
#[derive(Debug)] pub struct WritePinTypeBuilder {pub pin_type: PinType, }
impl WritePinTypeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "WritePinType".to_string(),    field: "pin_type".to_string(),    wanted: 4,    got: bytes.len()});}let pin_type = u8::from_le_bytes([bytes[3]]);let pin_type = PinType::from_u8(pin_type).unwrap();Ok(Self {pin_type, })
}
fn write_to(&self, buffer: &mut BytesMut) {let pin_type = self.pin_type.to_u8().unwrap();buffer[3..4].copy_from_slice(&pin_type.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for WritePinTypePacket { type ResponseType = WritePinTypeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WritePinTypeCompletePacket::new(pkt.event.clone()) }}impl Packet for WritePinTypePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WritePinTypePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let write_pin_type = match &command.child {CommandDataChild::WritePinType(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WritePinType"),};Self {command,write_pin_type,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_pin_type(&self) -> PinType{ self.write_pin_type.as_ref().pin_type}
}
impl Into<CommandPacket> for WritePinTypePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for WritePinTypeBuilder { type ResponseType = WritePinTypeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WritePinTypeCompletePacket::new(pkt.event.clone()) }}impl WritePinTypeBuilder {pub fn build(self) -> WritePinTypePacket {let write_pin_type= Arc::new(WritePinTypeData {pin_type: self.pin_type, });let command= Arc::new(CommandData {op_code: OpCode::WritePinType, child: CommandDataChild::WritePinType(write_pin_type),});WritePinTypePacket::new(command)}
}
impl Into<CommandPacket> for WritePinTypeBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct WritePinTypeCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WritePinTypeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_pin_type_complete: Arc<WritePinTypeCompleteData>,}
#[derive(Debug)] pub struct WritePinTypeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WritePinTypeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WritePinTypeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WritePinTypeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WritePinTypeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_pin_type_complete = match &command_complete.child {CommandCompleteDataChild::WritePinTypeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WritePinTypeComplete"),};Self {event,command_complete,write_pin_type_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_pin_type_complete.as_ref().status}
}
impl Into<EventPacket> for WritePinTypeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WritePinTypeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WritePinTypeCompleteBuilder {pub fn build(self) -> WritePinTypeCompletePacket {let write_pin_type_complete= Arc::new(WritePinTypeCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WritePinType, child: CommandCompleteDataChild::WritePinTypeComplete(write_pin_type_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WritePinTypeCompletePacket::new(event)}
}
impl Into<EventPacket> for WritePinTypeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WritePinTypeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadStoredLinkKeyData {bd_addr: Address, read_all_flag: ReadStoredLinkKeyReadAllFlag, }
#[derive(Debug, Clone)] pub struct ReadStoredLinkKeyPacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,read_stored_link_key: Arc<ReadStoredLinkKeyData>,}
#[derive(Debug)] pub struct ReadStoredLinkKeyBuilder {pub bd_addr: Address, pub read_all_flag: ReadStoredLinkKeyReadAllFlag, }
impl ReadStoredLinkKeyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "ReadStoredLinkKey".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "ReadStoredLinkKey".to_string(),    field: "read_all_flag".to_string(),    wanted: 10,    got: bytes.len()});}let read_all_flag = u8::from_le_bytes([bytes[9]]);let read_all_flag = ReadStoredLinkKeyReadAllFlag::from_u8(read_all_flag).unwrap();Ok(Self {bd_addr, read_all_flag, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);let read_all_flag = self.read_all_flag.to_u8().unwrap();buffer[9..10].copy_from_slice(&read_all_flag.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl CommandExpectations for ReadStoredLinkKeyPacket { type ResponseType = ReadStoredLinkKeyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadStoredLinkKeyCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadStoredLinkKeyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadStoredLinkKeyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let read_stored_link_key = match &security_command.child {SecurityCommandDataChild::ReadStoredLinkKey(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadStoredLinkKey"),};Self {command,security_command,read_stored_link_key,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.read_stored_link_key.as_ref().bd_addr}
pub fn get_read_all_flag(&self) -> ReadStoredLinkKeyReadAllFlag{ self.read_stored_link_key.as_ref().read_all_flag}
}
impl Into<CommandPacket> for ReadStoredLinkKeyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for ReadStoredLinkKeyPacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for ReadStoredLinkKeyBuilder { type ResponseType = ReadStoredLinkKeyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadStoredLinkKeyCompletePacket::new(pkt.event.clone()) }}impl ReadStoredLinkKeyBuilder {pub fn build(self) -> ReadStoredLinkKeyPacket {let read_stored_link_key= Arc::new(ReadStoredLinkKeyData {bd_addr: self.bd_addr, read_all_flag: self.read_all_flag, });let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::ReadStoredLinkKey(read_stored_link_key),});let command= Arc::new(CommandData {op_code: OpCode::ReadStoredLinkKey, child: CommandDataChild::SecurityCommand(security_command),});ReadStoredLinkKeyPacket::new(command)}
}
impl Into<CommandPacket> for ReadStoredLinkKeyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for ReadStoredLinkKeyBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadStoredLinkKeyCompleteData {status: ErrorCode, max_num_keys: u16, num_keys_read: u16, }
#[derive(Debug, Clone)] pub struct ReadStoredLinkKeyCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_stored_link_key_complete: Arc<ReadStoredLinkKeyCompleteData>,}
#[derive(Debug)] pub struct ReadStoredLinkKeyCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub max_num_keys: u16, pub num_keys_read: u16, }
impl ReadStoredLinkKeyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadStoredLinkKeyComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadStoredLinkKeyComplete".to_string(),    field: "max_num_keys".to_string(),    wanted: 8,    got: bytes.len()});}let max_num_keys = u16::from_le_bytes([bytes[6],bytes[7]]);if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "ReadStoredLinkKeyComplete".to_string(),    field: "num_keys_read".to_string(),    wanted: 10,    got: bytes.len()});}let num_keys_read = u16::from_le_bytes([bytes[8],bytes[9]]);Ok(Self {status, max_num_keys, num_keys_read, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let max_num_keys = self.max_num_keys;buffer[6..8].copy_from_slice(&max_num_keys.to_le_bytes()[0..2]);let num_keys_read = self.num_keys_read;buffer[8..10].copy_from_slice(&num_keys_read.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 5;ret}
}
impl Packet for ReadStoredLinkKeyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadStoredLinkKeyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_stored_link_key_complete = match &command_complete.child {CommandCompleteDataChild::ReadStoredLinkKeyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadStoredLinkKeyComplete"),};Self {event,command_complete,read_stored_link_key_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_stored_link_key_complete.as_ref().status}
pub fn get_max_num_keys(&self) -> u16{ self.read_stored_link_key_complete.as_ref().max_num_keys}
pub fn get_num_keys_read(&self) -> u16{ self.read_stored_link_key_complete.as_ref().num_keys_read}
}
impl Into<EventPacket> for ReadStoredLinkKeyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadStoredLinkKeyCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadStoredLinkKeyCompleteBuilder {pub fn build(self) -> ReadStoredLinkKeyCompletePacket {let read_stored_link_key_complete= Arc::new(ReadStoredLinkKeyCompleteData {status: self.status, max_num_keys: self.max_num_keys, num_keys_read: self.num_keys_read, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadStoredLinkKey, child: CommandCompleteDataChild::ReadStoredLinkKeyComplete(read_stored_link_key_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadStoredLinkKeyCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadStoredLinkKeyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadStoredLinkKeyCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WriteStoredLinkKeyData {keys_to_write: Vec::<KeyAndAddress>, }
#[derive(Debug, Clone)] pub struct WriteStoredLinkKeyPacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,write_stored_link_key: Arc<WriteStoredLinkKeyData>,}
#[derive(Debug)] pub struct WriteStoredLinkKeyBuilder {pub keys_to_write: Vec::<KeyAndAddress>, }
impl WriteStoredLinkKeyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "WriteStoredLinkKey".to_string(),    field: "keys_to_write_count".to_string(),    wanted: 4,    got: bytes.len()});}let keys_to_write_count = u8::from_le_bytes([bytes[3]]);let mut keys_to_write: Vec::<KeyAndAddress> = Vec::new();let mut parsable_ = &bytes[4..];let count_ = keys_to_write_count as usize;for _ in 0..count_ { match KeyAndAddress::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];keys_to_write.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {keys_to_write, })
}
fn write_to(&self, buffer: &mut BytesMut) {buffer[3..4].copy_from_slice(&(self.keys_to_write.len() as u8).to_le_bytes());let mut vec_buffer_ = &mut buffer[4..];for e_ in &self.keys_to_write { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;let ret = ret + (self.keys_to_write.len() * ((/* Bits: */ 176 + /* Dynamic: */ 0) / 8));ret}
}
impl CommandExpectations for WriteStoredLinkKeyPacket { type ResponseType = WriteStoredLinkKeyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteStoredLinkKeyCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteStoredLinkKeyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteStoredLinkKeyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let write_stored_link_key = match &security_command.child {SecurityCommandDataChild::WriteStoredLinkKey(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteStoredLinkKey"),};Self {command,security_command,write_stored_link_key,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_keys_to_write(&self) -> &Vec::<KeyAndAddress>{ &self.write_stored_link_key.as_ref().keys_to_write}
}
impl Into<CommandPacket> for WriteStoredLinkKeyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for WriteStoredLinkKeyPacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for WriteStoredLinkKeyBuilder { type ResponseType = WriteStoredLinkKeyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteStoredLinkKeyCompletePacket::new(pkt.event.clone()) }}impl WriteStoredLinkKeyBuilder {pub fn build(self) -> WriteStoredLinkKeyPacket {let write_stored_link_key= Arc::new(WriteStoredLinkKeyData {keys_to_write: self.keys_to_write, });let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::WriteStoredLinkKey(write_stored_link_key),});let command= Arc::new(CommandData {op_code: OpCode::WriteStoredLinkKey, child: CommandDataChild::SecurityCommand(security_command),});WriteStoredLinkKeyPacket::new(command)}
}
impl Into<CommandPacket> for WriteStoredLinkKeyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for WriteStoredLinkKeyBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct WriteStoredLinkKeyCompleteData {status: ErrorCode, num_keys_written: u8, }
#[derive(Debug, Clone)] pub struct WriteStoredLinkKeyCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_stored_link_key_complete: Arc<WriteStoredLinkKeyCompleteData>,}
#[derive(Debug)] pub struct WriteStoredLinkKeyCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub num_keys_written: u8, }
impl WriteStoredLinkKeyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteStoredLinkKeyComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "WriteStoredLinkKeyComplete".to_string(),    field: "num_keys_written".to_string(),    wanted: 7,    got: bytes.len()});}let num_keys_written = u8::from_le_bytes([bytes[6]]);Ok(Self {status, num_keys_written, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let num_keys_written = self.num_keys_written;buffer[6..7].copy_from_slice(&num_keys_written.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for WriteStoredLinkKeyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteStoredLinkKeyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_stored_link_key_complete = match &command_complete.child {CommandCompleteDataChild::WriteStoredLinkKeyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteStoredLinkKeyComplete"),};Self {event,command_complete,write_stored_link_key_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_stored_link_key_complete.as_ref().status}
pub fn get_num_keys_written(&self) -> u8{ self.write_stored_link_key_complete.as_ref().num_keys_written}
}
impl Into<EventPacket> for WriteStoredLinkKeyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteStoredLinkKeyCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteStoredLinkKeyCompleteBuilder {pub fn build(self) -> WriteStoredLinkKeyCompletePacket {let write_stored_link_key_complete= Arc::new(WriteStoredLinkKeyCompleteData {status: self.status, num_keys_written: self.num_keys_written, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteStoredLinkKey, child: CommandCompleteDataChild::WriteStoredLinkKeyComplete(write_stored_link_key_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteStoredLinkKeyCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteStoredLinkKeyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteStoredLinkKeyCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct DeleteStoredLinkKeyData {bd_addr: Address, delete_all_flag: DeleteStoredLinkKeyDeleteAllFlag, }
#[derive(Debug, Clone)] pub struct DeleteStoredLinkKeyPacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,delete_stored_link_key: Arc<DeleteStoredLinkKeyData>,}
#[derive(Debug)] pub struct DeleteStoredLinkKeyBuilder {pub bd_addr: Address, pub delete_all_flag: DeleteStoredLinkKeyDeleteAllFlag, }
impl DeleteStoredLinkKeyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "DeleteStoredLinkKey".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "DeleteStoredLinkKey".to_string(),    field: "delete_all_flag".to_string(),    wanted: 10,    got: bytes.len()});}let delete_all_flag = u8::from_le_bytes([bytes[9]]);let delete_all_flag = DeleteStoredLinkKeyDeleteAllFlag::from_u8(delete_all_flag).unwrap();Ok(Self {bd_addr, delete_all_flag, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);let delete_all_flag = self.delete_all_flag.to_u8().unwrap();buffer[9..10].copy_from_slice(&delete_all_flag.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl CommandExpectations for DeleteStoredLinkKeyPacket { type ResponseType = DeleteStoredLinkKeyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { DeleteStoredLinkKeyCompletePacket::new(pkt.event.clone()) }}impl Packet for DeleteStoredLinkKeyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl DeleteStoredLinkKeyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let delete_stored_link_key = match &security_command.child {SecurityCommandDataChild::DeleteStoredLinkKey(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DeleteStoredLinkKey"),};Self {command,security_command,delete_stored_link_key,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.delete_stored_link_key.as_ref().bd_addr}
pub fn get_delete_all_flag(&self) -> DeleteStoredLinkKeyDeleteAllFlag{ self.delete_stored_link_key.as_ref().delete_all_flag}
}
impl Into<CommandPacket> for DeleteStoredLinkKeyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for DeleteStoredLinkKeyPacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for DeleteStoredLinkKeyBuilder { type ResponseType = DeleteStoredLinkKeyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { DeleteStoredLinkKeyCompletePacket::new(pkt.event.clone()) }}impl DeleteStoredLinkKeyBuilder {pub fn build(self) -> DeleteStoredLinkKeyPacket {let delete_stored_link_key= Arc::new(DeleteStoredLinkKeyData {bd_addr: self.bd_addr, delete_all_flag: self.delete_all_flag, });let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::DeleteStoredLinkKey(delete_stored_link_key),});let command= Arc::new(CommandData {op_code: OpCode::DeleteStoredLinkKey, child: CommandDataChild::SecurityCommand(security_command),});DeleteStoredLinkKeyPacket::new(command)}
}
impl Into<CommandPacket> for DeleteStoredLinkKeyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for DeleteStoredLinkKeyBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct DeleteStoredLinkKeyCompleteData {status: ErrorCode, num_keys_deleted: u16, }
#[derive(Debug, Clone)] pub struct DeleteStoredLinkKeyCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,delete_stored_link_key_complete: Arc<DeleteStoredLinkKeyCompleteData>,}
#[derive(Debug)] pub struct DeleteStoredLinkKeyCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub num_keys_deleted: u16, }
impl DeleteStoredLinkKeyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "DeleteStoredLinkKeyComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "DeleteStoredLinkKeyComplete".to_string(),    field: "num_keys_deleted".to_string(),    wanted: 8,    got: bytes.len()});}let num_keys_deleted = u16::from_le_bytes([bytes[6],bytes[7]]);Ok(Self {status, num_keys_deleted, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let num_keys_deleted = self.num_keys_deleted;buffer[6..8].copy_from_slice(&num_keys_deleted.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for DeleteStoredLinkKeyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl DeleteStoredLinkKeyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let delete_stored_link_key_complete = match &command_complete.child {CommandCompleteDataChild::DeleteStoredLinkKeyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DeleteStoredLinkKeyComplete"),};Self {event,command_complete,delete_stored_link_key_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.delete_stored_link_key_complete.as_ref().status}
pub fn get_num_keys_deleted(&self) -> u16{ self.delete_stored_link_key_complete.as_ref().num_keys_deleted}
}
impl Into<EventPacket> for DeleteStoredLinkKeyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for DeleteStoredLinkKeyCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl DeleteStoredLinkKeyCompleteBuilder {pub fn build(self) -> DeleteStoredLinkKeyCompletePacket {let delete_stored_link_key_complete= Arc::new(DeleteStoredLinkKeyCompleteData {status: self.status, num_keys_deleted: self.num_keys_deleted, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::DeleteStoredLinkKey, child: CommandCompleteDataChild::DeleteStoredLinkKeyComplete(delete_stored_link_key_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});DeleteStoredLinkKeyCompletePacket::new(event)}
}
impl Into<EventPacket> for DeleteStoredLinkKeyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for DeleteStoredLinkKeyCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WriteLocalNameData {local_name: [u8; 248], }
#[derive(Debug, Clone)] pub struct WriteLocalNamePacket {command: Arc<CommandData>,write_local_name: Arc<WriteLocalNameData>,}
#[derive(Debug)] pub struct WriteLocalNameBuilder {pub local_name: [u8; 248], }
impl WriteLocalNameData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 251 { return Err(Error::InvalidLengthError{    obj: "WriteLocalName".to_string(),    field: "local_name".to_string(),    wanted: 251,    got: bytes.len()});}let local_name = bytes[3..251].try_into().unwrap();Ok(Self {local_name, })
}
fn write_to(&self, buffer: &mut BytesMut) {&buffer[3..251].copy_from_slice(&self.local_name);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 248;ret}
}
impl CommandExpectations for WriteLocalNamePacket { type ResponseType = WriteLocalNameCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteLocalNameCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteLocalNamePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteLocalNamePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let write_local_name = match &command.child {CommandDataChild::WriteLocalName(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteLocalName"),};Self {command,write_local_name,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_local_name(&self) -> &[u8; 248]{ &self.write_local_name.as_ref().local_name}
}
impl Into<CommandPacket> for WriteLocalNamePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for WriteLocalNameBuilder { type ResponseType = WriteLocalNameCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteLocalNameCompletePacket::new(pkt.event.clone()) }}impl WriteLocalNameBuilder {pub fn build(self) -> WriteLocalNamePacket {let write_local_name= Arc::new(WriteLocalNameData {local_name: self.local_name, });let command= Arc::new(CommandData {op_code: OpCode::WriteLocalName, child: CommandDataChild::WriteLocalName(write_local_name),});WriteLocalNamePacket::new(command)}
}
impl Into<CommandPacket> for WriteLocalNameBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct WriteLocalNameCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WriteLocalNameCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_local_name_complete: Arc<WriteLocalNameCompleteData>,}
#[derive(Debug)] pub struct WriteLocalNameCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WriteLocalNameCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteLocalNameComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WriteLocalNameCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteLocalNameCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_local_name_complete = match &command_complete.child {CommandCompleteDataChild::WriteLocalNameComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteLocalNameComplete"),};Self {event,command_complete,write_local_name_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_local_name_complete.as_ref().status}
}
impl Into<EventPacket> for WriteLocalNameCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteLocalNameCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteLocalNameCompleteBuilder {pub fn build(self) -> WriteLocalNameCompletePacket {let write_local_name_complete= Arc::new(WriteLocalNameCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteLocalName, child: CommandCompleteDataChild::WriteLocalNameComplete(write_local_name_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteLocalNameCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteLocalNameCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteLocalNameCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadLocalNameData {}
#[derive(Debug, Clone)] pub struct ReadLocalNamePacket {command: Arc<CommandData>,read_local_name: Arc<ReadLocalNameData>,}
#[derive(Debug)] pub struct ReadLocalNameBuilder {}
impl ReadLocalNameData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadLocalNamePacket { type ResponseType = ReadLocalNameCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLocalNameCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadLocalNamePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLocalNamePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let read_local_name = match &command.child {CommandDataChild::ReadLocalName(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLocalName"),};Self {command,read_local_name,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadLocalNamePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for ReadLocalNameBuilder { type ResponseType = ReadLocalNameCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLocalNameCompletePacket::new(pkt.event.clone()) }}impl ReadLocalNameBuilder {pub fn build(self) -> ReadLocalNamePacket {let read_local_name= Arc::new(ReadLocalNameData {});let command= Arc::new(CommandData {op_code: OpCode::ReadLocalName, child: CommandDataChild::ReadLocalName(read_local_name),});ReadLocalNamePacket::new(command)}
}
impl Into<CommandPacket> for ReadLocalNameBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadLocalNameCompleteData {status: ErrorCode, local_name: [u8; 248], }
#[derive(Debug, Clone)] pub struct ReadLocalNameCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_local_name_complete: Arc<ReadLocalNameCompleteData>,}
#[derive(Debug)] pub struct ReadLocalNameCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub local_name: [u8; 248], }
impl ReadLocalNameCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadLocalNameComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 254 { return Err(Error::InvalidLengthError{    obj: "ReadLocalNameComplete".to_string(),    field: "local_name".to_string(),    wanted: 254,    got: bytes.len()});}let local_name = bytes[6..254].try_into().unwrap();Ok(Self {status, local_name, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);&buffer[6..254].copy_from_slice(&self.local_name);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 249;ret}
}
impl Packet for ReadLocalNameCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLocalNameCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_local_name_complete = match &command_complete.child {CommandCompleteDataChild::ReadLocalNameComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLocalNameComplete"),};Self {event,command_complete,read_local_name_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_local_name_complete.as_ref().status}
pub fn get_local_name(&self) -> &[u8; 248]{ &self.read_local_name_complete.as_ref().local_name}
}
impl Into<EventPacket> for ReadLocalNameCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadLocalNameCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadLocalNameCompleteBuilder {pub fn build(self) -> ReadLocalNameCompletePacket {let read_local_name_complete= Arc::new(ReadLocalNameCompleteData {status: self.status, local_name: self.local_name, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadLocalName, child: CommandCompleteDataChild::ReadLocalNameComplete(read_local_name_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadLocalNameCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadLocalNameCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadLocalNameCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadConnectionAcceptTimeoutData {}
#[derive(Debug, Clone)] pub struct ReadConnectionAcceptTimeoutPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,read_connection_accept_timeout: Arc<ReadConnectionAcceptTimeoutData>,}
#[derive(Debug)] pub struct ReadConnectionAcceptTimeoutBuilder {}
impl ReadConnectionAcceptTimeoutData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadConnectionAcceptTimeoutPacket { type ResponseType = ReadConnectionAcceptTimeoutCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadConnectionAcceptTimeoutCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadConnectionAcceptTimeoutPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadConnectionAcceptTimeoutPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let read_connection_accept_timeout = match &connection_management_command.child {ConnectionManagementCommandDataChild::ReadConnectionAcceptTimeout(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadConnectionAcceptTimeout"),};Self {command,acl_command,connection_management_command,read_connection_accept_timeout,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadConnectionAcceptTimeoutPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for ReadConnectionAcceptTimeoutPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for ReadConnectionAcceptTimeoutPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for ReadConnectionAcceptTimeoutBuilder { type ResponseType = ReadConnectionAcceptTimeoutCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadConnectionAcceptTimeoutCompletePacket::new(pkt.event.clone()) }}impl ReadConnectionAcceptTimeoutBuilder {pub fn build(self) -> ReadConnectionAcceptTimeoutPacket {let read_connection_accept_timeout= Arc::new(ReadConnectionAcceptTimeoutData {});let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::ReadConnectionAcceptTimeout(read_connection_accept_timeout),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::ReadConnectionAcceptTimeout, child: CommandDataChild::AclCommand(acl_command),});ReadConnectionAcceptTimeoutPacket::new(command)}
}
impl Into<CommandPacket> for ReadConnectionAcceptTimeoutBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for ReadConnectionAcceptTimeoutBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for ReadConnectionAcceptTimeoutBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadConnectionAcceptTimeoutCompleteData {status: ErrorCode, conn_accept_timeout: u16, }
#[derive(Debug, Clone)] pub struct ReadConnectionAcceptTimeoutCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_connection_accept_timeout_complete: Arc<ReadConnectionAcceptTimeoutCompleteData>,}
#[derive(Debug)] pub struct ReadConnectionAcceptTimeoutCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub conn_accept_timeout: u16, }
impl ReadConnectionAcceptTimeoutCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadConnectionAcceptTimeoutComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadConnectionAcceptTimeoutComplete".to_string(),    field: "conn_accept_timeout".to_string(),    wanted: 8,    got: bytes.len()});}let conn_accept_timeout = u16::from_le_bytes([bytes[6],bytes[7]]);Ok(Self {status, conn_accept_timeout, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let conn_accept_timeout = self.conn_accept_timeout;buffer[6..8].copy_from_slice(&conn_accept_timeout.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for ReadConnectionAcceptTimeoutCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadConnectionAcceptTimeoutCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_connection_accept_timeout_complete = match &command_complete.child {CommandCompleteDataChild::ReadConnectionAcceptTimeoutComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadConnectionAcceptTimeoutComplete"),};Self {event,command_complete,read_connection_accept_timeout_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_connection_accept_timeout_complete.as_ref().status}
pub fn get_conn_accept_timeout(&self) -> u16{ self.read_connection_accept_timeout_complete.as_ref().conn_accept_timeout}
}
impl Into<EventPacket> for ReadConnectionAcceptTimeoutCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadConnectionAcceptTimeoutCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadConnectionAcceptTimeoutCompleteBuilder {pub fn build(self) -> ReadConnectionAcceptTimeoutCompletePacket {let read_connection_accept_timeout_complete= Arc::new(ReadConnectionAcceptTimeoutCompleteData {status: self.status, conn_accept_timeout: self.conn_accept_timeout, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadConnectionAcceptTimeout, child: CommandCompleteDataChild::ReadConnectionAcceptTimeoutComplete(read_connection_accept_timeout_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadConnectionAcceptTimeoutCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadConnectionAcceptTimeoutCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadConnectionAcceptTimeoutCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WriteConnectionAcceptTimeoutData {conn_accept_timeout: u16, }
#[derive(Debug, Clone)] pub struct WriteConnectionAcceptTimeoutPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,write_connection_accept_timeout: Arc<WriteConnectionAcceptTimeoutData>,}
#[derive(Debug)] pub struct WriteConnectionAcceptTimeoutBuilder {pub conn_accept_timeout: u16, }
impl WriteConnectionAcceptTimeoutData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "WriteConnectionAcceptTimeout".to_string(),    field: "conn_accept_timeout".to_string(),    wanted: 5,    got: bytes.len()});}let conn_accept_timeout = u16::from_le_bytes([bytes[3],bytes[4]]);Ok(Self {conn_accept_timeout, })
}
fn write_to(&self, buffer: &mut BytesMut) {let conn_accept_timeout = self.conn_accept_timeout;buffer[3..5].copy_from_slice(&conn_accept_timeout.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for WriteConnectionAcceptTimeoutPacket { type ResponseType = WriteConnectionAcceptTimeoutCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteConnectionAcceptTimeoutCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteConnectionAcceptTimeoutPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteConnectionAcceptTimeoutPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let write_connection_accept_timeout = match &connection_management_command.child {ConnectionManagementCommandDataChild::WriteConnectionAcceptTimeout(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteConnectionAcceptTimeout"),};Self {command,acl_command,connection_management_command,write_connection_accept_timeout,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_conn_accept_timeout(&self) -> u16{ self.write_connection_accept_timeout.as_ref().conn_accept_timeout}
}
impl Into<CommandPacket> for WriteConnectionAcceptTimeoutPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for WriteConnectionAcceptTimeoutPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for WriteConnectionAcceptTimeoutPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for WriteConnectionAcceptTimeoutBuilder { type ResponseType = WriteConnectionAcceptTimeoutCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteConnectionAcceptTimeoutCompletePacket::new(pkt.event.clone()) }}impl WriteConnectionAcceptTimeoutBuilder {pub fn build(self) -> WriteConnectionAcceptTimeoutPacket {let write_connection_accept_timeout= Arc::new(WriteConnectionAcceptTimeoutData {conn_accept_timeout: self.conn_accept_timeout, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::WriteConnectionAcceptTimeout(write_connection_accept_timeout),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::WriteConnectionAcceptTimeout, child: CommandDataChild::AclCommand(acl_command),});WriteConnectionAcceptTimeoutPacket::new(command)}
}
impl Into<CommandPacket> for WriteConnectionAcceptTimeoutBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for WriteConnectionAcceptTimeoutBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for WriteConnectionAcceptTimeoutBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct WriteConnectionAcceptTimeoutCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WriteConnectionAcceptTimeoutCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_connection_accept_timeout_complete: Arc<WriteConnectionAcceptTimeoutCompleteData>,}
#[derive(Debug)] pub struct WriteConnectionAcceptTimeoutCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WriteConnectionAcceptTimeoutCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteConnectionAcceptTimeoutComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WriteConnectionAcceptTimeoutCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteConnectionAcceptTimeoutCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_connection_accept_timeout_complete = match &command_complete.child {CommandCompleteDataChild::WriteConnectionAcceptTimeoutComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteConnectionAcceptTimeoutComplete"),};Self {event,command_complete,write_connection_accept_timeout_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_connection_accept_timeout_complete.as_ref().status}
}
impl Into<EventPacket> for WriteConnectionAcceptTimeoutCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteConnectionAcceptTimeoutCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteConnectionAcceptTimeoutCompleteBuilder {pub fn build(self) -> WriteConnectionAcceptTimeoutCompletePacket {let write_connection_accept_timeout_complete= Arc::new(WriteConnectionAcceptTimeoutCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteConnectionAcceptTimeout, child: CommandCompleteDataChild::WriteConnectionAcceptTimeoutComplete(write_connection_accept_timeout_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteConnectionAcceptTimeoutCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteConnectionAcceptTimeoutCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteConnectionAcceptTimeoutCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadPageTimeoutData {}
#[derive(Debug, Clone)] pub struct ReadPageTimeoutPacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,read_page_timeout: Arc<ReadPageTimeoutData>,}
#[derive(Debug)] pub struct ReadPageTimeoutBuilder {}
impl ReadPageTimeoutData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadPageTimeoutPacket { type ResponseType = ReadPageTimeoutCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadPageTimeoutCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadPageTimeoutPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadPageTimeoutPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let read_page_timeout = match &discovery_command.child {DiscoveryCommandDataChild::ReadPageTimeout(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadPageTimeout"),};Self {command,discovery_command,read_page_timeout,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadPageTimeoutPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for ReadPageTimeoutPacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for ReadPageTimeoutBuilder { type ResponseType = ReadPageTimeoutCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadPageTimeoutCompletePacket::new(pkt.event.clone()) }}impl ReadPageTimeoutBuilder {pub fn build(self) -> ReadPageTimeoutPacket {let read_page_timeout= Arc::new(ReadPageTimeoutData {});let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::ReadPageTimeout(read_page_timeout),});let command= Arc::new(CommandData {op_code: OpCode::ReadPageTimeout, child: CommandDataChild::DiscoveryCommand(discovery_command),});ReadPageTimeoutPacket::new(command)}
}
impl Into<CommandPacket> for ReadPageTimeoutBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for ReadPageTimeoutBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}
macro_rules! read_page_timeout_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::DiscoveryCommand(discovery_command_packet) => {match discovery_command_packet.specialize() {/* (2) */
DiscoveryCommandChild::ReadPageTimeout(packet) => {let rebuilder = ReadPageTimeoutBuilder {};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse read_page_timeout{:02x?}", discovery_command_packet); }}}_ => {println!("Couldn't parse discovery_command{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}read_page_timeout_builder_tests! { read_page_timeout_builder_test_00: b"\x17\x0c\x00",}


#[derive(Debug)] struct ReadPageTimeoutCompleteData {status: ErrorCode, page_timeout: u16, }
#[derive(Debug, Clone)] pub struct ReadPageTimeoutCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_page_timeout_complete: Arc<ReadPageTimeoutCompleteData>,}
#[derive(Debug)] pub struct ReadPageTimeoutCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub page_timeout: u16, }
impl ReadPageTimeoutCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadPageTimeoutComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadPageTimeoutComplete".to_string(),    field: "page_timeout".to_string(),    wanted: 8,    got: bytes.len()});}let page_timeout = u16::from_le_bytes([bytes[6],bytes[7]]);Ok(Self {status, page_timeout, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let page_timeout = self.page_timeout;buffer[6..8].copy_from_slice(&page_timeout.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for ReadPageTimeoutCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadPageTimeoutCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_page_timeout_complete = match &command_complete.child {CommandCompleteDataChild::ReadPageTimeoutComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadPageTimeoutComplete"),};Self {event,command_complete,read_page_timeout_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_page_timeout_complete.as_ref().status}
pub fn get_page_timeout(&self) -> u16{ self.read_page_timeout_complete.as_ref().page_timeout}
}
impl Into<EventPacket> for ReadPageTimeoutCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadPageTimeoutCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadPageTimeoutCompleteBuilder {pub fn build(self) -> ReadPageTimeoutCompletePacket {let read_page_timeout_complete= Arc::new(ReadPageTimeoutCompleteData {status: self.status, page_timeout: self.page_timeout, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadPageTimeout, child: CommandCompleteDataChild::ReadPageTimeoutComplete(read_page_timeout_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadPageTimeoutCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadPageTimeoutCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadPageTimeoutCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! read_page_timeout_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::ReadPageTimeoutComplete(packet) => {let rebuilder = ReadPageTimeoutCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),page_timeout : packet.get_page_timeout(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse read_page_timeout_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}read_page_timeout_complete_builder_tests! { read_page_timeout_complete_builder_test_00: b"\x0e\x06\x01\x17\x0c\x00\x11\x22",}


#[derive(Debug)] struct WritePageTimeoutData {page_timeout: u16, }
#[derive(Debug, Clone)] pub struct WritePageTimeoutPacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,write_page_timeout: Arc<WritePageTimeoutData>,}
#[derive(Debug)] pub struct WritePageTimeoutBuilder {pub page_timeout: u16, }
impl WritePageTimeoutData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "WritePageTimeout".to_string(),    field: "page_timeout".to_string(),    wanted: 5,    got: bytes.len()});}let page_timeout = u16::from_le_bytes([bytes[3],bytes[4]]);Ok(Self {page_timeout, })
}
fn write_to(&self, buffer: &mut BytesMut) {let page_timeout = self.page_timeout;buffer[3..5].copy_from_slice(&page_timeout.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for WritePageTimeoutPacket { type ResponseType = WritePageTimeoutCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WritePageTimeoutCompletePacket::new(pkt.event.clone()) }}impl Packet for WritePageTimeoutPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WritePageTimeoutPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let write_page_timeout = match &discovery_command.child {DiscoveryCommandDataChild::WritePageTimeout(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WritePageTimeout"),};Self {command,discovery_command,write_page_timeout,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_page_timeout(&self) -> u16{ self.write_page_timeout.as_ref().page_timeout}
}
impl Into<CommandPacket> for WritePageTimeoutPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for WritePageTimeoutPacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for WritePageTimeoutBuilder { type ResponseType = WritePageTimeoutCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WritePageTimeoutCompletePacket::new(pkt.event.clone()) }}impl WritePageTimeoutBuilder {pub fn build(self) -> WritePageTimeoutPacket {let write_page_timeout= Arc::new(WritePageTimeoutData {page_timeout: self.page_timeout, });let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::WritePageTimeout(write_page_timeout),});let command= Arc::new(CommandData {op_code: OpCode::WritePageTimeout, child: CommandDataChild::DiscoveryCommand(discovery_command),});WritePageTimeoutPacket::new(command)}
}
impl Into<CommandPacket> for WritePageTimeoutBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for WritePageTimeoutBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}
macro_rules! write_page_timeout_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::DiscoveryCommand(discovery_command_packet) => {match discovery_command_packet.specialize() {/* (2) */
DiscoveryCommandChild::WritePageTimeout(packet) => {let rebuilder = WritePageTimeoutBuilder {page_timeout : packet.get_page_timeout(),};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse write_page_timeout{:02x?}", discovery_command_packet); }}}_ => {println!("Couldn't parse discovery_command{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}write_page_timeout_builder_tests! { write_page_timeout_builder_test_00: b"\x18\x0c\x02\x00\x20",}


#[derive(Debug)] struct WritePageTimeoutCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WritePageTimeoutCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_page_timeout_complete: Arc<WritePageTimeoutCompleteData>,}
#[derive(Debug)] pub struct WritePageTimeoutCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WritePageTimeoutCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WritePageTimeoutComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WritePageTimeoutCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WritePageTimeoutCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_page_timeout_complete = match &command_complete.child {CommandCompleteDataChild::WritePageTimeoutComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WritePageTimeoutComplete"),};Self {event,command_complete,write_page_timeout_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_page_timeout_complete.as_ref().status}
}
impl Into<EventPacket> for WritePageTimeoutCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WritePageTimeoutCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WritePageTimeoutCompleteBuilder {pub fn build(self) -> WritePageTimeoutCompletePacket {let write_page_timeout_complete= Arc::new(WritePageTimeoutCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WritePageTimeout, child: CommandCompleteDataChild::WritePageTimeoutComplete(write_page_timeout_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WritePageTimeoutCompletePacket::new(event)}
}
impl Into<EventPacket> for WritePageTimeoutCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WritePageTimeoutCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! write_page_timeout_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::WritePageTimeoutComplete(packet) => {let rebuilder = WritePageTimeoutCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse write_page_timeout_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}write_page_timeout_complete_builder_tests! { write_page_timeout_complete_builder_test_00: b"\x0e\x04\x01\x18\x0c\x00",}


#[derive(Debug)] struct ReadScanEnableData {}
#[derive(Debug, Clone)] pub struct ReadScanEnablePacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,read_scan_enable: Arc<ReadScanEnableData>,}
#[derive(Debug)] pub struct ReadScanEnableBuilder {}
impl ReadScanEnableData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadScanEnablePacket { type ResponseType = ReadScanEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadScanEnableCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadScanEnablePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadScanEnablePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let read_scan_enable = match &discovery_command.child {DiscoveryCommandDataChild::ReadScanEnable(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadScanEnable"),};Self {command,discovery_command,read_scan_enable,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadScanEnablePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for ReadScanEnablePacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for ReadScanEnableBuilder { type ResponseType = ReadScanEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadScanEnableCompletePacket::new(pkt.event.clone()) }}impl ReadScanEnableBuilder {pub fn build(self) -> ReadScanEnablePacket {let read_scan_enable= Arc::new(ReadScanEnableData {});let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::ReadScanEnable(read_scan_enable),});let command= Arc::new(CommandData {op_code: OpCode::ReadScanEnable, child: CommandDataChild::DiscoveryCommand(discovery_command),});ReadScanEnablePacket::new(command)}
}
impl Into<CommandPacket> for ReadScanEnableBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for ReadScanEnableBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadScanEnableCompleteData {status: ErrorCode, scan_enable: ScanEnable, }
#[derive(Debug, Clone)] pub struct ReadScanEnableCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_scan_enable_complete: Arc<ReadScanEnableCompleteData>,}
#[derive(Debug)] pub struct ReadScanEnableCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub scan_enable: ScanEnable, }
impl ReadScanEnableCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadScanEnableComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ReadScanEnableComplete".to_string(),    field: "scan_enable".to_string(),    wanted: 7,    got: bytes.len()});}let scan_enable = u8::from_le_bytes([bytes[6]]);let scan_enable = ScanEnable::from_u8(scan_enable).unwrap();Ok(Self {status, scan_enable, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let scan_enable = self.scan_enable.to_u8().unwrap();buffer[6..7].copy_from_slice(&scan_enable.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for ReadScanEnableCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadScanEnableCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_scan_enable_complete = match &command_complete.child {CommandCompleteDataChild::ReadScanEnableComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadScanEnableComplete"),};Self {event,command_complete,read_scan_enable_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_scan_enable_complete.as_ref().status}
pub fn get_scan_enable(&self) -> ScanEnable{ self.read_scan_enable_complete.as_ref().scan_enable}
}
impl Into<EventPacket> for ReadScanEnableCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadScanEnableCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadScanEnableCompleteBuilder {pub fn build(self) -> ReadScanEnableCompletePacket {let read_scan_enable_complete= Arc::new(ReadScanEnableCompleteData {status: self.status, scan_enable: self.scan_enable, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadScanEnable, child: CommandCompleteDataChild::ReadScanEnableComplete(read_scan_enable_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadScanEnableCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadScanEnableCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadScanEnableCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WriteScanEnableData {scan_enable: ScanEnable, }
#[derive(Debug, Clone)] pub struct WriteScanEnablePacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,write_scan_enable: Arc<WriteScanEnableData>,}
#[derive(Debug)] pub struct WriteScanEnableBuilder {pub scan_enable: ScanEnable, }
impl WriteScanEnableData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "WriteScanEnable".to_string(),    field: "scan_enable".to_string(),    wanted: 4,    got: bytes.len()});}let scan_enable = u8::from_le_bytes([bytes[3]]);let scan_enable = ScanEnable::from_u8(scan_enable).unwrap();Ok(Self {scan_enable, })
}
fn write_to(&self, buffer: &mut BytesMut) {let scan_enable = self.scan_enable.to_u8().unwrap();buffer[3..4].copy_from_slice(&scan_enable.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for WriteScanEnablePacket { type ResponseType = WriteScanEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteScanEnableCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteScanEnablePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteScanEnablePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let write_scan_enable = match &discovery_command.child {DiscoveryCommandDataChild::WriteScanEnable(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteScanEnable"),};Self {command,discovery_command,write_scan_enable,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_scan_enable(&self) -> ScanEnable{ self.write_scan_enable.as_ref().scan_enable}
}
impl Into<CommandPacket> for WriteScanEnablePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for WriteScanEnablePacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for WriteScanEnableBuilder { type ResponseType = WriteScanEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteScanEnableCompletePacket::new(pkt.event.clone()) }}impl WriteScanEnableBuilder {pub fn build(self) -> WriteScanEnablePacket {let write_scan_enable= Arc::new(WriteScanEnableData {scan_enable: self.scan_enable, });let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::WriteScanEnable(write_scan_enable),});let command= Arc::new(CommandData {op_code: OpCode::WriteScanEnable, child: CommandDataChild::DiscoveryCommand(discovery_command),});WriteScanEnablePacket::new(command)}
}
impl Into<CommandPacket> for WriteScanEnableBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for WriteScanEnableBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}


#[derive(Debug)] struct WriteScanEnableCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WriteScanEnableCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_scan_enable_complete: Arc<WriteScanEnableCompleteData>,}
#[derive(Debug)] pub struct WriteScanEnableCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WriteScanEnableCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteScanEnableComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WriteScanEnableCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteScanEnableCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_scan_enable_complete = match &command_complete.child {CommandCompleteDataChild::WriteScanEnableComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteScanEnableComplete"),};Self {event,command_complete,write_scan_enable_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_scan_enable_complete.as_ref().status}
}
impl Into<EventPacket> for WriteScanEnableCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteScanEnableCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteScanEnableCompleteBuilder {pub fn build(self) -> WriteScanEnableCompletePacket {let write_scan_enable_complete= Arc::new(WriteScanEnableCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteScanEnable, child: CommandCompleteDataChild::WriteScanEnableComplete(write_scan_enable_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteScanEnableCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteScanEnableCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteScanEnableCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadPageScanActivityData {}
#[derive(Debug, Clone)] pub struct ReadPageScanActivityPacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,read_page_scan_activity: Arc<ReadPageScanActivityData>,}
#[derive(Debug)] pub struct ReadPageScanActivityBuilder {}
impl ReadPageScanActivityData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadPageScanActivityPacket { type ResponseType = ReadPageScanActivityCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadPageScanActivityCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadPageScanActivityPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadPageScanActivityPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let read_page_scan_activity = match &discovery_command.child {DiscoveryCommandDataChild::ReadPageScanActivity(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadPageScanActivity"),};Self {command,discovery_command,read_page_scan_activity,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadPageScanActivityPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for ReadPageScanActivityPacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for ReadPageScanActivityBuilder { type ResponseType = ReadPageScanActivityCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadPageScanActivityCompletePacket::new(pkt.event.clone()) }}impl ReadPageScanActivityBuilder {pub fn build(self) -> ReadPageScanActivityPacket {let read_page_scan_activity= Arc::new(ReadPageScanActivityData {});let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::ReadPageScanActivity(read_page_scan_activity),});let command= Arc::new(CommandData {op_code: OpCode::ReadPageScanActivity, child: CommandDataChild::DiscoveryCommand(discovery_command),});ReadPageScanActivityPacket::new(command)}
}
impl Into<CommandPacket> for ReadPageScanActivityBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for ReadPageScanActivityBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadPageScanActivityCompleteData {status: ErrorCode, page_scan_interval: u16, page_scan_window: u16, }
#[derive(Debug, Clone)] pub struct ReadPageScanActivityCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_page_scan_activity_complete: Arc<ReadPageScanActivityCompleteData>,}
#[derive(Debug)] pub struct ReadPageScanActivityCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub page_scan_interval: u16, pub page_scan_window: u16, }
impl ReadPageScanActivityCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadPageScanActivityComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadPageScanActivityComplete".to_string(),    field: "page_scan_interval".to_string(),    wanted: 8,    got: bytes.len()});}let page_scan_interval = u16::from_le_bytes([bytes[6],bytes[7]]);if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "ReadPageScanActivityComplete".to_string(),    field: "page_scan_window".to_string(),    wanted: 10,    got: bytes.len()});}let page_scan_window = u16::from_le_bytes([bytes[8],bytes[9]]);Ok(Self {status, page_scan_interval, page_scan_window, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let page_scan_interval = self.page_scan_interval;buffer[6..8].copy_from_slice(&page_scan_interval.to_le_bytes()[0..2]);let page_scan_window = self.page_scan_window;buffer[8..10].copy_from_slice(&page_scan_window.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 5;ret}
}
impl Packet for ReadPageScanActivityCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadPageScanActivityCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_page_scan_activity_complete = match &command_complete.child {CommandCompleteDataChild::ReadPageScanActivityComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadPageScanActivityComplete"),};Self {event,command_complete,read_page_scan_activity_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_page_scan_activity_complete.as_ref().status}
pub fn get_page_scan_interval(&self) -> u16{ self.read_page_scan_activity_complete.as_ref().page_scan_interval}
pub fn get_page_scan_window(&self) -> u16{ self.read_page_scan_activity_complete.as_ref().page_scan_window}
}
impl Into<EventPacket> for ReadPageScanActivityCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadPageScanActivityCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadPageScanActivityCompleteBuilder {pub fn build(self) -> ReadPageScanActivityCompletePacket {let read_page_scan_activity_complete= Arc::new(ReadPageScanActivityCompleteData {status: self.status, page_scan_interval: self.page_scan_interval, page_scan_window: self.page_scan_window, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadPageScanActivity, child: CommandCompleteDataChild::ReadPageScanActivityComplete(read_page_scan_activity_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadPageScanActivityCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadPageScanActivityCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadPageScanActivityCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WritePageScanActivityData {page_scan_interval: u16, page_scan_window: u16, }
#[derive(Debug, Clone)] pub struct WritePageScanActivityPacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,write_page_scan_activity: Arc<WritePageScanActivityData>,}
#[derive(Debug)] pub struct WritePageScanActivityBuilder {pub page_scan_interval: u16, pub page_scan_window: u16, }
impl WritePageScanActivityData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "WritePageScanActivity".to_string(),    field: "page_scan_interval".to_string(),    wanted: 5,    got: bytes.len()});}let page_scan_interval = u16::from_le_bytes([bytes[3],bytes[4]]);if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "WritePageScanActivity".to_string(),    field: "page_scan_window".to_string(),    wanted: 7,    got: bytes.len()});}let page_scan_window = u16::from_le_bytes([bytes[5],bytes[6]]);Ok(Self {page_scan_interval, page_scan_window, })
}
fn write_to(&self, buffer: &mut BytesMut) {let page_scan_interval = self.page_scan_interval;buffer[3..5].copy_from_slice(&page_scan_interval.to_le_bytes()[0..2]);let page_scan_window = self.page_scan_window;buffer[5..7].copy_from_slice(&page_scan_window.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl CommandExpectations for WritePageScanActivityPacket { type ResponseType = WritePageScanActivityCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WritePageScanActivityCompletePacket::new(pkt.event.clone()) }}impl Packet for WritePageScanActivityPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WritePageScanActivityPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let write_page_scan_activity = match &discovery_command.child {DiscoveryCommandDataChild::WritePageScanActivity(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WritePageScanActivity"),};Self {command,discovery_command,write_page_scan_activity,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_page_scan_interval(&self) -> u16{ self.write_page_scan_activity.as_ref().page_scan_interval}
pub fn get_page_scan_window(&self) -> u16{ self.write_page_scan_activity.as_ref().page_scan_window}
}
impl Into<CommandPacket> for WritePageScanActivityPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for WritePageScanActivityPacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for WritePageScanActivityBuilder { type ResponseType = WritePageScanActivityCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WritePageScanActivityCompletePacket::new(pkt.event.clone()) }}impl WritePageScanActivityBuilder {pub fn build(self) -> WritePageScanActivityPacket {let write_page_scan_activity= Arc::new(WritePageScanActivityData {page_scan_interval: self.page_scan_interval, page_scan_window: self.page_scan_window, });let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::WritePageScanActivity(write_page_scan_activity),});let command= Arc::new(CommandData {op_code: OpCode::WritePageScanActivity, child: CommandDataChild::DiscoveryCommand(discovery_command),});WritePageScanActivityPacket::new(command)}
}
impl Into<CommandPacket> for WritePageScanActivityBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for WritePageScanActivityBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}


#[derive(Debug)] struct WritePageScanActivityCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WritePageScanActivityCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_page_scan_activity_complete: Arc<WritePageScanActivityCompleteData>,}
#[derive(Debug)] pub struct WritePageScanActivityCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WritePageScanActivityCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WritePageScanActivityComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WritePageScanActivityCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WritePageScanActivityCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_page_scan_activity_complete = match &command_complete.child {CommandCompleteDataChild::WritePageScanActivityComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WritePageScanActivityComplete"),};Self {event,command_complete,write_page_scan_activity_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_page_scan_activity_complete.as_ref().status}
}
impl Into<EventPacket> for WritePageScanActivityCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WritePageScanActivityCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WritePageScanActivityCompleteBuilder {pub fn build(self) -> WritePageScanActivityCompletePacket {let write_page_scan_activity_complete= Arc::new(WritePageScanActivityCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WritePageScanActivity, child: CommandCompleteDataChild::WritePageScanActivityComplete(write_page_scan_activity_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WritePageScanActivityCompletePacket::new(event)}
}
impl Into<EventPacket> for WritePageScanActivityCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WritePageScanActivityCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadInquiryScanActivityData {}
#[derive(Debug, Clone)] pub struct ReadInquiryScanActivityPacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,read_inquiry_scan_activity: Arc<ReadInquiryScanActivityData>,}
#[derive(Debug)] pub struct ReadInquiryScanActivityBuilder {}
impl ReadInquiryScanActivityData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadInquiryScanActivityPacket { type ResponseType = ReadInquiryScanActivityCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadInquiryScanActivityCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadInquiryScanActivityPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadInquiryScanActivityPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let read_inquiry_scan_activity = match &discovery_command.child {DiscoveryCommandDataChild::ReadInquiryScanActivity(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadInquiryScanActivity"),};Self {command,discovery_command,read_inquiry_scan_activity,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadInquiryScanActivityPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for ReadInquiryScanActivityPacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for ReadInquiryScanActivityBuilder { type ResponseType = ReadInquiryScanActivityCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadInquiryScanActivityCompletePacket::new(pkt.event.clone()) }}impl ReadInquiryScanActivityBuilder {pub fn build(self) -> ReadInquiryScanActivityPacket {let read_inquiry_scan_activity= Arc::new(ReadInquiryScanActivityData {});let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::ReadInquiryScanActivity(read_inquiry_scan_activity),});let command= Arc::new(CommandData {op_code: OpCode::ReadInquiryScanActivity, child: CommandDataChild::DiscoveryCommand(discovery_command),});ReadInquiryScanActivityPacket::new(command)}
}
impl Into<CommandPacket> for ReadInquiryScanActivityBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for ReadInquiryScanActivityBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}
macro_rules! read_inquiry_scan_activity_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::DiscoveryCommand(discovery_command_packet) => {match discovery_command_packet.specialize() {/* (2) */
DiscoveryCommandChild::ReadInquiryScanActivity(packet) => {let rebuilder = ReadInquiryScanActivityBuilder {};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse read_inquiry_scan_activity{:02x?}", discovery_command_packet); }}}_ => {println!("Couldn't parse discovery_command{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}read_inquiry_scan_activity_builder_tests! { read_inquiry_scan_activity_builder_test_00: b"\x1d\x0c\x00",}


#[derive(Debug)] struct ReadInquiryScanActivityCompleteData {status: ErrorCode, inquiry_scan_interval: u16, inquiry_scan_window: u16, }
#[derive(Debug, Clone)] pub struct ReadInquiryScanActivityCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_inquiry_scan_activity_complete: Arc<ReadInquiryScanActivityCompleteData>,}
#[derive(Debug)] pub struct ReadInquiryScanActivityCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub inquiry_scan_interval: u16, pub inquiry_scan_window: u16, }
impl ReadInquiryScanActivityCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadInquiryScanActivityComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadInquiryScanActivityComplete".to_string(),    field: "inquiry_scan_interval".to_string(),    wanted: 8,    got: bytes.len()});}let inquiry_scan_interval = u16::from_le_bytes([bytes[6],bytes[7]]);if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "ReadInquiryScanActivityComplete".to_string(),    field: "inquiry_scan_window".to_string(),    wanted: 10,    got: bytes.len()});}let inquiry_scan_window = u16::from_le_bytes([bytes[8],bytes[9]]);Ok(Self {status, inquiry_scan_interval, inquiry_scan_window, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let inquiry_scan_interval = self.inquiry_scan_interval;buffer[6..8].copy_from_slice(&inquiry_scan_interval.to_le_bytes()[0..2]);let inquiry_scan_window = self.inquiry_scan_window;buffer[8..10].copy_from_slice(&inquiry_scan_window.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 5;ret}
}
impl Packet for ReadInquiryScanActivityCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadInquiryScanActivityCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_inquiry_scan_activity_complete = match &command_complete.child {CommandCompleteDataChild::ReadInquiryScanActivityComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadInquiryScanActivityComplete"),};Self {event,command_complete,read_inquiry_scan_activity_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_inquiry_scan_activity_complete.as_ref().status}
pub fn get_inquiry_scan_interval(&self) -> u16{ self.read_inquiry_scan_activity_complete.as_ref().inquiry_scan_interval}
pub fn get_inquiry_scan_window(&self) -> u16{ self.read_inquiry_scan_activity_complete.as_ref().inquiry_scan_window}
}
impl Into<EventPacket> for ReadInquiryScanActivityCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadInquiryScanActivityCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadInquiryScanActivityCompleteBuilder {pub fn build(self) -> ReadInquiryScanActivityCompletePacket {let read_inquiry_scan_activity_complete= Arc::new(ReadInquiryScanActivityCompleteData {status: self.status, inquiry_scan_interval: self.inquiry_scan_interval, inquiry_scan_window: self.inquiry_scan_window, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadInquiryScanActivity, child: CommandCompleteDataChild::ReadInquiryScanActivityComplete(read_inquiry_scan_activity_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadInquiryScanActivityCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadInquiryScanActivityCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadInquiryScanActivityCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! read_inquiry_scan_activity_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::ReadInquiryScanActivityComplete(packet) => {let rebuilder = ReadInquiryScanActivityCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),inquiry_scan_interval : packet.get_inquiry_scan_interval(),inquiry_scan_window : packet.get_inquiry_scan_window(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse read_inquiry_scan_activity_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}read_inquiry_scan_activity_complete_builder_tests! { read_inquiry_scan_activity_complete_builder_test_00: b"\x0e\x08\x01\x1d\x0c\x00\xaa\xbb\xcc\xdd",}


#[derive(Debug)] struct WriteInquiryScanActivityData {inquiry_scan_interval: u16, inquiry_scan_window: u16, }
#[derive(Debug, Clone)] pub struct WriteInquiryScanActivityPacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,write_inquiry_scan_activity: Arc<WriteInquiryScanActivityData>,}
#[derive(Debug)] pub struct WriteInquiryScanActivityBuilder {pub inquiry_scan_interval: u16, pub inquiry_scan_window: u16, }
impl WriteInquiryScanActivityData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "WriteInquiryScanActivity".to_string(),    field: "inquiry_scan_interval".to_string(),    wanted: 5,    got: bytes.len()});}let inquiry_scan_interval = u16::from_le_bytes([bytes[3],bytes[4]]);if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "WriteInquiryScanActivity".to_string(),    field: "inquiry_scan_window".to_string(),    wanted: 7,    got: bytes.len()});}let inquiry_scan_window = u16::from_le_bytes([bytes[5],bytes[6]]);Ok(Self {inquiry_scan_interval, inquiry_scan_window, })
}
fn write_to(&self, buffer: &mut BytesMut) {let inquiry_scan_interval = self.inquiry_scan_interval;buffer[3..5].copy_from_slice(&inquiry_scan_interval.to_le_bytes()[0..2]);let inquiry_scan_window = self.inquiry_scan_window;buffer[5..7].copy_from_slice(&inquiry_scan_window.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl CommandExpectations for WriteInquiryScanActivityPacket { type ResponseType = WriteInquiryScanActivityCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteInquiryScanActivityCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteInquiryScanActivityPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteInquiryScanActivityPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let write_inquiry_scan_activity = match &discovery_command.child {DiscoveryCommandDataChild::WriteInquiryScanActivity(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteInquiryScanActivity"),};Self {command,discovery_command,write_inquiry_scan_activity,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_inquiry_scan_interval(&self) -> u16{ self.write_inquiry_scan_activity.as_ref().inquiry_scan_interval}
pub fn get_inquiry_scan_window(&self) -> u16{ self.write_inquiry_scan_activity.as_ref().inquiry_scan_window}
}
impl Into<CommandPacket> for WriteInquiryScanActivityPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for WriteInquiryScanActivityPacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for WriteInquiryScanActivityBuilder { type ResponseType = WriteInquiryScanActivityCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteInquiryScanActivityCompletePacket::new(pkt.event.clone()) }}impl WriteInquiryScanActivityBuilder {pub fn build(self) -> WriteInquiryScanActivityPacket {let write_inquiry_scan_activity= Arc::new(WriteInquiryScanActivityData {inquiry_scan_interval: self.inquiry_scan_interval, inquiry_scan_window: self.inquiry_scan_window, });let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::WriteInquiryScanActivity(write_inquiry_scan_activity),});let command= Arc::new(CommandData {op_code: OpCode::WriteInquiryScanActivity, child: CommandDataChild::DiscoveryCommand(discovery_command),});WriteInquiryScanActivityPacket::new(command)}
}
impl Into<CommandPacket> for WriteInquiryScanActivityBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for WriteInquiryScanActivityBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}
macro_rules! write_inquiry_scan_activity_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::DiscoveryCommand(discovery_command_packet) => {match discovery_command_packet.specialize() {/* (2) */
DiscoveryCommandChild::WriteInquiryScanActivity(packet) => {let rebuilder = WriteInquiryScanActivityBuilder {inquiry_scan_interval : packet.get_inquiry_scan_interval(),inquiry_scan_window : packet.get_inquiry_scan_window(),};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse write_inquiry_scan_activity{:02x?}", discovery_command_packet); }}}_ => {println!("Couldn't parse discovery_command{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}write_inquiry_scan_activity_builder_tests! { write_inquiry_scan_activity_builder_test_00: b"\x1e\x0c\x04\x00\x08\x12\x00",}


#[derive(Debug)] struct WriteInquiryScanActivityCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WriteInquiryScanActivityCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_inquiry_scan_activity_complete: Arc<WriteInquiryScanActivityCompleteData>,}
#[derive(Debug)] pub struct WriteInquiryScanActivityCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WriteInquiryScanActivityCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteInquiryScanActivityComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WriteInquiryScanActivityCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteInquiryScanActivityCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_inquiry_scan_activity_complete = match &command_complete.child {CommandCompleteDataChild::WriteInquiryScanActivityComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteInquiryScanActivityComplete"),};Self {event,command_complete,write_inquiry_scan_activity_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_inquiry_scan_activity_complete.as_ref().status}
}
impl Into<EventPacket> for WriteInquiryScanActivityCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteInquiryScanActivityCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteInquiryScanActivityCompleteBuilder {pub fn build(self) -> WriteInquiryScanActivityCompletePacket {let write_inquiry_scan_activity_complete= Arc::new(WriteInquiryScanActivityCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteInquiryScanActivity, child: CommandCompleteDataChild::WriteInquiryScanActivityComplete(write_inquiry_scan_activity_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteInquiryScanActivityCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteInquiryScanActivityCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteInquiryScanActivityCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! write_inquiry_scan_activity_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::WriteInquiryScanActivityComplete(packet) => {let rebuilder = WriteInquiryScanActivityCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse write_inquiry_scan_activity_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}write_inquiry_scan_activity_complete_builder_tests! { write_inquiry_scan_activity_complete_builder_test_00: b"\x0e\x04\x01\x1e\x0c\x00",}


#[derive(Debug)] struct ReadAuthenticationEnableData {}
#[derive(Debug, Clone)] pub struct ReadAuthenticationEnablePacket {command: Arc<CommandData>,read_authentication_enable: Arc<ReadAuthenticationEnableData>,}
#[derive(Debug)] pub struct ReadAuthenticationEnableBuilder {}
impl ReadAuthenticationEnableData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadAuthenticationEnablePacket { type ResponseType = ReadAuthenticationEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadAuthenticationEnableCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadAuthenticationEnablePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadAuthenticationEnablePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let read_authentication_enable = match &command.child {CommandDataChild::ReadAuthenticationEnable(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadAuthenticationEnable"),};Self {command,read_authentication_enable,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadAuthenticationEnablePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for ReadAuthenticationEnableBuilder { type ResponseType = ReadAuthenticationEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadAuthenticationEnableCompletePacket::new(pkt.event.clone()) }}impl ReadAuthenticationEnableBuilder {pub fn build(self) -> ReadAuthenticationEnablePacket {let read_authentication_enable= Arc::new(ReadAuthenticationEnableData {});let command= Arc::new(CommandData {op_code: OpCode::ReadAuthenticationEnable, child: CommandDataChild::ReadAuthenticationEnable(read_authentication_enable),});ReadAuthenticationEnablePacket::new(command)}
}
impl Into<CommandPacket> for ReadAuthenticationEnableBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadAuthenticationEnableCompleteData {status: ErrorCode, authentication_enable: AuthenticationEnable, }
#[derive(Debug, Clone)] pub struct ReadAuthenticationEnableCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_authentication_enable_complete: Arc<ReadAuthenticationEnableCompleteData>,}
#[derive(Debug)] pub struct ReadAuthenticationEnableCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub authentication_enable: AuthenticationEnable, }
impl ReadAuthenticationEnableCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadAuthenticationEnableComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ReadAuthenticationEnableComplete".to_string(),    field: "authentication_enable".to_string(),    wanted: 7,    got: bytes.len()});}let authentication_enable = u8::from_le_bytes([bytes[6]]);let authentication_enable = AuthenticationEnable::from_u8(authentication_enable).unwrap();Ok(Self {status, authentication_enable, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let authentication_enable = self.authentication_enable.to_u8().unwrap();buffer[6..7].copy_from_slice(&authentication_enable.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for ReadAuthenticationEnableCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadAuthenticationEnableCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_authentication_enable_complete = match &command_complete.child {CommandCompleteDataChild::ReadAuthenticationEnableComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadAuthenticationEnableComplete"),};Self {event,command_complete,read_authentication_enable_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_authentication_enable_complete.as_ref().status}
pub fn get_authentication_enable(&self) -> AuthenticationEnable{ self.read_authentication_enable_complete.as_ref().authentication_enable}
}
impl Into<EventPacket> for ReadAuthenticationEnableCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadAuthenticationEnableCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadAuthenticationEnableCompleteBuilder {pub fn build(self) -> ReadAuthenticationEnableCompletePacket {let read_authentication_enable_complete= Arc::new(ReadAuthenticationEnableCompleteData {status: self.status, authentication_enable: self.authentication_enable, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadAuthenticationEnable, child: CommandCompleteDataChild::ReadAuthenticationEnableComplete(read_authentication_enable_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadAuthenticationEnableCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadAuthenticationEnableCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadAuthenticationEnableCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WriteAuthenticationEnableData {authentication_enable: AuthenticationEnable, }
#[derive(Debug, Clone)] pub struct WriteAuthenticationEnablePacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,write_authentication_enable: Arc<WriteAuthenticationEnableData>,}
#[derive(Debug)] pub struct WriteAuthenticationEnableBuilder {pub authentication_enable: AuthenticationEnable, }
impl WriteAuthenticationEnableData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "WriteAuthenticationEnable".to_string(),    field: "authentication_enable".to_string(),    wanted: 4,    got: bytes.len()});}let authentication_enable = u8::from_le_bytes([bytes[3]]);let authentication_enable = AuthenticationEnable::from_u8(authentication_enable).unwrap();Ok(Self {authentication_enable, })
}
fn write_to(&self, buffer: &mut BytesMut) {let authentication_enable = self.authentication_enable.to_u8().unwrap();buffer[3..4].copy_from_slice(&authentication_enable.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for WriteAuthenticationEnablePacket { type ResponseType = WriteAuthenticationEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteAuthenticationEnableCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteAuthenticationEnablePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteAuthenticationEnablePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let write_authentication_enable = match &security_command.child {SecurityCommandDataChild::WriteAuthenticationEnable(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteAuthenticationEnable"),};Self {command,security_command,write_authentication_enable,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_authentication_enable(&self) -> AuthenticationEnable{ self.write_authentication_enable.as_ref().authentication_enable}
}
impl Into<CommandPacket> for WriteAuthenticationEnablePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for WriteAuthenticationEnablePacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for WriteAuthenticationEnableBuilder { type ResponseType = WriteAuthenticationEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteAuthenticationEnableCompletePacket::new(pkt.event.clone()) }}impl WriteAuthenticationEnableBuilder {pub fn build(self) -> WriteAuthenticationEnablePacket {let write_authentication_enable= Arc::new(WriteAuthenticationEnableData {authentication_enable: self.authentication_enable, });let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::WriteAuthenticationEnable(write_authentication_enable),});let command= Arc::new(CommandData {op_code: OpCode::WriteAuthenticationEnable, child: CommandDataChild::SecurityCommand(security_command),});WriteAuthenticationEnablePacket::new(command)}
}
impl Into<CommandPacket> for WriteAuthenticationEnableBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for WriteAuthenticationEnableBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct WriteAuthenticationEnableCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WriteAuthenticationEnableCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_authentication_enable_complete: Arc<WriteAuthenticationEnableCompleteData>,}
#[derive(Debug)] pub struct WriteAuthenticationEnableCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WriteAuthenticationEnableCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteAuthenticationEnableComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WriteAuthenticationEnableCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteAuthenticationEnableCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_authentication_enable_complete = match &command_complete.child {CommandCompleteDataChild::WriteAuthenticationEnableComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteAuthenticationEnableComplete"),};Self {event,command_complete,write_authentication_enable_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_authentication_enable_complete.as_ref().status}
}
impl Into<EventPacket> for WriteAuthenticationEnableCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteAuthenticationEnableCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteAuthenticationEnableCompleteBuilder {pub fn build(self) -> WriteAuthenticationEnableCompletePacket {let write_authentication_enable_complete= Arc::new(WriteAuthenticationEnableCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteAuthenticationEnable, child: CommandCompleteDataChild::WriteAuthenticationEnableComplete(write_authentication_enable_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteAuthenticationEnableCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteAuthenticationEnableCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteAuthenticationEnableCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadClassOfDeviceData {}
#[derive(Debug, Clone)] pub struct ReadClassOfDevicePacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,read_class_of_device: Arc<ReadClassOfDeviceData>,}
#[derive(Debug)] pub struct ReadClassOfDeviceBuilder {}
impl ReadClassOfDeviceData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadClassOfDevicePacket { type ResponseType = ReadClassOfDeviceCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadClassOfDeviceCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadClassOfDevicePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadClassOfDevicePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let read_class_of_device = match &discovery_command.child {DiscoveryCommandDataChild::ReadClassOfDevice(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadClassOfDevice"),};Self {command,discovery_command,read_class_of_device,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadClassOfDevicePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for ReadClassOfDevicePacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for ReadClassOfDeviceBuilder { type ResponseType = ReadClassOfDeviceCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadClassOfDeviceCompletePacket::new(pkt.event.clone()) }}impl ReadClassOfDeviceBuilder {pub fn build(self) -> ReadClassOfDevicePacket {let read_class_of_device= Arc::new(ReadClassOfDeviceData {});let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::ReadClassOfDevice(read_class_of_device),});let command= Arc::new(CommandData {op_code: OpCode::ReadClassOfDevice, child: CommandDataChild::DiscoveryCommand(discovery_command),});ReadClassOfDevicePacket::new(command)}
}
impl Into<CommandPacket> for ReadClassOfDeviceBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for ReadClassOfDeviceBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadClassOfDeviceCompleteData {status: ErrorCode, class_of_device: ClassOfDevice, }
#[derive(Debug, Clone)] pub struct ReadClassOfDeviceCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_class_of_device_complete: Arc<ReadClassOfDeviceCompleteData>,}
#[derive(Debug)] pub struct ReadClassOfDeviceCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub class_of_device: ClassOfDevice, }
impl ReadClassOfDeviceCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadClassOfDeviceComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "ReadClassOfDeviceComplete".to_string(),    field: "class_of_device".to_string(),    wanted: 9,    got: bytes.len()});}let class_of_device = bytes[6..9].try_into().unwrap();Ok(Self {status, class_of_device, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let class_of_device: [u8; 3] = self.class_of_device.into();buffer[6..9].copy_from_slice(&class_of_device);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl Packet for ReadClassOfDeviceCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadClassOfDeviceCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_class_of_device_complete = match &command_complete.child {CommandCompleteDataChild::ReadClassOfDeviceComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadClassOfDeviceComplete"),};Self {event,command_complete,read_class_of_device_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_class_of_device_complete.as_ref().status}
pub fn get_class_of_device(&self) -> ClassOfDevice{ self.read_class_of_device_complete.as_ref().class_of_device}
}
impl Into<EventPacket> for ReadClassOfDeviceCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadClassOfDeviceCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadClassOfDeviceCompleteBuilder {pub fn build(self) -> ReadClassOfDeviceCompletePacket {let read_class_of_device_complete= Arc::new(ReadClassOfDeviceCompleteData {status: self.status, class_of_device: self.class_of_device, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadClassOfDevice, child: CommandCompleteDataChild::ReadClassOfDeviceComplete(read_class_of_device_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadClassOfDeviceCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadClassOfDeviceCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadClassOfDeviceCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WriteClassOfDeviceData {class_of_device: ClassOfDevice, }
#[derive(Debug, Clone)] pub struct WriteClassOfDevicePacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,write_class_of_device: Arc<WriteClassOfDeviceData>,}
#[derive(Debug)] pub struct WriteClassOfDeviceBuilder {pub class_of_device: ClassOfDevice, }
impl WriteClassOfDeviceData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteClassOfDevice".to_string(),    field: "class_of_device".to_string(),    wanted: 6,    got: bytes.len()});}let class_of_device = bytes[3..6].try_into().unwrap();Ok(Self {class_of_device, })
}
fn write_to(&self, buffer: &mut BytesMut) {let class_of_device: [u8; 3] = self.class_of_device.into();buffer[3..6].copy_from_slice(&class_of_device);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl CommandExpectations for WriteClassOfDevicePacket { type ResponseType = WriteClassOfDeviceCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteClassOfDeviceCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteClassOfDevicePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteClassOfDevicePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let write_class_of_device = match &discovery_command.child {DiscoveryCommandDataChild::WriteClassOfDevice(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteClassOfDevice"),};Self {command,discovery_command,write_class_of_device,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_class_of_device(&self) -> ClassOfDevice{ self.write_class_of_device.as_ref().class_of_device}
}
impl Into<CommandPacket> for WriteClassOfDevicePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for WriteClassOfDevicePacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for WriteClassOfDeviceBuilder { type ResponseType = WriteClassOfDeviceCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteClassOfDeviceCompletePacket::new(pkt.event.clone()) }}impl WriteClassOfDeviceBuilder {pub fn build(self) -> WriteClassOfDevicePacket {let write_class_of_device= Arc::new(WriteClassOfDeviceData {class_of_device: self.class_of_device, });let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::WriteClassOfDevice(write_class_of_device),});let command= Arc::new(CommandData {op_code: OpCode::WriteClassOfDevice, child: CommandDataChild::DiscoveryCommand(discovery_command),});WriteClassOfDevicePacket::new(command)}
}
impl Into<CommandPacket> for WriteClassOfDeviceBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for WriteClassOfDeviceBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}


#[derive(Debug)] struct WriteClassOfDeviceCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WriteClassOfDeviceCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_class_of_device_complete: Arc<WriteClassOfDeviceCompleteData>,}
#[derive(Debug)] pub struct WriteClassOfDeviceCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WriteClassOfDeviceCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteClassOfDeviceComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WriteClassOfDeviceCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteClassOfDeviceCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_class_of_device_complete = match &command_complete.child {CommandCompleteDataChild::WriteClassOfDeviceComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteClassOfDeviceComplete"),};Self {event,command_complete,write_class_of_device_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_class_of_device_complete.as_ref().status}
}
impl Into<EventPacket> for WriteClassOfDeviceCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteClassOfDeviceCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteClassOfDeviceCompleteBuilder {pub fn build(self) -> WriteClassOfDeviceCompletePacket {let write_class_of_device_complete= Arc::new(WriteClassOfDeviceCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteClassOfDevice, child: CommandCompleteDataChild::WriteClassOfDeviceComplete(write_class_of_device_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteClassOfDeviceCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteClassOfDeviceCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteClassOfDeviceCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadVoiceSettingData {}
#[derive(Debug, Clone)] pub struct ReadVoiceSettingPacket {command: Arc<CommandData>,read_voice_setting: Arc<ReadVoiceSettingData>,}
#[derive(Debug)] pub struct ReadVoiceSettingBuilder {}
impl ReadVoiceSettingData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadVoiceSettingPacket { type ResponseType = ReadVoiceSettingCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadVoiceSettingCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadVoiceSettingPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadVoiceSettingPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let read_voice_setting = match &command.child {CommandDataChild::ReadVoiceSetting(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadVoiceSetting"),};Self {command,read_voice_setting,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadVoiceSettingPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for ReadVoiceSettingBuilder { type ResponseType = ReadVoiceSettingCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadVoiceSettingCompletePacket::new(pkt.event.clone()) }}impl ReadVoiceSettingBuilder {pub fn build(self) -> ReadVoiceSettingPacket {let read_voice_setting= Arc::new(ReadVoiceSettingData {});let command= Arc::new(CommandData {op_code: OpCode::ReadVoiceSetting, child: CommandDataChild::ReadVoiceSetting(read_voice_setting),});ReadVoiceSettingPacket::new(command)}
}
impl Into<CommandPacket> for ReadVoiceSettingBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadVoiceSettingCompleteData {status: ErrorCode, voice_setting: u16, }
#[derive(Debug, Clone)] pub struct ReadVoiceSettingCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_voice_setting_complete: Arc<ReadVoiceSettingCompleteData>,}
#[derive(Debug)] pub struct ReadVoiceSettingCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub voice_setting: u16, }
impl ReadVoiceSettingCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadVoiceSettingComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadVoiceSettingComplete".to_string(),    field: "voice_setting".to_string(),    wanted: 8,    got: bytes.len()});}let voice_setting = u16::from_le_bytes([bytes[6],bytes[7]]);let voice_setting = voice_setting & 0x3ff;Ok(Self {status, voice_setting, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let voice_setting = self.voice_setting;let voice_setting = voice_setting & 0x3ff;buffer[6..8].copy_from_slice(&voice_setting.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for ReadVoiceSettingCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadVoiceSettingCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_voice_setting_complete = match &command_complete.child {CommandCompleteDataChild::ReadVoiceSettingComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadVoiceSettingComplete"),};Self {event,command_complete,read_voice_setting_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_voice_setting_complete.as_ref().status}
pub fn get_voice_setting(&self) -> u16{ self.read_voice_setting_complete.as_ref().voice_setting}
}
impl Into<EventPacket> for ReadVoiceSettingCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadVoiceSettingCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadVoiceSettingCompleteBuilder {pub fn build(self) -> ReadVoiceSettingCompletePacket {let read_voice_setting_complete= Arc::new(ReadVoiceSettingCompleteData {status: self.status, voice_setting: self.voice_setting, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadVoiceSetting, child: CommandCompleteDataChild::ReadVoiceSettingComplete(read_voice_setting_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadVoiceSettingCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadVoiceSettingCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadVoiceSettingCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WriteVoiceSettingData {voice_setting: u16, }
#[derive(Debug, Clone)] pub struct WriteVoiceSettingPacket {command: Arc<CommandData>,write_voice_setting: Arc<WriteVoiceSettingData>,}
#[derive(Debug)] pub struct WriteVoiceSettingBuilder {pub voice_setting: u16, }
impl WriteVoiceSettingData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "WriteVoiceSetting".to_string(),    field: "voice_setting".to_string(),    wanted: 5,    got: bytes.len()});}let voice_setting = u16::from_le_bytes([bytes[3],bytes[4]]);let voice_setting = voice_setting & 0x3ff;Ok(Self {voice_setting, })
}
fn write_to(&self, buffer: &mut BytesMut) {let voice_setting = self.voice_setting;let voice_setting = voice_setting & 0x3ff;buffer[3..5].copy_from_slice(&voice_setting.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for WriteVoiceSettingPacket { type ResponseType = WriteVoiceSettingCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteVoiceSettingCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteVoiceSettingPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteVoiceSettingPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let write_voice_setting = match &command.child {CommandDataChild::WriteVoiceSetting(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteVoiceSetting"),};Self {command,write_voice_setting,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_voice_setting(&self) -> u16{ self.write_voice_setting.as_ref().voice_setting}
}
impl Into<CommandPacket> for WriteVoiceSettingPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for WriteVoiceSettingBuilder { type ResponseType = WriteVoiceSettingCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteVoiceSettingCompletePacket::new(pkt.event.clone()) }}impl WriteVoiceSettingBuilder {pub fn build(self) -> WriteVoiceSettingPacket {let write_voice_setting= Arc::new(WriteVoiceSettingData {voice_setting: self.voice_setting, });let command= Arc::new(CommandData {op_code: OpCode::WriteVoiceSetting, child: CommandDataChild::WriteVoiceSetting(write_voice_setting),});WriteVoiceSettingPacket::new(command)}
}
impl Into<CommandPacket> for WriteVoiceSettingBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct WriteVoiceSettingCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WriteVoiceSettingCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_voice_setting_complete: Arc<WriteVoiceSettingCompleteData>,}
#[derive(Debug)] pub struct WriteVoiceSettingCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WriteVoiceSettingCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteVoiceSettingComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WriteVoiceSettingCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteVoiceSettingCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_voice_setting_complete = match &command_complete.child {CommandCompleteDataChild::WriteVoiceSettingComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteVoiceSettingComplete"),};Self {event,command_complete,write_voice_setting_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_voice_setting_complete.as_ref().status}
}
impl Into<EventPacket> for WriteVoiceSettingCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteVoiceSettingCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteVoiceSettingCompleteBuilder {pub fn build(self) -> WriteVoiceSettingCompletePacket {let write_voice_setting_complete= Arc::new(WriteVoiceSettingCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteVoiceSetting, child: CommandCompleteDataChild::WriteVoiceSettingComplete(write_voice_setting_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteVoiceSettingCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteVoiceSettingCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteVoiceSettingCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadAutomaticFlushTimeoutData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct ReadAutomaticFlushTimeoutPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,read_automatic_flush_timeout: Arc<ReadAutomaticFlushTimeoutData>,}
#[derive(Debug)] pub struct ReadAutomaticFlushTimeoutBuilder {pub connection_handle: u16, }
impl ReadAutomaticFlushTimeoutData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ReadAutomaticFlushTimeout".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for ReadAutomaticFlushTimeoutPacket { type ResponseType = ReadAutomaticFlushTimeoutCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadAutomaticFlushTimeoutCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadAutomaticFlushTimeoutPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadAutomaticFlushTimeoutPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let read_automatic_flush_timeout = match &connection_management_command.child {ConnectionManagementCommandDataChild::ReadAutomaticFlushTimeout(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadAutomaticFlushTimeout"),};Self {command,acl_command,connection_management_command,read_automatic_flush_timeout,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.read_automatic_flush_timeout.as_ref().connection_handle}
}
impl Into<CommandPacket> for ReadAutomaticFlushTimeoutPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for ReadAutomaticFlushTimeoutPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for ReadAutomaticFlushTimeoutPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for ReadAutomaticFlushTimeoutBuilder { type ResponseType = ReadAutomaticFlushTimeoutCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadAutomaticFlushTimeoutCompletePacket::new(pkt.event.clone()) }}impl ReadAutomaticFlushTimeoutBuilder {pub fn build(self) -> ReadAutomaticFlushTimeoutPacket {let read_automatic_flush_timeout= Arc::new(ReadAutomaticFlushTimeoutData {connection_handle: self.connection_handle, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::ReadAutomaticFlushTimeout(read_automatic_flush_timeout),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::ReadAutomaticFlushTimeout, child: CommandDataChild::AclCommand(acl_command),});ReadAutomaticFlushTimeoutPacket::new(command)}
}
impl Into<CommandPacket> for ReadAutomaticFlushTimeoutBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for ReadAutomaticFlushTimeoutBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for ReadAutomaticFlushTimeoutBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadAutomaticFlushTimeoutCompleteData {status: ErrorCode, connection_handle: u16, flush_timeout: u16, }
#[derive(Debug, Clone)] pub struct ReadAutomaticFlushTimeoutCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_automatic_flush_timeout_complete: Arc<ReadAutomaticFlushTimeoutCompleteData>,}
#[derive(Debug)] pub struct ReadAutomaticFlushTimeoutCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, pub flush_timeout: u16, }
impl ReadAutomaticFlushTimeoutCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadAutomaticFlushTimeoutComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadAutomaticFlushTimeoutComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "ReadAutomaticFlushTimeoutComplete".to_string(),    field: "flush_timeout".to_string(),    wanted: 10,    got: bytes.len()});}let flush_timeout = u16::from_le_bytes([bytes[8],bytes[9]]);Ok(Self {status, connection_handle, flush_timeout, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let flush_timeout = self.flush_timeout;buffer[8..10].copy_from_slice(&flush_timeout.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 5;ret}
}
impl Packet for ReadAutomaticFlushTimeoutCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadAutomaticFlushTimeoutCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_automatic_flush_timeout_complete = match &command_complete.child {CommandCompleteDataChild::ReadAutomaticFlushTimeoutComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadAutomaticFlushTimeoutComplete"),};Self {event,command_complete,read_automatic_flush_timeout_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_automatic_flush_timeout_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.read_automatic_flush_timeout_complete.as_ref().connection_handle}
pub fn get_flush_timeout(&self) -> u16{ self.read_automatic_flush_timeout_complete.as_ref().flush_timeout}
}
impl Into<EventPacket> for ReadAutomaticFlushTimeoutCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadAutomaticFlushTimeoutCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadAutomaticFlushTimeoutCompleteBuilder {pub fn build(self) -> ReadAutomaticFlushTimeoutCompletePacket {let read_automatic_flush_timeout_complete= Arc::new(ReadAutomaticFlushTimeoutCompleteData {status: self.status, connection_handle: self.connection_handle, flush_timeout: self.flush_timeout, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadAutomaticFlushTimeout, child: CommandCompleteDataChild::ReadAutomaticFlushTimeoutComplete(read_automatic_flush_timeout_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadAutomaticFlushTimeoutCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadAutomaticFlushTimeoutCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadAutomaticFlushTimeoutCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WriteAutomaticFlushTimeoutData {connection_handle: u16, flush_timeout: u16, }
#[derive(Debug, Clone)] pub struct WriteAutomaticFlushTimeoutPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,write_automatic_flush_timeout: Arc<WriteAutomaticFlushTimeoutData>,}
#[derive(Debug)] pub struct WriteAutomaticFlushTimeoutBuilder {pub connection_handle: u16, pub flush_timeout: u16, }
impl WriteAutomaticFlushTimeoutData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "WriteAutomaticFlushTimeout".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "WriteAutomaticFlushTimeout".to_string(),    field: "flush_timeout".to_string(),    wanted: 7,    got: bytes.len()});}let flush_timeout = u16::from_le_bytes([bytes[5],bytes[6]]);Ok(Self {connection_handle, flush_timeout, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let flush_timeout = self.flush_timeout;buffer[5..7].copy_from_slice(&flush_timeout.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl CommandExpectations for WriteAutomaticFlushTimeoutPacket { type ResponseType = WriteAutomaticFlushTimeoutCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteAutomaticFlushTimeoutCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteAutomaticFlushTimeoutPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteAutomaticFlushTimeoutPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let write_automatic_flush_timeout = match &connection_management_command.child {ConnectionManagementCommandDataChild::WriteAutomaticFlushTimeout(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteAutomaticFlushTimeout"),};Self {command,acl_command,connection_management_command,write_automatic_flush_timeout,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.write_automatic_flush_timeout.as_ref().connection_handle}
pub fn get_flush_timeout(&self) -> u16{ self.write_automatic_flush_timeout.as_ref().flush_timeout}
}
impl Into<CommandPacket> for WriteAutomaticFlushTimeoutPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for WriteAutomaticFlushTimeoutPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for WriteAutomaticFlushTimeoutPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for WriteAutomaticFlushTimeoutBuilder { type ResponseType = WriteAutomaticFlushTimeoutCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteAutomaticFlushTimeoutCompletePacket::new(pkt.event.clone()) }}impl WriteAutomaticFlushTimeoutBuilder {pub fn build(self) -> WriteAutomaticFlushTimeoutPacket {let write_automatic_flush_timeout= Arc::new(WriteAutomaticFlushTimeoutData {connection_handle: self.connection_handle, flush_timeout: self.flush_timeout, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::WriteAutomaticFlushTimeout(write_automatic_flush_timeout),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::WriteAutomaticFlushTimeout, child: CommandDataChild::AclCommand(acl_command),});WriteAutomaticFlushTimeoutPacket::new(command)}
}
impl Into<CommandPacket> for WriteAutomaticFlushTimeoutBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for WriteAutomaticFlushTimeoutBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for WriteAutomaticFlushTimeoutBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct WriteAutomaticFlushTimeoutCompleteData {status: ErrorCode, connection_handle: u16, }
#[derive(Debug, Clone)] pub struct WriteAutomaticFlushTimeoutCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_automatic_flush_timeout_complete: Arc<WriteAutomaticFlushTimeoutCompleteData>,}
#[derive(Debug)] pub struct WriteAutomaticFlushTimeoutCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, }
impl WriteAutomaticFlushTimeoutCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteAutomaticFlushTimeoutComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "WriteAutomaticFlushTimeoutComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;Ok(Self {status, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for WriteAutomaticFlushTimeoutCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteAutomaticFlushTimeoutCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_automatic_flush_timeout_complete = match &command_complete.child {CommandCompleteDataChild::WriteAutomaticFlushTimeoutComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteAutomaticFlushTimeoutComplete"),};Self {event,command_complete,write_automatic_flush_timeout_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_automatic_flush_timeout_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.write_automatic_flush_timeout_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for WriteAutomaticFlushTimeoutCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteAutomaticFlushTimeoutCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteAutomaticFlushTimeoutCompleteBuilder {pub fn build(self) -> WriteAutomaticFlushTimeoutCompletePacket {let write_automatic_flush_timeout_complete= Arc::new(WriteAutomaticFlushTimeoutCompleteData {status: self.status, connection_handle: self.connection_handle, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteAutomaticFlushTimeout, child: CommandCompleteDataChild::WriteAutomaticFlushTimeoutComplete(write_automatic_flush_timeout_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteAutomaticFlushTimeoutCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteAutomaticFlushTimeoutCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteAutomaticFlushTimeoutCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadNumBroadcastRetransmitsData {}
#[derive(Debug, Clone)] pub struct ReadNumBroadcastRetransmitsPacket {command: Arc<CommandData>,read_num_broadcast_retransmits: Arc<ReadNumBroadcastRetransmitsData>,}
#[derive(Debug)] pub struct ReadNumBroadcastRetransmitsBuilder {}
impl ReadNumBroadcastRetransmitsData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadNumBroadcastRetransmitsPacket { type ResponseType = ReadNumBroadcastRetransmitsCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadNumBroadcastRetransmitsCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadNumBroadcastRetransmitsPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadNumBroadcastRetransmitsPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let read_num_broadcast_retransmits = match &command.child {CommandDataChild::ReadNumBroadcastRetransmits(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadNumBroadcastRetransmits"),};Self {command,read_num_broadcast_retransmits,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadNumBroadcastRetransmitsPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for ReadNumBroadcastRetransmitsBuilder { type ResponseType = ReadNumBroadcastRetransmitsCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadNumBroadcastRetransmitsCompletePacket::new(pkt.event.clone()) }}impl ReadNumBroadcastRetransmitsBuilder {pub fn build(self) -> ReadNumBroadcastRetransmitsPacket {let read_num_broadcast_retransmits= Arc::new(ReadNumBroadcastRetransmitsData {});let command= Arc::new(CommandData {op_code: OpCode::ReadNumBroadcastRetransmits, child: CommandDataChild::ReadNumBroadcastRetransmits(read_num_broadcast_retransmits),});ReadNumBroadcastRetransmitsPacket::new(command)}
}
impl Into<CommandPacket> for ReadNumBroadcastRetransmitsBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadNumBroadcastRetransmitsCompleteData {status: ErrorCode, num_broadcast_retransmissions: u8, }
#[derive(Debug, Clone)] pub struct ReadNumBroadcastRetransmitsCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_num_broadcast_retransmits_complete: Arc<ReadNumBroadcastRetransmitsCompleteData>,}
#[derive(Debug)] pub struct ReadNumBroadcastRetransmitsCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub num_broadcast_retransmissions: u8, }
impl ReadNumBroadcastRetransmitsCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadNumBroadcastRetransmitsComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ReadNumBroadcastRetransmitsComplete".to_string(),    field: "num_broadcast_retransmissions".to_string(),    wanted: 7,    got: bytes.len()});}let num_broadcast_retransmissions = u8::from_le_bytes([bytes[6]]);Ok(Self {status, num_broadcast_retransmissions, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let num_broadcast_retransmissions = self.num_broadcast_retransmissions;buffer[6..7].copy_from_slice(&num_broadcast_retransmissions.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for ReadNumBroadcastRetransmitsCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadNumBroadcastRetransmitsCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_num_broadcast_retransmits_complete = match &command_complete.child {CommandCompleteDataChild::ReadNumBroadcastRetransmitsComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadNumBroadcastRetransmitsComplete"),};Self {event,command_complete,read_num_broadcast_retransmits_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_num_broadcast_retransmits_complete.as_ref().status}
pub fn get_num_broadcast_retransmissions(&self) -> u8{ self.read_num_broadcast_retransmits_complete.as_ref().num_broadcast_retransmissions}
}
impl Into<EventPacket> for ReadNumBroadcastRetransmitsCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadNumBroadcastRetransmitsCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadNumBroadcastRetransmitsCompleteBuilder {pub fn build(self) -> ReadNumBroadcastRetransmitsCompletePacket {let read_num_broadcast_retransmits_complete= Arc::new(ReadNumBroadcastRetransmitsCompleteData {status: self.status, num_broadcast_retransmissions: self.num_broadcast_retransmissions, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadNumBroadcastRetransmits, child: CommandCompleteDataChild::ReadNumBroadcastRetransmitsComplete(read_num_broadcast_retransmits_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadNumBroadcastRetransmitsCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadNumBroadcastRetransmitsCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadNumBroadcastRetransmitsCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WriteNumBroadcastRetransmitsData {num_broadcast_retransmissions: u8, }
#[derive(Debug, Clone)] pub struct WriteNumBroadcastRetransmitsPacket {command: Arc<CommandData>,write_num_broadcast_retransmits: Arc<WriteNumBroadcastRetransmitsData>,}
#[derive(Debug)] pub struct WriteNumBroadcastRetransmitsBuilder {pub num_broadcast_retransmissions: u8, }
impl WriteNumBroadcastRetransmitsData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "WriteNumBroadcastRetransmits".to_string(),    field: "num_broadcast_retransmissions".to_string(),    wanted: 4,    got: bytes.len()});}let num_broadcast_retransmissions = u8::from_le_bytes([bytes[3]]);Ok(Self {num_broadcast_retransmissions, })
}
fn write_to(&self, buffer: &mut BytesMut) {let num_broadcast_retransmissions = self.num_broadcast_retransmissions;buffer[3..4].copy_from_slice(&num_broadcast_retransmissions.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for WriteNumBroadcastRetransmitsPacket { type ResponseType = WriteNumBroadcastRetransmitsCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteNumBroadcastRetransmitsCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteNumBroadcastRetransmitsPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteNumBroadcastRetransmitsPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let write_num_broadcast_retransmits = match &command.child {CommandDataChild::WriteNumBroadcastRetransmits(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteNumBroadcastRetransmits"),};Self {command,write_num_broadcast_retransmits,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_num_broadcast_retransmissions(&self) -> u8{ self.write_num_broadcast_retransmits.as_ref().num_broadcast_retransmissions}
}
impl Into<CommandPacket> for WriteNumBroadcastRetransmitsPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for WriteNumBroadcastRetransmitsBuilder { type ResponseType = WriteNumBroadcastRetransmitsCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteNumBroadcastRetransmitsCompletePacket::new(pkt.event.clone()) }}impl WriteNumBroadcastRetransmitsBuilder {pub fn build(self) -> WriteNumBroadcastRetransmitsPacket {let write_num_broadcast_retransmits= Arc::new(WriteNumBroadcastRetransmitsData {num_broadcast_retransmissions: self.num_broadcast_retransmissions, });let command= Arc::new(CommandData {op_code: OpCode::WriteNumBroadcastRetransmits, child: CommandDataChild::WriteNumBroadcastRetransmits(write_num_broadcast_retransmits),});WriteNumBroadcastRetransmitsPacket::new(command)}
}
impl Into<CommandPacket> for WriteNumBroadcastRetransmitsBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct WriteNumBroadcastRetransmitsCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WriteNumBroadcastRetransmitsCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_num_broadcast_retransmits_complete: Arc<WriteNumBroadcastRetransmitsCompleteData>,}
#[derive(Debug)] pub struct WriteNumBroadcastRetransmitsCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WriteNumBroadcastRetransmitsCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteNumBroadcastRetransmitsComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WriteNumBroadcastRetransmitsCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteNumBroadcastRetransmitsCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_num_broadcast_retransmits_complete = match &command_complete.child {CommandCompleteDataChild::WriteNumBroadcastRetransmitsComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteNumBroadcastRetransmitsComplete"),};Self {event,command_complete,write_num_broadcast_retransmits_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_num_broadcast_retransmits_complete.as_ref().status}
}
impl Into<EventPacket> for WriteNumBroadcastRetransmitsCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteNumBroadcastRetransmitsCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteNumBroadcastRetransmitsCompleteBuilder {pub fn build(self) -> WriteNumBroadcastRetransmitsCompletePacket {let write_num_broadcast_retransmits_complete= Arc::new(WriteNumBroadcastRetransmitsCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteNumBroadcastRetransmits, child: CommandCompleteDataChild::WriteNumBroadcastRetransmitsComplete(write_num_broadcast_retransmits_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteNumBroadcastRetransmitsCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteNumBroadcastRetransmitsCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteNumBroadcastRetransmitsCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadHoldModeActivityData {}
#[derive(Debug, Clone)] pub struct ReadHoldModeActivityPacket {command: Arc<CommandData>,read_hold_mode_activity: Arc<ReadHoldModeActivityData>,}
#[derive(Debug)] pub struct ReadHoldModeActivityBuilder {}
impl ReadHoldModeActivityData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadHoldModeActivityPacket { type ResponseType = ReadHoldModeActivityCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadHoldModeActivityCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadHoldModeActivityPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadHoldModeActivityPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let read_hold_mode_activity = match &command.child {CommandDataChild::ReadHoldModeActivity(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadHoldModeActivity"),};Self {command,read_hold_mode_activity,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadHoldModeActivityPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for ReadHoldModeActivityBuilder { type ResponseType = ReadHoldModeActivityCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadHoldModeActivityCompletePacket::new(pkt.event.clone()) }}impl ReadHoldModeActivityBuilder {pub fn build(self) -> ReadHoldModeActivityPacket {let read_hold_mode_activity= Arc::new(ReadHoldModeActivityData {});let command= Arc::new(CommandData {op_code: OpCode::ReadHoldModeActivity, child: CommandDataChild::ReadHoldModeActivity(read_hold_mode_activity),});ReadHoldModeActivityPacket::new(command)}
}
impl Into<CommandPacket> for ReadHoldModeActivityBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadHoldModeActivityCompleteData {status: ErrorCode, hold_mode_activity: HoldModeActivity, }
#[derive(Debug, Clone)] pub struct ReadHoldModeActivityCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_hold_mode_activity_complete: Arc<ReadHoldModeActivityCompleteData>,}
#[derive(Debug)] pub struct ReadHoldModeActivityCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub hold_mode_activity: HoldModeActivity, }
impl ReadHoldModeActivityCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadHoldModeActivityComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ReadHoldModeActivityComplete".to_string(),    field: "hold_mode_activity".to_string(),    wanted: 7,    got: bytes.len()});}let hold_mode_activity = u8::from_le_bytes([bytes[6]]);let hold_mode_activity = HoldModeActivity::from_u8(hold_mode_activity).unwrap();Ok(Self {status, hold_mode_activity, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let hold_mode_activity = self.hold_mode_activity.to_u8().unwrap();buffer[6..7].copy_from_slice(&hold_mode_activity.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for ReadHoldModeActivityCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadHoldModeActivityCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_hold_mode_activity_complete = match &command_complete.child {CommandCompleteDataChild::ReadHoldModeActivityComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadHoldModeActivityComplete"),};Self {event,command_complete,read_hold_mode_activity_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_hold_mode_activity_complete.as_ref().status}
pub fn get_hold_mode_activity(&self) -> HoldModeActivity{ self.read_hold_mode_activity_complete.as_ref().hold_mode_activity}
}
impl Into<EventPacket> for ReadHoldModeActivityCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadHoldModeActivityCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadHoldModeActivityCompleteBuilder {pub fn build(self) -> ReadHoldModeActivityCompletePacket {let read_hold_mode_activity_complete= Arc::new(ReadHoldModeActivityCompleteData {status: self.status, hold_mode_activity: self.hold_mode_activity, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadHoldModeActivity, child: CommandCompleteDataChild::ReadHoldModeActivityComplete(read_hold_mode_activity_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadHoldModeActivityCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadHoldModeActivityCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadHoldModeActivityCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WriteHoldModeActivityData {hold_mode_activity: HoldModeActivity, }
#[derive(Debug, Clone)] pub struct WriteHoldModeActivityPacket {command: Arc<CommandData>,write_hold_mode_activity: Arc<WriteHoldModeActivityData>,}
#[derive(Debug)] pub struct WriteHoldModeActivityBuilder {pub hold_mode_activity: HoldModeActivity, }
impl WriteHoldModeActivityData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "WriteHoldModeActivity".to_string(),    field: "hold_mode_activity".to_string(),    wanted: 4,    got: bytes.len()});}let hold_mode_activity = u8::from_le_bytes([bytes[3]]);let hold_mode_activity = HoldModeActivity::from_u8(hold_mode_activity).unwrap();Ok(Self {hold_mode_activity, })
}
fn write_to(&self, buffer: &mut BytesMut) {let hold_mode_activity = self.hold_mode_activity.to_u8().unwrap();buffer[3..4].copy_from_slice(&hold_mode_activity.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for WriteHoldModeActivityPacket { type ResponseType = WriteHoldModeActivityCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteHoldModeActivityCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteHoldModeActivityPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteHoldModeActivityPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let write_hold_mode_activity = match &command.child {CommandDataChild::WriteHoldModeActivity(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteHoldModeActivity"),};Self {command,write_hold_mode_activity,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_hold_mode_activity(&self) -> HoldModeActivity{ self.write_hold_mode_activity.as_ref().hold_mode_activity}
}
impl Into<CommandPacket> for WriteHoldModeActivityPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for WriteHoldModeActivityBuilder { type ResponseType = WriteHoldModeActivityCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteHoldModeActivityCompletePacket::new(pkt.event.clone()) }}impl WriteHoldModeActivityBuilder {pub fn build(self) -> WriteHoldModeActivityPacket {let write_hold_mode_activity= Arc::new(WriteHoldModeActivityData {hold_mode_activity: self.hold_mode_activity, });let command= Arc::new(CommandData {op_code: OpCode::WriteHoldModeActivity, child: CommandDataChild::WriteHoldModeActivity(write_hold_mode_activity),});WriteHoldModeActivityPacket::new(command)}
}
impl Into<CommandPacket> for WriteHoldModeActivityBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct WriteHoldModeActivityCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WriteHoldModeActivityCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_hold_mode_activity_complete: Arc<WriteHoldModeActivityCompleteData>,}
#[derive(Debug)] pub struct WriteHoldModeActivityCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WriteHoldModeActivityCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteHoldModeActivityComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WriteHoldModeActivityCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteHoldModeActivityCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_hold_mode_activity_complete = match &command_complete.child {CommandCompleteDataChild::WriteHoldModeActivityComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteHoldModeActivityComplete"),};Self {event,command_complete,write_hold_mode_activity_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_hold_mode_activity_complete.as_ref().status}
}
impl Into<EventPacket> for WriteHoldModeActivityCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteHoldModeActivityCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteHoldModeActivityCompleteBuilder {pub fn build(self) -> WriteHoldModeActivityCompletePacket {let write_hold_mode_activity_complete= Arc::new(WriteHoldModeActivityCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteHoldModeActivity, child: CommandCompleteDataChild::WriteHoldModeActivityComplete(write_hold_mode_activity_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteHoldModeActivityCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteHoldModeActivityCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteHoldModeActivityCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadTransmitPowerLevelData {connection_handle: u16, transmit_power_level_type: TransmitPowerLevelType, }
#[derive(Debug, Clone)] pub struct ReadTransmitPowerLevelPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,read_transmit_power_level: Arc<ReadTransmitPowerLevelData>,}
#[derive(Debug)] pub struct ReadTransmitPowerLevelBuilder {pub connection_handle: u16, pub transmit_power_level_type: TransmitPowerLevelType, }
impl ReadTransmitPowerLevelData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ReadTransmitPowerLevel".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadTransmitPowerLevel".to_string(),    field: "transmit_power_level_type".to_string(),    wanted: 6,    got: bytes.len()});}let transmit_power_level_type = u8::from_le_bytes([bytes[5]]);let transmit_power_level_type = TransmitPowerLevelType::from_u8(transmit_power_level_type).unwrap();Ok(Self {connection_handle, transmit_power_level_type, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let transmit_power_level_type = self.transmit_power_level_type.to_u8().unwrap();buffer[5..6].copy_from_slice(&transmit_power_level_type.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl CommandExpectations for ReadTransmitPowerLevelPacket { type ResponseType = ReadTransmitPowerLevelCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadTransmitPowerLevelCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadTransmitPowerLevelPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadTransmitPowerLevelPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let read_transmit_power_level = match &connection_management_command.child {ConnectionManagementCommandDataChild::ReadTransmitPowerLevel(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadTransmitPowerLevel"),};Self {command,acl_command,connection_management_command,read_transmit_power_level,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.read_transmit_power_level.as_ref().connection_handle}
pub fn get_transmit_power_level_type(&self) -> TransmitPowerLevelType{ self.read_transmit_power_level.as_ref().transmit_power_level_type}
}
impl Into<CommandPacket> for ReadTransmitPowerLevelPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for ReadTransmitPowerLevelPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for ReadTransmitPowerLevelPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for ReadTransmitPowerLevelBuilder { type ResponseType = ReadTransmitPowerLevelCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadTransmitPowerLevelCompletePacket::new(pkt.event.clone()) }}impl ReadTransmitPowerLevelBuilder {pub fn build(self) -> ReadTransmitPowerLevelPacket {let read_transmit_power_level= Arc::new(ReadTransmitPowerLevelData {connection_handle: self.connection_handle, transmit_power_level_type: self.transmit_power_level_type, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::ReadTransmitPowerLevel(read_transmit_power_level),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::ReadTransmitPowerLevel, child: CommandDataChild::AclCommand(acl_command),});ReadTransmitPowerLevelPacket::new(command)}
}
impl Into<CommandPacket> for ReadTransmitPowerLevelBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for ReadTransmitPowerLevelBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for ReadTransmitPowerLevelBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadTransmitPowerLevelCompleteData {status: ErrorCode, connection_handle: u16, transmit_power_level: u8, }
#[derive(Debug, Clone)] pub struct ReadTransmitPowerLevelCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_transmit_power_level_complete: Arc<ReadTransmitPowerLevelCompleteData>,}
#[derive(Debug)] pub struct ReadTransmitPowerLevelCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, pub transmit_power_level: u8, }
impl ReadTransmitPowerLevelCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadTransmitPowerLevelComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadTransmitPowerLevelComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "ReadTransmitPowerLevelComplete".to_string(),    field: "transmit_power_level".to_string(),    wanted: 9,    got: bytes.len()});}let transmit_power_level = u8::from_le_bytes([bytes[8]]);Ok(Self {status, connection_handle, transmit_power_level, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let transmit_power_level = self.transmit_power_level;buffer[8..9].copy_from_slice(&transmit_power_level.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl Packet for ReadTransmitPowerLevelCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadTransmitPowerLevelCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_transmit_power_level_complete = match &command_complete.child {CommandCompleteDataChild::ReadTransmitPowerLevelComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadTransmitPowerLevelComplete"),};Self {event,command_complete,read_transmit_power_level_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_transmit_power_level_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.read_transmit_power_level_complete.as_ref().connection_handle}
pub fn get_transmit_power_level(&self) -> u8{ self.read_transmit_power_level_complete.as_ref().transmit_power_level}
}
impl Into<EventPacket> for ReadTransmitPowerLevelCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadTransmitPowerLevelCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadTransmitPowerLevelCompleteBuilder {pub fn build(self) -> ReadTransmitPowerLevelCompletePacket {let read_transmit_power_level_complete= Arc::new(ReadTransmitPowerLevelCompleteData {status: self.status, connection_handle: self.connection_handle, transmit_power_level: self.transmit_power_level, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadTransmitPowerLevel, child: CommandCompleteDataChild::ReadTransmitPowerLevelComplete(read_transmit_power_level_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadTransmitPowerLevelCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadTransmitPowerLevelCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadTransmitPowerLevelCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadSynchronousFlowControlEnableData {}
#[derive(Debug, Clone)] pub struct ReadSynchronousFlowControlEnablePacket {command: Arc<CommandData>,read_synchronous_flow_control_enable: Arc<ReadSynchronousFlowControlEnableData>,}
#[derive(Debug)] pub struct ReadSynchronousFlowControlEnableBuilder {}
impl ReadSynchronousFlowControlEnableData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadSynchronousFlowControlEnablePacket { type ResponseType = ReadSynchronousFlowControlEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadSynchronousFlowControlEnableCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadSynchronousFlowControlEnablePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadSynchronousFlowControlEnablePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let read_synchronous_flow_control_enable = match &command.child {CommandDataChild::ReadSynchronousFlowControlEnable(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadSynchronousFlowControlEnable"),};Self {command,read_synchronous_flow_control_enable,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadSynchronousFlowControlEnablePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for ReadSynchronousFlowControlEnableBuilder { type ResponseType = ReadSynchronousFlowControlEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadSynchronousFlowControlEnableCompletePacket::new(pkt.event.clone()) }}impl ReadSynchronousFlowControlEnableBuilder {pub fn build(self) -> ReadSynchronousFlowControlEnablePacket {let read_synchronous_flow_control_enable= Arc::new(ReadSynchronousFlowControlEnableData {});let command= Arc::new(CommandData {op_code: OpCode::ReadSynchronousFlowControlEnable, child: CommandDataChild::ReadSynchronousFlowControlEnable(read_synchronous_flow_control_enable),});ReadSynchronousFlowControlEnablePacket::new(command)}
}
impl Into<CommandPacket> for ReadSynchronousFlowControlEnableBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadSynchronousFlowControlEnableCompleteData {status: ErrorCode, enable: Enable, }
#[derive(Debug, Clone)] pub struct ReadSynchronousFlowControlEnableCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_synchronous_flow_control_enable_complete: Arc<ReadSynchronousFlowControlEnableCompleteData>,}
#[derive(Debug)] pub struct ReadSynchronousFlowControlEnableCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub enable: Enable, }
impl ReadSynchronousFlowControlEnableCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadSynchronousFlowControlEnableComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ReadSynchronousFlowControlEnableComplete".to_string(),    field: "enable".to_string(),    wanted: 7,    got: bytes.len()});}let enable = u8::from_le_bytes([bytes[6]]);let enable = Enable::from_u8(enable).unwrap();Ok(Self {status, enable, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let enable = self.enable.to_u8().unwrap();buffer[6..7].copy_from_slice(&enable.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for ReadSynchronousFlowControlEnableCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadSynchronousFlowControlEnableCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_synchronous_flow_control_enable_complete = match &command_complete.child {CommandCompleteDataChild::ReadSynchronousFlowControlEnableComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadSynchronousFlowControlEnableComplete"),};Self {event,command_complete,read_synchronous_flow_control_enable_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_synchronous_flow_control_enable_complete.as_ref().status}
pub fn get_enable(&self) -> Enable{ self.read_synchronous_flow_control_enable_complete.as_ref().enable}
}
impl Into<EventPacket> for ReadSynchronousFlowControlEnableCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadSynchronousFlowControlEnableCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadSynchronousFlowControlEnableCompleteBuilder {pub fn build(self) -> ReadSynchronousFlowControlEnableCompletePacket {let read_synchronous_flow_control_enable_complete= Arc::new(ReadSynchronousFlowControlEnableCompleteData {status: self.status, enable: self.enable, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadSynchronousFlowControlEnable, child: CommandCompleteDataChild::ReadSynchronousFlowControlEnableComplete(read_synchronous_flow_control_enable_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadSynchronousFlowControlEnableCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadSynchronousFlowControlEnableCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadSynchronousFlowControlEnableCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WriteSynchronousFlowControlEnableData {enable: Enable, }
#[derive(Debug, Clone)] pub struct WriteSynchronousFlowControlEnablePacket {command: Arc<CommandData>,write_synchronous_flow_control_enable: Arc<WriteSynchronousFlowControlEnableData>,}
#[derive(Debug)] pub struct WriteSynchronousFlowControlEnableBuilder {pub enable: Enable, }
impl WriteSynchronousFlowControlEnableData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "WriteSynchronousFlowControlEnable".to_string(),    field: "enable".to_string(),    wanted: 4,    got: bytes.len()});}let enable = u8::from_le_bytes([bytes[3]]);let enable = Enable::from_u8(enable).unwrap();Ok(Self {enable, })
}
fn write_to(&self, buffer: &mut BytesMut) {let enable = self.enable.to_u8().unwrap();buffer[3..4].copy_from_slice(&enable.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for WriteSynchronousFlowControlEnablePacket { type ResponseType = WriteSynchronousFlowControlEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteSynchronousFlowControlEnableCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteSynchronousFlowControlEnablePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteSynchronousFlowControlEnablePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let write_synchronous_flow_control_enable = match &command.child {CommandDataChild::WriteSynchronousFlowControlEnable(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteSynchronousFlowControlEnable"),};Self {command,write_synchronous_flow_control_enable,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_enable(&self) -> Enable{ self.write_synchronous_flow_control_enable.as_ref().enable}
}
impl Into<CommandPacket> for WriteSynchronousFlowControlEnablePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for WriteSynchronousFlowControlEnableBuilder { type ResponseType = WriteSynchronousFlowControlEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteSynchronousFlowControlEnableCompletePacket::new(pkt.event.clone()) }}impl WriteSynchronousFlowControlEnableBuilder {pub fn build(self) -> WriteSynchronousFlowControlEnablePacket {let write_synchronous_flow_control_enable= Arc::new(WriteSynchronousFlowControlEnableData {enable: self.enable, });let command= Arc::new(CommandData {op_code: OpCode::WriteSynchronousFlowControlEnable, child: CommandDataChild::WriteSynchronousFlowControlEnable(write_synchronous_flow_control_enable),});WriteSynchronousFlowControlEnablePacket::new(command)}
}
impl Into<CommandPacket> for WriteSynchronousFlowControlEnableBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct WriteSynchronousFlowControlEnableCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WriteSynchronousFlowControlEnableCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_synchronous_flow_control_enable_complete: Arc<WriteSynchronousFlowControlEnableCompleteData>,}
#[derive(Debug)] pub struct WriteSynchronousFlowControlEnableCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WriteSynchronousFlowControlEnableCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteSynchronousFlowControlEnableComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WriteSynchronousFlowControlEnableCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteSynchronousFlowControlEnableCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_synchronous_flow_control_enable_complete = match &command_complete.child {CommandCompleteDataChild::WriteSynchronousFlowControlEnableComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteSynchronousFlowControlEnableComplete"),};Self {event,command_complete,write_synchronous_flow_control_enable_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_synchronous_flow_control_enable_complete.as_ref().status}
}
impl Into<EventPacket> for WriteSynchronousFlowControlEnableCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteSynchronousFlowControlEnableCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteSynchronousFlowControlEnableCompleteBuilder {pub fn build(self) -> WriteSynchronousFlowControlEnableCompletePacket {let write_synchronous_flow_control_enable_complete= Arc::new(WriteSynchronousFlowControlEnableCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteSynchronousFlowControlEnable, child: CommandCompleteDataChild::WriteSynchronousFlowControlEnableComplete(write_synchronous_flow_control_enable_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteSynchronousFlowControlEnableCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteSynchronousFlowControlEnableCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteSynchronousFlowControlEnableCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct SetControllerToHostFlowControlData {acl: u8, synchronous: u8, }
#[derive(Debug, Clone)] pub struct SetControllerToHostFlowControlPacket {command: Arc<CommandData>,set_controller_to_host_flow_control: Arc<SetControllerToHostFlowControlData>,}
#[derive(Debug)] pub struct SetControllerToHostFlowControlBuilder {pub acl: u8, pub synchronous: u8, }
impl SetControllerToHostFlowControlData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {let acl = u8::from_le_bytes([bytes[3]]);let acl = acl & 0x1;let synchronous = u8::from_le_bytes([bytes[3]]);let synchronous = synchronous >> 1;let synchronous = synchronous & 0x1;Ok(Self {acl, synchronous, })
}
fn write_to(&self, buffer: &mut BytesMut) {let acl = self.acl;let acl = acl & 0x1;buffer[3..4].copy_from_slice(&acl.to_le_bytes()[0..1]);let synchronous = self.synchronous;let synchronous = synchronous & 0x1;let synchronous = (synchronous << 1) | ((buffer[3] as u8) & 0x1);buffer[3..4].copy_from_slice(&synchronous.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for SetControllerToHostFlowControlPacket { type ResponseType = SetControllerToHostFlowControlCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { SetControllerToHostFlowControlCompletePacket::new(pkt.event.clone()) }}impl Packet for SetControllerToHostFlowControlPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SetControllerToHostFlowControlPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let set_controller_to_host_flow_control = match &command.child {CommandDataChild::SetControllerToHostFlowControl(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetControllerToHostFlowControl"),};Self {command,set_controller_to_host_flow_control,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_acl(&self) -> u8{ self.set_controller_to_host_flow_control.as_ref().acl}
pub fn get_synchronous(&self) -> u8{ self.set_controller_to_host_flow_control.as_ref().synchronous}
}
impl Into<CommandPacket> for SetControllerToHostFlowControlPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for SetControllerToHostFlowControlBuilder { type ResponseType = SetControllerToHostFlowControlCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { SetControllerToHostFlowControlCompletePacket::new(pkt.event.clone()) }}impl SetControllerToHostFlowControlBuilder {pub fn build(self) -> SetControllerToHostFlowControlPacket {let set_controller_to_host_flow_control= Arc::new(SetControllerToHostFlowControlData {acl: self.acl, synchronous: self.synchronous, });let command= Arc::new(CommandData {op_code: OpCode::SetControllerToHostFlowControl, child: CommandDataChild::SetControllerToHostFlowControl(set_controller_to_host_flow_control),});SetControllerToHostFlowControlPacket::new(command)}
}
impl Into<CommandPacket> for SetControllerToHostFlowControlBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct SetControllerToHostFlowControlCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct SetControllerToHostFlowControlCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,set_controller_to_host_flow_control_complete: Arc<SetControllerToHostFlowControlCompleteData>,}
#[derive(Debug)] pub struct SetControllerToHostFlowControlCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl SetControllerToHostFlowControlCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "SetControllerToHostFlowControlComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for SetControllerToHostFlowControlCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SetControllerToHostFlowControlCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let set_controller_to_host_flow_control_complete = match &command_complete.child {CommandCompleteDataChild::SetControllerToHostFlowControlComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetControllerToHostFlowControlComplete"),};Self {event,command_complete,set_controller_to_host_flow_control_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.set_controller_to_host_flow_control_complete.as_ref().status}
}
impl Into<EventPacket> for SetControllerToHostFlowControlCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for SetControllerToHostFlowControlCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl SetControllerToHostFlowControlCompleteBuilder {pub fn build(self) -> SetControllerToHostFlowControlCompletePacket {let set_controller_to_host_flow_control_complete= Arc::new(SetControllerToHostFlowControlCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::SetControllerToHostFlowControl, child: CommandCompleteDataChild::SetControllerToHostFlowControlComplete(set_controller_to_host_flow_control_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});SetControllerToHostFlowControlCompletePacket::new(event)}
}
impl Into<EventPacket> for SetControllerToHostFlowControlCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for SetControllerToHostFlowControlCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct HostBufferSizeData {host_acl_data_packet_length: u16, host_synchronous_data_packet_length: u8, host_total_num_acl_data_packets: u16, host_total_num_synchronous_data_packets: u16, }
#[derive(Debug, Clone)] pub struct HostBufferSizePacket {command: Arc<CommandData>,host_buffer_size: Arc<HostBufferSizeData>,}
#[derive(Debug)] pub struct HostBufferSizeBuilder {pub host_acl_data_packet_length: u16, pub host_synchronous_data_packet_length: u8, pub host_total_num_acl_data_packets: u16, pub host_total_num_synchronous_data_packets: u16, }
impl HostBufferSizeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "HostBufferSize".to_string(),    field: "host_acl_data_packet_length".to_string(),    wanted: 5,    got: bytes.len()});}let host_acl_data_packet_length = u16::from_le_bytes([bytes[3],bytes[4]]);if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "HostBufferSize".to_string(),    field: "host_synchronous_data_packet_length".to_string(),    wanted: 6,    got: bytes.len()});}let host_synchronous_data_packet_length = u8::from_le_bytes([bytes[5]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "HostBufferSize".to_string(),    field: "host_total_num_acl_data_packets".to_string(),    wanted: 8,    got: bytes.len()});}let host_total_num_acl_data_packets = u16::from_le_bytes([bytes[6],bytes[7]]);if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "HostBufferSize".to_string(),    field: "host_total_num_synchronous_data_packets".to_string(),    wanted: 10,    got: bytes.len()});}let host_total_num_synchronous_data_packets = u16::from_le_bytes([bytes[8],bytes[9]]);Ok(Self {host_acl_data_packet_length, host_synchronous_data_packet_length, host_total_num_acl_data_packets, host_total_num_synchronous_data_packets, })
}
fn write_to(&self, buffer: &mut BytesMut) {let host_acl_data_packet_length = self.host_acl_data_packet_length;buffer[3..5].copy_from_slice(&host_acl_data_packet_length.to_le_bytes()[0..2]);let host_synchronous_data_packet_length = self.host_synchronous_data_packet_length;buffer[5..6].copy_from_slice(&host_synchronous_data_packet_length.to_le_bytes()[0..1]);let host_total_num_acl_data_packets = self.host_total_num_acl_data_packets;buffer[6..8].copy_from_slice(&host_total_num_acl_data_packets.to_le_bytes()[0..2]);let host_total_num_synchronous_data_packets = self.host_total_num_synchronous_data_packets;buffer[8..10].copy_from_slice(&host_total_num_synchronous_data_packets.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl CommandExpectations for HostBufferSizePacket { type ResponseType = HostBufferSizeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { HostBufferSizeCompletePacket::new(pkt.event.clone()) }}impl Packet for HostBufferSizePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl HostBufferSizePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let host_buffer_size = match &command.child {CommandDataChild::HostBufferSize(value) => (*value).clone(),_ => panic!("inconsistent state - child was not HostBufferSize"),};Self {command,host_buffer_size,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_host_acl_data_packet_length(&self) -> u16{ self.host_buffer_size.as_ref().host_acl_data_packet_length}
pub fn get_host_synchronous_data_packet_length(&self) -> u8{ self.host_buffer_size.as_ref().host_synchronous_data_packet_length}
pub fn get_host_total_num_acl_data_packets(&self) -> u16{ self.host_buffer_size.as_ref().host_total_num_acl_data_packets}
pub fn get_host_total_num_synchronous_data_packets(&self) -> u16{ self.host_buffer_size.as_ref().host_total_num_synchronous_data_packets}
}
impl Into<CommandPacket> for HostBufferSizePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for HostBufferSizeBuilder { type ResponseType = HostBufferSizeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { HostBufferSizeCompletePacket::new(pkt.event.clone()) }}impl HostBufferSizeBuilder {pub fn build(self) -> HostBufferSizePacket {let host_buffer_size= Arc::new(HostBufferSizeData {host_acl_data_packet_length: self.host_acl_data_packet_length, host_synchronous_data_packet_length: self.host_synchronous_data_packet_length, host_total_num_acl_data_packets: self.host_total_num_acl_data_packets, host_total_num_synchronous_data_packets: self.host_total_num_synchronous_data_packets, });let command= Arc::new(CommandData {op_code: OpCode::HostBufferSize, child: CommandDataChild::HostBufferSize(host_buffer_size),});HostBufferSizePacket::new(command)}
}
impl Into<CommandPacket> for HostBufferSizeBuilder { fn into(self) -> CommandPacket { self.build().into() }}
macro_rules! host_buffer_size_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::HostBufferSize(packet) => {let rebuilder = HostBufferSizeBuilder {host_acl_data_packet_length : packet.get_host_acl_data_packet_length(),host_synchronous_data_packet_length : packet.get_host_synchronous_data_packet_length(),host_total_num_acl_data_packets : packet.get_host_total_num_acl_data_packets(),host_total_num_synchronous_data_packets : packet.get_host_total_num_synchronous_data_packets(),};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse host_buffer_size{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}host_buffer_size_builder_tests! { host_buffer_size_builder_test_00: b"\x33\x0c\x07\x9b\x06\xff\x14\x00\x0a\x00",}


#[derive(Debug)] struct HostBufferSizeCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct HostBufferSizeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,host_buffer_size_complete: Arc<HostBufferSizeCompleteData>,}
#[derive(Debug)] pub struct HostBufferSizeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl HostBufferSizeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "HostBufferSizeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for HostBufferSizeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl HostBufferSizeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let host_buffer_size_complete = match &command_complete.child {CommandCompleteDataChild::HostBufferSizeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not HostBufferSizeComplete"),};Self {event,command_complete,host_buffer_size_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.host_buffer_size_complete.as_ref().status}
}
impl Into<EventPacket> for HostBufferSizeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for HostBufferSizeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl HostBufferSizeCompleteBuilder {pub fn build(self) -> HostBufferSizeCompletePacket {let host_buffer_size_complete= Arc::new(HostBufferSizeCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::HostBufferSize, child: CommandCompleteDataChild::HostBufferSizeComplete(host_buffer_size_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});HostBufferSizeCompletePacket::new(event)}
}
impl Into<EventPacket> for HostBufferSizeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for HostBufferSizeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! host_buffer_size_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::HostBufferSizeComplete(packet) => {let rebuilder = HostBufferSizeCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse host_buffer_size_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}host_buffer_size_complete_builder_tests! { host_buffer_size_complete_builder_test_00: b"\x0e\x04\x01\x33\x0c\x00",}


#[derive(Debug)] struct HostNumCompletedPacketsData {completed_packets: Vec::<CompletedPackets>, }
#[derive(Debug, Clone)] pub struct HostNumCompletedPacketsPacket {command: Arc<CommandData>,host_num_completed_packets: Arc<HostNumCompletedPacketsData>,}
#[derive(Debug)] pub struct HostNumCompletedPacketsBuilder {pub completed_packets: Vec::<CompletedPackets>, }
impl HostNumCompletedPacketsData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "HostNumCompletedPackets".to_string(),    field: "completed_packets_count".to_string(),    wanted: 4,    got: bytes.len()});}let completed_packets_count = u8::from_le_bytes([bytes[3]]);let mut completed_packets: Vec::<CompletedPackets> = Vec::new();let mut parsable_ = &bytes[4..];let count_ = completed_packets_count as usize;for _ in 0..count_ { match CompletedPackets::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];completed_packets.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {completed_packets, })
}
fn write_to(&self, buffer: &mut BytesMut) {buffer[3..4].copy_from_slice(&(self.completed_packets.len() as u8).to_le_bytes());let mut vec_buffer_ = &mut buffer[4..];for e_ in &self.completed_packets { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;let ret = ret + (self.completed_packets.len() * ((/* Bits: */ 32 + /* Dynamic: */ 0) / 8));ret}
}
impl CommandExpectations for HostNumCompletedPacketsPacket { type ResponseType = HostNumCompletedPacketsErrorPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { HostNumCompletedPacketsErrorPacket::new(pkt.event.clone()) }}impl Packet for HostNumCompletedPacketsPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl HostNumCompletedPacketsPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let host_num_completed_packets = match &command.child {CommandDataChild::HostNumCompletedPackets(value) => (*value).clone(),_ => panic!("inconsistent state - child was not HostNumCompletedPackets"),};Self {command,host_num_completed_packets,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_completed_packets(&self) -> &Vec::<CompletedPackets>{ &self.host_num_completed_packets.as_ref().completed_packets}
}
impl Into<CommandPacket> for HostNumCompletedPacketsPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for HostNumCompletedPacketsBuilder { type ResponseType = HostNumCompletedPacketsErrorPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { HostNumCompletedPacketsErrorPacket::new(pkt.event.clone()) }}impl HostNumCompletedPacketsBuilder {pub fn build(self) -> HostNumCompletedPacketsPacket {let host_num_completed_packets= Arc::new(HostNumCompletedPacketsData {completed_packets: self.completed_packets, });let command= Arc::new(CommandData {op_code: OpCode::HostNumCompletedPackets, child: CommandDataChild::HostNumCompletedPackets(host_num_completed_packets),});HostNumCompletedPacketsPacket::new(command)}
}
impl Into<CommandPacket> for HostNumCompletedPacketsBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct HostNumCompletedPacketsErrorData {error_code: ErrorCode, }
#[derive(Debug, Clone)] pub struct HostNumCompletedPacketsErrorPacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,host_num_completed_packets_error: Arc<HostNumCompletedPacketsErrorData>,}
#[derive(Debug)] pub struct HostNumCompletedPacketsErrorBuilder {pub num_hci_command_packets: u8, pub error_code: ErrorCode, }
impl HostNumCompletedPacketsErrorData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "HostNumCompletedPacketsError".to_string(),    field: "error_code".to_string(),    wanted: 6,    got: bytes.len()});}let error_code = u8::from_le_bytes([bytes[5]]);let error_code = ErrorCode::from_u8(error_code).unwrap();Ok(Self {error_code, })
}
fn write_to(&self, buffer: &mut BytesMut) {let error_code = self.error_code.to_u8().unwrap();buffer[5..6].copy_from_slice(&error_code.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for HostNumCompletedPacketsErrorPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl HostNumCompletedPacketsErrorPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let host_num_completed_packets_error = match &command_complete.child {CommandCompleteDataChild::HostNumCompletedPacketsError(value) => (*value).clone(),_ => panic!("inconsistent state - child was not HostNumCompletedPacketsError"),};Self {event,command_complete,host_num_completed_packets_error,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_error_code(&self) -> ErrorCode{ self.host_num_completed_packets_error.as_ref().error_code}
}
impl Into<EventPacket> for HostNumCompletedPacketsErrorPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for HostNumCompletedPacketsErrorPacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl HostNumCompletedPacketsErrorBuilder {pub fn build(self) -> HostNumCompletedPacketsErrorPacket {let host_num_completed_packets_error= Arc::new(HostNumCompletedPacketsErrorData {error_code: self.error_code, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::HostNumCompletedPackets, child: CommandCompleteDataChild::HostNumCompletedPacketsError(host_num_completed_packets_error),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});HostNumCompletedPacketsErrorPacket::new(event)}
}
impl Into<EventPacket> for HostNumCompletedPacketsErrorBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for HostNumCompletedPacketsErrorBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadLinkSupervisionTimeoutData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct ReadLinkSupervisionTimeoutPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,read_link_supervision_timeout: Arc<ReadLinkSupervisionTimeoutData>,}
#[derive(Debug)] pub struct ReadLinkSupervisionTimeoutBuilder {pub connection_handle: u16, }
impl ReadLinkSupervisionTimeoutData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ReadLinkSupervisionTimeout".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for ReadLinkSupervisionTimeoutPacket { type ResponseType = ReadLinkSupervisionTimeoutCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLinkSupervisionTimeoutCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadLinkSupervisionTimeoutPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLinkSupervisionTimeoutPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let read_link_supervision_timeout = match &connection_management_command.child {ConnectionManagementCommandDataChild::ReadLinkSupervisionTimeout(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLinkSupervisionTimeout"),};Self {command,acl_command,connection_management_command,read_link_supervision_timeout,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.read_link_supervision_timeout.as_ref().connection_handle}
}
impl Into<CommandPacket> for ReadLinkSupervisionTimeoutPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for ReadLinkSupervisionTimeoutPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for ReadLinkSupervisionTimeoutPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for ReadLinkSupervisionTimeoutBuilder { type ResponseType = ReadLinkSupervisionTimeoutCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLinkSupervisionTimeoutCompletePacket::new(pkt.event.clone()) }}impl ReadLinkSupervisionTimeoutBuilder {pub fn build(self) -> ReadLinkSupervisionTimeoutPacket {let read_link_supervision_timeout= Arc::new(ReadLinkSupervisionTimeoutData {connection_handle: self.connection_handle, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::ReadLinkSupervisionTimeout(read_link_supervision_timeout),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::ReadLinkSupervisionTimeout, child: CommandDataChild::AclCommand(acl_command),});ReadLinkSupervisionTimeoutPacket::new(command)}
}
impl Into<CommandPacket> for ReadLinkSupervisionTimeoutBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for ReadLinkSupervisionTimeoutBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for ReadLinkSupervisionTimeoutBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadLinkSupervisionTimeoutCompleteData {status: ErrorCode, connection_handle: u16, link_supervision_timeout: u16, }
#[derive(Debug, Clone)] pub struct ReadLinkSupervisionTimeoutCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_link_supervision_timeout_complete: Arc<ReadLinkSupervisionTimeoutCompleteData>,}
#[derive(Debug)] pub struct ReadLinkSupervisionTimeoutCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, pub link_supervision_timeout: u16, }
impl ReadLinkSupervisionTimeoutCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadLinkSupervisionTimeoutComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadLinkSupervisionTimeoutComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "ReadLinkSupervisionTimeoutComplete".to_string(),    field: "link_supervision_timeout".to_string(),    wanted: 10,    got: bytes.len()});}let link_supervision_timeout = u16::from_le_bytes([bytes[8],bytes[9]]);Ok(Self {status, connection_handle, link_supervision_timeout, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let link_supervision_timeout = self.link_supervision_timeout;buffer[8..10].copy_from_slice(&link_supervision_timeout.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 5;ret}
}
impl Packet for ReadLinkSupervisionTimeoutCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLinkSupervisionTimeoutCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_link_supervision_timeout_complete = match &command_complete.child {CommandCompleteDataChild::ReadLinkSupervisionTimeoutComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLinkSupervisionTimeoutComplete"),};Self {event,command_complete,read_link_supervision_timeout_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_link_supervision_timeout_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.read_link_supervision_timeout_complete.as_ref().connection_handle}
pub fn get_link_supervision_timeout(&self) -> u16{ self.read_link_supervision_timeout_complete.as_ref().link_supervision_timeout}
}
impl Into<EventPacket> for ReadLinkSupervisionTimeoutCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadLinkSupervisionTimeoutCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadLinkSupervisionTimeoutCompleteBuilder {pub fn build(self) -> ReadLinkSupervisionTimeoutCompletePacket {let read_link_supervision_timeout_complete= Arc::new(ReadLinkSupervisionTimeoutCompleteData {status: self.status, connection_handle: self.connection_handle, link_supervision_timeout: self.link_supervision_timeout, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadLinkSupervisionTimeout, child: CommandCompleteDataChild::ReadLinkSupervisionTimeoutComplete(read_link_supervision_timeout_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadLinkSupervisionTimeoutCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadLinkSupervisionTimeoutCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadLinkSupervisionTimeoutCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WriteLinkSupervisionTimeoutData {connection_handle: u16, link_supervision_timeout: u16, }
#[derive(Debug, Clone)] pub struct WriteLinkSupervisionTimeoutPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,write_link_supervision_timeout: Arc<WriteLinkSupervisionTimeoutData>,}
#[derive(Debug)] pub struct WriteLinkSupervisionTimeoutBuilder {pub connection_handle: u16, pub link_supervision_timeout: u16, }
impl WriteLinkSupervisionTimeoutData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "WriteLinkSupervisionTimeout".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "WriteLinkSupervisionTimeout".to_string(),    field: "link_supervision_timeout".to_string(),    wanted: 7,    got: bytes.len()});}let link_supervision_timeout = u16::from_le_bytes([bytes[5],bytes[6]]);Ok(Self {connection_handle, link_supervision_timeout, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let link_supervision_timeout = self.link_supervision_timeout;buffer[5..7].copy_from_slice(&link_supervision_timeout.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl CommandExpectations for WriteLinkSupervisionTimeoutPacket { type ResponseType = WriteLinkSupervisionTimeoutCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteLinkSupervisionTimeoutCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteLinkSupervisionTimeoutPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteLinkSupervisionTimeoutPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let write_link_supervision_timeout = match &connection_management_command.child {ConnectionManagementCommandDataChild::WriteLinkSupervisionTimeout(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteLinkSupervisionTimeout"),};Self {command,acl_command,connection_management_command,write_link_supervision_timeout,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.write_link_supervision_timeout.as_ref().connection_handle}
pub fn get_link_supervision_timeout(&self) -> u16{ self.write_link_supervision_timeout.as_ref().link_supervision_timeout}
}
impl Into<CommandPacket> for WriteLinkSupervisionTimeoutPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for WriteLinkSupervisionTimeoutPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for WriteLinkSupervisionTimeoutPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for WriteLinkSupervisionTimeoutBuilder { type ResponseType = WriteLinkSupervisionTimeoutCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteLinkSupervisionTimeoutCompletePacket::new(pkt.event.clone()) }}impl WriteLinkSupervisionTimeoutBuilder {pub fn build(self) -> WriteLinkSupervisionTimeoutPacket {let write_link_supervision_timeout= Arc::new(WriteLinkSupervisionTimeoutData {connection_handle: self.connection_handle, link_supervision_timeout: self.link_supervision_timeout, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::WriteLinkSupervisionTimeout(write_link_supervision_timeout),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::WriteLinkSupervisionTimeout, child: CommandDataChild::AclCommand(acl_command),});WriteLinkSupervisionTimeoutPacket::new(command)}
}
impl Into<CommandPacket> for WriteLinkSupervisionTimeoutBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for WriteLinkSupervisionTimeoutBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for WriteLinkSupervisionTimeoutBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct WriteLinkSupervisionTimeoutCompleteData {status: ErrorCode, connection_handle: u16, }
#[derive(Debug, Clone)] pub struct WriteLinkSupervisionTimeoutCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_link_supervision_timeout_complete: Arc<WriteLinkSupervisionTimeoutCompleteData>,}
#[derive(Debug)] pub struct WriteLinkSupervisionTimeoutCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, }
impl WriteLinkSupervisionTimeoutCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteLinkSupervisionTimeoutComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "WriteLinkSupervisionTimeoutComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;Ok(Self {status, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for WriteLinkSupervisionTimeoutCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteLinkSupervisionTimeoutCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_link_supervision_timeout_complete = match &command_complete.child {CommandCompleteDataChild::WriteLinkSupervisionTimeoutComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteLinkSupervisionTimeoutComplete"),};Self {event,command_complete,write_link_supervision_timeout_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_link_supervision_timeout_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.write_link_supervision_timeout_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for WriteLinkSupervisionTimeoutCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteLinkSupervisionTimeoutCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteLinkSupervisionTimeoutCompleteBuilder {pub fn build(self) -> WriteLinkSupervisionTimeoutCompletePacket {let write_link_supervision_timeout_complete= Arc::new(WriteLinkSupervisionTimeoutCompleteData {status: self.status, connection_handle: self.connection_handle, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteLinkSupervisionTimeout, child: CommandCompleteDataChild::WriteLinkSupervisionTimeoutComplete(write_link_supervision_timeout_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteLinkSupervisionTimeoutCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteLinkSupervisionTimeoutCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteLinkSupervisionTimeoutCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadNumberOfSupportedIacData {}
#[derive(Debug, Clone)] pub struct ReadNumberOfSupportedIacPacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,read_number_of_supported_iac: Arc<ReadNumberOfSupportedIacData>,}
#[derive(Debug)] pub struct ReadNumberOfSupportedIacBuilder {}
impl ReadNumberOfSupportedIacData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadNumberOfSupportedIacPacket { type ResponseType = ReadNumberOfSupportedIacCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadNumberOfSupportedIacCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadNumberOfSupportedIacPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadNumberOfSupportedIacPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let read_number_of_supported_iac = match &discovery_command.child {DiscoveryCommandDataChild::ReadNumberOfSupportedIac(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadNumberOfSupportedIac"),};Self {command,discovery_command,read_number_of_supported_iac,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadNumberOfSupportedIacPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for ReadNumberOfSupportedIacPacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for ReadNumberOfSupportedIacBuilder { type ResponseType = ReadNumberOfSupportedIacCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadNumberOfSupportedIacCompletePacket::new(pkt.event.clone()) }}impl ReadNumberOfSupportedIacBuilder {pub fn build(self) -> ReadNumberOfSupportedIacPacket {let read_number_of_supported_iac= Arc::new(ReadNumberOfSupportedIacData {});let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::ReadNumberOfSupportedIac(read_number_of_supported_iac),});let command= Arc::new(CommandData {op_code: OpCode::ReadNumberOfSupportedIac, child: CommandDataChild::DiscoveryCommand(discovery_command),});ReadNumberOfSupportedIacPacket::new(command)}
}
impl Into<CommandPacket> for ReadNumberOfSupportedIacBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for ReadNumberOfSupportedIacBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}
macro_rules! read_number_of_supported_iac_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::DiscoveryCommand(discovery_command_packet) => {match discovery_command_packet.specialize() {/* (2) */
DiscoveryCommandChild::ReadNumberOfSupportedIac(packet) => {let rebuilder = ReadNumberOfSupportedIacBuilder {};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse read_number_of_supported_iac{:02x?}", discovery_command_packet); }}}_ => {println!("Couldn't parse discovery_command{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}read_number_of_supported_iac_builder_tests! { read_number_of_supported_iac_builder_test_00: b"\x38\x0c\x00",}


#[derive(Debug)] struct ReadNumberOfSupportedIacCompleteData {status: ErrorCode, num_support_iac: u8, }
#[derive(Debug, Clone)] pub struct ReadNumberOfSupportedIacCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_number_of_supported_iac_complete: Arc<ReadNumberOfSupportedIacCompleteData>,}
#[derive(Debug)] pub struct ReadNumberOfSupportedIacCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub num_support_iac: u8, }
impl ReadNumberOfSupportedIacCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadNumberOfSupportedIacComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ReadNumberOfSupportedIacComplete".to_string(),    field: "num_support_iac".to_string(),    wanted: 7,    got: bytes.len()});}let num_support_iac = u8::from_le_bytes([bytes[6]]);Ok(Self {status, num_support_iac, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let num_support_iac = self.num_support_iac;buffer[6..7].copy_from_slice(&num_support_iac.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for ReadNumberOfSupportedIacCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadNumberOfSupportedIacCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_number_of_supported_iac_complete = match &command_complete.child {CommandCompleteDataChild::ReadNumberOfSupportedIacComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadNumberOfSupportedIacComplete"),};Self {event,command_complete,read_number_of_supported_iac_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_number_of_supported_iac_complete.as_ref().status}
pub fn get_num_support_iac(&self) -> u8{ self.read_number_of_supported_iac_complete.as_ref().num_support_iac}
}
impl Into<EventPacket> for ReadNumberOfSupportedIacCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadNumberOfSupportedIacCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadNumberOfSupportedIacCompleteBuilder {pub fn build(self) -> ReadNumberOfSupportedIacCompletePacket {let read_number_of_supported_iac_complete= Arc::new(ReadNumberOfSupportedIacCompleteData {status: self.status, num_support_iac: self.num_support_iac, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadNumberOfSupportedIac, child: CommandCompleteDataChild::ReadNumberOfSupportedIacComplete(read_number_of_supported_iac_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadNumberOfSupportedIacCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadNumberOfSupportedIacCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadNumberOfSupportedIacCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! read_number_of_supported_iac_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::ReadNumberOfSupportedIacComplete(packet) => {let rebuilder = ReadNumberOfSupportedIacCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),num_support_iac : packet.get_num_support_iac(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse read_number_of_supported_iac_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}read_number_of_supported_iac_complete_builder_tests! { read_number_of_supported_iac_complete_builder_test_00: b"\x0e\x05\x01\x38\x0c\x00\x99",}


#[derive(Debug)] struct ReadCurrentIacLapData {}
#[derive(Debug, Clone)] pub struct ReadCurrentIacLapPacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,read_current_iac_lap: Arc<ReadCurrentIacLapData>,}
#[derive(Debug)] pub struct ReadCurrentIacLapBuilder {}
impl ReadCurrentIacLapData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadCurrentIacLapPacket { type ResponseType = ReadCurrentIacLapCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadCurrentIacLapCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadCurrentIacLapPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadCurrentIacLapPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let read_current_iac_lap = match &discovery_command.child {DiscoveryCommandDataChild::ReadCurrentIacLap(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadCurrentIacLap"),};Self {command,discovery_command,read_current_iac_lap,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadCurrentIacLapPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for ReadCurrentIacLapPacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for ReadCurrentIacLapBuilder { type ResponseType = ReadCurrentIacLapCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadCurrentIacLapCompletePacket::new(pkt.event.clone()) }}impl ReadCurrentIacLapBuilder {pub fn build(self) -> ReadCurrentIacLapPacket {let read_current_iac_lap= Arc::new(ReadCurrentIacLapData {});let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::ReadCurrentIacLap(read_current_iac_lap),});let command= Arc::new(CommandData {op_code: OpCode::ReadCurrentIacLap, child: CommandDataChild::DiscoveryCommand(discovery_command),});ReadCurrentIacLapPacket::new(command)}
}
impl Into<CommandPacket> for ReadCurrentIacLapBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for ReadCurrentIacLapBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}
macro_rules! read_current_iac_lap_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::DiscoveryCommand(discovery_command_packet) => {match discovery_command_packet.specialize() {/* (2) */
DiscoveryCommandChild::ReadCurrentIacLap(packet) => {let rebuilder = ReadCurrentIacLapBuilder {};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse read_current_iac_lap{:02x?}", discovery_command_packet); }}}_ => {println!("Couldn't parse discovery_command{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}read_current_iac_lap_builder_tests! { read_current_iac_lap_builder_test_00: b"\x39\x0c\x00",}


#[derive(Debug)] struct ReadCurrentIacLapCompleteData {status: ErrorCode, laps_to_read: Vec::<Lap>, }
#[derive(Debug, Clone)] pub struct ReadCurrentIacLapCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_current_iac_lap_complete: Arc<ReadCurrentIacLapCompleteData>,}
#[derive(Debug)] pub struct ReadCurrentIacLapCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub laps_to_read: Vec::<Lap>, }
impl ReadCurrentIacLapCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadCurrentIacLapComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ReadCurrentIacLapComplete".to_string(),    field: "laps_to_read_count".to_string(),    wanted: 7,    got: bytes.len()});}let laps_to_read_count = u8::from_le_bytes([bytes[6]]);let mut laps_to_read: Vec::<Lap> = Vec::new();let mut parsable_ = &bytes[7..];let count_ = laps_to_read_count as usize;for _ in 0..count_ { match Lap::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];laps_to_read.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {status, laps_to_read, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);buffer[6..7].copy_from_slice(&(self.laps_to_read.len() as u8).to_le_bytes());let mut vec_buffer_ = &mut buffer[7..];for e_ in &self.laps_to_read { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;let ret = ret + (self.laps_to_read.len() * ((/* Bits: */ 24 + /* Dynamic: */ 0) / 8));ret}
}
impl Packet for ReadCurrentIacLapCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadCurrentIacLapCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_current_iac_lap_complete = match &command_complete.child {CommandCompleteDataChild::ReadCurrentIacLapComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadCurrentIacLapComplete"),};Self {event,command_complete,read_current_iac_lap_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_current_iac_lap_complete.as_ref().status}
pub fn get_laps_to_read(&self) -> &Vec::<Lap>{ &self.read_current_iac_lap_complete.as_ref().laps_to_read}
}
impl Into<EventPacket> for ReadCurrentIacLapCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadCurrentIacLapCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadCurrentIacLapCompleteBuilder {pub fn build(self) -> ReadCurrentIacLapCompletePacket {let read_current_iac_lap_complete= Arc::new(ReadCurrentIacLapCompleteData {status: self.status, laps_to_read: self.laps_to_read, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadCurrentIacLap, child: CommandCompleteDataChild::ReadCurrentIacLapComplete(read_current_iac_lap_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadCurrentIacLapCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadCurrentIacLapCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadCurrentIacLapCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! read_current_iac_lap_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::ReadCurrentIacLapComplete(packet) => {let rebuilder = ReadCurrentIacLapCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),laps_to_read : packet.get_laps_to_read().to_vec(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse read_current_iac_lap_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}read_current_iac_lap_complete_builder_tests! { read_current_iac_lap_complete_builder_test_00: b"\x0e\x0b\x01\x39\x0c\x00\x02\x11\x8b\x9e\x22\x8b\x9e",}


#[derive(Debug)] struct WriteCurrentIacLapData {laps_to_write: Vec::<Lap>, }
#[derive(Debug, Clone)] pub struct WriteCurrentIacLapPacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,write_current_iac_lap: Arc<WriteCurrentIacLapData>,}
#[derive(Debug)] pub struct WriteCurrentIacLapBuilder {pub laps_to_write: Vec::<Lap>, }
impl WriteCurrentIacLapData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "WriteCurrentIacLap".to_string(),    field: "laps_to_write_count".to_string(),    wanted: 4,    got: bytes.len()});}let laps_to_write_count = u8::from_le_bytes([bytes[3]]);let mut laps_to_write: Vec::<Lap> = Vec::new();let mut parsable_ = &bytes[4..];let count_ = laps_to_write_count as usize;for _ in 0..count_ { match Lap::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];laps_to_write.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {laps_to_write, })
}
fn write_to(&self, buffer: &mut BytesMut) {buffer[3..4].copy_from_slice(&(self.laps_to_write.len() as u8).to_le_bytes());let mut vec_buffer_ = &mut buffer[4..];for e_ in &self.laps_to_write { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;let ret = ret + (self.laps_to_write.len() * ((/* Bits: */ 24 + /* Dynamic: */ 0) / 8));ret}
}
impl CommandExpectations for WriteCurrentIacLapPacket { type ResponseType = WriteCurrentIacLapCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteCurrentIacLapCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteCurrentIacLapPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteCurrentIacLapPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let write_current_iac_lap = match &discovery_command.child {DiscoveryCommandDataChild::WriteCurrentIacLap(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteCurrentIacLap"),};Self {command,discovery_command,write_current_iac_lap,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_laps_to_write(&self) -> &Vec::<Lap>{ &self.write_current_iac_lap.as_ref().laps_to_write}
}
impl Into<CommandPacket> for WriteCurrentIacLapPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for WriteCurrentIacLapPacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for WriteCurrentIacLapBuilder { type ResponseType = WriteCurrentIacLapCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteCurrentIacLapCompletePacket::new(pkt.event.clone()) }}impl WriteCurrentIacLapBuilder {pub fn build(self) -> WriteCurrentIacLapPacket {let write_current_iac_lap= Arc::new(WriteCurrentIacLapData {laps_to_write: self.laps_to_write, });let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::WriteCurrentIacLap(write_current_iac_lap),});let command= Arc::new(CommandData {op_code: OpCode::WriteCurrentIacLap, child: CommandDataChild::DiscoveryCommand(discovery_command),});WriteCurrentIacLapPacket::new(command)}
}
impl Into<CommandPacket> for WriteCurrentIacLapBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for WriteCurrentIacLapBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}
macro_rules! write_current_iac_lap_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::DiscoveryCommand(discovery_command_packet) => {match discovery_command_packet.specialize() {/* (2) */
DiscoveryCommandChild::WriteCurrentIacLap(packet) => {let rebuilder = WriteCurrentIacLapBuilder {laps_to_write : packet.get_laps_to_write().to_vec(),};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse write_current_iac_lap{:02x?}", discovery_command_packet); }}}_ => {println!("Couldn't parse discovery_command{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}write_current_iac_lap_builder_tests! { write_current_iac_lap_builder_test_00: b"\x3a\x0c\x07\x02\x11\x8b\x9e\x22\x8b\x9e",}


#[derive(Debug)] struct WriteCurrentIacLapCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WriteCurrentIacLapCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_current_iac_lap_complete: Arc<WriteCurrentIacLapCompleteData>,}
#[derive(Debug)] pub struct WriteCurrentIacLapCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WriteCurrentIacLapCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteCurrentIacLapComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WriteCurrentIacLapCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteCurrentIacLapCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_current_iac_lap_complete = match &command_complete.child {CommandCompleteDataChild::WriteCurrentIacLapComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteCurrentIacLapComplete"),};Self {event,command_complete,write_current_iac_lap_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_current_iac_lap_complete.as_ref().status}
}
impl Into<EventPacket> for WriteCurrentIacLapCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteCurrentIacLapCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteCurrentIacLapCompleteBuilder {pub fn build(self) -> WriteCurrentIacLapCompletePacket {let write_current_iac_lap_complete= Arc::new(WriteCurrentIacLapCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteCurrentIacLap, child: CommandCompleteDataChild::WriteCurrentIacLapComplete(write_current_iac_lap_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteCurrentIacLapCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteCurrentIacLapCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteCurrentIacLapCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! write_current_iac_lap_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::WriteCurrentIacLapComplete(packet) => {let rebuilder = WriteCurrentIacLapCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse write_current_iac_lap_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}write_current_iac_lap_complete_builder_tests! { write_current_iac_lap_complete_builder_test_00: b"\x0e\x04\x01\x3a\x0c\x00",}


#[derive(Debug)] struct SetAfhHostChannelClassificationData {afh_host_channel_classification: [u8; 10], }
#[derive(Debug, Clone)] pub struct SetAfhHostChannelClassificationPacket {command: Arc<CommandData>,set_afh_host_channel_classification: Arc<SetAfhHostChannelClassificationData>,}
#[derive(Debug)] pub struct SetAfhHostChannelClassificationBuilder {pub afh_host_channel_classification: [u8; 10], }
impl SetAfhHostChannelClassificationData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "SetAfhHostChannelClassification".to_string(),    field: "afh_host_channel_classification".to_string(),    wanted: 13,    got: bytes.len()});}let afh_host_channel_classification = bytes[3..13].try_into().unwrap();Ok(Self {afh_host_channel_classification, })
}
fn write_to(&self, buffer: &mut BytesMut) {&buffer[3..13].copy_from_slice(&self.afh_host_channel_classification);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 10;ret}
}
impl CommandExpectations for SetAfhHostChannelClassificationPacket { type ResponseType = SetAfhHostChannelClassificationCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { SetAfhHostChannelClassificationCompletePacket::new(pkt.event.clone()) }}impl Packet for SetAfhHostChannelClassificationPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SetAfhHostChannelClassificationPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let set_afh_host_channel_classification = match &command.child {CommandDataChild::SetAfhHostChannelClassification(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetAfhHostChannelClassification"),};Self {command,set_afh_host_channel_classification,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_afh_host_channel_classification(&self) -> &[u8; 10]{ &self.set_afh_host_channel_classification.as_ref().afh_host_channel_classification}
}
impl Into<CommandPacket> for SetAfhHostChannelClassificationPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for SetAfhHostChannelClassificationBuilder { type ResponseType = SetAfhHostChannelClassificationCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { SetAfhHostChannelClassificationCompletePacket::new(pkt.event.clone()) }}impl SetAfhHostChannelClassificationBuilder {pub fn build(self) -> SetAfhHostChannelClassificationPacket {let set_afh_host_channel_classification= Arc::new(SetAfhHostChannelClassificationData {afh_host_channel_classification: self.afh_host_channel_classification, });let command= Arc::new(CommandData {op_code: OpCode::SetAfhHostChannelClassification, child: CommandDataChild::SetAfhHostChannelClassification(set_afh_host_channel_classification),});SetAfhHostChannelClassificationPacket::new(command)}
}
impl Into<CommandPacket> for SetAfhHostChannelClassificationBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct SetAfhHostChannelClassificationCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct SetAfhHostChannelClassificationCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,set_afh_host_channel_classification_complete: Arc<SetAfhHostChannelClassificationCompleteData>,}
#[derive(Debug)] pub struct SetAfhHostChannelClassificationCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl SetAfhHostChannelClassificationCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "SetAfhHostChannelClassificationComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for SetAfhHostChannelClassificationCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SetAfhHostChannelClassificationCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let set_afh_host_channel_classification_complete = match &command_complete.child {CommandCompleteDataChild::SetAfhHostChannelClassificationComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetAfhHostChannelClassificationComplete"),};Self {event,command_complete,set_afh_host_channel_classification_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.set_afh_host_channel_classification_complete.as_ref().status}
}
impl Into<EventPacket> for SetAfhHostChannelClassificationCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for SetAfhHostChannelClassificationCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl SetAfhHostChannelClassificationCompleteBuilder {pub fn build(self) -> SetAfhHostChannelClassificationCompletePacket {let set_afh_host_channel_classification_complete= Arc::new(SetAfhHostChannelClassificationCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::SetAfhHostChannelClassification, child: CommandCompleteDataChild::SetAfhHostChannelClassificationComplete(set_afh_host_channel_classification_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});SetAfhHostChannelClassificationCompletePacket::new(event)}
}
impl Into<EventPacket> for SetAfhHostChannelClassificationCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for SetAfhHostChannelClassificationCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadInquiryScanTypeData {}
#[derive(Debug, Clone)] pub struct ReadInquiryScanTypePacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,read_inquiry_scan_type: Arc<ReadInquiryScanTypeData>,}
#[derive(Debug)] pub struct ReadInquiryScanTypeBuilder {}
impl ReadInquiryScanTypeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadInquiryScanTypePacket { type ResponseType = ReadInquiryScanTypeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadInquiryScanTypeCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadInquiryScanTypePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadInquiryScanTypePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let read_inquiry_scan_type = match &discovery_command.child {DiscoveryCommandDataChild::ReadInquiryScanType(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadInquiryScanType"),};Self {command,discovery_command,read_inquiry_scan_type,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadInquiryScanTypePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for ReadInquiryScanTypePacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for ReadInquiryScanTypeBuilder { type ResponseType = ReadInquiryScanTypeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadInquiryScanTypeCompletePacket::new(pkt.event.clone()) }}impl ReadInquiryScanTypeBuilder {pub fn build(self) -> ReadInquiryScanTypePacket {let read_inquiry_scan_type= Arc::new(ReadInquiryScanTypeData {});let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::ReadInquiryScanType(read_inquiry_scan_type),});let command= Arc::new(CommandData {op_code: OpCode::ReadInquiryScanType, child: CommandDataChild::DiscoveryCommand(discovery_command),});ReadInquiryScanTypePacket::new(command)}
}
impl Into<CommandPacket> for ReadInquiryScanTypeBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for ReadInquiryScanTypeBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadInquiryScanTypeCompleteData {status: ErrorCode, inquiry_scan_type: InquiryScanType, }
#[derive(Debug, Clone)] pub struct ReadInquiryScanTypeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_inquiry_scan_type_complete: Arc<ReadInquiryScanTypeCompleteData>,}
#[derive(Debug)] pub struct ReadInquiryScanTypeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub inquiry_scan_type: InquiryScanType, }
impl ReadInquiryScanTypeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadInquiryScanTypeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ReadInquiryScanTypeComplete".to_string(),    field: "inquiry_scan_type".to_string(),    wanted: 7,    got: bytes.len()});}let inquiry_scan_type = u8::from_le_bytes([bytes[6]]);let inquiry_scan_type = InquiryScanType::from_u8(inquiry_scan_type).unwrap();Ok(Self {status, inquiry_scan_type, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let inquiry_scan_type = self.inquiry_scan_type.to_u8().unwrap();buffer[6..7].copy_from_slice(&inquiry_scan_type.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for ReadInquiryScanTypeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadInquiryScanTypeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_inquiry_scan_type_complete = match &command_complete.child {CommandCompleteDataChild::ReadInquiryScanTypeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadInquiryScanTypeComplete"),};Self {event,command_complete,read_inquiry_scan_type_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_inquiry_scan_type_complete.as_ref().status}
pub fn get_inquiry_scan_type(&self) -> InquiryScanType{ self.read_inquiry_scan_type_complete.as_ref().inquiry_scan_type}
}
impl Into<EventPacket> for ReadInquiryScanTypeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadInquiryScanTypeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadInquiryScanTypeCompleteBuilder {pub fn build(self) -> ReadInquiryScanTypeCompletePacket {let read_inquiry_scan_type_complete= Arc::new(ReadInquiryScanTypeCompleteData {status: self.status, inquiry_scan_type: self.inquiry_scan_type, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadInquiryScanType, child: CommandCompleteDataChild::ReadInquiryScanTypeComplete(read_inquiry_scan_type_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadInquiryScanTypeCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadInquiryScanTypeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadInquiryScanTypeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WriteInquiryScanTypeData {inquiry_scan_type: InquiryScanType, }
#[derive(Debug, Clone)] pub struct WriteInquiryScanTypePacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,write_inquiry_scan_type: Arc<WriteInquiryScanTypeData>,}
#[derive(Debug)] pub struct WriteInquiryScanTypeBuilder {pub inquiry_scan_type: InquiryScanType, }
impl WriteInquiryScanTypeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "WriteInquiryScanType".to_string(),    field: "inquiry_scan_type".to_string(),    wanted: 4,    got: bytes.len()});}let inquiry_scan_type = u8::from_le_bytes([bytes[3]]);let inquiry_scan_type = InquiryScanType::from_u8(inquiry_scan_type).unwrap();Ok(Self {inquiry_scan_type, })
}
fn write_to(&self, buffer: &mut BytesMut) {let inquiry_scan_type = self.inquiry_scan_type.to_u8().unwrap();buffer[3..4].copy_from_slice(&inquiry_scan_type.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for WriteInquiryScanTypePacket { type ResponseType = WriteInquiryScanTypeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteInquiryScanTypeCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteInquiryScanTypePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteInquiryScanTypePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let write_inquiry_scan_type = match &discovery_command.child {DiscoveryCommandDataChild::WriteInquiryScanType(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteInquiryScanType"),};Self {command,discovery_command,write_inquiry_scan_type,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_inquiry_scan_type(&self) -> InquiryScanType{ self.write_inquiry_scan_type.as_ref().inquiry_scan_type}
}
impl Into<CommandPacket> for WriteInquiryScanTypePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for WriteInquiryScanTypePacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for WriteInquiryScanTypeBuilder { type ResponseType = WriteInquiryScanTypeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteInquiryScanTypeCompletePacket::new(pkt.event.clone()) }}impl WriteInquiryScanTypeBuilder {pub fn build(self) -> WriteInquiryScanTypePacket {let write_inquiry_scan_type= Arc::new(WriteInquiryScanTypeData {inquiry_scan_type: self.inquiry_scan_type, });let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::WriteInquiryScanType(write_inquiry_scan_type),});let command= Arc::new(CommandData {op_code: OpCode::WriteInquiryScanType, child: CommandDataChild::DiscoveryCommand(discovery_command),});WriteInquiryScanTypePacket::new(command)}
}
impl Into<CommandPacket> for WriteInquiryScanTypeBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for WriteInquiryScanTypeBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}


#[derive(Debug)] struct WriteInquiryScanTypeCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WriteInquiryScanTypeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_inquiry_scan_type_complete: Arc<WriteInquiryScanTypeCompleteData>,}
#[derive(Debug)] pub struct WriteInquiryScanTypeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WriteInquiryScanTypeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteInquiryScanTypeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WriteInquiryScanTypeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteInquiryScanTypeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_inquiry_scan_type_complete = match &command_complete.child {CommandCompleteDataChild::WriteInquiryScanTypeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteInquiryScanTypeComplete"),};Self {event,command_complete,write_inquiry_scan_type_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_inquiry_scan_type_complete.as_ref().status}
}
impl Into<EventPacket> for WriteInquiryScanTypeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteInquiryScanTypeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteInquiryScanTypeCompleteBuilder {pub fn build(self) -> WriteInquiryScanTypeCompletePacket {let write_inquiry_scan_type_complete= Arc::new(WriteInquiryScanTypeCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteInquiryScanType, child: CommandCompleteDataChild::WriteInquiryScanTypeComplete(write_inquiry_scan_type_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteInquiryScanTypeCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteInquiryScanTypeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteInquiryScanTypeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadInquiryModeData {}
#[derive(Debug, Clone)] pub struct ReadInquiryModePacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,read_inquiry_mode: Arc<ReadInquiryModeData>,}
#[derive(Debug)] pub struct ReadInquiryModeBuilder {}
impl ReadInquiryModeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadInquiryModePacket { type ResponseType = ReadInquiryModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadInquiryModeCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadInquiryModePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadInquiryModePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let read_inquiry_mode = match &discovery_command.child {DiscoveryCommandDataChild::ReadInquiryMode(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadInquiryMode"),};Self {command,discovery_command,read_inquiry_mode,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadInquiryModePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for ReadInquiryModePacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for ReadInquiryModeBuilder { type ResponseType = ReadInquiryModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadInquiryModeCompletePacket::new(pkt.event.clone()) }}impl ReadInquiryModeBuilder {pub fn build(self) -> ReadInquiryModePacket {let read_inquiry_mode= Arc::new(ReadInquiryModeData {});let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::ReadInquiryMode(read_inquiry_mode),});let command= Arc::new(CommandData {op_code: OpCode::ReadInquiryMode, child: CommandDataChild::DiscoveryCommand(discovery_command),});ReadInquiryModePacket::new(command)}
}
impl Into<CommandPacket> for ReadInquiryModeBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for ReadInquiryModeBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadInquiryModeCompleteData {status: ErrorCode, inquiry_mode: InquiryMode, }
#[derive(Debug, Clone)] pub struct ReadInquiryModeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_inquiry_mode_complete: Arc<ReadInquiryModeCompleteData>,}
#[derive(Debug)] pub struct ReadInquiryModeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub inquiry_mode: InquiryMode, }
impl ReadInquiryModeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadInquiryModeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ReadInquiryModeComplete".to_string(),    field: "inquiry_mode".to_string(),    wanted: 7,    got: bytes.len()});}let inquiry_mode = u8::from_le_bytes([bytes[6]]);let inquiry_mode = InquiryMode::from_u8(inquiry_mode).unwrap();Ok(Self {status, inquiry_mode, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let inquiry_mode = self.inquiry_mode.to_u8().unwrap();buffer[6..7].copy_from_slice(&inquiry_mode.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for ReadInquiryModeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadInquiryModeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_inquiry_mode_complete = match &command_complete.child {CommandCompleteDataChild::ReadInquiryModeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadInquiryModeComplete"),};Self {event,command_complete,read_inquiry_mode_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_inquiry_mode_complete.as_ref().status}
pub fn get_inquiry_mode(&self) -> InquiryMode{ self.read_inquiry_mode_complete.as_ref().inquiry_mode}
}
impl Into<EventPacket> for ReadInquiryModeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadInquiryModeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadInquiryModeCompleteBuilder {pub fn build(self) -> ReadInquiryModeCompletePacket {let read_inquiry_mode_complete= Arc::new(ReadInquiryModeCompleteData {status: self.status, inquiry_mode: self.inquiry_mode, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadInquiryMode, child: CommandCompleteDataChild::ReadInquiryModeComplete(read_inquiry_mode_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadInquiryModeCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadInquiryModeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadInquiryModeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WriteInquiryModeData {inquiry_mode: InquiryMode, }
#[derive(Debug, Clone)] pub struct WriteInquiryModePacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,write_inquiry_mode: Arc<WriteInquiryModeData>,}
#[derive(Debug)] pub struct WriteInquiryModeBuilder {pub inquiry_mode: InquiryMode, }
impl WriteInquiryModeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "WriteInquiryMode".to_string(),    field: "inquiry_mode".to_string(),    wanted: 4,    got: bytes.len()});}let inquiry_mode = u8::from_le_bytes([bytes[3]]);let inquiry_mode = InquiryMode::from_u8(inquiry_mode).unwrap();Ok(Self {inquiry_mode, })
}
fn write_to(&self, buffer: &mut BytesMut) {let inquiry_mode = self.inquiry_mode.to_u8().unwrap();buffer[3..4].copy_from_slice(&inquiry_mode.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for WriteInquiryModePacket { type ResponseType = WriteInquiryModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteInquiryModeCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteInquiryModePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteInquiryModePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let write_inquiry_mode = match &discovery_command.child {DiscoveryCommandDataChild::WriteInquiryMode(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteInquiryMode"),};Self {command,discovery_command,write_inquiry_mode,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_inquiry_mode(&self) -> InquiryMode{ self.write_inquiry_mode.as_ref().inquiry_mode}
}
impl Into<CommandPacket> for WriteInquiryModePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for WriteInquiryModePacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for WriteInquiryModeBuilder { type ResponseType = WriteInquiryModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteInquiryModeCompletePacket::new(pkt.event.clone()) }}impl WriteInquiryModeBuilder {pub fn build(self) -> WriteInquiryModePacket {let write_inquiry_mode= Arc::new(WriteInquiryModeData {inquiry_mode: self.inquiry_mode, });let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::WriteInquiryMode(write_inquiry_mode),});let command= Arc::new(CommandData {op_code: OpCode::WriteInquiryMode, child: CommandDataChild::DiscoveryCommand(discovery_command),});WriteInquiryModePacket::new(command)}
}
impl Into<CommandPacket> for WriteInquiryModeBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for WriteInquiryModeBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}


#[derive(Debug)] struct WriteInquiryModeCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WriteInquiryModeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_inquiry_mode_complete: Arc<WriteInquiryModeCompleteData>,}
#[derive(Debug)] pub struct WriteInquiryModeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WriteInquiryModeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteInquiryModeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WriteInquiryModeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteInquiryModeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_inquiry_mode_complete = match &command_complete.child {CommandCompleteDataChild::WriteInquiryModeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteInquiryModeComplete"),};Self {event,command_complete,write_inquiry_mode_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_inquiry_mode_complete.as_ref().status}
}
impl Into<EventPacket> for WriteInquiryModeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteInquiryModeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteInquiryModeCompleteBuilder {pub fn build(self) -> WriteInquiryModeCompletePacket {let write_inquiry_mode_complete= Arc::new(WriteInquiryModeCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteInquiryMode, child: CommandCompleteDataChild::WriteInquiryModeComplete(write_inquiry_mode_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteInquiryModeCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteInquiryModeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteInquiryModeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadPageScanTypeData {}
#[derive(Debug, Clone)] pub struct ReadPageScanTypePacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,read_page_scan_type: Arc<ReadPageScanTypeData>,}
#[derive(Debug)] pub struct ReadPageScanTypeBuilder {}
impl ReadPageScanTypeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadPageScanTypePacket { type ResponseType = ReadPageScanTypeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadPageScanTypeCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadPageScanTypePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadPageScanTypePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let read_page_scan_type = match &discovery_command.child {DiscoveryCommandDataChild::ReadPageScanType(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadPageScanType"),};Self {command,discovery_command,read_page_scan_type,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadPageScanTypePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for ReadPageScanTypePacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for ReadPageScanTypeBuilder { type ResponseType = ReadPageScanTypeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadPageScanTypeCompletePacket::new(pkt.event.clone()) }}impl ReadPageScanTypeBuilder {pub fn build(self) -> ReadPageScanTypePacket {let read_page_scan_type= Arc::new(ReadPageScanTypeData {});let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::ReadPageScanType(read_page_scan_type),});let command= Arc::new(CommandData {op_code: OpCode::ReadPageScanType, child: CommandDataChild::DiscoveryCommand(discovery_command),});ReadPageScanTypePacket::new(command)}
}
impl Into<CommandPacket> for ReadPageScanTypeBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for ReadPageScanTypeBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadPageScanTypeCompleteData {status: ErrorCode, page_scan_type: PageScanType, }
#[derive(Debug, Clone)] pub struct ReadPageScanTypeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_page_scan_type_complete: Arc<ReadPageScanTypeCompleteData>,}
#[derive(Debug)] pub struct ReadPageScanTypeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub page_scan_type: PageScanType, }
impl ReadPageScanTypeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadPageScanTypeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ReadPageScanTypeComplete".to_string(),    field: "page_scan_type".to_string(),    wanted: 7,    got: bytes.len()});}let page_scan_type = u8::from_le_bytes([bytes[6]]);let page_scan_type = PageScanType::from_u8(page_scan_type).unwrap();Ok(Self {status, page_scan_type, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let page_scan_type = self.page_scan_type.to_u8().unwrap();buffer[6..7].copy_from_slice(&page_scan_type.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for ReadPageScanTypeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadPageScanTypeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_page_scan_type_complete = match &command_complete.child {CommandCompleteDataChild::ReadPageScanTypeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadPageScanTypeComplete"),};Self {event,command_complete,read_page_scan_type_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_page_scan_type_complete.as_ref().status}
pub fn get_page_scan_type(&self) -> PageScanType{ self.read_page_scan_type_complete.as_ref().page_scan_type}
}
impl Into<EventPacket> for ReadPageScanTypeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadPageScanTypeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadPageScanTypeCompleteBuilder {pub fn build(self) -> ReadPageScanTypeCompletePacket {let read_page_scan_type_complete= Arc::new(ReadPageScanTypeCompleteData {status: self.status, page_scan_type: self.page_scan_type, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadPageScanType, child: CommandCompleteDataChild::ReadPageScanTypeComplete(read_page_scan_type_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadPageScanTypeCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadPageScanTypeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadPageScanTypeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WritePageScanTypeData {page_scan_type: PageScanType, }
#[derive(Debug, Clone)] pub struct WritePageScanTypePacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,write_page_scan_type: Arc<WritePageScanTypeData>,}
#[derive(Debug)] pub struct WritePageScanTypeBuilder {pub page_scan_type: PageScanType, }
impl WritePageScanTypeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "WritePageScanType".to_string(),    field: "page_scan_type".to_string(),    wanted: 4,    got: bytes.len()});}let page_scan_type = u8::from_le_bytes([bytes[3]]);let page_scan_type = PageScanType::from_u8(page_scan_type).unwrap();Ok(Self {page_scan_type, })
}
fn write_to(&self, buffer: &mut BytesMut) {let page_scan_type = self.page_scan_type.to_u8().unwrap();buffer[3..4].copy_from_slice(&page_scan_type.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for WritePageScanTypePacket { type ResponseType = WritePageScanTypeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WritePageScanTypeCompletePacket::new(pkt.event.clone()) }}impl Packet for WritePageScanTypePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WritePageScanTypePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let write_page_scan_type = match &discovery_command.child {DiscoveryCommandDataChild::WritePageScanType(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WritePageScanType"),};Self {command,discovery_command,write_page_scan_type,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_page_scan_type(&self) -> PageScanType{ self.write_page_scan_type.as_ref().page_scan_type}
}
impl Into<CommandPacket> for WritePageScanTypePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for WritePageScanTypePacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for WritePageScanTypeBuilder { type ResponseType = WritePageScanTypeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WritePageScanTypeCompletePacket::new(pkt.event.clone()) }}impl WritePageScanTypeBuilder {pub fn build(self) -> WritePageScanTypePacket {let write_page_scan_type= Arc::new(WritePageScanTypeData {page_scan_type: self.page_scan_type, });let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::WritePageScanType(write_page_scan_type),});let command= Arc::new(CommandData {op_code: OpCode::WritePageScanType, child: CommandDataChild::DiscoveryCommand(discovery_command),});WritePageScanTypePacket::new(command)}
}
impl Into<CommandPacket> for WritePageScanTypeBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for WritePageScanTypeBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}


#[derive(Debug)] struct WritePageScanTypeCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WritePageScanTypeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_page_scan_type_complete: Arc<WritePageScanTypeCompleteData>,}
#[derive(Debug)] pub struct WritePageScanTypeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WritePageScanTypeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WritePageScanTypeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WritePageScanTypeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WritePageScanTypeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_page_scan_type_complete = match &command_complete.child {CommandCompleteDataChild::WritePageScanTypeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WritePageScanTypeComplete"),};Self {event,command_complete,write_page_scan_type_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_page_scan_type_complete.as_ref().status}
}
impl Into<EventPacket> for WritePageScanTypeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WritePageScanTypeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WritePageScanTypeCompleteBuilder {pub fn build(self) -> WritePageScanTypeCompletePacket {let write_page_scan_type_complete= Arc::new(WritePageScanTypeCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WritePageScanType, child: CommandCompleteDataChild::WritePageScanTypeComplete(write_page_scan_type_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WritePageScanTypeCompletePacket::new(event)}
}
impl Into<EventPacket> for WritePageScanTypeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WritePageScanTypeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadAfhChannelAssessmentModeData {}
#[derive(Debug, Clone)] pub struct ReadAfhChannelAssessmentModePacket {command: Arc<CommandData>,read_afh_channel_assessment_mode: Arc<ReadAfhChannelAssessmentModeData>,}
#[derive(Debug)] pub struct ReadAfhChannelAssessmentModeBuilder {}
impl ReadAfhChannelAssessmentModeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadAfhChannelAssessmentModePacket { type ResponseType = ReadAfhChannelAssessmentModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadAfhChannelAssessmentModeCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadAfhChannelAssessmentModePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadAfhChannelAssessmentModePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let read_afh_channel_assessment_mode = match &command.child {CommandDataChild::ReadAfhChannelAssessmentMode(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadAfhChannelAssessmentMode"),};Self {command,read_afh_channel_assessment_mode,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadAfhChannelAssessmentModePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for ReadAfhChannelAssessmentModeBuilder { type ResponseType = ReadAfhChannelAssessmentModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadAfhChannelAssessmentModeCompletePacket::new(pkt.event.clone()) }}impl ReadAfhChannelAssessmentModeBuilder {pub fn build(self) -> ReadAfhChannelAssessmentModePacket {let read_afh_channel_assessment_mode= Arc::new(ReadAfhChannelAssessmentModeData {});let command= Arc::new(CommandData {op_code: OpCode::ReadAfhChannelAssessmentMode, child: CommandDataChild::ReadAfhChannelAssessmentMode(read_afh_channel_assessment_mode),});ReadAfhChannelAssessmentModePacket::new(command)}
}
impl Into<CommandPacket> for ReadAfhChannelAssessmentModeBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadAfhChannelAssessmentModeCompleteData {status: ErrorCode, controller_channel_assessment: Enable, }
#[derive(Debug, Clone)] pub struct ReadAfhChannelAssessmentModeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_afh_channel_assessment_mode_complete: Arc<ReadAfhChannelAssessmentModeCompleteData>,}
#[derive(Debug)] pub struct ReadAfhChannelAssessmentModeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub controller_channel_assessment: Enable, }
impl ReadAfhChannelAssessmentModeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadAfhChannelAssessmentModeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ReadAfhChannelAssessmentModeComplete".to_string(),    field: "controller_channel_assessment".to_string(),    wanted: 7,    got: bytes.len()});}let controller_channel_assessment = u8::from_le_bytes([bytes[6]]);let controller_channel_assessment = Enable::from_u8(controller_channel_assessment).unwrap();Ok(Self {status, controller_channel_assessment, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let controller_channel_assessment = self.controller_channel_assessment.to_u8().unwrap();buffer[6..7].copy_from_slice(&controller_channel_assessment.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for ReadAfhChannelAssessmentModeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadAfhChannelAssessmentModeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_afh_channel_assessment_mode_complete = match &command_complete.child {CommandCompleteDataChild::ReadAfhChannelAssessmentModeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadAfhChannelAssessmentModeComplete"),};Self {event,command_complete,read_afh_channel_assessment_mode_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_afh_channel_assessment_mode_complete.as_ref().status}
pub fn get_controller_channel_assessment(&self) -> Enable{ self.read_afh_channel_assessment_mode_complete.as_ref().controller_channel_assessment}
}
impl Into<EventPacket> for ReadAfhChannelAssessmentModeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadAfhChannelAssessmentModeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadAfhChannelAssessmentModeCompleteBuilder {pub fn build(self) -> ReadAfhChannelAssessmentModeCompletePacket {let read_afh_channel_assessment_mode_complete= Arc::new(ReadAfhChannelAssessmentModeCompleteData {status: self.status, controller_channel_assessment: self.controller_channel_assessment, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadAfhChannelAssessmentMode, child: CommandCompleteDataChild::ReadAfhChannelAssessmentModeComplete(read_afh_channel_assessment_mode_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadAfhChannelAssessmentModeCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadAfhChannelAssessmentModeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadAfhChannelAssessmentModeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WriteAfhChannelAssessmentModeData {controller_channel_assessment: Enable, }
#[derive(Debug, Clone)] pub struct WriteAfhChannelAssessmentModePacket {command: Arc<CommandData>,write_afh_channel_assessment_mode: Arc<WriteAfhChannelAssessmentModeData>,}
#[derive(Debug)] pub struct WriteAfhChannelAssessmentModeBuilder {pub controller_channel_assessment: Enable, }
impl WriteAfhChannelAssessmentModeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "WriteAfhChannelAssessmentMode".to_string(),    field: "controller_channel_assessment".to_string(),    wanted: 4,    got: bytes.len()});}let controller_channel_assessment = u8::from_le_bytes([bytes[3]]);let controller_channel_assessment = Enable::from_u8(controller_channel_assessment).unwrap();Ok(Self {controller_channel_assessment, })
}
fn write_to(&self, buffer: &mut BytesMut) {let controller_channel_assessment = self.controller_channel_assessment.to_u8().unwrap();buffer[3..4].copy_from_slice(&controller_channel_assessment.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for WriteAfhChannelAssessmentModePacket { type ResponseType = WriteAfhChannelAssessmentModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteAfhChannelAssessmentModeCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteAfhChannelAssessmentModePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteAfhChannelAssessmentModePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let write_afh_channel_assessment_mode = match &command.child {CommandDataChild::WriteAfhChannelAssessmentMode(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteAfhChannelAssessmentMode"),};Self {command,write_afh_channel_assessment_mode,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_controller_channel_assessment(&self) -> Enable{ self.write_afh_channel_assessment_mode.as_ref().controller_channel_assessment}
}
impl Into<CommandPacket> for WriteAfhChannelAssessmentModePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for WriteAfhChannelAssessmentModeBuilder { type ResponseType = WriteAfhChannelAssessmentModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteAfhChannelAssessmentModeCompletePacket::new(pkt.event.clone()) }}impl WriteAfhChannelAssessmentModeBuilder {pub fn build(self) -> WriteAfhChannelAssessmentModePacket {let write_afh_channel_assessment_mode= Arc::new(WriteAfhChannelAssessmentModeData {controller_channel_assessment: self.controller_channel_assessment, });let command= Arc::new(CommandData {op_code: OpCode::WriteAfhChannelAssessmentMode, child: CommandDataChild::WriteAfhChannelAssessmentMode(write_afh_channel_assessment_mode),});WriteAfhChannelAssessmentModePacket::new(command)}
}
impl Into<CommandPacket> for WriteAfhChannelAssessmentModeBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct WriteAfhChannelAssessmentModeCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WriteAfhChannelAssessmentModeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_afh_channel_assessment_mode_complete: Arc<WriteAfhChannelAssessmentModeCompleteData>,}
#[derive(Debug)] pub struct WriteAfhChannelAssessmentModeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WriteAfhChannelAssessmentModeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteAfhChannelAssessmentModeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WriteAfhChannelAssessmentModeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteAfhChannelAssessmentModeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_afh_channel_assessment_mode_complete = match &command_complete.child {CommandCompleteDataChild::WriteAfhChannelAssessmentModeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteAfhChannelAssessmentModeComplete"),};Self {event,command_complete,write_afh_channel_assessment_mode_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_afh_channel_assessment_mode_complete.as_ref().status}
}
impl Into<EventPacket> for WriteAfhChannelAssessmentModeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteAfhChannelAssessmentModeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteAfhChannelAssessmentModeCompleteBuilder {pub fn build(self) -> WriteAfhChannelAssessmentModeCompletePacket {let write_afh_channel_assessment_mode_complete= Arc::new(WriteAfhChannelAssessmentModeCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteAfhChannelAssessmentMode, child: CommandCompleteDataChild::WriteAfhChannelAssessmentModeComplete(write_afh_channel_assessment_mode_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteAfhChannelAssessmentModeCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteAfhChannelAssessmentModeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteAfhChannelAssessmentModeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadExtendedInquiryResponseData {}
#[derive(Debug, Clone)] pub struct ReadExtendedInquiryResponsePacket {command: Arc<CommandData>,read_extended_inquiry_response: Arc<ReadExtendedInquiryResponseData>,}
#[derive(Debug)] pub struct ReadExtendedInquiryResponseBuilder {}
impl ReadExtendedInquiryResponseData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadExtendedInquiryResponsePacket { type ResponseType = ReadExtendedInquiryResponseCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadExtendedInquiryResponseCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadExtendedInquiryResponsePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadExtendedInquiryResponsePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let read_extended_inquiry_response = match &command.child {CommandDataChild::ReadExtendedInquiryResponse(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadExtendedInquiryResponse"),};Self {command,read_extended_inquiry_response,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadExtendedInquiryResponsePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for ReadExtendedInquiryResponseBuilder { type ResponseType = ReadExtendedInquiryResponseCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadExtendedInquiryResponseCompletePacket::new(pkt.event.clone()) }}impl ReadExtendedInquiryResponseBuilder {pub fn build(self) -> ReadExtendedInquiryResponsePacket {let read_extended_inquiry_response= Arc::new(ReadExtendedInquiryResponseData {});let command= Arc::new(CommandData {op_code: OpCode::ReadExtendedInquiryResponse, child: CommandDataChild::ReadExtendedInquiryResponse(read_extended_inquiry_response),});ReadExtendedInquiryResponsePacket::new(command)}
}
impl Into<CommandPacket> for ReadExtendedInquiryResponseBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadExtendedInquiryResponseCompleteData {status: ErrorCode, fec_required: FecRequired, extended_inquiry_response: Vec::<GapData>, }
#[derive(Debug, Clone)] pub struct ReadExtendedInquiryResponseCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_extended_inquiry_response_complete: Arc<ReadExtendedInquiryResponseCompleteData>,}
#[derive(Debug)] pub struct ReadExtendedInquiryResponseCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub fec_required: FecRequired, pub extended_inquiry_response: Vec::<GapData>, }
impl ReadExtendedInquiryResponseCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadExtendedInquiryResponseComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ReadExtendedInquiryResponseComplete".to_string(),    field: "fec_required".to_string(),    wanted: 7,    got: bytes.len()});}let fec_required = u8::from_le_bytes([bytes[6]]);let fec_required = FecRequired::from_u8(fec_required).unwrap();let mut extended_inquiry_response: Vec::<GapData> = Vec::new();let mut parsable_ = &bytes[7..];while parsable_.len() > 0 { match GapData::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];extended_inquiry_response.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {status, fec_required, extended_inquiry_response, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let fec_required = self.fec_required.to_u8().unwrap();buffer[6..7].copy_from_slice(&fec_required.to_le_bytes()[0..1]);let mut vec_buffer_ = &mut buffer[7..];for e_ in &self.extended_inquiry_response { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;let ret = ret + self.extended_inquiry_response.iter().fold(0, |acc, x| acc + x.get_total_size());ret}
}
impl Packet for ReadExtendedInquiryResponseCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadExtendedInquiryResponseCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_extended_inquiry_response_complete = match &command_complete.child {CommandCompleteDataChild::ReadExtendedInquiryResponseComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadExtendedInquiryResponseComplete"),};Self {event,command_complete,read_extended_inquiry_response_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_extended_inquiry_response_complete.as_ref().status}
pub fn get_fec_required(&self) -> FecRequired{ self.read_extended_inquiry_response_complete.as_ref().fec_required}
pub fn get_extended_inquiry_response(&self) -> &Vec::<GapData>{ &self.read_extended_inquiry_response_complete.as_ref().extended_inquiry_response}
}
impl Into<EventPacket> for ReadExtendedInquiryResponseCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadExtendedInquiryResponseCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadExtendedInquiryResponseCompleteBuilder {pub fn build(self) -> ReadExtendedInquiryResponseCompletePacket {let read_extended_inquiry_response_complete= Arc::new(ReadExtendedInquiryResponseCompleteData {status: self.status, fec_required: self.fec_required, extended_inquiry_response: self.extended_inquiry_response, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadExtendedInquiryResponse, child: CommandCompleteDataChild::ReadExtendedInquiryResponseComplete(read_extended_inquiry_response_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadExtendedInquiryResponseCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadExtendedInquiryResponseCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadExtendedInquiryResponseCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WriteExtendedInquiryResponseData {fec_required: FecRequired, extended_inquiry_response: Vec::<GapData>, }
#[derive(Debug, Clone)] pub struct WriteExtendedInquiryResponsePacket {command: Arc<CommandData>,write_extended_inquiry_response: Arc<WriteExtendedInquiryResponseData>,}
#[derive(Debug)] pub struct WriteExtendedInquiryResponseBuilder {pub fec_required: FecRequired, pub extended_inquiry_response: Vec::<GapData>, }
impl WriteExtendedInquiryResponseData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "WriteExtendedInquiryResponse".to_string(),    field: "fec_required".to_string(),    wanted: 4,    got: bytes.len()});}let fec_required = u8::from_le_bytes([bytes[3]]);let fec_required = FecRequired::from_u8(fec_required).unwrap();let mut extended_inquiry_response: Vec::<GapData> = Vec::new();let mut parsable_ = &bytes[4..];while parsable_.len() > 0 { match GapData::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];extended_inquiry_response.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {fec_required, extended_inquiry_response, })
}
fn write_to(&self, buffer: &mut BytesMut) {let fec_required = self.fec_required.to_u8().unwrap();buffer[3..4].copy_from_slice(&fec_required.to_le_bytes()[0..1]);let mut vec_buffer_ = &mut buffer[4..];for e_ in &self.extended_inquiry_response { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;/* Skipping extended_inquiry_response since it is padded */let ret = ret + 241;ret}
}
impl CommandExpectations for WriteExtendedInquiryResponsePacket { type ResponseType = WriteExtendedInquiryResponseCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteExtendedInquiryResponseCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteExtendedInquiryResponsePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteExtendedInquiryResponsePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let write_extended_inquiry_response = match &command.child {CommandDataChild::WriteExtendedInquiryResponse(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteExtendedInquiryResponse"),};Self {command,write_extended_inquiry_response,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_fec_required(&self) -> FecRequired{ self.write_extended_inquiry_response.as_ref().fec_required}
pub fn get_extended_inquiry_response(&self) -> &Vec::<GapData>{ &self.write_extended_inquiry_response.as_ref().extended_inquiry_response}
}
impl Into<CommandPacket> for WriteExtendedInquiryResponsePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for WriteExtendedInquiryResponseBuilder { type ResponseType = WriteExtendedInquiryResponseCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteExtendedInquiryResponseCompletePacket::new(pkt.event.clone()) }}impl WriteExtendedInquiryResponseBuilder {pub fn build(self) -> WriteExtendedInquiryResponsePacket {let write_extended_inquiry_response= Arc::new(WriteExtendedInquiryResponseData {fec_required: self.fec_required, extended_inquiry_response: self.extended_inquiry_response, });let command= Arc::new(CommandData {op_code: OpCode::WriteExtendedInquiryResponse, child: CommandDataChild::WriteExtendedInquiryResponse(write_extended_inquiry_response),});WriteExtendedInquiryResponsePacket::new(command)}
}
impl Into<CommandPacket> for WriteExtendedInquiryResponseBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct WriteExtendedInquiryResponseCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WriteExtendedInquiryResponseCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_extended_inquiry_response_complete: Arc<WriteExtendedInquiryResponseCompleteData>,}
#[derive(Debug)] pub struct WriteExtendedInquiryResponseCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WriteExtendedInquiryResponseCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteExtendedInquiryResponseComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WriteExtendedInquiryResponseCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteExtendedInquiryResponseCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_extended_inquiry_response_complete = match &command_complete.child {CommandCompleteDataChild::WriteExtendedInquiryResponseComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteExtendedInquiryResponseComplete"),};Self {event,command_complete,write_extended_inquiry_response_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_extended_inquiry_response_complete.as_ref().status}
}
impl Into<EventPacket> for WriteExtendedInquiryResponseCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteExtendedInquiryResponseCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteExtendedInquiryResponseCompleteBuilder {pub fn build(self) -> WriteExtendedInquiryResponseCompletePacket {let write_extended_inquiry_response_complete= Arc::new(WriteExtendedInquiryResponseCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteExtendedInquiryResponse, child: CommandCompleteDataChild::WriteExtendedInquiryResponseComplete(write_extended_inquiry_response_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteExtendedInquiryResponseCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteExtendedInquiryResponseCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteExtendedInquiryResponseCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct RefreshEncryptionKeyData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct RefreshEncryptionKeyPacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,refresh_encryption_key: Arc<RefreshEncryptionKeyData>,}
#[derive(Debug)] pub struct RefreshEncryptionKeyBuilder {pub connection_handle: u16, }
impl RefreshEncryptionKeyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "RefreshEncryptionKey".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for RefreshEncryptionKeyPacket { type ResponseType = RefreshEncryptionKeyStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { RefreshEncryptionKeyStatusPacket::new(pkt.event.clone()) }}impl Packet for RefreshEncryptionKeyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl RefreshEncryptionKeyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let refresh_encryption_key = match &security_command.child {SecurityCommandDataChild::RefreshEncryptionKey(value) => (*value).clone(),_ => panic!("inconsistent state - child was not RefreshEncryptionKey"),};Self {command,security_command,refresh_encryption_key,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.refresh_encryption_key.as_ref().connection_handle}
}
impl Into<CommandPacket> for RefreshEncryptionKeyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for RefreshEncryptionKeyPacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for RefreshEncryptionKeyBuilder { type ResponseType = RefreshEncryptionKeyStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { RefreshEncryptionKeyStatusPacket::new(pkt.event.clone()) }}impl RefreshEncryptionKeyBuilder {pub fn build(self) -> RefreshEncryptionKeyPacket {let refresh_encryption_key= Arc::new(RefreshEncryptionKeyData {connection_handle: self.connection_handle, });let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::RefreshEncryptionKey(refresh_encryption_key),});let command= Arc::new(CommandData {op_code: OpCode::RefreshEncryptionKey, child: CommandDataChild::SecurityCommand(security_command),});RefreshEncryptionKeyPacket::new(command)}
}
impl Into<CommandPacket> for RefreshEncryptionKeyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for RefreshEncryptionKeyBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct RefreshEncryptionKeyStatusData {}
#[derive(Debug, Clone)] pub struct RefreshEncryptionKeyStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,refresh_encryption_key_status: Arc<RefreshEncryptionKeyStatusData>,}
#[derive(Debug)] pub struct RefreshEncryptionKeyStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl RefreshEncryptionKeyStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for RefreshEncryptionKeyStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl RefreshEncryptionKeyStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let refresh_encryption_key_status = match &command_status.child {CommandStatusDataChild::RefreshEncryptionKeyStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not RefreshEncryptionKeyStatus"),};Self {event,command_status,refresh_encryption_key_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for RefreshEncryptionKeyStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for RefreshEncryptionKeyStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl RefreshEncryptionKeyStatusBuilder {pub fn build(self) -> RefreshEncryptionKeyStatusPacket {let refresh_encryption_key_status= Arc::new(RefreshEncryptionKeyStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::RefreshEncryptionKey, child: CommandStatusDataChild::RefreshEncryptionKeyStatus(refresh_encryption_key_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});RefreshEncryptionKeyStatusPacket::new(event)}
}
impl Into<EventPacket> for RefreshEncryptionKeyStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for RefreshEncryptionKeyStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct ReadSimplePairingModeData {}
#[derive(Debug, Clone)] pub struct ReadSimplePairingModePacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,read_simple_pairing_mode: Arc<ReadSimplePairingModeData>,}
#[derive(Debug)] pub struct ReadSimplePairingModeBuilder {}
impl ReadSimplePairingModeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadSimplePairingModePacket { type ResponseType = ReadSimplePairingModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadSimplePairingModeCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadSimplePairingModePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadSimplePairingModePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let read_simple_pairing_mode = match &security_command.child {SecurityCommandDataChild::ReadSimplePairingMode(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadSimplePairingMode"),};Self {command,security_command,read_simple_pairing_mode,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadSimplePairingModePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for ReadSimplePairingModePacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for ReadSimplePairingModeBuilder { type ResponseType = ReadSimplePairingModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadSimplePairingModeCompletePacket::new(pkt.event.clone()) }}impl ReadSimplePairingModeBuilder {pub fn build(self) -> ReadSimplePairingModePacket {let read_simple_pairing_mode= Arc::new(ReadSimplePairingModeData {});let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::ReadSimplePairingMode(read_simple_pairing_mode),});let command= Arc::new(CommandData {op_code: OpCode::ReadSimplePairingMode, child: CommandDataChild::SecurityCommand(security_command),});ReadSimplePairingModePacket::new(command)}
}
impl Into<CommandPacket> for ReadSimplePairingModeBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for ReadSimplePairingModeBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadSimplePairingModeCompleteData {status: ErrorCode, simple_pairing_mode: Enable, }
#[derive(Debug, Clone)] pub struct ReadSimplePairingModeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_simple_pairing_mode_complete: Arc<ReadSimplePairingModeCompleteData>,}
#[derive(Debug)] pub struct ReadSimplePairingModeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub simple_pairing_mode: Enable, }
impl ReadSimplePairingModeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadSimplePairingModeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ReadSimplePairingModeComplete".to_string(),    field: "simple_pairing_mode".to_string(),    wanted: 7,    got: bytes.len()});}let simple_pairing_mode = u8::from_le_bytes([bytes[6]]);let simple_pairing_mode = Enable::from_u8(simple_pairing_mode).unwrap();Ok(Self {status, simple_pairing_mode, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let simple_pairing_mode = self.simple_pairing_mode.to_u8().unwrap();buffer[6..7].copy_from_slice(&simple_pairing_mode.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for ReadSimplePairingModeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadSimplePairingModeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_simple_pairing_mode_complete = match &command_complete.child {CommandCompleteDataChild::ReadSimplePairingModeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadSimplePairingModeComplete"),};Self {event,command_complete,read_simple_pairing_mode_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_simple_pairing_mode_complete.as_ref().status}
pub fn get_simple_pairing_mode(&self) -> Enable{ self.read_simple_pairing_mode_complete.as_ref().simple_pairing_mode}
}
impl Into<EventPacket> for ReadSimplePairingModeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadSimplePairingModeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadSimplePairingModeCompleteBuilder {pub fn build(self) -> ReadSimplePairingModeCompletePacket {let read_simple_pairing_mode_complete= Arc::new(ReadSimplePairingModeCompleteData {status: self.status, simple_pairing_mode: self.simple_pairing_mode, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadSimplePairingMode, child: CommandCompleteDataChild::ReadSimplePairingModeComplete(read_simple_pairing_mode_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadSimplePairingModeCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadSimplePairingModeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadSimplePairingModeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WriteSimplePairingModeData {simple_pairing_mode: Enable, }
#[derive(Debug, Clone)] pub struct WriteSimplePairingModePacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,write_simple_pairing_mode: Arc<WriteSimplePairingModeData>,}
#[derive(Debug)] pub struct WriteSimplePairingModeBuilder {pub simple_pairing_mode: Enable, }
impl WriteSimplePairingModeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "WriteSimplePairingMode".to_string(),    field: "simple_pairing_mode".to_string(),    wanted: 4,    got: bytes.len()});}let simple_pairing_mode = u8::from_le_bytes([bytes[3]]);let simple_pairing_mode = Enable::from_u8(simple_pairing_mode).unwrap();Ok(Self {simple_pairing_mode, })
}
fn write_to(&self, buffer: &mut BytesMut) {let simple_pairing_mode = self.simple_pairing_mode.to_u8().unwrap();buffer[3..4].copy_from_slice(&simple_pairing_mode.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for WriteSimplePairingModePacket { type ResponseType = WriteSimplePairingModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteSimplePairingModeCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteSimplePairingModePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteSimplePairingModePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let write_simple_pairing_mode = match &security_command.child {SecurityCommandDataChild::WriteSimplePairingMode(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteSimplePairingMode"),};Self {command,security_command,write_simple_pairing_mode,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_simple_pairing_mode(&self) -> Enable{ self.write_simple_pairing_mode.as_ref().simple_pairing_mode}
}
impl Into<CommandPacket> for WriteSimplePairingModePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for WriteSimplePairingModePacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for WriteSimplePairingModeBuilder { type ResponseType = WriteSimplePairingModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteSimplePairingModeCompletePacket::new(pkt.event.clone()) }}impl WriteSimplePairingModeBuilder {pub fn build(self) -> WriteSimplePairingModePacket {let write_simple_pairing_mode= Arc::new(WriteSimplePairingModeData {simple_pairing_mode: self.simple_pairing_mode, });let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::WriteSimplePairingMode(write_simple_pairing_mode),});let command= Arc::new(CommandData {op_code: OpCode::WriteSimplePairingMode, child: CommandDataChild::SecurityCommand(security_command),});WriteSimplePairingModePacket::new(command)}
}
impl Into<CommandPacket> for WriteSimplePairingModeBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for WriteSimplePairingModeBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}
macro_rules! write_simple_pairing_mode_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::SecurityCommand(security_command_packet) => {match security_command_packet.specialize() {/* (2) */
SecurityCommandChild::WriteSimplePairingMode(packet) => {let rebuilder = WriteSimplePairingModeBuilder {simple_pairing_mode : packet.get_simple_pairing_mode(),};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse write_simple_pairing_mode{:02x?}", security_command_packet); }}}_ => {println!("Couldn't parse security_command{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}write_simple_pairing_mode_builder_tests! { write_simple_pairing_mode_builder_test_00: b"\x56\x0c\x01\x01",}


#[derive(Debug)] struct WriteSimplePairingModeCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WriteSimplePairingModeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_simple_pairing_mode_complete: Arc<WriteSimplePairingModeCompleteData>,}
#[derive(Debug)] pub struct WriteSimplePairingModeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WriteSimplePairingModeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteSimplePairingModeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WriteSimplePairingModeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteSimplePairingModeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_simple_pairing_mode_complete = match &command_complete.child {CommandCompleteDataChild::WriteSimplePairingModeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteSimplePairingModeComplete"),};Self {event,command_complete,write_simple_pairing_mode_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_simple_pairing_mode_complete.as_ref().status}
}
impl Into<EventPacket> for WriteSimplePairingModeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteSimplePairingModeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteSimplePairingModeCompleteBuilder {pub fn build(self) -> WriteSimplePairingModeCompletePacket {let write_simple_pairing_mode_complete= Arc::new(WriteSimplePairingModeCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteSimplePairingMode, child: CommandCompleteDataChild::WriteSimplePairingModeComplete(write_simple_pairing_mode_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteSimplePairingModeCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteSimplePairingModeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteSimplePairingModeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! write_simple_pairing_mode_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::WriteSimplePairingModeComplete(packet) => {let rebuilder = WriteSimplePairingModeCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse write_simple_pairing_mode_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}write_simple_pairing_mode_complete_builder_tests! { write_simple_pairing_mode_complete_builder_test_00: b"\x0e\x04\x01\x56\x0c\x00",}


#[derive(Debug)] struct ReadLocalOobDataData {}
#[derive(Debug, Clone)] pub struct ReadLocalOobDataPacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,read_local_oob_data: Arc<ReadLocalOobDataData>,}
#[derive(Debug)] pub struct ReadLocalOobDataBuilder {}
impl ReadLocalOobDataData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadLocalOobDataPacket { type ResponseType = ReadLocalOobDataCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLocalOobDataCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadLocalOobDataPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLocalOobDataPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let read_local_oob_data = match &security_command.child {SecurityCommandDataChild::ReadLocalOobData(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLocalOobData"),};Self {command,security_command,read_local_oob_data,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadLocalOobDataPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for ReadLocalOobDataPacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for ReadLocalOobDataBuilder { type ResponseType = ReadLocalOobDataCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLocalOobDataCompletePacket::new(pkt.event.clone()) }}impl ReadLocalOobDataBuilder {pub fn build(self) -> ReadLocalOobDataPacket {let read_local_oob_data= Arc::new(ReadLocalOobDataData {});let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::ReadLocalOobData(read_local_oob_data),});let command= Arc::new(CommandData {op_code: OpCode::ReadLocalOobData, child: CommandDataChild::SecurityCommand(security_command),});ReadLocalOobDataPacket::new(command)}
}
impl Into<CommandPacket> for ReadLocalOobDataBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for ReadLocalOobDataBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadLocalOobDataCompleteData {status: ErrorCode, c: [u8; 16], r: [u8; 16], }
#[derive(Debug, Clone)] pub struct ReadLocalOobDataCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_local_oob_data_complete: Arc<ReadLocalOobDataCompleteData>,}
#[derive(Debug)] pub struct ReadLocalOobDataCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub c: [u8; 16], pub r: [u8; 16], }
impl ReadLocalOobDataCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadLocalOobDataComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 22 { return Err(Error::InvalidLengthError{    obj: "ReadLocalOobDataComplete".to_string(),    field: "c".to_string(),    wanted: 22,    got: bytes.len()});}let c = bytes[6..22].try_into().unwrap();if bytes.len() < 38 { return Err(Error::InvalidLengthError{    obj: "ReadLocalOobDataComplete".to_string(),    field: "r".to_string(),    wanted: 38,    got: bytes.len()});}let r = bytes[22..38].try_into().unwrap();Ok(Self {status, c, r, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);&buffer[6..22].copy_from_slice(&self.c);&buffer[22..38].copy_from_slice(&self.r);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 33;ret}
}
impl Packet for ReadLocalOobDataCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLocalOobDataCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_local_oob_data_complete = match &command_complete.child {CommandCompleteDataChild::ReadLocalOobDataComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLocalOobDataComplete"),};Self {event,command_complete,read_local_oob_data_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_local_oob_data_complete.as_ref().status}
pub fn get_c(&self) -> &[u8; 16]{ &self.read_local_oob_data_complete.as_ref().c}
pub fn get_r(&self) -> &[u8; 16]{ &self.read_local_oob_data_complete.as_ref().r}
}
impl Into<EventPacket> for ReadLocalOobDataCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadLocalOobDataCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadLocalOobDataCompleteBuilder {pub fn build(self) -> ReadLocalOobDataCompletePacket {let read_local_oob_data_complete= Arc::new(ReadLocalOobDataCompleteData {status: self.status, c: self.c, r: self.r, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadLocalOobData, child: CommandCompleteDataChild::ReadLocalOobDataComplete(read_local_oob_data_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadLocalOobDataCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadLocalOobDataCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadLocalOobDataCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadInquiryResponseTransmitPowerLevelData {}
#[derive(Debug, Clone)] pub struct ReadInquiryResponseTransmitPowerLevelPacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,read_inquiry_response_transmit_power_level: Arc<ReadInquiryResponseTransmitPowerLevelData>,}
#[derive(Debug)] pub struct ReadInquiryResponseTransmitPowerLevelBuilder {}
impl ReadInquiryResponseTransmitPowerLevelData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadInquiryResponseTransmitPowerLevelPacket { type ResponseType = ReadInquiryResponseTransmitPowerLevelCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadInquiryResponseTransmitPowerLevelCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadInquiryResponseTransmitPowerLevelPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadInquiryResponseTransmitPowerLevelPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let read_inquiry_response_transmit_power_level = match &discovery_command.child {DiscoveryCommandDataChild::ReadInquiryResponseTransmitPowerLevel(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadInquiryResponseTransmitPowerLevel"),};Self {command,discovery_command,read_inquiry_response_transmit_power_level,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadInquiryResponseTransmitPowerLevelPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for ReadInquiryResponseTransmitPowerLevelPacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for ReadInquiryResponseTransmitPowerLevelBuilder { type ResponseType = ReadInquiryResponseTransmitPowerLevelCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadInquiryResponseTransmitPowerLevelCompletePacket::new(pkt.event.clone()) }}impl ReadInquiryResponseTransmitPowerLevelBuilder {pub fn build(self) -> ReadInquiryResponseTransmitPowerLevelPacket {let read_inquiry_response_transmit_power_level= Arc::new(ReadInquiryResponseTransmitPowerLevelData {});let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::ReadInquiryResponseTransmitPowerLevel(read_inquiry_response_transmit_power_level),});let command= Arc::new(CommandData {op_code: OpCode::ReadInquiryResponseTransmitPowerLevel, child: CommandDataChild::DiscoveryCommand(discovery_command),});ReadInquiryResponseTransmitPowerLevelPacket::new(command)}
}
impl Into<CommandPacket> for ReadInquiryResponseTransmitPowerLevelBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for ReadInquiryResponseTransmitPowerLevelBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadInquiryResponseTransmitPowerLevelCompleteData {status: ErrorCode, tx_power: u8, }
#[derive(Debug, Clone)] pub struct ReadInquiryResponseTransmitPowerLevelCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_inquiry_response_transmit_power_level_complete: Arc<ReadInquiryResponseTransmitPowerLevelCompleteData>,}
#[derive(Debug)] pub struct ReadInquiryResponseTransmitPowerLevelCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub tx_power: u8, }
impl ReadInquiryResponseTransmitPowerLevelCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadInquiryResponseTransmitPowerLevelComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ReadInquiryResponseTransmitPowerLevelComplete".to_string(),    field: "tx_power".to_string(),    wanted: 7,    got: bytes.len()});}let tx_power = u8::from_le_bytes([bytes[6]]);Ok(Self {status, tx_power, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let tx_power = self.tx_power;buffer[6..7].copy_from_slice(&tx_power.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for ReadInquiryResponseTransmitPowerLevelCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadInquiryResponseTransmitPowerLevelCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_inquiry_response_transmit_power_level_complete = match &command_complete.child {CommandCompleteDataChild::ReadInquiryResponseTransmitPowerLevelComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadInquiryResponseTransmitPowerLevelComplete"),};Self {event,command_complete,read_inquiry_response_transmit_power_level_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_inquiry_response_transmit_power_level_complete.as_ref().status}
pub fn get_tx_power(&self) -> u8{ self.read_inquiry_response_transmit_power_level_complete.as_ref().tx_power}
}
impl Into<EventPacket> for ReadInquiryResponseTransmitPowerLevelCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadInquiryResponseTransmitPowerLevelCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadInquiryResponseTransmitPowerLevelCompleteBuilder {pub fn build(self) -> ReadInquiryResponseTransmitPowerLevelCompletePacket {let read_inquiry_response_transmit_power_level_complete= Arc::new(ReadInquiryResponseTransmitPowerLevelCompleteData {status: self.status, tx_power: self.tx_power, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadInquiryResponseTransmitPowerLevel, child: CommandCompleteDataChild::ReadInquiryResponseTransmitPowerLevelComplete(read_inquiry_response_transmit_power_level_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadInquiryResponseTransmitPowerLevelCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadInquiryResponseTransmitPowerLevelCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadInquiryResponseTransmitPowerLevelCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WriteInquiryTransmitPowerLevelData {tx_power: u8, }
#[derive(Debug, Clone)] pub struct WriteInquiryTransmitPowerLevelPacket {command: Arc<CommandData>,discovery_command: Arc<DiscoveryCommandData>,write_inquiry_transmit_power_level: Arc<WriteInquiryTransmitPowerLevelData>,}
#[derive(Debug)] pub struct WriteInquiryTransmitPowerLevelBuilder {pub tx_power: u8, }
impl WriteInquiryTransmitPowerLevelData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "WriteInquiryTransmitPowerLevel".to_string(),    field: "tx_power".to_string(),    wanted: 4,    got: bytes.len()});}let tx_power = u8::from_le_bytes([bytes[3]]);Ok(Self {tx_power, })
}
fn write_to(&self, buffer: &mut BytesMut) {let tx_power = self.tx_power;buffer[3..4].copy_from_slice(&tx_power.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for WriteInquiryTransmitPowerLevelPacket { type ResponseType = WriteInquiryResponseTransmitPowerLevelCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteInquiryResponseTransmitPowerLevelCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteInquiryTransmitPowerLevelPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteInquiryTransmitPowerLevelPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let discovery_command = match &command.child {CommandDataChild::DiscoveryCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DiscoveryCommand"),};let write_inquiry_transmit_power_level = match &discovery_command.child {DiscoveryCommandDataChild::WriteInquiryTransmitPowerLevel(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteInquiryTransmitPowerLevel"),};Self {command,discovery_command,write_inquiry_transmit_power_level,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_tx_power(&self) -> u8{ self.write_inquiry_transmit_power_level.as_ref().tx_power}
}
impl Into<CommandPacket> for WriteInquiryTransmitPowerLevelPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<DiscoveryCommandPacket> for WriteInquiryTransmitPowerLevelPacket { fn into(self) -> DiscoveryCommandPacket {DiscoveryCommandPacket::new(self.command) }}
impl CommandExpectations for WriteInquiryTransmitPowerLevelBuilder { type ResponseType = WriteInquiryResponseTransmitPowerLevelCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteInquiryResponseTransmitPowerLevelCompletePacket::new(pkt.event.clone()) }}impl WriteInquiryTransmitPowerLevelBuilder {pub fn build(self) -> WriteInquiryTransmitPowerLevelPacket {let write_inquiry_transmit_power_level= Arc::new(WriteInquiryTransmitPowerLevelData {tx_power: self.tx_power, });let discovery_command= Arc::new(DiscoveryCommandData {child: DiscoveryCommandDataChild::WriteInquiryTransmitPowerLevel(write_inquiry_transmit_power_level),});let command= Arc::new(CommandData {op_code: OpCode::WriteInquiryTransmitPowerLevel, child: CommandDataChild::DiscoveryCommand(discovery_command),});WriteInquiryTransmitPowerLevelPacket::new(command)}
}
impl Into<CommandPacket> for WriteInquiryTransmitPowerLevelBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<DiscoveryCommandPacket> for WriteInquiryTransmitPowerLevelBuilder { fn into(self) -> DiscoveryCommandPacket { self.build().into() }}


#[derive(Debug)] struct WriteInquiryResponseTransmitPowerLevelCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WriteInquiryResponseTransmitPowerLevelCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_inquiry_response_transmit_power_level_complete: Arc<WriteInquiryResponseTransmitPowerLevelCompleteData>,}
#[derive(Debug)] pub struct WriteInquiryResponseTransmitPowerLevelCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WriteInquiryResponseTransmitPowerLevelCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteInquiryResponseTransmitPowerLevelComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WriteInquiryResponseTransmitPowerLevelCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteInquiryResponseTransmitPowerLevelCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_inquiry_response_transmit_power_level_complete = match &command_complete.child {CommandCompleteDataChild::WriteInquiryResponseTransmitPowerLevelComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteInquiryResponseTransmitPowerLevelComplete"),};Self {event,command_complete,write_inquiry_response_transmit_power_level_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_inquiry_response_transmit_power_level_complete.as_ref().status}
}
impl Into<EventPacket> for WriteInquiryResponseTransmitPowerLevelCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteInquiryResponseTransmitPowerLevelCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteInquiryResponseTransmitPowerLevelCompleteBuilder {pub fn build(self) -> WriteInquiryResponseTransmitPowerLevelCompletePacket {let write_inquiry_response_transmit_power_level_complete= Arc::new(WriteInquiryResponseTransmitPowerLevelCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteInquiryTransmitPowerLevel, child: CommandCompleteDataChild::WriteInquiryResponseTransmitPowerLevelComplete(write_inquiry_response_transmit_power_level_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteInquiryResponseTransmitPowerLevelCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteInquiryResponseTransmitPowerLevelCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteInquiryResponseTransmitPowerLevelCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct SendKeypressNotificationData {bd_addr: Address, notification_type: KeypressNotificationType, }
#[derive(Debug, Clone)] pub struct SendKeypressNotificationPacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,send_keypress_notification: Arc<SendKeypressNotificationData>,}
#[derive(Debug)] pub struct SendKeypressNotificationBuilder {pub bd_addr: Address, pub notification_type: KeypressNotificationType, }
impl SendKeypressNotificationData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "SendKeypressNotification".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "SendKeypressNotification".to_string(),    field: "notification_type".to_string(),    wanted: 10,    got: bytes.len()});}let notification_type = u8::from_le_bytes([bytes[9]]);let notification_type = KeypressNotificationType::from_u8(notification_type).unwrap();Ok(Self {bd_addr, notification_type, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);let notification_type = self.notification_type.to_u8().unwrap();buffer[9..10].copy_from_slice(&notification_type.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl CommandExpectations for SendKeypressNotificationPacket { type ResponseType = SendKeypressNotificationCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { SendKeypressNotificationCompletePacket::new(pkt.event.clone()) }}impl Packet for SendKeypressNotificationPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SendKeypressNotificationPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let send_keypress_notification = match &security_command.child {SecurityCommandDataChild::SendKeypressNotification(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SendKeypressNotification"),};Self {command,security_command,send_keypress_notification,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bd_addr(&self) -> Address{ self.send_keypress_notification.as_ref().bd_addr}
pub fn get_notification_type(&self) -> KeypressNotificationType{ self.send_keypress_notification.as_ref().notification_type}
}
impl Into<CommandPacket> for SendKeypressNotificationPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for SendKeypressNotificationPacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for SendKeypressNotificationBuilder { type ResponseType = SendKeypressNotificationCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { SendKeypressNotificationCompletePacket::new(pkt.event.clone()) }}impl SendKeypressNotificationBuilder {pub fn build(self) -> SendKeypressNotificationPacket {let send_keypress_notification= Arc::new(SendKeypressNotificationData {bd_addr: self.bd_addr, notification_type: self.notification_type, });let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::SendKeypressNotification(send_keypress_notification),});let command= Arc::new(CommandData {op_code: OpCode::SendKeypressNotification, child: CommandDataChild::SecurityCommand(security_command),});SendKeypressNotificationPacket::new(command)}
}
impl Into<CommandPacket> for SendKeypressNotificationBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for SendKeypressNotificationBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct SendKeypressNotificationCompleteData {status: ErrorCode, bd_addr: Address, }
#[derive(Debug, Clone)] pub struct SendKeypressNotificationCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,send_keypress_notification_complete: Arc<SendKeypressNotificationCompleteData>,}
#[derive(Debug)] pub struct SendKeypressNotificationCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub bd_addr: Address, }
impl SendKeypressNotificationCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "SendKeypressNotificationComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "SendKeypressNotificationComplete".to_string(),    field: "bd_addr".to_string(),    wanted: 12,    got: bytes.len()});}let bd_addr = bytes[6..12].try_into().unwrap();Ok(Self {status, bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let bd_addr: [u8; 6] = self.bd_addr.into();buffer[6..12].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for SendKeypressNotificationCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SendKeypressNotificationCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let send_keypress_notification_complete = match &command_complete.child {CommandCompleteDataChild::SendKeypressNotificationComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SendKeypressNotificationComplete"),};Self {event,command_complete,send_keypress_notification_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.send_keypress_notification_complete.as_ref().status}
pub fn get_bd_addr(&self) -> Address{ self.send_keypress_notification_complete.as_ref().bd_addr}
}
impl Into<EventPacket> for SendKeypressNotificationCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for SendKeypressNotificationCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl SendKeypressNotificationCompleteBuilder {pub fn build(self) -> SendKeypressNotificationCompletePacket {let send_keypress_notification_complete= Arc::new(SendKeypressNotificationCompleteData {status: self.status, bd_addr: self.bd_addr, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::SendKeypressNotification, child: CommandCompleteDataChild::SendKeypressNotificationComplete(send_keypress_notification_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});SendKeypressNotificationCompletePacket::new(event)}
}
impl Into<EventPacket> for SendKeypressNotificationCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for SendKeypressNotificationCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadLeHostSupportData {}
#[derive(Debug, Clone)] pub struct ReadLeHostSupportPacket {command: Arc<CommandData>,read_le_host_support: Arc<ReadLeHostSupportData>,}
#[derive(Debug)] pub struct ReadLeHostSupportBuilder {}
impl ReadLeHostSupportData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadLeHostSupportPacket { type ResponseType = ReadLeHostSupportCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLeHostSupportCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadLeHostSupportPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLeHostSupportPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let read_le_host_support = match &command.child {CommandDataChild::ReadLeHostSupport(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLeHostSupport"),};Self {command,read_le_host_support,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadLeHostSupportPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for ReadLeHostSupportBuilder { type ResponseType = ReadLeHostSupportCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLeHostSupportCompletePacket::new(pkt.event.clone()) }}impl ReadLeHostSupportBuilder {pub fn build(self) -> ReadLeHostSupportPacket {let read_le_host_support= Arc::new(ReadLeHostSupportData {});let command= Arc::new(CommandData {op_code: OpCode::ReadLeHostSupport, child: CommandDataChild::ReadLeHostSupport(read_le_host_support),});ReadLeHostSupportPacket::new(command)}
}
impl Into<CommandPacket> for ReadLeHostSupportBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadLeHostSupportCompleteData {status: ErrorCode, le_supported_host: Enable, }
#[derive(Debug, Clone)] pub struct ReadLeHostSupportCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_le_host_support_complete: Arc<ReadLeHostSupportCompleteData>,}
#[derive(Debug)] pub struct ReadLeHostSupportCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub le_supported_host: Enable, }
impl ReadLeHostSupportCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadLeHostSupportComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ReadLeHostSupportComplete".to_string(),    field: "le_supported_host".to_string(),    wanted: 7,    got: bytes.len()});}let le_supported_host = u8::from_le_bytes([bytes[6]]);let le_supported_host = Enable::from_u8(le_supported_host).unwrap();Ok(Self {status, le_supported_host, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let le_supported_host = self.le_supported_host.to_u8().unwrap();buffer[6..7].copy_from_slice(&le_supported_host.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for ReadLeHostSupportCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLeHostSupportCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_le_host_support_complete = match &command_complete.child {CommandCompleteDataChild::ReadLeHostSupportComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLeHostSupportComplete"),};Self {event,command_complete,read_le_host_support_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_le_host_support_complete.as_ref().status}
pub fn get_le_supported_host(&self) -> Enable{ self.read_le_host_support_complete.as_ref().le_supported_host}
}
impl Into<EventPacket> for ReadLeHostSupportCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadLeHostSupportCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadLeHostSupportCompleteBuilder {pub fn build(self) -> ReadLeHostSupportCompletePacket {let read_le_host_support_complete= Arc::new(ReadLeHostSupportCompleteData {status: self.status, le_supported_host: self.le_supported_host, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadLeHostSupport, child: CommandCompleteDataChild::ReadLeHostSupportComplete(read_le_host_support_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadLeHostSupportCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadLeHostSupportCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadLeHostSupportCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WriteLeHostSupportData {le_supported_host: Enable, simultaneous_le_host: Enable, }
#[derive(Debug, Clone)] pub struct WriteLeHostSupportPacket {command: Arc<CommandData>,write_le_host_support: Arc<WriteLeHostSupportData>,}
#[derive(Debug)] pub struct WriteLeHostSupportBuilder {pub le_supported_host: Enable, pub simultaneous_le_host: Enable, }
impl WriteLeHostSupportData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "WriteLeHostSupport".to_string(),    field: "le_supported_host".to_string(),    wanted: 4,    got: bytes.len()});}let le_supported_host = u8::from_le_bytes([bytes[3]]);let le_supported_host = Enable::from_u8(le_supported_host).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "WriteLeHostSupport".to_string(),    field: "simultaneous_le_host".to_string(),    wanted: 5,    got: bytes.len()});}let simultaneous_le_host = u8::from_le_bytes([bytes[4]]);let simultaneous_le_host = Enable::from_u8(simultaneous_le_host).unwrap();Ok(Self {le_supported_host, simultaneous_le_host, })
}
fn write_to(&self, buffer: &mut BytesMut) {let le_supported_host = self.le_supported_host.to_u8().unwrap();buffer[3..4].copy_from_slice(&le_supported_host.to_le_bytes()[0..1]);let simultaneous_le_host = self.simultaneous_le_host.to_u8().unwrap();buffer[4..5].copy_from_slice(&simultaneous_le_host.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for WriteLeHostSupportPacket { type ResponseType = WriteLeHostSupportCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteLeHostSupportCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteLeHostSupportPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteLeHostSupportPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let write_le_host_support = match &command.child {CommandDataChild::WriteLeHostSupport(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteLeHostSupport"),};Self {command,write_le_host_support,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_le_supported_host(&self) -> Enable{ self.write_le_host_support.as_ref().le_supported_host}
pub fn get_simultaneous_le_host(&self) -> Enable{ self.write_le_host_support.as_ref().simultaneous_le_host}
}
impl Into<CommandPacket> for WriteLeHostSupportPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for WriteLeHostSupportBuilder { type ResponseType = WriteLeHostSupportCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteLeHostSupportCompletePacket::new(pkt.event.clone()) }}impl WriteLeHostSupportBuilder {pub fn build(self) -> WriteLeHostSupportPacket {let write_le_host_support= Arc::new(WriteLeHostSupportData {le_supported_host: self.le_supported_host, simultaneous_le_host: self.simultaneous_le_host, });let command= Arc::new(CommandData {op_code: OpCode::WriteLeHostSupport, child: CommandDataChild::WriteLeHostSupport(write_le_host_support),});WriteLeHostSupportPacket::new(command)}
}
impl Into<CommandPacket> for WriteLeHostSupportBuilder { fn into(self) -> CommandPacket { self.build().into() }}
macro_rules! write_le_host_support_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::WriteLeHostSupport(packet) => {let rebuilder = WriteLeHostSupportBuilder {le_supported_host : packet.get_le_supported_host(),simultaneous_le_host : packet.get_simultaneous_le_host(),};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse write_le_host_support{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}write_le_host_support_builder_tests! { write_le_host_support_builder_test_00: b"\x6d\x0c\x02\x01\x01",}


#[derive(Debug)] struct WriteLeHostSupportCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WriteLeHostSupportCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_le_host_support_complete: Arc<WriteLeHostSupportCompleteData>,}
#[derive(Debug)] pub struct WriteLeHostSupportCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WriteLeHostSupportCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteLeHostSupportComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WriteLeHostSupportCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteLeHostSupportCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_le_host_support_complete = match &command_complete.child {CommandCompleteDataChild::WriteLeHostSupportComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteLeHostSupportComplete"),};Self {event,command_complete,write_le_host_support_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_le_host_support_complete.as_ref().status}
}
impl Into<EventPacket> for WriteLeHostSupportCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteLeHostSupportCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteLeHostSupportCompleteBuilder {pub fn build(self) -> WriteLeHostSupportCompletePacket {let write_le_host_support_complete= Arc::new(WriteLeHostSupportCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteLeHostSupport, child: CommandCompleteDataChild::WriteLeHostSupportComplete(write_le_host_support_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteLeHostSupportCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteLeHostSupportCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteLeHostSupportCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! write_le_host_support_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::WriteLeHostSupportComplete(packet) => {let rebuilder = WriteLeHostSupportCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse write_le_host_support_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}write_le_host_support_complete_builder_tests! { write_le_host_support_complete_builder_test_00: b"\x0e\x04\x01\x6d\x0c\x00",}


#[derive(Debug)] struct ReadSecureConnectionsHostSupportData {}
#[derive(Debug, Clone)] pub struct ReadSecureConnectionsHostSupportPacket {command: Arc<CommandData>,read_secure_connections_host_support: Arc<ReadSecureConnectionsHostSupportData>,}
#[derive(Debug)] pub struct ReadSecureConnectionsHostSupportBuilder {}
impl ReadSecureConnectionsHostSupportData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadSecureConnectionsHostSupportPacket { type ResponseType = ReadSecureConnectionsHostSupportCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadSecureConnectionsHostSupportCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadSecureConnectionsHostSupportPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadSecureConnectionsHostSupportPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let read_secure_connections_host_support = match &command.child {CommandDataChild::ReadSecureConnectionsHostSupport(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadSecureConnectionsHostSupport"),};Self {command,read_secure_connections_host_support,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadSecureConnectionsHostSupportPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for ReadSecureConnectionsHostSupportBuilder { type ResponseType = ReadSecureConnectionsHostSupportCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadSecureConnectionsHostSupportCompletePacket::new(pkt.event.clone()) }}impl ReadSecureConnectionsHostSupportBuilder {pub fn build(self) -> ReadSecureConnectionsHostSupportPacket {let read_secure_connections_host_support= Arc::new(ReadSecureConnectionsHostSupportData {});let command= Arc::new(CommandData {op_code: OpCode::ReadSecureConnectionsHostSupport, child: CommandDataChild::ReadSecureConnectionsHostSupport(read_secure_connections_host_support),});ReadSecureConnectionsHostSupportPacket::new(command)}
}
impl Into<CommandPacket> for ReadSecureConnectionsHostSupportBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadSecureConnectionsHostSupportCompleteData {status: ErrorCode, secure_connections_host_support: Enable, }
#[derive(Debug, Clone)] pub struct ReadSecureConnectionsHostSupportCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_secure_connections_host_support_complete: Arc<ReadSecureConnectionsHostSupportCompleteData>,}
#[derive(Debug)] pub struct ReadSecureConnectionsHostSupportCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub secure_connections_host_support: Enable, }
impl ReadSecureConnectionsHostSupportCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadSecureConnectionsHostSupportComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ReadSecureConnectionsHostSupportComplete".to_string(),    field: "secure_connections_host_support".to_string(),    wanted: 7,    got: bytes.len()});}let secure_connections_host_support = u8::from_le_bytes([bytes[6]]);let secure_connections_host_support = Enable::from_u8(secure_connections_host_support).unwrap();Ok(Self {status, secure_connections_host_support, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let secure_connections_host_support = self.secure_connections_host_support.to_u8().unwrap();buffer[6..7].copy_from_slice(&secure_connections_host_support.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for ReadSecureConnectionsHostSupportCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadSecureConnectionsHostSupportCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_secure_connections_host_support_complete = match &command_complete.child {CommandCompleteDataChild::ReadSecureConnectionsHostSupportComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadSecureConnectionsHostSupportComplete"),};Self {event,command_complete,read_secure_connections_host_support_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_secure_connections_host_support_complete.as_ref().status}
pub fn get_secure_connections_host_support(&self) -> Enable{ self.read_secure_connections_host_support_complete.as_ref().secure_connections_host_support}
}
impl Into<EventPacket> for ReadSecureConnectionsHostSupportCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadSecureConnectionsHostSupportCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadSecureConnectionsHostSupportCompleteBuilder {pub fn build(self) -> ReadSecureConnectionsHostSupportCompletePacket {let read_secure_connections_host_support_complete= Arc::new(ReadSecureConnectionsHostSupportCompleteData {status: self.status, secure_connections_host_support: self.secure_connections_host_support, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadSecureConnectionsHostSupport, child: CommandCompleteDataChild::ReadSecureConnectionsHostSupportComplete(read_secure_connections_host_support_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadSecureConnectionsHostSupportCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadSecureConnectionsHostSupportCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadSecureConnectionsHostSupportCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WriteSecureConnectionsHostSupportData {secure_connections_host_support: Enable, }
#[derive(Debug, Clone)] pub struct WriteSecureConnectionsHostSupportPacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,write_secure_connections_host_support: Arc<WriteSecureConnectionsHostSupportData>,}
#[derive(Debug)] pub struct WriteSecureConnectionsHostSupportBuilder {pub secure_connections_host_support: Enable, }
impl WriteSecureConnectionsHostSupportData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "WriteSecureConnectionsHostSupport".to_string(),    field: "secure_connections_host_support".to_string(),    wanted: 4,    got: bytes.len()});}let secure_connections_host_support = u8::from_le_bytes([bytes[3]]);let secure_connections_host_support = Enable::from_u8(secure_connections_host_support).unwrap();Ok(Self {secure_connections_host_support, })
}
fn write_to(&self, buffer: &mut BytesMut) {let secure_connections_host_support = self.secure_connections_host_support.to_u8().unwrap();buffer[3..4].copy_from_slice(&secure_connections_host_support.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for WriteSecureConnectionsHostSupportPacket { type ResponseType = WriteSecureConnectionsHostSupportCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteSecureConnectionsHostSupportCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteSecureConnectionsHostSupportPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteSecureConnectionsHostSupportPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let write_secure_connections_host_support = match &security_command.child {SecurityCommandDataChild::WriteSecureConnectionsHostSupport(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteSecureConnectionsHostSupport"),};Self {command,security_command,write_secure_connections_host_support,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_secure_connections_host_support(&self) -> Enable{ self.write_secure_connections_host_support.as_ref().secure_connections_host_support}
}
impl Into<CommandPacket> for WriteSecureConnectionsHostSupportPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for WriteSecureConnectionsHostSupportPacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for WriteSecureConnectionsHostSupportBuilder { type ResponseType = WriteSecureConnectionsHostSupportCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteSecureConnectionsHostSupportCompletePacket::new(pkt.event.clone()) }}impl WriteSecureConnectionsHostSupportBuilder {pub fn build(self) -> WriteSecureConnectionsHostSupportPacket {let write_secure_connections_host_support= Arc::new(WriteSecureConnectionsHostSupportData {secure_connections_host_support: self.secure_connections_host_support, });let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::WriteSecureConnectionsHostSupport(write_secure_connections_host_support),});let command= Arc::new(CommandData {op_code: OpCode::WriteSecureConnectionsHostSupport, child: CommandDataChild::SecurityCommand(security_command),});WriteSecureConnectionsHostSupportPacket::new(command)}
}
impl Into<CommandPacket> for WriteSecureConnectionsHostSupportBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for WriteSecureConnectionsHostSupportBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}
macro_rules! write_secure_connections_host_support_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::SecurityCommand(security_command_packet) => {match security_command_packet.specialize() {/* (2) */
SecurityCommandChild::WriteSecureConnectionsHostSupport(packet) => {let rebuilder = WriteSecureConnectionsHostSupportBuilder {secure_connections_host_support : packet.get_secure_connections_host_support(),};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse write_secure_connections_host_support{:02x?}", security_command_packet); }}}_ => {println!("Couldn't parse security_command{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}write_secure_connections_host_support_builder_tests! { write_secure_connections_host_support_builder_test_00: b"\x7a\x0c\x01\x01",}


#[derive(Debug)] struct WriteSecureConnectionsHostSupportCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WriteSecureConnectionsHostSupportCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_secure_connections_host_support_complete: Arc<WriteSecureConnectionsHostSupportCompleteData>,}
#[derive(Debug)] pub struct WriteSecureConnectionsHostSupportCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WriteSecureConnectionsHostSupportCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteSecureConnectionsHostSupportComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WriteSecureConnectionsHostSupportCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteSecureConnectionsHostSupportCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_secure_connections_host_support_complete = match &command_complete.child {CommandCompleteDataChild::WriteSecureConnectionsHostSupportComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteSecureConnectionsHostSupportComplete"),};Self {event,command_complete,write_secure_connections_host_support_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_secure_connections_host_support_complete.as_ref().status}
}
impl Into<EventPacket> for WriteSecureConnectionsHostSupportCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteSecureConnectionsHostSupportCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteSecureConnectionsHostSupportCompleteBuilder {pub fn build(self) -> WriteSecureConnectionsHostSupportCompletePacket {let write_secure_connections_host_support_complete= Arc::new(WriteSecureConnectionsHostSupportCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteSecureConnectionsHostSupport, child: CommandCompleteDataChild::WriteSecureConnectionsHostSupportComplete(write_secure_connections_host_support_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteSecureConnectionsHostSupportCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteSecureConnectionsHostSupportCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteSecureConnectionsHostSupportCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! write_secure_connections_host_support_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::WriteSecureConnectionsHostSupportComplete(packet) => {let rebuilder = WriteSecureConnectionsHostSupportCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse write_secure_connections_host_support_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}write_secure_connections_host_support_complete_builder_tests! { write_secure_connections_host_support_complete_builder_test_00: b"\x0e\x04\x01\x7a\x0c\x00",}


#[derive(Debug)] struct ReadLocalOobExtendedDataData {}
#[derive(Debug, Clone)] pub struct ReadLocalOobExtendedDataPacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,read_local_oob_extended_data: Arc<ReadLocalOobExtendedDataData>,}
#[derive(Debug)] pub struct ReadLocalOobExtendedDataBuilder {}
impl ReadLocalOobExtendedDataData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadLocalOobExtendedDataPacket { type ResponseType = ReadLocalOobExtendedDataCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLocalOobExtendedDataCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadLocalOobExtendedDataPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLocalOobExtendedDataPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let read_local_oob_extended_data = match &security_command.child {SecurityCommandDataChild::ReadLocalOobExtendedData(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLocalOobExtendedData"),};Self {command,security_command,read_local_oob_extended_data,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadLocalOobExtendedDataPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for ReadLocalOobExtendedDataPacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for ReadLocalOobExtendedDataBuilder { type ResponseType = ReadLocalOobExtendedDataCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLocalOobExtendedDataCompletePacket::new(pkt.event.clone()) }}impl ReadLocalOobExtendedDataBuilder {pub fn build(self) -> ReadLocalOobExtendedDataPacket {let read_local_oob_extended_data= Arc::new(ReadLocalOobExtendedDataData {});let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::ReadLocalOobExtendedData(read_local_oob_extended_data),});let command= Arc::new(CommandData {op_code: OpCode::ReadLocalOobExtendedData, child: CommandDataChild::SecurityCommand(security_command),});ReadLocalOobExtendedDataPacket::new(command)}
}
impl Into<CommandPacket> for ReadLocalOobExtendedDataBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for ReadLocalOobExtendedDataBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadLocalOobExtendedDataCompleteData {status: ErrorCode, c_192: [u8; 16], r_192: [u8; 16], c_256: [u8; 16], r_256: [u8; 16], }
#[derive(Debug, Clone)] pub struct ReadLocalOobExtendedDataCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_local_oob_extended_data_complete: Arc<ReadLocalOobExtendedDataCompleteData>,}
#[derive(Debug)] pub struct ReadLocalOobExtendedDataCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub c_192: [u8; 16], pub r_192: [u8; 16], pub c_256: [u8; 16], pub r_256: [u8; 16], }
impl ReadLocalOobExtendedDataCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadLocalOobExtendedDataComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 22 { return Err(Error::InvalidLengthError{    obj: "ReadLocalOobExtendedDataComplete".to_string(),    field: "c_192".to_string(),    wanted: 22,    got: bytes.len()});}let c_192 = bytes[6..22].try_into().unwrap();if bytes.len() < 38 { return Err(Error::InvalidLengthError{    obj: "ReadLocalOobExtendedDataComplete".to_string(),    field: "r_192".to_string(),    wanted: 38,    got: bytes.len()});}let r_192 = bytes[22..38].try_into().unwrap();if bytes.len() < 54 { return Err(Error::InvalidLengthError{    obj: "ReadLocalOobExtendedDataComplete".to_string(),    field: "c_256".to_string(),    wanted: 54,    got: bytes.len()});}let c_256 = bytes[38..54].try_into().unwrap();if bytes.len() < 70 { return Err(Error::InvalidLengthError{    obj: "ReadLocalOobExtendedDataComplete".to_string(),    field: "r_256".to_string(),    wanted: 70,    got: bytes.len()});}let r_256 = bytes[54..70].try_into().unwrap();Ok(Self {status, c_192, r_192, c_256, r_256, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);&buffer[6..22].copy_from_slice(&self.c_192);&buffer[22..38].copy_from_slice(&self.r_192);&buffer[38..54].copy_from_slice(&self.c_256);&buffer[54..70].copy_from_slice(&self.r_256);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 65;ret}
}
impl Packet for ReadLocalOobExtendedDataCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLocalOobExtendedDataCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_local_oob_extended_data_complete = match &command_complete.child {CommandCompleteDataChild::ReadLocalOobExtendedDataComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLocalOobExtendedDataComplete"),};Self {event,command_complete,read_local_oob_extended_data_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_local_oob_extended_data_complete.as_ref().status}
pub fn get_c_192(&self) -> &[u8; 16]{ &self.read_local_oob_extended_data_complete.as_ref().c_192}
pub fn get_r_192(&self) -> &[u8; 16]{ &self.read_local_oob_extended_data_complete.as_ref().r_192}
pub fn get_c_256(&self) -> &[u8; 16]{ &self.read_local_oob_extended_data_complete.as_ref().c_256}
pub fn get_r_256(&self) -> &[u8; 16]{ &self.read_local_oob_extended_data_complete.as_ref().r_256}
}
impl Into<EventPacket> for ReadLocalOobExtendedDataCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadLocalOobExtendedDataCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadLocalOobExtendedDataCompleteBuilder {pub fn build(self) -> ReadLocalOobExtendedDataCompletePacket {let read_local_oob_extended_data_complete= Arc::new(ReadLocalOobExtendedDataCompleteData {status: self.status, c_192: self.c_192, r_192: self.r_192, c_256: self.c_256, r_256: self.r_256, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadLocalOobExtendedData, child: CommandCompleteDataChild::ReadLocalOobExtendedDataComplete(read_local_oob_extended_data_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadLocalOobExtendedDataCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadLocalOobExtendedDataCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadLocalOobExtendedDataCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct SetEcosystemBaseIntervalData {interval: u16, }
#[derive(Debug, Clone)] pub struct SetEcosystemBaseIntervalPacket {command: Arc<CommandData>,set_ecosystem_base_interval: Arc<SetEcosystemBaseIntervalData>,}
#[derive(Debug)] pub struct SetEcosystemBaseIntervalBuilder {pub interval: u16, }
impl SetEcosystemBaseIntervalData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "SetEcosystemBaseInterval".to_string(),    field: "interval".to_string(),    wanted: 5,    got: bytes.len()});}let interval = u16::from_le_bytes([bytes[3],bytes[4]]);Ok(Self {interval, })
}
fn write_to(&self, buffer: &mut BytesMut) {let interval = self.interval;buffer[3..5].copy_from_slice(&interval.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for SetEcosystemBaseIntervalPacket { type ResponseType = SetEcosystemBaseIntervalCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { SetEcosystemBaseIntervalCompletePacket::new(pkt.event.clone()) }}impl Packet for SetEcosystemBaseIntervalPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SetEcosystemBaseIntervalPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let set_ecosystem_base_interval = match &command.child {CommandDataChild::SetEcosystemBaseInterval(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEcosystemBaseInterval"),};Self {command,set_ecosystem_base_interval,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_interval(&self) -> u16{ self.set_ecosystem_base_interval.as_ref().interval}
}
impl Into<CommandPacket> for SetEcosystemBaseIntervalPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for SetEcosystemBaseIntervalBuilder { type ResponseType = SetEcosystemBaseIntervalCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { SetEcosystemBaseIntervalCompletePacket::new(pkt.event.clone()) }}impl SetEcosystemBaseIntervalBuilder {pub fn build(self) -> SetEcosystemBaseIntervalPacket {let set_ecosystem_base_interval= Arc::new(SetEcosystemBaseIntervalData {interval: self.interval, });let command= Arc::new(CommandData {op_code: OpCode::SetEcosystemBaseInterval, child: CommandDataChild::SetEcosystemBaseInterval(set_ecosystem_base_interval),});SetEcosystemBaseIntervalPacket::new(command)}
}
impl Into<CommandPacket> for SetEcosystemBaseIntervalBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct SetEcosystemBaseIntervalCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct SetEcosystemBaseIntervalCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,set_ecosystem_base_interval_complete: Arc<SetEcosystemBaseIntervalCompleteData>,}
#[derive(Debug)] pub struct SetEcosystemBaseIntervalCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl SetEcosystemBaseIntervalCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "SetEcosystemBaseIntervalComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for SetEcosystemBaseIntervalCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SetEcosystemBaseIntervalCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let set_ecosystem_base_interval_complete = match &command_complete.child {CommandCompleteDataChild::SetEcosystemBaseIntervalComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SetEcosystemBaseIntervalComplete"),};Self {event,command_complete,set_ecosystem_base_interval_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.set_ecosystem_base_interval_complete.as_ref().status}
}
impl Into<EventPacket> for SetEcosystemBaseIntervalCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for SetEcosystemBaseIntervalCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl SetEcosystemBaseIntervalCompleteBuilder {pub fn build(self) -> SetEcosystemBaseIntervalCompletePacket {let set_ecosystem_base_interval_complete= Arc::new(SetEcosystemBaseIntervalCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::SetEcosystemBaseInterval, child: CommandCompleteDataChild::SetEcosystemBaseIntervalComplete(set_ecosystem_base_interval_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});SetEcosystemBaseIntervalCompletePacket::new(event)}
}
impl Into<EventPacket> for SetEcosystemBaseIntervalCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for SetEcosystemBaseIntervalCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ConfigureDataPathData {data_path_direction: DataPathDirection, data_path_id: u8, vendor_specific_config: Vec::<u8>, }
#[derive(Debug, Clone)] pub struct ConfigureDataPathPacket {command: Arc<CommandData>,configure_data_path: Arc<ConfigureDataPathData>,}
#[derive(Debug)] pub struct ConfigureDataPathBuilder {pub data_path_direction: DataPathDirection, pub data_path_id: u8, pub vendor_specific_config: Vec::<u8>, }
impl ConfigureDataPathData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "ConfigureDataPath".to_string(),    field: "data_path_direction".to_string(),    wanted: 4,    got: bytes.len()});}let data_path_direction = u8::from_le_bytes([bytes[3]]);let data_path_direction = DataPathDirection::from_u8(data_path_direction).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ConfigureDataPath".to_string(),    field: "data_path_id".to_string(),    wanted: 5,    got: bytes.len()});}let data_path_id = u8::from_le_bytes([bytes[4]]);if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ConfigureDataPath".to_string(),    field: "vendor_specific_config_size".to_string(),    wanted: 6,    got: bytes.len()});}let vendor_specific_config_size = u8::from_le_bytes([bytes[5]]);let want_ = 6 + (vendor_specific_config_size as usize);if bytes.len() < want_ { return Err(Error::InvalidLengthError{    obj: "ConfigureDataPath".to_string(),    field: "vendor_specific_config".to_string(),    wanted: want_,    got: bytes.len()});}let vendor_specific_config: Vec::<u8> = bytes[6..(6 + vendor_specific_config_size as usize)].to_vec().chunks_exact(1).into_iter().map(|i| u8::from_le_bytes([i[0]])).collect();Ok(Self {data_path_direction, data_path_id, vendor_specific_config, })
}
fn write_to(&self, buffer: &mut BytesMut) {let data_path_direction = self.data_path_direction.to_u8().unwrap();buffer[3..4].copy_from_slice(&data_path_direction.to_le_bytes()[0..1]);let data_path_id = self.data_path_id;buffer[4..5].copy_from_slice(&data_path_id.to_le_bytes()[0..1]);let vendor_specific_config_bytes = self.vendor_specific_config.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8);let vendor_specific_config_size = u8::try_from(vendor_specific_config_bytes).expect("payload size did not fit");buffer[5..6].copy_from_slice(&vendor_specific_config_size.to_le_bytes()[0..1]);for (i, e) in self.vendor_specific_config.iter().enumerate() {buffer[6+i..6+i+1].copy_from_slice(&e.to_le_bytes())}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;let ret = ret + (self.vendor_specific_config.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8));ret}
}
impl CommandExpectations for ConfigureDataPathPacket { type ResponseType = ConfigureDataPathCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ConfigureDataPathCompletePacket::new(pkt.event.clone()) }}impl Packet for ConfigureDataPathPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ConfigureDataPathPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let configure_data_path = match &command.child {CommandDataChild::ConfigureDataPath(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConfigureDataPath"),};Self {command,configure_data_path,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_data_path_direction(&self) -> DataPathDirection{ self.configure_data_path.as_ref().data_path_direction}
pub fn get_data_path_id(&self) -> u8{ self.configure_data_path.as_ref().data_path_id}
pub fn get_vendor_specific_config(&self) -> &Vec::<u8>{ &self.configure_data_path.as_ref().vendor_specific_config}
}
impl Into<CommandPacket> for ConfigureDataPathPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for ConfigureDataPathBuilder { type ResponseType = ConfigureDataPathCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ConfigureDataPathCompletePacket::new(pkt.event.clone()) }}impl ConfigureDataPathBuilder {pub fn build(self) -> ConfigureDataPathPacket {let configure_data_path= Arc::new(ConfigureDataPathData {data_path_direction: self.data_path_direction, data_path_id: self.data_path_id, vendor_specific_config: self.vendor_specific_config, });let command= Arc::new(CommandData {op_code: OpCode::ConfigureDataPath, child: CommandDataChild::ConfigureDataPath(configure_data_path),});ConfigureDataPathPacket::new(command)}
}
impl Into<CommandPacket> for ConfigureDataPathBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct ConfigureDataPathCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct ConfigureDataPathCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,configure_data_path_complete: Arc<ConfigureDataPathCompleteData>,}
#[derive(Debug)] pub struct ConfigureDataPathCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl ConfigureDataPathCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ConfigureDataPathComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for ConfigureDataPathCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ConfigureDataPathCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let configure_data_path_complete = match &command_complete.child {CommandCompleteDataChild::ConfigureDataPathComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConfigureDataPathComplete"),};Self {event,command_complete,configure_data_path_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.configure_data_path_complete.as_ref().status}
}
impl Into<EventPacket> for ConfigureDataPathCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ConfigureDataPathCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ConfigureDataPathCompleteBuilder {pub fn build(self) -> ConfigureDataPathCompletePacket {let configure_data_path_complete= Arc::new(ConfigureDataPathCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ConfigureDataPath, child: CommandCompleteDataChild::ConfigureDataPathComplete(configure_data_path_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ConfigureDataPathCompletePacket::new(event)}
}
impl Into<EventPacket> for ConfigureDataPathCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ConfigureDataPathCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadLocalVersionInformationData {}
#[derive(Debug, Clone)] pub struct ReadLocalVersionInformationPacket {command: Arc<CommandData>,read_local_version_information: Arc<ReadLocalVersionInformationData>,}
#[derive(Debug)] pub struct ReadLocalVersionInformationBuilder {}
impl ReadLocalVersionInformationData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadLocalVersionInformationPacket { type ResponseType = ReadLocalVersionInformationCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLocalVersionInformationCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadLocalVersionInformationPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLocalVersionInformationPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let read_local_version_information = match &command.child {CommandDataChild::ReadLocalVersionInformation(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLocalVersionInformation"),};Self {command,read_local_version_information,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadLocalVersionInformationPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for ReadLocalVersionInformationBuilder { type ResponseType = ReadLocalVersionInformationCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLocalVersionInformationCompletePacket::new(pkt.event.clone()) }}impl ReadLocalVersionInformationBuilder {pub fn build(self) -> ReadLocalVersionInformationPacket {let read_local_version_information= Arc::new(ReadLocalVersionInformationData {});let command= Arc::new(CommandData {op_code: OpCode::ReadLocalVersionInformation, child: CommandDataChild::ReadLocalVersionInformation(read_local_version_information),});ReadLocalVersionInformationPacket::new(command)}
}
impl Into<CommandPacket> for ReadLocalVersionInformationBuilder { fn into(self) -> CommandPacket { self.build().into() }}
macro_rules! read_local_version_information_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::ReadLocalVersionInformation(packet) => {let rebuilder = ReadLocalVersionInformationBuilder {};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse read_local_version_information{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}read_local_version_information_builder_tests! { read_local_version_information_builder_test_00: b"\x01\x10\x00",}


#[derive(Debug)] struct ReadLocalVersionInformationCompleteData {status: ErrorCode, local_version_information: LocalVersionInformation, }
#[derive(Debug, Clone)] pub struct ReadLocalVersionInformationCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_local_version_information_complete: Arc<ReadLocalVersionInformationCompleteData>,}
#[derive(Debug)] pub struct ReadLocalVersionInformationCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub local_version_information: LocalVersionInformation, }
impl ReadLocalVersionInformationCompleteData {fn conforms(bytes: &[u8]) -> bool {if !LocalVersionInformation::conforms(&bytes[6..14]) { return false; } true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadLocalVersionInformationComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();let local_version_information = LocalVersionInformation::parse(&bytes[6..14]).unwrap();Ok(Self {status, local_version_information, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let local_version_information = &mut buffer[6..14];self.local_version_information.write_to(local_version_information);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 9;ret}
}
impl Packet for ReadLocalVersionInformationCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLocalVersionInformationCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_local_version_information_complete = match &command_complete.child {CommandCompleteDataChild::ReadLocalVersionInformationComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLocalVersionInformationComplete"),};Self {event,command_complete,read_local_version_information_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_local_version_information_complete.as_ref().status}
pub fn get_local_version_information(&self) -> &LocalVersionInformation{ &self.read_local_version_information_complete.as_ref().local_version_information}
}
impl Into<EventPacket> for ReadLocalVersionInformationCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadLocalVersionInformationCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadLocalVersionInformationCompleteBuilder {pub fn build(self) -> ReadLocalVersionInformationCompletePacket {let read_local_version_information_complete= Arc::new(ReadLocalVersionInformationCompleteData {status: self.status, local_version_information: self.local_version_information, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadLocalVersionInformation, child: CommandCompleteDataChild::ReadLocalVersionInformationComplete(read_local_version_information_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadLocalVersionInformationCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadLocalVersionInformationCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadLocalVersionInformationCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! read_local_version_information_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::ReadLocalVersionInformationComplete(packet) => {let rebuilder = ReadLocalVersionInformationCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),local_version_information : packet.get_local_version_information().clone(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse read_local_version_information_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}read_local_version_information_complete_builder_tests! { read_local_version_information_complete_builder_test_00: b"\x0e\x0c\x01\x01\x10\x00\x09\x00\x00\x09\x1d\x00\xbe\x02",}


#[derive(Debug)] struct ReadLocalSupportedCommandsData {}
#[derive(Debug, Clone)] pub struct ReadLocalSupportedCommandsPacket {command: Arc<CommandData>,read_local_supported_commands: Arc<ReadLocalSupportedCommandsData>,}
#[derive(Debug)] pub struct ReadLocalSupportedCommandsBuilder {}
impl ReadLocalSupportedCommandsData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadLocalSupportedCommandsPacket { type ResponseType = ReadLocalSupportedCommandsCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLocalSupportedCommandsCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadLocalSupportedCommandsPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLocalSupportedCommandsPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let read_local_supported_commands = match &command.child {CommandDataChild::ReadLocalSupportedCommands(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLocalSupportedCommands"),};Self {command,read_local_supported_commands,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadLocalSupportedCommandsPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for ReadLocalSupportedCommandsBuilder { type ResponseType = ReadLocalSupportedCommandsCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLocalSupportedCommandsCompletePacket::new(pkt.event.clone()) }}impl ReadLocalSupportedCommandsBuilder {pub fn build(self) -> ReadLocalSupportedCommandsPacket {let read_local_supported_commands= Arc::new(ReadLocalSupportedCommandsData {});let command= Arc::new(CommandData {op_code: OpCode::ReadLocalSupportedCommands, child: CommandDataChild::ReadLocalSupportedCommands(read_local_supported_commands),});ReadLocalSupportedCommandsPacket::new(command)}
}
impl Into<CommandPacket> for ReadLocalSupportedCommandsBuilder { fn into(self) -> CommandPacket { self.build().into() }}
macro_rules! read_local_supported_commands_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::ReadLocalSupportedCommands(packet) => {let rebuilder = ReadLocalSupportedCommandsBuilder {};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse read_local_supported_commands{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}read_local_supported_commands_builder_tests! { read_local_supported_commands_builder_test_00: b"\x02\x10\x00",}


#[derive(Debug)] struct ReadLocalSupportedCommandsCompleteData {status: ErrorCode, supported_commands: [u8; 64], }
#[derive(Debug, Clone)] pub struct ReadLocalSupportedCommandsCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_local_supported_commands_complete: Arc<ReadLocalSupportedCommandsCompleteData>,}
#[derive(Debug)] pub struct ReadLocalSupportedCommandsCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub supported_commands: [u8; 64], }
impl ReadLocalSupportedCommandsCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedCommandsComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 70 { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedCommandsComplete".to_string(),    field: "supported_commands".to_string(),    wanted: 70,    got: bytes.len()});}let supported_commands = bytes[6..70].try_into().unwrap();Ok(Self {status, supported_commands, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);&buffer[6..70].copy_from_slice(&self.supported_commands);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 65;ret}
}
impl Packet for ReadLocalSupportedCommandsCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLocalSupportedCommandsCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_local_supported_commands_complete = match &command_complete.child {CommandCompleteDataChild::ReadLocalSupportedCommandsComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLocalSupportedCommandsComplete"),};Self {event,command_complete,read_local_supported_commands_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_local_supported_commands_complete.as_ref().status}
pub fn get_supported_commands(&self) -> &[u8; 64]{ &self.read_local_supported_commands_complete.as_ref().supported_commands}
}
impl Into<EventPacket> for ReadLocalSupportedCommandsCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadLocalSupportedCommandsCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadLocalSupportedCommandsCompleteBuilder {pub fn build(self) -> ReadLocalSupportedCommandsCompletePacket {let read_local_supported_commands_complete= Arc::new(ReadLocalSupportedCommandsCompleteData {status: self.status, supported_commands: self.supported_commands, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadLocalSupportedCommands, child: CommandCompleteDataChild::ReadLocalSupportedCommandsComplete(read_local_supported_commands_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadLocalSupportedCommandsCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadLocalSupportedCommandsCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadLocalSupportedCommandsCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! read_local_supported_commands_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::ReadLocalSupportedCommandsComplete(packet) => {let rebuilder = ReadLocalSupportedCommandsCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),supported_commands : packet.get_supported_commands().clone(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse read_local_supported_commands_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}read_local_supported_commands_complete_builder_tests! { read_local_supported_commands_complete_builder_test_00: b"\x0e\x44\x01\x02\x10\x00\xff\xff\xff\x03\xce\xff\xef\xff\xff\xff\xff\x7f\xf2\x0f\xe8\xfe\x3f\xf7\x83\xff\x1c\x00\x00\x00\x61\xff\xff\xff\x7f\xbe\x20\xf5\xff\xf0\xff\xff\xff\xff\xff\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",}


#[derive(Debug)] struct ReadLocalSupportedFeaturesData {}
#[derive(Debug, Clone)] pub struct ReadLocalSupportedFeaturesPacket {command: Arc<CommandData>,read_local_supported_features: Arc<ReadLocalSupportedFeaturesData>,}
#[derive(Debug)] pub struct ReadLocalSupportedFeaturesBuilder {}
impl ReadLocalSupportedFeaturesData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadLocalSupportedFeaturesPacket { type ResponseType = ReadLocalSupportedFeaturesCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLocalSupportedFeaturesCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadLocalSupportedFeaturesPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLocalSupportedFeaturesPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let read_local_supported_features = match &command.child {CommandDataChild::ReadLocalSupportedFeatures(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLocalSupportedFeatures"),};Self {command,read_local_supported_features,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadLocalSupportedFeaturesPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for ReadLocalSupportedFeaturesBuilder { type ResponseType = ReadLocalSupportedFeaturesCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLocalSupportedFeaturesCompletePacket::new(pkt.event.clone()) }}impl ReadLocalSupportedFeaturesBuilder {pub fn build(self) -> ReadLocalSupportedFeaturesPacket {let read_local_supported_features= Arc::new(ReadLocalSupportedFeaturesData {});let command= Arc::new(CommandData {op_code: OpCode::ReadLocalSupportedFeatures, child: CommandDataChild::ReadLocalSupportedFeatures(read_local_supported_features),});ReadLocalSupportedFeaturesPacket::new(command)}
}
impl Into<CommandPacket> for ReadLocalSupportedFeaturesBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadLocalSupportedFeaturesCompleteData {status: ErrorCode, lmp_features: u64, }
#[derive(Debug, Clone)] pub struct ReadLocalSupportedFeaturesCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_local_supported_features_complete: Arc<ReadLocalSupportedFeaturesCompleteData>,}
#[derive(Debug)] pub struct ReadLocalSupportedFeaturesCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub lmp_features: u64, }
impl ReadLocalSupportedFeaturesCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedFeaturesComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedFeaturesComplete".to_string(),    field: "lmp_features".to_string(),    wanted: 14,    got: bytes.len()});}let lmp_features = u64::from_le_bytes([bytes[6],bytes[7],bytes[8],bytes[9],bytes[10],bytes[11],bytes[12],bytes[13]]);Ok(Self {status, lmp_features, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let lmp_features = self.lmp_features;buffer[6..14].copy_from_slice(&lmp_features.to_le_bytes()[0..8]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 9;ret}
}
impl Packet for ReadLocalSupportedFeaturesCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLocalSupportedFeaturesCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_local_supported_features_complete = match &command_complete.child {CommandCompleteDataChild::ReadLocalSupportedFeaturesComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLocalSupportedFeaturesComplete"),};Self {event,command_complete,read_local_supported_features_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_local_supported_features_complete.as_ref().status}
pub fn get_lmp_features(&self) -> u64{ self.read_local_supported_features_complete.as_ref().lmp_features}
}
impl Into<EventPacket> for ReadLocalSupportedFeaturesCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadLocalSupportedFeaturesCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadLocalSupportedFeaturesCompleteBuilder {pub fn build(self) -> ReadLocalSupportedFeaturesCompletePacket {let read_local_supported_features_complete= Arc::new(ReadLocalSupportedFeaturesCompleteData {status: self.status, lmp_features: self.lmp_features, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadLocalSupportedFeatures, child: CommandCompleteDataChild::ReadLocalSupportedFeaturesComplete(read_local_supported_features_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadLocalSupportedFeaturesCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadLocalSupportedFeaturesCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadLocalSupportedFeaturesCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadLocalExtendedFeaturesData {page_number: u8, }
#[derive(Debug, Clone)] pub struct ReadLocalExtendedFeaturesPacket {command: Arc<CommandData>,read_local_extended_features: Arc<ReadLocalExtendedFeaturesData>,}
#[derive(Debug)] pub struct ReadLocalExtendedFeaturesBuilder {pub page_number: u8, }
impl ReadLocalExtendedFeaturesData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "ReadLocalExtendedFeatures".to_string(),    field: "page_number".to_string(),    wanted: 4,    got: bytes.len()});}let page_number = u8::from_le_bytes([bytes[3]]);Ok(Self {page_number, })
}
fn write_to(&self, buffer: &mut BytesMut) {let page_number = self.page_number;buffer[3..4].copy_from_slice(&page_number.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for ReadLocalExtendedFeaturesPacket { type ResponseType = ReadLocalExtendedFeaturesCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLocalExtendedFeaturesCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadLocalExtendedFeaturesPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLocalExtendedFeaturesPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let read_local_extended_features = match &command.child {CommandDataChild::ReadLocalExtendedFeatures(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLocalExtendedFeatures"),};Self {command,read_local_extended_features,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_page_number(&self) -> u8{ self.read_local_extended_features.as_ref().page_number}
}
impl Into<CommandPacket> for ReadLocalExtendedFeaturesPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for ReadLocalExtendedFeaturesBuilder { type ResponseType = ReadLocalExtendedFeaturesCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLocalExtendedFeaturesCompletePacket::new(pkt.event.clone()) }}impl ReadLocalExtendedFeaturesBuilder {pub fn build(self) -> ReadLocalExtendedFeaturesPacket {let read_local_extended_features= Arc::new(ReadLocalExtendedFeaturesData {page_number: self.page_number, });let command= Arc::new(CommandData {op_code: OpCode::ReadLocalExtendedFeatures, child: CommandDataChild::ReadLocalExtendedFeatures(read_local_extended_features),});ReadLocalExtendedFeaturesPacket::new(command)}
}
impl Into<CommandPacket> for ReadLocalExtendedFeaturesBuilder { fn into(self) -> CommandPacket { self.build().into() }}
macro_rules! read_local_extended_features_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::ReadLocalExtendedFeatures(packet) => {let rebuilder = ReadLocalExtendedFeaturesBuilder {page_number : packet.get_page_number(),};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse read_local_extended_features{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}read_local_extended_features_builder_tests! { read_local_extended_features_builder_test_00: b"\x04\x10\x01\x00",read_local_extended_features_builder_test_01: b"\x04\x10\x01\x01",read_local_extended_features_builder_test_02: b"\x04\x10\x01\x02",}


#[derive(Debug)] struct ReadLocalExtendedFeaturesCompleteData {status: ErrorCode, page_number: u8, maximum_page_number: u8, extended_lmp_features: u64, }
#[derive(Debug, Clone)] pub struct ReadLocalExtendedFeaturesCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_local_extended_features_complete: Arc<ReadLocalExtendedFeaturesCompleteData>,}
#[derive(Debug)] pub struct ReadLocalExtendedFeaturesCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub page_number: u8, pub maximum_page_number: u8, pub extended_lmp_features: u64, }
impl ReadLocalExtendedFeaturesCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadLocalExtendedFeaturesComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ReadLocalExtendedFeaturesComplete".to_string(),    field: "page_number".to_string(),    wanted: 7,    got: bytes.len()});}let page_number = u8::from_le_bytes([bytes[6]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadLocalExtendedFeaturesComplete".to_string(),    field: "maximum_page_number".to_string(),    wanted: 8,    got: bytes.len()});}let maximum_page_number = u8::from_le_bytes([bytes[7]]);if bytes.len() < 16 { return Err(Error::InvalidLengthError{    obj: "ReadLocalExtendedFeaturesComplete".to_string(),    field: "extended_lmp_features".to_string(),    wanted: 16,    got: bytes.len()});}let extended_lmp_features = u64::from_le_bytes([bytes[8],bytes[9],bytes[10],bytes[11],bytes[12],bytes[13],bytes[14],bytes[15]]);Ok(Self {status, page_number, maximum_page_number, extended_lmp_features, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let page_number = self.page_number;buffer[6..7].copy_from_slice(&page_number.to_le_bytes()[0..1]);let maximum_page_number = self.maximum_page_number;buffer[7..8].copy_from_slice(&maximum_page_number.to_le_bytes()[0..1]);let extended_lmp_features = self.extended_lmp_features;buffer[8..16].copy_from_slice(&extended_lmp_features.to_le_bytes()[0..8]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 11;ret}
}
impl Packet for ReadLocalExtendedFeaturesCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLocalExtendedFeaturesCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_local_extended_features_complete = match &command_complete.child {CommandCompleteDataChild::ReadLocalExtendedFeaturesComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLocalExtendedFeaturesComplete"),};Self {event,command_complete,read_local_extended_features_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_local_extended_features_complete.as_ref().status}
pub fn get_page_number(&self) -> u8{ self.read_local_extended_features_complete.as_ref().page_number}
pub fn get_maximum_page_number(&self) -> u8{ self.read_local_extended_features_complete.as_ref().maximum_page_number}
pub fn get_extended_lmp_features(&self) -> u64{ self.read_local_extended_features_complete.as_ref().extended_lmp_features}
}
impl Into<EventPacket> for ReadLocalExtendedFeaturesCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadLocalExtendedFeaturesCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadLocalExtendedFeaturesCompleteBuilder {pub fn build(self) -> ReadLocalExtendedFeaturesCompletePacket {let read_local_extended_features_complete= Arc::new(ReadLocalExtendedFeaturesCompleteData {status: self.status, page_number: self.page_number, maximum_page_number: self.maximum_page_number, extended_lmp_features: self.extended_lmp_features, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadLocalExtendedFeatures, child: CommandCompleteDataChild::ReadLocalExtendedFeaturesComplete(read_local_extended_features_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadLocalExtendedFeaturesCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadLocalExtendedFeaturesCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadLocalExtendedFeaturesCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! read_local_extended_features_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::ReadLocalExtendedFeaturesComplete(packet) => {let rebuilder = ReadLocalExtendedFeaturesCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),page_number : packet.get_page_number(),maximum_page_number : packet.get_maximum_page_number(),extended_lmp_features : packet.get_extended_lmp_features(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse read_local_extended_features_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}read_local_extended_features_complete_builder_tests! { read_local_extended_features_complete_builder_test_00: b"\x0e\x0e\x01\x04\x10\x00\x00\x02\xff\xfe\x8f\xfe\xd8\x3f\x5b\x87",read_local_extended_features_complete_builder_test_01: b"\x0e\x0e\x01\x04\x10\x00\x01\x02\x07\x00\x00\x00\x00\x00\x00\x00",read_local_extended_features_complete_builder_test_02: b"\x0e\x0e\x01\x04\x10\x00\x02\x02\x45\x03\x00\x00\x00\x00\x00\x00",}


#[derive(Debug)] struct ReadBufferSizeData {}
#[derive(Debug, Clone)] pub struct ReadBufferSizePacket {command: Arc<CommandData>,read_buffer_size: Arc<ReadBufferSizeData>,}
#[derive(Debug)] pub struct ReadBufferSizeBuilder {}
impl ReadBufferSizeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadBufferSizePacket { type ResponseType = ReadBufferSizeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadBufferSizeCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadBufferSizePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadBufferSizePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let read_buffer_size = match &command.child {CommandDataChild::ReadBufferSize(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadBufferSize"),};Self {command,read_buffer_size,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadBufferSizePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for ReadBufferSizeBuilder { type ResponseType = ReadBufferSizeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadBufferSizeCompletePacket::new(pkt.event.clone()) }}impl ReadBufferSizeBuilder {pub fn build(self) -> ReadBufferSizePacket {let read_buffer_size= Arc::new(ReadBufferSizeData {});let command= Arc::new(CommandData {op_code: OpCode::ReadBufferSize, child: CommandDataChild::ReadBufferSize(read_buffer_size),});ReadBufferSizePacket::new(command)}
}
impl Into<CommandPacket> for ReadBufferSizeBuilder { fn into(self) -> CommandPacket { self.build().into() }}
macro_rules! read_buffer_size_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::ReadBufferSize(packet) => {let rebuilder = ReadBufferSizeBuilder {};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse read_buffer_size{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}read_buffer_size_builder_tests! { read_buffer_size_builder_test_00: b"\x05\x10\x00",}


#[derive(Debug)] struct ReadBufferSizeCompleteData {status: ErrorCode, acl_data_packet_length: u16, synchronous_data_packet_length: u8, total_num_acl_data_packets: u16, total_num_synchronous_data_packets: u16, }
#[derive(Debug, Clone)] pub struct ReadBufferSizeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_buffer_size_complete: Arc<ReadBufferSizeCompleteData>,}
#[derive(Debug)] pub struct ReadBufferSizeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub acl_data_packet_length: u16, pub synchronous_data_packet_length: u8, pub total_num_acl_data_packets: u16, pub total_num_synchronous_data_packets: u16, }
impl ReadBufferSizeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadBufferSizeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadBufferSizeComplete".to_string(),    field: "acl_data_packet_length".to_string(),    wanted: 8,    got: bytes.len()});}let acl_data_packet_length = u16::from_le_bytes([bytes[6],bytes[7]]);if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "ReadBufferSizeComplete".to_string(),    field: "synchronous_data_packet_length".to_string(),    wanted: 9,    got: bytes.len()});}let synchronous_data_packet_length = u8::from_le_bytes([bytes[8]]);if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "ReadBufferSizeComplete".to_string(),    field: "total_num_acl_data_packets".to_string(),    wanted: 11,    got: bytes.len()});}let total_num_acl_data_packets = u16::from_le_bytes([bytes[9],bytes[10]]);if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "ReadBufferSizeComplete".to_string(),    field: "total_num_synchronous_data_packets".to_string(),    wanted: 13,    got: bytes.len()});}let total_num_synchronous_data_packets = u16::from_le_bytes([bytes[11],bytes[12]]);Ok(Self {status, acl_data_packet_length, synchronous_data_packet_length, total_num_acl_data_packets, total_num_synchronous_data_packets, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let acl_data_packet_length = self.acl_data_packet_length;buffer[6..8].copy_from_slice(&acl_data_packet_length.to_le_bytes()[0..2]);let synchronous_data_packet_length = self.synchronous_data_packet_length;buffer[8..9].copy_from_slice(&synchronous_data_packet_length.to_le_bytes()[0..1]);let total_num_acl_data_packets = self.total_num_acl_data_packets;buffer[9..11].copy_from_slice(&total_num_acl_data_packets.to_le_bytes()[0..2]);let total_num_synchronous_data_packets = self.total_num_synchronous_data_packets;buffer[11..13].copy_from_slice(&total_num_synchronous_data_packets.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 8;ret}
}
impl Packet for ReadBufferSizeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadBufferSizeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_buffer_size_complete = match &command_complete.child {CommandCompleteDataChild::ReadBufferSizeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadBufferSizeComplete"),};Self {event,command_complete,read_buffer_size_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_buffer_size_complete.as_ref().status}
pub fn get_acl_data_packet_length(&self) -> u16{ self.read_buffer_size_complete.as_ref().acl_data_packet_length}
pub fn get_synchronous_data_packet_length(&self) -> u8{ self.read_buffer_size_complete.as_ref().synchronous_data_packet_length}
pub fn get_total_num_acl_data_packets(&self) -> u16{ self.read_buffer_size_complete.as_ref().total_num_acl_data_packets}
pub fn get_total_num_synchronous_data_packets(&self) -> u16{ self.read_buffer_size_complete.as_ref().total_num_synchronous_data_packets}
}
impl Into<EventPacket> for ReadBufferSizeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadBufferSizeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadBufferSizeCompleteBuilder {pub fn build(self) -> ReadBufferSizeCompletePacket {let read_buffer_size_complete= Arc::new(ReadBufferSizeCompleteData {status: self.status, acl_data_packet_length: self.acl_data_packet_length, synchronous_data_packet_length: self.synchronous_data_packet_length, total_num_acl_data_packets: self.total_num_acl_data_packets, total_num_synchronous_data_packets: self.total_num_synchronous_data_packets, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadBufferSize, child: CommandCompleteDataChild::ReadBufferSizeComplete(read_buffer_size_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadBufferSizeCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadBufferSizeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadBufferSizeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! read_buffer_size_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::ReadBufferSizeComplete(packet) => {let rebuilder = ReadBufferSizeCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),acl_data_packet_length : packet.get_acl_data_packet_length(),synchronous_data_packet_length : packet.get_synchronous_data_packet_length(),total_num_acl_data_packets : packet.get_total_num_acl_data_packets(),total_num_synchronous_data_packets : packet.get_total_num_synchronous_data_packets(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse read_buffer_size_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}read_buffer_size_complete_builder_tests! { read_buffer_size_complete_builder_test_00: b"\x0e\x0b\x01\x05\x10\x00\x00\x04\x3c\x07\x00\x08\x00",}


#[derive(Debug)] struct ReadBdAddrData {}
#[derive(Debug, Clone)] pub struct ReadBdAddrPacket {command: Arc<CommandData>,read_bd_addr: Arc<ReadBdAddrData>,}
#[derive(Debug)] pub struct ReadBdAddrBuilder {}
impl ReadBdAddrData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadBdAddrPacket { type ResponseType = ReadBdAddrCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadBdAddrCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadBdAddrPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadBdAddrPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let read_bd_addr = match &command.child {CommandDataChild::ReadBdAddr(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadBdAddr"),};Self {command,read_bd_addr,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadBdAddrPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for ReadBdAddrBuilder { type ResponseType = ReadBdAddrCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadBdAddrCompletePacket::new(pkt.event.clone()) }}impl ReadBdAddrBuilder {pub fn build(self) -> ReadBdAddrPacket {let read_bd_addr= Arc::new(ReadBdAddrData {});let command= Arc::new(CommandData {op_code: OpCode::ReadBdAddr, child: CommandDataChild::ReadBdAddr(read_bd_addr),});ReadBdAddrPacket::new(command)}
}
impl Into<CommandPacket> for ReadBdAddrBuilder { fn into(self) -> CommandPacket { self.build().into() }}
macro_rules! read_bd_addr_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::ReadBdAddr(packet) => {let rebuilder = ReadBdAddrBuilder {};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse read_bd_addr{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}read_bd_addr_builder_tests! { read_bd_addr_builder_test_00: b"\x09\x10\x00",}


#[derive(Debug)] struct ReadBdAddrCompleteData {status: ErrorCode, bd_addr: Address, }
#[derive(Debug, Clone)] pub struct ReadBdAddrCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_bd_addr_complete: Arc<ReadBdAddrCompleteData>,}
#[derive(Debug)] pub struct ReadBdAddrCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub bd_addr: Address, }
impl ReadBdAddrCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadBdAddrComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "ReadBdAddrComplete".to_string(),    field: "bd_addr".to_string(),    wanted: 12,    got: bytes.len()});}let bd_addr = bytes[6..12].try_into().unwrap();Ok(Self {status, bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let bd_addr: [u8; 6] = self.bd_addr.into();buffer[6..12].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for ReadBdAddrCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadBdAddrCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_bd_addr_complete = match &command_complete.child {CommandCompleteDataChild::ReadBdAddrComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadBdAddrComplete"),};Self {event,command_complete,read_bd_addr_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_bd_addr_complete.as_ref().status}
pub fn get_bd_addr(&self) -> Address{ self.read_bd_addr_complete.as_ref().bd_addr}
}
impl Into<EventPacket> for ReadBdAddrCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadBdAddrCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadBdAddrCompleteBuilder {pub fn build(self) -> ReadBdAddrCompletePacket {let read_bd_addr_complete= Arc::new(ReadBdAddrCompleteData {status: self.status, bd_addr: self.bd_addr, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadBdAddr, child: CommandCompleteDataChild::ReadBdAddrComplete(read_bd_addr_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadBdAddrCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadBdAddrCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadBdAddrCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! read_bd_addr_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::ReadBdAddrComplete(packet) => {let rebuilder = ReadBdAddrCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),bd_addr : packet.get_bd_addr(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse read_bd_addr_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}read_bd_addr_complete_builder_tests! { read_bd_addr_complete_builder_test_00: b"\x0e\x0a\x01\x09\x10\x00\x14\x8e\x61\x5f\x36\x88",}


#[derive(Debug)] struct ReadDataBlockSizeData {}
#[derive(Debug, Clone)] pub struct ReadDataBlockSizePacket {command: Arc<CommandData>,read_data_block_size: Arc<ReadDataBlockSizeData>,}
#[derive(Debug)] pub struct ReadDataBlockSizeBuilder {}
impl ReadDataBlockSizeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadDataBlockSizePacket { type ResponseType = ReadDataBlockSizeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadDataBlockSizeCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadDataBlockSizePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadDataBlockSizePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let read_data_block_size = match &command.child {CommandDataChild::ReadDataBlockSize(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadDataBlockSize"),};Self {command,read_data_block_size,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadDataBlockSizePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for ReadDataBlockSizeBuilder { type ResponseType = ReadDataBlockSizeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadDataBlockSizeCompletePacket::new(pkt.event.clone()) }}impl ReadDataBlockSizeBuilder {pub fn build(self) -> ReadDataBlockSizePacket {let read_data_block_size= Arc::new(ReadDataBlockSizeData {});let command= Arc::new(CommandData {op_code: OpCode::ReadDataBlockSize, child: CommandDataChild::ReadDataBlockSize(read_data_block_size),});ReadDataBlockSizePacket::new(command)}
}
impl Into<CommandPacket> for ReadDataBlockSizeBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadDataBlockSizeCompleteData {status: ErrorCode, max_acl_data_packet_length: u16, data_block_length: u16, total_num_data_blocks: u16, }
#[derive(Debug, Clone)] pub struct ReadDataBlockSizeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_data_block_size_complete: Arc<ReadDataBlockSizeCompleteData>,}
#[derive(Debug)] pub struct ReadDataBlockSizeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub max_acl_data_packet_length: u16, pub data_block_length: u16, pub total_num_data_blocks: u16, }
impl ReadDataBlockSizeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadDataBlockSizeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadDataBlockSizeComplete".to_string(),    field: "max_acl_data_packet_length".to_string(),    wanted: 8,    got: bytes.len()});}let max_acl_data_packet_length = u16::from_le_bytes([bytes[6],bytes[7]]);if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "ReadDataBlockSizeComplete".to_string(),    field: "data_block_length".to_string(),    wanted: 10,    got: bytes.len()});}let data_block_length = u16::from_le_bytes([bytes[8],bytes[9]]);if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "ReadDataBlockSizeComplete".to_string(),    field: "total_num_data_blocks".to_string(),    wanted: 12,    got: bytes.len()});}let total_num_data_blocks = u16::from_le_bytes([bytes[10],bytes[11]]);Ok(Self {status, max_acl_data_packet_length, data_block_length, total_num_data_blocks, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let max_acl_data_packet_length = self.max_acl_data_packet_length;buffer[6..8].copy_from_slice(&max_acl_data_packet_length.to_le_bytes()[0..2]);let data_block_length = self.data_block_length;buffer[8..10].copy_from_slice(&data_block_length.to_le_bytes()[0..2]);let total_num_data_blocks = self.total_num_data_blocks;buffer[10..12].copy_from_slice(&total_num_data_blocks.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for ReadDataBlockSizeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadDataBlockSizeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_data_block_size_complete = match &command_complete.child {CommandCompleteDataChild::ReadDataBlockSizeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadDataBlockSizeComplete"),};Self {event,command_complete,read_data_block_size_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_data_block_size_complete.as_ref().status}
pub fn get_max_acl_data_packet_length(&self) -> u16{ self.read_data_block_size_complete.as_ref().max_acl_data_packet_length}
pub fn get_data_block_length(&self) -> u16{ self.read_data_block_size_complete.as_ref().data_block_length}
pub fn get_total_num_data_blocks(&self) -> u16{ self.read_data_block_size_complete.as_ref().total_num_data_blocks}
}
impl Into<EventPacket> for ReadDataBlockSizeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadDataBlockSizeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadDataBlockSizeCompleteBuilder {pub fn build(self) -> ReadDataBlockSizeCompletePacket {let read_data_block_size_complete= Arc::new(ReadDataBlockSizeCompleteData {status: self.status, max_acl_data_packet_length: self.max_acl_data_packet_length, data_block_length: self.data_block_length, total_num_data_blocks: self.total_num_data_blocks, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadDataBlockSize, child: CommandCompleteDataChild::ReadDataBlockSizeComplete(read_data_block_size_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadDataBlockSizeCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadDataBlockSizeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadDataBlockSizeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadLocalSupportedCodecsV1Data {}
#[derive(Debug, Clone)] pub struct ReadLocalSupportedCodecsV1Packet {command: Arc<CommandData>,read_local_supported_codecs_v1: Arc<ReadLocalSupportedCodecsV1Data>,}
#[derive(Debug)] pub struct ReadLocalSupportedCodecsV1Builder {}
impl ReadLocalSupportedCodecsV1Data {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadLocalSupportedCodecsV1Packet { type ResponseType = ReadLocalSupportedCodecsV1CompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLocalSupportedCodecsV1CompletePacket::new(pkt.event.clone()) }}impl Packet for ReadLocalSupportedCodecsV1Packet {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLocalSupportedCodecsV1Packet { fn new(root: Arc<CommandData>) -> Self {let command = root;let read_local_supported_codecs_v1 = match &command.child {CommandDataChild::ReadLocalSupportedCodecsV1(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLocalSupportedCodecsV1"),};Self {command,read_local_supported_codecs_v1,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadLocalSupportedCodecsV1Packet { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for ReadLocalSupportedCodecsV1Builder { type ResponseType = ReadLocalSupportedCodecsV1CompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLocalSupportedCodecsV1CompletePacket::new(pkt.event.clone()) }}impl ReadLocalSupportedCodecsV1Builder {pub fn build(self) -> ReadLocalSupportedCodecsV1Packet {let read_local_supported_codecs_v1= Arc::new(ReadLocalSupportedCodecsV1Data {});let command= Arc::new(CommandData {op_code: OpCode::ReadLocalSupportedCodecsV1, child: CommandDataChild::ReadLocalSupportedCodecsV1(read_local_supported_codecs_v1),});ReadLocalSupportedCodecsV1Packet::new(command)}
}
impl Into<CommandPacket> for ReadLocalSupportedCodecsV1Builder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadLocalSupportedCodecsV1CompleteData {status: ErrorCode, supported_codecs: Vec::<u8>, vendor_specific_codecs: Vec::<u32>, }
#[derive(Debug, Clone)] pub struct ReadLocalSupportedCodecsV1CompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_local_supported_codecs_v1_complete: Arc<ReadLocalSupportedCodecsV1CompleteData>,}
#[derive(Debug)] pub struct ReadLocalSupportedCodecsV1CompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub supported_codecs: Vec::<u8>, pub vendor_specific_codecs: Vec::<u32>, }
impl ReadLocalSupportedCodecsV1CompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedCodecsV1Complete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedCodecsV1Complete".to_string(),    field: "supported_codecs_size".to_string(),    wanted: 7,    got: bytes.len()});}let supported_codecs_size = u8::from_le_bytes([bytes[6]]);let want_ = 7 + (supported_codecs_size as usize);if bytes.len() < want_ { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedCodecsV1Complete".to_string(),    field: "supported_codecs".to_string(),    wanted: want_,    got: bytes.len()});}let supported_codecs: Vec::<u8> = bytes[7..(7 + supported_codecs_size as usize)].to_vec().chunks_exact(1).into_iter().map(|i| u8::from_le_bytes([i[0]])).collect();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedCodecsV1Complete".to_string(),    field: "vendor_specific_codecs_size".to_string(),    wanted: 8,    got: bytes.len()});}let vendor_specific_codecs_size = u8::from_le_bytes([bytes[7]]);let want_ = 8 + (vendor_specific_codecs_size as usize);if bytes.len() < want_ { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedCodecsV1Complete".to_string(),    field: "vendor_specific_codecs".to_string(),    wanted: want_,    got: bytes.len()});}let vendor_specific_codecs: Vec::<u32> = bytes[8..(8 + vendor_specific_codecs_size as usize)].to_vec().chunks_exact(4).into_iter().map(|i| u32::from_le_bytes([i[0], i[1], i[2], i[3]])).collect();Ok(Self {status, supported_codecs, vendor_specific_codecs, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let supported_codecs_bytes = self.supported_codecs.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8);let supported_codecs_size = u8::try_from(supported_codecs_bytes).expect("payload size did not fit");buffer[6..7].copy_from_slice(&supported_codecs_size.to_le_bytes()[0..1]);for (i, e) in self.supported_codecs.iter().enumerate() {buffer[7+i..7+i+1].copy_from_slice(&e.to_le_bytes())}let vendor_specific_codecs_bytes = self.vendor_specific_codecs.len() * ((/* Bits: */ 32 + /* Dynamic: */ 0) / 8);let vendor_specific_codecs_size = u8::try_from(vendor_specific_codecs_bytes).expect("payload size did not fit");buffer[7..8].copy_from_slice(&vendor_specific_codecs_size.to_le_bytes()[0..1]);for (i, e) in self.vendor_specific_codecs.iter().enumerate() {buffer[8+i..8+i+4].copy_from_slice(&e.to_le_bytes())}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;let ret = ret + (self.supported_codecs.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8));let ret = ret + 1;let ret = ret + (self.vendor_specific_codecs.len() * ((/* Bits: */ 32 + /* Dynamic: */ 0) / 8));ret}
}
impl Packet for ReadLocalSupportedCodecsV1CompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLocalSupportedCodecsV1CompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_local_supported_codecs_v1_complete = match &command_complete.child {CommandCompleteDataChild::ReadLocalSupportedCodecsV1Complete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLocalSupportedCodecsV1Complete"),};Self {event,command_complete,read_local_supported_codecs_v1_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_local_supported_codecs_v1_complete.as_ref().status}
pub fn get_supported_codecs(&self) -> &Vec::<u8>{ &self.read_local_supported_codecs_v1_complete.as_ref().supported_codecs}
pub fn get_vendor_specific_codecs(&self) -> &Vec::<u32>{ &self.read_local_supported_codecs_v1_complete.as_ref().vendor_specific_codecs}
}
impl Into<EventPacket> for ReadLocalSupportedCodecsV1CompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadLocalSupportedCodecsV1CompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadLocalSupportedCodecsV1CompleteBuilder {pub fn build(self) -> ReadLocalSupportedCodecsV1CompletePacket {let read_local_supported_codecs_v1_complete= Arc::new(ReadLocalSupportedCodecsV1CompleteData {status: self.status, supported_codecs: self.supported_codecs, vendor_specific_codecs: self.vendor_specific_codecs, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadLocalSupportedCodecsV1, child: CommandCompleteDataChild::ReadLocalSupportedCodecsV1Complete(read_local_supported_codecs_v1_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadLocalSupportedCodecsV1CompletePacket::new(event)}
}
impl Into<EventPacket> for ReadLocalSupportedCodecsV1CompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadLocalSupportedCodecsV1CompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadLocalSupportedCodecsV2Data {}
#[derive(Debug, Clone)] pub struct ReadLocalSupportedCodecsV2Packet {command: Arc<CommandData>,read_local_supported_codecs_v2: Arc<ReadLocalSupportedCodecsV2Data>,}
#[derive(Debug)] pub struct ReadLocalSupportedCodecsV2Builder {}
impl ReadLocalSupportedCodecsV2Data {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadLocalSupportedCodecsV2Packet { type ResponseType = ReadLocalSupportedCodecsV2CompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLocalSupportedCodecsV2CompletePacket::new(pkt.event.clone()) }}impl Packet for ReadLocalSupportedCodecsV2Packet {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLocalSupportedCodecsV2Packet { fn new(root: Arc<CommandData>) -> Self {let command = root;let read_local_supported_codecs_v2 = match &command.child {CommandDataChild::ReadLocalSupportedCodecsV2(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLocalSupportedCodecsV2"),};Self {command,read_local_supported_codecs_v2,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadLocalSupportedCodecsV2Packet { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for ReadLocalSupportedCodecsV2Builder { type ResponseType = ReadLocalSupportedCodecsV2CompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLocalSupportedCodecsV2CompletePacket::new(pkt.event.clone()) }}impl ReadLocalSupportedCodecsV2Builder {pub fn build(self) -> ReadLocalSupportedCodecsV2Packet {let read_local_supported_codecs_v2= Arc::new(ReadLocalSupportedCodecsV2Data {});let command= Arc::new(CommandData {op_code: OpCode::ReadLocalSupportedCodecsV2, child: CommandDataChild::ReadLocalSupportedCodecsV2(read_local_supported_codecs_v2),});ReadLocalSupportedCodecsV2Packet::new(command)}
}
impl Into<CommandPacket> for ReadLocalSupportedCodecsV2Builder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadLocalSupportedCodecsV2CompleteData {status: ErrorCode, supported_codecs: Vec::<CodecConfiguration>, vendor_specific_codecs: Vec::<VendorCodecConfiguration>, }
#[derive(Debug, Clone)] pub struct ReadLocalSupportedCodecsV2CompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_local_supported_codecs_v2_complete: Arc<ReadLocalSupportedCodecsV2CompleteData>,}
#[derive(Debug)] pub struct ReadLocalSupportedCodecsV2CompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub supported_codecs: Vec::<CodecConfiguration>, pub vendor_specific_codecs: Vec::<VendorCodecConfiguration>, }
impl ReadLocalSupportedCodecsV2CompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedCodecsV2Complete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedCodecsV2Complete".to_string(),    field: "supported_codecs_size".to_string(),    wanted: 7,    got: bytes.len()});}let supported_codecs_size = u8::from_le_bytes([bytes[6]]);let mut supported_codecs: Vec::<CodecConfiguration> = Vec::new();let mut parsable_ = &bytes[7..7 + (supported_codecs_size as usize)];while parsable_.len() > 0 { match CodecConfiguration::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];supported_codecs.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedCodecsV2Complete".to_string(),    field: "vendor_specific_codecs_size".to_string(),    wanted: 8,    got: bytes.len()});}let vendor_specific_codecs_size = u8::from_le_bytes([bytes[7]]);let mut vendor_specific_codecs: Vec::<VendorCodecConfiguration> = Vec::new();let mut parsable_ = &bytes[8..8 + (vendor_specific_codecs_size as usize)];while parsable_.len() > 0 { match VendorCodecConfiguration::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];vendor_specific_codecs.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {status, supported_codecs, vendor_specific_codecs, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let supported_codecs_bytes = self.supported_codecs.len() * ((/* Bits: */ 16 + /* Dynamic: */ 0) / 8);let supported_codecs_size = u8::try_from(supported_codecs_bytes).expect("payload size did not fit");buffer[6..7].copy_from_slice(&supported_codecs_size.to_le_bytes()[0..1]);let mut vec_buffer_ = &mut buffer[7..];for e_ in &self.supported_codecs { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}let vendor_specific_codecs_bytes = self.vendor_specific_codecs.len() * ((/* Bits: */ 40 + /* Dynamic: */ 0) / 8);let vendor_specific_codecs_size = u8::try_from(vendor_specific_codecs_bytes).expect("payload size did not fit");buffer[7..8].copy_from_slice(&vendor_specific_codecs_size.to_le_bytes()[0..1]);let mut vec_buffer_ = &mut buffer[8..];for e_ in &self.vendor_specific_codecs { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;let ret = ret + (self.supported_codecs.len() * ((/* Bits: */ 16 + /* Dynamic: */ 0) / 8));let ret = ret + 1;let ret = ret + (self.vendor_specific_codecs.len() * ((/* Bits: */ 40 + /* Dynamic: */ 0) / 8));ret}
}
impl Packet for ReadLocalSupportedCodecsV2CompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLocalSupportedCodecsV2CompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_local_supported_codecs_v2_complete = match &command_complete.child {CommandCompleteDataChild::ReadLocalSupportedCodecsV2Complete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLocalSupportedCodecsV2Complete"),};Self {event,command_complete,read_local_supported_codecs_v2_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_local_supported_codecs_v2_complete.as_ref().status}
pub fn get_supported_codecs(&self) -> &Vec::<CodecConfiguration>{ &self.read_local_supported_codecs_v2_complete.as_ref().supported_codecs}
pub fn get_vendor_specific_codecs(&self) -> &Vec::<VendorCodecConfiguration>{ &self.read_local_supported_codecs_v2_complete.as_ref().vendor_specific_codecs}
}
impl Into<EventPacket> for ReadLocalSupportedCodecsV2CompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadLocalSupportedCodecsV2CompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadLocalSupportedCodecsV2CompleteBuilder {pub fn build(self) -> ReadLocalSupportedCodecsV2CompletePacket {let read_local_supported_codecs_v2_complete= Arc::new(ReadLocalSupportedCodecsV2CompleteData {status: self.status, supported_codecs: self.supported_codecs, vendor_specific_codecs: self.vendor_specific_codecs, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadLocalSupportedCodecsV2, child: CommandCompleteDataChild::ReadLocalSupportedCodecsV2Complete(read_local_supported_codecs_v2_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadLocalSupportedCodecsV2CompletePacket::new(event)}
}
impl Into<EventPacket> for ReadLocalSupportedCodecsV2CompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadLocalSupportedCodecsV2CompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadLocalSupportedCodecCapabilitiesData {codec_id: u8, company_id: u16, codec_vendor_id: u16, br_edr: u8, br_edr_sco_and_esco: u8, le_cis: u8, le_bis: u8, direction: DataPathDirection, }
#[derive(Debug, Clone)] pub struct ReadLocalSupportedCodecCapabilitiesPacket {command: Arc<CommandData>,read_local_supported_codec_capabilities: Arc<ReadLocalSupportedCodecCapabilitiesData>,}
#[derive(Debug)] pub struct ReadLocalSupportedCodecCapabilitiesBuilder {pub codec_id: u8, pub company_id: u16, pub codec_vendor_id: u16, pub br_edr: u8, pub br_edr_sco_and_esco: u8, pub le_cis: u8, pub le_bis: u8, pub direction: DataPathDirection, }
impl ReadLocalSupportedCodecCapabilitiesData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedCodecCapabilities".to_string(),    field: "codec_id".to_string(),    wanted: 4,    got: bytes.len()});}let codec_id = u8::from_le_bytes([bytes[3]]);if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedCodecCapabilities".to_string(),    field: "company_id".to_string(),    wanted: 6,    got: bytes.len()});}let company_id = u16::from_le_bytes([bytes[4],bytes[5]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedCodecCapabilities".to_string(),    field: "codec_vendor_id".to_string(),    wanted: 8,    got: bytes.len()});}let codec_vendor_id = u16::from_le_bytes([bytes[6],bytes[7]]);let br_edr = u8::from_le_bytes([bytes[8]]);let br_edr = br_edr & 0x1;let br_edr_sco_and_esco = u8::from_le_bytes([bytes[8]]);let br_edr_sco_and_esco = br_edr_sco_and_esco >> 1;let br_edr_sco_and_esco = br_edr_sco_and_esco & 0x1;let le_cis = u8::from_le_bytes([bytes[8]]);let le_cis = le_cis >> 2;let le_cis = le_cis & 0x1;let le_bis = u8::from_le_bytes([bytes[8]]);let le_bis = le_bis >> 3;let le_bis = le_bis & 0x1;if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedCodecCapabilities".to_string(),    field: "direction".to_string(),    wanted: 10,    got: bytes.len()});}let direction = u8::from_le_bytes([bytes[9]]);let direction = DataPathDirection::from_u8(direction).unwrap();Ok(Self {codec_id, company_id, codec_vendor_id, br_edr, br_edr_sco_and_esco, le_cis, le_bis, direction, })
}
fn write_to(&self, buffer: &mut BytesMut) {let codec_id = self.codec_id;buffer[3..4].copy_from_slice(&codec_id.to_le_bytes()[0..1]);let company_id = self.company_id;buffer[4..6].copy_from_slice(&company_id.to_le_bytes()[0..2]);let codec_vendor_id = self.codec_vendor_id;buffer[6..8].copy_from_slice(&codec_vendor_id.to_le_bytes()[0..2]);let br_edr = self.br_edr;let br_edr = br_edr & 0x1;buffer[8..9].copy_from_slice(&br_edr.to_le_bytes()[0..1]);let br_edr_sco_and_esco = self.br_edr_sco_and_esco;let br_edr_sco_and_esco = br_edr_sco_and_esco & 0x1;let br_edr_sco_and_esco = (br_edr_sco_and_esco << 1) | ((buffer[8] as u8) & 0x1);buffer[8..9].copy_from_slice(&br_edr_sco_and_esco.to_le_bytes()[0..1]);let le_cis = self.le_cis;let le_cis = le_cis & 0x1;let le_cis = (le_cis << 2) | ((buffer[8] as u8) & 0x3);buffer[8..9].copy_from_slice(&le_cis.to_le_bytes()[0..1]);let le_bis = self.le_bis;let le_bis = le_bis & 0x1;let le_bis = (le_bis << 3) | ((buffer[8] as u8) & 0x7);buffer[8..9].copy_from_slice(&le_bis.to_le_bytes()[0..1]);let direction = self.direction.to_u8().unwrap();buffer[9..10].copy_from_slice(&direction.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl CommandExpectations for ReadLocalSupportedCodecCapabilitiesPacket { type ResponseType = ReadLocalSupportedCodecCapabilitiesCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLocalSupportedCodecCapabilitiesCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadLocalSupportedCodecCapabilitiesPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLocalSupportedCodecCapabilitiesPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let read_local_supported_codec_capabilities = match &command.child {CommandDataChild::ReadLocalSupportedCodecCapabilities(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLocalSupportedCodecCapabilities"),};Self {command,read_local_supported_codec_capabilities,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_codec_id(&self) -> u8{ self.read_local_supported_codec_capabilities.as_ref().codec_id}
pub fn get_company_id(&self) -> u16{ self.read_local_supported_codec_capabilities.as_ref().company_id}
pub fn get_codec_vendor_id(&self) -> u16{ self.read_local_supported_codec_capabilities.as_ref().codec_vendor_id}
pub fn get_br_edr(&self) -> u8{ self.read_local_supported_codec_capabilities.as_ref().br_edr}
pub fn get_br_edr_sco_and_esco(&self) -> u8{ self.read_local_supported_codec_capabilities.as_ref().br_edr_sco_and_esco}
pub fn get_le_cis(&self) -> u8{ self.read_local_supported_codec_capabilities.as_ref().le_cis}
pub fn get_le_bis(&self) -> u8{ self.read_local_supported_codec_capabilities.as_ref().le_bis}
pub fn get_direction(&self) -> DataPathDirection{ self.read_local_supported_codec_capabilities.as_ref().direction}
}
impl Into<CommandPacket> for ReadLocalSupportedCodecCapabilitiesPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for ReadLocalSupportedCodecCapabilitiesBuilder { type ResponseType = ReadLocalSupportedCodecCapabilitiesCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLocalSupportedCodecCapabilitiesCompletePacket::new(pkt.event.clone()) }}impl ReadLocalSupportedCodecCapabilitiesBuilder {pub fn build(self) -> ReadLocalSupportedCodecCapabilitiesPacket {let read_local_supported_codec_capabilities= Arc::new(ReadLocalSupportedCodecCapabilitiesData {codec_id: self.codec_id, company_id: self.company_id, codec_vendor_id: self.codec_vendor_id, br_edr: self.br_edr, br_edr_sco_and_esco: self.br_edr_sco_and_esco, le_cis: self.le_cis, le_bis: self.le_bis, direction: self.direction, });let command= Arc::new(CommandData {op_code: OpCode::ReadLocalSupportedCodecCapabilities, child: CommandDataChild::ReadLocalSupportedCodecCapabilities(read_local_supported_codec_capabilities),});ReadLocalSupportedCodecCapabilitiesPacket::new(command)}
}
impl Into<CommandPacket> for ReadLocalSupportedCodecCapabilitiesBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadLocalSupportedCodecCapabilitiesCompleteData {status: ErrorCode, codec_capabilities: Vec::<CodecCapability>, }
#[derive(Debug, Clone)] pub struct ReadLocalSupportedCodecCapabilitiesCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_local_supported_codec_capabilities_complete: Arc<ReadLocalSupportedCodecCapabilitiesCompleteData>,}
#[derive(Debug)] pub struct ReadLocalSupportedCodecCapabilitiesCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub codec_capabilities: Vec::<CodecCapability>, }
impl ReadLocalSupportedCodecCapabilitiesCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedCodecCapabilitiesComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedCodecCapabilitiesComplete".to_string(),    field: "codec_capabilities_count".to_string(),    wanted: 7,    got: bytes.len()});}let codec_capabilities_count = u8::from_le_bytes([bytes[6]]);let mut codec_capabilities: Vec::<CodecCapability> = Vec::new();let mut parsable_ = &bytes[7..];let count_ = codec_capabilities_count as usize;for _ in 0..count_ { match CodecCapability::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];codec_capabilities.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {status, codec_capabilities, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);buffer[6..7].copy_from_slice(&(self.codec_capabilities.len() as u8).to_le_bytes());let mut vec_buffer_ = &mut buffer[7..];for e_ in &self.codec_capabilities { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;let ret = ret + self.codec_capabilities.iter().fold(0, |acc, x| acc + x.get_total_size());ret}
}
impl Packet for ReadLocalSupportedCodecCapabilitiesCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLocalSupportedCodecCapabilitiesCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_local_supported_codec_capabilities_complete = match &command_complete.child {CommandCompleteDataChild::ReadLocalSupportedCodecCapabilitiesComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLocalSupportedCodecCapabilitiesComplete"),};Self {event,command_complete,read_local_supported_codec_capabilities_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_local_supported_codec_capabilities_complete.as_ref().status}
pub fn get_codec_capabilities(&self) -> &Vec::<CodecCapability>{ &self.read_local_supported_codec_capabilities_complete.as_ref().codec_capabilities}
}
impl Into<EventPacket> for ReadLocalSupportedCodecCapabilitiesCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadLocalSupportedCodecCapabilitiesCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadLocalSupportedCodecCapabilitiesCompleteBuilder {pub fn build(self) -> ReadLocalSupportedCodecCapabilitiesCompletePacket {let read_local_supported_codec_capabilities_complete= Arc::new(ReadLocalSupportedCodecCapabilitiesCompleteData {status: self.status, codec_capabilities: self.codec_capabilities, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadLocalSupportedCodecCapabilities, child: CommandCompleteDataChild::ReadLocalSupportedCodecCapabilitiesComplete(read_local_supported_codec_capabilities_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadLocalSupportedCodecCapabilitiesCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadLocalSupportedCodecCapabilitiesCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadLocalSupportedCodecCapabilitiesCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadLocalSupportedControllerDelayData {codec_id: u8, company_id: u16, codec_vendor_id: u16, br_edr: u8, br_edr_sco_and_esco: u8, le_cis: u8, le_bis: u8, direction: DataPathDirection, codec_configuration: Vec::<u8>, }
#[derive(Debug, Clone)] pub struct ReadLocalSupportedControllerDelayPacket {command: Arc<CommandData>,read_local_supported_controller_delay: Arc<ReadLocalSupportedControllerDelayData>,}
#[derive(Debug)] pub struct ReadLocalSupportedControllerDelayBuilder {pub codec_id: u8, pub company_id: u16, pub codec_vendor_id: u16, pub br_edr: u8, pub br_edr_sco_and_esco: u8, pub le_cis: u8, pub le_bis: u8, pub direction: DataPathDirection, pub codec_configuration: Vec::<u8>, }
impl ReadLocalSupportedControllerDelayData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedControllerDelay".to_string(),    field: "codec_id".to_string(),    wanted: 4,    got: bytes.len()});}let codec_id = u8::from_le_bytes([bytes[3]]);if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedControllerDelay".to_string(),    field: "company_id".to_string(),    wanted: 6,    got: bytes.len()});}let company_id = u16::from_le_bytes([bytes[4],bytes[5]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedControllerDelay".to_string(),    field: "codec_vendor_id".to_string(),    wanted: 8,    got: bytes.len()});}let codec_vendor_id = u16::from_le_bytes([bytes[6],bytes[7]]);let br_edr = u8::from_le_bytes([bytes[8]]);let br_edr = br_edr & 0x1;let br_edr_sco_and_esco = u8::from_le_bytes([bytes[8]]);let br_edr_sco_and_esco = br_edr_sco_and_esco >> 1;let br_edr_sco_and_esco = br_edr_sco_and_esco & 0x1;let le_cis = u8::from_le_bytes([bytes[8]]);let le_cis = le_cis >> 2;let le_cis = le_cis & 0x1;let le_bis = u8::from_le_bytes([bytes[8]]);let le_bis = le_bis >> 3;let le_bis = le_bis & 0x1;if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedControllerDelay".to_string(),    field: "direction".to_string(),    wanted: 10,    got: bytes.len()});}let direction = u8::from_le_bytes([bytes[9]]);let direction = DataPathDirection::from_u8(direction).unwrap();if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedControllerDelay".to_string(),    field: "codec_configuration_size".to_string(),    wanted: 11,    got: bytes.len()});}let codec_configuration_size = u8::from_le_bytes([bytes[10]]);let want_ = 11 + (codec_configuration_size as usize);if bytes.len() < want_ { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedControllerDelay".to_string(),    field: "codec_configuration".to_string(),    wanted: want_,    got: bytes.len()});}let codec_configuration: Vec::<u8> = bytes[11..(11 + codec_configuration_size as usize)].to_vec().chunks_exact(1).into_iter().map(|i| u8::from_le_bytes([i[0]])).collect();Ok(Self {codec_id, company_id, codec_vendor_id, br_edr, br_edr_sco_and_esco, le_cis, le_bis, direction, codec_configuration, })
}
fn write_to(&self, buffer: &mut BytesMut) {let codec_id = self.codec_id;buffer[3..4].copy_from_slice(&codec_id.to_le_bytes()[0..1]);let company_id = self.company_id;buffer[4..6].copy_from_slice(&company_id.to_le_bytes()[0..2]);let codec_vendor_id = self.codec_vendor_id;buffer[6..8].copy_from_slice(&codec_vendor_id.to_le_bytes()[0..2]);let br_edr = self.br_edr;let br_edr = br_edr & 0x1;buffer[8..9].copy_from_slice(&br_edr.to_le_bytes()[0..1]);let br_edr_sco_and_esco = self.br_edr_sco_and_esco;let br_edr_sco_and_esco = br_edr_sco_and_esco & 0x1;let br_edr_sco_and_esco = (br_edr_sco_and_esco << 1) | ((buffer[8] as u8) & 0x1);buffer[8..9].copy_from_slice(&br_edr_sco_and_esco.to_le_bytes()[0..1]);let le_cis = self.le_cis;let le_cis = le_cis & 0x1;let le_cis = (le_cis << 2) | ((buffer[8] as u8) & 0x3);buffer[8..9].copy_from_slice(&le_cis.to_le_bytes()[0..1]);let le_bis = self.le_bis;let le_bis = le_bis & 0x1;let le_bis = (le_bis << 3) | ((buffer[8] as u8) & 0x7);buffer[8..9].copy_from_slice(&le_bis.to_le_bytes()[0..1]);let direction = self.direction.to_u8().unwrap();buffer[9..10].copy_from_slice(&direction.to_le_bytes()[0..1]);let codec_configuration_bytes = self.codec_configuration.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8);let codec_configuration_size = u8::try_from(codec_configuration_bytes).expect("payload size did not fit");buffer[10..11].copy_from_slice(&codec_configuration_size.to_le_bytes()[0..1]);for (i, e) in self.codec_configuration.iter().enumerate() {buffer[11+i..11+i+1].copy_from_slice(&e.to_le_bytes())}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 8;let ret = ret + (self.codec_configuration.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8));ret}
}
impl CommandExpectations for ReadLocalSupportedControllerDelayPacket { type ResponseType = ReadLocalSupportedControllerDelayCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLocalSupportedControllerDelayCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadLocalSupportedControllerDelayPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLocalSupportedControllerDelayPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let read_local_supported_controller_delay = match &command.child {CommandDataChild::ReadLocalSupportedControllerDelay(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLocalSupportedControllerDelay"),};Self {command,read_local_supported_controller_delay,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_codec_id(&self) -> u8{ self.read_local_supported_controller_delay.as_ref().codec_id}
pub fn get_company_id(&self) -> u16{ self.read_local_supported_controller_delay.as_ref().company_id}
pub fn get_codec_vendor_id(&self) -> u16{ self.read_local_supported_controller_delay.as_ref().codec_vendor_id}
pub fn get_br_edr(&self) -> u8{ self.read_local_supported_controller_delay.as_ref().br_edr}
pub fn get_br_edr_sco_and_esco(&self) -> u8{ self.read_local_supported_controller_delay.as_ref().br_edr_sco_and_esco}
pub fn get_le_cis(&self) -> u8{ self.read_local_supported_controller_delay.as_ref().le_cis}
pub fn get_le_bis(&self) -> u8{ self.read_local_supported_controller_delay.as_ref().le_bis}
pub fn get_direction(&self) -> DataPathDirection{ self.read_local_supported_controller_delay.as_ref().direction}
pub fn get_codec_configuration(&self) -> &Vec::<u8>{ &self.read_local_supported_controller_delay.as_ref().codec_configuration}
}
impl Into<CommandPacket> for ReadLocalSupportedControllerDelayPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for ReadLocalSupportedControllerDelayBuilder { type ResponseType = ReadLocalSupportedControllerDelayCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLocalSupportedControllerDelayCompletePacket::new(pkt.event.clone()) }}impl ReadLocalSupportedControllerDelayBuilder {pub fn build(self) -> ReadLocalSupportedControllerDelayPacket {let read_local_supported_controller_delay= Arc::new(ReadLocalSupportedControllerDelayData {codec_id: self.codec_id, company_id: self.company_id, codec_vendor_id: self.codec_vendor_id, br_edr: self.br_edr, br_edr_sco_and_esco: self.br_edr_sco_and_esco, le_cis: self.le_cis, le_bis: self.le_bis, direction: self.direction, codec_configuration: self.codec_configuration, });let command= Arc::new(CommandData {op_code: OpCode::ReadLocalSupportedControllerDelay, child: CommandDataChild::ReadLocalSupportedControllerDelay(read_local_supported_controller_delay),});ReadLocalSupportedControllerDelayPacket::new(command)}
}
impl Into<CommandPacket> for ReadLocalSupportedControllerDelayBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadLocalSupportedControllerDelayCompleteData {status: ErrorCode, min_controller_delay: u32, max_controller_delay: u32, }
#[derive(Debug, Clone)] pub struct ReadLocalSupportedControllerDelayCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_local_supported_controller_delay_complete: Arc<ReadLocalSupportedControllerDelayCompleteData>,}
#[derive(Debug)] pub struct ReadLocalSupportedControllerDelayCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub min_controller_delay: u32, pub max_controller_delay: u32, }
impl ReadLocalSupportedControllerDelayCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedControllerDelayComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedControllerDelayComplete".to_string(),    field: "min_controller_delay".to_string(),    wanted: 9,    got: bytes.len()});}let min_controller_delay = u32::from_le_bytes([bytes[6],bytes[7],bytes[8],0]);let min_controller_delay = min_controller_delay & 0xffffff;if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "ReadLocalSupportedControllerDelayComplete".to_string(),    field: "max_controller_delay".to_string(),    wanted: 12,    got: bytes.len()});}let max_controller_delay = u32::from_le_bytes([bytes[9],bytes[10],bytes[11],0]);let max_controller_delay = max_controller_delay & 0xffffff;Ok(Self {status, min_controller_delay, max_controller_delay, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let min_controller_delay = self.min_controller_delay;let min_controller_delay = min_controller_delay & 0xffffff;buffer[6..9].copy_from_slice(&min_controller_delay.to_le_bytes()[0..3]);let max_controller_delay = self.max_controller_delay;let max_controller_delay = max_controller_delay & 0xffffff;buffer[9..12].copy_from_slice(&max_controller_delay.to_le_bytes()[0..3]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for ReadLocalSupportedControllerDelayCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLocalSupportedControllerDelayCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_local_supported_controller_delay_complete = match &command_complete.child {CommandCompleteDataChild::ReadLocalSupportedControllerDelayComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLocalSupportedControllerDelayComplete"),};Self {event,command_complete,read_local_supported_controller_delay_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_local_supported_controller_delay_complete.as_ref().status}
pub fn get_min_controller_delay(&self) -> u32{ self.read_local_supported_controller_delay_complete.as_ref().min_controller_delay}
pub fn get_max_controller_delay(&self) -> u32{ self.read_local_supported_controller_delay_complete.as_ref().max_controller_delay}
}
impl Into<EventPacket> for ReadLocalSupportedControllerDelayCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadLocalSupportedControllerDelayCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadLocalSupportedControllerDelayCompleteBuilder {pub fn build(self) -> ReadLocalSupportedControllerDelayCompletePacket {let read_local_supported_controller_delay_complete= Arc::new(ReadLocalSupportedControllerDelayCompleteData {status: self.status, min_controller_delay: self.min_controller_delay, max_controller_delay: self.max_controller_delay, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadLocalSupportedControllerDelay, child: CommandCompleteDataChild::ReadLocalSupportedControllerDelayComplete(read_local_supported_controller_delay_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadLocalSupportedControllerDelayCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadLocalSupportedControllerDelayCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadLocalSupportedControllerDelayCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadFailedContactCounterData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct ReadFailedContactCounterPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,read_failed_contact_counter: Arc<ReadFailedContactCounterData>,}
#[derive(Debug)] pub struct ReadFailedContactCounterBuilder {pub connection_handle: u16, }
impl ReadFailedContactCounterData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ReadFailedContactCounter".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for ReadFailedContactCounterPacket { type ResponseType = ReadFailedContactCounterCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadFailedContactCounterCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadFailedContactCounterPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadFailedContactCounterPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let read_failed_contact_counter = match &connection_management_command.child {ConnectionManagementCommandDataChild::ReadFailedContactCounter(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadFailedContactCounter"),};Self {command,acl_command,connection_management_command,read_failed_contact_counter,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.read_failed_contact_counter.as_ref().connection_handle}
}
impl Into<CommandPacket> for ReadFailedContactCounterPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for ReadFailedContactCounterPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for ReadFailedContactCounterPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for ReadFailedContactCounterBuilder { type ResponseType = ReadFailedContactCounterCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadFailedContactCounterCompletePacket::new(pkt.event.clone()) }}impl ReadFailedContactCounterBuilder {pub fn build(self) -> ReadFailedContactCounterPacket {let read_failed_contact_counter= Arc::new(ReadFailedContactCounterData {connection_handle: self.connection_handle, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::ReadFailedContactCounter(read_failed_contact_counter),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::ReadFailedContactCounter, child: CommandDataChild::AclCommand(acl_command),});ReadFailedContactCounterPacket::new(command)}
}
impl Into<CommandPacket> for ReadFailedContactCounterBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for ReadFailedContactCounterBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for ReadFailedContactCounterBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadFailedContactCounterCompleteData {status: ErrorCode, connection_handle: u16, failed_contact_counter: u16, }
#[derive(Debug, Clone)] pub struct ReadFailedContactCounterCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_failed_contact_counter_complete: Arc<ReadFailedContactCounterCompleteData>,}
#[derive(Debug)] pub struct ReadFailedContactCounterCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, pub failed_contact_counter: u16, }
impl ReadFailedContactCounterCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadFailedContactCounterComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadFailedContactCounterComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "ReadFailedContactCounterComplete".to_string(),    field: "failed_contact_counter".to_string(),    wanted: 10,    got: bytes.len()});}let failed_contact_counter = u16::from_le_bytes([bytes[8],bytes[9]]);Ok(Self {status, connection_handle, failed_contact_counter, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let failed_contact_counter = self.failed_contact_counter;buffer[8..10].copy_from_slice(&failed_contact_counter.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 5;ret}
}
impl Packet for ReadFailedContactCounterCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadFailedContactCounterCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_failed_contact_counter_complete = match &command_complete.child {CommandCompleteDataChild::ReadFailedContactCounterComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadFailedContactCounterComplete"),};Self {event,command_complete,read_failed_contact_counter_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_failed_contact_counter_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.read_failed_contact_counter_complete.as_ref().connection_handle}
pub fn get_failed_contact_counter(&self) -> u16{ self.read_failed_contact_counter_complete.as_ref().failed_contact_counter}
}
impl Into<EventPacket> for ReadFailedContactCounterCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadFailedContactCounterCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadFailedContactCounterCompleteBuilder {pub fn build(self) -> ReadFailedContactCounterCompletePacket {let read_failed_contact_counter_complete= Arc::new(ReadFailedContactCounterCompleteData {status: self.status, connection_handle: self.connection_handle, failed_contact_counter: self.failed_contact_counter, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadFailedContactCounter, child: CommandCompleteDataChild::ReadFailedContactCounterComplete(read_failed_contact_counter_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadFailedContactCounterCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadFailedContactCounterCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadFailedContactCounterCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ResetFailedContactCounterData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct ResetFailedContactCounterPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,reset_failed_contact_counter: Arc<ResetFailedContactCounterData>,}
#[derive(Debug)] pub struct ResetFailedContactCounterBuilder {pub connection_handle: u16, }
impl ResetFailedContactCounterData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ResetFailedContactCounter".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for ResetFailedContactCounterPacket { type ResponseType = ResetFailedContactCounterCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ResetFailedContactCounterCompletePacket::new(pkt.event.clone()) }}impl Packet for ResetFailedContactCounterPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ResetFailedContactCounterPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let reset_failed_contact_counter = match &connection_management_command.child {ConnectionManagementCommandDataChild::ResetFailedContactCounter(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ResetFailedContactCounter"),};Self {command,acl_command,connection_management_command,reset_failed_contact_counter,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.reset_failed_contact_counter.as_ref().connection_handle}
}
impl Into<CommandPacket> for ResetFailedContactCounterPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for ResetFailedContactCounterPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for ResetFailedContactCounterPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for ResetFailedContactCounterBuilder { type ResponseType = ResetFailedContactCounterCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ResetFailedContactCounterCompletePacket::new(pkt.event.clone()) }}impl ResetFailedContactCounterBuilder {pub fn build(self) -> ResetFailedContactCounterPacket {let reset_failed_contact_counter= Arc::new(ResetFailedContactCounterData {connection_handle: self.connection_handle, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::ResetFailedContactCounter(reset_failed_contact_counter),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::ResetFailedContactCounter, child: CommandDataChild::AclCommand(acl_command),});ResetFailedContactCounterPacket::new(command)}
}
impl Into<CommandPacket> for ResetFailedContactCounterBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for ResetFailedContactCounterBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for ResetFailedContactCounterBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct ResetFailedContactCounterCompleteData {status: ErrorCode, connection_handle: u16, }
#[derive(Debug, Clone)] pub struct ResetFailedContactCounterCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,reset_failed_contact_counter_complete: Arc<ResetFailedContactCounterCompleteData>,}
#[derive(Debug)] pub struct ResetFailedContactCounterCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, }
impl ResetFailedContactCounterCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ResetFailedContactCounterComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ResetFailedContactCounterComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;Ok(Self {status, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for ResetFailedContactCounterCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ResetFailedContactCounterCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let reset_failed_contact_counter_complete = match &command_complete.child {CommandCompleteDataChild::ResetFailedContactCounterComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ResetFailedContactCounterComplete"),};Self {event,command_complete,reset_failed_contact_counter_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.reset_failed_contact_counter_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.reset_failed_contact_counter_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for ResetFailedContactCounterCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ResetFailedContactCounterCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ResetFailedContactCounterCompleteBuilder {pub fn build(self) -> ResetFailedContactCounterCompletePacket {let reset_failed_contact_counter_complete= Arc::new(ResetFailedContactCounterCompleteData {status: self.status, connection_handle: self.connection_handle, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ResetFailedContactCounter, child: CommandCompleteDataChild::ResetFailedContactCounterComplete(reset_failed_contact_counter_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ResetFailedContactCounterCompletePacket::new(event)}
}
impl Into<EventPacket> for ResetFailedContactCounterCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ResetFailedContactCounterCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadLinkQualityData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct ReadLinkQualityPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,read_link_quality: Arc<ReadLinkQualityData>,}
#[derive(Debug)] pub struct ReadLinkQualityBuilder {pub connection_handle: u16, }
impl ReadLinkQualityData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ReadLinkQuality".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for ReadLinkQualityPacket { type ResponseType = ReadLinkQualityCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLinkQualityCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadLinkQualityPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLinkQualityPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let read_link_quality = match &connection_management_command.child {ConnectionManagementCommandDataChild::ReadLinkQuality(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLinkQuality"),};Self {command,acl_command,connection_management_command,read_link_quality,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.read_link_quality.as_ref().connection_handle}
}
impl Into<CommandPacket> for ReadLinkQualityPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for ReadLinkQualityPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for ReadLinkQualityPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for ReadLinkQualityBuilder { type ResponseType = ReadLinkQualityCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLinkQualityCompletePacket::new(pkt.event.clone()) }}impl ReadLinkQualityBuilder {pub fn build(self) -> ReadLinkQualityPacket {let read_link_quality= Arc::new(ReadLinkQualityData {connection_handle: self.connection_handle, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::ReadLinkQuality(read_link_quality),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::ReadLinkQuality, child: CommandDataChild::AclCommand(acl_command),});ReadLinkQualityPacket::new(command)}
}
impl Into<CommandPacket> for ReadLinkQualityBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for ReadLinkQualityBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for ReadLinkQualityBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadLinkQualityCompleteData {status: ErrorCode, connection_handle: u16, link_quality: u8, }
#[derive(Debug, Clone)] pub struct ReadLinkQualityCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_link_quality_complete: Arc<ReadLinkQualityCompleteData>,}
#[derive(Debug)] pub struct ReadLinkQualityCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, pub link_quality: u8, }
impl ReadLinkQualityCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadLinkQualityComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadLinkQualityComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "ReadLinkQualityComplete".to_string(),    field: "link_quality".to_string(),    wanted: 9,    got: bytes.len()});}let link_quality = u8::from_le_bytes([bytes[8]]);Ok(Self {status, connection_handle, link_quality, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let link_quality = self.link_quality;buffer[8..9].copy_from_slice(&link_quality.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl Packet for ReadLinkQualityCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLinkQualityCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_link_quality_complete = match &command_complete.child {CommandCompleteDataChild::ReadLinkQualityComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLinkQualityComplete"),};Self {event,command_complete,read_link_quality_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_link_quality_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.read_link_quality_complete.as_ref().connection_handle}
pub fn get_link_quality(&self) -> u8{ self.read_link_quality_complete.as_ref().link_quality}
}
impl Into<EventPacket> for ReadLinkQualityCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadLinkQualityCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadLinkQualityCompleteBuilder {pub fn build(self) -> ReadLinkQualityCompletePacket {let read_link_quality_complete= Arc::new(ReadLinkQualityCompleteData {status: self.status, connection_handle: self.connection_handle, link_quality: self.link_quality, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadLinkQuality, child: CommandCompleteDataChild::ReadLinkQualityComplete(read_link_quality_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadLinkQualityCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadLinkQualityCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadLinkQualityCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadRssiData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct ReadRssiPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,read_rssi: Arc<ReadRssiData>,}
#[derive(Debug)] pub struct ReadRssiBuilder {pub connection_handle: u16, }
impl ReadRssiData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ReadRssi".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for ReadRssiPacket { type ResponseType = ReadRssiCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadRssiCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadRssiPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadRssiPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let read_rssi = match &acl_command.child {AclCommandDataChild::ReadRssi(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadRssi"),};Self {command,acl_command,read_rssi,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.read_rssi.as_ref().connection_handle}
}
impl Into<CommandPacket> for ReadRssiPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for ReadRssiPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl CommandExpectations for ReadRssiBuilder { type ResponseType = ReadRssiCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadRssiCompletePacket::new(pkt.event.clone()) }}impl ReadRssiBuilder {pub fn build(self) -> ReadRssiPacket {let read_rssi= Arc::new(ReadRssiData {connection_handle: self.connection_handle, });let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ReadRssi(read_rssi),});let command= Arc::new(CommandData {op_code: OpCode::ReadRssi, child: CommandDataChild::AclCommand(acl_command),});ReadRssiPacket::new(command)}
}
impl Into<CommandPacket> for ReadRssiBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for ReadRssiBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadRssiCompleteData {status: ErrorCode, connection_handle: u16, rssi: u8, }
#[derive(Debug, Clone)] pub struct ReadRssiCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_rssi_complete: Arc<ReadRssiCompleteData>,}
#[derive(Debug)] pub struct ReadRssiCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, pub rssi: u8, }
impl ReadRssiCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadRssiComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadRssiComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "ReadRssiComplete".to_string(),    field: "rssi".to_string(),    wanted: 9,    got: bytes.len()});}let rssi = u8::from_le_bytes([bytes[8]]);Ok(Self {status, connection_handle, rssi, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let rssi = self.rssi;buffer[8..9].copy_from_slice(&rssi.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl Packet for ReadRssiCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadRssiCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_rssi_complete = match &command_complete.child {CommandCompleteDataChild::ReadRssiComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadRssiComplete"),};Self {event,command_complete,read_rssi_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_rssi_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.read_rssi_complete.as_ref().connection_handle}
pub fn get_rssi(&self) -> u8{ self.read_rssi_complete.as_ref().rssi}
}
impl Into<EventPacket> for ReadRssiCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadRssiCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadRssiCompleteBuilder {pub fn build(self) -> ReadRssiCompletePacket {let read_rssi_complete= Arc::new(ReadRssiCompleteData {status: self.status, connection_handle: self.connection_handle, rssi: self.rssi, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadRssi, child: CommandCompleteDataChild::ReadRssiComplete(read_rssi_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadRssiCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadRssiCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadRssiCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadAfhChannelMapData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct ReadAfhChannelMapPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,read_afh_channel_map: Arc<ReadAfhChannelMapData>,}
#[derive(Debug)] pub struct ReadAfhChannelMapBuilder {pub connection_handle: u16, }
impl ReadAfhChannelMapData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ReadAfhChannelMap".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for ReadAfhChannelMapPacket { type ResponseType = ReadAfhChannelMapCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadAfhChannelMapCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadAfhChannelMapPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadAfhChannelMapPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let read_afh_channel_map = match &connection_management_command.child {ConnectionManagementCommandDataChild::ReadAfhChannelMap(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadAfhChannelMap"),};Self {command,acl_command,connection_management_command,read_afh_channel_map,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.read_afh_channel_map.as_ref().connection_handle}
}
impl Into<CommandPacket> for ReadAfhChannelMapPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for ReadAfhChannelMapPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for ReadAfhChannelMapPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for ReadAfhChannelMapBuilder { type ResponseType = ReadAfhChannelMapCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadAfhChannelMapCompletePacket::new(pkt.event.clone()) }}impl ReadAfhChannelMapBuilder {pub fn build(self) -> ReadAfhChannelMapPacket {let read_afh_channel_map= Arc::new(ReadAfhChannelMapData {connection_handle: self.connection_handle, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::ReadAfhChannelMap(read_afh_channel_map),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::ReadAfhChannelMap, child: CommandDataChild::AclCommand(acl_command),});ReadAfhChannelMapPacket::new(command)}
}
impl Into<CommandPacket> for ReadAfhChannelMapBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for ReadAfhChannelMapBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for ReadAfhChannelMapBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadAfhChannelMapCompleteData {status: ErrorCode, connection_handle: u16, afh_mode: AfhMode, afh_channel_map: [u8; 10], }
#[derive(Debug, Clone)] pub struct ReadAfhChannelMapCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_afh_channel_map_complete: Arc<ReadAfhChannelMapCompleteData>,}
#[derive(Debug)] pub struct ReadAfhChannelMapCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, pub afh_mode: AfhMode, pub afh_channel_map: [u8; 10], }
impl ReadAfhChannelMapCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadAfhChannelMapComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadAfhChannelMapComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "ReadAfhChannelMapComplete".to_string(),    field: "afh_mode".to_string(),    wanted: 9,    got: bytes.len()});}let afh_mode = u8::from_le_bytes([bytes[8]]);let afh_mode = AfhMode::from_u8(afh_mode).unwrap();if bytes.len() < 19 { return Err(Error::InvalidLengthError{    obj: "ReadAfhChannelMapComplete".to_string(),    field: "afh_channel_map".to_string(),    wanted: 19,    got: bytes.len()});}let afh_channel_map = bytes[9..19].try_into().unwrap();Ok(Self {status, connection_handle, afh_mode, afh_channel_map, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let afh_mode = self.afh_mode.to_u8().unwrap();buffer[8..9].copy_from_slice(&afh_mode.to_le_bytes()[0..1]);&buffer[9..19].copy_from_slice(&self.afh_channel_map);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 14;ret}
}
impl Packet for ReadAfhChannelMapCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadAfhChannelMapCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_afh_channel_map_complete = match &command_complete.child {CommandCompleteDataChild::ReadAfhChannelMapComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadAfhChannelMapComplete"),};Self {event,command_complete,read_afh_channel_map_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_afh_channel_map_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.read_afh_channel_map_complete.as_ref().connection_handle}
pub fn get_afh_mode(&self) -> AfhMode{ self.read_afh_channel_map_complete.as_ref().afh_mode}
pub fn get_afh_channel_map(&self) -> &[u8; 10]{ &self.read_afh_channel_map_complete.as_ref().afh_channel_map}
}
impl Into<EventPacket> for ReadAfhChannelMapCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadAfhChannelMapCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadAfhChannelMapCompleteBuilder {pub fn build(self) -> ReadAfhChannelMapCompletePacket {let read_afh_channel_map_complete= Arc::new(ReadAfhChannelMapCompleteData {status: self.status, connection_handle: self.connection_handle, afh_mode: self.afh_mode, afh_channel_map: self.afh_channel_map, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadAfhChannelMap, child: CommandCompleteDataChild::ReadAfhChannelMapComplete(read_afh_channel_map_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadAfhChannelMapCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadAfhChannelMapCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadAfhChannelMapCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadClockData {connection_handle: u16, which_clock: WhichClock, }
#[derive(Debug, Clone)] pub struct ReadClockPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,connection_management_command: Arc<ConnectionManagementCommandData>,read_clock: Arc<ReadClockData>,}
#[derive(Debug)] pub struct ReadClockBuilder {pub connection_handle: u16, pub which_clock: WhichClock, }
impl ReadClockData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ReadClock".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadClock".to_string(),    field: "which_clock".to_string(),    wanted: 6,    got: bytes.len()});}let which_clock = u8::from_le_bytes([bytes[5]]);let which_clock = WhichClock::from_u8(which_clock).unwrap();Ok(Self {connection_handle, which_clock, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let which_clock = self.which_clock.to_u8().unwrap();buffer[5..6].copy_from_slice(&which_clock.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl CommandExpectations for ReadClockPacket { type ResponseType = ReadClockCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadClockCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadClockPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadClockPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let connection_management_command = match &acl_command.child {AclCommandDataChild::ConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionManagementCommand"),};let read_clock = match &connection_management_command.child {ConnectionManagementCommandDataChild::ReadClock(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadClock"),};Self {command,acl_command,connection_management_command,read_clock,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.read_clock.as_ref().connection_handle}
pub fn get_which_clock(&self) -> WhichClock{ self.read_clock.as_ref().which_clock}
}
impl Into<CommandPacket> for ReadClockPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for ReadClockPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<ConnectionManagementCommandPacket> for ReadClockPacket { fn into(self) -> ConnectionManagementCommandPacket {ConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for ReadClockBuilder { type ResponseType = ReadClockCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadClockCompletePacket::new(pkt.event.clone()) }}impl ReadClockBuilder {pub fn build(self) -> ReadClockPacket {let read_clock= Arc::new(ReadClockData {connection_handle: self.connection_handle, which_clock: self.which_clock, });let connection_management_command= Arc::new(ConnectionManagementCommandData {child: ConnectionManagementCommandDataChild::ReadClock(read_clock),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::ConnectionManagementCommand(connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::ReadClock, child: CommandDataChild::AclCommand(acl_command),});ReadClockPacket::new(command)}
}
impl Into<CommandPacket> for ReadClockBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for ReadClockBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<ConnectionManagementCommandPacket> for ReadClockBuilder { fn into(self) -> ConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadClockCompleteData {status: ErrorCode, connection_handle: u16, clock: u32, accuracy: u16, }
#[derive(Debug, Clone)] pub struct ReadClockCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_clock_complete: Arc<ReadClockCompleteData>,}
#[derive(Debug)] pub struct ReadClockCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, pub clock: u32, pub accuracy: u16, }
impl ReadClockCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadClockComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadClockComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "ReadClockComplete".to_string(),    field: "clock".to_string(),    wanted: 12,    got: bytes.len()});}let clock = u32::from_le_bytes([bytes[8],bytes[9],bytes[10],bytes[11]]);let clock = clock & 0xfffffff;if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "ReadClockComplete".to_string(),    field: "accuracy".to_string(),    wanted: 14,    got: bytes.len()});}let accuracy = u16::from_le_bytes([bytes[12],bytes[13]]);Ok(Self {status, connection_handle, clock, accuracy, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let clock = self.clock;let clock = clock & 0xfffffff;buffer[8..12].copy_from_slice(&clock.to_le_bytes()[0..4]);let accuracy = self.accuracy;buffer[12..14].copy_from_slice(&accuracy.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 9;ret}
}
impl Packet for ReadClockCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadClockCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_clock_complete = match &command_complete.child {CommandCompleteDataChild::ReadClockComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadClockComplete"),};Self {event,command_complete,read_clock_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_clock_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.read_clock_complete.as_ref().connection_handle}
pub fn get_clock(&self) -> u32{ self.read_clock_complete.as_ref().clock}
pub fn get_accuracy(&self) -> u16{ self.read_clock_complete.as_ref().accuracy}
}
impl Into<EventPacket> for ReadClockCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadClockCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadClockCompleteBuilder {pub fn build(self) -> ReadClockCompletePacket {let read_clock_complete= Arc::new(ReadClockCompleteData {status: self.status, connection_handle: self.connection_handle, clock: self.clock, accuracy: self.accuracy, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadClock, child: CommandCompleteDataChild::ReadClockComplete(read_clock_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadClockCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadClockCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadClockCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadEncryptionKeySizeData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct ReadEncryptionKeySizePacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,read_encryption_key_size: Arc<ReadEncryptionKeySizeData>,}
#[derive(Debug)] pub struct ReadEncryptionKeySizeBuilder {pub connection_handle: u16, }
impl ReadEncryptionKeySizeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ReadEncryptionKeySize".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for ReadEncryptionKeySizePacket { type ResponseType = ReadEncryptionKeySizeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadEncryptionKeySizeCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadEncryptionKeySizePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadEncryptionKeySizePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let read_encryption_key_size = match &security_command.child {SecurityCommandDataChild::ReadEncryptionKeySize(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadEncryptionKeySize"),};Self {command,security_command,read_encryption_key_size,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.read_encryption_key_size.as_ref().connection_handle}
}
impl Into<CommandPacket> for ReadEncryptionKeySizePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for ReadEncryptionKeySizePacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for ReadEncryptionKeySizeBuilder { type ResponseType = ReadEncryptionKeySizeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadEncryptionKeySizeCompletePacket::new(pkt.event.clone()) }}impl ReadEncryptionKeySizeBuilder {pub fn build(self) -> ReadEncryptionKeySizePacket {let read_encryption_key_size= Arc::new(ReadEncryptionKeySizeData {connection_handle: self.connection_handle, });let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::ReadEncryptionKeySize(read_encryption_key_size),});let command= Arc::new(CommandData {op_code: OpCode::ReadEncryptionKeySize, child: CommandDataChild::SecurityCommand(security_command),});ReadEncryptionKeySizePacket::new(command)}
}
impl Into<CommandPacket> for ReadEncryptionKeySizeBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for ReadEncryptionKeySizeBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadEncryptionKeySizeCompleteData {status: ErrorCode, connection_handle: u16, key_size: u8, }
#[derive(Debug, Clone)] pub struct ReadEncryptionKeySizeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_encryption_key_size_complete: Arc<ReadEncryptionKeySizeCompleteData>,}
#[derive(Debug)] pub struct ReadEncryptionKeySizeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, pub key_size: u8, }
impl ReadEncryptionKeySizeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadEncryptionKeySizeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadEncryptionKeySizeComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "ReadEncryptionKeySizeComplete".to_string(),    field: "key_size".to_string(),    wanted: 9,    got: bytes.len()});}let key_size = u8::from_le_bytes([bytes[8]]);Ok(Self {status, connection_handle, key_size, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let key_size = self.key_size;buffer[8..9].copy_from_slice(&key_size.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl Packet for ReadEncryptionKeySizeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadEncryptionKeySizeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_encryption_key_size_complete = match &command_complete.child {CommandCompleteDataChild::ReadEncryptionKeySizeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadEncryptionKeySizeComplete"),};Self {event,command_complete,read_encryption_key_size_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_encryption_key_size_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.read_encryption_key_size_complete.as_ref().connection_handle}
pub fn get_key_size(&self) -> u8{ self.read_encryption_key_size_complete.as_ref().key_size}
}
impl Into<EventPacket> for ReadEncryptionKeySizeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadEncryptionKeySizeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadEncryptionKeySizeCompleteBuilder {pub fn build(self) -> ReadEncryptionKeySizeCompletePacket {let read_encryption_key_size_complete= Arc::new(ReadEncryptionKeySizeCompleteData {status: self.status, connection_handle: self.connection_handle, key_size: self.key_size, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadEncryptionKeySize, child: CommandCompleteDataChild::ReadEncryptionKeySizeComplete(read_encryption_key_size_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadEncryptionKeySizeCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadEncryptionKeySizeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadEncryptionKeySizeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ReadLoopbackModeData {}
#[derive(Debug, Clone)] pub struct ReadLoopbackModePacket {command: Arc<CommandData>,read_loopback_mode: Arc<ReadLoopbackModeData>,}
#[derive(Debug)] pub struct ReadLoopbackModeBuilder {}
impl ReadLoopbackModeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ReadLoopbackModePacket { type ResponseType = ReadLoopbackModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLoopbackModeCompletePacket::new(pkt.event.clone()) }}impl Packet for ReadLoopbackModePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLoopbackModePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let read_loopback_mode = match &command.child {CommandDataChild::ReadLoopbackMode(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLoopbackMode"),};Self {command,read_loopback_mode,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ReadLoopbackModePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for ReadLoopbackModeBuilder { type ResponseType = ReadLoopbackModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ReadLoopbackModeCompletePacket::new(pkt.event.clone()) }}impl ReadLoopbackModeBuilder {pub fn build(self) -> ReadLoopbackModePacket {let read_loopback_mode= Arc::new(ReadLoopbackModeData {});let command= Arc::new(CommandData {op_code: OpCode::ReadLoopbackMode, child: CommandDataChild::ReadLoopbackMode(read_loopback_mode),});ReadLoopbackModePacket::new(command)}
}
impl Into<CommandPacket> for ReadLoopbackModeBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct ReadLoopbackModeCompleteData {status: ErrorCode, loopback_mode: LoopbackMode, }
#[derive(Debug, Clone)] pub struct ReadLoopbackModeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,read_loopback_mode_complete: Arc<ReadLoopbackModeCompleteData>,}
#[derive(Debug)] pub struct ReadLoopbackModeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub loopback_mode: LoopbackMode, }
impl ReadLoopbackModeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadLoopbackModeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ReadLoopbackModeComplete".to_string(),    field: "loopback_mode".to_string(),    wanted: 7,    got: bytes.len()});}let loopback_mode = u8::from_le_bytes([bytes[6]]);let loopback_mode = LoopbackMode::from_u8(loopback_mode).unwrap();Ok(Self {status, loopback_mode, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let loopback_mode = self.loopback_mode.to_u8().unwrap();buffer[6..7].copy_from_slice(&loopback_mode.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for ReadLoopbackModeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLoopbackModeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let read_loopback_mode_complete = match &command_complete.child {CommandCompleteDataChild::ReadLoopbackModeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLoopbackModeComplete"),};Self {event,command_complete,read_loopback_mode_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.read_loopback_mode_complete.as_ref().status}
pub fn get_loopback_mode(&self) -> LoopbackMode{ self.read_loopback_mode_complete.as_ref().loopback_mode}
}
impl Into<EventPacket> for ReadLoopbackModeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ReadLoopbackModeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ReadLoopbackModeCompleteBuilder {pub fn build(self) -> ReadLoopbackModeCompletePacket {let read_loopback_mode_complete= Arc::new(ReadLoopbackModeCompleteData {status: self.status, loopback_mode: self.loopback_mode, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ReadLoopbackMode, child: CommandCompleteDataChild::ReadLoopbackModeComplete(read_loopback_mode_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ReadLoopbackModeCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadLoopbackModeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ReadLoopbackModeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WriteLoopbackModeData {loopback_mode: LoopbackMode, }
#[derive(Debug, Clone)] pub struct WriteLoopbackModePacket {command: Arc<CommandData>,write_loopback_mode: Arc<WriteLoopbackModeData>,}
#[derive(Debug)] pub struct WriteLoopbackModeBuilder {pub loopback_mode: LoopbackMode, }
impl WriteLoopbackModeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "WriteLoopbackMode".to_string(),    field: "loopback_mode".to_string(),    wanted: 4,    got: bytes.len()});}let loopback_mode = u8::from_le_bytes([bytes[3]]);let loopback_mode = LoopbackMode::from_u8(loopback_mode).unwrap();Ok(Self {loopback_mode, })
}
fn write_to(&self, buffer: &mut BytesMut) {let loopback_mode = self.loopback_mode.to_u8().unwrap();buffer[3..4].copy_from_slice(&loopback_mode.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for WriteLoopbackModePacket { type ResponseType = WriteLoopbackModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteLoopbackModeCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteLoopbackModePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteLoopbackModePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let write_loopback_mode = match &command.child {CommandDataChild::WriteLoopbackMode(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteLoopbackMode"),};Self {command,write_loopback_mode,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_loopback_mode(&self) -> LoopbackMode{ self.write_loopback_mode.as_ref().loopback_mode}
}
impl Into<CommandPacket> for WriteLoopbackModePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for WriteLoopbackModeBuilder { type ResponseType = WriteLoopbackModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteLoopbackModeCompletePacket::new(pkt.event.clone()) }}impl WriteLoopbackModeBuilder {pub fn build(self) -> WriteLoopbackModePacket {let write_loopback_mode= Arc::new(WriteLoopbackModeData {loopback_mode: self.loopback_mode, });let command= Arc::new(CommandData {op_code: OpCode::WriteLoopbackMode, child: CommandDataChild::WriteLoopbackMode(write_loopback_mode),});WriteLoopbackModePacket::new(command)}
}
impl Into<CommandPacket> for WriteLoopbackModeBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct WriteLoopbackModeCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WriteLoopbackModeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_loopback_mode_complete: Arc<WriteLoopbackModeCompleteData>,}
#[derive(Debug)] pub struct WriteLoopbackModeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WriteLoopbackModeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteLoopbackModeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WriteLoopbackModeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteLoopbackModeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_loopback_mode_complete = match &command_complete.child {CommandCompleteDataChild::WriteLoopbackModeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteLoopbackModeComplete"),};Self {event,command_complete,write_loopback_mode_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_loopback_mode_complete.as_ref().status}
}
impl Into<EventPacket> for WriteLoopbackModeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteLoopbackModeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteLoopbackModeCompleteBuilder {pub fn build(self) -> WriteLoopbackModeCompletePacket {let write_loopback_mode_complete= Arc::new(WriteLoopbackModeCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteLoopbackMode, child: CommandCompleteDataChild::WriteLoopbackModeComplete(write_loopback_mode_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteLoopbackModeCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteLoopbackModeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteLoopbackModeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct EnableDeviceUnderTestModeData {}
#[derive(Debug, Clone)] pub struct EnableDeviceUnderTestModePacket {command: Arc<CommandData>,enable_device_under_test_mode: Arc<EnableDeviceUnderTestModeData>,}
#[derive(Debug)] pub struct EnableDeviceUnderTestModeBuilder {}
impl EnableDeviceUnderTestModeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for EnableDeviceUnderTestModePacket { type ResponseType = EnableDeviceUnderTestModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { EnableDeviceUnderTestModeCompletePacket::new(pkt.event.clone()) }}impl Packet for EnableDeviceUnderTestModePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl EnableDeviceUnderTestModePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let enable_device_under_test_mode = match &command.child {CommandDataChild::EnableDeviceUnderTestMode(value) => (*value).clone(),_ => panic!("inconsistent state - child was not EnableDeviceUnderTestMode"),};Self {command,enable_device_under_test_mode,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for EnableDeviceUnderTestModePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for EnableDeviceUnderTestModeBuilder { type ResponseType = EnableDeviceUnderTestModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { EnableDeviceUnderTestModeCompletePacket::new(pkt.event.clone()) }}impl EnableDeviceUnderTestModeBuilder {pub fn build(self) -> EnableDeviceUnderTestModePacket {let enable_device_under_test_mode= Arc::new(EnableDeviceUnderTestModeData {});let command= Arc::new(CommandData {op_code: OpCode::EnableDeviceUnderTestMode, child: CommandDataChild::EnableDeviceUnderTestMode(enable_device_under_test_mode),});EnableDeviceUnderTestModePacket::new(command)}
}
impl Into<CommandPacket> for EnableDeviceUnderTestModeBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct EnableDeviceUnderTestModeCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct EnableDeviceUnderTestModeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,enable_device_under_test_mode_complete: Arc<EnableDeviceUnderTestModeCompleteData>,}
#[derive(Debug)] pub struct EnableDeviceUnderTestModeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl EnableDeviceUnderTestModeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "EnableDeviceUnderTestModeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for EnableDeviceUnderTestModeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl EnableDeviceUnderTestModeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let enable_device_under_test_mode_complete = match &command_complete.child {CommandCompleteDataChild::EnableDeviceUnderTestModeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not EnableDeviceUnderTestModeComplete"),};Self {event,command_complete,enable_device_under_test_mode_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.enable_device_under_test_mode_complete.as_ref().status}
}
impl Into<EventPacket> for EnableDeviceUnderTestModeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for EnableDeviceUnderTestModeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl EnableDeviceUnderTestModeCompleteBuilder {pub fn build(self) -> EnableDeviceUnderTestModeCompletePacket {let enable_device_under_test_mode_complete= Arc::new(EnableDeviceUnderTestModeCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::EnableDeviceUnderTestMode, child: CommandCompleteDataChild::EnableDeviceUnderTestModeComplete(enable_device_under_test_mode_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});EnableDeviceUnderTestModeCompletePacket::new(event)}
}
impl Into<EventPacket> for EnableDeviceUnderTestModeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for EnableDeviceUnderTestModeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WriteSimplePairingDebugModeData {simple_pairing_debug_mode: Enable, }
#[derive(Debug, Clone)] pub struct WriteSimplePairingDebugModePacket {command: Arc<CommandData>,security_command: Arc<SecurityCommandData>,write_simple_pairing_debug_mode: Arc<WriteSimplePairingDebugModeData>,}
#[derive(Debug)] pub struct WriteSimplePairingDebugModeBuilder {pub simple_pairing_debug_mode: Enable, }
impl WriteSimplePairingDebugModeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "WriteSimplePairingDebugMode".to_string(),    field: "simple_pairing_debug_mode".to_string(),    wanted: 4,    got: bytes.len()});}let simple_pairing_debug_mode = u8::from_le_bytes([bytes[3]]);let simple_pairing_debug_mode = Enable::from_u8(simple_pairing_debug_mode).unwrap();Ok(Self {simple_pairing_debug_mode, })
}
fn write_to(&self, buffer: &mut BytesMut) {let simple_pairing_debug_mode = self.simple_pairing_debug_mode.to_u8().unwrap();buffer[3..4].copy_from_slice(&simple_pairing_debug_mode.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for WriteSimplePairingDebugModePacket { type ResponseType = WriteSimplePairingDebugModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteSimplePairingDebugModeCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteSimplePairingDebugModePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteSimplePairingDebugModePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let security_command = match &command.child {CommandDataChild::SecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SecurityCommand"),};let write_simple_pairing_debug_mode = match &security_command.child {SecurityCommandDataChild::WriteSimplePairingDebugMode(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteSimplePairingDebugMode"),};Self {command,security_command,write_simple_pairing_debug_mode,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_simple_pairing_debug_mode(&self) -> Enable{ self.write_simple_pairing_debug_mode.as_ref().simple_pairing_debug_mode}
}
impl Into<CommandPacket> for WriteSimplePairingDebugModePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<SecurityCommandPacket> for WriteSimplePairingDebugModePacket { fn into(self) -> SecurityCommandPacket {SecurityCommandPacket::new(self.command) }}
impl CommandExpectations for WriteSimplePairingDebugModeBuilder { type ResponseType = WriteSimplePairingDebugModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteSimplePairingDebugModeCompletePacket::new(pkt.event.clone()) }}impl WriteSimplePairingDebugModeBuilder {pub fn build(self) -> WriteSimplePairingDebugModePacket {let write_simple_pairing_debug_mode= Arc::new(WriteSimplePairingDebugModeData {simple_pairing_debug_mode: self.simple_pairing_debug_mode, });let security_command= Arc::new(SecurityCommandData {child: SecurityCommandDataChild::WriteSimplePairingDebugMode(write_simple_pairing_debug_mode),});let command= Arc::new(CommandData {op_code: OpCode::WriteSimplePairingDebugMode, child: CommandDataChild::SecurityCommand(security_command),});WriteSimplePairingDebugModePacket::new(command)}
}
impl Into<CommandPacket> for WriteSimplePairingDebugModeBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<SecurityCommandPacket> for WriteSimplePairingDebugModeBuilder { fn into(self) -> SecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct WriteSimplePairingDebugModeCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WriteSimplePairingDebugModeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_simple_pairing_debug_mode_complete: Arc<WriteSimplePairingDebugModeCompleteData>,}
#[derive(Debug)] pub struct WriteSimplePairingDebugModeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WriteSimplePairingDebugModeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteSimplePairingDebugModeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WriteSimplePairingDebugModeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteSimplePairingDebugModeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_simple_pairing_debug_mode_complete = match &command_complete.child {CommandCompleteDataChild::WriteSimplePairingDebugModeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteSimplePairingDebugModeComplete"),};Self {event,command_complete,write_simple_pairing_debug_mode_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_simple_pairing_debug_mode_complete.as_ref().status}
}
impl Into<EventPacket> for WriteSimplePairingDebugModeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteSimplePairingDebugModeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteSimplePairingDebugModeCompleteBuilder {pub fn build(self) -> WriteSimplePairingDebugModeCompletePacket {let write_simple_pairing_debug_mode_complete= Arc::new(WriteSimplePairingDebugModeCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteSimplePairingDebugMode, child: CommandCompleteDataChild::WriteSimplePairingDebugModeComplete(write_simple_pairing_debug_mode_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteSimplePairingDebugModeCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteSimplePairingDebugModeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteSimplePairingDebugModeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct WriteSecureConnectionsTestModeData {connection_handle: u16, dm1_aclu_mode: Enable, esco_loopback_mode: Enable, }
#[derive(Debug, Clone)] pub struct WriteSecureConnectionsTestModePacket {command: Arc<CommandData>,write_secure_connections_test_mode: Arc<WriteSecureConnectionsTestModeData>,}
#[derive(Debug)] pub struct WriteSecureConnectionsTestModeBuilder {pub connection_handle: u16, pub dm1_aclu_mode: Enable, pub esco_loopback_mode: Enable, }
impl WriteSecureConnectionsTestModeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "WriteSecureConnectionsTestMode".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteSecureConnectionsTestMode".to_string(),    field: "dm1_aclu_mode".to_string(),    wanted: 6,    got: bytes.len()});}let dm1_aclu_mode = u8::from_le_bytes([bytes[5]]);let dm1_aclu_mode = Enable::from_u8(dm1_aclu_mode).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "WriteSecureConnectionsTestMode".to_string(),    field: "esco_loopback_mode".to_string(),    wanted: 7,    got: bytes.len()});}let esco_loopback_mode = u8::from_le_bytes([bytes[6]]);let esco_loopback_mode = Enable::from_u8(esco_loopback_mode).unwrap();Ok(Self {connection_handle, dm1_aclu_mode, esco_loopback_mode, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let dm1_aclu_mode = self.dm1_aclu_mode.to_u8().unwrap();buffer[5..6].copy_from_slice(&dm1_aclu_mode.to_le_bytes()[0..1]);let esco_loopback_mode = self.esco_loopback_mode.to_u8().unwrap();buffer[6..7].copy_from_slice(&esco_loopback_mode.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl CommandExpectations for WriteSecureConnectionsTestModePacket { type ResponseType = WriteSecureConnectionsTestModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteSecureConnectionsTestModeCompletePacket::new(pkt.event.clone()) }}impl Packet for WriteSecureConnectionsTestModePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteSecureConnectionsTestModePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let write_secure_connections_test_mode = match &command.child {CommandDataChild::WriteSecureConnectionsTestMode(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteSecureConnectionsTestMode"),};Self {command,write_secure_connections_test_mode,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.write_secure_connections_test_mode.as_ref().connection_handle}
pub fn get_dm1_aclu_mode(&self) -> Enable{ self.write_secure_connections_test_mode.as_ref().dm1_aclu_mode}
pub fn get_esco_loopback_mode(&self) -> Enable{ self.write_secure_connections_test_mode.as_ref().esco_loopback_mode}
}
impl Into<CommandPacket> for WriteSecureConnectionsTestModePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for WriteSecureConnectionsTestModeBuilder { type ResponseType = WriteSecureConnectionsTestModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { WriteSecureConnectionsTestModeCompletePacket::new(pkt.event.clone()) }}impl WriteSecureConnectionsTestModeBuilder {pub fn build(self) -> WriteSecureConnectionsTestModePacket {let write_secure_connections_test_mode= Arc::new(WriteSecureConnectionsTestModeData {connection_handle: self.connection_handle, dm1_aclu_mode: self.dm1_aclu_mode, esco_loopback_mode: self.esco_loopback_mode, });let command= Arc::new(CommandData {op_code: OpCode::WriteSecureConnectionsTestMode, child: CommandDataChild::WriteSecureConnectionsTestMode(write_secure_connections_test_mode),});WriteSecureConnectionsTestModePacket::new(command)}
}
impl Into<CommandPacket> for WriteSecureConnectionsTestModeBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct WriteSecureConnectionsTestModeCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct WriteSecureConnectionsTestModeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,write_secure_connections_test_mode_complete: Arc<WriteSecureConnectionsTestModeCompleteData>,}
#[derive(Debug)] pub struct WriteSecureConnectionsTestModeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl WriteSecureConnectionsTestModeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "WriteSecureConnectionsTestModeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for WriteSecureConnectionsTestModeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl WriteSecureConnectionsTestModeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let write_secure_connections_test_mode_complete = match &command_complete.child {CommandCompleteDataChild::WriteSecureConnectionsTestModeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not WriteSecureConnectionsTestModeComplete"),};Self {event,command_complete,write_secure_connections_test_mode_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.write_secure_connections_test_mode_complete.as_ref().status}
}
impl Into<EventPacket> for WriteSecureConnectionsTestModeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for WriteSecureConnectionsTestModeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl WriteSecureConnectionsTestModeCompleteBuilder {pub fn build(self) -> WriteSecureConnectionsTestModeCompletePacket {let write_secure_connections_test_mode_complete= Arc::new(WriteSecureConnectionsTestModeCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::WriteSecureConnectionsTestMode, child: CommandCompleteDataChild::WriteSecureConnectionsTestModeComplete(write_secure_connections_test_mode_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});WriteSecureConnectionsTestModeCompletePacket::new(event)}
}
impl Into<EventPacket> for WriteSecureConnectionsTestModeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for WriteSecureConnectionsTestModeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetEventMaskData {le_event_mask: u64, }
#[derive(Debug, Clone)] pub struct LeSetEventMaskPacket {command: Arc<CommandData>,le_set_event_mask: Arc<LeSetEventMaskData>,}
#[derive(Debug)] pub struct LeSetEventMaskBuilder {pub le_event_mask: u64, }
impl LeSetEventMaskData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "LeSetEventMask".to_string(),    field: "le_event_mask".to_string(),    wanted: 11,    got: bytes.len()});}let le_event_mask = u64::from_le_bytes([bytes[3],bytes[4],bytes[5],bytes[6],bytes[7],bytes[8],bytes[9],bytes[10]]);Ok(Self {le_event_mask, })
}
fn write_to(&self, buffer: &mut BytesMut) {let le_event_mask = self.le_event_mask;buffer[3..11].copy_from_slice(&le_event_mask.to_le_bytes()[0..8]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 8;ret}
}
impl CommandExpectations for LeSetEventMaskPacket { type ResponseType = LeSetEventMaskCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetEventMaskCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetEventMaskPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetEventMaskPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_set_event_mask = match &command.child {CommandDataChild::LeSetEventMask(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetEventMask"),};Self {command,le_set_event_mask,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_le_event_mask(&self) -> u64{ self.le_set_event_mask.as_ref().le_event_mask}
}
impl Into<CommandPacket> for LeSetEventMaskPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeSetEventMaskBuilder { type ResponseType = LeSetEventMaskCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetEventMaskCompletePacket::new(pkt.event.clone()) }}impl LeSetEventMaskBuilder {pub fn build(self) -> LeSetEventMaskPacket {let le_set_event_mask= Arc::new(LeSetEventMaskData {le_event_mask: self.le_event_mask, });let command= Arc::new(CommandData {op_code: OpCode::LeSetEventMask, child: CommandDataChild::LeSetEventMask(le_set_event_mask),});LeSetEventMaskPacket::new(command)}
}
impl Into<CommandPacket> for LeSetEventMaskBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetEventMaskCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeSetEventMaskCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_event_mask_complete: Arc<LeSetEventMaskCompleteData>,}
#[derive(Debug)] pub struct LeSetEventMaskCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeSetEventMaskCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetEventMaskComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeSetEventMaskCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetEventMaskCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_event_mask_complete = match &command_complete.child {CommandCompleteDataChild::LeSetEventMaskComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetEventMaskComplete"),};Self {event,command_complete,le_set_event_mask_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_event_mask_complete.as_ref().status}
}
impl Into<EventPacket> for LeSetEventMaskCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetEventMaskCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetEventMaskCompleteBuilder {pub fn build(self) -> LeSetEventMaskCompletePacket {let le_set_event_mask_complete= Arc::new(LeSetEventMaskCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetEventMask, child: CommandCompleteDataChild::LeSetEventMaskComplete(le_set_event_mask_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetEventMaskCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetEventMaskCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetEventMaskCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeReadBufferSizeV1Data {}
#[derive(Debug, Clone)] pub struct LeReadBufferSizeV1Packet {command: Arc<CommandData>,le_read_buffer_size_v1: Arc<LeReadBufferSizeV1Data>,}
#[derive(Debug)] pub struct LeReadBufferSizeV1Builder {}
impl LeReadBufferSizeV1Data {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeReadBufferSizeV1Packet { type ResponseType = LeReadBufferSizeV1CompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadBufferSizeV1CompletePacket::new(pkt.event.clone()) }}impl Packet for LeReadBufferSizeV1Packet {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadBufferSizeV1Packet { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_read_buffer_size_v1 = match &command.child {CommandDataChild::LeReadBufferSizeV1(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadBufferSizeV1"),};Self {command,le_read_buffer_size_v1,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeReadBufferSizeV1Packet { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeReadBufferSizeV1Builder { type ResponseType = LeReadBufferSizeV1CompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadBufferSizeV1CompletePacket::new(pkt.event.clone()) }}impl LeReadBufferSizeV1Builder {pub fn build(self) -> LeReadBufferSizeV1Packet {let le_read_buffer_size_v1= Arc::new(LeReadBufferSizeV1Data {});let command= Arc::new(CommandData {op_code: OpCode::LeReadBufferSizeV1, child: CommandDataChild::LeReadBufferSizeV1(le_read_buffer_size_v1),});LeReadBufferSizeV1Packet::new(command)}
}
impl Into<CommandPacket> for LeReadBufferSizeV1Builder { fn into(self) -> CommandPacket { self.build().into() }}
macro_rules! le_read_buffer_size_v1_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::LeReadBufferSizeV1(packet) => {let rebuilder = LeReadBufferSizeV1Builder {};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse le_read_buffer_size_v1{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}le_read_buffer_size_v1_builder_tests! { le_read_buffer_size_v1_builder_test_00: b"\x02\x20\x00",}


#[derive(Debug)] struct LeReadBufferSizeV1CompleteData {status: ErrorCode, le_buffer_size: LeBufferSize, }
#[derive(Debug, Clone)] pub struct LeReadBufferSizeV1CompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_read_buffer_size_v1_complete: Arc<LeReadBufferSizeV1CompleteData>,}
#[derive(Debug)] pub struct LeReadBufferSizeV1CompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub le_buffer_size: LeBufferSize, }
impl LeReadBufferSizeV1CompleteData {fn conforms(bytes: &[u8]) -> bool {if !LeBufferSize::conforms(&bytes[6..9]) { return false; } true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeReadBufferSizeV1Complete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();let le_buffer_size = LeBufferSize::parse(&bytes[6..9]).unwrap();Ok(Self {status, le_buffer_size, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let le_buffer_size = &mut buffer[6..9];self.le_buffer_size.write_to(le_buffer_size);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl Packet for LeReadBufferSizeV1CompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadBufferSizeV1CompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_read_buffer_size_v1_complete = match &command_complete.child {CommandCompleteDataChild::LeReadBufferSizeV1Complete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadBufferSizeV1Complete"),};Self {event,command_complete,le_read_buffer_size_v1_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_read_buffer_size_v1_complete.as_ref().status}
pub fn get_le_buffer_size(&self) -> &LeBufferSize{ &self.le_read_buffer_size_v1_complete.as_ref().le_buffer_size}
}
impl Into<EventPacket> for LeReadBufferSizeV1CompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeReadBufferSizeV1CompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeReadBufferSizeV1CompleteBuilder {pub fn build(self) -> LeReadBufferSizeV1CompletePacket {let le_read_buffer_size_v1_complete= Arc::new(LeReadBufferSizeV1CompleteData {status: self.status, le_buffer_size: self.le_buffer_size, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeReadBufferSizeV1, child: CommandCompleteDataChild::LeReadBufferSizeV1Complete(le_read_buffer_size_v1_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeReadBufferSizeV1CompletePacket::new(event)}
}
impl Into<EventPacket> for LeReadBufferSizeV1CompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeReadBufferSizeV1CompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! le_read_buffer_size_v1_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::LeReadBufferSizeV1Complete(packet) => {let rebuilder = LeReadBufferSizeV1CompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),le_buffer_size : packet.get_le_buffer_size().clone(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse le_read_buffer_size_v1_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}le_read_buffer_size_v1_complete_builder_tests! { le_read_buffer_size_v1_complete_builder_test_00: b"\x0e\x07\x01\x02\x20\x00\xfb\x00\x10",}


#[derive(Debug)] struct LeReadLocalSupportedFeaturesData {}
#[derive(Debug, Clone)] pub struct LeReadLocalSupportedFeaturesPacket {command: Arc<CommandData>,le_read_local_supported_features: Arc<LeReadLocalSupportedFeaturesData>,}
#[derive(Debug)] pub struct LeReadLocalSupportedFeaturesBuilder {}
impl LeReadLocalSupportedFeaturesData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeReadLocalSupportedFeaturesPacket { type ResponseType = LeReadLocalSupportedFeaturesCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadLocalSupportedFeaturesCompletePacket::new(pkt.event.clone()) }}impl Packet for LeReadLocalSupportedFeaturesPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadLocalSupportedFeaturesPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_read_local_supported_features = match &command.child {CommandDataChild::LeReadLocalSupportedFeatures(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadLocalSupportedFeatures"),};Self {command,le_read_local_supported_features,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeReadLocalSupportedFeaturesPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeReadLocalSupportedFeaturesBuilder { type ResponseType = LeReadLocalSupportedFeaturesCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadLocalSupportedFeaturesCompletePacket::new(pkt.event.clone()) }}impl LeReadLocalSupportedFeaturesBuilder {pub fn build(self) -> LeReadLocalSupportedFeaturesPacket {let le_read_local_supported_features= Arc::new(LeReadLocalSupportedFeaturesData {});let command= Arc::new(CommandData {op_code: OpCode::LeReadLocalSupportedFeatures, child: CommandDataChild::LeReadLocalSupportedFeatures(le_read_local_supported_features),});LeReadLocalSupportedFeaturesPacket::new(command)}
}
impl Into<CommandPacket> for LeReadLocalSupportedFeaturesBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LeReadLocalSupportedFeaturesCompleteData {status: ErrorCode, le_features: u64, }
#[derive(Debug, Clone)] pub struct LeReadLocalSupportedFeaturesCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_read_local_supported_features_complete: Arc<LeReadLocalSupportedFeaturesCompleteData>,}
#[derive(Debug)] pub struct LeReadLocalSupportedFeaturesCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub le_features: u64, }
impl LeReadLocalSupportedFeaturesCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeReadLocalSupportedFeaturesComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "LeReadLocalSupportedFeaturesComplete".to_string(),    field: "le_features".to_string(),    wanted: 14,    got: bytes.len()});}let le_features = u64::from_le_bytes([bytes[6],bytes[7],bytes[8],bytes[9],bytes[10],bytes[11],bytes[12],bytes[13]]);Ok(Self {status, le_features, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let le_features = self.le_features;buffer[6..14].copy_from_slice(&le_features.to_le_bytes()[0..8]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 9;ret}
}
impl Packet for LeReadLocalSupportedFeaturesCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadLocalSupportedFeaturesCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_read_local_supported_features_complete = match &command_complete.child {CommandCompleteDataChild::LeReadLocalSupportedFeaturesComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadLocalSupportedFeaturesComplete"),};Self {event,command_complete,le_read_local_supported_features_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_read_local_supported_features_complete.as_ref().status}
pub fn get_le_features(&self) -> u64{ self.le_read_local_supported_features_complete.as_ref().le_features}
}
impl Into<EventPacket> for LeReadLocalSupportedFeaturesCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeReadLocalSupportedFeaturesCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeReadLocalSupportedFeaturesCompleteBuilder {pub fn build(self) -> LeReadLocalSupportedFeaturesCompletePacket {let le_read_local_supported_features_complete= Arc::new(LeReadLocalSupportedFeaturesCompleteData {status: self.status, le_features: self.le_features, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeReadLocalSupportedFeatures, child: CommandCompleteDataChild::LeReadLocalSupportedFeaturesComplete(le_read_local_supported_features_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeReadLocalSupportedFeaturesCompletePacket::new(event)}
}
impl Into<EventPacket> for LeReadLocalSupportedFeaturesCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeReadLocalSupportedFeaturesCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetRandomAddressData {random_address: Address, }
#[derive(Debug, Clone)] pub struct LeSetRandomAddressPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_set_random_address: Arc<LeSetRandomAddressData>,}
#[derive(Debug)] pub struct LeSetRandomAddressBuilder {pub random_address: Address, }
impl LeSetRandomAddressData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeSetRandomAddress".to_string(),    field: "random_address".to_string(),    wanted: 9,    got: bytes.len()});}let random_address = bytes[3..9].try_into().unwrap();Ok(Self {random_address, })
}
fn write_to(&self, buffer: &mut BytesMut) {let random_address: [u8; 6] = self.random_address.into();buffer[3..9].copy_from_slice(&random_address);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl CommandExpectations for LeSetRandomAddressPacket { type ResponseType = LeSetRandomAddressCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetRandomAddressCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetRandomAddressPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetRandomAddressPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_set_random_address = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeSetRandomAddress(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetRandomAddress"),};Self {command,le_advertising_command,le_set_random_address,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_random_address(&self) -> Address{ self.le_set_random_address.as_ref().random_address}
}
impl Into<CommandPacket> for LeSetRandomAddressPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeSetRandomAddressPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetRandomAddressBuilder { type ResponseType = LeSetRandomAddressCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetRandomAddressCompletePacket::new(pkt.event.clone()) }}impl LeSetRandomAddressBuilder {pub fn build(self) -> LeSetRandomAddressPacket {let le_set_random_address= Arc::new(LeSetRandomAddressData {random_address: self.random_address, });let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeSetRandomAddress(le_set_random_address),});let command= Arc::new(CommandData {op_code: OpCode::LeSetRandomAddress, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeSetRandomAddressPacket::new(command)}
}
impl Into<CommandPacket> for LeSetRandomAddressBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeSetRandomAddressBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetRandomAddressCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeSetRandomAddressCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_random_address_complete: Arc<LeSetRandomAddressCompleteData>,}
#[derive(Debug)] pub struct LeSetRandomAddressCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeSetRandomAddressCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetRandomAddressComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeSetRandomAddressCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetRandomAddressCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_random_address_complete = match &command_complete.child {CommandCompleteDataChild::LeSetRandomAddressComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetRandomAddressComplete"),};Self {event,command_complete,le_set_random_address_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_random_address_complete.as_ref().status}
}
impl Into<EventPacket> for LeSetRandomAddressCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetRandomAddressCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetRandomAddressCompleteBuilder {pub fn build(self) -> LeSetRandomAddressCompletePacket {let le_set_random_address_complete= Arc::new(LeSetRandomAddressCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetRandomAddress, child: CommandCompleteDataChild::LeSetRandomAddressComplete(le_set_random_address_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetRandomAddressCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetRandomAddressCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetRandomAddressCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetAdvertisingParametersData {interval_min: u16, interval_max: u16, advt_type: AdvertisingType, own_address_type: OwnAddressType, peer_address_type: PeerAddressType, peer_address: Address, channel_map: u8, filter_policy: AdvertisingFilterPolicy, }
#[derive(Debug, Clone)] pub struct LeSetAdvertisingParametersPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_set_advertising_parameters: Arc<LeSetAdvertisingParametersData>,}
#[derive(Debug)] pub struct LeSetAdvertisingParametersBuilder {pub interval_min: u16, pub interval_max: u16, pub advt_type: AdvertisingType, pub own_address_type: OwnAddressType, pub peer_address_type: PeerAddressType, pub peer_address: Address, pub channel_map: u8, pub filter_policy: AdvertisingFilterPolicy, }
impl LeSetAdvertisingParametersData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeSetAdvertisingParameters".to_string(),    field: "interval_min".to_string(),    wanted: 5,    got: bytes.len()});}let interval_min = u16::from_le_bytes([bytes[3],bytes[4]]);if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeSetAdvertisingParameters".to_string(),    field: "interval_max".to_string(),    wanted: 7,    got: bytes.len()});}let interval_max = u16::from_le_bytes([bytes[5],bytes[6]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeSetAdvertisingParameters".to_string(),    field: "advt_type".to_string(),    wanted: 8,    got: bytes.len()});}let advt_type = u8::from_le_bytes([bytes[7]]);let advt_type = AdvertisingType::from_u8(advt_type).unwrap();if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeSetAdvertisingParameters".to_string(),    field: "own_address_type".to_string(),    wanted: 9,    got: bytes.len()});}let own_address_type = u8::from_le_bytes([bytes[8]]);let own_address_type = OwnAddressType::from_u8(own_address_type).unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeSetAdvertisingParameters".to_string(),    field: "peer_address_type".to_string(),    wanted: 10,    got: bytes.len()});}let peer_address_type = u8::from_le_bytes([bytes[9]]);let peer_address_type = PeerAddressType::from_u8(peer_address_type).unwrap();if bytes.len() < 16 { return Err(Error::InvalidLengthError{    obj: "LeSetAdvertisingParameters".to_string(),    field: "peer_address".to_string(),    wanted: 16,    got: bytes.len()});}let peer_address = bytes[10..16].try_into().unwrap();if bytes.len() < 17 { return Err(Error::InvalidLengthError{    obj: "LeSetAdvertisingParameters".to_string(),    field: "channel_map".to_string(),    wanted: 17,    got: bytes.len()});}let channel_map = u8::from_le_bytes([bytes[16]]);let filter_policy = u8::from_le_bytes([bytes[17]]);let filter_policy = filter_policy & 0x3;let filter_policy = AdvertisingFilterPolicy::from_u8(filter_policy).unwrap();Ok(Self {interval_min, interval_max, advt_type, own_address_type, peer_address_type, peer_address, channel_map, filter_policy, })
}
fn write_to(&self, buffer: &mut BytesMut) {let interval_min = self.interval_min;buffer[3..5].copy_from_slice(&interval_min.to_le_bytes()[0..2]);let interval_max = self.interval_max;buffer[5..7].copy_from_slice(&interval_max.to_le_bytes()[0..2]);let advt_type = self.advt_type.to_u8().unwrap();buffer[7..8].copy_from_slice(&advt_type.to_le_bytes()[0..1]);let own_address_type = self.own_address_type.to_u8().unwrap();buffer[8..9].copy_from_slice(&own_address_type.to_le_bytes()[0..1]);let peer_address_type = self.peer_address_type.to_u8().unwrap();buffer[9..10].copy_from_slice(&peer_address_type.to_le_bytes()[0..1]);let peer_address: [u8; 6] = self.peer_address.into();buffer[10..16].copy_from_slice(&peer_address);let channel_map = self.channel_map;buffer[16..17].copy_from_slice(&channel_map.to_le_bytes()[0..1]);let filter_policy = self.filter_policy.to_u8().unwrap();let filter_policy = filter_policy & 0x3;buffer[17..18].copy_from_slice(&filter_policy.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 15;ret}
}
impl CommandExpectations for LeSetAdvertisingParametersPacket { type ResponseType = LeSetAdvertisingParametersCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetAdvertisingParametersCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetAdvertisingParametersPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetAdvertisingParametersPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_set_advertising_parameters = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeSetAdvertisingParameters(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetAdvertisingParameters"),};Self {command,le_advertising_command,le_set_advertising_parameters,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_interval_min(&self) -> u16{ self.le_set_advertising_parameters.as_ref().interval_min}
pub fn get_interval_max(&self) -> u16{ self.le_set_advertising_parameters.as_ref().interval_max}
pub fn get_advt_type(&self) -> AdvertisingType{ self.le_set_advertising_parameters.as_ref().advt_type}
pub fn get_own_address_type(&self) -> OwnAddressType{ self.le_set_advertising_parameters.as_ref().own_address_type}
pub fn get_peer_address_type(&self) -> PeerAddressType{ self.le_set_advertising_parameters.as_ref().peer_address_type}
pub fn get_peer_address(&self) -> Address{ self.le_set_advertising_parameters.as_ref().peer_address}
pub fn get_channel_map(&self) -> u8{ self.le_set_advertising_parameters.as_ref().channel_map}
pub fn get_filter_policy(&self) -> AdvertisingFilterPolicy{ self.le_set_advertising_parameters.as_ref().filter_policy}
}
impl Into<CommandPacket> for LeSetAdvertisingParametersPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeSetAdvertisingParametersPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetAdvertisingParametersBuilder { type ResponseType = LeSetAdvertisingParametersCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetAdvertisingParametersCompletePacket::new(pkt.event.clone()) }}impl LeSetAdvertisingParametersBuilder {pub fn build(self) -> LeSetAdvertisingParametersPacket {let le_set_advertising_parameters= Arc::new(LeSetAdvertisingParametersData {interval_min: self.interval_min, interval_max: self.interval_max, advt_type: self.advt_type, own_address_type: self.own_address_type, peer_address_type: self.peer_address_type, peer_address: self.peer_address, channel_map: self.channel_map, filter_policy: self.filter_policy, });let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeSetAdvertisingParameters(le_set_advertising_parameters),});let command= Arc::new(CommandData {op_code: OpCode::LeSetAdvertisingParameters, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeSetAdvertisingParametersPacket::new(command)}
}
impl Into<CommandPacket> for LeSetAdvertisingParametersBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeSetAdvertisingParametersBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetAdvertisingParametersCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeSetAdvertisingParametersCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_advertising_parameters_complete: Arc<LeSetAdvertisingParametersCompleteData>,}
#[derive(Debug)] pub struct LeSetAdvertisingParametersCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeSetAdvertisingParametersCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetAdvertisingParametersComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeSetAdvertisingParametersCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetAdvertisingParametersCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_advertising_parameters_complete = match &command_complete.child {CommandCompleteDataChild::LeSetAdvertisingParametersComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetAdvertisingParametersComplete"),};Self {event,command_complete,le_set_advertising_parameters_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_advertising_parameters_complete.as_ref().status}
}
impl Into<EventPacket> for LeSetAdvertisingParametersCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetAdvertisingParametersCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetAdvertisingParametersCompleteBuilder {pub fn build(self) -> LeSetAdvertisingParametersCompletePacket {let le_set_advertising_parameters_complete= Arc::new(LeSetAdvertisingParametersCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetAdvertisingParameters, child: CommandCompleteDataChild::LeSetAdvertisingParametersComplete(le_set_advertising_parameters_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetAdvertisingParametersCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetAdvertisingParametersCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetAdvertisingParametersCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeReadAdvertisingPhysicalChannelTxPowerData {}
#[derive(Debug, Clone)] pub struct LeReadAdvertisingPhysicalChannelTxPowerPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_read_advertising_physical_channel_tx_power: Arc<LeReadAdvertisingPhysicalChannelTxPowerData>,}
#[derive(Debug)] pub struct LeReadAdvertisingPhysicalChannelTxPowerBuilder {}
impl LeReadAdvertisingPhysicalChannelTxPowerData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeReadAdvertisingPhysicalChannelTxPowerPacket { type ResponseType = LeReadAdvertisingPhysicalChannelTxPowerCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadAdvertisingPhysicalChannelTxPowerCompletePacket::new(pkt.event.clone()) }}impl Packet for LeReadAdvertisingPhysicalChannelTxPowerPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadAdvertisingPhysicalChannelTxPowerPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_read_advertising_physical_channel_tx_power = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeReadAdvertisingPhysicalChannelTxPower(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadAdvertisingPhysicalChannelTxPower"),};Self {command,le_advertising_command,le_read_advertising_physical_channel_tx_power,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeReadAdvertisingPhysicalChannelTxPowerPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeReadAdvertisingPhysicalChannelTxPowerPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeReadAdvertisingPhysicalChannelTxPowerBuilder { type ResponseType = LeReadAdvertisingPhysicalChannelTxPowerCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadAdvertisingPhysicalChannelTxPowerCompletePacket::new(pkt.event.clone()) }}impl LeReadAdvertisingPhysicalChannelTxPowerBuilder {pub fn build(self) -> LeReadAdvertisingPhysicalChannelTxPowerPacket {let le_read_advertising_physical_channel_tx_power= Arc::new(LeReadAdvertisingPhysicalChannelTxPowerData {});let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeReadAdvertisingPhysicalChannelTxPower(le_read_advertising_physical_channel_tx_power),});let command= Arc::new(CommandData {op_code: OpCode::LeReadAdvertisingPhysicalChannelTxPower, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeReadAdvertisingPhysicalChannelTxPowerPacket::new(command)}
}
impl Into<CommandPacket> for LeReadAdvertisingPhysicalChannelTxPowerBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeReadAdvertisingPhysicalChannelTxPowerBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeReadAdvertisingPhysicalChannelTxPowerCompleteData {status: ErrorCode, transmit_power_level: u8, }
#[derive(Debug, Clone)] pub struct LeReadAdvertisingPhysicalChannelTxPowerCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_read_advertising_physical_channel_tx_power_complete: Arc<LeReadAdvertisingPhysicalChannelTxPowerCompleteData>,}
#[derive(Debug)] pub struct LeReadAdvertisingPhysicalChannelTxPowerCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub transmit_power_level: u8, }
impl LeReadAdvertisingPhysicalChannelTxPowerCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeReadAdvertisingPhysicalChannelTxPowerComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeReadAdvertisingPhysicalChannelTxPowerComplete".to_string(),    field: "transmit_power_level".to_string(),    wanted: 7,    got: bytes.len()});}let transmit_power_level = u8::from_le_bytes([bytes[6]]);Ok(Self {status, transmit_power_level, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let transmit_power_level = self.transmit_power_level;buffer[6..7].copy_from_slice(&transmit_power_level.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for LeReadAdvertisingPhysicalChannelTxPowerCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadAdvertisingPhysicalChannelTxPowerCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_read_advertising_physical_channel_tx_power_complete = match &command_complete.child {CommandCompleteDataChild::LeReadAdvertisingPhysicalChannelTxPowerComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadAdvertisingPhysicalChannelTxPowerComplete"),};Self {event,command_complete,le_read_advertising_physical_channel_tx_power_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_read_advertising_physical_channel_tx_power_complete.as_ref().status}
pub fn get_transmit_power_level(&self) -> u8{ self.le_read_advertising_physical_channel_tx_power_complete.as_ref().transmit_power_level}
}
impl Into<EventPacket> for LeReadAdvertisingPhysicalChannelTxPowerCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeReadAdvertisingPhysicalChannelTxPowerCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeReadAdvertisingPhysicalChannelTxPowerCompleteBuilder {pub fn build(self) -> LeReadAdvertisingPhysicalChannelTxPowerCompletePacket {let le_read_advertising_physical_channel_tx_power_complete= Arc::new(LeReadAdvertisingPhysicalChannelTxPowerCompleteData {status: self.status, transmit_power_level: self.transmit_power_level, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeReadAdvertisingPhysicalChannelTxPower, child: CommandCompleteDataChild::LeReadAdvertisingPhysicalChannelTxPowerComplete(le_read_advertising_physical_channel_tx_power_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeReadAdvertisingPhysicalChannelTxPowerCompletePacket::new(event)}
}
impl Into<EventPacket> for LeReadAdvertisingPhysicalChannelTxPowerCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeReadAdvertisingPhysicalChannelTxPowerCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetAdvertisingDataData {advertising_data: Vec::<GapData>, }
#[derive(Debug, Clone)] pub struct LeSetAdvertisingDataPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_set_advertising_data: Arc<LeSetAdvertisingDataData>,}
#[derive(Debug)] pub struct LeSetAdvertisingDataBuilder {pub advertising_data: Vec::<GapData>, }
impl LeSetAdvertisingDataData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetAdvertisingData".to_string(),    field: "advertising_data_size".to_string(),    wanted: 4,    got: bytes.len()});}let advertising_data_size = u8::from_le_bytes([bytes[3]]);let mut advertising_data: Vec::<GapData> = Vec::new();let mut parsable_ = &bytes[4..4 + (advertising_data_size as usize)];while parsable_.len() > 0 { match GapData::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];advertising_data.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {advertising_data, })
}
fn write_to(&self, buffer: &mut BytesMut) {let advertising_data_bytes = self.advertising_data.iter().fold(0, |acc, x| acc + x.get_total_size());let advertising_data_size = u8::try_from(advertising_data_bytes).expect("payload size did not fit");buffer[3..4].copy_from_slice(&advertising_data_size.to_le_bytes()[0..1]);let mut vec_buffer_ = &mut buffer[4..];for e_ in &self.advertising_data { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;/* Skipping advertising_data since it is padded */let ret = ret + 32;ret}
}
impl CommandExpectations for LeSetAdvertisingDataPacket { type ResponseType = LeSetAdvertisingDataCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetAdvertisingDataCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetAdvertisingDataPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetAdvertisingDataPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_set_advertising_data = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeSetAdvertisingData(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetAdvertisingData"),};Self {command,le_advertising_command,le_set_advertising_data,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_advertising_data(&self) -> &Vec::<GapData>{ &self.le_set_advertising_data.as_ref().advertising_data}
}
impl Into<CommandPacket> for LeSetAdvertisingDataPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeSetAdvertisingDataPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetAdvertisingDataBuilder { type ResponseType = LeSetAdvertisingDataCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetAdvertisingDataCompletePacket::new(pkt.event.clone()) }}impl LeSetAdvertisingDataBuilder {pub fn build(self) -> LeSetAdvertisingDataPacket {let le_set_advertising_data= Arc::new(LeSetAdvertisingDataData {advertising_data: self.advertising_data, });let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeSetAdvertisingData(le_set_advertising_data),});let command= Arc::new(CommandData {op_code: OpCode::LeSetAdvertisingData, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeSetAdvertisingDataPacket::new(command)}
}
impl Into<CommandPacket> for LeSetAdvertisingDataBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeSetAdvertisingDataBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetAdvertisingDataCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeSetAdvertisingDataCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_advertising_data_complete: Arc<LeSetAdvertisingDataCompleteData>,}
#[derive(Debug)] pub struct LeSetAdvertisingDataCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeSetAdvertisingDataCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetAdvertisingDataComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeSetAdvertisingDataCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetAdvertisingDataCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_advertising_data_complete = match &command_complete.child {CommandCompleteDataChild::LeSetAdvertisingDataComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetAdvertisingDataComplete"),};Self {event,command_complete,le_set_advertising_data_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_advertising_data_complete.as_ref().status}
}
impl Into<EventPacket> for LeSetAdvertisingDataCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetAdvertisingDataCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetAdvertisingDataCompleteBuilder {pub fn build(self) -> LeSetAdvertisingDataCompletePacket {let le_set_advertising_data_complete= Arc::new(LeSetAdvertisingDataCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetAdvertisingData, child: CommandCompleteDataChild::LeSetAdvertisingDataComplete(le_set_advertising_data_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetAdvertisingDataCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetAdvertisingDataCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetAdvertisingDataCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetScanResponseDataData {advertising_data: Vec::<GapData>, }
#[derive(Debug, Clone)] pub struct LeSetScanResponseDataPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_set_scan_response_data: Arc<LeSetScanResponseDataData>,}
#[derive(Debug)] pub struct LeSetScanResponseDataBuilder {pub advertising_data: Vec::<GapData>, }
impl LeSetScanResponseDataData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetScanResponseData".to_string(),    field: "advertising_data_size".to_string(),    wanted: 4,    got: bytes.len()});}let advertising_data_size = u8::from_le_bytes([bytes[3]]);let mut advertising_data: Vec::<GapData> = Vec::new();let mut parsable_ = &bytes[4..4 + (advertising_data_size as usize)];while parsable_.len() > 0 { match GapData::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];advertising_data.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {advertising_data, })
}
fn write_to(&self, buffer: &mut BytesMut) {let advertising_data_bytes = self.advertising_data.iter().fold(0, |acc, x| acc + x.get_total_size());let advertising_data_size = u8::try_from(advertising_data_bytes).expect("payload size did not fit");buffer[3..4].copy_from_slice(&advertising_data_size.to_le_bytes()[0..1]);let mut vec_buffer_ = &mut buffer[4..];for e_ in &self.advertising_data { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;/* Skipping advertising_data since it is padded */let ret = ret + 32;ret}
}
impl CommandExpectations for LeSetScanResponseDataPacket { type ResponseType = LeSetScanResponseDataCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetScanResponseDataCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetScanResponseDataPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetScanResponseDataPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_set_scan_response_data = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeSetScanResponseData(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetScanResponseData"),};Self {command,le_advertising_command,le_set_scan_response_data,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_advertising_data(&self) -> &Vec::<GapData>{ &self.le_set_scan_response_data.as_ref().advertising_data}
}
impl Into<CommandPacket> for LeSetScanResponseDataPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeSetScanResponseDataPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetScanResponseDataBuilder { type ResponseType = LeSetScanResponseDataCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetScanResponseDataCompletePacket::new(pkt.event.clone()) }}impl LeSetScanResponseDataBuilder {pub fn build(self) -> LeSetScanResponseDataPacket {let le_set_scan_response_data= Arc::new(LeSetScanResponseDataData {advertising_data: self.advertising_data, });let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeSetScanResponseData(le_set_scan_response_data),});let command= Arc::new(CommandData {op_code: OpCode::LeSetScanResponseData, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeSetScanResponseDataPacket::new(command)}
}
impl Into<CommandPacket> for LeSetScanResponseDataBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeSetScanResponseDataBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetScanResponseDataCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeSetScanResponseDataCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_scan_response_data_complete: Arc<LeSetScanResponseDataCompleteData>,}
#[derive(Debug)] pub struct LeSetScanResponseDataCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeSetScanResponseDataCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetScanResponseDataComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeSetScanResponseDataCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetScanResponseDataCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_scan_response_data_complete = match &command_complete.child {CommandCompleteDataChild::LeSetScanResponseDataComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetScanResponseDataComplete"),};Self {event,command_complete,le_set_scan_response_data_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_scan_response_data_complete.as_ref().status}
}
impl Into<EventPacket> for LeSetScanResponseDataCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetScanResponseDataCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetScanResponseDataCompleteBuilder {pub fn build(self) -> LeSetScanResponseDataCompletePacket {let le_set_scan_response_data_complete= Arc::new(LeSetScanResponseDataCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetScanResponseData, child: CommandCompleteDataChild::LeSetScanResponseDataComplete(le_set_scan_response_data_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetScanResponseDataCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetScanResponseDataCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetScanResponseDataCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetAdvertisingEnableData {advertising_enable: Enable, }
#[derive(Debug, Clone)] pub struct LeSetAdvertisingEnablePacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_set_advertising_enable: Arc<LeSetAdvertisingEnableData>,}
#[derive(Debug)] pub struct LeSetAdvertisingEnableBuilder {pub advertising_enable: Enable, }
impl LeSetAdvertisingEnableData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetAdvertisingEnable".to_string(),    field: "advertising_enable".to_string(),    wanted: 4,    got: bytes.len()});}let advertising_enable = u8::from_le_bytes([bytes[3]]);let advertising_enable = Enable::from_u8(advertising_enable).unwrap();Ok(Self {advertising_enable, })
}
fn write_to(&self, buffer: &mut BytesMut) {let advertising_enable = self.advertising_enable.to_u8().unwrap();buffer[3..4].copy_from_slice(&advertising_enable.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for LeSetAdvertisingEnablePacket { type ResponseType = LeSetAdvertisingEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetAdvertisingEnableCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetAdvertisingEnablePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetAdvertisingEnablePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_set_advertising_enable = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeSetAdvertisingEnable(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetAdvertisingEnable"),};Self {command,le_advertising_command,le_set_advertising_enable,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_advertising_enable(&self) -> Enable{ self.le_set_advertising_enable.as_ref().advertising_enable}
}
impl Into<CommandPacket> for LeSetAdvertisingEnablePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeSetAdvertisingEnablePacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetAdvertisingEnableBuilder { type ResponseType = LeSetAdvertisingEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetAdvertisingEnableCompletePacket::new(pkt.event.clone()) }}impl LeSetAdvertisingEnableBuilder {pub fn build(self) -> LeSetAdvertisingEnablePacket {let le_set_advertising_enable= Arc::new(LeSetAdvertisingEnableData {advertising_enable: self.advertising_enable, });let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeSetAdvertisingEnable(le_set_advertising_enable),});let command= Arc::new(CommandData {op_code: OpCode::LeSetAdvertisingEnable, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeSetAdvertisingEnablePacket::new(command)}
}
impl Into<CommandPacket> for LeSetAdvertisingEnableBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeSetAdvertisingEnableBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetAdvertisingEnableCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeSetAdvertisingEnableCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_advertising_enable_complete: Arc<LeSetAdvertisingEnableCompleteData>,}
#[derive(Debug)] pub struct LeSetAdvertisingEnableCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeSetAdvertisingEnableCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetAdvertisingEnableComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeSetAdvertisingEnableCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetAdvertisingEnableCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_advertising_enable_complete = match &command_complete.child {CommandCompleteDataChild::LeSetAdvertisingEnableComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetAdvertisingEnableComplete"),};Self {event,command_complete,le_set_advertising_enable_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_advertising_enable_complete.as_ref().status}
}
impl Into<EventPacket> for LeSetAdvertisingEnableCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetAdvertisingEnableCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetAdvertisingEnableCompleteBuilder {pub fn build(self) -> LeSetAdvertisingEnableCompletePacket {let le_set_advertising_enable_complete= Arc::new(LeSetAdvertisingEnableCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetAdvertisingEnable, child: CommandCompleteDataChild::LeSetAdvertisingEnableComplete(le_set_advertising_enable_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetAdvertisingEnableCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetAdvertisingEnableCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetAdvertisingEnableCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetScanParametersData {le_scan_type: LeScanType, le_scan_interval: u16, le_scan_window: u16, own_address_type: OwnAddressType, scanning_filter_policy: LeScanningFilterPolicy, }
#[derive(Debug, Clone)] pub struct LeSetScanParametersPacket {command: Arc<CommandData>,le_scanning_command: Arc<LeScanningCommandData>,le_set_scan_parameters: Arc<LeSetScanParametersData>,}
#[derive(Debug)] pub struct LeSetScanParametersBuilder {pub le_scan_type: LeScanType, pub le_scan_interval: u16, pub le_scan_window: u16, pub own_address_type: OwnAddressType, pub scanning_filter_policy: LeScanningFilterPolicy, }
impl LeSetScanParametersData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetScanParameters".to_string(),    field: "le_scan_type".to_string(),    wanted: 4,    got: bytes.len()});}let le_scan_type = u8::from_le_bytes([bytes[3]]);let le_scan_type = LeScanType::from_u8(le_scan_type).unwrap();if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetScanParameters".to_string(),    field: "le_scan_interval".to_string(),    wanted: 6,    got: bytes.len()});}let le_scan_interval = u16::from_le_bytes([bytes[4],bytes[5]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeSetScanParameters".to_string(),    field: "le_scan_window".to_string(),    wanted: 8,    got: bytes.len()});}let le_scan_window = u16::from_le_bytes([bytes[6],bytes[7]]);if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeSetScanParameters".to_string(),    field: "own_address_type".to_string(),    wanted: 9,    got: bytes.len()});}let own_address_type = u8::from_le_bytes([bytes[8]]);let own_address_type = OwnAddressType::from_u8(own_address_type).unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeSetScanParameters".to_string(),    field: "scanning_filter_policy".to_string(),    wanted: 10,    got: bytes.len()});}let scanning_filter_policy = u8::from_le_bytes([bytes[9]]);let scanning_filter_policy = LeScanningFilterPolicy::from_u8(scanning_filter_policy).unwrap();Ok(Self {le_scan_type, le_scan_interval, le_scan_window, own_address_type, scanning_filter_policy, })
}
fn write_to(&self, buffer: &mut BytesMut) {let le_scan_type = self.le_scan_type.to_u8().unwrap();buffer[3..4].copy_from_slice(&le_scan_type.to_le_bytes()[0..1]);let le_scan_interval = self.le_scan_interval;buffer[4..6].copy_from_slice(&le_scan_interval.to_le_bytes()[0..2]);let le_scan_window = self.le_scan_window;buffer[6..8].copy_from_slice(&le_scan_window.to_le_bytes()[0..2]);let own_address_type = self.own_address_type.to_u8().unwrap();buffer[8..9].copy_from_slice(&own_address_type.to_le_bytes()[0..1]);let scanning_filter_policy = self.scanning_filter_policy.to_u8().unwrap();buffer[9..10].copy_from_slice(&scanning_filter_policy.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl CommandExpectations for LeSetScanParametersPacket { type ResponseType = LeSetScanParametersCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetScanParametersCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetScanParametersPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetScanParametersPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_scanning_command = match &command.child {CommandDataChild::LeScanningCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanningCommand"),};let le_set_scan_parameters = match &le_scanning_command.child {LeScanningCommandDataChild::LeSetScanParameters(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetScanParameters"),};Self {command,le_scanning_command,le_set_scan_parameters,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_le_scan_type(&self) -> LeScanType{ self.le_set_scan_parameters.as_ref().le_scan_type}
pub fn get_le_scan_interval(&self) -> u16{ self.le_set_scan_parameters.as_ref().le_scan_interval}
pub fn get_le_scan_window(&self) -> u16{ self.le_set_scan_parameters.as_ref().le_scan_window}
pub fn get_own_address_type(&self) -> OwnAddressType{ self.le_set_scan_parameters.as_ref().own_address_type}
pub fn get_scanning_filter_policy(&self) -> LeScanningFilterPolicy{ self.le_set_scan_parameters.as_ref().scanning_filter_policy}
}
impl Into<CommandPacket> for LeSetScanParametersPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeScanningCommandPacket> for LeSetScanParametersPacket { fn into(self) -> LeScanningCommandPacket {LeScanningCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetScanParametersBuilder { type ResponseType = LeSetScanParametersCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetScanParametersCompletePacket::new(pkt.event.clone()) }}impl LeSetScanParametersBuilder {pub fn build(self) -> LeSetScanParametersPacket {let le_set_scan_parameters= Arc::new(LeSetScanParametersData {le_scan_type: self.le_scan_type, le_scan_interval: self.le_scan_interval, le_scan_window: self.le_scan_window, own_address_type: self.own_address_type, scanning_filter_policy: self.scanning_filter_policy, });let le_scanning_command= Arc::new(LeScanningCommandData {child: LeScanningCommandDataChild::LeSetScanParameters(le_set_scan_parameters),});let command= Arc::new(CommandData {op_code: OpCode::LeSetScanParameters, child: CommandDataChild::LeScanningCommand(le_scanning_command),});LeSetScanParametersPacket::new(command)}
}
impl Into<CommandPacket> for LeSetScanParametersBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeScanningCommandPacket> for LeSetScanParametersBuilder { fn into(self) -> LeScanningCommandPacket { self.build().into() }}
macro_rules! le_set_scan_parameters_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::LeScanningCommand(le_scanning_command_packet) => {match le_scanning_command_packet.specialize() {/* (2) */
LeScanningCommandChild::LeSetScanParameters(packet) => {let rebuilder = LeSetScanParametersBuilder {le_scan_type : packet.get_le_scan_type(),le_scan_interval : packet.get_le_scan_interval(),le_scan_window : packet.get_le_scan_window(),own_address_type : packet.get_own_address_type(),scanning_filter_policy : packet.get_scanning_filter_policy(),};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse le_set_scan_parameters{:02x?}", le_scanning_command_packet); }}}_ => {println!("Couldn't parse le_scanning_command{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}le_set_scan_parameters_builder_tests! { le_set_scan_parameters_builder_test_00: b"\x0b\x20\x07\x01\x12\x00\x12\x00\x01\x00",}


#[derive(Debug)] struct LeSetScanParametersCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeSetScanParametersCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_scan_parameters_complete: Arc<LeSetScanParametersCompleteData>,}
#[derive(Debug)] pub struct LeSetScanParametersCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeSetScanParametersCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetScanParametersComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeSetScanParametersCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetScanParametersCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_scan_parameters_complete = match &command_complete.child {CommandCompleteDataChild::LeSetScanParametersComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetScanParametersComplete"),};Self {event,command_complete,le_set_scan_parameters_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_scan_parameters_complete.as_ref().status}
}
impl Into<EventPacket> for LeSetScanParametersCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetScanParametersCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetScanParametersCompleteBuilder {pub fn build(self) -> LeSetScanParametersCompletePacket {let le_set_scan_parameters_complete= Arc::new(LeSetScanParametersCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetScanParameters, child: CommandCompleteDataChild::LeSetScanParametersComplete(le_set_scan_parameters_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetScanParametersCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetScanParametersCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetScanParametersCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetScanEnableData {le_scan_enable: Enable, filter_duplicates: Enable, }
#[derive(Debug, Clone)] pub struct LeSetScanEnablePacket {command: Arc<CommandData>,le_scanning_command: Arc<LeScanningCommandData>,le_set_scan_enable: Arc<LeSetScanEnableData>,}
#[derive(Debug)] pub struct LeSetScanEnableBuilder {pub le_scan_enable: Enable, pub filter_duplicates: Enable, }
impl LeSetScanEnableData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetScanEnable".to_string(),    field: "le_scan_enable".to_string(),    wanted: 4,    got: bytes.len()});}let le_scan_enable = u8::from_le_bytes([bytes[3]]);let le_scan_enable = Enable::from_u8(le_scan_enable).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeSetScanEnable".to_string(),    field: "filter_duplicates".to_string(),    wanted: 5,    got: bytes.len()});}let filter_duplicates = u8::from_le_bytes([bytes[4]]);let filter_duplicates = Enable::from_u8(filter_duplicates).unwrap();Ok(Self {le_scan_enable, filter_duplicates, })
}
fn write_to(&self, buffer: &mut BytesMut) {let le_scan_enable = self.le_scan_enable.to_u8().unwrap();buffer[3..4].copy_from_slice(&le_scan_enable.to_le_bytes()[0..1]);let filter_duplicates = self.filter_duplicates.to_u8().unwrap();buffer[4..5].copy_from_slice(&filter_duplicates.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for LeSetScanEnablePacket { type ResponseType = LeSetScanEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetScanEnableCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetScanEnablePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetScanEnablePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_scanning_command = match &command.child {CommandDataChild::LeScanningCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanningCommand"),};let le_set_scan_enable = match &le_scanning_command.child {LeScanningCommandDataChild::LeSetScanEnable(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetScanEnable"),};Self {command,le_scanning_command,le_set_scan_enable,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_le_scan_enable(&self) -> Enable{ self.le_set_scan_enable.as_ref().le_scan_enable}
pub fn get_filter_duplicates(&self) -> Enable{ self.le_set_scan_enable.as_ref().filter_duplicates}
}
impl Into<CommandPacket> for LeSetScanEnablePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeScanningCommandPacket> for LeSetScanEnablePacket { fn into(self) -> LeScanningCommandPacket {LeScanningCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetScanEnableBuilder { type ResponseType = LeSetScanEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetScanEnableCompletePacket::new(pkt.event.clone()) }}impl LeSetScanEnableBuilder {pub fn build(self) -> LeSetScanEnablePacket {let le_set_scan_enable= Arc::new(LeSetScanEnableData {le_scan_enable: self.le_scan_enable, filter_duplicates: self.filter_duplicates, });let le_scanning_command= Arc::new(LeScanningCommandData {child: LeScanningCommandDataChild::LeSetScanEnable(le_set_scan_enable),});let command= Arc::new(CommandData {op_code: OpCode::LeSetScanEnable, child: CommandDataChild::LeScanningCommand(le_scanning_command),});LeSetScanEnablePacket::new(command)}
}
impl Into<CommandPacket> for LeSetScanEnableBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeScanningCommandPacket> for LeSetScanEnableBuilder { fn into(self) -> LeScanningCommandPacket { self.build().into() }}
macro_rules! le_set_scan_enable_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::LeScanningCommand(le_scanning_command_packet) => {match le_scanning_command_packet.specialize() {/* (2) */
LeScanningCommandChild::LeSetScanEnable(packet) => {let rebuilder = LeSetScanEnableBuilder {le_scan_enable : packet.get_le_scan_enable(),filter_duplicates : packet.get_filter_duplicates(),};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse le_set_scan_enable{:02x?}", le_scanning_command_packet); }}}_ => {println!("Couldn't parse le_scanning_command{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}le_set_scan_enable_builder_tests! { le_set_scan_enable_builder_test_00: b"\x0c\x20\x02\x01\x00",}


#[derive(Debug)] struct LeSetScanEnableCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeSetScanEnableCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_scan_enable_complete: Arc<LeSetScanEnableCompleteData>,}
#[derive(Debug)] pub struct LeSetScanEnableCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeSetScanEnableCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetScanEnableComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeSetScanEnableCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetScanEnableCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_scan_enable_complete = match &command_complete.child {CommandCompleteDataChild::LeSetScanEnableComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetScanEnableComplete"),};Self {event,command_complete,le_set_scan_enable_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_scan_enable_complete.as_ref().status}
}
impl Into<EventPacket> for LeSetScanEnableCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetScanEnableCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetScanEnableCompleteBuilder {pub fn build(self) -> LeSetScanEnableCompletePacket {let le_set_scan_enable_complete= Arc::new(LeSetScanEnableCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetScanEnable, child: CommandCompleteDataChild::LeSetScanEnableComplete(le_set_scan_enable_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetScanEnableCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetScanEnableCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetScanEnableCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeCreateConnectionData {le_scan_interval: u16, le_scan_window: u16, initiator_filter_policy: InitiatorFilterPolicy, peer_address_type: AddressType, peer_address: Address, own_address_type: OwnAddressType, conn_interval_min: u16, conn_interval_max: u16, conn_latency: u16, supervision_timeout: u16, minimum_ce_length: u16, maximum_ce_length: u16, }
#[derive(Debug, Clone)] pub struct LeCreateConnectionPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,le_connection_management_command: Arc<LeConnectionManagementCommandData>,le_create_connection: Arc<LeCreateConnectionData>,}
#[derive(Debug)] pub struct LeCreateConnectionBuilder {pub le_scan_interval: u16, pub le_scan_window: u16, pub initiator_filter_policy: InitiatorFilterPolicy, pub peer_address_type: AddressType, pub peer_address: Address, pub own_address_type: OwnAddressType, pub conn_interval_min: u16, pub conn_interval_max: u16, pub conn_latency: u16, pub supervision_timeout: u16, pub minimum_ce_length: u16, pub maximum_ce_length: u16, }
impl LeCreateConnectionData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeCreateConnection".to_string(),    field: "le_scan_interval".to_string(),    wanted: 5,    got: bytes.len()});}let le_scan_interval = u16::from_le_bytes([bytes[3],bytes[4]]);if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeCreateConnection".to_string(),    field: "le_scan_window".to_string(),    wanted: 7,    got: bytes.len()});}let le_scan_window = u16::from_le_bytes([bytes[5],bytes[6]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeCreateConnection".to_string(),    field: "initiator_filter_policy".to_string(),    wanted: 8,    got: bytes.len()});}let initiator_filter_policy = u8::from_le_bytes([bytes[7]]);let initiator_filter_policy = InitiatorFilterPolicy::from_u8(initiator_filter_policy).unwrap();if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeCreateConnection".to_string(),    field: "peer_address_type".to_string(),    wanted: 9,    got: bytes.len()});}let peer_address_type = u8::from_le_bytes([bytes[8]]);let peer_address_type = AddressType::from_u8(peer_address_type).unwrap();if bytes.len() < 15 { return Err(Error::InvalidLengthError{    obj: "LeCreateConnection".to_string(),    field: "peer_address".to_string(),    wanted: 15,    got: bytes.len()});}let peer_address = bytes[9..15].try_into().unwrap();if bytes.len() < 16 { return Err(Error::InvalidLengthError{    obj: "LeCreateConnection".to_string(),    field: "own_address_type".to_string(),    wanted: 16,    got: bytes.len()});}let own_address_type = u8::from_le_bytes([bytes[15]]);let own_address_type = OwnAddressType::from_u8(own_address_type).unwrap();if bytes.len() < 18 { return Err(Error::InvalidLengthError{    obj: "LeCreateConnection".to_string(),    field: "conn_interval_min".to_string(),    wanted: 18,    got: bytes.len()});}let conn_interval_min = u16::from_le_bytes([bytes[16],bytes[17]]);if bytes.len() < 20 { return Err(Error::InvalidLengthError{    obj: "LeCreateConnection".to_string(),    field: "conn_interval_max".to_string(),    wanted: 20,    got: bytes.len()});}let conn_interval_max = u16::from_le_bytes([bytes[18],bytes[19]]);if bytes.len() < 22 { return Err(Error::InvalidLengthError{    obj: "LeCreateConnection".to_string(),    field: "conn_latency".to_string(),    wanted: 22,    got: bytes.len()});}let conn_latency = u16::from_le_bytes([bytes[20],bytes[21]]);if bytes.len() < 24 { return Err(Error::InvalidLengthError{    obj: "LeCreateConnection".to_string(),    field: "supervision_timeout".to_string(),    wanted: 24,    got: bytes.len()});}let supervision_timeout = u16::from_le_bytes([bytes[22],bytes[23]]);if bytes.len() < 26 { return Err(Error::InvalidLengthError{    obj: "LeCreateConnection".to_string(),    field: "minimum_ce_length".to_string(),    wanted: 26,    got: bytes.len()});}let minimum_ce_length = u16::from_le_bytes([bytes[24],bytes[25]]);if bytes.len() < 28 { return Err(Error::InvalidLengthError{    obj: "LeCreateConnection".to_string(),    field: "maximum_ce_length".to_string(),    wanted: 28,    got: bytes.len()});}let maximum_ce_length = u16::from_le_bytes([bytes[26],bytes[27]]);Ok(Self {le_scan_interval, le_scan_window, initiator_filter_policy, peer_address_type, peer_address, own_address_type, conn_interval_min, conn_interval_max, conn_latency, supervision_timeout, minimum_ce_length, maximum_ce_length, })
}
fn write_to(&self, buffer: &mut BytesMut) {let le_scan_interval = self.le_scan_interval;buffer[3..5].copy_from_slice(&le_scan_interval.to_le_bytes()[0..2]);let le_scan_window = self.le_scan_window;buffer[5..7].copy_from_slice(&le_scan_window.to_le_bytes()[0..2]);let initiator_filter_policy = self.initiator_filter_policy.to_u8().unwrap();buffer[7..8].copy_from_slice(&initiator_filter_policy.to_le_bytes()[0..1]);let peer_address_type = self.peer_address_type.to_u8().unwrap();buffer[8..9].copy_from_slice(&peer_address_type.to_le_bytes()[0..1]);let peer_address: [u8; 6] = self.peer_address.into();buffer[9..15].copy_from_slice(&peer_address);let own_address_type = self.own_address_type.to_u8().unwrap();buffer[15..16].copy_from_slice(&own_address_type.to_le_bytes()[0..1]);let conn_interval_min = self.conn_interval_min;buffer[16..18].copy_from_slice(&conn_interval_min.to_le_bytes()[0..2]);let conn_interval_max = self.conn_interval_max;buffer[18..20].copy_from_slice(&conn_interval_max.to_le_bytes()[0..2]);let conn_latency = self.conn_latency;buffer[20..22].copy_from_slice(&conn_latency.to_le_bytes()[0..2]);let supervision_timeout = self.supervision_timeout;buffer[22..24].copy_from_slice(&supervision_timeout.to_le_bytes()[0..2]);let minimum_ce_length = self.minimum_ce_length;buffer[24..26].copy_from_slice(&minimum_ce_length.to_le_bytes()[0..2]);let maximum_ce_length = self.maximum_ce_length;buffer[26..28].copy_from_slice(&maximum_ce_length.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 25;ret}
}
impl CommandExpectations for LeCreateConnectionPacket { type ResponseType = LeCreateConnectionStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeCreateConnectionStatusPacket::new(pkt.event.clone()) }}impl Packet for LeCreateConnectionPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeCreateConnectionPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let le_connection_management_command = match &acl_command.child {AclCommandDataChild::LeConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeConnectionManagementCommand"),};let le_create_connection = match &le_connection_management_command.child {LeConnectionManagementCommandDataChild::LeCreateConnection(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeCreateConnection"),};Self {command,acl_command,le_connection_management_command,le_create_connection,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_le_scan_interval(&self) -> u16{ self.le_create_connection.as_ref().le_scan_interval}
pub fn get_le_scan_window(&self) -> u16{ self.le_create_connection.as_ref().le_scan_window}
pub fn get_initiator_filter_policy(&self) -> InitiatorFilterPolicy{ self.le_create_connection.as_ref().initiator_filter_policy}
pub fn get_peer_address_type(&self) -> AddressType{ self.le_create_connection.as_ref().peer_address_type}
pub fn get_peer_address(&self) -> Address{ self.le_create_connection.as_ref().peer_address}
pub fn get_own_address_type(&self) -> OwnAddressType{ self.le_create_connection.as_ref().own_address_type}
pub fn get_conn_interval_min(&self) -> u16{ self.le_create_connection.as_ref().conn_interval_min}
pub fn get_conn_interval_max(&self) -> u16{ self.le_create_connection.as_ref().conn_interval_max}
pub fn get_conn_latency(&self) -> u16{ self.le_create_connection.as_ref().conn_latency}
pub fn get_supervision_timeout(&self) -> u16{ self.le_create_connection.as_ref().supervision_timeout}
pub fn get_minimum_ce_length(&self) -> u16{ self.le_create_connection.as_ref().minimum_ce_length}
pub fn get_maximum_ce_length(&self) -> u16{ self.le_create_connection.as_ref().maximum_ce_length}
}
impl Into<CommandPacket> for LeCreateConnectionPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for LeCreateConnectionPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<LeConnectionManagementCommandPacket> for LeCreateConnectionPacket { fn into(self) -> LeConnectionManagementCommandPacket {LeConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for LeCreateConnectionBuilder { type ResponseType = LeCreateConnectionStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeCreateConnectionStatusPacket::new(pkt.event.clone()) }}impl LeCreateConnectionBuilder {pub fn build(self) -> LeCreateConnectionPacket {let le_create_connection= Arc::new(LeCreateConnectionData {le_scan_interval: self.le_scan_interval, le_scan_window: self.le_scan_window, initiator_filter_policy: self.initiator_filter_policy, peer_address_type: self.peer_address_type, peer_address: self.peer_address, own_address_type: self.own_address_type, conn_interval_min: self.conn_interval_min, conn_interval_max: self.conn_interval_max, conn_latency: self.conn_latency, supervision_timeout: self.supervision_timeout, minimum_ce_length: self.minimum_ce_length, maximum_ce_length: self.maximum_ce_length, });let le_connection_management_command= Arc::new(LeConnectionManagementCommandData {child: LeConnectionManagementCommandDataChild::LeCreateConnection(le_create_connection),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::LeConnectionManagementCommand(le_connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::LeCreateConnection, child: CommandDataChild::AclCommand(acl_command),});LeCreateConnectionPacket::new(command)}
}
impl Into<CommandPacket> for LeCreateConnectionBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for LeCreateConnectionBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<LeConnectionManagementCommandPacket> for LeCreateConnectionBuilder { fn into(self) -> LeConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeCreateConnectionStatusData {}
#[derive(Debug, Clone)] pub struct LeCreateConnectionStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,le_create_connection_status: Arc<LeCreateConnectionStatusData>,}
#[derive(Debug)] pub struct LeCreateConnectionStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl LeCreateConnectionStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeCreateConnectionStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeCreateConnectionStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let le_create_connection_status = match &command_status.child {CommandStatusDataChild::LeCreateConnectionStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeCreateConnectionStatus"),};Self {event,command_status,le_create_connection_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for LeCreateConnectionStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for LeCreateConnectionStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl LeCreateConnectionStatusBuilder {pub fn build(self) -> LeCreateConnectionStatusPacket {let le_create_connection_status= Arc::new(LeCreateConnectionStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeCreateConnection, child: CommandStatusDataChild::LeCreateConnectionStatus(le_create_connection_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});LeCreateConnectionStatusPacket::new(event)}
}
impl Into<EventPacket> for LeCreateConnectionStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for LeCreateConnectionStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct LeCreateConnectionCancelData {}
#[derive(Debug, Clone)] pub struct LeCreateConnectionCancelPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,le_connection_management_command: Arc<LeConnectionManagementCommandData>,le_create_connection_cancel: Arc<LeCreateConnectionCancelData>,}
#[derive(Debug)] pub struct LeCreateConnectionCancelBuilder {}
impl LeCreateConnectionCancelData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeCreateConnectionCancelPacket { type ResponseType = LeCreateConnectionCancelCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeCreateConnectionCancelCompletePacket::new(pkt.event.clone()) }}impl Packet for LeCreateConnectionCancelPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeCreateConnectionCancelPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let le_connection_management_command = match &acl_command.child {AclCommandDataChild::LeConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeConnectionManagementCommand"),};let le_create_connection_cancel = match &le_connection_management_command.child {LeConnectionManagementCommandDataChild::LeCreateConnectionCancel(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeCreateConnectionCancel"),};Self {command,acl_command,le_connection_management_command,le_create_connection_cancel,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeCreateConnectionCancelPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for LeCreateConnectionCancelPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<LeConnectionManagementCommandPacket> for LeCreateConnectionCancelPacket { fn into(self) -> LeConnectionManagementCommandPacket {LeConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for LeCreateConnectionCancelBuilder { type ResponseType = LeCreateConnectionCancelCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeCreateConnectionCancelCompletePacket::new(pkt.event.clone()) }}impl LeCreateConnectionCancelBuilder {pub fn build(self) -> LeCreateConnectionCancelPacket {let le_create_connection_cancel= Arc::new(LeCreateConnectionCancelData {});let le_connection_management_command= Arc::new(LeConnectionManagementCommandData {child: LeConnectionManagementCommandDataChild::LeCreateConnectionCancel(le_create_connection_cancel),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::LeConnectionManagementCommand(le_connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::LeCreateConnectionCancel, child: CommandDataChild::AclCommand(acl_command),});LeCreateConnectionCancelPacket::new(command)}
}
impl Into<CommandPacket> for LeCreateConnectionCancelBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for LeCreateConnectionCancelBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<LeConnectionManagementCommandPacket> for LeCreateConnectionCancelBuilder { fn into(self) -> LeConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeCreateConnectionCancelCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeCreateConnectionCancelCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_create_connection_cancel_complete: Arc<LeCreateConnectionCancelCompleteData>,}
#[derive(Debug)] pub struct LeCreateConnectionCancelCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeCreateConnectionCancelCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeCreateConnectionCancelComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeCreateConnectionCancelCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeCreateConnectionCancelCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_create_connection_cancel_complete = match &command_complete.child {CommandCompleteDataChild::LeCreateConnectionCancelComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeCreateConnectionCancelComplete"),};Self {event,command_complete,le_create_connection_cancel_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_create_connection_cancel_complete.as_ref().status}
}
impl Into<EventPacket> for LeCreateConnectionCancelCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeCreateConnectionCancelCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeCreateConnectionCancelCompleteBuilder {pub fn build(self) -> LeCreateConnectionCancelCompletePacket {let le_create_connection_cancel_complete= Arc::new(LeCreateConnectionCancelCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeCreateConnectionCancel, child: CommandCompleteDataChild::LeCreateConnectionCancelComplete(le_create_connection_cancel_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeCreateConnectionCancelCompletePacket::new(event)}
}
impl Into<EventPacket> for LeCreateConnectionCancelCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeCreateConnectionCancelCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeReadConnectListSizeData {}
#[derive(Debug, Clone)] pub struct LeReadConnectListSizePacket {command: Arc<CommandData>,le_read_connect_list_size: Arc<LeReadConnectListSizeData>,}
#[derive(Debug)] pub struct LeReadConnectListSizeBuilder {}
impl LeReadConnectListSizeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeReadConnectListSizePacket { type ResponseType = LeReadConnectListSizeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadConnectListSizeCompletePacket::new(pkt.event.clone()) }}impl Packet for LeReadConnectListSizePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadConnectListSizePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_read_connect_list_size = match &command.child {CommandDataChild::LeReadConnectListSize(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadConnectListSize"),};Self {command,le_read_connect_list_size,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeReadConnectListSizePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeReadConnectListSizeBuilder { type ResponseType = LeReadConnectListSizeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadConnectListSizeCompletePacket::new(pkt.event.clone()) }}impl LeReadConnectListSizeBuilder {pub fn build(self) -> LeReadConnectListSizePacket {let le_read_connect_list_size= Arc::new(LeReadConnectListSizeData {});let command= Arc::new(CommandData {op_code: OpCode::LeReadConnectListSize, child: CommandDataChild::LeReadConnectListSize(le_read_connect_list_size),});LeReadConnectListSizePacket::new(command)}
}
impl Into<CommandPacket> for LeReadConnectListSizeBuilder { fn into(self) -> CommandPacket { self.build().into() }}
macro_rules! le_read_connect_list_size_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::LeReadConnectListSize(packet) => {let rebuilder = LeReadConnectListSizeBuilder {};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse le_read_connect_list_size{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}le_read_connect_list_size_builder_tests! { le_read_connect_list_size_builder_test_00: b"\x0f\x20\x00",}


#[derive(Debug)] struct LeReadConnectListSizeCompleteData {status: ErrorCode, connect_list_size: u8, }
#[derive(Debug, Clone)] pub struct LeReadConnectListSizeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_read_connect_list_size_complete: Arc<LeReadConnectListSizeCompleteData>,}
#[derive(Debug)] pub struct LeReadConnectListSizeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connect_list_size: u8, }
impl LeReadConnectListSizeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeReadConnectListSizeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeReadConnectListSizeComplete".to_string(),    field: "connect_list_size".to_string(),    wanted: 7,    got: bytes.len()});}let connect_list_size = u8::from_le_bytes([bytes[6]]);Ok(Self {status, connect_list_size, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connect_list_size = self.connect_list_size;buffer[6..7].copy_from_slice(&connect_list_size.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for LeReadConnectListSizeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadConnectListSizeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_read_connect_list_size_complete = match &command_complete.child {CommandCompleteDataChild::LeReadConnectListSizeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadConnectListSizeComplete"),};Self {event,command_complete,le_read_connect_list_size_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_read_connect_list_size_complete.as_ref().status}
pub fn get_connect_list_size(&self) -> u8{ self.le_read_connect_list_size_complete.as_ref().connect_list_size}
}
impl Into<EventPacket> for LeReadConnectListSizeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeReadConnectListSizeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeReadConnectListSizeCompleteBuilder {pub fn build(self) -> LeReadConnectListSizeCompletePacket {let le_read_connect_list_size_complete= Arc::new(LeReadConnectListSizeCompleteData {status: self.status, connect_list_size: self.connect_list_size, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeReadConnectListSize, child: CommandCompleteDataChild::LeReadConnectListSizeComplete(le_read_connect_list_size_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeReadConnectListSizeCompletePacket::new(event)}
}
impl Into<EventPacket> for LeReadConnectListSizeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeReadConnectListSizeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! le_read_connect_list_size_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::LeReadConnectListSizeComplete(packet) => {let rebuilder = LeReadConnectListSizeCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),connect_list_size : packet.get_connect_list_size(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse le_read_connect_list_size_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}le_read_connect_list_size_complete_builder_tests! { le_read_connect_list_size_complete_builder_test_00: b"\x0e\x05\x01\x0f\x20\x00\x80",}


#[derive(Debug)] struct LeClearConnectListData {}
#[derive(Debug, Clone)] pub struct LeClearConnectListPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,le_connection_management_command: Arc<LeConnectionManagementCommandData>,le_clear_connect_list: Arc<LeClearConnectListData>,}
#[derive(Debug)] pub struct LeClearConnectListBuilder {}
impl LeClearConnectListData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeClearConnectListPacket { type ResponseType = LeClearConnectListCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeClearConnectListCompletePacket::new(pkt.event.clone()) }}impl Packet for LeClearConnectListPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeClearConnectListPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let le_connection_management_command = match &acl_command.child {AclCommandDataChild::LeConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeConnectionManagementCommand"),};let le_clear_connect_list = match &le_connection_management_command.child {LeConnectionManagementCommandDataChild::LeClearConnectList(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeClearConnectList"),};Self {command,acl_command,le_connection_management_command,le_clear_connect_list,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeClearConnectListPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for LeClearConnectListPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<LeConnectionManagementCommandPacket> for LeClearConnectListPacket { fn into(self) -> LeConnectionManagementCommandPacket {LeConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for LeClearConnectListBuilder { type ResponseType = LeClearConnectListCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeClearConnectListCompletePacket::new(pkt.event.clone()) }}impl LeClearConnectListBuilder {pub fn build(self) -> LeClearConnectListPacket {let le_clear_connect_list= Arc::new(LeClearConnectListData {});let le_connection_management_command= Arc::new(LeConnectionManagementCommandData {child: LeConnectionManagementCommandDataChild::LeClearConnectList(le_clear_connect_list),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::LeConnectionManagementCommand(le_connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::LeClearConnectList, child: CommandDataChild::AclCommand(acl_command),});LeClearConnectListPacket::new(command)}
}
impl Into<CommandPacket> for LeClearConnectListBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for LeClearConnectListBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<LeConnectionManagementCommandPacket> for LeClearConnectListBuilder { fn into(self) -> LeConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeClearConnectListCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeClearConnectListCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_clear_connect_list_complete: Arc<LeClearConnectListCompleteData>,}
#[derive(Debug)] pub struct LeClearConnectListCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeClearConnectListCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeClearConnectListComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeClearConnectListCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeClearConnectListCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_clear_connect_list_complete = match &command_complete.child {CommandCompleteDataChild::LeClearConnectListComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeClearConnectListComplete"),};Self {event,command_complete,le_clear_connect_list_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_clear_connect_list_complete.as_ref().status}
}
impl Into<EventPacket> for LeClearConnectListCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeClearConnectListCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeClearConnectListCompleteBuilder {pub fn build(self) -> LeClearConnectListCompletePacket {let le_clear_connect_list_complete= Arc::new(LeClearConnectListCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeClearConnectList, child: CommandCompleteDataChild::LeClearConnectListComplete(le_clear_connect_list_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeClearConnectListCompletePacket::new(event)}
}
impl Into<EventPacket> for LeClearConnectListCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeClearConnectListCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeAddDeviceToConnectListData {address_type: ConnectListAddressType, address: Address, }
#[derive(Debug, Clone)] pub struct LeAddDeviceToConnectListPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,le_connection_management_command: Arc<LeConnectionManagementCommandData>,le_add_device_to_connect_list: Arc<LeAddDeviceToConnectListData>,}
#[derive(Debug)] pub struct LeAddDeviceToConnectListBuilder {pub address_type: ConnectListAddressType, pub address: Address, }
impl LeAddDeviceToConnectListData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeAddDeviceToConnectList".to_string(),    field: "address_type".to_string(),    wanted: 4,    got: bytes.len()});}let address_type = u8::from_le_bytes([bytes[3]]);let address_type = ConnectListAddressType::from_u8(address_type).unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeAddDeviceToConnectList".to_string(),    field: "address".to_string(),    wanted: 10,    got: bytes.len()});}let address = bytes[4..10].try_into().unwrap();Ok(Self {address_type, address, })
}
fn write_to(&self, buffer: &mut BytesMut) {let address_type = self.address_type.to_u8().unwrap();buffer[3..4].copy_from_slice(&address_type.to_le_bytes()[0..1]);let address: [u8; 6] = self.address.into();buffer[4..10].copy_from_slice(&address);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl CommandExpectations for LeAddDeviceToConnectListPacket { type ResponseType = LeAddDeviceToConnectListCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeAddDeviceToConnectListCompletePacket::new(pkt.event.clone()) }}impl Packet for LeAddDeviceToConnectListPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAddDeviceToConnectListPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let le_connection_management_command = match &acl_command.child {AclCommandDataChild::LeConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeConnectionManagementCommand"),};let le_add_device_to_connect_list = match &le_connection_management_command.child {LeConnectionManagementCommandDataChild::LeAddDeviceToConnectList(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAddDeviceToConnectList"),};Self {command,acl_command,le_connection_management_command,le_add_device_to_connect_list,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_address_type(&self) -> ConnectListAddressType{ self.le_add_device_to_connect_list.as_ref().address_type}
pub fn get_address(&self) -> Address{ self.le_add_device_to_connect_list.as_ref().address}
}
impl Into<CommandPacket> for LeAddDeviceToConnectListPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for LeAddDeviceToConnectListPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<LeConnectionManagementCommandPacket> for LeAddDeviceToConnectListPacket { fn into(self) -> LeConnectionManagementCommandPacket {LeConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for LeAddDeviceToConnectListBuilder { type ResponseType = LeAddDeviceToConnectListCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeAddDeviceToConnectListCompletePacket::new(pkt.event.clone()) }}impl LeAddDeviceToConnectListBuilder {pub fn build(self) -> LeAddDeviceToConnectListPacket {let le_add_device_to_connect_list= Arc::new(LeAddDeviceToConnectListData {address_type: self.address_type, address: self.address, });let le_connection_management_command= Arc::new(LeConnectionManagementCommandData {child: LeConnectionManagementCommandDataChild::LeAddDeviceToConnectList(le_add_device_to_connect_list),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::LeConnectionManagementCommand(le_connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::LeAddDeviceToConnectList, child: CommandDataChild::AclCommand(acl_command),});LeAddDeviceToConnectListPacket::new(command)}
}
impl Into<CommandPacket> for LeAddDeviceToConnectListBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for LeAddDeviceToConnectListBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<LeConnectionManagementCommandPacket> for LeAddDeviceToConnectListBuilder { fn into(self) -> LeConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeAddDeviceToConnectListCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeAddDeviceToConnectListCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_add_device_to_connect_list_complete: Arc<LeAddDeviceToConnectListCompleteData>,}
#[derive(Debug)] pub struct LeAddDeviceToConnectListCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeAddDeviceToConnectListCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeAddDeviceToConnectListComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeAddDeviceToConnectListCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAddDeviceToConnectListCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_add_device_to_connect_list_complete = match &command_complete.child {CommandCompleteDataChild::LeAddDeviceToConnectListComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAddDeviceToConnectListComplete"),};Self {event,command_complete,le_add_device_to_connect_list_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_add_device_to_connect_list_complete.as_ref().status}
}
impl Into<EventPacket> for LeAddDeviceToConnectListCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeAddDeviceToConnectListCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeAddDeviceToConnectListCompleteBuilder {pub fn build(self) -> LeAddDeviceToConnectListCompletePacket {let le_add_device_to_connect_list_complete= Arc::new(LeAddDeviceToConnectListCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeAddDeviceToConnectList, child: CommandCompleteDataChild::LeAddDeviceToConnectListComplete(le_add_device_to_connect_list_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeAddDeviceToConnectListCompletePacket::new(event)}
}
impl Into<EventPacket> for LeAddDeviceToConnectListCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeAddDeviceToConnectListCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeRemoveDeviceFromConnectListData {address_type: ConnectListAddressType, address: Address, }
#[derive(Debug, Clone)] pub struct LeRemoveDeviceFromConnectListPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,le_connection_management_command: Arc<LeConnectionManagementCommandData>,le_remove_device_from_connect_list: Arc<LeRemoveDeviceFromConnectListData>,}
#[derive(Debug)] pub struct LeRemoveDeviceFromConnectListBuilder {pub address_type: ConnectListAddressType, pub address: Address, }
impl LeRemoveDeviceFromConnectListData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeRemoveDeviceFromConnectList".to_string(),    field: "address_type".to_string(),    wanted: 4,    got: bytes.len()});}let address_type = u8::from_le_bytes([bytes[3]]);let address_type = ConnectListAddressType::from_u8(address_type).unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeRemoveDeviceFromConnectList".to_string(),    field: "address".to_string(),    wanted: 10,    got: bytes.len()});}let address = bytes[4..10].try_into().unwrap();Ok(Self {address_type, address, })
}
fn write_to(&self, buffer: &mut BytesMut) {let address_type = self.address_type.to_u8().unwrap();buffer[3..4].copy_from_slice(&address_type.to_le_bytes()[0..1]);let address: [u8; 6] = self.address.into();buffer[4..10].copy_from_slice(&address);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl CommandExpectations for LeRemoveDeviceFromConnectListPacket { type ResponseType = LeRemoveDeviceFromConnectListCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeRemoveDeviceFromConnectListCompletePacket::new(pkt.event.clone()) }}impl Packet for LeRemoveDeviceFromConnectListPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeRemoveDeviceFromConnectListPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let le_connection_management_command = match &acl_command.child {AclCommandDataChild::LeConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeConnectionManagementCommand"),};let le_remove_device_from_connect_list = match &le_connection_management_command.child {LeConnectionManagementCommandDataChild::LeRemoveDeviceFromConnectList(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeRemoveDeviceFromConnectList"),};Self {command,acl_command,le_connection_management_command,le_remove_device_from_connect_list,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_address_type(&self) -> ConnectListAddressType{ self.le_remove_device_from_connect_list.as_ref().address_type}
pub fn get_address(&self) -> Address{ self.le_remove_device_from_connect_list.as_ref().address}
}
impl Into<CommandPacket> for LeRemoveDeviceFromConnectListPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for LeRemoveDeviceFromConnectListPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<LeConnectionManagementCommandPacket> for LeRemoveDeviceFromConnectListPacket { fn into(self) -> LeConnectionManagementCommandPacket {LeConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for LeRemoveDeviceFromConnectListBuilder { type ResponseType = LeRemoveDeviceFromConnectListCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeRemoveDeviceFromConnectListCompletePacket::new(pkt.event.clone()) }}impl LeRemoveDeviceFromConnectListBuilder {pub fn build(self) -> LeRemoveDeviceFromConnectListPacket {let le_remove_device_from_connect_list= Arc::new(LeRemoveDeviceFromConnectListData {address_type: self.address_type, address: self.address, });let le_connection_management_command= Arc::new(LeConnectionManagementCommandData {child: LeConnectionManagementCommandDataChild::LeRemoveDeviceFromConnectList(le_remove_device_from_connect_list),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::LeConnectionManagementCommand(le_connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::LeRemoveDeviceFromConnectList, child: CommandDataChild::AclCommand(acl_command),});LeRemoveDeviceFromConnectListPacket::new(command)}
}
impl Into<CommandPacket> for LeRemoveDeviceFromConnectListBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for LeRemoveDeviceFromConnectListBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<LeConnectionManagementCommandPacket> for LeRemoveDeviceFromConnectListBuilder { fn into(self) -> LeConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeRemoveDeviceFromConnectListCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeRemoveDeviceFromConnectListCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_remove_device_from_connect_list_complete: Arc<LeRemoveDeviceFromConnectListCompleteData>,}
#[derive(Debug)] pub struct LeRemoveDeviceFromConnectListCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeRemoveDeviceFromConnectListCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeRemoveDeviceFromConnectListComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeRemoveDeviceFromConnectListCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeRemoveDeviceFromConnectListCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_remove_device_from_connect_list_complete = match &command_complete.child {CommandCompleteDataChild::LeRemoveDeviceFromConnectListComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeRemoveDeviceFromConnectListComplete"),};Self {event,command_complete,le_remove_device_from_connect_list_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_remove_device_from_connect_list_complete.as_ref().status}
}
impl Into<EventPacket> for LeRemoveDeviceFromConnectListCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeRemoveDeviceFromConnectListCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeRemoveDeviceFromConnectListCompleteBuilder {pub fn build(self) -> LeRemoveDeviceFromConnectListCompletePacket {let le_remove_device_from_connect_list_complete= Arc::new(LeRemoveDeviceFromConnectListCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeRemoveDeviceFromConnectList, child: CommandCompleteDataChild::LeRemoveDeviceFromConnectListComplete(le_remove_device_from_connect_list_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeRemoveDeviceFromConnectListCompletePacket::new(event)}
}
impl Into<EventPacket> for LeRemoveDeviceFromConnectListCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeRemoveDeviceFromConnectListCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeConnectionUpdateData {connection_handle: u16, conn_interval_min: u16, conn_interval_max: u16, conn_latency: u16, supervision_timeout: u16, minimum_ce_length: u16, maximum_ce_length: u16, }
#[derive(Debug, Clone)] pub struct LeConnectionUpdatePacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,le_connection_management_command: Arc<LeConnectionManagementCommandData>,le_connection_update: Arc<LeConnectionUpdateData>,}
#[derive(Debug)] pub struct LeConnectionUpdateBuilder {pub connection_handle: u16, pub conn_interval_min: u16, pub conn_interval_max: u16, pub conn_latency: u16, pub supervision_timeout: u16, pub minimum_ce_length: u16, pub maximum_ce_length: u16, }
impl LeConnectionUpdateData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeConnectionUpdate".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeConnectionUpdate".to_string(),    field: "conn_interval_min".to_string(),    wanted: 7,    got: bytes.len()});}let conn_interval_min = u16::from_le_bytes([bytes[5],bytes[6]]);if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeConnectionUpdate".to_string(),    field: "conn_interval_max".to_string(),    wanted: 9,    got: bytes.len()});}let conn_interval_max = u16::from_le_bytes([bytes[7],bytes[8]]);if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "LeConnectionUpdate".to_string(),    field: "conn_latency".to_string(),    wanted: 11,    got: bytes.len()});}let conn_latency = u16::from_le_bytes([bytes[9],bytes[10]]);if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "LeConnectionUpdate".to_string(),    field: "supervision_timeout".to_string(),    wanted: 13,    got: bytes.len()});}let supervision_timeout = u16::from_le_bytes([bytes[11],bytes[12]]);if bytes.len() < 15 { return Err(Error::InvalidLengthError{    obj: "LeConnectionUpdate".to_string(),    field: "minimum_ce_length".to_string(),    wanted: 15,    got: bytes.len()});}let minimum_ce_length = u16::from_le_bytes([bytes[13],bytes[14]]);if bytes.len() < 17 { return Err(Error::InvalidLengthError{    obj: "LeConnectionUpdate".to_string(),    field: "maximum_ce_length".to_string(),    wanted: 17,    got: bytes.len()});}let maximum_ce_length = u16::from_le_bytes([bytes[15],bytes[16]]);Ok(Self {connection_handle, conn_interval_min, conn_interval_max, conn_latency, supervision_timeout, minimum_ce_length, maximum_ce_length, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let conn_interval_min = self.conn_interval_min;buffer[5..7].copy_from_slice(&conn_interval_min.to_le_bytes()[0..2]);let conn_interval_max = self.conn_interval_max;buffer[7..9].copy_from_slice(&conn_interval_max.to_le_bytes()[0..2]);let conn_latency = self.conn_latency;buffer[9..11].copy_from_slice(&conn_latency.to_le_bytes()[0..2]);let supervision_timeout = self.supervision_timeout;buffer[11..13].copy_from_slice(&supervision_timeout.to_le_bytes()[0..2]);let minimum_ce_length = self.minimum_ce_length;buffer[13..15].copy_from_slice(&minimum_ce_length.to_le_bytes()[0..2]);let maximum_ce_length = self.maximum_ce_length;buffer[15..17].copy_from_slice(&maximum_ce_length.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 14;ret}
}
impl CommandExpectations for LeConnectionUpdatePacket { type ResponseType = LeConnectionUpdateStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeConnectionUpdateStatusPacket::new(pkt.event.clone()) }}impl Packet for LeConnectionUpdatePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeConnectionUpdatePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let le_connection_management_command = match &acl_command.child {AclCommandDataChild::LeConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeConnectionManagementCommand"),};let le_connection_update = match &le_connection_management_command.child {LeConnectionManagementCommandDataChild::LeConnectionUpdate(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeConnectionUpdate"),};Self {command,acl_command,le_connection_management_command,le_connection_update,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_connection_update.as_ref().connection_handle}
pub fn get_conn_interval_min(&self) -> u16{ self.le_connection_update.as_ref().conn_interval_min}
pub fn get_conn_interval_max(&self) -> u16{ self.le_connection_update.as_ref().conn_interval_max}
pub fn get_conn_latency(&self) -> u16{ self.le_connection_update.as_ref().conn_latency}
pub fn get_supervision_timeout(&self) -> u16{ self.le_connection_update.as_ref().supervision_timeout}
pub fn get_minimum_ce_length(&self) -> u16{ self.le_connection_update.as_ref().minimum_ce_length}
pub fn get_maximum_ce_length(&self) -> u16{ self.le_connection_update.as_ref().maximum_ce_length}
}
impl Into<CommandPacket> for LeConnectionUpdatePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for LeConnectionUpdatePacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<LeConnectionManagementCommandPacket> for LeConnectionUpdatePacket { fn into(self) -> LeConnectionManagementCommandPacket {LeConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for LeConnectionUpdateBuilder { type ResponseType = LeConnectionUpdateStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeConnectionUpdateStatusPacket::new(pkt.event.clone()) }}impl LeConnectionUpdateBuilder {pub fn build(self) -> LeConnectionUpdatePacket {let le_connection_update= Arc::new(LeConnectionUpdateData {connection_handle: self.connection_handle, conn_interval_min: self.conn_interval_min, conn_interval_max: self.conn_interval_max, conn_latency: self.conn_latency, supervision_timeout: self.supervision_timeout, minimum_ce_length: self.minimum_ce_length, maximum_ce_length: self.maximum_ce_length, });let le_connection_management_command= Arc::new(LeConnectionManagementCommandData {child: LeConnectionManagementCommandDataChild::LeConnectionUpdate(le_connection_update),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::LeConnectionManagementCommand(le_connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::LeConnectionUpdate, child: CommandDataChild::AclCommand(acl_command),});LeConnectionUpdatePacket::new(command)}
}
impl Into<CommandPacket> for LeConnectionUpdateBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for LeConnectionUpdateBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<LeConnectionManagementCommandPacket> for LeConnectionUpdateBuilder { fn into(self) -> LeConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeConnectionUpdateStatusData {}
#[derive(Debug, Clone)] pub struct LeConnectionUpdateStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,le_connection_update_status: Arc<LeConnectionUpdateStatusData>,}
#[derive(Debug)] pub struct LeConnectionUpdateStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl LeConnectionUpdateStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeConnectionUpdateStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeConnectionUpdateStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let le_connection_update_status = match &command_status.child {CommandStatusDataChild::LeConnectionUpdateStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeConnectionUpdateStatus"),};Self {event,command_status,le_connection_update_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for LeConnectionUpdateStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for LeConnectionUpdateStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl LeConnectionUpdateStatusBuilder {pub fn build(self) -> LeConnectionUpdateStatusPacket {let le_connection_update_status= Arc::new(LeConnectionUpdateStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeConnectionUpdate, child: CommandStatusDataChild::LeConnectionUpdateStatus(le_connection_update_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});LeConnectionUpdateStatusPacket::new(event)}
}
impl Into<EventPacket> for LeConnectionUpdateStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for LeConnectionUpdateStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct LeSetHostChannelClassificationData {channel_map: [u8; 5], }
#[derive(Debug, Clone)] pub struct LeSetHostChannelClassificationPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,le_connection_management_command: Arc<LeConnectionManagementCommandData>,le_set_host_channel_classification: Arc<LeSetHostChannelClassificationData>,}
#[derive(Debug)] pub struct LeSetHostChannelClassificationBuilder {pub channel_map: [u8; 5], }
impl LeSetHostChannelClassificationData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeSetHostChannelClassification".to_string(),    field: "channel_map".to_string(),    wanted: 8,    got: bytes.len()});}let channel_map = bytes[3..8].try_into().unwrap();Ok(Self {channel_map, })
}
fn write_to(&self, buffer: &mut BytesMut) {&buffer[3..8].copy_from_slice(&self.channel_map);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 5;ret}
}
impl CommandExpectations for LeSetHostChannelClassificationPacket { type ResponseType = LeSetHostChannelClassificationCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetHostChannelClassificationCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetHostChannelClassificationPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetHostChannelClassificationPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let le_connection_management_command = match &acl_command.child {AclCommandDataChild::LeConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeConnectionManagementCommand"),};let le_set_host_channel_classification = match &le_connection_management_command.child {LeConnectionManagementCommandDataChild::LeSetHostChannelClassification(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetHostChannelClassification"),};Self {command,acl_command,le_connection_management_command,le_set_host_channel_classification,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_channel_map(&self) -> &[u8; 5]{ &self.le_set_host_channel_classification.as_ref().channel_map}
}
impl Into<CommandPacket> for LeSetHostChannelClassificationPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for LeSetHostChannelClassificationPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<LeConnectionManagementCommandPacket> for LeSetHostChannelClassificationPacket { fn into(self) -> LeConnectionManagementCommandPacket {LeConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetHostChannelClassificationBuilder { type ResponseType = LeSetHostChannelClassificationCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetHostChannelClassificationCompletePacket::new(pkt.event.clone()) }}impl LeSetHostChannelClassificationBuilder {pub fn build(self) -> LeSetHostChannelClassificationPacket {let le_set_host_channel_classification= Arc::new(LeSetHostChannelClassificationData {channel_map: self.channel_map, });let le_connection_management_command= Arc::new(LeConnectionManagementCommandData {child: LeConnectionManagementCommandDataChild::LeSetHostChannelClassification(le_set_host_channel_classification),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::LeConnectionManagementCommand(le_connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::LeSetHostChannelClassification, child: CommandDataChild::AclCommand(acl_command),});LeSetHostChannelClassificationPacket::new(command)}
}
impl Into<CommandPacket> for LeSetHostChannelClassificationBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for LeSetHostChannelClassificationBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<LeConnectionManagementCommandPacket> for LeSetHostChannelClassificationBuilder { fn into(self) -> LeConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetHostChannelClassificationCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeSetHostChannelClassificationCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_host_channel_classification_complete: Arc<LeSetHostChannelClassificationCompleteData>,}
#[derive(Debug)] pub struct LeSetHostChannelClassificationCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeSetHostChannelClassificationCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetHostChannelClassificationComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeSetHostChannelClassificationCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetHostChannelClassificationCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_host_channel_classification_complete = match &command_complete.child {CommandCompleteDataChild::LeSetHostChannelClassificationComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetHostChannelClassificationComplete"),};Self {event,command_complete,le_set_host_channel_classification_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_host_channel_classification_complete.as_ref().status}
}
impl Into<EventPacket> for LeSetHostChannelClassificationCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetHostChannelClassificationCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetHostChannelClassificationCompleteBuilder {pub fn build(self) -> LeSetHostChannelClassificationCompletePacket {let le_set_host_channel_classification_complete= Arc::new(LeSetHostChannelClassificationCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetHostChannelClassification, child: CommandCompleteDataChild::LeSetHostChannelClassificationComplete(le_set_host_channel_classification_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetHostChannelClassificationCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetHostChannelClassificationCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetHostChannelClassificationCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeReadChannelMapData {}
#[derive(Debug, Clone)] pub struct LeReadChannelMapPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,le_connection_management_command: Arc<LeConnectionManagementCommandData>,le_read_channel_map: Arc<LeReadChannelMapData>,}
#[derive(Debug)] pub struct LeReadChannelMapBuilder {}
impl LeReadChannelMapData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeReadChannelMapPacket { type ResponseType = LeReadChannelMapCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadChannelMapCompletePacket::new(pkt.event.clone()) }}impl Packet for LeReadChannelMapPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadChannelMapPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let le_connection_management_command = match &acl_command.child {AclCommandDataChild::LeConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeConnectionManagementCommand"),};let le_read_channel_map = match &le_connection_management_command.child {LeConnectionManagementCommandDataChild::LeReadChannelMap(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadChannelMap"),};Self {command,acl_command,le_connection_management_command,le_read_channel_map,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeReadChannelMapPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for LeReadChannelMapPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<LeConnectionManagementCommandPacket> for LeReadChannelMapPacket { fn into(self) -> LeConnectionManagementCommandPacket {LeConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for LeReadChannelMapBuilder { type ResponseType = LeReadChannelMapCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadChannelMapCompletePacket::new(pkt.event.clone()) }}impl LeReadChannelMapBuilder {pub fn build(self) -> LeReadChannelMapPacket {let le_read_channel_map= Arc::new(LeReadChannelMapData {});let le_connection_management_command= Arc::new(LeConnectionManagementCommandData {child: LeConnectionManagementCommandDataChild::LeReadChannelMap(le_read_channel_map),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::LeConnectionManagementCommand(le_connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::LeReadChannelMap, child: CommandDataChild::AclCommand(acl_command),});LeReadChannelMapPacket::new(command)}
}
impl Into<CommandPacket> for LeReadChannelMapBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for LeReadChannelMapBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<LeConnectionManagementCommandPacket> for LeReadChannelMapBuilder { fn into(self) -> LeConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeReadChannelMapCompleteData {status: ErrorCode, connection_handle: u16, channel_map: [u8; 5], }
#[derive(Debug, Clone)] pub struct LeReadChannelMapCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_read_channel_map_complete: Arc<LeReadChannelMapCompleteData>,}
#[derive(Debug)] pub struct LeReadChannelMapCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, pub channel_map: [u8; 5], }
impl LeReadChannelMapCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeReadChannelMapComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeReadChannelMapComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "LeReadChannelMapComplete".to_string(),    field: "channel_map".to_string(),    wanted: 13,    got: bytes.len()});}let channel_map = bytes[8..13].try_into().unwrap();Ok(Self {status, connection_handle, channel_map, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);&buffer[8..13].copy_from_slice(&self.channel_map);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 8;ret}
}
impl Packet for LeReadChannelMapCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadChannelMapCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_read_channel_map_complete = match &command_complete.child {CommandCompleteDataChild::LeReadChannelMapComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadChannelMapComplete"),};Self {event,command_complete,le_read_channel_map_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_read_channel_map_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_read_channel_map_complete.as_ref().connection_handle}
pub fn get_channel_map(&self) -> &[u8; 5]{ &self.le_read_channel_map_complete.as_ref().channel_map}
}
impl Into<EventPacket> for LeReadChannelMapCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeReadChannelMapCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeReadChannelMapCompleteBuilder {pub fn build(self) -> LeReadChannelMapCompletePacket {let le_read_channel_map_complete= Arc::new(LeReadChannelMapCompleteData {status: self.status, connection_handle: self.connection_handle, channel_map: self.channel_map, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeReadChannelMap, child: CommandCompleteDataChild::LeReadChannelMapComplete(le_read_channel_map_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeReadChannelMapCompletePacket::new(event)}
}
impl Into<EventPacket> for LeReadChannelMapCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeReadChannelMapCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeReadRemoteFeaturesData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct LeReadRemoteFeaturesPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,le_connection_management_command: Arc<LeConnectionManagementCommandData>,le_read_remote_features: Arc<LeReadRemoteFeaturesData>,}
#[derive(Debug)] pub struct LeReadRemoteFeaturesBuilder {pub connection_handle: u16, }
impl LeReadRemoteFeaturesData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeReadRemoteFeatures".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for LeReadRemoteFeaturesPacket { type ResponseType = LeReadRemoteFeaturesStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadRemoteFeaturesStatusPacket::new(pkt.event.clone()) }}impl Packet for LeReadRemoteFeaturesPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadRemoteFeaturesPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let le_connection_management_command = match &acl_command.child {AclCommandDataChild::LeConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeConnectionManagementCommand"),};let le_read_remote_features = match &le_connection_management_command.child {LeConnectionManagementCommandDataChild::LeReadRemoteFeatures(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadRemoteFeatures"),};Self {command,acl_command,le_connection_management_command,le_read_remote_features,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_read_remote_features.as_ref().connection_handle}
}
impl Into<CommandPacket> for LeReadRemoteFeaturesPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for LeReadRemoteFeaturesPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<LeConnectionManagementCommandPacket> for LeReadRemoteFeaturesPacket { fn into(self) -> LeConnectionManagementCommandPacket {LeConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for LeReadRemoteFeaturesBuilder { type ResponseType = LeReadRemoteFeaturesStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadRemoteFeaturesStatusPacket::new(pkt.event.clone()) }}impl LeReadRemoteFeaturesBuilder {pub fn build(self) -> LeReadRemoteFeaturesPacket {let le_read_remote_features= Arc::new(LeReadRemoteFeaturesData {connection_handle: self.connection_handle, });let le_connection_management_command= Arc::new(LeConnectionManagementCommandData {child: LeConnectionManagementCommandDataChild::LeReadRemoteFeatures(le_read_remote_features),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::LeConnectionManagementCommand(le_connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::LeReadRemoteFeatures, child: CommandDataChild::AclCommand(acl_command),});LeReadRemoteFeaturesPacket::new(command)}
}
impl Into<CommandPacket> for LeReadRemoteFeaturesBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for LeReadRemoteFeaturesBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<LeConnectionManagementCommandPacket> for LeReadRemoteFeaturesBuilder { fn into(self) -> LeConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeReadRemoteFeaturesStatusData {}
#[derive(Debug, Clone)] pub struct LeReadRemoteFeaturesStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,le_read_remote_features_status: Arc<LeReadRemoteFeaturesStatusData>,}
#[derive(Debug)] pub struct LeReadRemoteFeaturesStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl LeReadRemoteFeaturesStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeReadRemoteFeaturesStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadRemoteFeaturesStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let le_read_remote_features_status = match &command_status.child {CommandStatusDataChild::LeReadRemoteFeaturesStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadRemoteFeaturesStatus"),};Self {event,command_status,le_read_remote_features_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for LeReadRemoteFeaturesStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for LeReadRemoteFeaturesStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl LeReadRemoteFeaturesStatusBuilder {pub fn build(self) -> LeReadRemoteFeaturesStatusPacket {let le_read_remote_features_status= Arc::new(LeReadRemoteFeaturesStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeReadRemoteFeatures, child: CommandStatusDataChild::LeReadRemoteFeaturesStatus(le_read_remote_features_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});LeReadRemoteFeaturesStatusPacket::new(event)}
}
impl Into<EventPacket> for LeReadRemoteFeaturesStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for LeReadRemoteFeaturesStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct LeEncryptData {key: [u8; 16], plaintext_data: [u8; 16], }
#[derive(Debug, Clone)] pub struct LeEncryptPacket {command: Arc<CommandData>,le_security_command: Arc<LeSecurityCommandData>,le_encrypt: Arc<LeEncryptData>,}
#[derive(Debug)] pub struct LeEncryptBuilder {pub key: [u8; 16], pub plaintext_data: [u8; 16], }
impl LeEncryptData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 19 { return Err(Error::InvalidLengthError{    obj: "LeEncrypt".to_string(),    field: "key".to_string(),    wanted: 19,    got: bytes.len()});}let key = bytes[3..19].try_into().unwrap();if bytes.len() < 35 { return Err(Error::InvalidLengthError{    obj: "LeEncrypt".to_string(),    field: "plaintext_data".to_string(),    wanted: 35,    got: bytes.len()});}let plaintext_data = bytes[19..35].try_into().unwrap();Ok(Self {key, plaintext_data, })
}
fn write_to(&self, buffer: &mut BytesMut) {&buffer[3..19].copy_from_slice(&self.key);&buffer[19..35].copy_from_slice(&self.plaintext_data);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 32;ret}
}
impl CommandExpectations for LeEncryptPacket { type ResponseType = LeEncryptCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeEncryptCompletePacket::new(pkt.event.clone()) }}impl Packet for LeEncryptPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeEncryptPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_security_command = match &command.child {CommandDataChild::LeSecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSecurityCommand"),};let le_encrypt = match &le_security_command.child {LeSecurityCommandDataChild::LeEncrypt(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeEncrypt"),};Self {command,le_security_command,le_encrypt,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_key(&self) -> &[u8; 16]{ &self.le_encrypt.as_ref().key}
pub fn get_plaintext_data(&self) -> &[u8; 16]{ &self.le_encrypt.as_ref().plaintext_data}
}
impl Into<CommandPacket> for LeEncryptPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeSecurityCommandPacket> for LeEncryptPacket { fn into(self) -> LeSecurityCommandPacket {LeSecurityCommandPacket::new(self.command) }}
impl CommandExpectations for LeEncryptBuilder { type ResponseType = LeEncryptCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeEncryptCompletePacket::new(pkt.event.clone()) }}impl LeEncryptBuilder {pub fn build(self) -> LeEncryptPacket {let le_encrypt= Arc::new(LeEncryptData {key: self.key, plaintext_data: self.plaintext_data, });let le_security_command= Arc::new(LeSecurityCommandData {child: LeSecurityCommandDataChild::LeEncrypt(le_encrypt),});let command= Arc::new(CommandData {op_code: OpCode::LeEncrypt, child: CommandDataChild::LeSecurityCommand(le_security_command),});LeEncryptPacket::new(command)}
}
impl Into<CommandPacket> for LeEncryptBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeSecurityCommandPacket> for LeEncryptBuilder { fn into(self) -> LeSecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeEncryptCompleteData {status: ErrorCode, encrypted_data: [u8; 16], }
#[derive(Debug, Clone)] pub struct LeEncryptCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_encrypt_complete: Arc<LeEncryptCompleteData>,}
#[derive(Debug)] pub struct LeEncryptCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub encrypted_data: [u8; 16], }
impl LeEncryptCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeEncryptComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 22 { return Err(Error::InvalidLengthError{    obj: "LeEncryptComplete".to_string(),    field: "encrypted_data".to_string(),    wanted: 22,    got: bytes.len()});}let encrypted_data = bytes[6..22].try_into().unwrap();Ok(Self {status, encrypted_data, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);&buffer[6..22].copy_from_slice(&self.encrypted_data);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 17;ret}
}
impl Packet for LeEncryptCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeEncryptCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_encrypt_complete = match &command_complete.child {CommandCompleteDataChild::LeEncryptComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeEncryptComplete"),};Self {event,command_complete,le_encrypt_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_encrypt_complete.as_ref().status}
pub fn get_encrypted_data(&self) -> &[u8; 16]{ &self.le_encrypt_complete.as_ref().encrypted_data}
}
impl Into<EventPacket> for LeEncryptCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeEncryptCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeEncryptCompleteBuilder {pub fn build(self) -> LeEncryptCompletePacket {let le_encrypt_complete= Arc::new(LeEncryptCompleteData {status: self.status, encrypted_data: self.encrypted_data, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeEncrypt, child: CommandCompleteDataChild::LeEncryptComplete(le_encrypt_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeEncryptCompletePacket::new(event)}
}
impl Into<EventPacket> for LeEncryptCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeEncryptCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeRandData {}
#[derive(Debug, Clone)] pub struct LeRandPacket {command: Arc<CommandData>,le_security_command: Arc<LeSecurityCommandData>,le_rand: Arc<LeRandData>,}
#[derive(Debug)] pub struct LeRandBuilder {}
impl LeRandData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeRandPacket { type ResponseType = LeRandCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeRandCompletePacket::new(pkt.event.clone()) }}impl Packet for LeRandPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeRandPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_security_command = match &command.child {CommandDataChild::LeSecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSecurityCommand"),};let le_rand = match &le_security_command.child {LeSecurityCommandDataChild::LeRand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeRand"),};Self {command,le_security_command,le_rand,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeRandPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeSecurityCommandPacket> for LeRandPacket { fn into(self) -> LeSecurityCommandPacket {LeSecurityCommandPacket::new(self.command) }}
impl CommandExpectations for LeRandBuilder { type ResponseType = LeRandCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeRandCompletePacket::new(pkt.event.clone()) }}impl LeRandBuilder {pub fn build(self) -> LeRandPacket {let le_rand= Arc::new(LeRandData {});let le_security_command= Arc::new(LeSecurityCommandData {child: LeSecurityCommandDataChild::LeRand(le_rand),});let command= Arc::new(CommandData {op_code: OpCode::LeRand, child: CommandDataChild::LeSecurityCommand(le_security_command),});LeRandPacket::new(command)}
}
impl Into<CommandPacket> for LeRandBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeSecurityCommandPacket> for LeRandBuilder { fn into(self) -> LeSecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeRandCompleteData {status: ErrorCode, random_number: u64, }
#[derive(Debug, Clone)] pub struct LeRandCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_rand_complete: Arc<LeRandCompleteData>,}
#[derive(Debug)] pub struct LeRandCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub random_number: u64, }
impl LeRandCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeRandComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "LeRandComplete".to_string(),    field: "random_number".to_string(),    wanted: 14,    got: bytes.len()});}let random_number = u64::from_le_bytes([bytes[6],bytes[7],bytes[8],bytes[9],bytes[10],bytes[11],bytes[12],bytes[13]]);Ok(Self {status, random_number, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let random_number = self.random_number;buffer[6..14].copy_from_slice(&random_number.to_le_bytes()[0..8]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 9;ret}
}
impl Packet for LeRandCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeRandCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_rand_complete = match &command_complete.child {CommandCompleteDataChild::LeRandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeRandComplete"),};Self {event,command_complete,le_rand_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_rand_complete.as_ref().status}
pub fn get_random_number(&self) -> u64{ self.le_rand_complete.as_ref().random_number}
}
impl Into<EventPacket> for LeRandCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeRandCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeRandCompleteBuilder {pub fn build(self) -> LeRandCompletePacket {let le_rand_complete= Arc::new(LeRandCompleteData {status: self.status, random_number: self.random_number, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeRand, child: CommandCompleteDataChild::LeRandComplete(le_rand_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeRandCompletePacket::new(event)}
}
impl Into<EventPacket> for LeRandCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeRandCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeStartEncryptionData {connection_handle: u16, rand: [u8; 8], ediv: u16, ltk: [u8; 16], }
#[derive(Debug, Clone)] pub struct LeStartEncryptionPacket {command: Arc<CommandData>,le_security_command: Arc<LeSecurityCommandData>,le_start_encryption: Arc<LeStartEncryptionData>,}
#[derive(Debug)] pub struct LeStartEncryptionBuilder {pub connection_handle: u16, pub rand: [u8; 8], pub ediv: u16, pub ltk: [u8; 16], }
impl LeStartEncryptionData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeStartEncryption".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "LeStartEncryption".to_string(),    field: "rand".to_string(),    wanted: 13,    got: bytes.len()});}let rand = bytes[5..13].try_into().unwrap();if bytes.len() < 15 { return Err(Error::InvalidLengthError{    obj: "LeStartEncryption".to_string(),    field: "ediv".to_string(),    wanted: 15,    got: bytes.len()});}let ediv = u16::from_le_bytes([bytes[13],bytes[14]]);if bytes.len() < 31 { return Err(Error::InvalidLengthError{    obj: "LeStartEncryption".to_string(),    field: "ltk".to_string(),    wanted: 31,    got: bytes.len()});}let ltk = bytes[15..31].try_into().unwrap();Ok(Self {connection_handle, rand, ediv, ltk, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);&buffer[5..13].copy_from_slice(&self.rand);let ediv = self.ediv;buffer[13..15].copy_from_slice(&ediv.to_le_bytes()[0..2]);&buffer[15..31].copy_from_slice(&self.ltk);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 28;ret}
}
impl CommandExpectations for LeStartEncryptionPacket { type ResponseType = LeStartEncryptionStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeStartEncryptionStatusPacket::new(pkt.event.clone()) }}impl Packet for LeStartEncryptionPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeStartEncryptionPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_security_command = match &command.child {CommandDataChild::LeSecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSecurityCommand"),};let le_start_encryption = match &le_security_command.child {LeSecurityCommandDataChild::LeStartEncryption(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeStartEncryption"),};Self {command,le_security_command,le_start_encryption,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_start_encryption.as_ref().connection_handle}
pub fn get_rand(&self) -> &[u8; 8]{ &self.le_start_encryption.as_ref().rand}
pub fn get_ediv(&self) -> u16{ self.le_start_encryption.as_ref().ediv}
pub fn get_ltk(&self) -> &[u8; 16]{ &self.le_start_encryption.as_ref().ltk}
}
impl Into<CommandPacket> for LeStartEncryptionPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeSecurityCommandPacket> for LeStartEncryptionPacket { fn into(self) -> LeSecurityCommandPacket {LeSecurityCommandPacket::new(self.command) }}
impl CommandExpectations for LeStartEncryptionBuilder { type ResponseType = LeStartEncryptionStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeStartEncryptionStatusPacket::new(pkt.event.clone()) }}impl LeStartEncryptionBuilder {pub fn build(self) -> LeStartEncryptionPacket {let le_start_encryption= Arc::new(LeStartEncryptionData {connection_handle: self.connection_handle, rand: self.rand, ediv: self.ediv, ltk: self.ltk, });let le_security_command= Arc::new(LeSecurityCommandData {child: LeSecurityCommandDataChild::LeStartEncryption(le_start_encryption),});let command= Arc::new(CommandData {op_code: OpCode::LeStartEncryption, child: CommandDataChild::LeSecurityCommand(le_security_command),});LeStartEncryptionPacket::new(command)}
}
impl Into<CommandPacket> for LeStartEncryptionBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeSecurityCommandPacket> for LeStartEncryptionBuilder { fn into(self) -> LeSecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeStartEncryptionStatusData {}
#[derive(Debug, Clone)] pub struct LeStartEncryptionStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,le_start_encryption_status: Arc<LeStartEncryptionStatusData>,}
#[derive(Debug)] pub struct LeStartEncryptionStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl LeStartEncryptionStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeStartEncryptionStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeStartEncryptionStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let le_start_encryption_status = match &command_status.child {CommandStatusDataChild::LeStartEncryptionStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeStartEncryptionStatus"),};Self {event,command_status,le_start_encryption_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for LeStartEncryptionStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for LeStartEncryptionStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl LeStartEncryptionStatusBuilder {pub fn build(self) -> LeStartEncryptionStatusPacket {let le_start_encryption_status= Arc::new(LeStartEncryptionStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeStartEncryption, child: CommandStatusDataChild::LeStartEncryptionStatus(le_start_encryption_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});LeStartEncryptionStatusPacket::new(event)}
}
impl Into<EventPacket> for LeStartEncryptionStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for LeStartEncryptionStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct LeLongTermKeyRequestReplyData {connection_handle: u16, long_term_key: [u8; 16], }
#[derive(Debug, Clone)] pub struct LeLongTermKeyRequestReplyPacket {command: Arc<CommandData>,le_security_command: Arc<LeSecurityCommandData>,le_long_term_key_request_reply: Arc<LeLongTermKeyRequestReplyData>,}
#[derive(Debug)] pub struct LeLongTermKeyRequestReplyBuilder {pub connection_handle: u16, pub long_term_key: [u8; 16], }
impl LeLongTermKeyRequestReplyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeLongTermKeyRequestReply".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);if bytes.len() < 21 { return Err(Error::InvalidLengthError{    obj: "LeLongTermKeyRequestReply".to_string(),    field: "long_term_key".to_string(),    wanted: 21,    got: bytes.len()});}let long_term_key = bytes[5..21].try_into().unwrap();Ok(Self {connection_handle, long_term_key, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);&buffer[5..21].copy_from_slice(&self.long_term_key);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 18;ret}
}
impl CommandExpectations for LeLongTermKeyRequestReplyPacket { type ResponseType = LeLongTermKeyRequestReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeLongTermKeyRequestReplyCompletePacket::new(pkt.event.clone()) }}impl Packet for LeLongTermKeyRequestReplyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeLongTermKeyRequestReplyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_security_command = match &command.child {CommandDataChild::LeSecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSecurityCommand"),};let le_long_term_key_request_reply = match &le_security_command.child {LeSecurityCommandDataChild::LeLongTermKeyRequestReply(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeLongTermKeyRequestReply"),};Self {command,le_security_command,le_long_term_key_request_reply,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_long_term_key_request_reply.as_ref().connection_handle}
pub fn get_long_term_key(&self) -> &[u8; 16]{ &self.le_long_term_key_request_reply.as_ref().long_term_key}
}
impl Into<CommandPacket> for LeLongTermKeyRequestReplyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeSecurityCommandPacket> for LeLongTermKeyRequestReplyPacket { fn into(self) -> LeSecurityCommandPacket {LeSecurityCommandPacket::new(self.command) }}
impl CommandExpectations for LeLongTermKeyRequestReplyBuilder { type ResponseType = LeLongTermKeyRequestReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeLongTermKeyRequestReplyCompletePacket::new(pkt.event.clone()) }}impl LeLongTermKeyRequestReplyBuilder {pub fn build(self) -> LeLongTermKeyRequestReplyPacket {let le_long_term_key_request_reply= Arc::new(LeLongTermKeyRequestReplyData {connection_handle: self.connection_handle, long_term_key: self.long_term_key, });let le_security_command= Arc::new(LeSecurityCommandData {child: LeSecurityCommandDataChild::LeLongTermKeyRequestReply(le_long_term_key_request_reply),});let command= Arc::new(CommandData {op_code: OpCode::LeLongTermKeyRequestReply, child: CommandDataChild::LeSecurityCommand(le_security_command),});LeLongTermKeyRequestReplyPacket::new(command)}
}
impl Into<CommandPacket> for LeLongTermKeyRequestReplyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeSecurityCommandPacket> for LeLongTermKeyRequestReplyBuilder { fn into(self) -> LeSecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeLongTermKeyRequestReplyCompleteData {status: ErrorCode, connection_handle: u16, }
#[derive(Debug, Clone)] pub struct LeLongTermKeyRequestReplyCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_long_term_key_request_reply_complete: Arc<LeLongTermKeyRequestReplyCompleteData>,}
#[derive(Debug)] pub struct LeLongTermKeyRequestReplyCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, }
impl LeLongTermKeyRequestReplyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeLongTermKeyRequestReplyComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeLongTermKeyRequestReplyComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;Ok(Self {status, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for LeLongTermKeyRequestReplyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeLongTermKeyRequestReplyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_long_term_key_request_reply_complete = match &command_complete.child {CommandCompleteDataChild::LeLongTermKeyRequestReplyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeLongTermKeyRequestReplyComplete"),};Self {event,command_complete,le_long_term_key_request_reply_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_long_term_key_request_reply_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_long_term_key_request_reply_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for LeLongTermKeyRequestReplyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeLongTermKeyRequestReplyCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeLongTermKeyRequestReplyCompleteBuilder {pub fn build(self) -> LeLongTermKeyRequestReplyCompletePacket {let le_long_term_key_request_reply_complete= Arc::new(LeLongTermKeyRequestReplyCompleteData {status: self.status, connection_handle: self.connection_handle, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeLongTermKeyRequestReply, child: CommandCompleteDataChild::LeLongTermKeyRequestReplyComplete(le_long_term_key_request_reply_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeLongTermKeyRequestReplyCompletePacket::new(event)}
}
impl Into<EventPacket> for LeLongTermKeyRequestReplyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeLongTermKeyRequestReplyCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeLongTermKeyRequestNegativeReplyData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct LeLongTermKeyRequestNegativeReplyPacket {command: Arc<CommandData>,le_security_command: Arc<LeSecurityCommandData>,le_long_term_key_request_negative_reply: Arc<LeLongTermKeyRequestNegativeReplyData>,}
#[derive(Debug)] pub struct LeLongTermKeyRequestNegativeReplyBuilder {pub connection_handle: u16, }
impl LeLongTermKeyRequestNegativeReplyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeLongTermKeyRequestNegativeReply".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for LeLongTermKeyRequestNegativeReplyPacket { type ResponseType = LeLongTermKeyRequestNegativeReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeLongTermKeyRequestNegativeReplyCompletePacket::new(pkt.event.clone()) }}impl Packet for LeLongTermKeyRequestNegativeReplyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeLongTermKeyRequestNegativeReplyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_security_command = match &command.child {CommandDataChild::LeSecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSecurityCommand"),};let le_long_term_key_request_negative_reply = match &le_security_command.child {LeSecurityCommandDataChild::LeLongTermKeyRequestNegativeReply(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeLongTermKeyRequestNegativeReply"),};Self {command,le_security_command,le_long_term_key_request_negative_reply,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_long_term_key_request_negative_reply.as_ref().connection_handle}
}
impl Into<CommandPacket> for LeLongTermKeyRequestNegativeReplyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeSecurityCommandPacket> for LeLongTermKeyRequestNegativeReplyPacket { fn into(self) -> LeSecurityCommandPacket {LeSecurityCommandPacket::new(self.command) }}
impl CommandExpectations for LeLongTermKeyRequestNegativeReplyBuilder { type ResponseType = LeLongTermKeyRequestNegativeReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeLongTermKeyRequestNegativeReplyCompletePacket::new(pkt.event.clone()) }}impl LeLongTermKeyRequestNegativeReplyBuilder {pub fn build(self) -> LeLongTermKeyRequestNegativeReplyPacket {let le_long_term_key_request_negative_reply= Arc::new(LeLongTermKeyRequestNegativeReplyData {connection_handle: self.connection_handle, });let le_security_command= Arc::new(LeSecurityCommandData {child: LeSecurityCommandDataChild::LeLongTermKeyRequestNegativeReply(le_long_term_key_request_negative_reply),});let command= Arc::new(CommandData {op_code: OpCode::LeLongTermKeyRequestNegativeReply, child: CommandDataChild::LeSecurityCommand(le_security_command),});LeLongTermKeyRequestNegativeReplyPacket::new(command)}
}
impl Into<CommandPacket> for LeLongTermKeyRequestNegativeReplyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeSecurityCommandPacket> for LeLongTermKeyRequestNegativeReplyBuilder { fn into(self) -> LeSecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeLongTermKeyRequestNegativeReplyCompleteData {status: ErrorCode, connection_handle: u16, }
#[derive(Debug, Clone)] pub struct LeLongTermKeyRequestNegativeReplyCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_long_term_key_request_negative_reply_complete: Arc<LeLongTermKeyRequestNegativeReplyCompleteData>,}
#[derive(Debug)] pub struct LeLongTermKeyRequestNegativeReplyCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, }
impl LeLongTermKeyRequestNegativeReplyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeLongTermKeyRequestNegativeReplyComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeLongTermKeyRequestNegativeReplyComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;Ok(Self {status, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for LeLongTermKeyRequestNegativeReplyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeLongTermKeyRequestNegativeReplyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_long_term_key_request_negative_reply_complete = match &command_complete.child {CommandCompleteDataChild::LeLongTermKeyRequestNegativeReplyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeLongTermKeyRequestNegativeReplyComplete"),};Self {event,command_complete,le_long_term_key_request_negative_reply_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_long_term_key_request_negative_reply_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_long_term_key_request_negative_reply_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for LeLongTermKeyRequestNegativeReplyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeLongTermKeyRequestNegativeReplyCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeLongTermKeyRequestNegativeReplyCompleteBuilder {pub fn build(self) -> LeLongTermKeyRequestNegativeReplyCompletePacket {let le_long_term_key_request_negative_reply_complete= Arc::new(LeLongTermKeyRequestNegativeReplyCompleteData {status: self.status, connection_handle: self.connection_handle, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeLongTermKeyRequestNegativeReply, child: CommandCompleteDataChild::LeLongTermKeyRequestNegativeReplyComplete(le_long_term_key_request_negative_reply_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeLongTermKeyRequestNegativeReplyCompletePacket::new(event)}
}
impl Into<EventPacket> for LeLongTermKeyRequestNegativeReplyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeLongTermKeyRequestNegativeReplyCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeReadSupportedStatesData {}
#[derive(Debug, Clone)] pub struct LeReadSupportedStatesPacket {command: Arc<CommandData>,le_read_supported_states: Arc<LeReadSupportedStatesData>,}
#[derive(Debug)] pub struct LeReadSupportedStatesBuilder {}
impl LeReadSupportedStatesData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeReadSupportedStatesPacket { type ResponseType = LeReadSupportedStatesCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadSupportedStatesCompletePacket::new(pkt.event.clone()) }}impl Packet for LeReadSupportedStatesPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadSupportedStatesPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_read_supported_states = match &command.child {CommandDataChild::LeReadSupportedStates(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadSupportedStates"),};Self {command,le_read_supported_states,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeReadSupportedStatesPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeReadSupportedStatesBuilder { type ResponseType = LeReadSupportedStatesCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadSupportedStatesCompletePacket::new(pkt.event.clone()) }}impl LeReadSupportedStatesBuilder {pub fn build(self) -> LeReadSupportedStatesPacket {let le_read_supported_states= Arc::new(LeReadSupportedStatesData {});let command= Arc::new(CommandData {op_code: OpCode::LeReadSupportedStates, child: CommandDataChild::LeReadSupportedStates(le_read_supported_states),});LeReadSupportedStatesPacket::new(command)}
}
impl Into<CommandPacket> for LeReadSupportedStatesBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LeReadSupportedStatesCompleteData {status: ErrorCode, le_states: u64, }
#[derive(Debug, Clone)] pub struct LeReadSupportedStatesCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_read_supported_states_complete: Arc<LeReadSupportedStatesCompleteData>,}
#[derive(Debug)] pub struct LeReadSupportedStatesCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub le_states: u64, }
impl LeReadSupportedStatesCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeReadSupportedStatesComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "LeReadSupportedStatesComplete".to_string(),    field: "le_states".to_string(),    wanted: 14,    got: bytes.len()});}let le_states = u64::from_le_bytes([bytes[6],bytes[7],bytes[8],bytes[9],bytes[10],bytes[11],bytes[12],bytes[13]]);Ok(Self {status, le_states, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let le_states = self.le_states;buffer[6..14].copy_from_slice(&le_states.to_le_bytes()[0..8]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 9;ret}
}
impl Packet for LeReadSupportedStatesCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadSupportedStatesCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_read_supported_states_complete = match &command_complete.child {CommandCompleteDataChild::LeReadSupportedStatesComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadSupportedStatesComplete"),};Self {event,command_complete,le_read_supported_states_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_read_supported_states_complete.as_ref().status}
pub fn get_le_states(&self) -> u64{ self.le_read_supported_states_complete.as_ref().le_states}
}
impl Into<EventPacket> for LeReadSupportedStatesCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeReadSupportedStatesCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeReadSupportedStatesCompleteBuilder {pub fn build(self) -> LeReadSupportedStatesCompletePacket {let le_read_supported_states_complete= Arc::new(LeReadSupportedStatesCompleteData {status: self.status, le_states: self.le_states, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeReadSupportedStates, child: CommandCompleteDataChild::LeReadSupportedStatesComplete(le_read_supported_states_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeReadSupportedStatesCompletePacket::new(event)}
}
impl Into<EventPacket> for LeReadSupportedStatesCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeReadSupportedStatesCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeReceiverTestData {rx_channel: u8, }
#[derive(Debug, Clone)] pub struct LeReceiverTestPacket {command: Arc<CommandData>,le_receiver_test: Arc<LeReceiverTestData>,}
#[derive(Debug)] pub struct LeReceiverTestBuilder {pub rx_channel: u8, }
impl LeReceiverTestData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeReceiverTest".to_string(),    field: "rx_channel".to_string(),    wanted: 4,    got: bytes.len()});}let rx_channel = u8::from_le_bytes([bytes[3]]);Ok(Self {rx_channel, })
}
fn write_to(&self, buffer: &mut BytesMut) {let rx_channel = self.rx_channel;buffer[3..4].copy_from_slice(&rx_channel.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for LeReceiverTestPacket { type ResponseType = LeReceiverTestCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReceiverTestCompletePacket::new(pkt.event.clone()) }}impl Packet for LeReceiverTestPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReceiverTestPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_receiver_test = match &command.child {CommandDataChild::LeReceiverTest(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReceiverTest"),};Self {command,le_receiver_test,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_rx_channel(&self) -> u8{ self.le_receiver_test.as_ref().rx_channel}
}
impl Into<CommandPacket> for LeReceiverTestPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeReceiverTestBuilder { type ResponseType = LeReceiverTestCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReceiverTestCompletePacket::new(pkt.event.clone()) }}impl LeReceiverTestBuilder {pub fn build(self) -> LeReceiverTestPacket {let le_receiver_test= Arc::new(LeReceiverTestData {rx_channel: self.rx_channel, });let command= Arc::new(CommandData {op_code: OpCode::LeReceiverTest, child: CommandDataChild::LeReceiverTest(le_receiver_test),});LeReceiverTestPacket::new(command)}
}
impl Into<CommandPacket> for LeReceiverTestBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LeReceiverTestCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeReceiverTestCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_receiver_test_complete: Arc<LeReceiverTestCompleteData>,}
#[derive(Debug)] pub struct LeReceiverTestCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeReceiverTestCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeReceiverTestComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeReceiverTestCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReceiverTestCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_receiver_test_complete = match &command_complete.child {CommandCompleteDataChild::LeReceiverTestComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReceiverTestComplete"),};Self {event,command_complete,le_receiver_test_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_receiver_test_complete.as_ref().status}
}
impl Into<EventPacket> for LeReceiverTestCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeReceiverTestCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeReceiverTestCompleteBuilder {pub fn build(self) -> LeReceiverTestCompletePacket {let le_receiver_test_complete= Arc::new(LeReceiverTestCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeReceiverTest, child: CommandCompleteDataChild::LeReceiverTestComplete(le_receiver_test_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeReceiverTestCompletePacket::new(event)}
}
impl Into<EventPacket> for LeReceiverTestCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeReceiverTestCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeTransmitterTestData {tx_channel: u8, test_data_length: u8, packet_payload: LeTestPayload, }
#[derive(Debug, Clone)] pub struct LeTransmitterTestPacket {command: Arc<CommandData>,le_transmitter_test: Arc<LeTransmitterTestData>,}
#[derive(Debug)] pub struct LeTransmitterTestBuilder {pub tx_channel: u8, pub test_data_length: u8, pub packet_payload: LeTestPayload, }
impl LeTransmitterTestData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeTransmitterTest".to_string(),    field: "tx_channel".to_string(),    wanted: 4,    got: bytes.len()});}let tx_channel = u8::from_le_bytes([bytes[3]]);if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeTransmitterTest".to_string(),    field: "test_data_length".to_string(),    wanted: 5,    got: bytes.len()});}let test_data_length = u8::from_le_bytes([bytes[4]]);if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeTransmitterTest".to_string(),    field: "packet_payload".to_string(),    wanted: 6,    got: bytes.len()});}let packet_payload = u8::from_le_bytes([bytes[5]]);let packet_payload = LeTestPayload::from_u8(packet_payload).unwrap();Ok(Self {tx_channel, test_data_length, packet_payload, })
}
fn write_to(&self, buffer: &mut BytesMut) {let tx_channel = self.tx_channel;buffer[3..4].copy_from_slice(&tx_channel.to_le_bytes()[0..1]);let test_data_length = self.test_data_length;buffer[4..5].copy_from_slice(&test_data_length.to_le_bytes()[0..1]);let packet_payload = self.packet_payload.to_u8().unwrap();buffer[5..6].copy_from_slice(&packet_payload.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl CommandExpectations for LeTransmitterTestPacket { type ResponseType = LeTransmitterTestCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeTransmitterTestCompletePacket::new(pkt.event.clone()) }}impl Packet for LeTransmitterTestPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeTransmitterTestPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_transmitter_test = match &command.child {CommandDataChild::LeTransmitterTest(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeTransmitterTest"),};Self {command,le_transmitter_test,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_tx_channel(&self) -> u8{ self.le_transmitter_test.as_ref().tx_channel}
pub fn get_test_data_length(&self) -> u8{ self.le_transmitter_test.as_ref().test_data_length}
pub fn get_packet_payload(&self) -> LeTestPayload{ self.le_transmitter_test.as_ref().packet_payload}
}
impl Into<CommandPacket> for LeTransmitterTestPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeTransmitterTestBuilder { type ResponseType = LeTransmitterTestCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeTransmitterTestCompletePacket::new(pkt.event.clone()) }}impl LeTransmitterTestBuilder {pub fn build(self) -> LeTransmitterTestPacket {let le_transmitter_test= Arc::new(LeTransmitterTestData {tx_channel: self.tx_channel, test_data_length: self.test_data_length, packet_payload: self.packet_payload, });let command= Arc::new(CommandData {op_code: OpCode::LeTransmitterTest, child: CommandDataChild::LeTransmitterTest(le_transmitter_test),});LeTransmitterTestPacket::new(command)}
}
impl Into<CommandPacket> for LeTransmitterTestBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LeTransmitterTestCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeTransmitterTestCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_transmitter_test_complete: Arc<LeTransmitterTestCompleteData>,}
#[derive(Debug)] pub struct LeTransmitterTestCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeTransmitterTestCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeTransmitterTestComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeTransmitterTestCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeTransmitterTestCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_transmitter_test_complete = match &command_complete.child {CommandCompleteDataChild::LeTransmitterTestComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeTransmitterTestComplete"),};Self {event,command_complete,le_transmitter_test_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_transmitter_test_complete.as_ref().status}
}
impl Into<EventPacket> for LeTransmitterTestCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeTransmitterTestCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeTransmitterTestCompleteBuilder {pub fn build(self) -> LeTransmitterTestCompletePacket {let le_transmitter_test_complete= Arc::new(LeTransmitterTestCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeTransmitterTest, child: CommandCompleteDataChild::LeTransmitterTestComplete(le_transmitter_test_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeTransmitterTestCompletePacket::new(event)}
}
impl Into<EventPacket> for LeTransmitterTestCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeTransmitterTestCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeTestEndData {}
#[derive(Debug, Clone)] pub struct LeTestEndPacket {command: Arc<CommandData>,le_test_end: Arc<LeTestEndData>,}
#[derive(Debug)] pub struct LeTestEndBuilder {}
impl LeTestEndData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeTestEndPacket { type ResponseType = LeTestEndCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeTestEndCompletePacket::new(pkt.event.clone()) }}impl Packet for LeTestEndPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeTestEndPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_test_end = match &command.child {CommandDataChild::LeTestEnd(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeTestEnd"),};Self {command,le_test_end,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeTestEndPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeTestEndBuilder { type ResponseType = LeTestEndCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeTestEndCompletePacket::new(pkt.event.clone()) }}impl LeTestEndBuilder {pub fn build(self) -> LeTestEndPacket {let le_test_end= Arc::new(LeTestEndData {});let command= Arc::new(CommandData {op_code: OpCode::LeTestEnd, child: CommandDataChild::LeTestEnd(le_test_end),});LeTestEndPacket::new(command)}
}
impl Into<CommandPacket> for LeTestEndBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LeTestEndCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeTestEndCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_test_end_complete: Arc<LeTestEndCompleteData>,}
#[derive(Debug)] pub struct LeTestEndCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeTestEndCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeTestEndComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeTestEndCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeTestEndCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_test_end_complete = match &command_complete.child {CommandCompleteDataChild::LeTestEndComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeTestEndComplete"),};Self {event,command_complete,le_test_end_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_test_end_complete.as_ref().status}
}
impl Into<EventPacket> for LeTestEndCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeTestEndCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeTestEndCompleteBuilder {pub fn build(self) -> LeTestEndCompletePacket {let le_test_end_complete= Arc::new(LeTestEndCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeTestEnd, child: CommandCompleteDataChild::LeTestEndComplete(le_test_end_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeTestEndCompletePacket::new(event)}
}
impl Into<EventPacket> for LeTestEndCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeTestEndCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeRemoteConnectionParameterRequestReplyData {connection_handle: u16, interval_min: u16, interval_max: u16, latency: u16, timeout: u16, minimum_ce_length: u16, maximum_ce_length: u16, }
#[derive(Debug, Clone)] pub struct LeRemoteConnectionParameterRequestReplyPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,le_connection_management_command: Arc<LeConnectionManagementCommandData>,le_remote_connection_parameter_request_reply: Arc<LeRemoteConnectionParameterRequestReplyData>,}
#[derive(Debug)] pub struct LeRemoteConnectionParameterRequestReplyBuilder {pub connection_handle: u16, pub interval_min: u16, pub interval_max: u16, pub latency: u16, pub timeout: u16, pub minimum_ce_length: u16, pub maximum_ce_length: u16, }
impl LeRemoteConnectionParameterRequestReplyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeRemoteConnectionParameterRequestReply".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeRemoteConnectionParameterRequestReply".to_string(),    field: "interval_min".to_string(),    wanted: 7,    got: bytes.len()});}let interval_min = u16::from_le_bytes([bytes[5],bytes[6]]);if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeRemoteConnectionParameterRequestReply".to_string(),    field: "interval_max".to_string(),    wanted: 9,    got: bytes.len()});}let interval_max = u16::from_le_bytes([bytes[7],bytes[8]]);if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "LeRemoteConnectionParameterRequestReply".to_string(),    field: "latency".to_string(),    wanted: 11,    got: bytes.len()});}let latency = u16::from_le_bytes([bytes[9],bytes[10]]);if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "LeRemoteConnectionParameterRequestReply".to_string(),    field: "timeout".to_string(),    wanted: 13,    got: bytes.len()});}let timeout = u16::from_le_bytes([bytes[11],bytes[12]]);if bytes.len() < 15 { return Err(Error::InvalidLengthError{    obj: "LeRemoteConnectionParameterRequestReply".to_string(),    field: "minimum_ce_length".to_string(),    wanted: 15,    got: bytes.len()});}let minimum_ce_length = u16::from_le_bytes([bytes[13],bytes[14]]);if bytes.len() < 17 { return Err(Error::InvalidLengthError{    obj: "LeRemoteConnectionParameterRequestReply".to_string(),    field: "maximum_ce_length".to_string(),    wanted: 17,    got: bytes.len()});}let maximum_ce_length = u16::from_le_bytes([bytes[15],bytes[16]]);Ok(Self {connection_handle, interval_min, interval_max, latency, timeout, minimum_ce_length, maximum_ce_length, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let interval_min = self.interval_min;buffer[5..7].copy_from_slice(&interval_min.to_le_bytes()[0..2]);let interval_max = self.interval_max;buffer[7..9].copy_from_slice(&interval_max.to_le_bytes()[0..2]);let latency = self.latency;buffer[9..11].copy_from_slice(&latency.to_le_bytes()[0..2]);let timeout = self.timeout;buffer[11..13].copy_from_slice(&timeout.to_le_bytes()[0..2]);let minimum_ce_length = self.minimum_ce_length;buffer[13..15].copy_from_slice(&minimum_ce_length.to_le_bytes()[0..2]);let maximum_ce_length = self.maximum_ce_length;buffer[15..17].copy_from_slice(&maximum_ce_length.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 14;ret}
}
impl CommandExpectations for LeRemoteConnectionParameterRequestReplyPacket { type ResponseType = LeRemoteConnectionParameterRequestReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeRemoteConnectionParameterRequestReplyCompletePacket::new(pkt.event.clone()) }}impl Packet for LeRemoteConnectionParameterRequestReplyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeRemoteConnectionParameterRequestReplyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let le_connection_management_command = match &acl_command.child {AclCommandDataChild::LeConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeConnectionManagementCommand"),};let le_remote_connection_parameter_request_reply = match &le_connection_management_command.child {LeConnectionManagementCommandDataChild::LeRemoteConnectionParameterRequestReply(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeRemoteConnectionParameterRequestReply"),};Self {command,acl_command,le_connection_management_command,le_remote_connection_parameter_request_reply,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_remote_connection_parameter_request_reply.as_ref().connection_handle}
pub fn get_interval_min(&self) -> u16{ self.le_remote_connection_parameter_request_reply.as_ref().interval_min}
pub fn get_interval_max(&self) -> u16{ self.le_remote_connection_parameter_request_reply.as_ref().interval_max}
pub fn get_latency(&self) -> u16{ self.le_remote_connection_parameter_request_reply.as_ref().latency}
pub fn get_timeout(&self) -> u16{ self.le_remote_connection_parameter_request_reply.as_ref().timeout}
pub fn get_minimum_ce_length(&self) -> u16{ self.le_remote_connection_parameter_request_reply.as_ref().minimum_ce_length}
pub fn get_maximum_ce_length(&self) -> u16{ self.le_remote_connection_parameter_request_reply.as_ref().maximum_ce_length}
}
impl Into<CommandPacket> for LeRemoteConnectionParameterRequestReplyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for LeRemoteConnectionParameterRequestReplyPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<LeConnectionManagementCommandPacket> for LeRemoteConnectionParameterRequestReplyPacket { fn into(self) -> LeConnectionManagementCommandPacket {LeConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for LeRemoteConnectionParameterRequestReplyBuilder { type ResponseType = LeRemoteConnectionParameterRequestReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeRemoteConnectionParameterRequestReplyCompletePacket::new(pkt.event.clone()) }}impl LeRemoteConnectionParameterRequestReplyBuilder {pub fn build(self) -> LeRemoteConnectionParameterRequestReplyPacket {let le_remote_connection_parameter_request_reply= Arc::new(LeRemoteConnectionParameterRequestReplyData {connection_handle: self.connection_handle, interval_min: self.interval_min, interval_max: self.interval_max, latency: self.latency, timeout: self.timeout, minimum_ce_length: self.minimum_ce_length, maximum_ce_length: self.maximum_ce_length, });let le_connection_management_command= Arc::new(LeConnectionManagementCommandData {child: LeConnectionManagementCommandDataChild::LeRemoteConnectionParameterRequestReply(le_remote_connection_parameter_request_reply),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::LeConnectionManagementCommand(le_connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::LeRemoteConnectionParameterRequestReply, child: CommandDataChild::AclCommand(acl_command),});LeRemoteConnectionParameterRequestReplyPacket::new(command)}
}
impl Into<CommandPacket> for LeRemoteConnectionParameterRequestReplyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for LeRemoteConnectionParameterRequestReplyBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<LeConnectionManagementCommandPacket> for LeRemoteConnectionParameterRequestReplyBuilder { fn into(self) -> LeConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeRemoteConnectionParameterRequestReplyCompleteData {status: ErrorCode, connection_handle: u16, }
#[derive(Debug, Clone)] pub struct LeRemoteConnectionParameterRequestReplyCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_remote_connection_parameter_request_reply_complete: Arc<LeRemoteConnectionParameterRequestReplyCompleteData>,}
#[derive(Debug)] pub struct LeRemoteConnectionParameterRequestReplyCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, }
impl LeRemoteConnectionParameterRequestReplyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeRemoteConnectionParameterRequestReplyComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeRemoteConnectionParameterRequestReplyComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;Ok(Self {status, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for LeRemoteConnectionParameterRequestReplyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeRemoteConnectionParameterRequestReplyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_remote_connection_parameter_request_reply_complete = match &command_complete.child {CommandCompleteDataChild::LeRemoteConnectionParameterRequestReplyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeRemoteConnectionParameterRequestReplyComplete"),};Self {event,command_complete,le_remote_connection_parameter_request_reply_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_remote_connection_parameter_request_reply_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_remote_connection_parameter_request_reply_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for LeRemoteConnectionParameterRequestReplyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeRemoteConnectionParameterRequestReplyCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeRemoteConnectionParameterRequestReplyCompleteBuilder {pub fn build(self) -> LeRemoteConnectionParameterRequestReplyCompletePacket {let le_remote_connection_parameter_request_reply_complete= Arc::new(LeRemoteConnectionParameterRequestReplyCompleteData {status: self.status, connection_handle: self.connection_handle, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeRemoteConnectionParameterRequestReply, child: CommandCompleteDataChild::LeRemoteConnectionParameterRequestReplyComplete(le_remote_connection_parameter_request_reply_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeRemoteConnectionParameterRequestReplyCompletePacket::new(event)}
}
impl Into<EventPacket> for LeRemoteConnectionParameterRequestReplyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeRemoteConnectionParameterRequestReplyCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeRemoteConnectionParameterRequestNegativeReplyData {connection_handle: u16, reason: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeRemoteConnectionParameterRequestNegativeReplyPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,le_connection_management_command: Arc<LeConnectionManagementCommandData>,le_remote_connection_parameter_request_negative_reply: Arc<LeRemoteConnectionParameterRequestNegativeReplyData>,}
#[derive(Debug)] pub struct LeRemoteConnectionParameterRequestNegativeReplyBuilder {pub connection_handle: u16, pub reason: ErrorCode, }
impl LeRemoteConnectionParameterRequestNegativeReplyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeRemoteConnectionParameterRequestNegativeReply".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeRemoteConnectionParameterRequestNegativeReply".to_string(),    field: "reason".to_string(),    wanted: 6,    got: bytes.len()});}let reason = u8::from_le_bytes([bytes[5]]);let reason = ErrorCode::from_u8(reason).unwrap();Ok(Self {connection_handle, reason, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let reason = self.reason.to_u8().unwrap();buffer[5..6].copy_from_slice(&reason.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl CommandExpectations for LeRemoteConnectionParameterRequestNegativeReplyPacket { type ResponseType = LeRemoteConnectionParameterRequestNegativeReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeRemoteConnectionParameterRequestNegativeReplyCompletePacket::new(pkt.event.clone()) }}impl Packet for LeRemoteConnectionParameterRequestNegativeReplyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeRemoteConnectionParameterRequestNegativeReplyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let le_connection_management_command = match &acl_command.child {AclCommandDataChild::LeConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeConnectionManagementCommand"),};let le_remote_connection_parameter_request_negative_reply = match &le_connection_management_command.child {LeConnectionManagementCommandDataChild::LeRemoteConnectionParameterRequestNegativeReply(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeRemoteConnectionParameterRequestNegativeReply"),};Self {command,acl_command,le_connection_management_command,le_remote_connection_parameter_request_negative_reply,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_remote_connection_parameter_request_negative_reply.as_ref().connection_handle}
pub fn get_reason(&self) -> ErrorCode{ self.le_remote_connection_parameter_request_negative_reply.as_ref().reason}
}
impl Into<CommandPacket> for LeRemoteConnectionParameterRequestNegativeReplyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for LeRemoteConnectionParameterRequestNegativeReplyPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<LeConnectionManagementCommandPacket> for LeRemoteConnectionParameterRequestNegativeReplyPacket { fn into(self) -> LeConnectionManagementCommandPacket {LeConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for LeRemoteConnectionParameterRequestNegativeReplyBuilder { type ResponseType = LeRemoteConnectionParameterRequestNegativeReplyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeRemoteConnectionParameterRequestNegativeReplyCompletePacket::new(pkt.event.clone()) }}impl LeRemoteConnectionParameterRequestNegativeReplyBuilder {pub fn build(self) -> LeRemoteConnectionParameterRequestNegativeReplyPacket {let le_remote_connection_parameter_request_negative_reply= Arc::new(LeRemoteConnectionParameterRequestNegativeReplyData {connection_handle: self.connection_handle, reason: self.reason, });let le_connection_management_command= Arc::new(LeConnectionManagementCommandData {child: LeConnectionManagementCommandDataChild::LeRemoteConnectionParameterRequestNegativeReply(le_remote_connection_parameter_request_negative_reply),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::LeConnectionManagementCommand(le_connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::LeRemoteConnectionParameterRequestNegativeReply, child: CommandDataChild::AclCommand(acl_command),});LeRemoteConnectionParameterRequestNegativeReplyPacket::new(command)}
}
impl Into<CommandPacket> for LeRemoteConnectionParameterRequestNegativeReplyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for LeRemoteConnectionParameterRequestNegativeReplyBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<LeConnectionManagementCommandPacket> for LeRemoteConnectionParameterRequestNegativeReplyBuilder { fn into(self) -> LeConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeRemoteConnectionParameterRequestNegativeReplyCompleteData {status: ErrorCode, connection_handle: u16, }
#[derive(Debug, Clone)] pub struct LeRemoteConnectionParameterRequestNegativeReplyCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_remote_connection_parameter_request_negative_reply_complete: Arc<LeRemoteConnectionParameterRequestNegativeReplyCompleteData>,}
#[derive(Debug)] pub struct LeRemoteConnectionParameterRequestNegativeReplyCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, }
impl LeRemoteConnectionParameterRequestNegativeReplyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeRemoteConnectionParameterRequestNegativeReplyComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeRemoteConnectionParameterRequestNegativeReplyComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;Ok(Self {status, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for LeRemoteConnectionParameterRequestNegativeReplyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeRemoteConnectionParameterRequestNegativeReplyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_remote_connection_parameter_request_negative_reply_complete = match &command_complete.child {CommandCompleteDataChild::LeRemoteConnectionParameterRequestNegativeReplyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeRemoteConnectionParameterRequestNegativeReplyComplete"),};Self {event,command_complete,le_remote_connection_parameter_request_negative_reply_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_remote_connection_parameter_request_negative_reply_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_remote_connection_parameter_request_negative_reply_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for LeRemoteConnectionParameterRequestNegativeReplyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeRemoteConnectionParameterRequestNegativeReplyCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeRemoteConnectionParameterRequestNegativeReplyCompleteBuilder {pub fn build(self) -> LeRemoteConnectionParameterRequestNegativeReplyCompletePacket {let le_remote_connection_parameter_request_negative_reply_complete= Arc::new(LeRemoteConnectionParameterRequestNegativeReplyCompleteData {status: self.status, connection_handle: self.connection_handle, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeRemoteConnectionParameterRequestNegativeReply, child: CommandCompleteDataChild::LeRemoteConnectionParameterRequestNegativeReplyComplete(le_remote_connection_parameter_request_negative_reply_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeRemoteConnectionParameterRequestNegativeReplyCompletePacket::new(event)}
}
impl Into<EventPacket> for LeRemoteConnectionParameterRequestNegativeReplyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeRemoteConnectionParameterRequestNegativeReplyCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetDataLengthData {connection_handle: u16, tx_octets: u16, tx_time: u16, }
#[derive(Debug, Clone)] pub struct LeSetDataLengthPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,le_connection_management_command: Arc<LeConnectionManagementCommandData>,le_set_data_length: Arc<LeSetDataLengthData>,}
#[derive(Debug)] pub struct LeSetDataLengthBuilder {pub connection_handle: u16, pub tx_octets: u16, pub tx_time: u16, }
impl LeSetDataLengthData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeSetDataLength".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeSetDataLength".to_string(),    field: "tx_octets".to_string(),    wanted: 7,    got: bytes.len()});}let tx_octets = u16::from_le_bytes([bytes[5],bytes[6]]);if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeSetDataLength".to_string(),    field: "tx_time".to_string(),    wanted: 9,    got: bytes.len()});}let tx_time = u16::from_le_bytes([bytes[7],bytes[8]]);Ok(Self {connection_handle, tx_octets, tx_time, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let tx_octets = self.tx_octets;buffer[5..7].copy_from_slice(&tx_octets.to_le_bytes()[0..2]);let tx_time = self.tx_time;buffer[7..9].copy_from_slice(&tx_time.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl CommandExpectations for LeSetDataLengthPacket { type ResponseType = LeSetDataLengthCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetDataLengthCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetDataLengthPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetDataLengthPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let le_connection_management_command = match &acl_command.child {AclCommandDataChild::LeConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeConnectionManagementCommand"),};let le_set_data_length = match &le_connection_management_command.child {LeConnectionManagementCommandDataChild::LeSetDataLength(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetDataLength"),};Self {command,acl_command,le_connection_management_command,le_set_data_length,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_set_data_length.as_ref().connection_handle}
pub fn get_tx_octets(&self) -> u16{ self.le_set_data_length.as_ref().tx_octets}
pub fn get_tx_time(&self) -> u16{ self.le_set_data_length.as_ref().tx_time}
}
impl Into<CommandPacket> for LeSetDataLengthPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for LeSetDataLengthPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<LeConnectionManagementCommandPacket> for LeSetDataLengthPacket { fn into(self) -> LeConnectionManagementCommandPacket {LeConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetDataLengthBuilder { type ResponseType = LeSetDataLengthCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetDataLengthCompletePacket::new(pkt.event.clone()) }}impl LeSetDataLengthBuilder {pub fn build(self) -> LeSetDataLengthPacket {let le_set_data_length= Arc::new(LeSetDataLengthData {connection_handle: self.connection_handle, tx_octets: self.tx_octets, tx_time: self.tx_time, });let le_connection_management_command= Arc::new(LeConnectionManagementCommandData {child: LeConnectionManagementCommandDataChild::LeSetDataLength(le_set_data_length),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::LeConnectionManagementCommand(le_connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::LeSetDataLength, child: CommandDataChild::AclCommand(acl_command),});LeSetDataLengthPacket::new(command)}
}
impl Into<CommandPacket> for LeSetDataLengthBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for LeSetDataLengthBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<LeConnectionManagementCommandPacket> for LeSetDataLengthBuilder { fn into(self) -> LeConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetDataLengthCompleteData {status: ErrorCode, connection_handle: u16, }
#[derive(Debug, Clone)] pub struct LeSetDataLengthCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_data_length_complete: Arc<LeSetDataLengthCompleteData>,}
#[derive(Debug)] pub struct LeSetDataLengthCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, }
impl LeSetDataLengthCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetDataLengthComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeSetDataLengthComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;Ok(Self {status, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for LeSetDataLengthCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetDataLengthCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_data_length_complete = match &command_complete.child {CommandCompleteDataChild::LeSetDataLengthComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetDataLengthComplete"),};Self {event,command_complete,le_set_data_length_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_data_length_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_set_data_length_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for LeSetDataLengthCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetDataLengthCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetDataLengthCompleteBuilder {pub fn build(self) -> LeSetDataLengthCompletePacket {let le_set_data_length_complete= Arc::new(LeSetDataLengthCompleteData {status: self.status, connection_handle: self.connection_handle, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetDataLength, child: CommandCompleteDataChild::LeSetDataLengthComplete(le_set_data_length_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetDataLengthCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetDataLengthCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetDataLengthCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeReadSuggestedDefaultDataLengthData {}
#[derive(Debug, Clone)] pub struct LeReadSuggestedDefaultDataLengthPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,le_connection_management_command: Arc<LeConnectionManagementCommandData>,le_read_suggested_default_data_length: Arc<LeReadSuggestedDefaultDataLengthData>,}
#[derive(Debug)] pub struct LeReadSuggestedDefaultDataLengthBuilder {}
impl LeReadSuggestedDefaultDataLengthData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeReadSuggestedDefaultDataLengthPacket { type ResponseType = LeReadSuggestedDefaultDataLengthCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadSuggestedDefaultDataLengthCompletePacket::new(pkt.event.clone()) }}impl Packet for LeReadSuggestedDefaultDataLengthPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadSuggestedDefaultDataLengthPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let le_connection_management_command = match &acl_command.child {AclCommandDataChild::LeConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeConnectionManagementCommand"),};let le_read_suggested_default_data_length = match &le_connection_management_command.child {LeConnectionManagementCommandDataChild::LeReadSuggestedDefaultDataLength(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadSuggestedDefaultDataLength"),};Self {command,acl_command,le_connection_management_command,le_read_suggested_default_data_length,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeReadSuggestedDefaultDataLengthPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for LeReadSuggestedDefaultDataLengthPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<LeConnectionManagementCommandPacket> for LeReadSuggestedDefaultDataLengthPacket { fn into(self) -> LeConnectionManagementCommandPacket {LeConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for LeReadSuggestedDefaultDataLengthBuilder { type ResponseType = LeReadSuggestedDefaultDataLengthCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadSuggestedDefaultDataLengthCompletePacket::new(pkt.event.clone()) }}impl LeReadSuggestedDefaultDataLengthBuilder {pub fn build(self) -> LeReadSuggestedDefaultDataLengthPacket {let le_read_suggested_default_data_length= Arc::new(LeReadSuggestedDefaultDataLengthData {});let le_connection_management_command= Arc::new(LeConnectionManagementCommandData {child: LeConnectionManagementCommandDataChild::LeReadSuggestedDefaultDataLength(le_read_suggested_default_data_length),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::LeConnectionManagementCommand(le_connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::LeReadSuggestedDefaultDataLength, child: CommandDataChild::AclCommand(acl_command),});LeReadSuggestedDefaultDataLengthPacket::new(command)}
}
impl Into<CommandPacket> for LeReadSuggestedDefaultDataLengthBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for LeReadSuggestedDefaultDataLengthBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<LeConnectionManagementCommandPacket> for LeReadSuggestedDefaultDataLengthBuilder { fn into(self) -> LeConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeReadSuggestedDefaultDataLengthCompleteData {status: ErrorCode, tx_octets: u16, tx_time: u16, }
#[derive(Debug, Clone)] pub struct LeReadSuggestedDefaultDataLengthCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_read_suggested_default_data_length_complete: Arc<LeReadSuggestedDefaultDataLengthCompleteData>,}
#[derive(Debug)] pub struct LeReadSuggestedDefaultDataLengthCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub tx_octets: u16, pub tx_time: u16, }
impl LeReadSuggestedDefaultDataLengthCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeReadSuggestedDefaultDataLengthComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeReadSuggestedDefaultDataLengthComplete".to_string(),    field: "tx_octets".to_string(),    wanted: 8,    got: bytes.len()});}let tx_octets = u16::from_le_bytes([bytes[6],bytes[7]]);if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeReadSuggestedDefaultDataLengthComplete".to_string(),    field: "tx_time".to_string(),    wanted: 10,    got: bytes.len()});}let tx_time = u16::from_le_bytes([bytes[8],bytes[9]]);Ok(Self {status, tx_octets, tx_time, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let tx_octets = self.tx_octets;buffer[6..8].copy_from_slice(&tx_octets.to_le_bytes()[0..2]);let tx_time = self.tx_time;buffer[8..10].copy_from_slice(&tx_time.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 5;ret}
}
impl Packet for LeReadSuggestedDefaultDataLengthCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadSuggestedDefaultDataLengthCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_read_suggested_default_data_length_complete = match &command_complete.child {CommandCompleteDataChild::LeReadSuggestedDefaultDataLengthComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadSuggestedDefaultDataLengthComplete"),};Self {event,command_complete,le_read_suggested_default_data_length_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_read_suggested_default_data_length_complete.as_ref().status}
pub fn get_tx_octets(&self) -> u16{ self.le_read_suggested_default_data_length_complete.as_ref().tx_octets}
pub fn get_tx_time(&self) -> u16{ self.le_read_suggested_default_data_length_complete.as_ref().tx_time}
}
impl Into<EventPacket> for LeReadSuggestedDefaultDataLengthCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeReadSuggestedDefaultDataLengthCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeReadSuggestedDefaultDataLengthCompleteBuilder {pub fn build(self) -> LeReadSuggestedDefaultDataLengthCompletePacket {let le_read_suggested_default_data_length_complete= Arc::new(LeReadSuggestedDefaultDataLengthCompleteData {status: self.status, tx_octets: self.tx_octets, tx_time: self.tx_time, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeReadSuggestedDefaultDataLength, child: CommandCompleteDataChild::LeReadSuggestedDefaultDataLengthComplete(le_read_suggested_default_data_length_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeReadSuggestedDefaultDataLengthCompletePacket::new(event)}
}
impl Into<EventPacket> for LeReadSuggestedDefaultDataLengthCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeReadSuggestedDefaultDataLengthCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeWriteSuggestedDefaultDataLengthData {tx_octets: u16, tx_time: u16, }
#[derive(Debug, Clone)] pub struct LeWriteSuggestedDefaultDataLengthPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,le_connection_management_command: Arc<LeConnectionManagementCommandData>,le_write_suggested_default_data_length: Arc<LeWriteSuggestedDefaultDataLengthData>,}
#[derive(Debug)] pub struct LeWriteSuggestedDefaultDataLengthBuilder {pub tx_octets: u16, pub tx_time: u16, }
impl LeWriteSuggestedDefaultDataLengthData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeWriteSuggestedDefaultDataLength".to_string(),    field: "tx_octets".to_string(),    wanted: 5,    got: bytes.len()});}let tx_octets = u16::from_le_bytes([bytes[3],bytes[4]]);if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeWriteSuggestedDefaultDataLength".to_string(),    field: "tx_time".to_string(),    wanted: 7,    got: bytes.len()});}let tx_time = u16::from_le_bytes([bytes[5],bytes[6]]);Ok(Self {tx_octets, tx_time, })
}
fn write_to(&self, buffer: &mut BytesMut) {let tx_octets = self.tx_octets;buffer[3..5].copy_from_slice(&tx_octets.to_le_bytes()[0..2]);let tx_time = self.tx_time;buffer[5..7].copy_from_slice(&tx_time.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl CommandExpectations for LeWriteSuggestedDefaultDataLengthPacket { type ResponseType = LeWriteSuggestedDefaultDataLengthCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeWriteSuggestedDefaultDataLengthCompletePacket::new(pkt.event.clone()) }}impl Packet for LeWriteSuggestedDefaultDataLengthPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeWriteSuggestedDefaultDataLengthPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let le_connection_management_command = match &acl_command.child {AclCommandDataChild::LeConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeConnectionManagementCommand"),};let le_write_suggested_default_data_length = match &le_connection_management_command.child {LeConnectionManagementCommandDataChild::LeWriteSuggestedDefaultDataLength(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeWriteSuggestedDefaultDataLength"),};Self {command,acl_command,le_connection_management_command,le_write_suggested_default_data_length,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_tx_octets(&self) -> u16{ self.le_write_suggested_default_data_length.as_ref().tx_octets}
pub fn get_tx_time(&self) -> u16{ self.le_write_suggested_default_data_length.as_ref().tx_time}
}
impl Into<CommandPacket> for LeWriteSuggestedDefaultDataLengthPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for LeWriteSuggestedDefaultDataLengthPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<LeConnectionManagementCommandPacket> for LeWriteSuggestedDefaultDataLengthPacket { fn into(self) -> LeConnectionManagementCommandPacket {LeConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for LeWriteSuggestedDefaultDataLengthBuilder { type ResponseType = LeWriteSuggestedDefaultDataLengthCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeWriteSuggestedDefaultDataLengthCompletePacket::new(pkt.event.clone()) }}impl LeWriteSuggestedDefaultDataLengthBuilder {pub fn build(self) -> LeWriteSuggestedDefaultDataLengthPacket {let le_write_suggested_default_data_length= Arc::new(LeWriteSuggestedDefaultDataLengthData {tx_octets: self.tx_octets, tx_time: self.tx_time, });let le_connection_management_command= Arc::new(LeConnectionManagementCommandData {child: LeConnectionManagementCommandDataChild::LeWriteSuggestedDefaultDataLength(le_write_suggested_default_data_length),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::LeConnectionManagementCommand(le_connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::LeWriteSuggestedDefaultDataLength, child: CommandDataChild::AclCommand(acl_command),});LeWriteSuggestedDefaultDataLengthPacket::new(command)}
}
impl Into<CommandPacket> for LeWriteSuggestedDefaultDataLengthBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for LeWriteSuggestedDefaultDataLengthBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<LeConnectionManagementCommandPacket> for LeWriteSuggestedDefaultDataLengthBuilder { fn into(self) -> LeConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeWriteSuggestedDefaultDataLengthCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeWriteSuggestedDefaultDataLengthCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_write_suggested_default_data_length_complete: Arc<LeWriteSuggestedDefaultDataLengthCompleteData>,}
#[derive(Debug)] pub struct LeWriteSuggestedDefaultDataLengthCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeWriteSuggestedDefaultDataLengthCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeWriteSuggestedDefaultDataLengthComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeWriteSuggestedDefaultDataLengthCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeWriteSuggestedDefaultDataLengthCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_write_suggested_default_data_length_complete = match &command_complete.child {CommandCompleteDataChild::LeWriteSuggestedDefaultDataLengthComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeWriteSuggestedDefaultDataLengthComplete"),};Self {event,command_complete,le_write_suggested_default_data_length_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_write_suggested_default_data_length_complete.as_ref().status}
}
impl Into<EventPacket> for LeWriteSuggestedDefaultDataLengthCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeWriteSuggestedDefaultDataLengthCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeWriteSuggestedDefaultDataLengthCompleteBuilder {pub fn build(self) -> LeWriteSuggestedDefaultDataLengthCompletePacket {let le_write_suggested_default_data_length_complete= Arc::new(LeWriteSuggestedDefaultDataLengthCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeWriteSuggestedDefaultDataLength, child: CommandCompleteDataChild::LeWriteSuggestedDefaultDataLengthComplete(le_write_suggested_default_data_length_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeWriteSuggestedDefaultDataLengthCompletePacket::new(event)}
}
impl Into<EventPacket> for LeWriteSuggestedDefaultDataLengthCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeWriteSuggestedDefaultDataLengthCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeReadLocalP256PublicKeyCommandData {}
#[derive(Debug, Clone)] pub struct LeReadLocalP256PublicKeyCommandPacket {command: Arc<CommandData>,le_security_command: Arc<LeSecurityCommandData>,le_read_local_p256_public_key_command: Arc<LeReadLocalP256PublicKeyCommandData>,}
#[derive(Debug)] pub struct LeReadLocalP256PublicKeyCommandBuilder {}
impl LeReadLocalP256PublicKeyCommandData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeReadLocalP256PublicKeyCommandPacket { type ResponseType = LeReadLocalP256PublicKeyCommandStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadLocalP256PublicKeyCommandStatusPacket::new(pkt.event.clone()) }}impl Packet for LeReadLocalP256PublicKeyCommandPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadLocalP256PublicKeyCommandPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_security_command = match &command.child {CommandDataChild::LeSecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSecurityCommand"),};let le_read_local_p256_public_key_command = match &le_security_command.child {LeSecurityCommandDataChild::LeReadLocalP256PublicKeyCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadLocalP256PublicKeyCommand"),};Self {command,le_security_command,le_read_local_p256_public_key_command,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeReadLocalP256PublicKeyCommandPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeSecurityCommandPacket> for LeReadLocalP256PublicKeyCommandPacket { fn into(self) -> LeSecurityCommandPacket {LeSecurityCommandPacket::new(self.command) }}
impl CommandExpectations for LeReadLocalP256PublicKeyCommandBuilder { type ResponseType = LeReadLocalP256PublicKeyCommandStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadLocalP256PublicKeyCommandStatusPacket::new(pkt.event.clone()) }}impl LeReadLocalP256PublicKeyCommandBuilder {pub fn build(self) -> LeReadLocalP256PublicKeyCommandPacket {let le_read_local_p256_public_key_command= Arc::new(LeReadLocalP256PublicKeyCommandData {});let le_security_command= Arc::new(LeSecurityCommandData {child: LeSecurityCommandDataChild::LeReadLocalP256PublicKeyCommand(le_read_local_p256_public_key_command),});let command= Arc::new(CommandData {op_code: OpCode::LeReadLocalP256PublicKeyCommand, child: CommandDataChild::LeSecurityCommand(le_security_command),});LeReadLocalP256PublicKeyCommandPacket::new(command)}
}
impl Into<CommandPacket> for LeReadLocalP256PublicKeyCommandBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeSecurityCommandPacket> for LeReadLocalP256PublicKeyCommandBuilder { fn into(self) -> LeSecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeReadLocalP256PublicKeyCommandStatusData {}
#[derive(Debug, Clone)] pub struct LeReadLocalP256PublicKeyCommandStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,le_read_local_p256_public_key_command_status: Arc<LeReadLocalP256PublicKeyCommandStatusData>,}
#[derive(Debug)] pub struct LeReadLocalP256PublicKeyCommandStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl LeReadLocalP256PublicKeyCommandStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeReadLocalP256PublicKeyCommandStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadLocalP256PublicKeyCommandStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let le_read_local_p256_public_key_command_status = match &command_status.child {CommandStatusDataChild::LeReadLocalP256PublicKeyCommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadLocalP256PublicKeyCommandStatus"),};Self {event,command_status,le_read_local_p256_public_key_command_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for LeReadLocalP256PublicKeyCommandStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for LeReadLocalP256PublicKeyCommandStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl LeReadLocalP256PublicKeyCommandStatusBuilder {pub fn build(self) -> LeReadLocalP256PublicKeyCommandStatusPacket {let le_read_local_p256_public_key_command_status= Arc::new(LeReadLocalP256PublicKeyCommandStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeReadLocalP256PublicKeyCommand, child: CommandStatusDataChild::LeReadLocalP256PublicKeyCommandStatus(le_read_local_p256_public_key_command_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});LeReadLocalP256PublicKeyCommandStatusPacket::new(event)}
}
impl Into<EventPacket> for LeReadLocalP256PublicKeyCommandStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for LeReadLocalP256PublicKeyCommandStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct LeGenerateDhkeyV1CommandData {remote_p_256_public_key: [u8; 64], }
#[derive(Debug, Clone)] pub struct LeGenerateDhkeyV1CommandPacket {command: Arc<CommandData>,le_security_command: Arc<LeSecurityCommandData>,le_generate_dhkey_v1_command: Arc<LeGenerateDhkeyV1CommandData>,}
#[derive(Debug)] pub struct LeGenerateDhkeyV1CommandBuilder {pub remote_p_256_public_key: [u8; 64], }
impl LeGenerateDhkeyV1CommandData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 67 { return Err(Error::InvalidLengthError{    obj: "LeGenerateDhkeyV1Command".to_string(),    field: "remote_p_256_public_key".to_string(),    wanted: 67,    got: bytes.len()});}let remote_p_256_public_key = bytes[3..67].try_into().unwrap();Ok(Self {remote_p_256_public_key, })
}
fn write_to(&self, buffer: &mut BytesMut) {&buffer[3..67].copy_from_slice(&self.remote_p_256_public_key);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 64;ret}
}
impl CommandExpectations for LeGenerateDhkeyV1CommandPacket { type ResponseType = LeGenerateDhkeyV1CommandStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeGenerateDhkeyV1CommandStatusPacket::new(pkt.event.clone()) }}impl Packet for LeGenerateDhkeyV1CommandPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeGenerateDhkeyV1CommandPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_security_command = match &command.child {CommandDataChild::LeSecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSecurityCommand"),};let le_generate_dhkey_v1_command = match &le_security_command.child {LeSecurityCommandDataChild::LeGenerateDhkeyV1Command(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeGenerateDhkeyV1Command"),};Self {command,le_security_command,le_generate_dhkey_v1_command,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_remote_p_256_public_key(&self) -> &[u8; 64]{ &self.le_generate_dhkey_v1_command.as_ref().remote_p_256_public_key}
}
impl Into<CommandPacket> for LeGenerateDhkeyV1CommandPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeSecurityCommandPacket> for LeGenerateDhkeyV1CommandPacket { fn into(self) -> LeSecurityCommandPacket {LeSecurityCommandPacket::new(self.command) }}
impl CommandExpectations for LeGenerateDhkeyV1CommandBuilder { type ResponseType = LeGenerateDhkeyV1CommandStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeGenerateDhkeyV1CommandStatusPacket::new(pkt.event.clone()) }}impl LeGenerateDhkeyV1CommandBuilder {pub fn build(self) -> LeGenerateDhkeyV1CommandPacket {let le_generate_dhkey_v1_command= Arc::new(LeGenerateDhkeyV1CommandData {remote_p_256_public_key: self.remote_p_256_public_key, });let le_security_command= Arc::new(LeSecurityCommandData {child: LeSecurityCommandDataChild::LeGenerateDhkeyV1Command(le_generate_dhkey_v1_command),});let command= Arc::new(CommandData {op_code: OpCode::LeGenerateDhkeyCommandV1, child: CommandDataChild::LeSecurityCommand(le_security_command),});LeGenerateDhkeyV1CommandPacket::new(command)}
}
impl Into<CommandPacket> for LeGenerateDhkeyV1CommandBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeSecurityCommandPacket> for LeGenerateDhkeyV1CommandBuilder { fn into(self) -> LeSecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeGenerateDhkeyV1CommandStatusData {}
#[derive(Debug, Clone)] pub struct LeGenerateDhkeyV1CommandStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,le_generate_dhkey_v1_command_status: Arc<LeGenerateDhkeyV1CommandStatusData>,}
#[derive(Debug)] pub struct LeGenerateDhkeyV1CommandStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl LeGenerateDhkeyV1CommandStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeGenerateDhkeyV1CommandStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeGenerateDhkeyV1CommandStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let le_generate_dhkey_v1_command_status = match &command_status.child {CommandStatusDataChild::LeGenerateDhkeyV1CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeGenerateDhkeyV1CommandStatus"),};Self {event,command_status,le_generate_dhkey_v1_command_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for LeGenerateDhkeyV1CommandStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for LeGenerateDhkeyV1CommandStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl LeGenerateDhkeyV1CommandStatusBuilder {pub fn build(self) -> LeGenerateDhkeyV1CommandStatusPacket {let le_generate_dhkey_v1_command_status= Arc::new(LeGenerateDhkeyV1CommandStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeGenerateDhkeyCommandV1, child: CommandStatusDataChild::LeGenerateDhkeyV1CommandStatus(le_generate_dhkey_v1_command_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});LeGenerateDhkeyV1CommandStatusPacket::new(event)}
}
impl Into<EventPacket> for LeGenerateDhkeyV1CommandStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for LeGenerateDhkeyV1CommandStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct LeAddDeviceToResolvingListData {peer_identity_address_type: PeerAddressType, peer_identity_address: Address, peer_irk: [u8; 16], local_irk: [u8; 16], }
#[derive(Debug, Clone)] pub struct LeAddDeviceToResolvingListPacket {command: Arc<CommandData>,le_security_command: Arc<LeSecurityCommandData>,le_add_device_to_resolving_list: Arc<LeAddDeviceToResolvingListData>,}
#[derive(Debug)] pub struct LeAddDeviceToResolvingListBuilder {pub peer_identity_address_type: PeerAddressType, pub peer_identity_address: Address, pub peer_irk: [u8; 16], pub local_irk: [u8; 16], }
impl LeAddDeviceToResolvingListData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeAddDeviceToResolvingList".to_string(),    field: "peer_identity_address_type".to_string(),    wanted: 4,    got: bytes.len()});}let peer_identity_address_type = u8::from_le_bytes([bytes[3]]);let peer_identity_address_type = PeerAddressType::from_u8(peer_identity_address_type).unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeAddDeviceToResolvingList".to_string(),    field: "peer_identity_address".to_string(),    wanted: 10,    got: bytes.len()});}let peer_identity_address = bytes[4..10].try_into().unwrap();if bytes.len() < 26 { return Err(Error::InvalidLengthError{    obj: "LeAddDeviceToResolvingList".to_string(),    field: "peer_irk".to_string(),    wanted: 26,    got: bytes.len()});}let peer_irk = bytes[10..26].try_into().unwrap();if bytes.len() < 42 { return Err(Error::InvalidLengthError{    obj: "LeAddDeviceToResolvingList".to_string(),    field: "local_irk".to_string(),    wanted: 42,    got: bytes.len()});}let local_irk = bytes[26..42].try_into().unwrap();Ok(Self {peer_identity_address_type, peer_identity_address, peer_irk, local_irk, })
}
fn write_to(&self, buffer: &mut BytesMut) {let peer_identity_address_type = self.peer_identity_address_type.to_u8().unwrap();buffer[3..4].copy_from_slice(&peer_identity_address_type.to_le_bytes()[0..1]);let peer_identity_address: [u8; 6] = self.peer_identity_address.into();buffer[4..10].copy_from_slice(&peer_identity_address);&buffer[10..26].copy_from_slice(&self.peer_irk);&buffer[26..42].copy_from_slice(&self.local_irk);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 39;ret}
}
impl CommandExpectations for LeAddDeviceToResolvingListPacket { type ResponseType = LeAddDeviceToResolvingListCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeAddDeviceToResolvingListCompletePacket::new(pkt.event.clone()) }}impl Packet for LeAddDeviceToResolvingListPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAddDeviceToResolvingListPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_security_command = match &command.child {CommandDataChild::LeSecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSecurityCommand"),};let le_add_device_to_resolving_list = match &le_security_command.child {LeSecurityCommandDataChild::LeAddDeviceToResolvingList(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAddDeviceToResolvingList"),};Self {command,le_security_command,le_add_device_to_resolving_list,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_peer_identity_address_type(&self) -> PeerAddressType{ self.le_add_device_to_resolving_list.as_ref().peer_identity_address_type}
pub fn get_peer_identity_address(&self) -> Address{ self.le_add_device_to_resolving_list.as_ref().peer_identity_address}
pub fn get_peer_irk(&self) -> &[u8; 16]{ &self.le_add_device_to_resolving_list.as_ref().peer_irk}
pub fn get_local_irk(&self) -> &[u8; 16]{ &self.le_add_device_to_resolving_list.as_ref().local_irk}
}
impl Into<CommandPacket> for LeAddDeviceToResolvingListPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeSecurityCommandPacket> for LeAddDeviceToResolvingListPacket { fn into(self) -> LeSecurityCommandPacket {LeSecurityCommandPacket::new(self.command) }}
impl CommandExpectations for LeAddDeviceToResolvingListBuilder { type ResponseType = LeAddDeviceToResolvingListCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeAddDeviceToResolvingListCompletePacket::new(pkt.event.clone()) }}impl LeAddDeviceToResolvingListBuilder {pub fn build(self) -> LeAddDeviceToResolvingListPacket {let le_add_device_to_resolving_list= Arc::new(LeAddDeviceToResolvingListData {peer_identity_address_type: self.peer_identity_address_type, peer_identity_address: self.peer_identity_address, peer_irk: self.peer_irk, local_irk: self.local_irk, });let le_security_command= Arc::new(LeSecurityCommandData {child: LeSecurityCommandDataChild::LeAddDeviceToResolvingList(le_add_device_to_resolving_list),});let command= Arc::new(CommandData {op_code: OpCode::LeAddDeviceToResolvingList, child: CommandDataChild::LeSecurityCommand(le_security_command),});LeAddDeviceToResolvingListPacket::new(command)}
}
impl Into<CommandPacket> for LeAddDeviceToResolvingListBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeSecurityCommandPacket> for LeAddDeviceToResolvingListBuilder { fn into(self) -> LeSecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeAddDeviceToResolvingListCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeAddDeviceToResolvingListCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_add_device_to_resolving_list_complete: Arc<LeAddDeviceToResolvingListCompleteData>,}
#[derive(Debug)] pub struct LeAddDeviceToResolvingListCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeAddDeviceToResolvingListCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeAddDeviceToResolvingListComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeAddDeviceToResolvingListCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAddDeviceToResolvingListCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_add_device_to_resolving_list_complete = match &command_complete.child {CommandCompleteDataChild::LeAddDeviceToResolvingListComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAddDeviceToResolvingListComplete"),};Self {event,command_complete,le_add_device_to_resolving_list_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_add_device_to_resolving_list_complete.as_ref().status}
}
impl Into<EventPacket> for LeAddDeviceToResolvingListCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeAddDeviceToResolvingListCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeAddDeviceToResolvingListCompleteBuilder {pub fn build(self) -> LeAddDeviceToResolvingListCompletePacket {let le_add_device_to_resolving_list_complete= Arc::new(LeAddDeviceToResolvingListCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeAddDeviceToResolvingList, child: CommandCompleteDataChild::LeAddDeviceToResolvingListComplete(le_add_device_to_resolving_list_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeAddDeviceToResolvingListCompletePacket::new(event)}
}
impl Into<EventPacket> for LeAddDeviceToResolvingListCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeAddDeviceToResolvingListCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeRemoveDeviceFromResolvingListData {peer_identity_address_type: PeerAddressType, peer_identity_address: Address, }
#[derive(Debug, Clone)] pub struct LeRemoveDeviceFromResolvingListPacket {command: Arc<CommandData>,le_security_command: Arc<LeSecurityCommandData>,le_remove_device_from_resolving_list: Arc<LeRemoveDeviceFromResolvingListData>,}
#[derive(Debug)] pub struct LeRemoveDeviceFromResolvingListBuilder {pub peer_identity_address_type: PeerAddressType, pub peer_identity_address: Address, }
impl LeRemoveDeviceFromResolvingListData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeRemoveDeviceFromResolvingList".to_string(),    field: "peer_identity_address_type".to_string(),    wanted: 4,    got: bytes.len()});}let peer_identity_address_type = u8::from_le_bytes([bytes[3]]);let peer_identity_address_type = PeerAddressType::from_u8(peer_identity_address_type).unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeRemoveDeviceFromResolvingList".to_string(),    field: "peer_identity_address".to_string(),    wanted: 10,    got: bytes.len()});}let peer_identity_address = bytes[4..10].try_into().unwrap();Ok(Self {peer_identity_address_type, peer_identity_address, })
}
fn write_to(&self, buffer: &mut BytesMut) {let peer_identity_address_type = self.peer_identity_address_type.to_u8().unwrap();buffer[3..4].copy_from_slice(&peer_identity_address_type.to_le_bytes()[0..1]);let peer_identity_address: [u8; 6] = self.peer_identity_address.into();buffer[4..10].copy_from_slice(&peer_identity_address);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl CommandExpectations for LeRemoveDeviceFromResolvingListPacket { type ResponseType = LeRemoveDeviceFromResolvingListCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeRemoveDeviceFromResolvingListCompletePacket::new(pkt.event.clone()) }}impl Packet for LeRemoveDeviceFromResolvingListPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeRemoveDeviceFromResolvingListPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_security_command = match &command.child {CommandDataChild::LeSecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSecurityCommand"),};let le_remove_device_from_resolving_list = match &le_security_command.child {LeSecurityCommandDataChild::LeRemoveDeviceFromResolvingList(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeRemoveDeviceFromResolvingList"),};Self {command,le_security_command,le_remove_device_from_resolving_list,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_peer_identity_address_type(&self) -> PeerAddressType{ self.le_remove_device_from_resolving_list.as_ref().peer_identity_address_type}
pub fn get_peer_identity_address(&self) -> Address{ self.le_remove_device_from_resolving_list.as_ref().peer_identity_address}
}
impl Into<CommandPacket> for LeRemoveDeviceFromResolvingListPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeSecurityCommandPacket> for LeRemoveDeviceFromResolvingListPacket { fn into(self) -> LeSecurityCommandPacket {LeSecurityCommandPacket::new(self.command) }}
impl CommandExpectations for LeRemoveDeviceFromResolvingListBuilder { type ResponseType = LeRemoveDeviceFromResolvingListCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeRemoveDeviceFromResolvingListCompletePacket::new(pkt.event.clone()) }}impl LeRemoveDeviceFromResolvingListBuilder {pub fn build(self) -> LeRemoveDeviceFromResolvingListPacket {let le_remove_device_from_resolving_list= Arc::new(LeRemoveDeviceFromResolvingListData {peer_identity_address_type: self.peer_identity_address_type, peer_identity_address: self.peer_identity_address, });let le_security_command= Arc::new(LeSecurityCommandData {child: LeSecurityCommandDataChild::LeRemoveDeviceFromResolvingList(le_remove_device_from_resolving_list),});let command= Arc::new(CommandData {op_code: OpCode::LeRemoveDeviceFromResolvingList, child: CommandDataChild::LeSecurityCommand(le_security_command),});LeRemoveDeviceFromResolvingListPacket::new(command)}
}
impl Into<CommandPacket> for LeRemoveDeviceFromResolvingListBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeSecurityCommandPacket> for LeRemoveDeviceFromResolvingListBuilder { fn into(self) -> LeSecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeRemoveDeviceFromResolvingListCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeRemoveDeviceFromResolvingListCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_remove_device_from_resolving_list_complete: Arc<LeRemoveDeviceFromResolvingListCompleteData>,}
#[derive(Debug)] pub struct LeRemoveDeviceFromResolvingListCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeRemoveDeviceFromResolvingListCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeRemoveDeviceFromResolvingListComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeRemoveDeviceFromResolvingListCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeRemoveDeviceFromResolvingListCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_remove_device_from_resolving_list_complete = match &command_complete.child {CommandCompleteDataChild::LeRemoveDeviceFromResolvingListComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeRemoveDeviceFromResolvingListComplete"),};Self {event,command_complete,le_remove_device_from_resolving_list_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_remove_device_from_resolving_list_complete.as_ref().status}
}
impl Into<EventPacket> for LeRemoveDeviceFromResolvingListCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeRemoveDeviceFromResolvingListCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeRemoveDeviceFromResolvingListCompleteBuilder {pub fn build(self) -> LeRemoveDeviceFromResolvingListCompletePacket {let le_remove_device_from_resolving_list_complete= Arc::new(LeRemoveDeviceFromResolvingListCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeRemoveDeviceFromResolvingList, child: CommandCompleteDataChild::LeRemoveDeviceFromResolvingListComplete(le_remove_device_from_resolving_list_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeRemoveDeviceFromResolvingListCompletePacket::new(event)}
}
impl Into<EventPacket> for LeRemoveDeviceFromResolvingListCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeRemoveDeviceFromResolvingListCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeClearResolvingListData {}
#[derive(Debug, Clone)] pub struct LeClearResolvingListPacket {command: Arc<CommandData>,le_security_command: Arc<LeSecurityCommandData>,le_clear_resolving_list: Arc<LeClearResolvingListData>,}
#[derive(Debug)] pub struct LeClearResolvingListBuilder {}
impl LeClearResolvingListData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeClearResolvingListPacket { type ResponseType = LeClearResolvingListCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeClearResolvingListCompletePacket::new(pkt.event.clone()) }}impl Packet for LeClearResolvingListPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeClearResolvingListPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_security_command = match &command.child {CommandDataChild::LeSecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSecurityCommand"),};let le_clear_resolving_list = match &le_security_command.child {LeSecurityCommandDataChild::LeClearResolvingList(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeClearResolvingList"),};Self {command,le_security_command,le_clear_resolving_list,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeClearResolvingListPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeSecurityCommandPacket> for LeClearResolvingListPacket { fn into(self) -> LeSecurityCommandPacket {LeSecurityCommandPacket::new(self.command) }}
impl CommandExpectations for LeClearResolvingListBuilder { type ResponseType = LeClearResolvingListCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeClearResolvingListCompletePacket::new(pkt.event.clone()) }}impl LeClearResolvingListBuilder {pub fn build(self) -> LeClearResolvingListPacket {let le_clear_resolving_list= Arc::new(LeClearResolvingListData {});let le_security_command= Arc::new(LeSecurityCommandData {child: LeSecurityCommandDataChild::LeClearResolvingList(le_clear_resolving_list),});let command= Arc::new(CommandData {op_code: OpCode::LeClearResolvingList, child: CommandDataChild::LeSecurityCommand(le_security_command),});LeClearResolvingListPacket::new(command)}
}
impl Into<CommandPacket> for LeClearResolvingListBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeSecurityCommandPacket> for LeClearResolvingListBuilder { fn into(self) -> LeSecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeClearResolvingListCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeClearResolvingListCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_clear_resolving_list_complete: Arc<LeClearResolvingListCompleteData>,}
#[derive(Debug)] pub struct LeClearResolvingListCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeClearResolvingListCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeClearResolvingListComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeClearResolvingListCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeClearResolvingListCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_clear_resolving_list_complete = match &command_complete.child {CommandCompleteDataChild::LeClearResolvingListComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeClearResolvingListComplete"),};Self {event,command_complete,le_clear_resolving_list_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_clear_resolving_list_complete.as_ref().status}
}
impl Into<EventPacket> for LeClearResolvingListCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeClearResolvingListCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeClearResolvingListCompleteBuilder {pub fn build(self) -> LeClearResolvingListCompletePacket {let le_clear_resolving_list_complete= Arc::new(LeClearResolvingListCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeClearResolvingList, child: CommandCompleteDataChild::LeClearResolvingListComplete(le_clear_resolving_list_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeClearResolvingListCompletePacket::new(event)}
}
impl Into<EventPacket> for LeClearResolvingListCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeClearResolvingListCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeReadResolvingListSizeData {}
#[derive(Debug, Clone)] pub struct LeReadResolvingListSizePacket {command: Arc<CommandData>,le_read_resolving_list_size: Arc<LeReadResolvingListSizeData>,}
#[derive(Debug)] pub struct LeReadResolvingListSizeBuilder {}
impl LeReadResolvingListSizeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeReadResolvingListSizePacket { type ResponseType = LeReadResolvingListSizeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadResolvingListSizeCompletePacket::new(pkt.event.clone()) }}impl Packet for LeReadResolvingListSizePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadResolvingListSizePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_read_resolving_list_size = match &command.child {CommandDataChild::LeReadResolvingListSize(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadResolvingListSize"),};Self {command,le_read_resolving_list_size,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeReadResolvingListSizePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeReadResolvingListSizeBuilder { type ResponseType = LeReadResolvingListSizeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadResolvingListSizeCompletePacket::new(pkt.event.clone()) }}impl LeReadResolvingListSizeBuilder {pub fn build(self) -> LeReadResolvingListSizePacket {let le_read_resolving_list_size= Arc::new(LeReadResolvingListSizeData {});let command= Arc::new(CommandData {op_code: OpCode::LeReadResolvingListSize, child: CommandDataChild::LeReadResolvingListSize(le_read_resolving_list_size),});LeReadResolvingListSizePacket::new(command)}
}
impl Into<CommandPacket> for LeReadResolvingListSizeBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LeReadResolvingListSizeCompleteData {status: ErrorCode, resolving_list_size: u8, }
#[derive(Debug, Clone)] pub struct LeReadResolvingListSizeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_read_resolving_list_size_complete: Arc<LeReadResolvingListSizeCompleteData>,}
#[derive(Debug)] pub struct LeReadResolvingListSizeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub resolving_list_size: u8, }
impl LeReadResolvingListSizeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeReadResolvingListSizeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeReadResolvingListSizeComplete".to_string(),    field: "resolving_list_size".to_string(),    wanted: 7,    got: bytes.len()});}let resolving_list_size = u8::from_le_bytes([bytes[6]]);Ok(Self {status, resolving_list_size, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let resolving_list_size = self.resolving_list_size;buffer[6..7].copy_from_slice(&resolving_list_size.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for LeReadResolvingListSizeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadResolvingListSizeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_read_resolving_list_size_complete = match &command_complete.child {CommandCompleteDataChild::LeReadResolvingListSizeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadResolvingListSizeComplete"),};Self {event,command_complete,le_read_resolving_list_size_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_read_resolving_list_size_complete.as_ref().status}
pub fn get_resolving_list_size(&self) -> u8{ self.le_read_resolving_list_size_complete.as_ref().resolving_list_size}
}
impl Into<EventPacket> for LeReadResolvingListSizeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeReadResolvingListSizeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeReadResolvingListSizeCompleteBuilder {pub fn build(self) -> LeReadResolvingListSizeCompletePacket {let le_read_resolving_list_size_complete= Arc::new(LeReadResolvingListSizeCompleteData {status: self.status, resolving_list_size: self.resolving_list_size, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeReadResolvingListSize, child: CommandCompleteDataChild::LeReadResolvingListSizeComplete(le_read_resolving_list_size_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeReadResolvingListSizeCompletePacket::new(event)}
}
impl Into<EventPacket> for LeReadResolvingListSizeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeReadResolvingListSizeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeReadPeerResolvableAddressData {peer_identity_address_type: PeerAddressType, peer_identity_address: Address, }
#[derive(Debug, Clone)] pub struct LeReadPeerResolvableAddressPacket {command: Arc<CommandData>,le_security_command: Arc<LeSecurityCommandData>,le_read_peer_resolvable_address: Arc<LeReadPeerResolvableAddressData>,}
#[derive(Debug)] pub struct LeReadPeerResolvableAddressBuilder {pub peer_identity_address_type: PeerAddressType, pub peer_identity_address: Address, }
impl LeReadPeerResolvableAddressData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeReadPeerResolvableAddress".to_string(),    field: "peer_identity_address_type".to_string(),    wanted: 4,    got: bytes.len()});}let peer_identity_address_type = u8::from_le_bytes([bytes[3]]);let peer_identity_address_type = PeerAddressType::from_u8(peer_identity_address_type).unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeReadPeerResolvableAddress".to_string(),    field: "peer_identity_address".to_string(),    wanted: 10,    got: bytes.len()});}let peer_identity_address = bytes[4..10].try_into().unwrap();Ok(Self {peer_identity_address_type, peer_identity_address, })
}
fn write_to(&self, buffer: &mut BytesMut) {let peer_identity_address_type = self.peer_identity_address_type.to_u8().unwrap();buffer[3..4].copy_from_slice(&peer_identity_address_type.to_le_bytes()[0..1]);let peer_identity_address: [u8; 6] = self.peer_identity_address.into();buffer[4..10].copy_from_slice(&peer_identity_address);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl CommandExpectations for LeReadPeerResolvableAddressPacket { type ResponseType = LeReadPeerResolvableAddressCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadPeerResolvableAddressCompletePacket::new(pkt.event.clone()) }}impl Packet for LeReadPeerResolvableAddressPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadPeerResolvableAddressPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_security_command = match &command.child {CommandDataChild::LeSecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSecurityCommand"),};let le_read_peer_resolvable_address = match &le_security_command.child {LeSecurityCommandDataChild::LeReadPeerResolvableAddress(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadPeerResolvableAddress"),};Self {command,le_security_command,le_read_peer_resolvable_address,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_peer_identity_address_type(&self) -> PeerAddressType{ self.le_read_peer_resolvable_address.as_ref().peer_identity_address_type}
pub fn get_peer_identity_address(&self) -> Address{ self.le_read_peer_resolvable_address.as_ref().peer_identity_address}
}
impl Into<CommandPacket> for LeReadPeerResolvableAddressPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeSecurityCommandPacket> for LeReadPeerResolvableAddressPacket { fn into(self) -> LeSecurityCommandPacket {LeSecurityCommandPacket::new(self.command) }}
impl CommandExpectations for LeReadPeerResolvableAddressBuilder { type ResponseType = LeReadPeerResolvableAddressCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadPeerResolvableAddressCompletePacket::new(pkt.event.clone()) }}impl LeReadPeerResolvableAddressBuilder {pub fn build(self) -> LeReadPeerResolvableAddressPacket {let le_read_peer_resolvable_address= Arc::new(LeReadPeerResolvableAddressData {peer_identity_address_type: self.peer_identity_address_type, peer_identity_address: self.peer_identity_address, });let le_security_command= Arc::new(LeSecurityCommandData {child: LeSecurityCommandDataChild::LeReadPeerResolvableAddress(le_read_peer_resolvable_address),});let command= Arc::new(CommandData {op_code: OpCode::LeReadPeerResolvableAddress, child: CommandDataChild::LeSecurityCommand(le_security_command),});LeReadPeerResolvableAddressPacket::new(command)}
}
impl Into<CommandPacket> for LeReadPeerResolvableAddressBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeSecurityCommandPacket> for LeReadPeerResolvableAddressBuilder { fn into(self) -> LeSecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeReadPeerResolvableAddressCompleteData {status: ErrorCode, peer_resolvable_address: Address, }
#[derive(Debug, Clone)] pub struct LeReadPeerResolvableAddressCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_read_peer_resolvable_address_complete: Arc<LeReadPeerResolvableAddressCompleteData>,}
#[derive(Debug)] pub struct LeReadPeerResolvableAddressCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub peer_resolvable_address: Address, }
impl LeReadPeerResolvableAddressCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeReadPeerResolvableAddressComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "LeReadPeerResolvableAddressComplete".to_string(),    field: "peer_resolvable_address".to_string(),    wanted: 12,    got: bytes.len()});}let peer_resolvable_address = bytes[6..12].try_into().unwrap();Ok(Self {status, peer_resolvable_address, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let peer_resolvable_address: [u8; 6] = self.peer_resolvable_address.into();buffer[6..12].copy_from_slice(&peer_resolvable_address);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for LeReadPeerResolvableAddressCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadPeerResolvableAddressCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_read_peer_resolvable_address_complete = match &command_complete.child {CommandCompleteDataChild::LeReadPeerResolvableAddressComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadPeerResolvableAddressComplete"),};Self {event,command_complete,le_read_peer_resolvable_address_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_read_peer_resolvable_address_complete.as_ref().status}
pub fn get_peer_resolvable_address(&self) -> Address{ self.le_read_peer_resolvable_address_complete.as_ref().peer_resolvable_address}
}
impl Into<EventPacket> for LeReadPeerResolvableAddressCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeReadPeerResolvableAddressCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeReadPeerResolvableAddressCompleteBuilder {pub fn build(self) -> LeReadPeerResolvableAddressCompletePacket {let le_read_peer_resolvable_address_complete= Arc::new(LeReadPeerResolvableAddressCompleteData {status: self.status, peer_resolvable_address: self.peer_resolvable_address, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeReadPeerResolvableAddress, child: CommandCompleteDataChild::LeReadPeerResolvableAddressComplete(le_read_peer_resolvable_address_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeReadPeerResolvableAddressCompletePacket::new(event)}
}
impl Into<EventPacket> for LeReadPeerResolvableAddressCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeReadPeerResolvableAddressCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeReadLocalResolvableAddressData {peer_identity_address_type: PeerAddressType, peer_identity_address: Address, }
#[derive(Debug, Clone)] pub struct LeReadLocalResolvableAddressPacket {command: Arc<CommandData>,le_security_command: Arc<LeSecurityCommandData>,le_read_local_resolvable_address: Arc<LeReadLocalResolvableAddressData>,}
#[derive(Debug)] pub struct LeReadLocalResolvableAddressBuilder {pub peer_identity_address_type: PeerAddressType, pub peer_identity_address: Address, }
impl LeReadLocalResolvableAddressData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeReadLocalResolvableAddress".to_string(),    field: "peer_identity_address_type".to_string(),    wanted: 4,    got: bytes.len()});}let peer_identity_address_type = u8::from_le_bytes([bytes[3]]);let peer_identity_address_type = PeerAddressType::from_u8(peer_identity_address_type).unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeReadLocalResolvableAddress".to_string(),    field: "peer_identity_address".to_string(),    wanted: 10,    got: bytes.len()});}let peer_identity_address = bytes[4..10].try_into().unwrap();Ok(Self {peer_identity_address_type, peer_identity_address, })
}
fn write_to(&self, buffer: &mut BytesMut) {let peer_identity_address_type = self.peer_identity_address_type.to_u8().unwrap();buffer[3..4].copy_from_slice(&peer_identity_address_type.to_le_bytes()[0..1]);let peer_identity_address: [u8; 6] = self.peer_identity_address.into();buffer[4..10].copy_from_slice(&peer_identity_address);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl CommandExpectations for LeReadLocalResolvableAddressPacket { type ResponseType = LeReadLocalResolvableAddressCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadLocalResolvableAddressCompletePacket::new(pkt.event.clone()) }}impl Packet for LeReadLocalResolvableAddressPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadLocalResolvableAddressPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_security_command = match &command.child {CommandDataChild::LeSecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSecurityCommand"),};let le_read_local_resolvable_address = match &le_security_command.child {LeSecurityCommandDataChild::LeReadLocalResolvableAddress(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadLocalResolvableAddress"),};Self {command,le_security_command,le_read_local_resolvable_address,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_peer_identity_address_type(&self) -> PeerAddressType{ self.le_read_local_resolvable_address.as_ref().peer_identity_address_type}
pub fn get_peer_identity_address(&self) -> Address{ self.le_read_local_resolvable_address.as_ref().peer_identity_address}
}
impl Into<CommandPacket> for LeReadLocalResolvableAddressPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeSecurityCommandPacket> for LeReadLocalResolvableAddressPacket { fn into(self) -> LeSecurityCommandPacket {LeSecurityCommandPacket::new(self.command) }}
impl CommandExpectations for LeReadLocalResolvableAddressBuilder { type ResponseType = LeReadLocalResolvableAddressCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadLocalResolvableAddressCompletePacket::new(pkt.event.clone()) }}impl LeReadLocalResolvableAddressBuilder {pub fn build(self) -> LeReadLocalResolvableAddressPacket {let le_read_local_resolvable_address= Arc::new(LeReadLocalResolvableAddressData {peer_identity_address_type: self.peer_identity_address_type, peer_identity_address: self.peer_identity_address, });let le_security_command= Arc::new(LeSecurityCommandData {child: LeSecurityCommandDataChild::LeReadLocalResolvableAddress(le_read_local_resolvable_address),});let command= Arc::new(CommandData {op_code: OpCode::LeReadLocalResolvableAddress, child: CommandDataChild::LeSecurityCommand(le_security_command),});LeReadLocalResolvableAddressPacket::new(command)}
}
impl Into<CommandPacket> for LeReadLocalResolvableAddressBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeSecurityCommandPacket> for LeReadLocalResolvableAddressBuilder { fn into(self) -> LeSecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeReadLocalResolvableAddressCompleteData {status: ErrorCode, local_resolvable_address: Address, }
#[derive(Debug, Clone)] pub struct LeReadLocalResolvableAddressCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_read_local_resolvable_address_complete: Arc<LeReadLocalResolvableAddressCompleteData>,}
#[derive(Debug)] pub struct LeReadLocalResolvableAddressCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub local_resolvable_address: Address, }
impl LeReadLocalResolvableAddressCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeReadLocalResolvableAddressComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "LeReadLocalResolvableAddressComplete".to_string(),    field: "local_resolvable_address".to_string(),    wanted: 12,    got: bytes.len()});}let local_resolvable_address = bytes[6..12].try_into().unwrap();Ok(Self {status, local_resolvable_address, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let local_resolvable_address: [u8; 6] = self.local_resolvable_address.into();buffer[6..12].copy_from_slice(&local_resolvable_address);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for LeReadLocalResolvableAddressCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadLocalResolvableAddressCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_read_local_resolvable_address_complete = match &command_complete.child {CommandCompleteDataChild::LeReadLocalResolvableAddressComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadLocalResolvableAddressComplete"),};Self {event,command_complete,le_read_local_resolvable_address_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_read_local_resolvable_address_complete.as_ref().status}
pub fn get_local_resolvable_address(&self) -> Address{ self.le_read_local_resolvable_address_complete.as_ref().local_resolvable_address}
}
impl Into<EventPacket> for LeReadLocalResolvableAddressCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeReadLocalResolvableAddressCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeReadLocalResolvableAddressCompleteBuilder {pub fn build(self) -> LeReadLocalResolvableAddressCompletePacket {let le_read_local_resolvable_address_complete= Arc::new(LeReadLocalResolvableAddressCompleteData {status: self.status, local_resolvable_address: self.local_resolvable_address, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeReadLocalResolvableAddress, child: CommandCompleteDataChild::LeReadLocalResolvableAddressComplete(le_read_local_resolvable_address_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeReadLocalResolvableAddressCompletePacket::new(event)}
}
impl Into<EventPacket> for LeReadLocalResolvableAddressCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeReadLocalResolvableAddressCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetAddressResolutionEnableData {address_resolution_enable: Enable, }
#[derive(Debug, Clone)] pub struct LeSetAddressResolutionEnablePacket {command: Arc<CommandData>,le_security_command: Arc<LeSecurityCommandData>,le_set_address_resolution_enable: Arc<LeSetAddressResolutionEnableData>,}
#[derive(Debug)] pub struct LeSetAddressResolutionEnableBuilder {pub address_resolution_enable: Enable, }
impl LeSetAddressResolutionEnableData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetAddressResolutionEnable".to_string(),    field: "address_resolution_enable".to_string(),    wanted: 4,    got: bytes.len()});}let address_resolution_enable = u8::from_le_bytes([bytes[3]]);let address_resolution_enable = Enable::from_u8(address_resolution_enable).unwrap();Ok(Self {address_resolution_enable, })
}
fn write_to(&self, buffer: &mut BytesMut) {let address_resolution_enable = self.address_resolution_enable.to_u8().unwrap();buffer[3..4].copy_from_slice(&address_resolution_enable.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for LeSetAddressResolutionEnablePacket { type ResponseType = LeSetAddressResolutionEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetAddressResolutionEnableCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetAddressResolutionEnablePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetAddressResolutionEnablePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_security_command = match &command.child {CommandDataChild::LeSecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSecurityCommand"),};let le_set_address_resolution_enable = match &le_security_command.child {LeSecurityCommandDataChild::LeSetAddressResolutionEnable(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetAddressResolutionEnable"),};Self {command,le_security_command,le_set_address_resolution_enable,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_address_resolution_enable(&self) -> Enable{ self.le_set_address_resolution_enable.as_ref().address_resolution_enable}
}
impl Into<CommandPacket> for LeSetAddressResolutionEnablePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeSecurityCommandPacket> for LeSetAddressResolutionEnablePacket { fn into(self) -> LeSecurityCommandPacket {LeSecurityCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetAddressResolutionEnableBuilder { type ResponseType = LeSetAddressResolutionEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetAddressResolutionEnableCompletePacket::new(pkt.event.clone()) }}impl LeSetAddressResolutionEnableBuilder {pub fn build(self) -> LeSetAddressResolutionEnablePacket {let le_set_address_resolution_enable= Arc::new(LeSetAddressResolutionEnableData {address_resolution_enable: self.address_resolution_enable, });let le_security_command= Arc::new(LeSecurityCommandData {child: LeSecurityCommandDataChild::LeSetAddressResolutionEnable(le_set_address_resolution_enable),});let command= Arc::new(CommandData {op_code: OpCode::LeSetAddressResolutionEnable, child: CommandDataChild::LeSecurityCommand(le_security_command),});LeSetAddressResolutionEnablePacket::new(command)}
}
impl Into<CommandPacket> for LeSetAddressResolutionEnableBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeSecurityCommandPacket> for LeSetAddressResolutionEnableBuilder { fn into(self) -> LeSecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetAddressResolutionEnableCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeSetAddressResolutionEnableCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_address_resolution_enable_complete: Arc<LeSetAddressResolutionEnableCompleteData>,}
#[derive(Debug)] pub struct LeSetAddressResolutionEnableCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeSetAddressResolutionEnableCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetAddressResolutionEnableComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeSetAddressResolutionEnableCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetAddressResolutionEnableCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_address_resolution_enable_complete = match &command_complete.child {CommandCompleteDataChild::LeSetAddressResolutionEnableComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetAddressResolutionEnableComplete"),};Self {event,command_complete,le_set_address_resolution_enable_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_address_resolution_enable_complete.as_ref().status}
}
impl Into<EventPacket> for LeSetAddressResolutionEnableCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetAddressResolutionEnableCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetAddressResolutionEnableCompleteBuilder {pub fn build(self) -> LeSetAddressResolutionEnableCompletePacket {let le_set_address_resolution_enable_complete= Arc::new(LeSetAddressResolutionEnableCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetAddressResolutionEnable, child: CommandCompleteDataChild::LeSetAddressResolutionEnableComplete(le_set_address_resolution_enable_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetAddressResolutionEnableCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetAddressResolutionEnableCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetAddressResolutionEnableCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetResolvablePrivateAddressTimeoutData {rpa_timeout: u16, }
#[derive(Debug, Clone)] pub struct LeSetResolvablePrivateAddressTimeoutPacket {command: Arc<CommandData>,le_security_command: Arc<LeSecurityCommandData>,le_set_resolvable_private_address_timeout: Arc<LeSetResolvablePrivateAddressTimeoutData>,}
#[derive(Debug)] pub struct LeSetResolvablePrivateAddressTimeoutBuilder {pub rpa_timeout: u16, }
impl LeSetResolvablePrivateAddressTimeoutData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeSetResolvablePrivateAddressTimeout".to_string(),    field: "rpa_timeout".to_string(),    wanted: 5,    got: bytes.len()});}let rpa_timeout = u16::from_le_bytes([bytes[3],bytes[4]]);Ok(Self {rpa_timeout, })
}
fn write_to(&self, buffer: &mut BytesMut) {let rpa_timeout = self.rpa_timeout;buffer[3..5].copy_from_slice(&rpa_timeout.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for LeSetResolvablePrivateAddressTimeoutPacket { type ResponseType = LeSetResolvablePrivateAddressTimeoutCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetResolvablePrivateAddressTimeoutCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetResolvablePrivateAddressTimeoutPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetResolvablePrivateAddressTimeoutPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_security_command = match &command.child {CommandDataChild::LeSecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSecurityCommand"),};let le_set_resolvable_private_address_timeout = match &le_security_command.child {LeSecurityCommandDataChild::LeSetResolvablePrivateAddressTimeout(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetResolvablePrivateAddressTimeout"),};Self {command,le_security_command,le_set_resolvable_private_address_timeout,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_rpa_timeout(&self) -> u16{ self.le_set_resolvable_private_address_timeout.as_ref().rpa_timeout}
}
impl Into<CommandPacket> for LeSetResolvablePrivateAddressTimeoutPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeSecurityCommandPacket> for LeSetResolvablePrivateAddressTimeoutPacket { fn into(self) -> LeSecurityCommandPacket {LeSecurityCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetResolvablePrivateAddressTimeoutBuilder { type ResponseType = LeSetResolvablePrivateAddressTimeoutCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetResolvablePrivateAddressTimeoutCompletePacket::new(pkt.event.clone()) }}impl LeSetResolvablePrivateAddressTimeoutBuilder {pub fn build(self) -> LeSetResolvablePrivateAddressTimeoutPacket {let le_set_resolvable_private_address_timeout= Arc::new(LeSetResolvablePrivateAddressTimeoutData {rpa_timeout: self.rpa_timeout, });let le_security_command= Arc::new(LeSecurityCommandData {child: LeSecurityCommandDataChild::LeSetResolvablePrivateAddressTimeout(le_set_resolvable_private_address_timeout),});let command= Arc::new(CommandData {op_code: OpCode::LeSetResolvablePrivateAddressTimeout, child: CommandDataChild::LeSecurityCommand(le_security_command),});LeSetResolvablePrivateAddressTimeoutPacket::new(command)}
}
impl Into<CommandPacket> for LeSetResolvablePrivateAddressTimeoutBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeSecurityCommandPacket> for LeSetResolvablePrivateAddressTimeoutBuilder { fn into(self) -> LeSecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetResolvablePrivateAddressTimeoutCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeSetResolvablePrivateAddressTimeoutCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_resolvable_private_address_timeout_complete: Arc<LeSetResolvablePrivateAddressTimeoutCompleteData>,}
#[derive(Debug)] pub struct LeSetResolvablePrivateAddressTimeoutCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeSetResolvablePrivateAddressTimeoutCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetResolvablePrivateAddressTimeoutComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeSetResolvablePrivateAddressTimeoutCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetResolvablePrivateAddressTimeoutCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_resolvable_private_address_timeout_complete = match &command_complete.child {CommandCompleteDataChild::LeSetResolvablePrivateAddressTimeoutComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetResolvablePrivateAddressTimeoutComplete"),};Self {event,command_complete,le_set_resolvable_private_address_timeout_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_resolvable_private_address_timeout_complete.as_ref().status}
}
impl Into<EventPacket> for LeSetResolvablePrivateAddressTimeoutCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetResolvablePrivateAddressTimeoutCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetResolvablePrivateAddressTimeoutCompleteBuilder {pub fn build(self) -> LeSetResolvablePrivateAddressTimeoutCompletePacket {let le_set_resolvable_private_address_timeout_complete= Arc::new(LeSetResolvablePrivateAddressTimeoutCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetResolvablePrivateAddressTimeout, child: CommandCompleteDataChild::LeSetResolvablePrivateAddressTimeoutComplete(le_set_resolvable_private_address_timeout_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetResolvablePrivateAddressTimeoutCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetResolvablePrivateAddressTimeoutCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetResolvablePrivateAddressTimeoutCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeReadMaximumDataLengthData {}
#[derive(Debug, Clone)] pub struct LeReadMaximumDataLengthPacket {command: Arc<CommandData>,le_read_maximum_data_length: Arc<LeReadMaximumDataLengthData>,}
#[derive(Debug)] pub struct LeReadMaximumDataLengthBuilder {}
impl LeReadMaximumDataLengthData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeReadMaximumDataLengthPacket { type ResponseType = LeReadMaximumDataLengthCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadMaximumDataLengthCompletePacket::new(pkt.event.clone()) }}impl Packet for LeReadMaximumDataLengthPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadMaximumDataLengthPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_read_maximum_data_length = match &command.child {CommandDataChild::LeReadMaximumDataLength(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadMaximumDataLength"),};Self {command,le_read_maximum_data_length,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeReadMaximumDataLengthPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeReadMaximumDataLengthBuilder { type ResponseType = LeReadMaximumDataLengthCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadMaximumDataLengthCompletePacket::new(pkt.event.clone()) }}impl LeReadMaximumDataLengthBuilder {pub fn build(self) -> LeReadMaximumDataLengthPacket {let le_read_maximum_data_length= Arc::new(LeReadMaximumDataLengthData {});let command= Arc::new(CommandData {op_code: OpCode::LeReadMaximumDataLength, child: CommandDataChild::LeReadMaximumDataLength(le_read_maximum_data_length),});LeReadMaximumDataLengthPacket::new(command)}
}
impl Into<CommandPacket> for LeReadMaximumDataLengthBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LeReadMaximumDataLengthCompleteData {status: ErrorCode, le_maximum_data_length: LeMaximumDataLength, }
#[derive(Debug, Clone)] pub struct LeReadMaximumDataLengthCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_read_maximum_data_length_complete: Arc<LeReadMaximumDataLengthCompleteData>,}
#[derive(Debug)] pub struct LeReadMaximumDataLengthCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub le_maximum_data_length: LeMaximumDataLength, }
impl LeReadMaximumDataLengthCompleteData {fn conforms(bytes: &[u8]) -> bool {if !LeMaximumDataLength::conforms(&bytes[6..14]) { return false; } true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeReadMaximumDataLengthComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();let le_maximum_data_length = LeMaximumDataLength::parse(&bytes[6..14]).unwrap();Ok(Self {status, le_maximum_data_length, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let le_maximum_data_length = &mut buffer[6..14];self.le_maximum_data_length.write_to(le_maximum_data_length);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 9;ret}
}
impl Packet for LeReadMaximumDataLengthCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadMaximumDataLengthCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_read_maximum_data_length_complete = match &command_complete.child {CommandCompleteDataChild::LeReadMaximumDataLengthComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadMaximumDataLengthComplete"),};Self {event,command_complete,le_read_maximum_data_length_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_read_maximum_data_length_complete.as_ref().status}
pub fn get_le_maximum_data_length(&self) -> &LeMaximumDataLength{ &self.le_read_maximum_data_length_complete.as_ref().le_maximum_data_length}
}
impl Into<EventPacket> for LeReadMaximumDataLengthCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeReadMaximumDataLengthCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeReadMaximumDataLengthCompleteBuilder {pub fn build(self) -> LeReadMaximumDataLengthCompletePacket {let le_read_maximum_data_length_complete= Arc::new(LeReadMaximumDataLengthCompleteData {status: self.status, le_maximum_data_length: self.le_maximum_data_length, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeReadMaximumDataLength, child: CommandCompleteDataChild::LeReadMaximumDataLengthComplete(le_read_maximum_data_length_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeReadMaximumDataLengthCompletePacket::new(event)}
}
impl Into<EventPacket> for LeReadMaximumDataLengthCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeReadMaximumDataLengthCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeReadPhyData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct LeReadPhyPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,le_connection_management_command: Arc<LeConnectionManagementCommandData>,le_read_phy: Arc<LeReadPhyData>,}
#[derive(Debug)] pub struct LeReadPhyBuilder {pub connection_handle: u16, }
impl LeReadPhyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeReadPhy".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for LeReadPhyPacket { type ResponseType = LeReadPhyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadPhyCompletePacket::new(pkt.event.clone()) }}impl Packet for LeReadPhyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadPhyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let le_connection_management_command = match &acl_command.child {AclCommandDataChild::LeConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeConnectionManagementCommand"),};let le_read_phy = match &le_connection_management_command.child {LeConnectionManagementCommandDataChild::LeReadPhy(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadPhy"),};Self {command,acl_command,le_connection_management_command,le_read_phy,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_read_phy.as_ref().connection_handle}
}
impl Into<CommandPacket> for LeReadPhyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for LeReadPhyPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<LeConnectionManagementCommandPacket> for LeReadPhyPacket { fn into(self) -> LeConnectionManagementCommandPacket {LeConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for LeReadPhyBuilder { type ResponseType = LeReadPhyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadPhyCompletePacket::new(pkt.event.clone()) }}impl LeReadPhyBuilder {pub fn build(self) -> LeReadPhyPacket {let le_read_phy= Arc::new(LeReadPhyData {connection_handle: self.connection_handle, });let le_connection_management_command= Arc::new(LeConnectionManagementCommandData {child: LeConnectionManagementCommandDataChild::LeReadPhy(le_read_phy),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::LeConnectionManagementCommand(le_connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::LeReadPhy, child: CommandDataChild::AclCommand(acl_command),});LeReadPhyPacket::new(command)}
}
impl Into<CommandPacket> for LeReadPhyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for LeReadPhyBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<LeConnectionManagementCommandPacket> for LeReadPhyBuilder { fn into(self) -> LeConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeReadPhyCompleteData {status: ErrorCode, connection_handle: u16, tx_phy: PhyType, rx_phy: PhyType, }
#[derive(Debug, Clone)] pub struct LeReadPhyCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_read_phy_complete: Arc<LeReadPhyCompleteData>,}
#[derive(Debug)] pub struct LeReadPhyCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, pub tx_phy: PhyType, pub rx_phy: PhyType, }
impl LeReadPhyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeReadPhyComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeReadPhyComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeReadPhyComplete".to_string(),    field: "tx_phy".to_string(),    wanted: 9,    got: bytes.len()});}let tx_phy = u8::from_le_bytes([bytes[8]]);let tx_phy = PhyType::from_u8(tx_phy).unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeReadPhyComplete".to_string(),    field: "rx_phy".to_string(),    wanted: 10,    got: bytes.len()});}let rx_phy = u8::from_le_bytes([bytes[9]]);let rx_phy = PhyType::from_u8(rx_phy).unwrap();Ok(Self {status, connection_handle, tx_phy, rx_phy, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let tx_phy = self.tx_phy.to_u8().unwrap();buffer[8..9].copy_from_slice(&tx_phy.to_le_bytes()[0..1]);let rx_phy = self.rx_phy.to_u8().unwrap();buffer[9..10].copy_from_slice(&rx_phy.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 5;ret}
}
impl Packet for LeReadPhyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadPhyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_read_phy_complete = match &command_complete.child {CommandCompleteDataChild::LeReadPhyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadPhyComplete"),};Self {event,command_complete,le_read_phy_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_read_phy_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_read_phy_complete.as_ref().connection_handle}
pub fn get_tx_phy(&self) -> PhyType{ self.le_read_phy_complete.as_ref().tx_phy}
pub fn get_rx_phy(&self) -> PhyType{ self.le_read_phy_complete.as_ref().rx_phy}
}
impl Into<EventPacket> for LeReadPhyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeReadPhyCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeReadPhyCompleteBuilder {pub fn build(self) -> LeReadPhyCompletePacket {let le_read_phy_complete= Arc::new(LeReadPhyCompleteData {status: self.status, connection_handle: self.connection_handle, tx_phy: self.tx_phy, rx_phy: self.rx_phy, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeReadPhy, child: CommandCompleteDataChild::LeReadPhyComplete(le_read_phy_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeReadPhyCompletePacket::new(event)}
}
impl Into<EventPacket> for LeReadPhyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeReadPhyCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetDefaultPhyData {all_phys_no_transmit_preference: u8, all_phys_no_receive_preference: u8, tx_phys_bitmask: u8, rx_phys_bitmask: u8, }
#[derive(Debug, Clone)] pub struct LeSetDefaultPhyPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,le_connection_management_command: Arc<LeConnectionManagementCommandData>,le_set_default_phy: Arc<LeSetDefaultPhyData>,}
#[derive(Debug)] pub struct LeSetDefaultPhyBuilder {pub all_phys_no_transmit_preference: u8, pub all_phys_no_receive_preference: u8, pub tx_phys_bitmask: u8, pub rx_phys_bitmask: u8, }
impl LeSetDefaultPhyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {let all_phys_no_transmit_preference = u8::from_le_bytes([bytes[3]]);let all_phys_no_transmit_preference = all_phys_no_transmit_preference & 0x1;let all_phys_no_receive_preference = u8::from_le_bytes([bytes[3]]);let all_phys_no_receive_preference = all_phys_no_receive_preference >> 1;let all_phys_no_receive_preference = all_phys_no_receive_preference & 0x1;let tx_phys_bitmask = u8::from_le_bytes([bytes[4]]);let tx_phys_bitmask = tx_phys_bitmask & 0x7;let rx_phys_bitmask = u8::from_le_bytes([bytes[5]]);let rx_phys_bitmask = rx_phys_bitmask & 0x7;Ok(Self {all_phys_no_transmit_preference, all_phys_no_receive_preference, tx_phys_bitmask, rx_phys_bitmask, })
}
fn write_to(&self, buffer: &mut BytesMut) {let all_phys_no_transmit_preference = self.all_phys_no_transmit_preference;let all_phys_no_transmit_preference = all_phys_no_transmit_preference & 0x1;buffer[3..4].copy_from_slice(&all_phys_no_transmit_preference.to_le_bytes()[0..1]);let all_phys_no_receive_preference = self.all_phys_no_receive_preference;let all_phys_no_receive_preference = all_phys_no_receive_preference & 0x1;let all_phys_no_receive_preference = (all_phys_no_receive_preference << 1) | ((buffer[3] as u8) & 0x1);buffer[3..4].copy_from_slice(&all_phys_no_receive_preference.to_le_bytes()[0..1]);let tx_phys_bitmask = self.tx_phys_bitmask;let tx_phys_bitmask = tx_phys_bitmask & 0x7;buffer[4..5].copy_from_slice(&tx_phys_bitmask.to_le_bytes()[0..1]);let rx_phys_bitmask = self.rx_phys_bitmask;let rx_phys_bitmask = rx_phys_bitmask & 0x7;buffer[5..6].copy_from_slice(&rx_phys_bitmask.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl CommandExpectations for LeSetDefaultPhyPacket { type ResponseType = LeSetDefaultPhyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetDefaultPhyCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetDefaultPhyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetDefaultPhyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let le_connection_management_command = match &acl_command.child {AclCommandDataChild::LeConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeConnectionManagementCommand"),};let le_set_default_phy = match &le_connection_management_command.child {LeConnectionManagementCommandDataChild::LeSetDefaultPhy(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetDefaultPhy"),};Self {command,acl_command,le_connection_management_command,le_set_default_phy,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_all_phys_no_transmit_preference(&self) -> u8{ self.le_set_default_phy.as_ref().all_phys_no_transmit_preference}
pub fn get_all_phys_no_receive_preference(&self) -> u8{ self.le_set_default_phy.as_ref().all_phys_no_receive_preference}
pub fn get_tx_phys_bitmask(&self) -> u8{ self.le_set_default_phy.as_ref().tx_phys_bitmask}
pub fn get_rx_phys_bitmask(&self) -> u8{ self.le_set_default_phy.as_ref().rx_phys_bitmask}
}
impl Into<CommandPacket> for LeSetDefaultPhyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for LeSetDefaultPhyPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<LeConnectionManagementCommandPacket> for LeSetDefaultPhyPacket { fn into(self) -> LeConnectionManagementCommandPacket {LeConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetDefaultPhyBuilder { type ResponseType = LeSetDefaultPhyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetDefaultPhyCompletePacket::new(pkt.event.clone()) }}impl LeSetDefaultPhyBuilder {pub fn build(self) -> LeSetDefaultPhyPacket {let le_set_default_phy= Arc::new(LeSetDefaultPhyData {all_phys_no_transmit_preference: self.all_phys_no_transmit_preference, all_phys_no_receive_preference: self.all_phys_no_receive_preference, tx_phys_bitmask: self.tx_phys_bitmask, rx_phys_bitmask: self.rx_phys_bitmask, });let le_connection_management_command= Arc::new(LeConnectionManagementCommandData {child: LeConnectionManagementCommandDataChild::LeSetDefaultPhy(le_set_default_phy),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::LeConnectionManagementCommand(le_connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::LeSetDefaultPhy, child: CommandDataChild::AclCommand(acl_command),});LeSetDefaultPhyPacket::new(command)}
}
impl Into<CommandPacket> for LeSetDefaultPhyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for LeSetDefaultPhyBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<LeConnectionManagementCommandPacket> for LeSetDefaultPhyBuilder { fn into(self) -> LeConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetDefaultPhyCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeSetDefaultPhyCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_default_phy_complete: Arc<LeSetDefaultPhyCompleteData>,}
#[derive(Debug)] pub struct LeSetDefaultPhyCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeSetDefaultPhyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetDefaultPhyComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeSetDefaultPhyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetDefaultPhyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_default_phy_complete = match &command_complete.child {CommandCompleteDataChild::LeSetDefaultPhyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetDefaultPhyComplete"),};Self {event,command_complete,le_set_default_phy_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_default_phy_complete.as_ref().status}
}
impl Into<EventPacket> for LeSetDefaultPhyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetDefaultPhyCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetDefaultPhyCompleteBuilder {pub fn build(self) -> LeSetDefaultPhyCompletePacket {let le_set_default_phy_complete= Arc::new(LeSetDefaultPhyCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetDefaultPhy, child: CommandCompleteDataChild::LeSetDefaultPhyComplete(le_set_default_phy_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetDefaultPhyCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetDefaultPhyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetDefaultPhyCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetPhyData {connection_handle: u16, all_phys_no_transmit_preference: u8, all_phys_no_receive_preference: u8, tx_phys_bitmask: u8, rx_phys_bitmask: u8, phy_options: PhyOptions, }
#[derive(Debug, Clone)] pub struct LeSetPhyPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,le_connection_management_command: Arc<LeConnectionManagementCommandData>,le_set_phy: Arc<LeSetPhyData>,}
#[derive(Debug)] pub struct LeSetPhyBuilder {pub connection_handle: u16, pub all_phys_no_transmit_preference: u8, pub all_phys_no_receive_preference: u8, pub tx_phys_bitmask: u8, pub rx_phys_bitmask: u8, pub phy_options: PhyOptions, }
impl LeSetPhyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeSetPhy".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;let all_phys_no_transmit_preference = u8::from_le_bytes([bytes[5]]);let all_phys_no_transmit_preference = all_phys_no_transmit_preference & 0x1;let all_phys_no_receive_preference = u8::from_le_bytes([bytes[5]]);let all_phys_no_receive_preference = all_phys_no_receive_preference >> 1;let all_phys_no_receive_preference = all_phys_no_receive_preference & 0x1;let tx_phys_bitmask = u8::from_le_bytes([bytes[6]]);let tx_phys_bitmask = tx_phys_bitmask & 0x7;let rx_phys_bitmask = u8::from_le_bytes([bytes[7]]);let rx_phys_bitmask = rx_phys_bitmask & 0x7;if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeSetPhy".to_string(),    field: "phy_options".to_string(),    wanted: 9,    got: bytes.len()});}let phy_options = u8::from_le_bytes([bytes[8]]);let phy_options = PhyOptions::from_u8(phy_options).unwrap();Ok(Self {connection_handle, all_phys_no_transmit_preference, all_phys_no_receive_preference, tx_phys_bitmask, rx_phys_bitmask, phy_options, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let all_phys_no_transmit_preference = self.all_phys_no_transmit_preference;let all_phys_no_transmit_preference = all_phys_no_transmit_preference & 0x1;buffer[5..6].copy_from_slice(&all_phys_no_transmit_preference.to_le_bytes()[0..1]);let all_phys_no_receive_preference = self.all_phys_no_receive_preference;let all_phys_no_receive_preference = all_phys_no_receive_preference & 0x1;let all_phys_no_receive_preference = (all_phys_no_receive_preference << 1) | ((buffer[5] as u8) & 0x1);buffer[5..6].copy_from_slice(&all_phys_no_receive_preference.to_le_bytes()[0..1]);let tx_phys_bitmask = self.tx_phys_bitmask;let tx_phys_bitmask = tx_phys_bitmask & 0x7;buffer[6..7].copy_from_slice(&tx_phys_bitmask.to_le_bytes()[0..1]);let rx_phys_bitmask = self.rx_phys_bitmask;let rx_phys_bitmask = rx_phys_bitmask & 0x7;buffer[7..8].copy_from_slice(&rx_phys_bitmask.to_le_bytes()[0..1]);let phy_options = self.phy_options.to_u8().unwrap();buffer[8..9].copy_from_slice(&phy_options.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl CommandExpectations for LeSetPhyPacket { type ResponseType = LeSetPhyStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetPhyStatusPacket::new(pkt.event.clone()) }}impl Packet for LeSetPhyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetPhyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let le_connection_management_command = match &acl_command.child {AclCommandDataChild::LeConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeConnectionManagementCommand"),};let le_set_phy = match &le_connection_management_command.child {LeConnectionManagementCommandDataChild::LeSetPhy(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetPhy"),};Self {command,acl_command,le_connection_management_command,le_set_phy,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_set_phy.as_ref().connection_handle}
pub fn get_all_phys_no_transmit_preference(&self) -> u8{ self.le_set_phy.as_ref().all_phys_no_transmit_preference}
pub fn get_all_phys_no_receive_preference(&self) -> u8{ self.le_set_phy.as_ref().all_phys_no_receive_preference}
pub fn get_tx_phys_bitmask(&self) -> u8{ self.le_set_phy.as_ref().tx_phys_bitmask}
pub fn get_rx_phys_bitmask(&self) -> u8{ self.le_set_phy.as_ref().rx_phys_bitmask}
pub fn get_phy_options(&self) -> PhyOptions{ self.le_set_phy.as_ref().phy_options}
}
impl Into<CommandPacket> for LeSetPhyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for LeSetPhyPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<LeConnectionManagementCommandPacket> for LeSetPhyPacket { fn into(self) -> LeConnectionManagementCommandPacket {LeConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetPhyBuilder { type ResponseType = LeSetPhyStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetPhyStatusPacket::new(pkt.event.clone()) }}impl LeSetPhyBuilder {pub fn build(self) -> LeSetPhyPacket {let le_set_phy= Arc::new(LeSetPhyData {connection_handle: self.connection_handle, all_phys_no_transmit_preference: self.all_phys_no_transmit_preference, all_phys_no_receive_preference: self.all_phys_no_receive_preference, tx_phys_bitmask: self.tx_phys_bitmask, rx_phys_bitmask: self.rx_phys_bitmask, phy_options: self.phy_options, });let le_connection_management_command= Arc::new(LeConnectionManagementCommandData {child: LeConnectionManagementCommandDataChild::LeSetPhy(le_set_phy),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::LeConnectionManagementCommand(le_connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::LeSetPhy, child: CommandDataChild::AclCommand(acl_command),});LeSetPhyPacket::new(command)}
}
impl Into<CommandPacket> for LeSetPhyBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for LeSetPhyBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<LeConnectionManagementCommandPacket> for LeSetPhyBuilder { fn into(self) -> LeConnectionManagementCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetPhyStatusData {}
#[derive(Debug, Clone)] pub struct LeSetPhyStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,le_set_phy_status: Arc<LeSetPhyStatusData>,}
#[derive(Debug)] pub struct LeSetPhyStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl LeSetPhyStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeSetPhyStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetPhyStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let le_set_phy_status = match &command_status.child {CommandStatusDataChild::LeSetPhyStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetPhyStatus"),};Self {event,command_status,le_set_phy_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for LeSetPhyStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for LeSetPhyStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl LeSetPhyStatusBuilder {pub fn build(self) -> LeSetPhyStatusPacket {let le_set_phy_status= Arc::new(LeSetPhyStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetPhy, child: CommandStatusDataChild::LeSetPhyStatus(le_set_phy_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});LeSetPhyStatusPacket::new(event)}
}
impl Into<EventPacket> for LeSetPhyStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for LeSetPhyStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct LeEnhancedReceiverTestData {rx_channel: u8, phy: PhyType, modulation_index: ModulationIndex, }
#[derive(Debug, Clone)] pub struct LeEnhancedReceiverTestPacket {command: Arc<CommandData>,le_enhanced_receiver_test: Arc<LeEnhancedReceiverTestData>,}
#[derive(Debug)] pub struct LeEnhancedReceiverTestBuilder {pub rx_channel: u8, pub phy: PhyType, pub modulation_index: ModulationIndex, }
impl LeEnhancedReceiverTestData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedReceiverTest".to_string(),    field: "rx_channel".to_string(),    wanted: 4,    got: bytes.len()});}let rx_channel = u8::from_le_bytes([bytes[3]]);if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedReceiverTest".to_string(),    field: "phy".to_string(),    wanted: 5,    got: bytes.len()});}let phy = u8::from_le_bytes([bytes[4]]);let phy = PhyType::from_u8(phy).unwrap();if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedReceiverTest".to_string(),    field: "modulation_index".to_string(),    wanted: 6,    got: bytes.len()});}let modulation_index = u8::from_le_bytes([bytes[5]]);let modulation_index = ModulationIndex::from_u8(modulation_index).unwrap();Ok(Self {rx_channel, phy, modulation_index, })
}
fn write_to(&self, buffer: &mut BytesMut) {let rx_channel = self.rx_channel;buffer[3..4].copy_from_slice(&rx_channel.to_le_bytes()[0..1]);let phy = self.phy.to_u8().unwrap();buffer[4..5].copy_from_slice(&phy.to_le_bytes()[0..1]);let modulation_index = self.modulation_index.to_u8().unwrap();buffer[5..6].copy_from_slice(&modulation_index.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl CommandExpectations for LeEnhancedReceiverTestPacket { type ResponseType = LeEnhancedReceiverTestCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeEnhancedReceiverTestCompletePacket::new(pkt.event.clone()) }}impl Packet for LeEnhancedReceiverTestPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeEnhancedReceiverTestPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_enhanced_receiver_test = match &command.child {CommandDataChild::LeEnhancedReceiverTest(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeEnhancedReceiverTest"),};Self {command,le_enhanced_receiver_test,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_rx_channel(&self) -> u8{ self.le_enhanced_receiver_test.as_ref().rx_channel}
pub fn get_phy(&self) -> PhyType{ self.le_enhanced_receiver_test.as_ref().phy}
pub fn get_modulation_index(&self) -> ModulationIndex{ self.le_enhanced_receiver_test.as_ref().modulation_index}
}
impl Into<CommandPacket> for LeEnhancedReceiverTestPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeEnhancedReceiverTestBuilder { type ResponseType = LeEnhancedReceiverTestCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeEnhancedReceiverTestCompletePacket::new(pkt.event.clone()) }}impl LeEnhancedReceiverTestBuilder {pub fn build(self) -> LeEnhancedReceiverTestPacket {let le_enhanced_receiver_test= Arc::new(LeEnhancedReceiverTestData {rx_channel: self.rx_channel, phy: self.phy, modulation_index: self.modulation_index, });let command= Arc::new(CommandData {op_code: OpCode::LeEnhancedReceiverTest, child: CommandDataChild::LeEnhancedReceiverTest(le_enhanced_receiver_test),});LeEnhancedReceiverTestPacket::new(command)}
}
impl Into<CommandPacket> for LeEnhancedReceiverTestBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LeEnhancedReceiverTestCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeEnhancedReceiverTestCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_enhanced_receiver_test_complete: Arc<LeEnhancedReceiverTestCompleteData>,}
#[derive(Debug)] pub struct LeEnhancedReceiverTestCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeEnhancedReceiverTestCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedReceiverTestComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeEnhancedReceiverTestCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeEnhancedReceiverTestCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_enhanced_receiver_test_complete = match &command_complete.child {CommandCompleteDataChild::LeEnhancedReceiverTestComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeEnhancedReceiverTestComplete"),};Self {event,command_complete,le_enhanced_receiver_test_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_enhanced_receiver_test_complete.as_ref().status}
}
impl Into<EventPacket> for LeEnhancedReceiverTestCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeEnhancedReceiverTestCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeEnhancedReceiverTestCompleteBuilder {pub fn build(self) -> LeEnhancedReceiverTestCompletePacket {let le_enhanced_receiver_test_complete= Arc::new(LeEnhancedReceiverTestCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeEnhancedReceiverTest, child: CommandCompleteDataChild::LeEnhancedReceiverTestComplete(le_enhanced_receiver_test_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeEnhancedReceiverTestCompletePacket::new(event)}
}
impl Into<EventPacket> for LeEnhancedReceiverTestCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeEnhancedReceiverTestCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeEnhancedTransmitterTestData {tx_channel: u8, test_data_length: u8, packet_payload: LeTestPayload, phy: PhyType, }
#[derive(Debug, Clone)] pub struct LeEnhancedTransmitterTestPacket {command: Arc<CommandData>,le_enhanced_transmitter_test: Arc<LeEnhancedTransmitterTestData>,}
#[derive(Debug)] pub struct LeEnhancedTransmitterTestBuilder {pub tx_channel: u8, pub test_data_length: u8, pub packet_payload: LeTestPayload, pub phy: PhyType, }
impl LeEnhancedTransmitterTestData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedTransmitterTest".to_string(),    field: "tx_channel".to_string(),    wanted: 4,    got: bytes.len()});}let tx_channel = u8::from_le_bytes([bytes[3]]);if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedTransmitterTest".to_string(),    field: "test_data_length".to_string(),    wanted: 5,    got: bytes.len()});}let test_data_length = u8::from_le_bytes([bytes[4]]);if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedTransmitterTest".to_string(),    field: "packet_payload".to_string(),    wanted: 6,    got: bytes.len()});}let packet_payload = u8::from_le_bytes([bytes[5]]);let packet_payload = LeTestPayload::from_u8(packet_payload).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedTransmitterTest".to_string(),    field: "phy".to_string(),    wanted: 7,    got: bytes.len()});}let phy = u8::from_le_bytes([bytes[6]]);let phy = PhyType::from_u8(phy).unwrap();Ok(Self {tx_channel, test_data_length, packet_payload, phy, })
}
fn write_to(&self, buffer: &mut BytesMut) {let tx_channel = self.tx_channel;buffer[3..4].copy_from_slice(&tx_channel.to_le_bytes()[0..1]);let test_data_length = self.test_data_length;buffer[4..5].copy_from_slice(&test_data_length.to_le_bytes()[0..1]);let packet_payload = self.packet_payload.to_u8().unwrap();buffer[5..6].copy_from_slice(&packet_payload.to_le_bytes()[0..1]);let phy = self.phy.to_u8().unwrap();buffer[6..7].copy_from_slice(&phy.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl CommandExpectations for LeEnhancedTransmitterTestPacket { type ResponseType = LeEnhancedTransmitterTestCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeEnhancedTransmitterTestCompletePacket::new(pkt.event.clone()) }}impl Packet for LeEnhancedTransmitterTestPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeEnhancedTransmitterTestPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_enhanced_transmitter_test = match &command.child {CommandDataChild::LeEnhancedTransmitterTest(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeEnhancedTransmitterTest"),};Self {command,le_enhanced_transmitter_test,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_tx_channel(&self) -> u8{ self.le_enhanced_transmitter_test.as_ref().tx_channel}
pub fn get_test_data_length(&self) -> u8{ self.le_enhanced_transmitter_test.as_ref().test_data_length}
pub fn get_packet_payload(&self) -> LeTestPayload{ self.le_enhanced_transmitter_test.as_ref().packet_payload}
pub fn get_phy(&self) -> PhyType{ self.le_enhanced_transmitter_test.as_ref().phy}
}
impl Into<CommandPacket> for LeEnhancedTransmitterTestPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeEnhancedTransmitterTestBuilder { type ResponseType = LeEnhancedTransmitterTestCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeEnhancedTransmitterTestCompletePacket::new(pkt.event.clone()) }}impl LeEnhancedTransmitterTestBuilder {pub fn build(self) -> LeEnhancedTransmitterTestPacket {let le_enhanced_transmitter_test= Arc::new(LeEnhancedTransmitterTestData {tx_channel: self.tx_channel, test_data_length: self.test_data_length, packet_payload: self.packet_payload, phy: self.phy, });let command= Arc::new(CommandData {op_code: OpCode::LeEnhancedTransmitterTest, child: CommandDataChild::LeEnhancedTransmitterTest(le_enhanced_transmitter_test),});LeEnhancedTransmitterTestPacket::new(command)}
}
impl Into<CommandPacket> for LeEnhancedTransmitterTestBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LeEnhancedTransmitterTestCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeEnhancedTransmitterTestCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_enhanced_transmitter_test_complete: Arc<LeEnhancedTransmitterTestCompleteData>,}
#[derive(Debug)] pub struct LeEnhancedTransmitterTestCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeEnhancedTransmitterTestCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedTransmitterTestComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeEnhancedTransmitterTestCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeEnhancedTransmitterTestCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_enhanced_transmitter_test_complete = match &command_complete.child {CommandCompleteDataChild::LeEnhancedTransmitterTestComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeEnhancedTransmitterTestComplete"),};Self {event,command_complete,le_enhanced_transmitter_test_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_enhanced_transmitter_test_complete.as_ref().status}
}
impl Into<EventPacket> for LeEnhancedTransmitterTestCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeEnhancedTransmitterTestCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeEnhancedTransmitterTestCompleteBuilder {pub fn build(self) -> LeEnhancedTransmitterTestCompletePacket {let le_enhanced_transmitter_test_complete= Arc::new(LeEnhancedTransmitterTestCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeEnhancedTransmitterTest, child: CommandCompleteDataChild::LeEnhancedTransmitterTestComplete(le_enhanced_transmitter_test_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeEnhancedTransmitterTestCompletePacket::new(event)}
}
impl Into<EventPacket> for LeEnhancedTransmitterTestCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeEnhancedTransmitterTestCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetExtendedAdvertisingRandomAddressData {advertising_handle: u8, advertising_random_address: Address, }
#[derive(Debug, Clone)] pub struct LeSetExtendedAdvertisingRandomAddressPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_set_extended_advertising_random_address: Arc<LeSetExtendedAdvertisingRandomAddressData>,}
#[derive(Debug)] pub struct LeSetExtendedAdvertisingRandomAddressBuilder {pub advertising_handle: u8, pub advertising_random_address: Address, }
impl LeSetExtendedAdvertisingRandomAddressData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingRandomAddress".to_string(),    field: "advertising_handle".to_string(),    wanted: 4,    got: bytes.len()});}let advertising_handle = u8::from_le_bytes([bytes[3]]);if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingRandomAddress".to_string(),    field: "advertising_random_address".to_string(),    wanted: 10,    got: bytes.len()});}let advertising_random_address = bytes[4..10].try_into().unwrap();Ok(Self {advertising_handle, advertising_random_address, })
}
fn write_to(&self, buffer: &mut BytesMut) {let advertising_handle = self.advertising_handle;buffer[3..4].copy_from_slice(&advertising_handle.to_le_bytes()[0..1]);let advertising_random_address: [u8; 6] = self.advertising_random_address.into();buffer[4..10].copy_from_slice(&advertising_random_address);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl CommandExpectations for LeSetExtendedAdvertisingRandomAddressPacket { type ResponseType = LeSetExtendedAdvertisingRandomAddressCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetExtendedAdvertisingRandomAddressCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetExtendedAdvertisingRandomAddressPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetExtendedAdvertisingRandomAddressPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_set_extended_advertising_random_address = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingRandomAddress(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetExtendedAdvertisingRandomAddress"),};Self {command,le_advertising_command,le_set_extended_advertising_random_address,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_advertising_handle(&self) -> u8{ self.le_set_extended_advertising_random_address.as_ref().advertising_handle}
pub fn get_advertising_random_address(&self) -> Address{ self.le_set_extended_advertising_random_address.as_ref().advertising_random_address}
}
impl Into<CommandPacket> for LeSetExtendedAdvertisingRandomAddressPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeSetExtendedAdvertisingRandomAddressPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetExtendedAdvertisingRandomAddressBuilder { type ResponseType = LeSetExtendedAdvertisingRandomAddressCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetExtendedAdvertisingRandomAddressCompletePacket::new(pkt.event.clone()) }}impl LeSetExtendedAdvertisingRandomAddressBuilder {pub fn build(self) -> LeSetExtendedAdvertisingRandomAddressPacket {let le_set_extended_advertising_random_address= Arc::new(LeSetExtendedAdvertisingRandomAddressData {advertising_handle: self.advertising_handle, advertising_random_address: self.advertising_random_address, });let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingRandomAddress(le_set_extended_advertising_random_address),});let command= Arc::new(CommandData {op_code: OpCode::LeSetExtendedAdvertisingRandomAddress, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeSetExtendedAdvertisingRandomAddressPacket::new(command)}
}
impl Into<CommandPacket> for LeSetExtendedAdvertisingRandomAddressBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeSetExtendedAdvertisingRandomAddressBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}
macro_rules! le_set_extended_advertising_random_address_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::LeAdvertisingCommand(le_advertising_command_packet) => {match le_advertising_command_packet.specialize() {/* (2) */
LeAdvertisingCommandChild::LeSetExtendedAdvertisingRandomAddress(packet) => {let rebuilder = LeSetExtendedAdvertisingRandomAddressBuilder {advertising_handle : packet.get_advertising_handle(),advertising_random_address : packet.get_advertising_random_address(),};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse le_set_extended_advertising_random_address{:02x?}", le_advertising_command_packet); }}}_ => {println!("Couldn't parse le_advertising_command{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}le_set_extended_advertising_random_address_builder_tests! { le_set_extended_advertising_random_address_builder_test_00: b"\x35\x20\x07\x00\x77\x58\xeb\xd3\x1c\x6e",}


#[derive(Debug)] struct LeSetExtendedAdvertisingRandomAddressCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeSetExtendedAdvertisingRandomAddressCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_extended_advertising_random_address_complete: Arc<LeSetExtendedAdvertisingRandomAddressCompleteData>,}
#[derive(Debug)] pub struct LeSetExtendedAdvertisingRandomAddressCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeSetExtendedAdvertisingRandomAddressCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingRandomAddressComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeSetExtendedAdvertisingRandomAddressCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetExtendedAdvertisingRandomAddressCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_extended_advertising_random_address_complete = match &command_complete.child {CommandCompleteDataChild::LeSetExtendedAdvertisingRandomAddressComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetExtendedAdvertisingRandomAddressComplete"),};Self {event,command_complete,le_set_extended_advertising_random_address_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_extended_advertising_random_address_complete.as_ref().status}
}
impl Into<EventPacket> for LeSetExtendedAdvertisingRandomAddressCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetExtendedAdvertisingRandomAddressCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetExtendedAdvertisingRandomAddressCompleteBuilder {pub fn build(self) -> LeSetExtendedAdvertisingRandomAddressCompletePacket {let le_set_extended_advertising_random_address_complete= Arc::new(LeSetExtendedAdvertisingRandomAddressCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetExtendedAdvertisingRandomAddress, child: CommandCompleteDataChild::LeSetExtendedAdvertisingRandomAddressComplete(le_set_extended_advertising_random_address_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetExtendedAdvertisingRandomAddressCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetExtendedAdvertisingRandomAddressCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetExtendedAdvertisingRandomAddressCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! le_set_extended_advertising_random_address_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::LeSetExtendedAdvertisingRandomAddressComplete(packet) => {let rebuilder = LeSetExtendedAdvertisingRandomAddressCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse le_set_extended_advertising_random_address_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}le_set_extended_advertising_random_address_complete_builder_tests! { le_set_extended_advertising_random_address_complete_builder_test_00: b"\x0e\x04\x01\x35\x20\x00",}


#[derive(Debug)] struct LeSetExtendedAdvertisingLegacyParametersData {advertising_handle: u8, advertising_event_legacy_properties: LegacyAdvertisingProperties, primary_advertising_interval_min: u32, primary_advertising_interval_max: u32, primary_advertising_channel_map: u8, own_address_type: OwnAddressType, peer_address_type: PeerAddressType, peer_address: Address, advertising_filter_policy: AdvertisingFilterPolicy, advertising_tx_power: u8, advertising_sid: u8, scan_request_notification_enable: Enable, }
#[derive(Debug, Clone)] pub struct LeSetExtendedAdvertisingLegacyParametersPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_set_extended_advertising_legacy_parameters: Arc<LeSetExtendedAdvertisingLegacyParametersData>,}
#[derive(Debug)] pub struct LeSetExtendedAdvertisingLegacyParametersBuilder {pub advertising_handle: u8, pub advertising_event_legacy_properties: LegacyAdvertisingProperties, pub primary_advertising_interval_min: u32, pub primary_advertising_interval_max: u32, pub primary_advertising_channel_map: u8, pub own_address_type: OwnAddressType, pub peer_address_type: PeerAddressType, pub peer_address: Address, pub advertising_filter_policy: AdvertisingFilterPolicy, pub advertising_tx_power: u8, pub advertising_sid: u8, pub scan_request_notification_enable: Enable, }
impl LeSetExtendedAdvertisingLegacyParametersData {fn conforms(bytes: &[u8]) -> bool {let fixed_scalar1 = u8::from_le_bytes([bytes[4]]);let fixed_scalar1 = fixed_scalar1 >> 4;let fixed_scalar1 = fixed_scalar1 & 0x1;if fixed_scalar1 != 1 { return false; } let fixed_scalar2 = u8::from_le_bytes([bytes[23]]);if fixed_scalar2 != 1 { return false; } let fixed_scalar3 = u8::from_le_bytes([bytes[25]]);if fixed_scalar3 != 1 { return false; }  true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingLegacyParameters".to_string(),    field: "advertising_handle".to_string(),    wanted: 4,    got: bytes.len()});}let advertising_handle = u8::from_le_bytes([bytes[3]]);let advertising_event_legacy_properties = u8::from_le_bytes([bytes[4]]);let advertising_event_legacy_properties = advertising_event_legacy_properties & 0xf;let advertising_event_legacy_properties = LegacyAdvertisingProperties::from_u8(advertising_event_legacy_properties).unwrap();let fixed_scalar1 = u8::from_le_bytes([bytes[4]]);let fixed_scalar1 = fixed_scalar1 >> 4;let fixed_scalar1 = fixed_scalar1 & 0x1;if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingLegacyParameters".to_string(),    field: "primary_advertising_interval_min".to_string(),    wanted: 9,    got: bytes.len()});}let primary_advertising_interval_min = u32::from_le_bytes([bytes[6],bytes[7],bytes[8],0]);let primary_advertising_interval_min = primary_advertising_interval_min & 0xffffff;if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingLegacyParameters".to_string(),    field: "primary_advertising_interval_max".to_string(),    wanted: 12,    got: bytes.len()});}let primary_advertising_interval_max = u32::from_le_bytes([bytes[9],bytes[10],bytes[11],0]);let primary_advertising_interval_max = primary_advertising_interval_max & 0xffffff;let primary_advertising_channel_map = u8::from_le_bytes([bytes[12]]);let primary_advertising_channel_map = primary_advertising_channel_map & 0x7;if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingLegacyParameters".to_string(),    field: "own_address_type".to_string(),    wanted: 14,    got: bytes.len()});}let own_address_type = u8::from_le_bytes([bytes[13]]);let own_address_type = OwnAddressType::from_u8(own_address_type).unwrap();if bytes.len() < 15 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingLegacyParameters".to_string(),    field: "peer_address_type".to_string(),    wanted: 15,    got: bytes.len()});}let peer_address_type = u8::from_le_bytes([bytes[14]]);let peer_address_type = PeerAddressType::from_u8(peer_address_type).unwrap();if bytes.len() < 21 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingLegacyParameters".to_string(),    field: "peer_address".to_string(),    wanted: 21,    got: bytes.len()});}let peer_address = bytes[15..21].try_into().unwrap();let advertising_filter_policy = u8::from_le_bytes([bytes[21]]);let advertising_filter_policy = advertising_filter_policy & 0x3;let advertising_filter_policy = AdvertisingFilterPolicy::from_u8(advertising_filter_policy).unwrap();if bytes.len() < 23 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingLegacyParameters".to_string(),    field: "advertising_tx_power".to_string(),    wanted: 23,    got: bytes.len()});}let advertising_tx_power = u8::from_le_bytes([bytes[22]]);if bytes.len() < 24 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingLegacyParameters".to_string(),    field: "fixed_scalar2".to_string(),    wanted: 24,    got: bytes.len()});}let fixed_scalar2 = u8::from_le_bytes([bytes[23]]);if bytes.len() < 26 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingLegacyParameters".to_string(),    field: "fixed_scalar3".to_string(),    wanted: 26,    got: bytes.len()});}let fixed_scalar3 = u8::from_le_bytes([bytes[25]]);if bytes.len() < 27 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingLegacyParameters".to_string(),    field: "advertising_sid".to_string(),    wanted: 27,    got: bytes.len()});}let advertising_sid = u8::from_le_bytes([bytes[26]]);if bytes.len() < 28 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingLegacyParameters".to_string(),    field: "scan_request_notification_enable".to_string(),    wanted: 28,    got: bytes.len()});}let scan_request_notification_enable = u8::from_le_bytes([bytes[27]]);let scan_request_notification_enable = Enable::from_u8(scan_request_notification_enable).unwrap();Ok(Self {advertising_handle, advertising_event_legacy_properties, primary_advertising_interval_min, primary_advertising_interval_max, primary_advertising_channel_map, own_address_type, peer_address_type, peer_address, advertising_filter_policy, advertising_tx_power, advertising_sid, scan_request_notification_enable, })
}
fn write_to(&self, buffer: &mut BytesMut) {let advertising_handle = self.advertising_handle;buffer[3..4].copy_from_slice(&advertising_handle.to_le_bytes()[0..1]);let advertising_event_legacy_properties = self.advertising_event_legacy_properties.to_u8().unwrap();let advertising_event_legacy_properties = advertising_event_legacy_properties & 0xf;buffer[4..5].copy_from_slice(&advertising_event_legacy_properties.to_le_bytes()[0..1]);let fixed_scalar1: u8 = 1;let fixed_scalar1 = fixed_scalar1 & 0x1;let fixed_scalar1 = (fixed_scalar1 << 4) | ((buffer[4] as u8) & 0xf);buffer[4..5].copy_from_slice(&fixed_scalar1.to_le_bytes()[0..1]);let primary_advertising_interval_min = self.primary_advertising_interval_min;let primary_advertising_interval_min = primary_advertising_interval_min & 0xffffff;buffer[6..9].copy_from_slice(&primary_advertising_interval_min.to_le_bytes()[0..3]);let primary_advertising_interval_max = self.primary_advertising_interval_max;let primary_advertising_interval_max = primary_advertising_interval_max & 0xffffff;buffer[9..12].copy_from_slice(&primary_advertising_interval_max.to_le_bytes()[0..3]);let primary_advertising_channel_map = self.primary_advertising_channel_map;let primary_advertising_channel_map = primary_advertising_channel_map & 0x7;buffer[12..13].copy_from_slice(&primary_advertising_channel_map.to_le_bytes()[0..1]);let own_address_type = self.own_address_type.to_u8().unwrap();buffer[13..14].copy_from_slice(&own_address_type.to_le_bytes()[0..1]);let peer_address_type = self.peer_address_type.to_u8().unwrap();buffer[14..15].copy_from_slice(&peer_address_type.to_le_bytes()[0..1]);let peer_address: [u8; 6] = self.peer_address.into();buffer[15..21].copy_from_slice(&peer_address);let advertising_filter_policy = self.advertising_filter_policy.to_u8().unwrap();let advertising_filter_policy = advertising_filter_policy & 0x3;buffer[21..22].copy_from_slice(&advertising_filter_policy.to_le_bytes()[0..1]);let advertising_tx_power = self.advertising_tx_power;buffer[22..23].copy_from_slice(&advertising_tx_power.to_le_bytes()[0..1]);let fixed_scalar2: u8 = 1;buffer[23..24].copy_from_slice(&fixed_scalar2.to_le_bytes()[0..1]);let fixed_scalar3: u8 = 1;buffer[25..26].copy_from_slice(&fixed_scalar3.to_le_bytes()[0..1]);let advertising_sid = self.advertising_sid;buffer[26..27].copy_from_slice(&advertising_sid.to_le_bytes()[0..1]);let scan_request_notification_enable = self.scan_request_notification_enable.to_u8().unwrap();buffer[27..28].copy_from_slice(&scan_request_notification_enable.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 25;ret}
}
impl CommandExpectations for LeSetExtendedAdvertisingLegacyParametersPacket { type ResponseType = LeSetExtendedAdvertisingParametersCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetExtendedAdvertisingParametersCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetExtendedAdvertisingLegacyParametersPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetExtendedAdvertisingLegacyParametersPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_set_extended_advertising_legacy_parameters = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingLegacyParameters(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetExtendedAdvertisingLegacyParameters"),};Self {command,le_advertising_command,le_set_extended_advertising_legacy_parameters,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_advertising_handle(&self) -> u8{ self.le_set_extended_advertising_legacy_parameters.as_ref().advertising_handle}
pub fn get_advertising_event_legacy_properties(&self) -> LegacyAdvertisingProperties{ self.le_set_extended_advertising_legacy_parameters.as_ref().advertising_event_legacy_properties}
pub fn get_primary_advertising_interval_min(&self) -> u32{ self.le_set_extended_advertising_legacy_parameters.as_ref().primary_advertising_interval_min}
pub fn get_primary_advertising_interval_max(&self) -> u32{ self.le_set_extended_advertising_legacy_parameters.as_ref().primary_advertising_interval_max}
pub fn get_primary_advertising_channel_map(&self) -> u8{ self.le_set_extended_advertising_legacy_parameters.as_ref().primary_advertising_channel_map}
pub fn get_own_address_type(&self) -> OwnAddressType{ self.le_set_extended_advertising_legacy_parameters.as_ref().own_address_type}
pub fn get_peer_address_type(&self) -> PeerAddressType{ self.le_set_extended_advertising_legacy_parameters.as_ref().peer_address_type}
pub fn get_peer_address(&self) -> Address{ self.le_set_extended_advertising_legacy_parameters.as_ref().peer_address}
pub fn get_advertising_filter_policy(&self) -> AdvertisingFilterPolicy{ self.le_set_extended_advertising_legacy_parameters.as_ref().advertising_filter_policy}
pub fn get_advertising_tx_power(&self) -> u8{ self.le_set_extended_advertising_legacy_parameters.as_ref().advertising_tx_power}
pub fn get_advertising_sid(&self) -> u8{ self.le_set_extended_advertising_legacy_parameters.as_ref().advertising_sid}
pub fn get_scan_request_notification_enable(&self) -> Enable{ self.le_set_extended_advertising_legacy_parameters.as_ref().scan_request_notification_enable}
}
impl Into<CommandPacket> for LeSetExtendedAdvertisingLegacyParametersPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeSetExtendedAdvertisingLegacyParametersPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetExtendedAdvertisingLegacyParametersBuilder { type ResponseType = LeSetExtendedAdvertisingParametersCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetExtendedAdvertisingParametersCompletePacket::new(pkt.event.clone()) }}impl LeSetExtendedAdvertisingLegacyParametersBuilder {pub fn build(self) -> LeSetExtendedAdvertisingLegacyParametersPacket {let le_set_extended_advertising_legacy_parameters= Arc::new(LeSetExtendedAdvertisingLegacyParametersData {advertising_handle: self.advertising_handle, advertising_event_legacy_properties: self.advertising_event_legacy_properties, primary_advertising_interval_min: self.primary_advertising_interval_min, primary_advertising_interval_max: self.primary_advertising_interval_max, primary_advertising_channel_map: self.primary_advertising_channel_map, own_address_type: self.own_address_type, peer_address_type: self.peer_address_type, peer_address: self.peer_address, advertising_filter_policy: self.advertising_filter_policy, advertising_tx_power: self.advertising_tx_power, advertising_sid: self.advertising_sid, scan_request_notification_enable: self.scan_request_notification_enable, });let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingLegacyParameters(le_set_extended_advertising_legacy_parameters),});let command= Arc::new(CommandData {op_code: OpCode::LeSetExtendedAdvertisingParameters, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeSetExtendedAdvertisingLegacyParametersPacket::new(command)}
}
impl Into<CommandPacket> for LeSetExtendedAdvertisingLegacyParametersBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeSetExtendedAdvertisingLegacyParametersBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}
macro_rules! le_set_extended_advertising_legacy_parameters_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::LeAdvertisingCommand(le_advertising_command_packet) => {match le_advertising_command_packet.specialize() {/* (2) */
LeAdvertisingCommandChild::LeSetExtendedAdvertisingLegacyParameters(packet) => {let rebuilder = LeSetExtendedAdvertisingLegacyParametersBuilder {advertising_handle : packet.get_advertising_handle(),advertising_event_legacy_properties : packet.get_advertising_event_legacy_properties(),primary_advertising_interval_min : packet.get_primary_advertising_interval_min(),primary_advertising_interval_max : packet.get_primary_advertising_interval_max(),primary_advertising_channel_map : packet.get_primary_advertising_channel_map(),own_address_type : packet.get_own_address_type(),peer_address_type : packet.get_peer_address_type(),peer_address : packet.get_peer_address(),advertising_filter_policy : packet.get_advertising_filter_policy(),advertising_tx_power : packet.get_advertising_tx_power(),advertising_sid : packet.get_advertising_sid(),scan_request_notification_enable : packet.get_scan_request_notification_enable(),};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse le_set_extended_advertising_legacy_parameters{:02x?}", le_advertising_command_packet); }}}_ => {println!("Couldn't parse le_advertising_command{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}le_set_extended_advertising_legacy_parameters_builder_tests! { le_set_extended_advertising_legacy_parameters_builder_test_00: b"\x36\x20\x19\x00\x13\x00\x90\x01\x00\xc2\x01\x00\x07\x01\x00\x00\x00\x00\x00\x00\x00\x00\xf9\x01\x00\x01\x01\x00",le_set_extended_advertising_legacy_parameters_builder_test_01: b"\x36\x20\x19\x01\x13\x00\x90\x01\x00\xc2\x01\x00\x07\x01\x00\x00\x00\x00\x00\x00\x00\x00\xf9\x01\x00\x01\x01\x00",}


#[derive(Debug)] struct LeSetExtendedAdvertisingParametersData {advertising_handle: u8, advertising_event_legacy_properties: u8, advertising_event_properties: u8, primary_advertising_interval_min: u32, primary_advertising_interval_max: u32, primary_advertising_channel_map: u8, own_address_type: OwnAddressType, peer_address_type: PeerAddressType, peer_address: Address, advertising_filter_policy: AdvertisingFilterPolicy, advertising_tx_power: u8, primary_advertising_phy: PrimaryPhyType, secondary_advertising_max_skip: u8, secondary_advertising_phy: SecondaryPhyType, advertising_sid: u8, scan_request_notification_enable: Enable, }
#[derive(Debug, Clone)] pub struct LeSetExtendedAdvertisingParametersPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_set_extended_advertising_parameters: Arc<LeSetExtendedAdvertisingParametersData>,}
#[derive(Debug)] pub struct LeSetExtendedAdvertisingParametersBuilder {pub advertising_handle: u8, pub advertising_event_legacy_properties: u8, pub advertising_event_properties: u8, pub primary_advertising_interval_min: u32, pub primary_advertising_interval_max: u32, pub primary_advertising_channel_map: u8, pub own_address_type: OwnAddressType, pub peer_address_type: PeerAddressType, pub peer_address: Address, pub advertising_filter_policy: AdvertisingFilterPolicy, pub advertising_tx_power: u8, pub primary_advertising_phy: PrimaryPhyType, pub secondary_advertising_max_skip: u8, pub secondary_advertising_phy: SecondaryPhyType, pub advertising_sid: u8, pub scan_request_notification_enable: Enable, }
impl LeSetExtendedAdvertisingParametersData {fn conforms(bytes: &[u8]) -> bool {let fixed_scalar4 = u8::from_le_bytes([bytes[4]]);let fixed_scalar4 = fixed_scalar4 >> 4;let fixed_scalar4 = fixed_scalar4 & 0x1;if fixed_scalar4 != 0 { return false; }  true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingParameters".to_string(),    field: "advertising_handle".to_string(),    wanted: 4,    got: bytes.len()});}let advertising_handle = u8::from_le_bytes([bytes[3]]);let advertising_event_legacy_properties = u8::from_le_bytes([bytes[4]]);let advertising_event_legacy_properties = advertising_event_legacy_properties & 0xf;let fixed_scalar4 = u8::from_le_bytes([bytes[4]]);let fixed_scalar4 = fixed_scalar4 >> 4;let fixed_scalar4 = fixed_scalar4 & 0x1;let advertising_event_properties = u8::from_le_bytes([bytes[4]]);let advertising_event_properties = advertising_event_properties >> 5;let advertising_event_properties = advertising_event_properties & 0x7;if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingParameters".to_string(),    field: "primary_advertising_interval_min".to_string(),    wanted: 9,    got: bytes.len()});}let primary_advertising_interval_min = u32::from_le_bytes([bytes[6],bytes[7],bytes[8],0]);let primary_advertising_interval_min = primary_advertising_interval_min & 0xffffff;if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingParameters".to_string(),    field: "primary_advertising_interval_max".to_string(),    wanted: 12,    got: bytes.len()});}let primary_advertising_interval_max = u32::from_le_bytes([bytes[9],bytes[10],bytes[11],0]);let primary_advertising_interval_max = primary_advertising_interval_max & 0xffffff;let primary_advertising_channel_map = u8::from_le_bytes([bytes[12]]);let primary_advertising_channel_map = primary_advertising_channel_map & 0x7;if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingParameters".to_string(),    field: "own_address_type".to_string(),    wanted: 14,    got: bytes.len()});}let own_address_type = u8::from_le_bytes([bytes[13]]);let own_address_type = OwnAddressType::from_u8(own_address_type).unwrap();if bytes.len() < 15 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingParameters".to_string(),    field: "peer_address_type".to_string(),    wanted: 15,    got: bytes.len()});}let peer_address_type = u8::from_le_bytes([bytes[14]]);let peer_address_type = PeerAddressType::from_u8(peer_address_type).unwrap();if bytes.len() < 21 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingParameters".to_string(),    field: "peer_address".to_string(),    wanted: 21,    got: bytes.len()});}let peer_address = bytes[15..21].try_into().unwrap();let advertising_filter_policy = u8::from_le_bytes([bytes[21]]);let advertising_filter_policy = advertising_filter_policy & 0x3;let advertising_filter_policy = AdvertisingFilterPolicy::from_u8(advertising_filter_policy).unwrap();if bytes.len() < 23 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingParameters".to_string(),    field: "advertising_tx_power".to_string(),    wanted: 23,    got: bytes.len()});}let advertising_tx_power = u8::from_le_bytes([bytes[22]]);if bytes.len() < 24 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingParameters".to_string(),    field: "primary_advertising_phy".to_string(),    wanted: 24,    got: bytes.len()});}let primary_advertising_phy = u8::from_le_bytes([bytes[23]]);let primary_advertising_phy = PrimaryPhyType::from_u8(primary_advertising_phy).unwrap();if bytes.len() < 25 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingParameters".to_string(),    field: "secondary_advertising_max_skip".to_string(),    wanted: 25,    got: bytes.len()});}let secondary_advertising_max_skip = u8::from_le_bytes([bytes[24]]);if bytes.len() < 26 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingParameters".to_string(),    field: "secondary_advertising_phy".to_string(),    wanted: 26,    got: bytes.len()});}let secondary_advertising_phy = u8::from_le_bytes([bytes[25]]);let secondary_advertising_phy = SecondaryPhyType::from_u8(secondary_advertising_phy).unwrap();if bytes.len() < 27 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingParameters".to_string(),    field: "advertising_sid".to_string(),    wanted: 27,    got: bytes.len()});}let advertising_sid = u8::from_le_bytes([bytes[26]]);if bytes.len() < 28 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingParameters".to_string(),    field: "scan_request_notification_enable".to_string(),    wanted: 28,    got: bytes.len()});}let scan_request_notification_enable = u8::from_le_bytes([bytes[27]]);let scan_request_notification_enable = Enable::from_u8(scan_request_notification_enable).unwrap();Ok(Self {advertising_handle, advertising_event_legacy_properties, advertising_event_properties, primary_advertising_interval_min, primary_advertising_interval_max, primary_advertising_channel_map, own_address_type, peer_address_type, peer_address, advertising_filter_policy, advertising_tx_power, primary_advertising_phy, secondary_advertising_max_skip, secondary_advertising_phy, advertising_sid, scan_request_notification_enable, })
}
fn write_to(&self, buffer: &mut BytesMut) {let advertising_handle = self.advertising_handle;buffer[3..4].copy_from_slice(&advertising_handle.to_le_bytes()[0..1]);let advertising_event_legacy_properties = self.advertising_event_legacy_properties;let advertising_event_legacy_properties = advertising_event_legacy_properties & 0xf;buffer[4..5].copy_from_slice(&advertising_event_legacy_properties.to_le_bytes()[0..1]);let fixed_scalar4: u8 = 0;let fixed_scalar4 = fixed_scalar4 & 0x1;let fixed_scalar4 = (fixed_scalar4 << 4) | ((buffer[4] as u8) & 0xf);buffer[4..5].copy_from_slice(&fixed_scalar4.to_le_bytes()[0..1]);let advertising_event_properties = self.advertising_event_properties;let advertising_event_properties = advertising_event_properties & 0x7;let advertising_event_properties = (advertising_event_properties << 5) | ((buffer[4] as u8) & 0x1f);buffer[4..5].copy_from_slice(&advertising_event_properties.to_le_bytes()[0..1]);let primary_advertising_interval_min = self.primary_advertising_interval_min;let primary_advertising_interval_min = primary_advertising_interval_min & 0xffffff;buffer[6..9].copy_from_slice(&primary_advertising_interval_min.to_le_bytes()[0..3]);let primary_advertising_interval_max = self.primary_advertising_interval_max;let primary_advertising_interval_max = primary_advertising_interval_max & 0xffffff;buffer[9..12].copy_from_slice(&primary_advertising_interval_max.to_le_bytes()[0..3]);let primary_advertising_channel_map = self.primary_advertising_channel_map;let primary_advertising_channel_map = primary_advertising_channel_map & 0x7;buffer[12..13].copy_from_slice(&primary_advertising_channel_map.to_le_bytes()[0..1]);let own_address_type = self.own_address_type.to_u8().unwrap();buffer[13..14].copy_from_slice(&own_address_type.to_le_bytes()[0..1]);let peer_address_type = self.peer_address_type.to_u8().unwrap();buffer[14..15].copy_from_slice(&peer_address_type.to_le_bytes()[0..1]);let peer_address: [u8; 6] = self.peer_address.into();buffer[15..21].copy_from_slice(&peer_address);let advertising_filter_policy = self.advertising_filter_policy.to_u8().unwrap();let advertising_filter_policy = advertising_filter_policy & 0x3;buffer[21..22].copy_from_slice(&advertising_filter_policy.to_le_bytes()[0..1]);let advertising_tx_power = self.advertising_tx_power;buffer[22..23].copy_from_slice(&advertising_tx_power.to_le_bytes()[0..1]);let primary_advertising_phy = self.primary_advertising_phy.to_u8().unwrap();buffer[23..24].copy_from_slice(&primary_advertising_phy.to_le_bytes()[0..1]);let secondary_advertising_max_skip = self.secondary_advertising_max_skip;buffer[24..25].copy_from_slice(&secondary_advertising_max_skip.to_le_bytes()[0..1]);let secondary_advertising_phy = self.secondary_advertising_phy.to_u8().unwrap();buffer[25..26].copy_from_slice(&secondary_advertising_phy.to_le_bytes()[0..1]);let advertising_sid = self.advertising_sid;buffer[26..27].copy_from_slice(&advertising_sid.to_le_bytes()[0..1]);let scan_request_notification_enable = self.scan_request_notification_enable.to_u8().unwrap();buffer[27..28].copy_from_slice(&scan_request_notification_enable.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 25;ret}
}
impl CommandExpectations for LeSetExtendedAdvertisingParametersPacket { type ResponseType = LeSetExtendedAdvertisingParametersCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetExtendedAdvertisingParametersCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetExtendedAdvertisingParametersPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetExtendedAdvertisingParametersPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_set_extended_advertising_parameters = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingParameters(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetExtendedAdvertisingParameters"),};Self {command,le_advertising_command,le_set_extended_advertising_parameters,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_advertising_handle(&self) -> u8{ self.le_set_extended_advertising_parameters.as_ref().advertising_handle}
pub fn get_advertising_event_legacy_properties(&self) -> u8{ self.le_set_extended_advertising_parameters.as_ref().advertising_event_legacy_properties}
pub fn get_advertising_event_properties(&self) -> u8{ self.le_set_extended_advertising_parameters.as_ref().advertising_event_properties}
pub fn get_primary_advertising_interval_min(&self) -> u32{ self.le_set_extended_advertising_parameters.as_ref().primary_advertising_interval_min}
pub fn get_primary_advertising_interval_max(&self) -> u32{ self.le_set_extended_advertising_parameters.as_ref().primary_advertising_interval_max}
pub fn get_primary_advertising_channel_map(&self) -> u8{ self.le_set_extended_advertising_parameters.as_ref().primary_advertising_channel_map}
pub fn get_own_address_type(&self) -> OwnAddressType{ self.le_set_extended_advertising_parameters.as_ref().own_address_type}
pub fn get_peer_address_type(&self) -> PeerAddressType{ self.le_set_extended_advertising_parameters.as_ref().peer_address_type}
pub fn get_peer_address(&self) -> Address{ self.le_set_extended_advertising_parameters.as_ref().peer_address}
pub fn get_advertising_filter_policy(&self) -> AdvertisingFilterPolicy{ self.le_set_extended_advertising_parameters.as_ref().advertising_filter_policy}
pub fn get_advertising_tx_power(&self) -> u8{ self.le_set_extended_advertising_parameters.as_ref().advertising_tx_power}
pub fn get_primary_advertising_phy(&self) -> PrimaryPhyType{ self.le_set_extended_advertising_parameters.as_ref().primary_advertising_phy}
pub fn get_secondary_advertising_max_skip(&self) -> u8{ self.le_set_extended_advertising_parameters.as_ref().secondary_advertising_max_skip}
pub fn get_secondary_advertising_phy(&self) -> SecondaryPhyType{ self.le_set_extended_advertising_parameters.as_ref().secondary_advertising_phy}
pub fn get_advertising_sid(&self) -> u8{ self.le_set_extended_advertising_parameters.as_ref().advertising_sid}
pub fn get_scan_request_notification_enable(&self) -> Enable{ self.le_set_extended_advertising_parameters.as_ref().scan_request_notification_enable}
}
impl Into<CommandPacket> for LeSetExtendedAdvertisingParametersPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeSetExtendedAdvertisingParametersPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetExtendedAdvertisingParametersBuilder { type ResponseType = LeSetExtendedAdvertisingParametersCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetExtendedAdvertisingParametersCompletePacket::new(pkt.event.clone()) }}impl LeSetExtendedAdvertisingParametersBuilder {pub fn build(self) -> LeSetExtendedAdvertisingParametersPacket {let le_set_extended_advertising_parameters= Arc::new(LeSetExtendedAdvertisingParametersData {advertising_handle: self.advertising_handle, advertising_event_legacy_properties: self.advertising_event_legacy_properties, advertising_event_properties: self.advertising_event_properties, primary_advertising_interval_min: self.primary_advertising_interval_min, primary_advertising_interval_max: self.primary_advertising_interval_max, primary_advertising_channel_map: self.primary_advertising_channel_map, own_address_type: self.own_address_type, peer_address_type: self.peer_address_type, peer_address: self.peer_address, advertising_filter_policy: self.advertising_filter_policy, advertising_tx_power: self.advertising_tx_power, primary_advertising_phy: self.primary_advertising_phy, secondary_advertising_max_skip: self.secondary_advertising_max_skip, secondary_advertising_phy: self.secondary_advertising_phy, advertising_sid: self.advertising_sid, scan_request_notification_enable: self.scan_request_notification_enable, });let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingParameters(le_set_extended_advertising_parameters),});let command= Arc::new(CommandData {op_code: OpCode::LeSetExtendedAdvertisingParameters, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeSetExtendedAdvertisingParametersPacket::new(command)}
}
impl Into<CommandPacket> for LeSetExtendedAdvertisingParametersBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeSetExtendedAdvertisingParametersBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetExtendedAdvertisingParametersCompleteData {status: ErrorCode, selected_tx_power: u8, }
#[derive(Debug, Clone)] pub struct LeSetExtendedAdvertisingParametersCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_extended_advertising_parameters_complete: Arc<LeSetExtendedAdvertisingParametersCompleteData>,}
#[derive(Debug)] pub struct LeSetExtendedAdvertisingParametersCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub selected_tx_power: u8, }
impl LeSetExtendedAdvertisingParametersCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingParametersComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingParametersComplete".to_string(),    field: "selected_tx_power".to_string(),    wanted: 7,    got: bytes.len()});}let selected_tx_power = u8::from_le_bytes([bytes[6]]);Ok(Self {status, selected_tx_power, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let selected_tx_power = self.selected_tx_power;buffer[6..7].copy_from_slice(&selected_tx_power.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for LeSetExtendedAdvertisingParametersCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetExtendedAdvertisingParametersCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_extended_advertising_parameters_complete = match &command_complete.child {CommandCompleteDataChild::LeSetExtendedAdvertisingParametersComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetExtendedAdvertisingParametersComplete"),};Self {event,command_complete,le_set_extended_advertising_parameters_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_extended_advertising_parameters_complete.as_ref().status}
pub fn get_selected_tx_power(&self) -> u8{ self.le_set_extended_advertising_parameters_complete.as_ref().selected_tx_power}
}
impl Into<EventPacket> for LeSetExtendedAdvertisingParametersCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetExtendedAdvertisingParametersCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetExtendedAdvertisingParametersCompleteBuilder {pub fn build(self) -> LeSetExtendedAdvertisingParametersCompletePacket {let le_set_extended_advertising_parameters_complete= Arc::new(LeSetExtendedAdvertisingParametersCompleteData {status: self.status, selected_tx_power: self.selected_tx_power, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetExtendedAdvertisingParameters, child: CommandCompleteDataChild::LeSetExtendedAdvertisingParametersComplete(le_set_extended_advertising_parameters_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetExtendedAdvertisingParametersCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetExtendedAdvertisingParametersCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetExtendedAdvertisingParametersCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetExtendedAdvertisingDataData {advertising_handle: u8, operation: Operation, fragment_preference: FragmentPreference, advertising_data: Vec::<GapData>, }
#[derive(Debug, Clone)] pub struct LeSetExtendedAdvertisingDataPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_set_extended_advertising_data: Arc<LeSetExtendedAdvertisingDataData>,}
#[derive(Debug)] pub struct LeSetExtendedAdvertisingDataBuilder {pub advertising_handle: u8, pub operation: Operation, pub fragment_preference: FragmentPreference, pub advertising_data: Vec::<GapData>, }
impl LeSetExtendedAdvertisingDataData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingData".to_string(),    field: "advertising_handle".to_string(),    wanted: 4,    got: bytes.len()});}let advertising_handle = u8::from_le_bytes([bytes[3]]);let operation = u8::from_le_bytes([bytes[4]]);let operation = operation & 0x7;let operation = Operation::from_u8(operation).unwrap();let fragment_preference = u8::from_le_bytes([bytes[5]]);let fragment_preference = fragment_preference & 0x1;let fragment_preference = FragmentPreference::from_u8(fragment_preference).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingData".to_string(),    field: "advertising_data_size".to_string(),    wanted: 7,    got: bytes.len()});}let advertising_data_size = u8::from_le_bytes([bytes[6]]);let mut advertising_data: Vec::<GapData> = Vec::new();let mut parsable_ = &bytes[7..7 + (advertising_data_size as usize)];while parsable_.len() > 0 { match GapData::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];advertising_data.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {advertising_handle, operation, fragment_preference, advertising_data, })
}
fn write_to(&self, buffer: &mut BytesMut) {let advertising_handle = self.advertising_handle;buffer[3..4].copy_from_slice(&advertising_handle.to_le_bytes()[0..1]);let operation = self.operation.to_u8().unwrap();let operation = operation & 0x7;buffer[4..5].copy_from_slice(&operation.to_le_bytes()[0..1]);let fragment_preference = self.fragment_preference.to_u8().unwrap();let fragment_preference = fragment_preference & 0x1;buffer[5..6].copy_from_slice(&fragment_preference.to_le_bytes()[0..1]);let advertising_data_bytes = self.advertising_data.iter().fold(0, |acc, x| acc + x.get_total_size());let advertising_data_size = u8::try_from(advertising_data_bytes).expect("payload size did not fit");buffer[6..7].copy_from_slice(&advertising_data_size.to_le_bytes()[0..1]);let mut vec_buffer_ = &mut buffer[7..];for e_ in &self.advertising_data { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;let ret = ret + self.advertising_data.iter().fold(0, |acc, x| acc + x.get_total_size());ret}
}
impl CommandExpectations for LeSetExtendedAdvertisingDataPacket { type ResponseType = LeSetExtendedAdvertisingDataCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetExtendedAdvertisingDataCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetExtendedAdvertisingDataPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetExtendedAdvertisingDataPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_set_extended_advertising_data = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingData(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetExtendedAdvertisingData"),};Self {command,le_advertising_command,le_set_extended_advertising_data,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_advertising_handle(&self) -> u8{ self.le_set_extended_advertising_data.as_ref().advertising_handle}
pub fn get_operation(&self) -> Operation{ self.le_set_extended_advertising_data.as_ref().operation}
pub fn get_fragment_preference(&self) -> FragmentPreference{ self.le_set_extended_advertising_data.as_ref().fragment_preference}
pub fn get_advertising_data(&self) -> &Vec::<GapData>{ &self.le_set_extended_advertising_data.as_ref().advertising_data}
}
impl Into<CommandPacket> for LeSetExtendedAdvertisingDataPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeSetExtendedAdvertisingDataPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetExtendedAdvertisingDataBuilder { type ResponseType = LeSetExtendedAdvertisingDataCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetExtendedAdvertisingDataCompletePacket::new(pkt.event.clone()) }}impl LeSetExtendedAdvertisingDataBuilder {pub fn build(self) -> LeSetExtendedAdvertisingDataPacket {let le_set_extended_advertising_data= Arc::new(LeSetExtendedAdvertisingDataData {advertising_handle: self.advertising_handle, operation: self.operation, fragment_preference: self.fragment_preference, advertising_data: self.advertising_data, });let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingData(le_set_extended_advertising_data),});let command= Arc::new(CommandData {op_code: OpCode::LeSetExtendedAdvertisingData, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeSetExtendedAdvertisingDataPacket::new(command)}
}
impl Into<CommandPacket> for LeSetExtendedAdvertisingDataBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeSetExtendedAdvertisingDataBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}
macro_rules! le_set_extended_advertising_data_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::LeAdvertisingCommand(le_advertising_command_packet) => {match le_advertising_command_packet.specialize() {/* (2) */
LeAdvertisingCommandChild::LeSetExtendedAdvertisingData(packet) => {let rebuilder = LeSetExtendedAdvertisingDataBuilder {advertising_handle : packet.get_advertising_handle(),operation : packet.get_operation(),fragment_preference : packet.get_fragment_preference(),advertising_data : packet.get_advertising_data().to_vec(),};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse le_set_extended_advertising_data{:02x?}", le_advertising_command_packet); }}}_ => {println!("Couldn't parse le_advertising_command{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}le_set_extended_advertising_data_builder_tests! { le_set_extended_advertising_data_builder_test_00: b"\x37\x20\x12\x00\x03\x01\x0e\x02\x01\x02\x0a\x09\x50\x69\x78\x65\x6c\x20\x33\x20\x58",}


#[derive(Debug)] struct LeSetExtendedAdvertisingDataRawData {advertising_handle: u8, operation: Operation, fragment_preference: FragmentPreference, advertising_data: Vec::<u8>, }
#[derive(Debug, Clone)] pub struct LeSetExtendedAdvertisingDataRawPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_set_extended_advertising_data_raw: Arc<LeSetExtendedAdvertisingDataRawData>,}
#[derive(Debug)] pub struct LeSetExtendedAdvertisingDataRawBuilder {pub advertising_handle: u8, pub operation: Operation, pub fragment_preference: FragmentPreference, pub advertising_data: Vec::<u8>, }
impl LeSetExtendedAdvertisingDataRawData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingDataRaw".to_string(),    field: "advertising_handle".to_string(),    wanted: 4,    got: bytes.len()});}let advertising_handle = u8::from_le_bytes([bytes[3]]);let operation = u8::from_le_bytes([bytes[4]]);let operation = operation & 0x7;let operation = Operation::from_u8(operation).unwrap();let fragment_preference = u8::from_le_bytes([bytes[5]]);let fragment_preference = fragment_preference & 0x1;let fragment_preference = FragmentPreference::from_u8(fragment_preference).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingDataRaw".to_string(),    field: "advertising_data_size".to_string(),    wanted: 7,    got: bytes.len()});}let advertising_data_size = u8::from_le_bytes([bytes[6]]);let want_ = 7 + (advertising_data_size as usize);if bytes.len() < want_ { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingDataRaw".to_string(),    field: "advertising_data".to_string(),    wanted: want_,    got: bytes.len()});}let advertising_data: Vec::<u8> = bytes[7..(7 + advertising_data_size as usize)].to_vec().chunks_exact(1).into_iter().map(|i| u8::from_le_bytes([i[0]])).collect();Ok(Self {advertising_handle, operation, fragment_preference, advertising_data, })
}
fn write_to(&self, buffer: &mut BytesMut) {let advertising_handle = self.advertising_handle;buffer[3..4].copy_from_slice(&advertising_handle.to_le_bytes()[0..1]);let operation = self.operation.to_u8().unwrap();let operation = operation & 0x7;buffer[4..5].copy_from_slice(&operation.to_le_bytes()[0..1]);let fragment_preference = self.fragment_preference.to_u8().unwrap();let fragment_preference = fragment_preference & 0x1;buffer[5..6].copy_from_slice(&fragment_preference.to_le_bytes()[0..1]);let advertising_data_bytes = self.advertising_data.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8);let advertising_data_size = u8::try_from(advertising_data_bytes).expect("payload size did not fit");buffer[6..7].copy_from_slice(&advertising_data_size.to_le_bytes()[0..1]);for (i, e) in self.advertising_data.iter().enumerate() {buffer[7+i..7+i+1].copy_from_slice(&e.to_le_bytes())}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;let ret = ret + (self.advertising_data.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8));ret}
}
impl CommandExpectations for LeSetExtendedAdvertisingDataRawPacket { type ResponseType = LeSetExtendedAdvertisingDataCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetExtendedAdvertisingDataCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetExtendedAdvertisingDataRawPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetExtendedAdvertisingDataRawPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_set_extended_advertising_data_raw = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingDataRaw(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetExtendedAdvertisingDataRaw"),};Self {command,le_advertising_command,le_set_extended_advertising_data_raw,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_advertising_handle(&self) -> u8{ self.le_set_extended_advertising_data_raw.as_ref().advertising_handle}
pub fn get_operation(&self) -> Operation{ self.le_set_extended_advertising_data_raw.as_ref().operation}
pub fn get_fragment_preference(&self) -> FragmentPreference{ self.le_set_extended_advertising_data_raw.as_ref().fragment_preference}
pub fn get_advertising_data(&self) -> &Vec::<u8>{ &self.le_set_extended_advertising_data_raw.as_ref().advertising_data}
}
impl Into<CommandPacket> for LeSetExtendedAdvertisingDataRawPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeSetExtendedAdvertisingDataRawPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetExtendedAdvertisingDataRawBuilder { type ResponseType = LeSetExtendedAdvertisingDataCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetExtendedAdvertisingDataCompletePacket::new(pkt.event.clone()) }}impl LeSetExtendedAdvertisingDataRawBuilder {pub fn build(self) -> LeSetExtendedAdvertisingDataRawPacket {let le_set_extended_advertising_data_raw= Arc::new(LeSetExtendedAdvertisingDataRawData {advertising_handle: self.advertising_handle, operation: self.operation, fragment_preference: self.fragment_preference, advertising_data: self.advertising_data, });let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingDataRaw(le_set_extended_advertising_data_raw),});let command= Arc::new(CommandData {op_code: OpCode::LeSetExtendedAdvertisingData, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeSetExtendedAdvertisingDataRawPacket::new(command)}
}
impl Into<CommandPacket> for LeSetExtendedAdvertisingDataRawBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeSetExtendedAdvertisingDataRawBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetExtendedAdvertisingDataCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeSetExtendedAdvertisingDataCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_extended_advertising_data_complete: Arc<LeSetExtendedAdvertisingDataCompleteData>,}
#[derive(Debug)] pub struct LeSetExtendedAdvertisingDataCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeSetExtendedAdvertisingDataCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingDataComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeSetExtendedAdvertisingDataCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetExtendedAdvertisingDataCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_extended_advertising_data_complete = match &command_complete.child {CommandCompleteDataChild::LeSetExtendedAdvertisingDataComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetExtendedAdvertisingDataComplete"),};Self {event,command_complete,le_set_extended_advertising_data_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_extended_advertising_data_complete.as_ref().status}
}
impl Into<EventPacket> for LeSetExtendedAdvertisingDataCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetExtendedAdvertisingDataCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetExtendedAdvertisingDataCompleteBuilder {pub fn build(self) -> LeSetExtendedAdvertisingDataCompletePacket {let le_set_extended_advertising_data_complete= Arc::new(LeSetExtendedAdvertisingDataCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetExtendedAdvertisingData, child: CommandCompleteDataChild::LeSetExtendedAdvertisingDataComplete(le_set_extended_advertising_data_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetExtendedAdvertisingDataCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetExtendedAdvertisingDataCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetExtendedAdvertisingDataCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! le_set_extended_advertising_data_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::LeSetExtendedAdvertisingDataComplete(packet) => {let rebuilder = LeSetExtendedAdvertisingDataCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse le_set_extended_advertising_data_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}le_set_extended_advertising_data_complete_builder_tests! { le_set_extended_advertising_data_complete_builder_test_00: b"\x0e\x04\x01\x37\x20\x00",}


#[derive(Debug)] struct LeSetExtendedAdvertisingScanResponseData {advertising_handle: u8, operation: Operation, fragment_preference: FragmentPreference, scan_response_data: Vec::<GapData>, }
#[derive(Debug, Clone)] pub struct LeSetExtendedAdvertisingScanResponsePacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_set_extended_advertising_scan_response: Arc<LeSetExtendedAdvertisingScanResponseData>,}
#[derive(Debug)] pub struct LeSetExtendedAdvertisingScanResponseBuilder {pub advertising_handle: u8, pub operation: Operation, pub fragment_preference: FragmentPreference, pub scan_response_data: Vec::<GapData>, }
impl LeSetExtendedAdvertisingScanResponseData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingScanResponse".to_string(),    field: "advertising_handle".to_string(),    wanted: 4,    got: bytes.len()});}let advertising_handle = u8::from_le_bytes([bytes[3]]);let operation = u8::from_le_bytes([bytes[4]]);let operation = operation & 0x7;let operation = Operation::from_u8(operation).unwrap();let fragment_preference = u8::from_le_bytes([bytes[5]]);let fragment_preference = fragment_preference & 0x1;let fragment_preference = FragmentPreference::from_u8(fragment_preference).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingScanResponse".to_string(),    field: "scan_response_data_size".to_string(),    wanted: 7,    got: bytes.len()});}let scan_response_data_size = u8::from_le_bytes([bytes[6]]);let mut scan_response_data: Vec::<GapData> = Vec::new();let mut parsable_ = &bytes[7..7 + (scan_response_data_size as usize)];while parsable_.len() > 0 { match GapData::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];scan_response_data.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {advertising_handle, operation, fragment_preference, scan_response_data, })
}
fn write_to(&self, buffer: &mut BytesMut) {let advertising_handle = self.advertising_handle;buffer[3..4].copy_from_slice(&advertising_handle.to_le_bytes()[0..1]);let operation = self.operation.to_u8().unwrap();let operation = operation & 0x7;buffer[4..5].copy_from_slice(&operation.to_le_bytes()[0..1]);let fragment_preference = self.fragment_preference.to_u8().unwrap();let fragment_preference = fragment_preference & 0x1;buffer[5..6].copy_from_slice(&fragment_preference.to_le_bytes()[0..1]);let scan_response_data_bytes = self.scan_response_data.iter().fold(0, |acc, x| acc + x.get_total_size());let scan_response_data_size = u8::try_from(scan_response_data_bytes).expect("payload size did not fit");buffer[6..7].copy_from_slice(&scan_response_data_size.to_le_bytes()[0..1]);let mut vec_buffer_ = &mut buffer[7..];for e_ in &self.scan_response_data { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;let ret = ret + self.scan_response_data.iter().fold(0, |acc, x| acc + x.get_total_size());ret}
}
impl CommandExpectations for LeSetExtendedAdvertisingScanResponsePacket { type ResponseType = LeSetExtendedAdvertisingScanResponseCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetExtendedAdvertisingScanResponseCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetExtendedAdvertisingScanResponsePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetExtendedAdvertisingScanResponsePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_set_extended_advertising_scan_response = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingScanResponse(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetExtendedAdvertisingScanResponse"),};Self {command,le_advertising_command,le_set_extended_advertising_scan_response,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_advertising_handle(&self) -> u8{ self.le_set_extended_advertising_scan_response.as_ref().advertising_handle}
pub fn get_operation(&self) -> Operation{ self.le_set_extended_advertising_scan_response.as_ref().operation}
pub fn get_fragment_preference(&self) -> FragmentPreference{ self.le_set_extended_advertising_scan_response.as_ref().fragment_preference}
pub fn get_scan_response_data(&self) -> &Vec::<GapData>{ &self.le_set_extended_advertising_scan_response.as_ref().scan_response_data}
}
impl Into<CommandPacket> for LeSetExtendedAdvertisingScanResponsePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeSetExtendedAdvertisingScanResponsePacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetExtendedAdvertisingScanResponseBuilder { type ResponseType = LeSetExtendedAdvertisingScanResponseCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetExtendedAdvertisingScanResponseCompletePacket::new(pkt.event.clone()) }}impl LeSetExtendedAdvertisingScanResponseBuilder {pub fn build(self) -> LeSetExtendedAdvertisingScanResponsePacket {let le_set_extended_advertising_scan_response= Arc::new(LeSetExtendedAdvertisingScanResponseData {advertising_handle: self.advertising_handle, operation: self.operation, fragment_preference: self.fragment_preference, scan_response_data: self.scan_response_data, });let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingScanResponse(le_set_extended_advertising_scan_response),});let command= Arc::new(CommandData {op_code: OpCode::LeSetExtendedAdvertisingScanResponse, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeSetExtendedAdvertisingScanResponsePacket::new(command)}
}
impl Into<CommandPacket> for LeSetExtendedAdvertisingScanResponseBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeSetExtendedAdvertisingScanResponseBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetExtendedAdvertisingScanResponseRawData {advertising_handle: u8, operation: Operation, fragment_preference: FragmentPreference, scan_response_data: Vec::<u8>, }
#[derive(Debug, Clone)] pub struct LeSetExtendedAdvertisingScanResponseRawPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_set_extended_advertising_scan_response_raw: Arc<LeSetExtendedAdvertisingScanResponseRawData>,}
#[derive(Debug)] pub struct LeSetExtendedAdvertisingScanResponseRawBuilder {pub advertising_handle: u8, pub operation: Operation, pub fragment_preference: FragmentPreference, pub scan_response_data: Vec::<u8>, }
impl LeSetExtendedAdvertisingScanResponseRawData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingScanResponseRaw".to_string(),    field: "advertising_handle".to_string(),    wanted: 4,    got: bytes.len()});}let advertising_handle = u8::from_le_bytes([bytes[3]]);let operation = u8::from_le_bytes([bytes[4]]);let operation = operation & 0x7;let operation = Operation::from_u8(operation).unwrap();let fragment_preference = u8::from_le_bytes([bytes[5]]);let fragment_preference = fragment_preference & 0x1;let fragment_preference = FragmentPreference::from_u8(fragment_preference).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingScanResponseRaw".to_string(),    field: "scan_response_data_size".to_string(),    wanted: 7,    got: bytes.len()});}let scan_response_data_size = u8::from_le_bytes([bytes[6]]);let want_ = 7 + (scan_response_data_size as usize);if bytes.len() < want_ { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingScanResponseRaw".to_string(),    field: "scan_response_data".to_string(),    wanted: want_,    got: bytes.len()});}let scan_response_data: Vec::<u8> = bytes[7..(7 + scan_response_data_size as usize)].to_vec().chunks_exact(1).into_iter().map(|i| u8::from_le_bytes([i[0]])).collect();Ok(Self {advertising_handle, operation, fragment_preference, scan_response_data, })
}
fn write_to(&self, buffer: &mut BytesMut) {let advertising_handle = self.advertising_handle;buffer[3..4].copy_from_slice(&advertising_handle.to_le_bytes()[0..1]);let operation = self.operation.to_u8().unwrap();let operation = operation & 0x7;buffer[4..5].copy_from_slice(&operation.to_le_bytes()[0..1]);let fragment_preference = self.fragment_preference.to_u8().unwrap();let fragment_preference = fragment_preference & 0x1;buffer[5..6].copy_from_slice(&fragment_preference.to_le_bytes()[0..1]);let scan_response_data_bytes = self.scan_response_data.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8);let scan_response_data_size = u8::try_from(scan_response_data_bytes).expect("payload size did not fit");buffer[6..7].copy_from_slice(&scan_response_data_size.to_le_bytes()[0..1]);for (i, e) in self.scan_response_data.iter().enumerate() {buffer[7+i..7+i+1].copy_from_slice(&e.to_le_bytes())}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;let ret = ret + (self.scan_response_data.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8));ret}
}
impl CommandExpectations for LeSetExtendedAdvertisingScanResponseRawPacket { type ResponseType = LeSetExtendedAdvertisingScanResponseCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetExtendedAdvertisingScanResponseCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetExtendedAdvertisingScanResponseRawPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetExtendedAdvertisingScanResponseRawPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_set_extended_advertising_scan_response_raw = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingScanResponseRaw(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetExtendedAdvertisingScanResponseRaw"),};Self {command,le_advertising_command,le_set_extended_advertising_scan_response_raw,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_advertising_handle(&self) -> u8{ self.le_set_extended_advertising_scan_response_raw.as_ref().advertising_handle}
pub fn get_operation(&self) -> Operation{ self.le_set_extended_advertising_scan_response_raw.as_ref().operation}
pub fn get_fragment_preference(&self) -> FragmentPreference{ self.le_set_extended_advertising_scan_response_raw.as_ref().fragment_preference}
pub fn get_scan_response_data(&self) -> &Vec::<u8>{ &self.le_set_extended_advertising_scan_response_raw.as_ref().scan_response_data}
}
impl Into<CommandPacket> for LeSetExtendedAdvertisingScanResponseRawPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeSetExtendedAdvertisingScanResponseRawPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetExtendedAdvertisingScanResponseRawBuilder { type ResponseType = LeSetExtendedAdvertisingScanResponseCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetExtendedAdvertisingScanResponseCompletePacket::new(pkt.event.clone()) }}impl LeSetExtendedAdvertisingScanResponseRawBuilder {pub fn build(self) -> LeSetExtendedAdvertisingScanResponseRawPacket {let le_set_extended_advertising_scan_response_raw= Arc::new(LeSetExtendedAdvertisingScanResponseRawData {advertising_handle: self.advertising_handle, operation: self.operation, fragment_preference: self.fragment_preference, scan_response_data: self.scan_response_data, });let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingScanResponseRaw(le_set_extended_advertising_scan_response_raw),});let command= Arc::new(CommandData {op_code: OpCode::LeSetExtendedAdvertisingScanResponse, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeSetExtendedAdvertisingScanResponseRawPacket::new(command)}
}
impl Into<CommandPacket> for LeSetExtendedAdvertisingScanResponseRawBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeSetExtendedAdvertisingScanResponseRawBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetExtendedAdvertisingScanResponseCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeSetExtendedAdvertisingScanResponseCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_extended_advertising_scan_response_complete: Arc<LeSetExtendedAdvertisingScanResponseCompleteData>,}
#[derive(Debug)] pub struct LeSetExtendedAdvertisingScanResponseCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeSetExtendedAdvertisingScanResponseCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingScanResponseComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeSetExtendedAdvertisingScanResponseCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetExtendedAdvertisingScanResponseCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_extended_advertising_scan_response_complete = match &command_complete.child {CommandCompleteDataChild::LeSetExtendedAdvertisingScanResponseComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetExtendedAdvertisingScanResponseComplete"),};Self {event,command_complete,le_set_extended_advertising_scan_response_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_extended_advertising_scan_response_complete.as_ref().status}
}
impl Into<EventPacket> for LeSetExtendedAdvertisingScanResponseCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetExtendedAdvertisingScanResponseCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetExtendedAdvertisingScanResponseCompleteBuilder {pub fn build(self) -> LeSetExtendedAdvertisingScanResponseCompletePacket {let le_set_extended_advertising_scan_response_complete= Arc::new(LeSetExtendedAdvertisingScanResponseCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetExtendedAdvertisingScanResponse, child: CommandCompleteDataChild::LeSetExtendedAdvertisingScanResponseComplete(le_set_extended_advertising_scan_response_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetExtendedAdvertisingScanResponseCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetExtendedAdvertisingScanResponseCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetExtendedAdvertisingScanResponseCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetExtendedAdvertisingEnableDisableAllData {}
#[derive(Debug, Clone)] pub struct LeSetExtendedAdvertisingEnableDisableAllPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_set_extended_advertising_enable_disable_all: Arc<LeSetExtendedAdvertisingEnableDisableAllData>,}
#[derive(Debug)] pub struct LeSetExtendedAdvertisingEnableDisableAllBuilder {}
impl LeSetExtendedAdvertisingEnableDisableAllData {fn conforms(bytes: &[u8]) -> bool {let fixed_scalar5 = u8::from_le_bytes([bytes[3]]);if fixed_scalar5 != 0 { return false; } let fixed_scalar6 = u8::from_le_bytes([bytes[4]]);if fixed_scalar6 != 0 { return false; }  true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingEnableDisableAll".to_string(),    field: "fixed_scalar5".to_string(),    wanted: 4,    got: bytes.len()});}let fixed_scalar5 = u8::from_le_bytes([bytes[3]]);if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingEnableDisableAll".to_string(),    field: "fixed_scalar6".to_string(),    wanted: 5,    got: bytes.len()});}let fixed_scalar6 = u8::from_le_bytes([bytes[4]]);Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {let fixed_scalar5: u8 = 0;buffer[3..4].copy_from_slice(&fixed_scalar5.to_le_bytes()[0..1]);let fixed_scalar6: u8 = 0;buffer[4..5].copy_from_slice(&fixed_scalar6.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for LeSetExtendedAdvertisingEnableDisableAllPacket { type ResponseType = LeSetExtendedAdvertisingEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetExtendedAdvertisingEnableCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetExtendedAdvertisingEnableDisableAllPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetExtendedAdvertisingEnableDisableAllPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_set_extended_advertising_enable_disable_all = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingEnableDisableAll(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetExtendedAdvertisingEnableDisableAll"),};Self {command,le_advertising_command,le_set_extended_advertising_enable_disable_all,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeSetExtendedAdvertisingEnableDisableAllPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeSetExtendedAdvertisingEnableDisableAllPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetExtendedAdvertisingEnableDisableAllBuilder { type ResponseType = LeSetExtendedAdvertisingEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetExtendedAdvertisingEnableCompletePacket::new(pkt.event.clone()) }}impl LeSetExtendedAdvertisingEnableDisableAllBuilder {pub fn build(self) -> LeSetExtendedAdvertisingEnableDisableAllPacket {let le_set_extended_advertising_enable_disable_all= Arc::new(LeSetExtendedAdvertisingEnableDisableAllData {});let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingEnableDisableAll(le_set_extended_advertising_enable_disable_all),});let command= Arc::new(CommandData {op_code: OpCode::LeSetExtendedAdvertisingEnable, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeSetExtendedAdvertisingEnableDisableAllPacket::new(command)}
}
impl Into<CommandPacket> for LeSetExtendedAdvertisingEnableDisableAllBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeSetExtendedAdvertisingEnableDisableAllBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetExtendedAdvertisingDisableData {disabled_sets: Vec::<DisabledSet>, }
#[derive(Debug, Clone)] pub struct LeSetExtendedAdvertisingDisablePacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_set_extended_advertising_disable: Arc<LeSetExtendedAdvertisingDisableData>,}
#[derive(Debug)] pub struct LeSetExtendedAdvertisingDisableBuilder {pub disabled_sets: Vec::<DisabledSet>, }
impl LeSetExtendedAdvertisingDisableData {fn conforms(bytes: &[u8]) -> bool {let fixed_scalar9 = u8::from_le_bytes([bytes[3]]);if fixed_scalar9 != 0 { return false; }  true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingDisable".to_string(),    field: "fixed_scalar9".to_string(),    wanted: 4,    got: bytes.len()});}let fixed_scalar9 = u8::from_le_bytes([bytes[3]]);if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingDisable".to_string(),    field: "disabled_sets_count".to_string(),    wanted: 5,    got: bytes.len()});}let disabled_sets_count = u8::from_le_bytes([bytes[4]]);let mut disabled_sets: Vec::<DisabledSet> = Vec::new();let mut parsable_ = &bytes[5..];let count_ = disabled_sets_count as usize;for _ in 0..count_ { match DisabledSet::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];disabled_sets.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {disabled_sets, })
}
fn write_to(&self, buffer: &mut BytesMut) {let fixed_scalar9: u8 = 0;buffer[3..4].copy_from_slice(&fixed_scalar9.to_le_bytes()[0..1]);buffer[4..5].copy_from_slice(&(self.disabled_sets.len() as u8).to_le_bytes());let mut vec_buffer_ = &mut buffer[5..];for e_ in &self.disabled_sets { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;let ret = ret + (self.disabled_sets.len() * ((/* Bits: */ 32 + /* Dynamic: */ 0) / 8));ret}
}
impl CommandExpectations for LeSetExtendedAdvertisingDisablePacket { type ResponseType = LeSetExtendedAdvertisingEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetExtendedAdvertisingEnableCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetExtendedAdvertisingDisablePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetExtendedAdvertisingDisablePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_set_extended_advertising_disable = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingDisable(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetExtendedAdvertisingDisable"),};Self {command,le_advertising_command,le_set_extended_advertising_disable,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_disabled_sets(&self) -> &Vec::<DisabledSet>{ &self.le_set_extended_advertising_disable.as_ref().disabled_sets}
}
impl Into<CommandPacket> for LeSetExtendedAdvertisingDisablePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeSetExtendedAdvertisingDisablePacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetExtendedAdvertisingDisableBuilder { type ResponseType = LeSetExtendedAdvertisingEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetExtendedAdvertisingEnableCompletePacket::new(pkt.event.clone()) }}impl LeSetExtendedAdvertisingDisableBuilder {pub fn build(self) -> LeSetExtendedAdvertisingDisablePacket {let le_set_extended_advertising_disable= Arc::new(LeSetExtendedAdvertisingDisableData {disabled_sets: self.disabled_sets, });let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingDisable(le_set_extended_advertising_disable),});let command= Arc::new(CommandData {op_code: OpCode::LeSetExtendedAdvertisingEnable, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeSetExtendedAdvertisingDisablePacket::new(command)}
}
impl Into<CommandPacket> for LeSetExtendedAdvertisingDisableBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeSetExtendedAdvertisingDisableBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetExtendedAdvertisingEnableData {enable: Enable, enabled_sets: Vec::<EnabledSet>, }
#[derive(Debug, Clone)] pub struct LeSetExtendedAdvertisingEnablePacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_set_extended_advertising_enable: Arc<LeSetExtendedAdvertisingEnableData>,}
#[derive(Debug)] pub struct LeSetExtendedAdvertisingEnableBuilder {pub enable: Enable, pub enabled_sets: Vec::<EnabledSet>, }
impl LeSetExtendedAdvertisingEnableData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingEnable".to_string(),    field: "enable".to_string(),    wanted: 4,    got: bytes.len()});}let enable = u8::from_le_bytes([bytes[3]]);let enable = Enable::from_u8(enable).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingEnable".to_string(),    field: "enabled_sets_count".to_string(),    wanted: 5,    got: bytes.len()});}let enabled_sets_count = u8::from_le_bytes([bytes[4]]);let mut enabled_sets: Vec::<EnabledSet> = Vec::new();let mut parsable_ = &bytes[5..];let count_ = enabled_sets_count as usize;for _ in 0..count_ { match EnabledSet::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];enabled_sets.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {enable, enabled_sets, })
}
fn write_to(&self, buffer: &mut BytesMut) {let enable = self.enable.to_u8().unwrap();buffer[3..4].copy_from_slice(&enable.to_le_bytes()[0..1]);buffer[4..5].copy_from_slice(&(self.enabled_sets.len() as u8).to_le_bytes());let mut vec_buffer_ = &mut buffer[5..];for e_ in &self.enabled_sets { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;let ret = ret + (self.enabled_sets.len() * ((/* Bits: */ 32 + /* Dynamic: */ 0) / 8));ret}
}
impl CommandExpectations for LeSetExtendedAdvertisingEnablePacket { type ResponseType = LeSetExtendedAdvertisingEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetExtendedAdvertisingEnableCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetExtendedAdvertisingEnablePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetExtendedAdvertisingEnablePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_set_extended_advertising_enable = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingEnable(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetExtendedAdvertisingEnable"),};Self {command,le_advertising_command,le_set_extended_advertising_enable,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_enable(&self) -> Enable{ self.le_set_extended_advertising_enable.as_ref().enable}
pub fn get_enabled_sets(&self) -> &Vec::<EnabledSet>{ &self.le_set_extended_advertising_enable.as_ref().enabled_sets}
}
impl Into<CommandPacket> for LeSetExtendedAdvertisingEnablePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeSetExtendedAdvertisingEnablePacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetExtendedAdvertisingEnableBuilder { type ResponseType = LeSetExtendedAdvertisingEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetExtendedAdvertisingEnableCompletePacket::new(pkt.event.clone()) }}impl LeSetExtendedAdvertisingEnableBuilder {pub fn build(self) -> LeSetExtendedAdvertisingEnablePacket {let le_set_extended_advertising_enable= Arc::new(LeSetExtendedAdvertisingEnableData {enable: self.enable, enabled_sets: self.enabled_sets, });let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeSetExtendedAdvertisingEnable(le_set_extended_advertising_enable),});let command= Arc::new(CommandData {op_code: OpCode::LeSetExtendedAdvertisingEnable, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeSetExtendedAdvertisingEnablePacket::new(command)}
}
impl Into<CommandPacket> for LeSetExtendedAdvertisingEnableBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeSetExtendedAdvertisingEnableBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}
macro_rules! le_set_extended_advertising_enable_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::LeAdvertisingCommand(le_advertising_command_packet) => {match le_advertising_command_packet.specialize() {/* (2) */
LeAdvertisingCommandChild::LeSetExtendedAdvertisingEnable(packet) => {let rebuilder = LeSetExtendedAdvertisingEnableBuilder {enable : packet.get_enable(),enabled_sets : packet.get_enabled_sets().to_vec(),};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse le_set_extended_advertising_enable{:02x?}", le_advertising_command_packet); }}}_ => {println!("Couldn't parse le_advertising_command{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}le_set_extended_advertising_enable_builder_tests! { le_set_extended_advertising_enable_builder_test_00: b"\x39\x20\x06\x00\x01\x01\x00\x00\x00",}


#[derive(Debug)] struct LeSetExtendedAdvertisingEnableCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeSetExtendedAdvertisingEnableCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_extended_advertising_enable_complete: Arc<LeSetExtendedAdvertisingEnableCompleteData>,}
#[derive(Debug)] pub struct LeSetExtendedAdvertisingEnableCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeSetExtendedAdvertisingEnableCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedAdvertisingEnableComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeSetExtendedAdvertisingEnableCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetExtendedAdvertisingEnableCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_extended_advertising_enable_complete = match &command_complete.child {CommandCompleteDataChild::LeSetExtendedAdvertisingEnableComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetExtendedAdvertisingEnableComplete"),};Self {event,command_complete,le_set_extended_advertising_enable_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_extended_advertising_enable_complete.as_ref().status}
}
impl Into<EventPacket> for LeSetExtendedAdvertisingEnableCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetExtendedAdvertisingEnableCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetExtendedAdvertisingEnableCompleteBuilder {pub fn build(self) -> LeSetExtendedAdvertisingEnableCompletePacket {let le_set_extended_advertising_enable_complete= Arc::new(LeSetExtendedAdvertisingEnableCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetExtendedAdvertisingEnable, child: CommandCompleteDataChild::LeSetExtendedAdvertisingEnableComplete(le_set_extended_advertising_enable_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetExtendedAdvertisingEnableCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetExtendedAdvertisingEnableCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetExtendedAdvertisingEnableCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! le_set_extended_advertising_enable_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::LeSetExtendedAdvertisingEnableComplete(packet) => {let rebuilder = LeSetExtendedAdvertisingEnableCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse le_set_extended_advertising_enable_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}le_set_extended_advertising_enable_complete_builder_tests! { le_set_extended_advertising_enable_complete_builder_test_00: b"\x0e\x04\x01\x39\x20\x00",}


#[derive(Debug)] struct LeReadMaximumAdvertisingDataLengthData {}
#[derive(Debug, Clone)] pub struct LeReadMaximumAdvertisingDataLengthPacket {command: Arc<CommandData>,le_read_maximum_advertising_data_length: Arc<LeReadMaximumAdvertisingDataLengthData>,}
#[derive(Debug)] pub struct LeReadMaximumAdvertisingDataLengthBuilder {}
impl LeReadMaximumAdvertisingDataLengthData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeReadMaximumAdvertisingDataLengthPacket { type ResponseType = LeReadMaximumAdvertisingDataLengthCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadMaximumAdvertisingDataLengthCompletePacket::new(pkt.event.clone()) }}impl Packet for LeReadMaximumAdvertisingDataLengthPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadMaximumAdvertisingDataLengthPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_read_maximum_advertising_data_length = match &command.child {CommandDataChild::LeReadMaximumAdvertisingDataLength(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadMaximumAdvertisingDataLength"),};Self {command,le_read_maximum_advertising_data_length,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeReadMaximumAdvertisingDataLengthPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeReadMaximumAdvertisingDataLengthBuilder { type ResponseType = LeReadMaximumAdvertisingDataLengthCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadMaximumAdvertisingDataLengthCompletePacket::new(pkt.event.clone()) }}impl LeReadMaximumAdvertisingDataLengthBuilder {pub fn build(self) -> LeReadMaximumAdvertisingDataLengthPacket {let le_read_maximum_advertising_data_length= Arc::new(LeReadMaximumAdvertisingDataLengthData {});let command= Arc::new(CommandData {op_code: OpCode::LeReadMaximumAdvertisingDataLength, child: CommandDataChild::LeReadMaximumAdvertisingDataLength(le_read_maximum_advertising_data_length),});LeReadMaximumAdvertisingDataLengthPacket::new(command)}
}
impl Into<CommandPacket> for LeReadMaximumAdvertisingDataLengthBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LeReadMaximumAdvertisingDataLengthCompleteData {status: ErrorCode, maximum_advertising_data_length: u16, }
#[derive(Debug, Clone)] pub struct LeReadMaximumAdvertisingDataLengthCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_read_maximum_advertising_data_length_complete: Arc<LeReadMaximumAdvertisingDataLengthCompleteData>,}
#[derive(Debug)] pub struct LeReadMaximumAdvertisingDataLengthCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub maximum_advertising_data_length: u16, }
impl LeReadMaximumAdvertisingDataLengthCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeReadMaximumAdvertisingDataLengthComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeReadMaximumAdvertisingDataLengthComplete".to_string(),    field: "maximum_advertising_data_length".to_string(),    wanted: 8,    got: bytes.len()});}let maximum_advertising_data_length = u16::from_le_bytes([bytes[6],bytes[7]]);Ok(Self {status, maximum_advertising_data_length, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let maximum_advertising_data_length = self.maximum_advertising_data_length;buffer[6..8].copy_from_slice(&maximum_advertising_data_length.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for LeReadMaximumAdvertisingDataLengthCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadMaximumAdvertisingDataLengthCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_read_maximum_advertising_data_length_complete = match &command_complete.child {CommandCompleteDataChild::LeReadMaximumAdvertisingDataLengthComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadMaximumAdvertisingDataLengthComplete"),};Self {event,command_complete,le_read_maximum_advertising_data_length_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_read_maximum_advertising_data_length_complete.as_ref().status}
pub fn get_maximum_advertising_data_length(&self) -> u16{ self.le_read_maximum_advertising_data_length_complete.as_ref().maximum_advertising_data_length}
}
impl Into<EventPacket> for LeReadMaximumAdvertisingDataLengthCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeReadMaximumAdvertisingDataLengthCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeReadMaximumAdvertisingDataLengthCompleteBuilder {pub fn build(self) -> LeReadMaximumAdvertisingDataLengthCompletePacket {let le_read_maximum_advertising_data_length_complete= Arc::new(LeReadMaximumAdvertisingDataLengthCompleteData {status: self.status, maximum_advertising_data_length: self.maximum_advertising_data_length, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeReadMaximumAdvertisingDataLength, child: CommandCompleteDataChild::LeReadMaximumAdvertisingDataLengthComplete(le_read_maximum_advertising_data_length_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeReadMaximumAdvertisingDataLengthCompletePacket::new(event)}
}
impl Into<EventPacket> for LeReadMaximumAdvertisingDataLengthCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeReadMaximumAdvertisingDataLengthCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeReadNumberOfSupportedAdvertisingSetsData {}
#[derive(Debug, Clone)] pub struct LeReadNumberOfSupportedAdvertisingSetsPacket {command: Arc<CommandData>,le_read_number_of_supported_advertising_sets: Arc<LeReadNumberOfSupportedAdvertisingSetsData>,}
#[derive(Debug)] pub struct LeReadNumberOfSupportedAdvertisingSetsBuilder {}
impl LeReadNumberOfSupportedAdvertisingSetsData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeReadNumberOfSupportedAdvertisingSetsPacket { type ResponseType = LeReadNumberOfSupportedAdvertisingSetsCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadNumberOfSupportedAdvertisingSetsCompletePacket::new(pkt.event.clone()) }}impl Packet for LeReadNumberOfSupportedAdvertisingSetsPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadNumberOfSupportedAdvertisingSetsPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_read_number_of_supported_advertising_sets = match &command.child {CommandDataChild::LeReadNumberOfSupportedAdvertisingSets(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadNumberOfSupportedAdvertisingSets"),};Self {command,le_read_number_of_supported_advertising_sets,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeReadNumberOfSupportedAdvertisingSetsPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeReadNumberOfSupportedAdvertisingSetsBuilder { type ResponseType = LeReadNumberOfSupportedAdvertisingSetsCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadNumberOfSupportedAdvertisingSetsCompletePacket::new(pkt.event.clone()) }}impl LeReadNumberOfSupportedAdvertisingSetsBuilder {pub fn build(self) -> LeReadNumberOfSupportedAdvertisingSetsPacket {let le_read_number_of_supported_advertising_sets= Arc::new(LeReadNumberOfSupportedAdvertisingSetsData {});let command= Arc::new(CommandData {op_code: OpCode::LeReadNumberOfSupportedAdvertisingSets, child: CommandDataChild::LeReadNumberOfSupportedAdvertisingSets(le_read_number_of_supported_advertising_sets),});LeReadNumberOfSupportedAdvertisingSetsPacket::new(command)}
}
impl Into<CommandPacket> for LeReadNumberOfSupportedAdvertisingSetsBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LeReadNumberOfSupportedAdvertisingSetsCompleteData {status: ErrorCode, number_supported_advertising_sets: u8, }
#[derive(Debug, Clone)] pub struct LeReadNumberOfSupportedAdvertisingSetsCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_read_number_of_supported_advertising_sets_complete: Arc<LeReadNumberOfSupportedAdvertisingSetsCompleteData>,}
#[derive(Debug)] pub struct LeReadNumberOfSupportedAdvertisingSetsCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub number_supported_advertising_sets: u8, }
impl LeReadNumberOfSupportedAdvertisingSetsCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeReadNumberOfSupportedAdvertisingSetsComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeReadNumberOfSupportedAdvertisingSetsComplete".to_string(),    field: "number_supported_advertising_sets".to_string(),    wanted: 7,    got: bytes.len()});}let number_supported_advertising_sets = u8::from_le_bytes([bytes[6]]);Ok(Self {status, number_supported_advertising_sets, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let number_supported_advertising_sets = self.number_supported_advertising_sets;buffer[6..7].copy_from_slice(&number_supported_advertising_sets.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for LeReadNumberOfSupportedAdvertisingSetsCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadNumberOfSupportedAdvertisingSetsCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_read_number_of_supported_advertising_sets_complete = match &command_complete.child {CommandCompleteDataChild::LeReadNumberOfSupportedAdvertisingSetsComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadNumberOfSupportedAdvertisingSetsComplete"),};Self {event,command_complete,le_read_number_of_supported_advertising_sets_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_read_number_of_supported_advertising_sets_complete.as_ref().status}
pub fn get_number_supported_advertising_sets(&self) -> u8{ self.le_read_number_of_supported_advertising_sets_complete.as_ref().number_supported_advertising_sets}
}
impl Into<EventPacket> for LeReadNumberOfSupportedAdvertisingSetsCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeReadNumberOfSupportedAdvertisingSetsCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeReadNumberOfSupportedAdvertisingSetsCompleteBuilder {pub fn build(self) -> LeReadNumberOfSupportedAdvertisingSetsCompletePacket {let le_read_number_of_supported_advertising_sets_complete= Arc::new(LeReadNumberOfSupportedAdvertisingSetsCompleteData {status: self.status, number_supported_advertising_sets: self.number_supported_advertising_sets, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeReadNumberOfSupportedAdvertisingSets, child: CommandCompleteDataChild::LeReadNumberOfSupportedAdvertisingSetsComplete(le_read_number_of_supported_advertising_sets_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeReadNumberOfSupportedAdvertisingSetsCompletePacket::new(event)}
}
impl Into<EventPacket> for LeReadNumberOfSupportedAdvertisingSetsCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeReadNumberOfSupportedAdvertisingSetsCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeRemoveAdvertisingSetData {advertising_handle: u8, }
#[derive(Debug, Clone)] pub struct LeRemoveAdvertisingSetPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_remove_advertising_set: Arc<LeRemoveAdvertisingSetData>,}
#[derive(Debug)] pub struct LeRemoveAdvertisingSetBuilder {pub advertising_handle: u8, }
impl LeRemoveAdvertisingSetData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeRemoveAdvertisingSet".to_string(),    field: "advertising_handle".to_string(),    wanted: 4,    got: bytes.len()});}let advertising_handle = u8::from_le_bytes([bytes[3]]);Ok(Self {advertising_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let advertising_handle = self.advertising_handle;buffer[3..4].copy_from_slice(&advertising_handle.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for LeRemoveAdvertisingSetPacket { type ResponseType = LeRemoveAdvertisingSetCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeRemoveAdvertisingSetCompletePacket::new(pkt.event.clone()) }}impl Packet for LeRemoveAdvertisingSetPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeRemoveAdvertisingSetPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_remove_advertising_set = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeRemoveAdvertisingSet(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeRemoveAdvertisingSet"),};Self {command,le_advertising_command,le_remove_advertising_set,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_advertising_handle(&self) -> u8{ self.le_remove_advertising_set.as_ref().advertising_handle}
}
impl Into<CommandPacket> for LeRemoveAdvertisingSetPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeRemoveAdvertisingSetPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeRemoveAdvertisingSetBuilder { type ResponseType = LeRemoveAdvertisingSetCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeRemoveAdvertisingSetCompletePacket::new(pkt.event.clone()) }}impl LeRemoveAdvertisingSetBuilder {pub fn build(self) -> LeRemoveAdvertisingSetPacket {let le_remove_advertising_set= Arc::new(LeRemoveAdvertisingSetData {advertising_handle: self.advertising_handle, });let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeRemoveAdvertisingSet(le_remove_advertising_set),});let command= Arc::new(CommandData {op_code: OpCode::LeRemoveAdvertisingSet, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeRemoveAdvertisingSetPacket::new(command)}
}
impl Into<CommandPacket> for LeRemoveAdvertisingSetBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeRemoveAdvertisingSetBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}
macro_rules! le_remove_advertising_set_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::LeAdvertisingCommand(le_advertising_command_packet) => {match le_advertising_command_packet.specialize() {/* (2) */
LeAdvertisingCommandChild::LeRemoveAdvertisingSet(packet) => {let rebuilder = LeRemoveAdvertisingSetBuilder {advertising_handle : packet.get_advertising_handle(),};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse le_remove_advertising_set{:02x?}", le_advertising_command_packet); }}}_ => {println!("Couldn't parse le_advertising_command{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}le_remove_advertising_set_builder_tests! { le_remove_advertising_set_builder_test_00: b"\x3c\x20\x01\x01",}


#[derive(Debug)] struct LeRemoveAdvertisingSetCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeRemoveAdvertisingSetCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_remove_advertising_set_complete: Arc<LeRemoveAdvertisingSetCompleteData>,}
#[derive(Debug)] pub struct LeRemoveAdvertisingSetCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeRemoveAdvertisingSetCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeRemoveAdvertisingSetComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeRemoveAdvertisingSetCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeRemoveAdvertisingSetCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_remove_advertising_set_complete = match &command_complete.child {CommandCompleteDataChild::LeRemoveAdvertisingSetComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeRemoveAdvertisingSetComplete"),};Self {event,command_complete,le_remove_advertising_set_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_remove_advertising_set_complete.as_ref().status}
}
impl Into<EventPacket> for LeRemoveAdvertisingSetCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeRemoveAdvertisingSetCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeRemoveAdvertisingSetCompleteBuilder {pub fn build(self) -> LeRemoveAdvertisingSetCompletePacket {let le_remove_advertising_set_complete= Arc::new(LeRemoveAdvertisingSetCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeRemoveAdvertisingSet, child: CommandCompleteDataChild::LeRemoveAdvertisingSetComplete(le_remove_advertising_set_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeRemoveAdvertisingSetCompletePacket::new(event)}
}
impl Into<EventPacket> for LeRemoveAdvertisingSetCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeRemoveAdvertisingSetCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! le_remove_advertising_set_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::LeRemoveAdvertisingSetComplete(packet) => {let rebuilder = LeRemoveAdvertisingSetCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse le_remove_advertising_set_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}le_remove_advertising_set_complete_builder_tests! { le_remove_advertising_set_complete_builder_test_00: b"\x0e\x04\x01\x3c\x20\x00",}


#[derive(Debug)] struct LeClearAdvertisingSetsData {}
#[derive(Debug, Clone)] pub struct LeClearAdvertisingSetsPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_clear_advertising_sets: Arc<LeClearAdvertisingSetsData>,}
#[derive(Debug)] pub struct LeClearAdvertisingSetsBuilder {}
impl LeClearAdvertisingSetsData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeClearAdvertisingSetsPacket { type ResponseType = LeClearAdvertisingSetsCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeClearAdvertisingSetsCompletePacket::new(pkt.event.clone()) }}impl Packet for LeClearAdvertisingSetsPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeClearAdvertisingSetsPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_clear_advertising_sets = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeClearAdvertisingSets(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeClearAdvertisingSets"),};Self {command,le_advertising_command,le_clear_advertising_sets,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeClearAdvertisingSetsPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeClearAdvertisingSetsPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeClearAdvertisingSetsBuilder { type ResponseType = LeClearAdvertisingSetsCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeClearAdvertisingSetsCompletePacket::new(pkt.event.clone()) }}impl LeClearAdvertisingSetsBuilder {pub fn build(self) -> LeClearAdvertisingSetsPacket {let le_clear_advertising_sets= Arc::new(LeClearAdvertisingSetsData {});let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeClearAdvertisingSets(le_clear_advertising_sets),});let command= Arc::new(CommandData {op_code: OpCode::LeClearAdvertisingSets, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeClearAdvertisingSetsPacket::new(command)}
}
impl Into<CommandPacket> for LeClearAdvertisingSetsBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeClearAdvertisingSetsBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeClearAdvertisingSetsCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeClearAdvertisingSetsCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_clear_advertising_sets_complete: Arc<LeClearAdvertisingSetsCompleteData>,}
#[derive(Debug)] pub struct LeClearAdvertisingSetsCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeClearAdvertisingSetsCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeClearAdvertisingSetsComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeClearAdvertisingSetsCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeClearAdvertisingSetsCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_clear_advertising_sets_complete = match &command_complete.child {CommandCompleteDataChild::LeClearAdvertisingSetsComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeClearAdvertisingSetsComplete"),};Self {event,command_complete,le_clear_advertising_sets_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_clear_advertising_sets_complete.as_ref().status}
}
impl Into<EventPacket> for LeClearAdvertisingSetsCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeClearAdvertisingSetsCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeClearAdvertisingSetsCompleteBuilder {pub fn build(self) -> LeClearAdvertisingSetsCompletePacket {let le_clear_advertising_sets_complete= Arc::new(LeClearAdvertisingSetsCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeClearAdvertisingSets, child: CommandCompleteDataChild::LeClearAdvertisingSetsComplete(le_clear_advertising_sets_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeClearAdvertisingSetsCompletePacket::new(event)}
}
impl Into<EventPacket> for LeClearAdvertisingSetsCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeClearAdvertisingSetsCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetPeriodicAdvertisingParamData {advertising_handle: u8, periodic_advertising_interval_min: u16, periodic_advertising_interval_max: u16, include_tx_power: u8, }
#[derive(Debug, Clone)] pub struct LeSetPeriodicAdvertisingParamPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_set_periodic_advertising_param: Arc<LeSetPeriodicAdvertisingParamData>,}
#[derive(Debug)] pub struct LeSetPeriodicAdvertisingParamBuilder {pub advertising_handle: u8, pub periodic_advertising_interval_min: u16, pub periodic_advertising_interval_max: u16, pub include_tx_power: u8, }
impl LeSetPeriodicAdvertisingParamData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetPeriodicAdvertisingParam".to_string(),    field: "advertising_handle".to_string(),    wanted: 4,    got: bytes.len()});}let advertising_handle = u8::from_le_bytes([bytes[3]]);if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetPeriodicAdvertisingParam".to_string(),    field: "periodic_advertising_interval_min".to_string(),    wanted: 6,    got: bytes.len()});}let periodic_advertising_interval_min = u16::from_le_bytes([bytes[4],bytes[5]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeSetPeriodicAdvertisingParam".to_string(),    field: "periodic_advertising_interval_max".to_string(),    wanted: 8,    got: bytes.len()});}let periodic_advertising_interval_max = u16::from_le_bytes([bytes[6],bytes[7]]);let include_tx_power = u8::from_le_bytes([bytes[8]]);let include_tx_power = include_tx_power >> 6;let include_tx_power = include_tx_power & 0x1;Ok(Self {advertising_handle, periodic_advertising_interval_min, periodic_advertising_interval_max, include_tx_power, })
}
fn write_to(&self, buffer: &mut BytesMut) {let advertising_handle = self.advertising_handle;buffer[3..4].copy_from_slice(&advertising_handle.to_le_bytes()[0..1]);let periodic_advertising_interval_min = self.periodic_advertising_interval_min;buffer[4..6].copy_from_slice(&periodic_advertising_interval_min.to_le_bytes()[0..2]);let periodic_advertising_interval_max = self.periodic_advertising_interval_max;buffer[6..8].copy_from_slice(&periodic_advertising_interval_max.to_le_bytes()[0..2]);let include_tx_power = self.include_tx_power;let include_tx_power = include_tx_power & 0x1;let include_tx_power = (include_tx_power << 6) | ((buffer[8] as u8) & 0x3f);buffer[8..9].copy_from_slice(&include_tx_power.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl CommandExpectations for LeSetPeriodicAdvertisingParamPacket { type ResponseType = LeSetPeriodicAdvertisingParamCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetPeriodicAdvertisingParamCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetPeriodicAdvertisingParamPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetPeriodicAdvertisingParamPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_set_periodic_advertising_param = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeSetPeriodicAdvertisingParam(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetPeriodicAdvertisingParam"),};Self {command,le_advertising_command,le_set_periodic_advertising_param,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_advertising_handle(&self) -> u8{ self.le_set_periodic_advertising_param.as_ref().advertising_handle}
pub fn get_periodic_advertising_interval_min(&self) -> u16{ self.le_set_periodic_advertising_param.as_ref().periodic_advertising_interval_min}
pub fn get_periodic_advertising_interval_max(&self) -> u16{ self.le_set_periodic_advertising_param.as_ref().periodic_advertising_interval_max}
pub fn get_include_tx_power(&self) -> u8{ self.le_set_periodic_advertising_param.as_ref().include_tx_power}
}
impl Into<CommandPacket> for LeSetPeriodicAdvertisingParamPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeSetPeriodicAdvertisingParamPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetPeriodicAdvertisingParamBuilder { type ResponseType = LeSetPeriodicAdvertisingParamCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetPeriodicAdvertisingParamCompletePacket::new(pkt.event.clone()) }}impl LeSetPeriodicAdvertisingParamBuilder {pub fn build(self) -> LeSetPeriodicAdvertisingParamPacket {let le_set_periodic_advertising_param= Arc::new(LeSetPeriodicAdvertisingParamData {advertising_handle: self.advertising_handle, periodic_advertising_interval_min: self.periodic_advertising_interval_min, periodic_advertising_interval_max: self.periodic_advertising_interval_max, include_tx_power: self.include_tx_power, });let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeSetPeriodicAdvertisingParam(le_set_periodic_advertising_param),});let command= Arc::new(CommandData {op_code: OpCode::LeSetPeriodicAdvertisingParam, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeSetPeriodicAdvertisingParamPacket::new(command)}
}
impl Into<CommandPacket> for LeSetPeriodicAdvertisingParamBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeSetPeriodicAdvertisingParamBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetPeriodicAdvertisingParamCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeSetPeriodicAdvertisingParamCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_periodic_advertising_param_complete: Arc<LeSetPeriodicAdvertisingParamCompleteData>,}
#[derive(Debug)] pub struct LeSetPeriodicAdvertisingParamCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeSetPeriodicAdvertisingParamCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetPeriodicAdvertisingParamComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeSetPeriodicAdvertisingParamCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetPeriodicAdvertisingParamCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_periodic_advertising_param_complete = match &command_complete.child {CommandCompleteDataChild::LeSetPeriodicAdvertisingParamComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetPeriodicAdvertisingParamComplete"),};Self {event,command_complete,le_set_periodic_advertising_param_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_periodic_advertising_param_complete.as_ref().status}
}
impl Into<EventPacket> for LeSetPeriodicAdvertisingParamCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetPeriodicAdvertisingParamCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetPeriodicAdvertisingParamCompleteBuilder {pub fn build(self) -> LeSetPeriodicAdvertisingParamCompletePacket {let le_set_periodic_advertising_param_complete= Arc::new(LeSetPeriodicAdvertisingParamCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetPeriodicAdvertisingParam, child: CommandCompleteDataChild::LeSetPeriodicAdvertisingParamComplete(le_set_periodic_advertising_param_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetPeriodicAdvertisingParamCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetPeriodicAdvertisingParamCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetPeriodicAdvertisingParamCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetPeriodicAdvertisingDataData {advertising_handle: u8, operation: Operation, scan_response_data: Vec::<GapData>, }
#[derive(Debug, Clone)] pub struct LeSetPeriodicAdvertisingDataPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_set_periodic_advertising_data: Arc<LeSetPeriodicAdvertisingDataData>,}
#[derive(Debug)] pub struct LeSetPeriodicAdvertisingDataBuilder {pub advertising_handle: u8, pub operation: Operation, pub scan_response_data: Vec::<GapData>, }
impl LeSetPeriodicAdvertisingDataData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetPeriodicAdvertisingData".to_string(),    field: "advertising_handle".to_string(),    wanted: 4,    got: bytes.len()});}let advertising_handle = u8::from_le_bytes([bytes[3]]);let operation = u8::from_le_bytes([bytes[4]]);let operation = operation & 0x7;let operation = Operation::from_u8(operation).unwrap();if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetPeriodicAdvertisingData".to_string(),    field: "scan_response_data_size".to_string(),    wanted: 6,    got: bytes.len()});}let scan_response_data_size = u8::from_le_bytes([bytes[5]]);let mut scan_response_data: Vec::<GapData> = Vec::new();let mut parsable_ = &bytes[6..6 + (scan_response_data_size as usize)];while parsable_.len() > 0 { match GapData::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];scan_response_data.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {advertising_handle, operation, scan_response_data, })
}
fn write_to(&self, buffer: &mut BytesMut) {let advertising_handle = self.advertising_handle;buffer[3..4].copy_from_slice(&advertising_handle.to_le_bytes()[0..1]);let operation = self.operation.to_u8().unwrap();let operation = operation & 0x7;buffer[4..5].copy_from_slice(&operation.to_le_bytes()[0..1]);let scan_response_data_bytes = self.scan_response_data.iter().fold(0, |acc, x| acc + x.get_total_size());let scan_response_data_size = u8::try_from(scan_response_data_bytes).expect("payload size did not fit");buffer[5..6].copy_from_slice(&scan_response_data_size.to_le_bytes()[0..1]);let mut vec_buffer_ = &mut buffer[6..];for e_ in &self.scan_response_data { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;let ret = ret + self.scan_response_data.iter().fold(0, |acc, x| acc + x.get_total_size());ret}
}
impl CommandExpectations for LeSetPeriodicAdvertisingDataPacket { type ResponseType = LeSetPeriodicAdvertisingDataCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetPeriodicAdvertisingDataCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetPeriodicAdvertisingDataPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetPeriodicAdvertisingDataPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_set_periodic_advertising_data = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeSetPeriodicAdvertisingData(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetPeriodicAdvertisingData"),};Self {command,le_advertising_command,le_set_periodic_advertising_data,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_advertising_handle(&self) -> u8{ self.le_set_periodic_advertising_data.as_ref().advertising_handle}
pub fn get_operation(&self) -> Operation{ self.le_set_periodic_advertising_data.as_ref().operation}
pub fn get_scan_response_data(&self) -> &Vec::<GapData>{ &self.le_set_periodic_advertising_data.as_ref().scan_response_data}
}
impl Into<CommandPacket> for LeSetPeriodicAdvertisingDataPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeSetPeriodicAdvertisingDataPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetPeriodicAdvertisingDataBuilder { type ResponseType = LeSetPeriodicAdvertisingDataCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetPeriodicAdvertisingDataCompletePacket::new(pkt.event.clone()) }}impl LeSetPeriodicAdvertisingDataBuilder {pub fn build(self) -> LeSetPeriodicAdvertisingDataPacket {let le_set_periodic_advertising_data= Arc::new(LeSetPeriodicAdvertisingDataData {advertising_handle: self.advertising_handle, operation: self.operation, scan_response_data: self.scan_response_data, });let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeSetPeriodicAdvertisingData(le_set_periodic_advertising_data),});let command= Arc::new(CommandData {op_code: OpCode::LeSetPeriodicAdvertisingData, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeSetPeriodicAdvertisingDataPacket::new(command)}
}
impl Into<CommandPacket> for LeSetPeriodicAdvertisingDataBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeSetPeriodicAdvertisingDataBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetPeriodicAdvertisingDataCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeSetPeriodicAdvertisingDataCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_periodic_advertising_data_complete: Arc<LeSetPeriodicAdvertisingDataCompleteData>,}
#[derive(Debug)] pub struct LeSetPeriodicAdvertisingDataCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeSetPeriodicAdvertisingDataCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetPeriodicAdvertisingDataComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeSetPeriodicAdvertisingDataCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetPeriodicAdvertisingDataCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_periodic_advertising_data_complete = match &command_complete.child {CommandCompleteDataChild::LeSetPeriodicAdvertisingDataComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetPeriodicAdvertisingDataComplete"),};Self {event,command_complete,le_set_periodic_advertising_data_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_periodic_advertising_data_complete.as_ref().status}
}
impl Into<EventPacket> for LeSetPeriodicAdvertisingDataCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetPeriodicAdvertisingDataCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetPeriodicAdvertisingDataCompleteBuilder {pub fn build(self) -> LeSetPeriodicAdvertisingDataCompletePacket {let le_set_periodic_advertising_data_complete= Arc::new(LeSetPeriodicAdvertisingDataCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetPeriodicAdvertisingData, child: CommandCompleteDataChild::LeSetPeriodicAdvertisingDataComplete(le_set_periodic_advertising_data_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetPeriodicAdvertisingDataCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetPeriodicAdvertisingDataCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetPeriodicAdvertisingDataCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetPeriodicAdvertisingEnableData {enable: Enable, advertising_handle: u8, }
#[derive(Debug, Clone)] pub struct LeSetPeriodicAdvertisingEnablePacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_set_periodic_advertising_enable: Arc<LeSetPeriodicAdvertisingEnableData>,}
#[derive(Debug)] pub struct LeSetPeriodicAdvertisingEnableBuilder {pub enable: Enable, pub advertising_handle: u8, }
impl LeSetPeriodicAdvertisingEnableData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetPeriodicAdvertisingEnable".to_string(),    field: "enable".to_string(),    wanted: 4,    got: bytes.len()});}let enable = u8::from_le_bytes([bytes[3]]);let enable = Enable::from_u8(enable).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeSetPeriodicAdvertisingEnable".to_string(),    field: "advertising_handle".to_string(),    wanted: 5,    got: bytes.len()});}let advertising_handle = u8::from_le_bytes([bytes[4]]);Ok(Self {enable, advertising_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let enable = self.enable.to_u8().unwrap();buffer[3..4].copy_from_slice(&enable.to_le_bytes()[0..1]);let advertising_handle = self.advertising_handle;buffer[4..5].copy_from_slice(&advertising_handle.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for LeSetPeriodicAdvertisingEnablePacket { type ResponseType = LeSetPeriodicAdvertisingEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetPeriodicAdvertisingEnableCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetPeriodicAdvertisingEnablePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetPeriodicAdvertisingEnablePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_set_periodic_advertising_enable = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeSetPeriodicAdvertisingEnable(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetPeriodicAdvertisingEnable"),};Self {command,le_advertising_command,le_set_periodic_advertising_enable,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_enable(&self) -> Enable{ self.le_set_periodic_advertising_enable.as_ref().enable}
pub fn get_advertising_handle(&self) -> u8{ self.le_set_periodic_advertising_enable.as_ref().advertising_handle}
}
impl Into<CommandPacket> for LeSetPeriodicAdvertisingEnablePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeSetPeriodicAdvertisingEnablePacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetPeriodicAdvertisingEnableBuilder { type ResponseType = LeSetPeriodicAdvertisingEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetPeriodicAdvertisingEnableCompletePacket::new(pkt.event.clone()) }}impl LeSetPeriodicAdvertisingEnableBuilder {pub fn build(self) -> LeSetPeriodicAdvertisingEnablePacket {let le_set_periodic_advertising_enable= Arc::new(LeSetPeriodicAdvertisingEnableData {enable: self.enable, advertising_handle: self.advertising_handle, });let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeSetPeriodicAdvertisingEnable(le_set_periodic_advertising_enable),});let command= Arc::new(CommandData {op_code: OpCode::LeSetPeriodicAdvertisingEnable, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeSetPeriodicAdvertisingEnablePacket::new(command)}
}
impl Into<CommandPacket> for LeSetPeriodicAdvertisingEnableBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeSetPeriodicAdvertisingEnableBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetPeriodicAdvertisingEnableCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeSetPeriodicAdvertisingEnableCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_periodic_advertising_enable_complete: Arc<LeSetPeriodicAdvertisingEnableCompleteData>,}
#[derive(Debug)] pub struct LeSetPeriodicAdvertisingEnableCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeSetPeriodicAdvertisingEnableCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetPeriodicAdvertisingEnableComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeSetPeriodicAdvertisingEnableCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetPeriodicAdvertisingEnableCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_periodic_advertising_enable_complete = match &command_complete.child {CommandCompleteDataChild::LeSetPeriodicAdvertisingEnableComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetPeriodicAdvertisingEnableComplete"),};Self {event,command_complete,le_set_periodic_advertising_enable_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_periodic_advertising_enable_complete.as_ref().status}
}
impl Into<EventPacket> for LeSetPeriodicAdvertisingEnableCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetPeriodicAdvertisingEnableCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetPeriodicAdvertisingEnableCompleteBuilder {pub fn build(self) -> LeSetPeriodicAdvertisingEnableCompletePacket {let le_set_periodic_advertising_enable_complete= Arc::new(LeSetPeriodicAdvertisingEnableCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetPeriodicAdvertisingEnable, child: CommandCompleteDataChild::LeSetPeriodicAdvertisingEnableComplete(le_set_periodic_advertising_enable_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetPeriodicAdvertisingEnableCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetPeriodicAdvertisingEnableCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetPeriodicAdvertisingEnableCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetExtendedScanParametersData {own_address_type: OwnAddressType, scanning_filter_policy: LeScanningFilterPolicy, scanning_phys: u8, parameters: Vec::<PhyScanParameters>, }
#[derive(Debug, Clone)] pub struct LeSetExtendedScanParametersPacket {command: Arc<CommandData>,le_scanning_command: Arc<LeScanningCommandData>,le_set_extended_scan_parameters: Arc<LeSetExtendedScanParametersData>,}
#[derive(Debug)] pub struct LeSetExtendedScanParametersBuilder {pub own_address_type: OwnAddressType, pub scanning_filter_policy: LeScanningFilterPolicy, pub scanning_phys: u8, pub parameters: Vec::<PhyScanParameters>, }
impl LeSetExtendedScanParametersData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedScanParameters".to_string(),    field: "own_address_type".to_string(),    wanted: 4,    got: bytes.len()});}let own_address_type = u8::from_le_bytes([bytes[3]]);let own_address_type = OwnAddressType::from_u8(own_address_type).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedScanParameters".to_string(),    field: "scanning_filter_policy".to_string(),    wanted: 5,    got: bytes.len()});}let scanning_filter_policy = u8::from_le_bytes([bytes[4]]);let scanning_filter_policy = LeScanningFilterPolicy::from_u8(scanning_filter_policy).unwrap();if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedScanParameters".to_string(),    field: "scanning_phys".to_string(),    wanted: 6,    got: bytes.len()});}let scanning_phys = u8::from_le_bytes([bytes[5]]);let mut parameters: Vec::<PhyScanParameters> = Vec::new();let mut parsable_ = &bytes[6..];while parsable_.len() > 0 { match PhyScanParameters::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];parameters.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {own_address_type, scanning_filter_policy, scanning_phys, parameters, })
}
fn write_to(&self, buffer: &mut BytesMut) {let own_address_type = self.own_address_type.to_u8().unwrap();buffer[3..4].copy_from_slice(&own_address_type.to_le_bytes()[0..1]);let scanning_filter_policy = self.scanning_filter_policy.to_u8().unwrap();buffer[4..5].copy_from_slice(&scanning_filter_policy.to_le_bytes()[0..1]);let scanning_phys = self.scanning_phys;buffer[5..6].copy_from_slice(&scanning_phys.to_le_bytes()[0..1]);let mut vec_buffer_ = &mut buffer[6..];for e_ in &self.parameters { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;let ret = ret + (self.parameters.len() * ((/* Bits: */ 40 + /* Dynamic: */ 0) / 8));ret}
}
impl CommandExpectations for LeSetExtendedScanParametersPacket { type ResponseType = LeSetExtendedScanParametersCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetExtendedScanParametersCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetExtendedScanParametersPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetExtendedScanParametersPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_scanning_command = match &command.child {CommandDataChild::LeScanningCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanningCommand"),};let le_set_extended_scan_parameters = match &le_scanning_command.child {LeScanningCommandDataChild::LeSetExtendedScanParameters(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetExtendedScanParameters"),};Self {command,le_scanning_command,le_set_extended_scan_parameters,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_own_address_type(&self) -> OwnAddressType{ self.le_set_extended_scan_parameters.as_ref().own_address_type}
pub fn get_scanning_filter_policy(&self) -> LeScanningFilterPolicy{ self.le_set_extended_scan_parameters.as_ref().scanning_filter_policy}
pub fn get_scanning_phys(&self) -> u8{ self.le_set_extended_scan_parameters.as_ref().scanning_phys}
pub fn get_parameters(&self) -> &Vec::<PhyScanParameters>{ &self.le_set_extended_scan_parameters.as_ref().parameters}
}
impl Into<CommandPacket> for LeSetExtendedScanParametersPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeScanningCommandPacket> for LeSetExtendedScanParametersPacket { fn into(self) -> LeScanningCommandPacket {LeScanningCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetExtendedScanParametersBuilder { type ResponseType = LeSetExtendedScanParametersCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetExtendedScanParametersCompletePacket::new(pkt.event.clone()) }}impl LeSetExtendedScanParametersBuilder {pub fn build(self) -> LeSetExtendedScanParametersPacket {let le_set_extended_scan_parameters= Arc::new(LeSetExtendedScanParametersData {own_address_type: self.own_address_type, scanning_filter_policy: self.scanning_filter_policy, scanning_phys: self.scanning_phys, parameters: self.parameters, });let le_scanning_command= Arc::new(LeScanningCommandData {child: LeScanningCommandDataChild::LeSetExtendedScanParameters(le_set_extended_scan_parameters),});let command= Arc::new(CommandData {op_code: OpCode::LeSetExtendedScanParameters, child: CommandDataChild::LeScanningCommand(le_scanning_command),});LeSetExtendedScanParametersPacket::new(command)}
}
impl Into<CommandPacket> for LeSetExtendedScanParametersBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeScanningCommandPacket> for LeSetExtendedScanParametersBuilder { fn into(self) -> LeScanningCommandPacket { self.build().into() }}
macro_rules! le_set_extended_scan_parameters_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::LeScanningCommand(le_scanning_command_packet) => {match le_scanning_command_packet.specialize() {/* (2) */
LeScanningCommandChild::LeSetExtendedScanParameters(packet) => {let rebuilder = LeSetExtendedScanParametersBuilder {own_address_type : packet.get_own_address_type(),scanning_filter_policy : packet.get_scanning_filter_policy(),scanning_phys : packet.get_scanning_phys(),parameters : packet.get_parameters().to_vec(),};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse le_set_extended_scan_parameters{:02x?}", le_scanning_command_packet); }}}_ => {println!("Couldn't parse le_scanning_command{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}le_set_extended_scan_parameters_builder_tests! { le_set_extended_scan_parameters_builder_test_00: b"\x41\x20\x08\x01\x00\x01\x01\x12\x00\x12\x00",le_set_extended_scan_parameters_builder_test_01: b"\x41\x20\x08\x01\x00\x01\x01\x99\x19\x99\x19",}


#[derive(Debug)] struct LeSetExtendedScanParametersCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeSetExtendedScanParametersCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_extended_scan_parameters_complete: Arc<LeSetExtendedScanParametersCompleteData>,}
#[derive(Debug)] pub struct LeSetExtendedScanParametersCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeSetExtendedScanParametersCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedScanParametersComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeSetExtendedScanParametersCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetExtendedScanParametersCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_extended_scan_parameters_complete = match &command_complete.child {CommandCompleteDataChild::LeSetExtendedScanParametersComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetExtendedScanParametersComplete"),};Self {event,command_complete,le_set_extended_scan_parameters_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_extended_scan_parameters_complete.as_ref().status}
}
impl Into<EventPacket> for LeSetExtendedScanParametersCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetExtendedScanParametersCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetExtendedScanParametersCompleteBuilder {pub fn build(self) -> LeSetExtendedScanParametersCompletePacket {let le_set_extended_scan_parameters_complete= Arc::new(LeSetExtendedScanParametersCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetExtendedScanParameters, child: CommandCompleteDataChild::LeSetExtendedScanParametersComplete(le_set_extended_scan_parameters_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetExtendedScanParametersCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetExtendedScanParametersCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetExtendedScanParametersCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! le_set_extended_scan_parameters_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::LeSetExtendedScanParametersComplete(packet) => {let rebuilder = LeSetExtendedScanParametersCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse le_set_extended_scan_parameters_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}le_set_extended_scan_parameters_complete_builder_tests! { le_set_extended_scan_parameters_complete_builder_test_00: b"\x0e\x04\x01\x41\x20\x00",}


#[derive(Debug)] struct LeSetExtendedScanEnableData {enable: Enable, filter_duplicates: FilterDuplicates, duration: u16, period: u16, }
#[derive(Debug, Clone)] pub struct LeSetExtendedScanEnablePacket {command: Arc<CommandData>,le_scanning_command: Arc<LeScanningCommandData>,le_set_extended_scan_enable: Arc<LeSetExtendedScanEnableData>,}
#[derive(Debug)] pub struct LeSetExtendedScanEnableBuilder {pub enable: Enable, pub filter_duplicates: FilterDuplicates, pub duration: u16, pub period: u16, }
impl LeSetExtendedScanEnableData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedScanEnable".to_string(),    field: "enable".to_string(),    wanted: 4,    got: bytes.len()});}let enable = u8::from_le_bytes([bytes[3]]);let enable = Enable::from_u8(enable).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedScanEnable".to_string(),    field: "filter_duplicates".to_string(),    wanted: 5,    got: bytes.len()});}let filter_duplicates = u8::from_le_bytes([bytes[4]]);let filter_duplicates = FilterDuplicates::from_u8(filter_duplicates).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedScanEnable".to_string(),    field: "duration".to_string(),    wanted: 7,    got: bytes.len()});}let duration = u16::from_le_bytes([bytes[5],bytes[6]]);if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedScanEnable".to_string(),    field: "period".to_string(),    wanted: 9,    got: bytes.len()});}let period = u16::from_le_bytes([bytes[7],bytes[8]]);Ok(Self {enable, filter_duplicates, duration, period, })
}
fn write_to(&self, buffer: &mut BytesMut) {let enable = self.enable.to_u8().unwrap();buffer[3..4].copy_from_slice(&enable.to_le_bytes()[0..1]);let filter_duplicates = self.filter_duplicates.to_u8().unwrap();buffer[4..5].copy_from_slice(&filter_duplicates.to_le_bytes()[0..1]);let duration = self.duration;buffer[5..7].copy_from_slice(&duration.to_le_bytes()[0..2]);let period = self.period;buffer[7..9].copy_from_slice(&period.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl CommandExpectations for LeSetExtendedScanEnablePacket { type ResponseType = LeSetExtendedScanEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetExtendedScanEnableCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetExtendedScanEnablePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetExtendedScanEnablePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_scanning_command = match &command.child {CommandDataChild::LeScanningCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanningCommand"),};let le_set_extended_scan_enable = match &le_scanning_command.child {LeScanningCommandDataChild::LeSetExtendedScanEnable(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetExtendedScanEnable"),};Self {command,le_scanning_command,le_set_extended_scan_enable,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_enable(&self) -> Enable{ self.le_set_extended_scan_enable.as_ref().enable}
pub fn get_filter_duplicates(&self) -> FilterDuplicates{ self.le_set_extended_scan_enable.as_ref().filter_duplicates}
pub fn get_duration(&self) -> u16{ self.le_set_extended_scan_enable.as_ref().duration}
pub fn get_period(&self) -> u16{ self.le_set_extended_scan_enable.as_ref().period}
}
impl Into<CommandPacket> for LeSetExtendedScanEnablePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeScanningCommandPacket> for LeSetExtendedScanEnablePacket { fn into(self) -> LeScanningCommandPacket {LeScanningCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetExtendedScanEnableBuilder { type ResponseType = LeSetExtendedScanEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetExtendedScanEnableCompletePacket::new(pkt.event.clone()) }}impl LeSetExtendedScanEnableBuilder {pub fn build(self) -> LeSetExtendedScanEnablePacket {let le_set_extended_scan_enable= Arc::new(LeSetExtendedScanEnableData {enable: self.enable, filter_duplicates: self.filter_duplicates, duration: self.duration, period: self.period, });let le_scanning_command= Arc::new(LeScanningCommandData {child: LeScanningCommandDataChild::LeSetExtendedScanEnable(le_set_extended_scan_enable),});let command= Arc::new(CommandData {op_code: OpCode::LeSetExtendedScanEnable, child: CommandDataChild::LeScanningCommand(le_scanning_command),});LeSetExtendedScanEnablePacket::new(command)}
}
impl Into<CommandPacket> for LeSetExtendedScanEnableBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeScanningCommandPacket> for LeSetExtendedScanEnableBuilder { fn into(self) -> LeScanningCommandPacket { self.build().into() }}
macro_rules! le_set_extended_scan_enable_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::LeScanningCommand(le_scanning_command_packet) => {match le_scanning_command_packet.specialize() {/* (2) */
LeScanningCommandChild::LeSetExtendedScanEnable(packet) => {let rebuilder = LeSetExtendedScanEnableBuilder {enable : packet.get_enable(),filter_duplicates : packet.get_filter_duplicates(),duration : packet.get_duration(),period : packet.get_period(),};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse le_set_extended_scan_enable{:02x?}", le_scanning_command_packet); }}}_ => {println!("Couldn't parse le_scanning_command{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}le_set_extended_scan_enable_builder_tests! { le_set_extended_scan_enable_builder_test_00: b"\x42\x20\x06\x00\x01\x00\x00\x00\x00",le_set_extended_scan_enable_builder_test_01: b"\x42\x20\x06\x01\x00\x00\x00\x00\x00",}


#[derive(Debug)] struct LeSetExtendedScanEnableCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeSetExtendedScanEnableCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_extended_scan_enable_complete: Arc<LeSetExtendedScanEnableCompleteData>,}
#[derive(Debug)] pub struct LeSetExtendedScanEnableCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeSetExtendedScanEnableCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetExtendedScanEnableComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeSetExtendedScanEnableCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetExtendedScanEnableCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_extended_scan_enable_complete = match &command_complete.child {CommandCompleteDataChild::LeSetExtendedScanEnableComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetExtendedScanEnableComplete"),};Self {event,command_complete,le_set_extended_scan_enable_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_extended_scan_enable_complete.as_ref().status}
}
impl Into<EventPacket> for LeSetExtendedScanEnableCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetExtendedScanEnableCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetExtendedScanEnableCompleteBuilder {pub fn build(self) -> LeSetExtendedScanEnableCompletePacket {let le_set_extended_scan_enable_complete= Arc::new(LeSetExtendedScanEnableCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetExtendedScanEnable, child: CommandCompleteDataChild::LeSetExtendedScanEnableComplete(le_set_extended_scan_enable_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetExtendedScanEnableCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetExtendedScanEnableCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetExtendedScanEnableCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! le_set_extended_scan_enable_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::LeSetExtendedScanEnableComplete(packet) => {let rebuilder = LeSetExtendedScanEnableCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse le_set_extended_scan_enable_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}le_set_extended_scan_enable_complete_builder_tests! { le_set_extended_scan_enable_complete_builder_test_00: b"\x0e\x04\x01\x42\x20\x00",}


#[derive(Debug)] struct LeExtendedCreateConnectionData {initiator_filter_policy: InitiatorFilterPolicy, own_address_type: OwnAddressType, peer_address_type: AddressType, peer_address: Address, initiating_phys: u8, phy_scan_parameters: Vec::<LeCreateConnPhyScanParameters>, }
#[derive(Debug, Clone)] pub struct LeExtendedCreateConnectionPacket {command: Arc<CommandData>,acl_command: Arc<AclCommandData>,le_connection_management_command: Arc<LeConnectionManagementCommandData>,le_extended_create_connection: Arc<LeExtendedCreateConnectionData>,}
#[derive(Debug)] pub struct LeExtendedCreateConnectionBuilder {pub initiator_filter_policy: InitiatorFilterPolicy, pub own_address_type: OwnAddressType, pub peer_address_type: AddressType, pub peer_address: Address, pub initiating_phys: u8, pub phy_scan_parameters: Vec::<LeCreateConnPhyScanParameters>, }
impl LeExtendedCreateConnectionData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeExtendedCreateConnection".to_string(),    field: "initiator_filter_policy".to_string(),    wanted: 4,    got: bytes.len()});}let initiator_filter_policy = u8::from_le_bytes([bytes[3]]);let initiator_filter_policy = InitiatorFilterPolicy::from_u8(initiator_filter_policy).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeExtendedCreateConnection".to_string(),    field: "own_address_type".to_string(),    wanted: 5,    got: bytes.len()});}let own_address_type = u8::from_le_bytes([bytes[4]]);let own_address_type = OwnAddressType::from_u8(own_address_type).unwrap();if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeExtendedCreateConnection".to_string(),    field: "peer_address_type".to_string(),    wanted: 6,    got: bytes.len()});}let peer_address_type = u8::from_le_bytes([bytes[5]]);let peer_address_type = AddressType::from_u8(peer_address_type).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "LeExtendedCreateConnection".to_string(),    field: "peer_address".to_string(),    wanted: 12,    got: bytes.len()});}let peer_address = bytes[6..12].try_into().unwrap();if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "LeExtendedCreateConnection".to_string(),    field: "initiating_phys".to_string(),    wanted: 13,    got: bytes.len()});}let initiating_phys = u8::from_le_bytes([bytes[12]]);let mut phy_scan_parameters: Vec::<LeCreateConnPhyScanParameters> = Vec::new();let mut parsable_ = &bytes[13..];while parsable_.len() > 0 { match LeCreateConnPhyScanParameters::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];phy_scan_parameters.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {initiator_filter_policy, own_address_type, peer_address_type, peer_address, initiating_phys, phy_scan_parameters, })
}
fn write_to(&self, buffer: &mut BytesMut) {let initiator_filter_policy = self.initiator_filter_policy.to_u8().unwrap();buffer[3..4].copy_from_slice(&initiator_filter_policy.to_le_bytes()[0..1]);let own_address_type = self.own_address_type.to_u8().unwrap();buffer[4..5].copy_from_slice(&own_address_type.to_le_bytes()[0..1]);let peer_address_type = self.peer_address_type.to_u8().unwrap();buffer[5..6].copy_from_slice(&peer_address_type.to_le_bytes()[0..1]);let peer_address: [u8; 6] = self.peer_address.into();buffer[6..12].copy_from_slice(&peer_address);let initiating_phys = self.initiating_phys;buffer[12..13].copy_from_slice(&initiating_phys.to_le_bytes()[0..1]);let mut vec_buffer_ = &mut buffer[13..];for e_ in &self.phy_scan_parameters { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 10;let ret = ret + (self.phy_scan_parameters.len() * ((/* Bits: */ 128 + /* Dynamic: */ 0) / 8));ret}
}
impl CommandExpectations for LeExtendedCreateConnectionPacket { type ResponseType = LeExtendedCreateConnectionStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeExtendedCreateConnectionStatusPacket::new(pkt.event.clone()) }}impl Packet for LeExtendedCreateConnectionPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeExtendedCreateConnectionPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let acl_command = match &command.child {CommandDataChild::AclCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AclCommand"),};let le_connection_management_command = match &acl_command.child {AclCommandDataChild::LeConnectionManagementCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeConnectionManagementCommand"),};let le_extended_create_connection = match &le_connection_management_command.child {LeConnectionManagementCommandDataChild::LeExtendedCreateConnection(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeExtendedCreateConnection"),};Self {command,acl_command,le_connection_management_command,le_extended_create_connection,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_initiator_filter_policy(&self) -> InitiatorFilterPolicy{ self.le_extended_create_connection.as_ref().initiator_filter_policy}
pub fn get_own_address_type(&self) -> OwnAddressType{ self.le_extended_create_connection.as_ref().own_address_type}
pub fn get_peer_address_type(&self) -> AddressType{ self.le_extended_create_connection.as_ref().peer_address_type}
pub fn get_peer_address(&self) -> Address{ self.le_extended_create_connection.as_ref().peer_address}
pub fn get_initiating_phys(&self) -> u8{ self.le_extended_create_connection.as_ref().initiating_phys}
pub fn get_phy_scan_parameters(&self) -> &Vec::<LeCreateConnPhyScanParameters>{ &self.le_extended_create_connection.as_ref().phy_scan_parameters}
}
impl Into<CommandPacket> for LeExtendedCreateConnectionPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<AclCommandPacket> for LeExtendedCreateConnectionPacket { fn into(self) -> AclCommandPacket {AclCommandPacket::new(self.command) }}
impl Into<LeConnectionManagementCommandPacket> for LeExtendedCreateConnectionPacket { fn into(self) -> LeConnectionManagementCommandPacket {LeConnectionManagementCommandPacket::new(self.command) }}
impl CommandExpectations for LeExtendedCreateConnectionBuilder { type ResponseType = LeExtendedCreateConnectionStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeExtendedCreateConnectionStatusPacket::new(pkt.event.clone()) }}impl LeExtendedCreateConnectionBuilder {pub fn build(self) -> LeExtendedCreateConnectionPacket {let le_extended_create_connection= Arc::new(LeExtendedCreateConnectionData {initiator_filter_policy: self.initiator_filter_policy, own_address_type: self.own_address_type, peer_address_type: self.peer_address_type, peer_address: self.peer_address, initiating_phys: self.initiating_phys, phy_scan_parameters: self.phy_scan_parameters, });let le_connection_management_command= Arc::new(LeConnectionManagementCommandData {child: LeConnectionManagementCommandDataChild::LeExtendedCreateConnection(le_extended_create_connection),});let acl_command= Arc::new(AclCommandData {child: AclCommandDataChild::LeConnectionManagementCommand(le_connection_management_command),});let command= Arc::new(CommandData {op_code: OpCode::LeExtendedCreateConnection, child: CommandDataChild::AclCommand(acl_command),});LeExtendedCreateConnectionPacket::new(command)}
}
impl Into<CommandPacket> for LeExtendedCreateConnectionBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<AclCommandPacket> for LeExtendedCreateConnectionBuilder { fn into(self) -> AclCommandPacket { self.build().into() }}
impl Into<LeConnectionManagementCommandPacket> for LeExtendedCreateConnectionBuilder { fn into(self) -> LeConnectionManagementCommandPacket { self.build().into() }}
macro_rules! le_extended_create_connection_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::AclCommand(acl_command_packet) => {match acl_command_packet.specialize() {/* (2) */
AclCommandChild::LeConnectionManagementCommand(le_connection_management_command_packet) => {match le_connection_management_command_packet.specialize() {/* (3) */
LeConnectionManagementCommandChild::LeExtendedCreateConnection(packet) => {let rebuilder = LeExtendedCreateConnectionBuilder {initiator_filter_policy : packet.get_initiator_filter_policy(),own_address_type : packet.get_own_address_type(),peer_address_type : packet.get_peer_address_type(),peer_address : packet.get_peer_address(),initiating_phys : packet.get_initiating_phys(),phy_scan_parameters : packet.get_phy_scan_parameters().to_vec(),};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse le_extended_create_connection{:02x?}", le_connection_management_command_packet); }}}_ => {println!("Couldn't parse le_connection_management_command{:02x?}", acl_command_packet); }}}_ => {println!("Couldn't parse acl_command{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}le_extended_create_connection_builder_tests! { le_extended_create_connection_builder_test_00: b"\x43\x20\x2a\x01\x01\x00\x00\x00\x00\x00\x00\x00\x03\x00\x08\x30\x00\x18\x00\x28\x00\x00\x00\xf4\x01\x00\x00\x00\x00\x00\x08\x30\x00\x18\x00\x28\x00\x00\x00\xf4\x01\x00\x00\x00\x00",}


#[derive(Debug)] struct LeExtendedCreateConnectionStatusData {}
#[derive(Debug, Clone)] pub struct LeExtendedCreateConnectionStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,le_extended_create_connection_status: Arc<LeExtendedCreateConnectionStatusData>,}
#[derive(Debug)] pub struct LeExtendedCreateConnectionStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl LeExtendedCreateConnectionStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeExtendedCreateConnectionStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeExtendedCreateConnectionStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let le_extended_create_connection_status = match &command_status.child {CommandStatusDataChild::LeExtendedCreateConnectionStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeExtendedCreateConnectionStatus"),};Self {event,command_status,le_extended_create_connection_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for LeExtendedCreateConnectionStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for LeExtendedCreateConnectionStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl LeExtendedCreateConnectionStatusBuilder {pub fn build(self) -> LeExtendedCreateConnectionStatusPacket {let le_extended_create_connection_status= Arc::new(LeExtendedCreateConnectionStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeExtendedCreateConnection, child: CommandStatusDataChild::LeExtendedCreateConnectionStatus(le_extended_create_connection_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});LeExtendedCreateConnectionStatusPacket::new(event)}
}
impl Into<EventPacket> for LeExtendedCreateConnectionStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for LeExtendedCreateConnectionStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] enum LePeriodicAdvertisingCreateSyncDataChild {Payload(Bytes),None,}
impl LePeriodicAdvertisingCreateSyncDataChild {fn get_total_size(&self) -> usize {match self {LePeriodicAdvertisingCreateSyncDataChild::Payload(p) => p.len(),LePeriodicAdvertisingCreateSyncDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LePeriodicAdvertisingCreateSyncChild {Payload(Bytes),None,}
#[derive(Debug)] struct LePeriodicAdvertisingCreateSyncData {child: LePeriodicAdvertisingCreateSyncDataChild,}
#[derive(Debug, Clone)] pub struct LePeriodicAdvertisingCreateSyncPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_periodic_advertising_create_sync: Arc<LePeriodicAdvertisingCreateSyncData>,}
#[derive(Debug)] pub struct LePeriodicAdvertisingCreateSyncBuilder {pub payload: Option<Bytes>,}
impl LePeriodicAdvertisingCreateSyncData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {let payload: Vec::<u8> = bytes[3..].into();let child = if payload.len() > 0 {LePeriodicAdvertisingCreateSyncDataChild::Payload(Bytes::from(payload))} else {LePeriodicAdvertisingCreateSyncDataChild::None};Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {LePeriodicAdvertisingCreateSyncDataChild::Payload(p) => buffer[3..].copy_from_slice(&p[..]),LePeriodicAdvertisingCreateSyncDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LePeriodicAdvertisingCreateSyncPacket { type ResponseType = LePeriodicAdvertisingCreateSyncStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LePeriodicAdvertisingCreateSyncStatusPacket::new(pkt.event.clone()) }}impl Packet for LePeriodicAdvertisingCreateSyncPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LePeriodicAdvertisingCreateSyncPacket { pub fn specialize(&self) -> LePeriodicAdvertisingCreateSyncChild { match &self.le_periodic_advertising_create_sync.child {LePeriodicAdvertisingCreateSyncDataChild::Payload(p) => LePeriodicAdvertisingCreateSyncChild::Payload(p.clone()),LePeriodicAdvertisingCreateSyncDataChild::None => LePeriodicAdvertisingCreateSyncChild::None,}} fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_periodic_advertising_create_sync = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LePeriodicAdvertisingCreateSync(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LePeriodicAdvertisingCreateSync"),};Self {command,le_advertising_command,le_periodic_advertising_create_sync,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LePeriodicAdvertisingCreateSyncPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LePeriodicAdvertisingCreateSyncPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LePeriodicAdvertisingCreateSyncBuilder { type ResponseType = LePeriodicAdvertisingCreateSyncStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LePeriodicAdvertisingCreateSyncStatusPacket::new(pkt.event.clone()) }}impl LePeriodicAdvertisingCreateSyncBuilder {pub fn build(self) -> LePeriodicAdvertisingCreateSyncPacket {let le_periodic_advertising_create_sync= Arc::new(LePeriodicAdvertisingCreateSyncData {child: match self.payload { None => LePeriodicAdvertisingCreateSyncDataChild::None,Some(bytes) => LePeriodicAdvertisingCreateSyncDataChild::Payload(bytes),},});let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LePeriodicAdvertisingCreateSync(le_periodic_advertising_create_sync),});let command= Arc::new(CommandData {op_code: OpCode::LePeriodicAdvertisingCreateSync, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LePeriodicAdvertisingCreateSyncPacket::new(command)}
}
impl Into<CommandPacket> for LePeriodicAdvertisingCreateSyncBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LePeriodicAdvertisingCreateSyncBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] struct LePeriodicAdvertisingCreateSyncStatusData {}
#[derive(Debug, Clone)] pub struct LePeriodicAdvertisingCreateSyncStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,le_periodic_advertising_create_sync_status: Arc<LePeriodicAdvertisingCreateSyncStatusData>,}
#[derive(Debug)] pub struct LePeriodicAdvertisingCreateSyncStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl LePeriodicAdvertisingCreateSyncStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LePeriodicAdvertisingCreateSyncStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LePeriodicAdvertisingCreateSyncStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let le_periodic_advertising_create_sync_status = match &command_status.child {CommandStatusDataChild::LePeriodicAdvertisingCreateSyncStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LePeriodicAdvertisingCreateSyncStatus"),};Self {event,command_status,le_periodic_advertising_create_sync_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for LePeriodicAdvertisingCreateSyncStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for LePeriodicAdvertisingCreateSyncStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl LePeriodicAdvertisingCreateSyncStatusBuilder {pub fn build(self) -> LePeriodicAdvertisingCreateSyncStatusPacket {let le_periodic_advertising_create_sync_status= Arc::new(LePeriodicAdvertisingCreateSyncStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LePeriodicAdvertisingCreateSync, child: CommandStatusDataChild::LePeriodicAdvertisingCreateSyncStatus(le_periodic_advertising_create_sync_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});LePeriodicAdvertisingCreateSyncStatusPacket::new(event)}
}
impl Into<EventPacket> for LePeriodicAdvertisingCreateSyncStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for LePeriodicAdvertisingCreateSyncStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] enum LePeriodicAdvertisingCreateSyncCancelDataChild {Payload(Bytes),None,}
impl LePeriodicAdvertisingCreateSyncCancelDataChild {fn get_total_size(&self) -> usize {match self {LePeriodicAdvertisingCreateSyncCancelDataChild::Payload(p) => p.len(),LePeriodicAdvertisingCreateSyncCancelDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LePeriodicAdvertisingCreateSyncCancelChild {Payload(Bytes),None,}
#[derive(Debug)] struct LePeriodicAdvertisingCreateSyncCancelData {child: LePeriodicAdvertisingCreateSyncCancelDataChild,}
#[derive(Debug, Clone)] pub struct LePeriodicAdvertisingCreateSyncCancelPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_periodic_advertising_create_sync_cancel: Arc<LePeriodicAdvertisingCreateSyncCancelData>,}
#[derive(Debug)] pub struct LePeriodicAdvertisingCreateSyncCancelBuilder {pub payload: Option<Bytes>,}
impl LePeriodicAdvertisingCreateSyncCancelData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {let payload: Vec::<u8> = bytes[3..].into();let child = if payload.len() > 0 {LePeriodicAdvertisingCreateSyncCancelDataChild::Payload(Bytes::from(payload))} else {LePeriodicAdvertisingCreateSyncCancelDataChild::None};Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {LePeriodicAdvertisingCreateSyncCancelDataChild::Payload(p) => buffer[3..].copy_from_slice(&p[..]),LePeriodicAdvertisingCreateSyncCancelDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LePeriodicAdvertisingCreateSyncCancelPacket { type ResponseType = LePeriodicAdvertisingCreateSyncCancelCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LePeriodicAdvertisingCreateSyncCancelCompletePacket::new(pkt.event.clone()) }}impl Packet for LePeriodicAdvertisingCreateSyncCancelPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LePeriodicAdvertisingCreateSyncCancelPacket { pub fn specialize(&self) -> LePeriodicAdvertisingCreateSyncCancelChild { match &self.le_periodic_advertising_create_sync_cancel.child {LePeriodicAdvertisingCreateSyncCancelDataChild::Payload(p) => LePeriodicAdvertisingCreateSyncCancelChild::Payload(p.clone()),LePeriodicAdvertisingCreateSyncCancelDataChild::None => LePeriodicAdvertisingCreateSyncCancelChild::None,}} fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_periodic_advertising_create_sync_cancel = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LePeriodicAdvertisingCreateSyncCancel(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LePeriodicAdvertisingCreateSyncCancel"),};Self {command,le_advertising_command,le_periodic_advertising_create_sync_cancel,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LePeriodicAdvertisingCreateSyncCancelPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LePeriodicAdvertisingCreateSyncCancelPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LePeriodicAdvertisingCreateSyncCancelBuilder { type ResponseType = LePeriodicAdvertisingCreateSyncCancelCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LePeriodicAdvertisingCreateSyncCancelCompletePacket::new(pkt.event.clone()) }}impl LePeriodicAdvertisingCreateSyncCancelBuilder {pub fn build(self) -> LePeriodicAdvertisingCreateSyncCancelPacket {let le_periodic_advertising_create_sync_cancel= Arc::new(LePeriodicAdvertisingCreateSyncCancelData {child: match self.payload { None => LePeriodicAdvertisingCreateSyncCancelDataChild::None,Some(bytes) => LePeriodicAdvertisingCreateSyncCancelDataChild::Payload(bytes),},});let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LePeriodicAdvertisingCreateSyncCancel(le_periodic_advertising_create_sync_cancel),});let command= Arc::new(CommandData {op_code: OpCode::LePeriodicAdvertisingCreateSyncCancel, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LePeriodicAdvertisingCreateSyncCancelPacket::new(command)}
}
impl Into<CommandPacket> for LePeriodicAdvertisingCreateSyncCancelBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LePeriodicAdvertisingCreateSyncCancelBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] struct LePeriodicAdvertisingCreateSyncCancelCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LePeriodicAdvertisingCreateSyncCancelCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_periodic_advertising_create_sync_cancel_complete: Arc<LePeriodicAdvertisingCreateSyncCancelCompleteData>,}
#[derive(Debug)] pub struct LePeriodicAdvertisingCreateSyncCancelCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LePeriodicAdvertisingCreateSyncCancelCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LePeriodicAdvertisingCreateSyncCancelComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LePeriodicAdvertisingCreateSyncCancelCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LePeriodicAdvertisingCreateSyncCancelCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_periodic_advertising_create_sync_cancel_complete = match &command_complete.child {CommandCompleteDataChild::LePeriodicAdvertisingCreateSyncCancelComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LePeriodicAdvertisingCreateSyncCancelComplete"),};Self {event,command_complete,le_periodic_advertising_create_sync_cancel_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_periodic_advertising_create_sync_cancel_complete.as_ref().status}
}
impl Into<EventPacket> for LePeriodicAdvertisingCreateSyncCancelCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LePeriodicAdvertisingCreateSyncCancelCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LePeriodicAdvertisingCreateSyncCancelCompleteBuilder {pub fn build(self) -> LePeriodicAdvertisingCreateSyncCancelCompletePacket {let le_periodic_advertising_create_sync_cancel_complete= Arc::new(LePeriodicAdvertisingCreateSyncCancelCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LePeriodicAdvertisingCreateSyncCancel, child: CommandCompleteDataChild::LePeriodicAdvertisingCreateSyncCancelComplete(le_periodic_advertising_create_sync_cancel_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LePeriodicAdvertisingCreateSyncCancelCompletePacket::new(event)}
}
impl Into<EventPacket> for LePeriodicAdvertisingCreateSyncCancelCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LePeriodicAdvertisingCreateSyncCancelCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] enum LePeriodicAdvertisingTerminateSyncDataChild {Payload(Bytes),None,}
impl LePeriodicAdvertisingTerminateSyncDataChild {fn get_total_size(&self) -> usize {match self {LePeriodicAdvertisingTerminateSyncDataChild::Payload(p) => p.len(),LePeriodicAdvertisingTerminateSyncDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LePeriodicAdvertisingTerminateSyncChild {Payload(Bytes),None,}
#[derive(Debug)] struct LePeriodicAdvertisingTerminateSyncData {child: LePeriodicAdvertisingTerminateSyncDataChild,}
#[derive(Debug, Clone)] pub struct LePeriodicAdvertisingTerminateSyncPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_periodic_advertising_terminate_sync: Arc<LePeriodicAdvertisingTerminateSyncData>,}
#[derive(Debug)] pub struct LePeriodicAdvertisingTerminateSyncBuilder {pub payload: Option<Bytes>,}
impl LePeriodicAdvertisingTerminateSyncData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {let payload: Vec::<u8> = bytes[3..].into();let child = if payload.len() > 0 {LePeriodicAdvertisingTerminateSyncDataChild::Payload(Bytes::from(payload))} else {LePeriodicAdvertisingTerminateSyncDataChild::None};Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {LePeriodicAdvertisingTerminateSyncDataChild::Payload(p) => buffer[3..].copy_from_slice(&p[..]),LePeriodicAdvertisingTerminateSyncDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LePeriodicAdvertisingTerminateSyncPacket { type ResponseType = LePeriodicAdvertisingTerminateSyncCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LePeriodicAdvertisingTerminateSyncCompletePacket::new(pkt.event.clone()) }}impl Packet for LePeriodicAdvertisingTerminateSyncPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LePeriodicAdvertisingTerminateSyncPacket { pub fn specialize(&self) -> LePeriodicAdvertisingTerminateSyncChild { match &self.le_periodic_advertising_terminate_sync.child {LePeriodicAdvertisingTerminateSyncDataChild::Payload(p) => LePeriodicAdvertisingTerminateSyncChild::Payload(p.clone()),LePeriodicAdvertisingTerminateSyncDataChild::None => LePeriodicAdvertisingTerminateSyncChild::None,}} fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_periodic_advertising_terminate_sync = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LePeriodicAdvertisingTerminateSync(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LePeriodicAdvertisingTerminateSync"),};Self {command,le_advertising_command,le_periodic_advertising_terminate_sync,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LePeriodicAdvertisingTerminateSyncPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LePeriodicAdvertisingTerminateSyncPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LePeriodicAdvertisingTerminateSyncBuilder { type ResponseType = LePeriodicAdvertisingTerminateSyncCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LePeriodicAdvertisingTerminateSyncCompletePacket::new(pkt.event.clone()) }}impl LePeriodicAdvertisingTerminateSyncBuilder {pub fn build(self) -> LePeriodicAdvertisingTerminateSyncPacket {let le_periodic_advertising_terminate_sync= Arc::new(LePeriodicAdvertisingTerminateSyncData {child: match self.payload { None => LePeriodicAdvertisingTerminateSyncDataChild::None,Some(bytes) => LePeriodicAdvertisingTerminateSyncDataChild::Payload(bytes),},});let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LePeriodicAdvertisingTerminateSync(le_periodic_advertising_terminate_sync),});let command= Arc::new(CommandData {op_code: OpCode::LePeriodicAdvertisingTerminateSync, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LePeriodicAdvertisingTerminateSyncPacket::new(command)}
}
impl Into<CommandPacket> for LePeriodicAdvertisingTerminateSyncBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LePeriodicAdvertisingTerminateSyncBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] struct LePeriodicAdvertisingTerminateSyncCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LePeriodicAdvertisingTerminateSyncCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_periodic_advertising_terminate_sync_complete: Arc<LePeriodicAdvertisingTerminateSyncCompleteData>,}
#[derive(Debug)] pub struct LePeriodicAdvertisingTerminateSyncCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LePeriodicAdvertisingTerminateSyncCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LePeriodicAdvertisingTerminateSyncComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LePeriodicAdvertisingTerminateSyncCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LePeriodicAdvertisingTerminateSyncCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_periodic_advertising_terminate_sync_complete = match &command_complete.child {CommandCompleteDataChild::LePeriodicAdvertisingTerminateSyncComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LePeriodicAdvertisingTerminateSyncComplete"),};Self {event,command_complete,le_periodic_advertising_terminate_sync_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_periodic_advertising_terminate_sync_complete.as_ref().status}
}
impl Into<EventPacket> for LePeriodicAdvertisingTerminateSyncCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LePeriodicAdvertisingTerminateSyncCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LePeriodicAdvertisingTerminateSyncCompleteBuilder {pub fn build(self) -> LePeriodicAdvertisingTerminateSyncCompletePacket {let le_periodic_advertising_terminate_sync_complete= Arc::new(LePeriodicAdvertisingTerminateSyncCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LePeriodicAdvertisingTerminateSync, child: CommandCompleteDataChild::LePeriodicAdvertisingTerminateSyncComplete(le_periodic_advertising_terminate_sync_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LePeriodicAdvertisingTerminateSyncCompletePacket::new(event)}
}
impl Into<EventPacket> for LePeriodicAdvertisingTerminateSyncCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LePeriodicAdvertisingTerminateSyncCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeAddDeviceToPeriodicAdvertisingListData {advertising_address_type: AdvertisingAddressType, advertiser_address: Address, advertising_sid: u8, }
#[derive(Debug, Clone)] pub struct LeAddDeviceToPeriodicAdvertisingListPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_add_device_to_periodic_advertising_list: Arc<LeAddDeviceToPeriodicAdvertisingListData>,}
#[derive(Debug)] pub struct LeAddDeviceToPeriodicAdvertisingListBuilder {pub advertising_address_type: AdvertisingAddressType, pub advertiser_address: Address, pub advertising_sid: u8, }
impl LeAddDeviceToPeriodicAdvertisingListData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeAddDeviceToPeriodicAdvertisingList".to_string(),    field: "advertising_address_type".to_string(),    wanted: 4,    got: bytes.len()});}let advertising_address_type = u8::from_le_bytes([bytes[3]]);let advertising_address_type = AdvertisingAddressType::from_u8(advertising_address_type).unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeAddDeviceToPeriodicAdvertisingList".to_string(),    field: "advertiser_address".to_string(),    wanted: 10,    got: bytes.len()});}let advertiser_address = bytes[4..10].try_into().unwrap();let advertising_sid = u8::from_le_bytes([bytes[10]]);let advertising_sid = advertising_sid & 0xf;Ok(Self {advertising_address_type, advertiser_address, advertising_sid, })
}
fn write_to(&self, buffer: &mut BytesMut) {let advertising_address_type = self.advertising_address_type.to_u8().unwrap();buffer[3..4].copy_from_slice(&advertising_address_type.to_le_bytes()[0..1]);let advertiser_address: [u8; 6] = self.advertiser_address.into();buffer[4..10].copy_from_slice(&advertiser_address);let advertising_sid = self.advertising_sid;let advertising_sid = advertising_sid & 0xf;buffer[10..11].copy_from_slice(&advertising_sid.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 8;ret}
}
impl CommandExpectations for LeAddDeviceToPeriodicAdvertisingListPacket { type ResponseType = LeAddDeviceToPeriodicAdvertisingListCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeAddDeviceToPeriodicAdvertisingListCompletePacket::new(pkt.event.clone()) }}impl Packet for LeAddDeviceToPeriodicAdvertisingListPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAddDeviceToPeriodicAdvertisingListPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_add_device_to_periodic_advertising_list = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeAddDeviceToPeriodicAdvertisingList(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAddDeviceToPeriodicAdvertisingList"),};Self {command,le_advertising_command,le_add_device_to_periodic_advertising_list,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_advertising_address_type(&self) -> AdvertisingAddressType{ self.le_add_device_to_periodic_advertising_list.as_ref().advertising_address_type}
pub fn get_advertiser_address(&self) -> Address{ self.le_add_device_to_periodic_advertising_list.as_ref().advertiser_address}
pub fn get_advertising_sid(&self) -> u8{ self.le_add_device_to_periodic_advertising_list.as_ref().advertising_sid}
}
impl Into<CommandPacket> for LeAddDeviceToPeriodicAdvertisingListPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeAddDeviceToPeriodicAdvertisingListPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeAddDeviceToPeriodicAdvertisingListBuilder { type ResponseType = LeAddDeviceToPeriodicAdvertisingListCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeAddDeviceToPeriodicAdvertisingListCompletePacket::new(pkt.event.clone()) }}impl LeAddDeviceToPeriodicAdvertisingListBuilder {pub fn build(self) -> LeAddDeviceToPeriodicAdvertisingListPacket {let le_add_device_to_periodic_advertising_list= Arc::new(LeAddDeviceToPeriodicAdvertisingListData {advertising_address_type: self.advertising_address_type, advertiser_address: self.advertiser_address, advertising_sid: self.advertising_sid, });let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeAddDeviceToPeriodicAdvertisingList(le_add_device_to_periodic_advertising_list),});let command= Arc::new(CommandData {op_code: OpCode::LeAddDeviceToPeriodicAdvertisingList, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeAddDeviceToPeriodicAdvertisingListPacket::new(command)}
}
impl Into<CommandPacket> for LeAddDeviceToPeriodicAdvertisingListBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeAddDeviceToPeriodicAdvertisingListBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeAddDeviceToPeriodicAdvertisingListCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeAddDeviceToPeriodicAdvertisingListCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_add_device_to_periodic_advertising_list_complete: Arc<LeAddDeviceToPeriodicAdvertisingListCompleteData>,}
#[derive(Debug)] pub struct LeAddDeviceToPeriodicAdvertisingListCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeAddDeviceToPeriodicAdvertisingListCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeAddDeviceToPeriodicAdvertisingListComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeAddDeviceToPeriodicAdvertisingListCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAddDeviceToPeriodicAdvertisingListCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_add_device_to_periodic_advertising_list_complete = match &command_complete.child {CommandCompleteDataChild::LeAddDeviceToPeriodicAdvertisingListComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAddDeviceToPeriodicAdvertisingListComplete"),};Self {event,command_complete,le_add_device_to_periodic_advertising_list_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_add_device_to_periodic_advertising_list_complete.as_ref().status}
}
impl Into<EventPacket> for LeAddDeviceToPeriodicAdvertisingListCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeAddDeviceToPeriodicAdvertisingListCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeAddDeviceToPeriodicAdvertisingListCompleteBuilder {pub fn build(self) -> LeAddDeviceToPeriodicAdvertisingListCompletePacket {let le_add_device_to_periodic_advertising_list_complete= Arc::new(LeAddDeviceToPeriodicAdvertisingListCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeAddDeviceToPeriodicAdvertisingList, child: CommandCompleteDataChild::LeAddDeviceToPeriodicAdvertisingListComplete(le_add_device_to_periodic_advertising_list_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeAddDeviceToPeriodicAdvertisingListCompletePacket::new(event)}
}
impl Into<EventPacket> for LeAddDeviceToPeriodicAdvertisingListCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeAddDeviceToPeriodicAdvertisingListCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] enum LeRemoveDeviceFromPeriodicAdvertisingListDataChild {Payload(Bytes),None,}
impl LeRemoveDeviceFromPeriodicAdvertisingListDataChild {fn get_total_size(&self) -> usize {match self {LeRemoveDeviceFromPeriodicAdvertisingListDataChild::Payload(p) => p.len(),LeRemoveDeviceFromPeriodicAdvertisingListDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LeRemoveDeviceFromPeriodicAdvertisingListChild {Payload(Bytes),None,}
#[derive(Debug)] struct LeRemoveDeviceFromPeriodicAdvertisingListData {child: LeRemoveDeviceFromPeriodicAdvertisingListDataChild,}
#[derive(Debug, Clone)] pub struct LeRemoveDeviceFromPeriodicAdvertisingListPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_remove_device_from_periodic_advertising_list: Arc<LeRemoveDeviceFromPeriodicAdvertisingListData>,}
#[derive(Debug)] pub struct LeRemoveDeviceFromPeriodicAdvertisingListBuilder {pub payload: Option<Bytes>,}
impl LeRemoveDeviceFromPeriodicAdvertisingListData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {let payload: Vec::<u8> = bytes[3..].into();let child = if payload.len() > 0 {LeRemoveDeviceFromPeriodicAdvertisingListDataChild::Payload(Bytes::from(payload))} else {LeRemoveDeviceFromPeriodicAdvertisingListDataChild::None};Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {LeRemoveDeviceFromPeriodicAdvertisingListDataChild::Payload(p) => buffer[3..].copy_from_slice(&p[..]),LeRemoveDeviceFromPeriodicAdvertisingListDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeRemoveDeviceFromPeriodicAdvertisingListPacket { type ResponseType = LeRemoveDeviceFromPeriodicAdvertisingListCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeRemoveDeviceFromPeriodicAdvertisingListCompletePacket::new(pkt.event.clone()) }}impl Packet for LeRemoveDeviceFromPeriodicAdvertisingListPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeRemoveDeviceFromPeriodicAdvertisingListPacket { pub fn specialize(&self) -> LeRemoveDeviceFromPeriodicAdvertisingListChild { match &self.le_remove_device_from_periodic_advertising_list.child {LeRemoveDeviceFromPeriodicAdvertisingListDataChild::Payload(p) => LeRemoveDeviceFromPeriodicAdvertisingListChild::Payload(p.clone()),LeRemoveDeviceFromPeriodicAdvertisingListDataChild::None => LeRemoveDeviceFromPeriodicAdvertisingListChild::None,}} fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_remove_device_from_periodic_advertising_list = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeRemoveDeviceFromPeriodicAdvertisingList(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeRemoveDeviceFromPeriodicAdvertisingList"),};Self {command,le_advertising_command,le_remove_device_from_periodic_advertising_list,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeRemoveDeviceFromPeriodicAdvertisingListPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeRemoveDeviceFromPeriodicAdvertisingListPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeRemoveDeviceFromPeriodicAdvertisingListBuilder { type ResponseType = LeRemoveDeviceFromPeriodicAdvertisingListCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeRemoveDeviceFromPeriodicAdvertisingListCompletePacket::new(pkt.event.clone()) }}impl LeRemoveDeviceFromPeriodicAdvertisingListBuilder {pub fn build(self) -> LeRemoveDeviceFromPeriodicAdvertisingListPacket {let le_remove_device_from_periodic_advertising_list= Arc::new(LeRemoveDeviceFromPeriodicAdvertisingListData {child: match self.payload { None => LeRemoveDeviceFromPeriodicAdvertisingListDataChild::None,Some(bytes) => LeRemoveDeviceFromPeriodicAdvertisingListDataChild::Payload(bytes),},});let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeRemoveDeviceFromPeriodicAdvertisingList(le_remove_device_from_periodic_advertising_list),});let command= Arc::new(CommandData {op_code: OpCode::LeRemoveDeviceFromPeriodicAdvertisingList, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeRemoveDeviceFromPeriodicAdvertisingListPacket::new(command)}
}
impl Into<CommandPacket> for LeRemoveDeviceFromPeriodicAdvertisingListBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeRemoveDeviceFromPeriodicAdvertisingListBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeRemoveDeviceFromPeriodicAdvertisingListCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeRemoveDeviceFromPeriodicAdvertisingListCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_remove_device_from_periodic_advertising_list_complete: Arc<LeRemoveDeviceFromPeriodicAdvertisingListCompleteData>,}
#[derive(Debug)] pub struct LeRemoveDeviceFromPeriodicAdvertisingListCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeRemoveDeviceFromPeriodicAdvertisingListCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeRemoveDeviceFromPeriodicAdvertisingListComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeRemoveDeviceFromPeriodicAdvertisingListCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeRemoveDeviceFromPeriodicAdvertisingListCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_remove_device_from_periodic_advertising_list_complete = match &command_complete.child {CommandCompleteDataChild::LeRemoveDeviceFromPeriodicAdvertisingListComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeRemoveDeviceFromPeriodicAdvertisingListComplete"),};Self {event,command_complete,le_remove_device_from_periodic_advertising_list_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_remove_device_from_periodic_advertising_list_complete.as_ref().status}
}
impl Into<EventPacket> for LeRemoveDeviceFromPeriodicAdvertisingListCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeRemoveDeviceFromPeriodicAdvertisingListCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeRemoveDeviceFromPeriodicAdvertisingListCompleteBuilder {pub fn build(self) -> LeRemoveDeviceFromPeriodicAdvertisingListCompletePacket {let le_remove_device_from_periodic_advertising_list_complete= Arc::new(LeRemoveDeviceFromPeriodicAdvertisingListCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeRemoveDeviceFromPeriodicAdvertisingList, child: CommandCompleteDataChild::LeRemoveDeviceFromPeriodicAdvertisingListComplete(le_remove_device_from_periodic_advertising_list_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeRemoveDeviceFromPeriodicAdvertisingListCompletePacket::new(event)}
}
impl Into<EventPacket> for LeRemoveDeviceFromPeriodicAdvertisingListCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeRemoveDeviceFromPeriodicAdvertisingListCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeClearPeriodicAdvertisingListData {}
#[derive(Debug, Clone)] pub struct LeClearPeriodicAdvertisingListPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_clear_periodic_advertising_list: Arc<LeClearPeriodicAdvertisingListData>,}
#[derive(Debug)] pub struct LeClearPeriodicAdvertisingListBuilder {}
impl LeClearPeriodicAdvertisingListData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeClearPeriodicAdvertisingListPacket { type ResponseType = LeClearPeriodicAdvertisingListCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeClearPeriodicAdvertisingListCompletePacket::new(pkt.event.clone()) }}impl Packet for LeClearPeriodicAdvertisingListPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeClearPeriodicAdvertisingListPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_clear_periodic_advertising_list = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeClearPeriodicAdvertisingList(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeClearPeriodicAdvertisingList"),};Self {command,le_advertising_command,le_clear_periodic_advertising_list,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeClearPeriodicAdvertisingListPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeClearPeriodicAdvertisingListPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeClearPeriodicAdvertisingListBuilder { type ResponseType = LeClearPeriodicAdvertisingListCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeClearPeriodicAdvertisingListCompletePacket::new(pkt.event.clone()) }}impl LeClearPeriodicAdvertisingListBuilder {pub fn build(self) -> LeClearPeriodicAdvertisingListPacket {let le_clear_periodic_advertising_list= Arc::new(LeClearPeriodicAdvertisingListData {});let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeClearPeriodicAdvertisingList(le_clear_periodic_advertising_list),});let command= Arc::new(CommandData {op_code: OpCode::LeClearPeriodicAdvertisingList, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeClearPeriodicAdvertisingListPacket::new(command)}
}
impl Into<CommandPacket> for LeClearPeriodicAdvertisingListBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeClearPeriodicAdvertisingListBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeClearPeriodicAdvertisingListCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeClearPeriodicAdvertisingListCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_clear_periodic_advertising_list_complete: Arc<LeClearPeriodicAdvertisingListCompleteData>,}
#[derive(Debug)] pub struct LeClearPeriodicAdvertisingListCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeClearPeriodicAdvertisingListCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeClearPeriodicAdvertisingListComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeClearPeriodicAdvertisingListCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeClearPeriodicAdvertisingListCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_clear_periodic_advertising_list_complete = match &command_complete.child {CommandCompleteDataChild::LeClearPeriodicAdvertisingListComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeClearPeriodicAdvertisingListComplete"),};Self {event,command_complete,le_clear_periodic_advertising_list_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_clear_periodic_advertising_list_complete.as_ref().status}
}
impl Into<EventPacket> for LeClearPeriodicAdvertisingListCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeClearPeriodicAdvertisingListCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeClearPeriodicAdvertisingListCompleteBuilder {pub fn build(self) -> LeClearPeriodicAdvertisingListCompletePacket {let le_clear_periodic_advertising_list_complete= Arc::new(LeClearPeriodicAdvertisingListCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeClearPeriodicAdvertisingList, child: CommandCompleteDataChild::LeClearPeriodicAdvertisingListComplete(le_clear_periodic_advertising_list_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeClearPeriodicAdvertisingListCompletePacket::new(event)}
}
impl Into<EventPacket> for LeClearPeriodicAdvertisingListCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeClearPeriodicAdvertisingListCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeReadPeriodicAdvertiserListSizeData {}
#[derive(Debug, Clone)] pub struct LeReadPeriodicAdvertiserListSizePacket {command: Arc<CommandData>,le_read_periodic_advertiser_list_size: Arc<LeReadPeriodicAdvertiserListSizeData>,}
#[derive(Debug)] pub struct LeReadPeriodicAdvertiserListSizeBuilder {}
impl LeReadPeriodicAdvertiserListSizeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeReadPeriodicAdvertiserListSizePacket { type ResponseType = LeReadPeriodicAdvertiserListSizeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadPeriodicAdvertiserListSizeCompletePacket::new(pkt.event.clone()) }}impl Packet for LeReadPeriodicAdvertiserListSizePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadPeriodicAdvertiserListSizePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_read_periodic_advertiser_list_size = match &command.child {CommandDataChild::LeReadPeriodicAdvertiserListSize(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadPeriodicAdvertiserListSize"),};Self {command,le_read_periodic_advertiser_list_size,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeReadPeriodicAdvertiserListSizePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeReadPeriodicAdvertiserListSizeBuilder { type ResponseType = LeReadPeriodicAdvertiserListSizeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadPeriodicAdvertiserListSizeCompletePacket::new(pkt.event.clone()) }}impl LeReadPeriodicAdvertiserListSizeBuilder {pub fn build(self) -> LeReadPeriodicAdvertiserListSizePacket {let le_read_periodic_advertiser_list_size= Arc::new(LeReadPeriodicAdvertiserListSizeData {});let command= Arc::new(CommandData {op_code: OpCode::LeReadPeriodicAdvertisingListSize, child: CommandDataChild::LeReadPeriodicAdvertiserListSize(le_read_periodic_advertiser_list_size),});LeReadPeriodicAdvertiserListSizePacket::new(command)}
}
impl Into<CommandPacket> for LeReadPeriodicAdvertiserListSizeBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LeReadPeriodicAdvertiserListSizeCompleteData {status: ErrorCode, periodic_advertiser_list_size: u8, }
#[derive(Debug, Clone)] pub struct LeReadPeriodicAdvertiserListSizeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_read_periodic_advertiser_list_size_complete: Arc<LeReadPeriodicAdvertiserListSizeCompleteData>,}
#[derive(Debug)] pub struct LeReadPeriodicAdvertiserListSizeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub periodic_advertiser_list_size: u8, }
impl LeReadPeriodicAdvertiserListSizeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeReadPeriodicAdvertiserListSizeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeReadPeriodicAdvertiserListSizeComplete".to_string(),    field: "periodic_advertiser_list_size".to_string(),    wanted: 7,    got: bytes.len()});}let periodic_advertiser_list_size = u8::from_le_bytes([bytes[6]]);Ok(Self {status, periodic_advertiser_list_size, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let periodic_advertiser_list_size = self.periodic_advertiser_list_size;buffer[6..7].copy_from_slice(&periodic_advertiser_list_size.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for LeReadPeriodicAdvertiserListSizeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadPeriodicAdvertiserListSizeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_read_periodic_advertiser_list_size_complete = match &command_complete.child {CommandCompleteDataChild::LeReadPeriodicAdvertiserListSizeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadPeriodicAdvertiserListSizeComplete"),};Self {event,command_complete,le_read_periodic_advertiser_list_size_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_read_periodic_advertiser_list_size_complete.as_ref().status}
pub fn get_periodic_advertiser_list_size(&self) -> u8{ self.le_read_periodic_advertiser_list_size_complete.as_ref().periodic_advertiser_list_size}
}
impl Into<EventPacket> for LeReadPeriodicAdvertiserListSizeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeReadPeriodicAdvertiserListSizeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeReadPeriodicAdvertiserListSizeCompleteBuilder {pub fn build(self) -> LeReadPeriodicAdvertiserListSizeCompletePacket {let le_read_periodic_advertiser_list_size_complete= Arc::new(LeReadPeriodicAdvertiserListSizeCompleteData {status: self.status, periodic_advertiser_list_size: self.periodic_advertiser_list_size, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeReadPeriodicAdvertisingListSize, child: CommandCompleteDataChild::LeReadPeriodicAdvertiserListSizeComplete(le_read_periodic_advertiser_list_size_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeReadPeriodicAdvertiserListSizeCompletePacket::new(event)}
}
impl Into<EventPacket> for LeReadPeriodicAdvertiserListSizeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeReadPeriodicAdvertiserListSizeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeReadTransmitPowerData {}
#[derive(Debug, Clone)] pub struct LeReadTransmitPowerPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_read_transmit_power: Arc<LeReadTransmitPowerData>,}
#[derive(Debug)] pub struct LeReadTransmitPowerBuilder {}
impl LeReadTransmitPowerData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeReadTransmitPowerPacket { type ResponseType = LeReadTransmitPowerCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadTransmitPowerCompletePacket::new(pkt.event.clone()) }}impl Packet for LeReadTransmitPowerPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadTransmitPowerPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_read_transmit_power = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeReadTransmitPower(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadTransmitPower"),};Self {command,le_advertising_command,le_read_transmit_power,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeReadTransmitPowerPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeReadTransmitPowerPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeReadTransmitPowerBuilder { type ResponseType = LeReadTransmitPowerCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadTransmitPowerCompletePacket::new(pkt.event.clone()) }}impl LeReadTransmitPowerBuilder {pub fn build(self) -> LeReadTransmitPowerPacket {let le_read_transmit_power= Arc::new(LeReadTransmitPowerData {});let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeReadTransmitPower(le_read_transmit_power),});let command= Arc::new(CommandData {op_code: OpCode::LeReadTransmitPower, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeReadTransmitPowerPacket::new(command)}
}
impl Into<CommandPacket> for LeReadTransmitPowerBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeReadTransmitPowerBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeReadTransmitPowerCompleteData {status: ErrorCode, min_tx_power_dbm: u8, max_tx_power_dbm: u8, }
#[derive(Debug, Clone)] pub struct LeReadTransmitPowerCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_read_transmit_power_complete: Arc<LeReadTransmitPowerCompleteData>,}
#[derive(Debug)] pub struct LeReadTransmitPowerCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub min_tx_power_dbm: u8, pub max_tx_power_dbm: u8, }
impl LeReadTransmitPowerCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeReadTransmitPowerComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeReadTransmitPowerComplete".to_string(),    field: "min_tx_power_dbm".to_string(),    wanted: 7,    got: bytes.len()});}let min_tx_power_dbm = u8::from_le_bytes([bytes[6]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeReadTransmitPowerComplete".to_string(),    field: "max_tx_power_dbm".to_string(),    wanted: 8,    got: bytes.len()});}let max_tx_power_dbm = u8::from_le_bytes([bytes[7]]);Ok(Self {status, min_tx_power_dbm, max_tx_power_dbm, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let min_tx_power_dbm = self.min_tx_power_dbm;buffer[6..7].copy_from_slice(&min_tx_power_dbm.to_le_bytes()[0..1]);let max_tx_power_dbm = self.max_tx_power_dbm;buffer[7..8].copy_from_slice(&max_tx_power_dbm.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for LeReadTransmitPowerCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadTransmitPowerCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_read_transmit_power_complete = match &command_complete.child {CommandCompleteDataChild::LeReadTransmitPowerComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadTransmitPowerComplete"),};Self {event,command_complete,le_read_transmit_power_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_read_transmit_power_complete.as_ref().status}
pub fn get_min_tx_power_dbm(&self) -> u8{ self.le_read_transmit_power_complete.as_ref().min_tx_power_dbm}
pub fn get_max_tx_power_dbm(&self) -> u8{ self.le_read_transmit_power_complete.as_ref().max_tx_power_dbm}
}
impl Into<EventPacket> for LeReadTransmitPowerCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeReadTransmitPowerCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeReadTransmitPowerCompleteBuilder {pub fn build(self) -> LeReadTransmitPowerCompletePacket {let le_read_transmit_power_complete= Arc::new(LeReadTransmitPowerCompleteData {status: self.status, min_tx_power_dbm: self.min_tx_power_dbm, max_tx_power_dbm: self.max_tx_power_dbm, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeReadTransmitPower, child: CommandCompleteDataChild::LeReadTransmitPowerComplete(le_read_transmit_power_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeReadTransmitPowerCompletePacket::new(event)}
}
impl Into<EventPacket> for LeReadTransmitPowerCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeReadTransmitPowerCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeReadRfPathCompensationPowerData {}
#[derive(Debug, Clone)] pub struct LeReadRfPathCompensationPowerPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_read_rf_path_compensation_power: Arc<LeReadRfPathCompensationPowerData>,}
#[derive(Debug)] pub struct LeReadRfPathCompensationPowerBuilder {}
impl LeReadRfPathCompensationPowerData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeReadRfPathCompensationPowerPacket { type ResponseType = LeReadRfPathCompensationPowerCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadRfPathCompensationPowerCompletePacket::new(pkt.event.clone()) }}impl Packet for LeReadRfPathCompensationPowerPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadRfPathCompensationPowerPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_read_rf_path_compensation_power = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeReadRfPathCompensationPower(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadRfPathCompensationPower"),};Self {command,le_advertising_command,le_read_rf_path_compensation_power,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeReadRfPathCompensationPowerPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeReadRfPathCompensationPowerPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeReadRfPathCompensationPowerBuilder { type ResponseType = LeReadRfPathCompensationPowerCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadRfPathCompensationPowerCompletePacket::new(pkt.event.clone()) }}impl LeReadRfPathCompensationPowerBuilder {pub fn build(self) -> LeReadRfPathCompensationPowerPacket {let le_read_rf_path_compensation_power= Arc::new(LeReadRfPathCompensationPowerData {});let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeReadRfPathCompensationPower(le_read_rf_path_compensation_power),});let command= Arc::new(CommandData {op_code: OpCode::LeReadRfPathCompensationPower, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeReadRfPathCompensationPowerPacket::new(command)}
}
impl Into<CommandPacket> for LeReadRfPathCompensationPowerBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeReadRfPathCompensationPowerBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeReadRfPathCompensationPowerCompleteData {status: ErrorCode, rf_tx_path_compensation_tenths_db: u16, rf_rx_path_compensation_tenths_db: u16, }
#[derive(Debug, Clone)] pub struct LeReadRfPathCompensationPowerCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_read_rf_path_compensation_power_complete: Arc<LeReadRfPathCompensationPowerCompleteData>,}
#[derive(Debug)] pub struct LeReadRfPathCompensationPowerCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub rf_tx_path_compensation_tenths_db: u16, pub rf_rx_path_compensation_tenths_db: u16, }
impl LeReadRfPathCompensationPowerCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeReadRfPathCompensationPowerComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeReadRfPathCompensationPowerComplete".to_string(),    field: "rf_tx_path_compensation_tenths_db".to_string(),    wanted: 8,    got: bytes.len()});}let rf_tx_path_compensation_tenths_db = u16::from_le_bytes([bytes[6],bytes[7]]);if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeReadRfPathCompensationPowerComplete".to_string(),    field: "rf_rx_path_compensation_tenths_db".to_string(),    wanted: 10,    got: bytes.len()});}let rf_rx_path_compensation_tenths_db = u16::from_le_bytes([bytes[8],bytes[9]]);Ok(Self {status, rf_tx_path_compensation_tenths_db, rf_rx_path_compensation_tenths_db, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let rf_tx_path_compensation_tenths_db = self.rf_tx_path_compensation_tenths_db;buffer[6..8].copy_from_slice(&rf_tx_path_compensation_tenths_db.to_le_bytes()[0..2]);let rf_rx_path_compensation_tenths_db = self.rf_rx_path_compensation_tenths_db;buffer[8..10].copy_from_slice(&rf_rx_path_compensation_tenths_db.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 5;ret}
}
impl Packet for LeReadRfPathCompensationPowerCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadRfPathCompensationPowerCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_read_rf_path_compensation_power_complete = match &command_complete.child {CommandCompleteDataChild::LeReadRfPathCompensationPowerComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadRfPathCompensationPowerComplete"),};Self {event,command_complete,le_read_rf_path_compensation_power_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_read_rf_path_compensation_power_complete.as_ref().status}
pub fn get_rf_tx_path_compensation_tenths_db(&self) -> u16{ self.le_read_rf_path_compensation_power_complete.as_ref().rf_tx_path_compensation_tenths_db}
pub fn get_rf_rx_path_compensation_tenths_db(&self) -> u16{ self.le_read_rf_path_compensation_power_complete.as_ref().rf_rx_path_compensation_tenths_db}
}
impl Into<EventPacket> for LeReadRfPathCompensationPowerCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeReadRfPathCompensationPowerCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeReadRfPathCompensationPowerCompleteBuilder {pub fn build(self) -> LeReadRfPathCompensationPowerCompletePacket {let le_read_rf_path_compensation_power_complete= Arc::new(LeReadRfPathCompensationPowerCompleteData {status: self.status, rf_tx_path_compensation_tenths_db: self.rf_tx_path_compensation_tenths_db, rf_rx_path_compensation_tenths_db: self.rf_rx_path_compensation_tenths_db, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeReadRfPathCompensationPower, child: CommandCompleteDataChild::LeReadRfPathCompensationPowerComplete(le_read_rf_path_compensation_power_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeReadRfPathCompensationPowerCompletePacket::new(event)}
}
impl Into<EventPacket> for LeReadRfPathCompensationPowerCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeReadRfPathCompensationPowerCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeWriteRfPathCompensationPowerData {rf_tx_path_compensation_tenths_db: u16, rf_rx_path_compensation_tenths_db: u16, }
#[derive(Debug, Clone)] pub struct LeWriteRfPathCompensationPowerPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_write_rf_path_compensation_power: Arc<LeWriteRfPathCompensationPowerData>,}
#[derive(Debug)] pub struct LeWriteRfPathCompensationPowerBuilder {pub rf_tx_path_compensation_tenths_db: u16, pub rf_rx_path_compensation_tenths_db: u16, }
impl LeWriteRfPathCompensationPowerData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeWriteRfPathCompensationPower".to_string(),    field: "rf_tx_path_compensation_tenths_db".to_string(),    wanted: 5,    got: bytes.len()});}let rf_tx_path_compensation_tenths_db = u16::from_le_bytes([bytes[3],bytes[4]]);if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeWriteRfPathCompensationPower".to_string(),    field: "rf_rx_path_compensation_tenths_db".to_string(),    wanted: 7,    got: bytes.len()});}let rf_rx_path_compensation_tenths_db = u16::from_le_bytes([bytes[5],bytes[6]]);Ok(Self {rf_tx_path_compensation_tenths_db, rf_rx_path_compensation_tenths_db, })
}
fn write_to(&self, buffer: &mut BytesMut) {let rf_tx_path_compensation_tenths_db = self.rf_tx_path_compensation_tenths_db;buffer[3..5].copy_from_slice(&rf_tx_path_compensation_tenths_db.to_le_bytes()[0..2]);let rf_rx_path_compensation_tenths_db = self.rf_rx_path_compensation_tenths_db;buffer[5..7].copy_from_slice(&rf_rx_path_compensation_tenths_db.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl CommandExpectations for LeWriteRfPathCompensationPowerPacket { type ResponseType = LeWriteRfPathCompensationPowerCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeWriteRfPathCompensationPowerCompletePacket::new(pkt.event.clone()) }}impl Packet for LeWriteRfPathCompensationPowerPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeWriteRfPathCompensationPowerPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_write_rf_path_compensation_power = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeWriteRfPathCompensationPower(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeWriteRfPathCompensationPower"),};Self {command,le_advertising_command,le_write_rf_path_compensation_power,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_rf_tx_path_compensation_tenths_db(&self) -> u16{ self.le_write_rf_path_compensation_power.as_ref().rf_tx_path_compensation_tenths_db}
pub fn get_rf_rx_path_compensation_tenths_db(&self) -> u16{ self.le_write_rf_path_compensation_power.as_ref().rf_rx_path_compensation_tenths_db}
}
impl Into<CommandPacket> for LeWriteRfPathCompensationPowerPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeWriteRfPathCompensationPowerPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeWriteRfPathCompensationPowerBuilder { type ResponseType = LeWriteRfPathCompensationPowerCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeWriteRfPathCompensationPowerCompletePacket::new(pkt.event.clone()) }}impl LeWriteRfPathCompensationPowerBuilder {pub fn build(self) -> LeWriteRfPathCompensationPowerPacket {let le_write_rf_path_compensation_power= Arc::new(LeWriteRfPathCompensationPowerData {rf_tx_path_compensation_tenths_db: self.rf_tx_path_compensation_tenths_db, rf_rx_path_compensation_tenths_db: self.rf_rx_path_compensation_tenths_db, });let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeWriteRfPathCompensationPower(le_write_rf_path_compensation_power),});let command= Arc::new(CommandData {op_code: OpCode::LeWriteRfPathCompensationPower, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeWriteRfPathCompensationPowerPacket::new(command)}
}
impl Into<CommandPacket> for LeWriteRfPathCompensationPowerBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeWriteRfPathCompensationPowerBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeWriteRfPathCompensationPowerCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeWriteRfPathCompensationPowerCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_write_rf_path_compensation_power_complete: Arc<LeWriteRfPathCompensationPowerCompleteData>,}
#[derive(Debug)] pub struct LeWriteRfPathCompensationPowerCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeWriteRfPathCompensationPowerCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeWriteRfPathCompensationPowerComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeWriteRfPathCompensationPowerCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeWriteRfPathCompensationPowerCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_write_rf_path_compensation_power_complete = match &command_complete.child {CommandCompleteDataChild::LeWriteRfPathCompensationPowerComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeWriteRfPathCompensationPowerComplete"),};Self {event,command_complete,le_write_rf_path_compensation_power_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_write_rf_path_compensation_power_complete.as_ref().status}
}
impl Into<EventPacket> for LeWriteRfPathCompensationPowerCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeWriteRfPathCompensationPowerCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeWriteRfPathCompensationPowerCompleteBuilder {pub fn build(self) -> LeWriteRfPathCompensationPowerCompletePacket {let le_write_rf_path_compensation_power_complete= Arc::new(LeWriteRfPathCompensationPowerCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeWriteRfPathCompensationPower, child: CommandCompleteDataChild::LeWriteRfPathCompensationPowerComplete(le_write_rf_path_compensation_power_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeWriteRfPathCompensationPowerCompletePacket::new(event)}
}
impl Into<EventPacket> for LeWriteRfPathCompensationPowerCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeWriteRfPathCompensationPowerCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetPrivacyModeData {peer_identity_address_type: PeerAddressType, peer_identity_address: Address, privacy_mode: PrivacyMode, }
#[derive(Debug, Clone)] pub struct LeSetPrivacyModePacket {command: Arc<CommandData>,le_security_command: Arc<LeSecurityCommandData>,le_set_privacy_mode: Arc<LeSetPrivacyModeData>,}
#[derive(Debug)] pub struct LeSetPrivacyModeBuilder {pub peer_identity_address_type: PeerAddressType, pub peer_identity_address: Address, pub privacy_mode: PrivacyMode, }
impl LeSetPrivacyModeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetPrivacyMode".to_string(),    field: "peer_identity_address_type".to_string(),    wanted: 4,    got: bytes.len()});}let peer_identity_address_type = u8::from_le_bytes([bytes[3]]);let peer_identity_address_type = PeerAddressType::from_u8(peer_identity_address_type).unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeSetPrivacyMode".to_string(),    field: "peer_identity_address".to_string(),    wanted: 10,    got: bytes.len()});}let peer_identity_address = bytes[4..10].try_into().unwrap();if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "LeSetPrivacyMode".to_string(),    field: "privacy_mode".to_string(),    wanted: 11,    got: bytes.len()});}let privacy_mode = u8::from_le_bytes([bytes[10]]);let privacy_mode = PrivacyMode::from_u8(privacy_mode).unwrap();Ok(Self {peer_identity_address_type, peer_identity_address, privacy_mode, })
}
fn write_to(&self, buffer: &mut BytesMut) {let peer_identity_address_type = self.peer_identity_address_type.to_u8().unwrap();buffer[3..4].copy_from_slice(&peer_identity_address_type.to_le_bytes()[0..1]);let peer_identity_address: [u8; 6] = self.peer_identity_address.into();buffer[4..10].copy_from_slice(&peer_identity_address);let privacy_mode = self.privacy_mode.to_u8().unwrap();buffer[10..11].copy_from_slice(&privacy_mode.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 8;ret}
}
impl CommandExpectations for LeSetPrivacyModePacket { type ResponseType = LeSetPrivacyModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetPrivacyModeCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetPrivacyModePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetPrivacyModePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_security_command = match &command.child {CommandDataChild::LeSecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSecurityCommand"),};let le_set_privacy_mode = match &le_security_command.child {LeSecurityCommandDataChild::LeSetPrivacyMode(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetPrivacyMode"),};Self {command,le_security_command,le_set_privacy_mode,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_peer_identity_address_type(&self) -> PeerAddressType{ self.le_set_privacy_mode.as_ref().peer_identity_address_type}
pub fn get_peer_identity_address(&self) -> Address{ self.le_set_privacy_mode.as_ref().peer_identity_address}
pub fn get_privacy_mode(&self) -> PrivacyMode{ self.le_set_privacy_mode.as_ref().privacy_mode}
}
impl Into<CommandPacket> for LeSetPrivacyModePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeSecurityCommandPacket> for LeSetPrivacyModePacket { fn into(self) -> LeSecurityCommandPacket {LeSecurityCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetPrivacyModeBuilder { type ResponseType = LeSetPrivacyModeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetPrivacyModeCompletePacket::new(pkt.event.clone()) }}impl LeSetPrivacyModeBuilder {pub fn build(self) -> LeSetPrivacyModePacket {let le_set_privacy_mode= Arc::new(LeSetPrivacyModeData {peer_identity_address_type: self.peer_identity_address_type, peer_identity_address: self.peer_identity_address, privacy_mode: self.privacy_mode, });let le_security_command= Arc::new(LeSecurityCommandData {child: LeSecurityCommandDataChild::LeSetPrivacyMode(le_set_privacy_mode),});let command= Arc::new(CommandData {op_code: OpCode::LeSetPrivacyMode, child: CommandDataChild::LeSecurityCommand(le_security_command),});LeSetPrivacyModePacket::new(command)}
}
impl Into<CommandPacket> for LeSetPrivacyModeBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeSecurityCommandPacket> for LeSetPrivacyModeBuilder { fn into(self) -> LeSecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetPrivacyModeCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeSetPrivacyModeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_privacy_mode_complete: Arc<LeSetPrivacyModeCompleteData>,}
#[derive(Debug)] pub struct LeSetPrivacyModeCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeSetPrivacyModeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetPrivacyModeComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeSetPrivacyModeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetPrivacyModeCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_privacy_mode_complete = match &command_complete.child {CommandCompleteDataChild::LeSetPrivacyModeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetPrivacyModeComplete"),};Self {event,command_complete,le_set_privacy_mode_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_privacy_mode_complete.as_ref().status}
}
impl Into<EventPacket> for LeSetPrivacyModeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetPrivacyModeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetPrivacyModeCompleteBuilder {pub fn build(self) -> LeSetPrivacyModeCompletePacket {let le_set_privacy_mode_complete= Arc::new(LeSetPrivacyModeCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetPrivacyMode, child: CommandCompleteDataChild::LeSetPrivacyModeComplete(le_set_privacy_mode_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetPrivacyModeCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetPrivacyModeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetPrivacyModeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetPeriodicAdvertisingReceiveEnableData {sync_handle: u16, enable: u8, }
#[derive(Debug, Clone)] pub struct LeSetPeriodicAdvertisingReceiveEnablePacket {command: Arc<CommandData>,le_set_periodic_advertising_receive_enable: Arc<LeSetPeriodicAdvertisingReceiveEnableData>,}
#[derive(Debug)] pub struct LeSetPeriodicAdvertisingReceiveEnableBuilder {pub sync_handle: u16, pub enable: u8, }
impl LeSetPeriodicAdvertisingReceiveEnableData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeSetPeriodicAdvertisingReceiveEnable".to_string(),    field: "sync_handle".to_string(),    wanted: 5,    got: bytes.len()});}let sync_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let sync_handle = sync_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetPeriodicAdvertisingReceiveEnable".to_string(),    field: "enable".to_string(),    wanted: 6,    got: bytes.len()});}let enable = u8::from_le_bytes([bytes[5]]);Ok(Self {sync_handle, enable, })
}
fn write_to(&self, buffer: &mut BytesMut) {let sync_handle = self.sync_handle;let sync_handle = sync_handle & 0xfff;buffer[3..5].copy_from_slice(&sync_handle.to_le_bytes()[0..2]);let enable = self.enable;buffer[5..6].copy_from_slice(&enable.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl CommandExpectations for LeSetPeriodicAdvertisingReceiveEnablePacket { type ResponseType = LeSetPeriodicAdvertisingReceiveEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetPeriodicAdvertisingReceiveEnableCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetPeriodicAdvertisingReceiveEnablePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetPeriodicAdvertisingReceiveEnablePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_set_periodic_advertising_receive_enable = match &command.child {CommandDataChild::LeSetPeriodicAdvertisingReceiveEnable(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetPeriodicAdvertisingReceiveEnable"),};Self {command,le_set_periodic_advertising_receive_enable,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_sync_handle(&self) -> u16{ self.le_set_periodic_advertising_receive_enable.as_ref().sync_handle}
pub fn get_enable(&self) -> u8{ self.le_set_periodic_advertising_receive_enable.as_ref().enable}
}
impl Into<CommandPacket> for LeSetPeriodicAdvertisingReceiveEnablePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeSetPeriodicAdvertisingReceiveEnableBuilder { type ResponseType = LeSetPeriodicAdvertisingReceiveEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetPeriodicAdvertisingReceiveEnableCompletePacket::new(pkt.event.clone()) }}impl LeSetPeriodicAdvertisingReceiveEnableBuilder {pub fn build(self) -> LeSetPeriodicAdvertisingReceiveEnablePacket {let le_set_periodic_advertising_receive_enable= Arc::new(LeSetPeriodicAdvertisingReceiveEnableData {sync_handle: self.sync_handle, enable: self.enable, });let command= Arc::new(CommandData {op_code: OpCode::LeSetPeriodicAdvertisingReceiveEnable, child: CommandDataChild::LeSetPeriodicAdvertisingReceiveEnable(le_set_periodic_advertising_receive_enable),});LeSetPeriodicAdvertisingReceiveEnablePacket::new(command)}
}
impl Into<CommandPacket> for LeSetPeriodicAdvertisingReceiveEnableBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetPeriodicAdvertisingReceiveEnableCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeSetPeriodicAdvertisingReceiveEnableCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_periodic_advertising_receive_enable_complete: Arc<LeSetPeriodicAdvertisingReceiveEnableCompleteData>,}
#[derive(Debug)] pub struct LeSetPeriodicAdvertisingReceiveEnableCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeSetPeriodicAdvertisingReceiveEnableCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetPeriodicAdvertisingReceiveEnableComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeSetPeriodicAdvertisingReceiveEnableCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetPeriodicAdvertisingReceiveEnableCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_periodic_advertising_receive_enable_complete = match &command_complete.child {CommandCompleteDataChild::LeSetPeriodicAdvertisingReceiveEnableComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetPeriodicAdvertisingReceiveEnableComplete"),};Self {event,command_complete,le_set_periodic_advertising_receive_enable_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_periodic_advertising_receive_enable_complete.as_ref().status}
}
impl Into<EventPacket> for LeSetPeriodicAdvertisingReceiveEnableCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetPeriodicAdvertisingReceiveEnableCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetPeriodicAdvertisingReceiveEnableCompleteBuilder {pub fn build(self) -> LeSetPeriodicAdvertisingReceiveEnableCompletePacket {let le_set_periodic_advertising_receive_enable_complete= Arc::new(LeSetPeriodicAdvertisingReceiveEnableCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetPeriodicAdvertisingReceiveEnable, child: CommandCompleteDataChild::LeSetPeriodicAdvertisingReceiveEnableComplete(le_set_periodic_advertising_receive_enable_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetPeriodicAdvertisingReceiveEnableCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetPeriodicAdvertisingReceiveEnableCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetPeriodicAdvertisingReceiveEnableCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LePeriodicAdvertisingSyncTransferData {connection_handle: u16, service_data: u16, sync_handle: u16, }
#[derive(Debug, Clone)] pub struct LePeriodicAdvertisingSyncTransferPacket {command: Arc<CommandData>,le_periodic_advertising_sync_transfer: Arc<LePeriodicAdvertisingSyncTransferData>,}
#[derive(Debug)] pub struct LePeriodicAdvertisingSyncTransferBuilder {pub connection_handle: u16, pub service_data: u16, pub sync_handle: u16, }
impl LePeriodicAdvertisingSyncTransferData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LePeriodicAdvertisingSyncTransfer".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LePeriodicAdvertisingSyncTransfer".to_string(),    field: "service_data".to_string(),    wanted: 7,    got: bytes.len()});}let service_data = u16::from_le_bytes([bytes[5],bytes[6]]);if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LePeriodicAdvertisingSyncTransfer".to_string(),    field: "sync_handle".to_string(),    wanted: 9,    got: bytes.len()});}let sync_handle = u16::from_le_bytes([bytes[7],bytes[8]]);let sync_handle = sync_handle & 0xfff;Ok(Self {connection_handle, service_data, sync_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let service_data = self.service_data;buffer[5..7].copy_from_slice(&service_data.to_le_bytes()[0..2]);let sync_handle = self.sync_handle;let sync_handle = sync_handle & 0xfff;buffer[7..9].copy_from_slice(&sync_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl CommandExpectations for LePeriodicAdvertisingSyncTransferPacket { type ResponseType = LePeriodicAdvertisingSyncTransferCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LePeriodicAdvertisingSyncTransferCompletePacket::new(pkt.event.clone()) }}impl Packet for LePeriodicAdvertisingSyncTransferPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LePeriodicAdvertisingSyncTransferPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_periodic_advertising_sync_transfer = match &command.child {CommandDataChild::LePeriodicAdvertisingSyncTransfer(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LePeriodicAdvertisingSyncTransfer"),};Self {command,le_periodic_advertising_sync_transfer,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_periodic_advertising_sync_transfer.as_ref().connection_handle}
pub fn get_service_data(&self) -> u16{ self.le_periodic_advertising_sync_transfer.as_ref().service_data}
pub fn get_sync_handle(&self) -> u16{ self.le_periodic_advertising_sync_transfer.as_ref().sync_handle}
}
impl Into<CommandPacket> for LePeriodicAdvertisingSyncTransferPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LePeriodicAdvertisingSyncTransferBuilder { type ResponseType = LePeriodicAdvertisingSyncTransferCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LePeriodicAdvertisingSyncTransferCompletePacket::new(pkt.event.clone()) }}impl LePeriodicAdvertisingSyncTransferBuilder {pub fn build(self) -> LePeriodicAdvertisingSyncTransferPacket {let le_periodic_advertising_sync_transfer= Arc::new(LePeriodicAdvertisingSyncTransferData {connection_handle: self.connection_handle, service_data: self.service_data, sync_handle: self.sync_handle, });let command= Arc::new(CommandData {op_code: OpCode::LePeriodicAdvertisingSyncTransfer, child: CommandDataChild::LePeriodicAdvertisingSyncTransfer(le_periodic_advertising_sync_transfer),});LePeriodicAdvertisingSyncTransferPacket::new(command)}
}
impl Into<CommandPacket> for LePeriodicAdvertisingSyncTransferBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LePeriodicAdvertisingSyncTransferCompleteData {status: ErrorCode, connection_handle: u16, }
#[derive(Debug, Clone)] pub struct LePeriodicAdvertisingSyncTransferCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_periodic_advertising_sync_transfer_complete: Arc<LePeriodicAdvertisingSyncTransferCompleteData>,}
#[derive(Debug)] pub struct LePeriodicAdvertisingSyncTransferCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, }
impl LePeriodicAdvertisingSyncTransferCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LePeriodicAdvertisingSyncTransferComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LePeriodicAdvertisingSyncTransferComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;Ok(Self {status, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for LePeriodicAdvertisingSyncTransferCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LePeriodicAdvertisingSyncTransferCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_periodic_advertising_sync_transfer_complete = match &command_complete.child {CommandCompleteDataChild::LePeriodicAdvertisingSyncTransferComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LePeriodicAdvertisingSyncTransferComplete"),};Self {event,command_complete,le_periodic_advertising_sync_transfer_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_periodic_advertising_sync_transfer_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_periodic_advertising_sync_transfer_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for LePeriodicAdvertisingSyncTransferCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LePeriodicAdvertisingSyncTransferCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LePeriodicAdvertisingSyncTransferCompleteBuilder {pub fn build(self) -> LePeriodicAdvertisingSyncTransferCompletePacket {let le_periodic_advertising_sync_transfer_complete= Arc::new(LePeriodicAdvertisingSyncTransferCompleteData {status: self.status, connection_handle: self.connection_handle, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LePeriodicAdvertisingSyncTransfer, child: CommandCompleteDataChild::LePeriodicAdvertisingSyncTransferComplete(le_periodic_advertising_sync_transfer_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LePeriodicAdvertisingSyncTransferCompletePacket::new(event)}
}
impl Into<EventPacket> for LePeriodicAdvertisingSyncTransferCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LePeriodicAdvertisingSyncTransferCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LePeriodicAdvertisingSetInfoTransferData {connection_handle: u16, service_data: u16, advertising_handle: u8, }
#[derive(Debug, Clone)] pub struct LePeriodicAdvertisingSetInfoTransferPacket {command: Arc<CommandData>,le_periodic_advertising_set_info_transfer: Arc<LePeriodicAdvertisingSetInfoTransferData>,}
#[derive(Debug)] pub struct LePeriodicAdvertisingSetInfoTransferBuilder {pub connection_handle: u16, pub service_data: u16, pub advertising_handle: u8, }
impl LePeriodicAdvertisingSetInfoTransferData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LePeriodicAdvertisingSetInfoTransfer".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LePeriodicAdvertisingSetInfoTransfer".to_string(),    field: "service_data".to_string(),    wanted: 7,    got: bytes.len()});}let service_data = u16::from_le_bytes([bytes[5],bytes[6]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LePeriodicAdvertisingSetInfoTransfer".to_string(),    field: "advertising_handle".to_string(),    wanted: 8,    got: bytes.len()});}let advertising_handle = u8::from_le_bytes([bytes[7]]);Ok(Self {connection_handle, service_data, advertising_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let service_data = self.service_data;buffer[5..7].copy_from_slice(&service_data.to_le_bytes()[0..2]);let advertising_handle = self.advertising_handle;buffer[7..8].copy_from_slice(&advertising_handle.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 5;ret}
}
impl CommandExpectations for LePeriodicAdvertisingSetInfoTransferPacket { type ResponseType = LePeriodicAdvertisingSetInfoTransferCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LePeriodicAdvertisingSetInfoTransferCompletePacket::new(pkt.event.clone()) }}impl Packet for LePeriodicAdvertisingSetInfoTransferPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LePeriodicAdvertisingSetInfoTransferPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_periodic_advertising_set_info_transfer = match &command.child {CommandDataChild::LePeriodicAdvertisingSetInfoTransfer(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LePeriodicAdvertisingSetInfoTransfer"),};Self {command,le_periodic_advertising_set_info_transfer,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_periodic_advertising_set_info_transfer.as_ref().connection_handle}
pub fn get_service_data(&self) -> u16{ self.le_periodic_advertising_set_info_transfer.as_ref().service_data}
pub fn get_advertising_handle(&self) -> u8{ self.le_periodic_advertising_set_info_transfer.as_ref().advertising_handle}
}
impl Into<CommandPacket> for LePeriodicAdvertisingSetInfoTransferPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LePeriodicAdvertisingSetInfoTransferBuilder { type ResponseType = LePeriodicAdvertisingSetInfoTransferCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LePeriodicAdvertisingSetInfoTransferCompletePacket::new(pkt.event.clone()) }}impl LePeriodicAdvertisingSetInfoTransferBuilder {pub fn build(self) -> LePeriodicAdvertisingSetInfoTransferPacket {let le_periodic_advertising_set_info_transfer= Arc::new(LePeriodicAdvertisingSetInfoTransferData {connection_handle: self.connection_handle, service_data: self.service_data, advertising_handle: self.advertising_handle, });let command= Arc::new(CommandData {op_code: OpCode::LePeriodicAdvertisingSetInfoTransfer, child: CommandDataChild::LePeriodicAdvertisingSetInfoTransfer(le_periodic_advertising_set_info_transfer),});LePeriodicAdvertisingSetInfoTransferPacket::new(command)}
}
impl Into<CommandPacket> for LePeriodicAdvertisingSetInfoTransferBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LePeriodicAdvertisingSetInfoTransferCompleteData {status: ErrorCode, connection_handle: u16, }
#[derive(Debug, Clone)] pub struct LePeriodicAdvertisingSetInfoTransferCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_periodic_advertising_set_info_transfer_complete: Arc<LePeriodicAdvertisingSetInfoTransferCompleteData>,}
#[derive(Debug)] pub struct LePeriodicAdvertisingSetInfoTransferCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, }
impl LePeriodicAdvertisingSetInfoTransferCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LePeriodicAdvertisingSetInfoTransferComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LePeriodicAdvertisingSetInfoTransferComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;Ok(Self {status, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for LePeriodicAdvertisingSetInfoTransferCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LePeriodicAdvertisingSetInfoTransferCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_periodic_advertising_set_info_transfer_complete = match &command_complete.child {CommandCompleteDataChild::LePeriodicAdvertisingSetInfoTransferComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LePeriodicAdvertisingSetInfoTransferComplete"),};Self {event,command_complete,le_periodic_advertising_set_info_transfer_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_periodic_advertising_set_info_transfer_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_periodic_advertising_set_info_transfer_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for LePeriodicAdvertisingSetInfoTransferCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LePeriodicAdvertisingSetInfoTransferCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LePeriodicAdvertisingSetInfoTransferCompleteBuilder {pub fn build(self) -> LePeriodicAdvertisingSetInfoTransferCompletePacket {let le_periodic_advertising_set_info_transfer_complete= Arc::new(LePeriodicAdvertisingSetInfoTransferCompleteData {status: self.status, connection_handle: self.connection_handle, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LePeriodicAdvertisingSetInfoTransfer, child: CommandCompleteDataChild::LePeriodicAdvertisingSetInfoTransferComplete(le_periodic_advertising_set_info_transfer_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LePeriodicAdvertisingSetInfoTransferCompletePacket::new(event)}
}
impl Into<EventPacket> for LePeriodicAdvertisingSetInfoTransferCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LePeriodicAdvertisingSetInfoTransferCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetPeriodicAdvertisingSyncTransferParametersData {connection_handle: u16, mode: SyncTransferMode, skip: u16, sync_timeout: u16, cte_type: u8, }
#[derive(Debug, Clone)] pub struct LeSetPeriodicAdvertisingSyncTransferParametersPacket {command: Arc<CommandData>,le_set_periodic_advertising_sync_transfer_parameters: Arc<LeSetPeriodicAdvertisingSyncTransferParametersData>,}
#[derive(Debug)] pub struct LeSetPeriodicAdvertisingSyncTransferParametersBuilder {pub connection_handle: u16, pub mode: SyncTransferMode, pub skip: u16, pub sync_timeout: u16, pub cte_type: u8, }
impl LeSetPeriodicAdvertisingSyncTransferParametersData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeSetPeriodicAdvertisingSyncTransferParameters".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetPeriodicAdvertisingSyncTransferParameters".to_string(),    field: "mode".to_string(),    wanted: 6,    got: bytes.len()});}let mode = u8::from_le_bytes([bytes[5]]);let mode = SyncTransferMode::from_u8(mode).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeSetPeriodicAdvertisingSyncTransferParameters".to_string(),    field: "skip".to_string(),    wanted: 8,    got: bytes.len()});}let skip = u16::from_le_bytes([bytes[6],bytes[7]]);if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeSetPeriodicAdvertisingSyncTransferParameters".to_string(),    field: "sync_timeout".to_string(),    wanted: 10,    got: bytes.len()});}let sync_timeout = u16::from_le_bytes([bytes[8],bytes[9]]);if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "LeSetPeriodicAdvertisingSyncTransferParameters".to_string(),    field: "cte_type".to_string(),    wanted: 11,    got: bytes.len()});}let cte_type = u8::from_le_bytes([bytes[10]]);Ok(Self {connection_handle, mode, skip, sync_timeout, cte_type, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let mode = self.mode.to_u8().unwrap();buffer[5..6].copy_from_slice(&mode.to_le_bytes()[0..1]);let skip = self.skip;buffer[6..8].copy_from_slice(&skip.to_le_bytes()[0..2]);let sync_timeout = self.sync_timeout;buffer[8..10].copy_from_slice(&sync_timeout.to_le_bytes()[0..2]);let cte_type = self.cte_type;buffer[10..11].copy_from_slice(&cte_type.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 8;ret}
}
impl CommandExpectations for LeSetPeriodicAdvertisingSyncTransferParametersPacket { type ResponseType = LeSetPeriodicAdvertisingSyncTransferParametersCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetPeriodicAdvertisingSyncTransferParametersCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetPeriodicAdvertisingSyncTransferParametersPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetPeriodicAdvertisingSyncTransferParametersPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_set_periodic_advertising_sync_transfer_parameters = match &command.child {CommandDataChild::LeSetPeriodicAdvertisingSyncTransferParameters(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetPeriodicAdvertisingSyncTransferParameters"),};Self {command,le_set_periodic_advertising_sync_transfer_parameters,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_set_periodic_advertising_sync_transfer_parameters.as_ref().connection_handle}
pub fn get_mode(&self) -> SyncTransferMode{ self.le_set_periodic_advertising_sync_transfer_parameters.as_ref().mode}
pub fn get_skip(&self) -> u16{ self.le_set_periodic_advertising_sync_transfer_parameters.as_ref().skip}
pub fn get_sync_timeout(&self) -> u16{ self.le_set_periodic_advertising_sync_transfer_parameters.as_ref().sync_timeout}
pub fn get_cte_type(&self) -> u8{ self.le_set_periodic_advertising_sync_transfer_parameters.as_ref().cte_type}
}
impl Into<CommandPacket> for LeSetPeriodicAdvertisingSyncTransferParametersPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeSetPeriodicAdvertisingSyncTransferParametersBuilder { type ResponseType = LeSetPeriodicAdvertisingSyncTransferParametersCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetPeriodicAdvertisingSyncTransferParametersCompletePacket::new(pkt.event.clone()) }}impl LeSetPeriodicAdvertisingSyncTransferParametersBuilder {pub fn build(self) -> LeSetPeriodicAdvertisingSyncTransferParametersPacket {let le_set_periodic_advertising_sync_transfer_parameters= Arc::new(LeSetPeriodicAdvertisingSyncTransferParametersData {connection_handle: self.connection_handle, mode: self.mode, skip: self.skip, sync_timeout: self.sync_timeout, cte_type: self.cte_type, });let command= Arc::new(CommandData {op_code: OpCode::LeSetPeriodicAdvertisingSyncTransferParameters, child: CommandDataChild::LeSetPeriodicAdvertisingSyncTransferParameters(le_set_periodic_advertising_sync_transfer_parameters),});LeSetPeriodicAdvertisingSyncTransferParametersPacket::new(command)}
}
impl Into<CommandPacket> for LeSetPeriodicAdvertisingSyncTransferParametersBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetPeriodicAdvertisingSyncTransferParametersCompleteData {status: ErrorCode, connection_handle: u16, }
#[derive(Debug, Clone)] pub struct LeSetPeriodicAdvertisingSyncTransferParametersCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_periodic_advertising_sync_transfer_parameters_complete: Arc<LeSetPeriodicAdvertisingSyncTransferParametersCompleteData>,}
#[derive(Debug)] pub struct LeSetPeriodicAdvertisingSyncTransferParametersCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, }
impl LeSetPeriodicAdvertisingSyncTransferParametersCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetPeriodicAdvertisingSyncTransferParametersComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeSetPeriodicAdvertisingSyncTransferParametersComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;Ok(Self {status, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for LeSetPeriodicAdvertisingSyncTransferParametersCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetPeriodicAdvertisingSyncTransferParametersCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_periodic_advertising_sync_transfer_parameters_complete = match &command_complete.child {CommandCompleteDataChild::LeSetPeriodicAdvertisingSyncTransferParametersComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetPeriodicAdvertisingSyncTransferParametersComplete"),};Self {event,command_complete,le_set_periodic_advertising_sync_transfer_parameters_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_periodic_advertising_sync_transfer_parameters_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_set_periodic_advertising_sync_transfer_parameters_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for LeSetPeriodicAdvertisingSyncTransferParametersCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetPeriodicAdvertisingSyncTransferParametersCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetPeriodicAdvertisingSyncTransferParametersCompleteBuilder {pub fn build(self) -> LeSetPeriodicAdvertisingSyncTransferParametersCompletePacket {let le_set_periodic_advertising_sync_transfer_parameters_complete= Arc::new(LeSetPeriodicAdvertisingSyncTransferParametersCompleteData {status: self.status, connection_handle: self.connection_handle, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetPeriodicAdvertisingSyncTransferParameters, child: CommandCompleteDataChild::LeSetPeriodicAdvertisingSyncTransferParametersComplete(le_set_periodic_advertising_sync_transfer_parameters_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetPeriodicAdvertisingSyncTransferParametersCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetPeriodicAdvertisingSyncTransferParametersCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetPeriodicAdvertisingSyncTransferParametersCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetDefaultPeriodicAdvertisingSyncTransferParametersData {mode: SyncTransferMode, skip: u16, sync_timeout: u16, cte_type: u8, }
#[derive(Debug, Clone)] pub struct LeSetDefaultPeriodicAdvertisingSyncTransferParametersPacket {command: Arc<CommandData>,le_set_default_periodic_advertising_sync_transfer_parameters: Arc<LeSetDefaultPeriodicAdvertisingSyncTransferParametersData>,}
#[derive(Debug)] pub struct LeSetDefaultPeriodicAdvertisingSyncTransferParametersBuilder {pub mode: SyncTransferMode, pub skip: u16, pub sync_timeout: u16, pub cte_type: u8, }
impl LeSetDefaultPeriodicAdvertisingSyncTransferParametersData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetDefaultPeriodicAdvertisingSyncTransferParameters".to_string(),    field: "mode".to_string(),    wanted: 4,    got: bytes.len()});}let mode = u8::from_le_bytes([bytes[3]]);let mode = SyncTransferMode::from_u8(mode).unwrap();if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetDefaultPeriodicAdvertisingSyncTransferParameters".to_string(),    field: "skip".to_string(),    wanted: 6,    got: bytes.len()});}let skip = u16::from_le_bytes([bytes[4],bytes[5]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeSetDefaultPeriodicAdvertisingSyncTransferParameters".to_string(),    field: "sync_timeout".to_string(),    wanted: 8,    got: bytes.len()});}let sync_timeout = u16::from_le_bytes([bytes[6],bytes[7]]);if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeSetDefaultPeriodicAdvertisingSyncTransferParameters".to_string(),    field: "cte_type".to_string(),    wanted: 9,    got: bytes.len()});}let cte_type = u8::from_le_bytes([bytes[8]]);Ok(Self {mode, skip, sync_timeout, cte_type, })
}
fn write_to(&self, buffer: &mut BytesMut) {let mode = self.mode.to_u8().unwrap();buffer[3..4].copy_from_slice(&mode.to_le_bytes()[0..1]);let skip = self.skip;buffer[4..6].copy_from_slice(&skip.to_le_bytes()[0..2]);let sync_timeout = self.sync_timeout;buffer[6..8].copy_from_slice(&sync_timeout.to_le_bytes()[0..2]);let cte_type = self.cte_type;buffer[8..9].copy_from_slice(&cte_type.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl CommandExpectations for LeSetDefaultPeriodicAdvertisingSyncTransferParametersPacket { type ResponseType = LeSetDefaultPeriodicAdvertisingSyncTransferParametersCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetDefaultPeriodicAdvertisingSyncTransferParametersCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetDefaultPeriodicAdvertisingSyncTransferParametersPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetDefaultPeriodicAdvertisingSyncTransferParametersPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_set_default_periodic_advertising_sync_transfer_parameters = match &command.child {CommandDataChild::LeSetDefaultPeriodicAdvertisingSyncTransferParameters(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetDefaultPeriodicAdvertisingSyncTransferParameters"),};Self {command,le_set_default_periodic_advertising_sync_transfer_parameters,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_mode(&self) -> SyncTransferMode{ self.le_set_default_periodic_advertising_sync_transfer_parameters.as_ref().mode}
pub fn get_skip(&self) -> u16{ self.le_set_default_periodic_advertising_sync_transfer_parameters.as_ref().skip}
pub fn get_sync_timeout(&self) -> u16{ self.le_set_default_periodic_advertising_sync_transfer_parameters.as_ref().sync_timeout}
pub fn get_cte_type(&self) -> u8{ self.le_set_default_periodic_advertising_sync_transfer_parameters.as_ref().cte_type}
}
impl Into<CommandPacket> for LeSetDefaultPeriodicAdvertisingSyncTransferParametersPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeSetDefaultPeriodicAdvertisingSyncTransferParametersBuilder { type ResponseType = LeSetDefaultPeriodicAdvertisingSyncTransferParametersCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetDefaultPeriodicAdvertisingSyncTransferParametersCompletePacket::new(pkt.event.clone()) }}impl LeSetDefaultPeriodicAdvertisingSyncTransferParametersBuilder {pub fn build(self) -> LeSetDefaultPeriodicAdvertisingSyncTransferParametersPacket {let le_set_default_periodic_advertising_sync_transfer_parameters= Arc::new(LeSetDefaultPeriodicAdvertisingSyncTransferParametersData {mode: self.mode, skip: self.skip, sync_timeout: self.sync_timeout, cte_type: self.cte_type, });let command= Arc::new(CommandData {op_code: OpCode::LeSetDefaultPeriodicAdvertisingSyncTransferParameters, child: CommandDataChild::LeSetDefaultPeriodicAdvertisingSyncTransferParameters(le_set_default_periodic_advertising_sync_transfer_parameters),});LeSetDefaultPeriodicAdvertisingSyncTransferParametersPacket::new(command)}
}
impl Into<CommandPacket> for LeSetDefaultPeriodicAdvertisingSyncTransferParametersBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetDefaultPeriodicAdvertisingSyncTransferParametersCompleteData {}
#[derive(Debug, Clone)] pub struct LeSetDefaultPeriodicAdvertisingSyncTransferParametersCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_default_periodic_advertising_sync_transfer_parameters_complete: Arc<LeSetDefaultPeriodicAdvertisingSyncTransferParametersCompleteData>,}
#[derive(Debug)] pub struct LeSetDefaultPeriodicAdvertisingSyncTransferParametersCompleteBuilder {pub num_hci_command_packets: u8, }
impl LeSetDefaultPeriodicAdvertisingSyncTransferParametersCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeSetDefaultPeriodicAdvertisingSyncTransferParametersCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetDefaultPeriodicAdvertisingSyncTransferParametersCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_default_periodic_advertising_sync_transfer_parameters_complete = match &command_complete.child {CommandCompleteDataChild::LeSetDefaultPeriodicAdvertisingSyncTransferParametersComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetDefaultPeriodicAdvertisingSyncTransferParametersComplete"),};Self {event,command_complete,le_set_default_periodic_advertising_sync_transfer_parameters_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
}
impl Into<EventPacket> for LeSetDefaultPeriodicAdvertisingSyncTransferParametersCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetDefaultPeriodicAdvertisingSyncTransferParametersCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetDefaultPeriodicAdvertisingSyncTransferParametersCompleteBuilder {pub fn build(self) -> LeSetDefaultPeriodicAdvertisingSyncTransferParametersCompletePacket {let le_set_default_periodic_advertising_sync_transfer_parameters_complete= Arc::new(LeSetDefaultPeriodicAdvertisingSyncTransferParametersCompleteData {});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetDefaultPeriodicAdvertisingSyncTransferParameters, child: CommandCompleteDataChild::LeSetDefaultPeriodicAdvertisingSyncTransferParametersComplete(le_set_default_periodic_advertising_sync_transfer_parameters_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetDefaultPeriodicAdvertisingSyncTransferParametersCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetDefaultPeriodicAdvertisingSyncTransferParametersCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetDefaultPeriodicAdvertisingSyncTransferParametersCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeGenerateDhkeyCommandData {remote_p_256_public_key: [u8; 64], key_type: UseDebugKey, }
#[derive(Debug, Clone)] pub struct LeGenerateDhkeyCommandPacket {command: Arc<CommandData>,le_security_command: Arc<LeSecurityCommandData>,le_generate_dhkey_command: Arc<LeGenerateDhkeyCommandData>,}
#[derive(Debug)] pub struct LeGenerateDhkeyCommandBuilder {pub remote_p_256_public_key: [u8; 64], pub key_type: UseDebugKey, }
impl LeGenerateDhkeyCommandData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 67 { return Err(Error::InvalidLengthError{    obj: "LeGenerateDhkeyCommand".to_string(),    field: "remote_p_256_public_key".to_string(),    wanted: 67,    got: bytes.len()});}let remote_p_256_public_key = bytes[3..67].try_into().unwrap();if bytes.len() < 68 { return Err(Error::InvalidLengthError{    obj: "LeGenerateDhkeyCommand".to_string(),    field: "key_type".to_string(),    wanted: 68,    got: bytes.len()});}let key_type = u8::from_le_bytes([bytes[67]]);let key_type = UseDebugKey::from_u8(key_type).unwrap();Ok(Self {remote_p_256_public_key, key_type, })
}
fn write_to(&self, buffer: &mut BytesMut) {&buffer[3..67].copy_from_slice(&self.remote_p_256_public_key);let key_type = self.key_type.to_u8().unwrap();buffer[67..68].copy_from_slice(&key_type.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 65;ret}
}
impl CommandExpectations for LeGenerateDhkeyCommandPacket { type ResponseType = LeGenerateDhkeyCommandStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeGenerateDhkeyCommandStatusPacket::new(pkt.event.clone()) }}impl Packet for LeGenerateDhkeyCommandPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeGenerateDhkeyCommandPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_security_command = match &command.child {CommandDataChild::LeSecurityCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSecurityCommand"),};let le_generate_dhkey_command = match &le_security_command.child {LeSecurityCommandDataChild::LeGenerateDhkeyCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeGenerateDhkeyCommand"),};Self {command,le_security_command,le_generate_dhkey_command,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_remote_p_256_public_key(&self) -> &[u8; 64]{ &self.le_generate_dhkey_command.as_ref().remote_p_256_public_key}
pub fn get_key_type(&self) -> UseDebugKey{ self.le_generate_dhkey_command.as_ref().key_type}
}
impl Into<CommandPacket> for LeGenerateDhkeyCommandPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeSecurityCommandPacket> for LeGenerateDhkeyCommandPacket { fn into(self) -> LeSecurityCommandPacket {LeSecurityCommandPacket::new(self.command) }}
impl CommandExpectations for LeGenerateDhkeyCommandBuilder { type ResponseType = LeGenerateDhkeyCommandStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeGenerateDhkeyCommandStatusPacket::new(pkt.event.clone()) }}impl LeGenerateDhkeyCommandBuilder {pub fn build(self) -> LeGenerateDhkeyCommandPacket {let le_generate_dhkey_command= Arc::new(LeGenerateDhkeyCommandData {remote_p_256_public_key: self.remote_p_256_public_key, key_type: self.key_type, });let le_security_command= Arc::new(LeSecurityCommandData {child: LeSecurityCommandDataChild::LeGenerateDhkeyCommand(le_generate_dhkey_command),});let command= Arc::new(CommandData {op_code: OpCode::LeGenerateDhkeyCommand, child: CommandDataChild::LeSecurityCommand(le_security_command),});LeGenerateDhkeyCommandPacket::new(command)}
}
impl Into<CommandPacket> for LeGenerateDhkeyCommandBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeSecurityCommandPacket> for LeGenerateDhkeyCommandBuilder { fn into(self) -> LeSecurityCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeGenerateDhkeyCommandStatusData {}
#[derive(Debug, Clone)] pub struct LeGenerateDhkeyCommandStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,le_generate_dhkey_command_status: Arc<LeGenerateDhkeyCommandStatusData>,}
#[derive(Debug)] pub struct LeGenerateDhkeyCommandStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl LeGenerateDhkeyCommandStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeGenerateDhkeyCommandStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeGenerateDhkeyCommandStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let le_generate_dhkey_command_status = match &command_status.child {CommandStatusDataChild::LeGenerateDhkeyCommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeGenerateDhkeyCommandStatus"),};Self {event,command_status,le_generate_dhkey_command_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for LeGenerateDhkeyCommandStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for LeGenerateDhkeyCommandStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl LeGenerateDhkeyCommandStatusBuilder {pub fn build(self) -> LeGenerateDhkeyCommandStatusPacket {let le_generate_dhkey_command_status= Arc::new(LeGenerateDhkeyCommandStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeGenerateDhkeyCommand, child: CommandStatusDataChild::LeGenerateDhkeyCommandStatus(le_generate_dhkey_command_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});LeGenerateDhkeyCommandStatusPacket::new(event)}
}
impl Into<EventPacket> for LeGenerateDhkeyCommandStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for LeGenerateDhkeyCommandStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct LeModifySleepClockAccuracyData {action: ScaAction, }
#[derive(Debug, Clone)] pub struct LeModifySleepClockAccuracyPacket {command: Arc<CommandData>,le_modify_sleep_clock_accuracy: Arc<LeModifySleepClockAccuracyData>,}
#[derive(Debug)] pub struct LeModifySleepClockAccuracyBuilder {pub action: ScaAction, }
impl LeModifySleepClockAccuracyData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeModifySleepClockAccuracy".to_string(),    field: "action".to_string(),    wanted: 4,    got: bytes.len()});}let action = u8::from_le_bytes([bytes[3]]);let action = ScaAction::from_u8(action).unwrap();Ok(Self {action, })
}
fn write_to(&self, buffer: &mut BytesMut) {let action = self.action.to_u8().unwrap();buffer[3..4].copy_from_slice(&action.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for LeModifySleepClockAccuracyPacket { type ResponseType = LeModifySleepClockAccuracyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeModifySleepClockAccuracyCompletePacket::new(pkt.event.clone()) }}impl Packet for LeModifySleepClockAccuracyPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeModifySleepClockAccuracyPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_modify_sleep_clock_accuracy = match &command.child {CommandDataChild::LeModifySleepClockAccuracy(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeModifySleepClockAccuracy"),};Self {command,le_modify_sleep_clock_accuracy,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_action(&self) -> ScaAction{ self.le_modify_sleep_clock_accuracy.as_ref().action}
}
impl Into<CommandPacket> for LeModifySleepClockAccuracyPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeModifySleepClockAccuracyBuilder { type ResponseType = LeModifySleepClockAccuracyCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeModifySleepClockAccuracyCompletePacket::new(pkt.event.clone()) }}impl LeModifySleepClockAccuracyBuilder {pub fn build(self) -> LeModifySleepClockAccuracyPacket {let le_modify_sleep_clock_accuracy= Arc::new(LeModifySleepClockAccuracyData {action: self.action, });let command= Arc::new(CommandData {op_code: OpCode::LeModifySleepClockAccuracy, child: CommandDataChild::LeModifySleepClockAccuracy(le_modify_sleep_clock_accuracy),});LeModifySleepClockAccuracyPacket::new(command)}
}
impl Into<CommandPacket> for LeModifySleepClockAccuracyBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LeModifySleepClockAccuracyCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeModifySleepClockAccuracyCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_modify_sleep_clock_accuracy_complete: Arc<LeModifySleepClockAccuracyCompleteData>,}
#[derive(Debug)] pub struct LeModifySleepClockAccuracyCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeModifySleepClockAccuracyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeModifySleepClockAccuracyComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeModifySleepClockAccuracyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeModifySleepClockAccuracyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_modify_sleep_clock_accuracy_complete = match &command_complete.child {CommandCompleteDataChild::LeModifySleepClockAccuracyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeModifySleepClockAccuracyComplete"),};Self {event,command_complete,le_modify_sleep_clock_accuracy_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_modify_sleep_clock_accuracy_complete.as_ref().status}
}
impl Into<EventPacket> for LeModifySleepClockAccuracyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeModifySleepClockAccuracyCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeModifySleepClockAccuracyCompleteBuilder {pub fn build(self) -> LeModifySleepClockAccuracyCompletePacket {let le_modify_sleep_clock_accuracy_complete= Arc::new(LeModifySleepClockAccuracyCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeModifySleepClockAccuracy, child: CommandCompleteDataChild::LeModifySleepClockAccuracyComplete(le_modify_sleep_clock_accuracy_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeModifySleepClockAccuracyCompletePacket::new(event)}
}
impl Into<EventPacket> for LeModifySleepClockAccuracyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeModifySleepClockAccuracyCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeReadBufferSizeV2Data {}
#[derive(Debug, Clone)] pub struct LeReadBufferSizeV2Packet {command: Arc<CommandData>,le_read_buffer_size_v2: Arc<LeReadBufferSizeV2Data>,}
#[derive(Debug)] pub struct LeReadBufferSizeV2Builder {}
impl LeReadBufferSizeV2Data {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeReadBufferSizeV2Packet { type ResponseType = LeReadBufferSizeV2CompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadBufferSizeV2CompletePacket::new(pkt.event.clone()) }}impl Packet for LeReadBufferSizeV2Packet {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadBufferSizeV2Packet { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_read_buffer_size_v2 = match &command.child {CommandDataChild::LeReadBufferSizeV2(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadBufferSizeV2"),};Self {command,le_read_buffer_size_v2,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeReadBufferSizeV2Packet { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeReadBufferSizeV2Builder { type ResponseType = LeReadBufferSizeV2CompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadBufferSizeV2CompletePacket::new(pkt.event.clone()) }}impl LeReadBufferSizeV2Builder {pub fn build(self) -> LeReadBufferSizeV2Packet {let le_read_buffer_size_v2= Arc::new(LeReadBufferSizeV2Data {});let command= Arc::new(CommandData {op_code: OpCode::LeReadBufferSizeV2, child: CommandDataChild::LeReadBufferSizeV2(le_read_buffer_size_v2),});LeReadBufferSizeV2Packet::new(command)}
}
impl Into<CommandPacket> for LeReadBufferSizeV2Builder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LeReadBufferSizeV2CompleteData {status: ErrorCode, le_buffer_size: LeBufferSize, iso_buffer_size: LeBufferSize, }
#[derive(Debug, Clone)] pub struct LeReadBufferSizeV2CompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_read_buffer_size_v2_complete: Arc<LeReadBufferSizeV2CompleteData>,}
#[derive(Debug)] pub struct LeReadBufferSizeV2CompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub le_buffer_size: LeBufferSize, pub iso_buffer_size: LeBufferSize, }
impl LeReadBufferSizeV2CompleteData {fn conforms(bytes: &[u8]) -> bool {if !LeBufferSize::conforms(&bytes[6..9]) { return false; }if !LeBufferSize::conforms(&bytes[9..12]) { return false; } true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeReadBufferSizeV2Complete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();let le_buffer_size = LeBufferSize::parse(&bytes[6..9]).unwrap();let iso_buffer_size = LeBufferSize::parse(&bytes[9..12]).unwrap();Ok(Self {status, le_buffer_size, iso_buffer_size, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let le_buffer_size = &mut buffer[6..9];self.le_buffer_size.write_to(le_buffer_size);let iso_buffer_size = &mut buffer[9..12];self.iso_buffer_size.write_to(iso_buffer_size);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for LeReadBufferSizeV2CompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadBufferSizeV2CompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_read_buffer_size_v2_complete = match &command_complete.child {CommandCompleteDataChild::LeReadBufferSizeV2Complete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadBufferSizeV2Complete"),};Self {event,command_complete,le_read_buffer_size_v2_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_read_buffer_size_v2_complete.as_ref().status}
pub fn get_le_buffer_size(&self) -> &LeBufferSize{ &self.le_read_buffer_size_v2_complete.as_ref().le_buffer_size}
pub fn get_iso_buffer_size(&self) -> &LeBufferSize{ &self.le_read_buffer_size_v2_complete.as_ref().iso_buffer_size}
}
impl Into<EventPacket> for LeReadBufferSizeV2CompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeReadBufferSizeV2CompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeReadBufferSizeV2CompleteBuilder {pub fn build(self) -> LeReadBufferSizeV2CompletePacket {let le_read_buffer_size_v2_complete= Arc::new(LeReadBufferSizeV2CompleteData {status: self.status, le_buffer_size: self.le_buffer_size, iso_buffer_size: self.iso_buffer_size, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeReadBufferSizeV2, child: CommandCompleteDataChild::LeReadBufferSizeV2Complete(le_read_buffer_size_v2_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeReadBufferSizeV2CompletePacket::new(event)}
}
impl Into<EventPacket> for LeReadBufferSizeV2CompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeReadBufferSizeV2CompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeReadIsoTxSyncData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct LeReadIsoTxSyncPacket {command: Arc<CommandData>,le_iso_command: Arc<LeIsoCommandData>,le_read_iso_tx_sync: Arc<LeReadIsoTxSyncData>,}
#[derive(Debug)] pub struct LeReadIsoTxSyncBuilder {pub connection_handle: u16, }
impl LeReadIsoTxSyncData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeReadIsoTxSync".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for LeReadIsoTxSyncPacket { type ResponseType = LeReadIsoTxSyncCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadIsoTxSyncCompletePacket::new(pkt.event.clone()) }}impl Packet for LeReadIsoTxSyncPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadIsoTxSyncPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_iso_command = match &command.child {CommandDataChild::LeIsoCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeIsoCommand"),};let le_read_iso_tx_sync = match &le_iso_command.child {LeIsoCommandDataChild::LeReadIsoTxSync(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadIsoTxSync"),};Self {command,le_iso_command,le_read_iso_tx_sync,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_read_iso_tx_sync.as_ref().connection_handle}
}
impl Into<CommandPacket> for LeReadIsoTxSyncPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeIsoCommandPacket> for LeReadIsoTxSyncPacket { fn into(self) -> LeIsoCommandPacket {LeIsoCommandPacket::new(self.command) }}
impl CommandExpectations for LeReadIsoTxSyncBuilder { type ResponseType = LeReadIsoTxSyncCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadIsoTxSyncCompletePacket::new(pkt.event.clone()) }}impl LeReadIsoTxSyncBuilder {pub fn build(self) -> LeReadIsoTxSyncPacket {let le_read_iso_tx_sync= Arc::new(LeReadIsoTxSyncData {connection_handle: self.connection_handle, });let le_iso_command= Arc::new(LeIsoCommandData {child: LeIsoCommandDataChild::LeReadIsoTxSync(le_read_iso_tx_sync),});let command= Arc::new(CommandData {op_code: OpCode::LeReadIsoTxSync, child: CommandDataChild::LeIsoCommand(le_iso_command),});LeReadIsoTxSyncPacket::new(command)}
}
impl Into<CommandPacket> for LeReadIsoTxSyncBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeIsoCommandPacket> for LeReadIsoTxSyncBuilder { fn into(self) -> LeIsoCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeReadIsoTxSyncCompleteData {connection_handle: u16, packet_sequence_number: u16, timestamp: u32, time_offset: u32, }
#[derive(Debug, Clone)] pub struct LeReadIsoTxSyncCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_read_iso_tx_sync_complete: Arc<LeReadIsoTxSyncCompleteData>,}
#[derive(Debug)] pub struct LeReadIsoTxSyncCompleteBuilder {pub num_hci_command_packets: u8, pub connection_handle: u16, pub packet_sequence_number: u16, pub timestamp: u32, pub time_offset: u32, }
impl LeReadIsoTxSyncCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeReadIsoTxSyncComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 7,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[5],bytes[6]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeReadIsoTxSyncComplete".to_string(),    field: "packet_sequence_number".to_string(),    wanted: 9,    got: bytes.len()});}let packet_sequence_number = u16::from_le_bytes([bytes[7],bytes[8]]);if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "LeReadIsoTxSyncComplete".to_string(),    field: "timestamp".to_string(),    wanted: 13,    got: bytes.len()});}let timestamp = u32::from_le_bytes([bytes[9],bytes[10],bytes[11],bytes[12]]);if bytes.len() < 16 { return Err(Error::InvalidLengthError{    obj: "LeReadIsoTxSyncComplete".to_string(),    field: "time_offset".to_string(),    wanted: 16,    got: bytes.len()});}let time_offset = u32::from_le_bytes([bytes[13],bytes[14],bytes[15],0]);let time_offset = time_offset & 0xffffff;Ok(Self {connection_handle, packet_sequence_number, timestamp, time_offset, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[5..7].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let packet_sequence_number = self.packet_sequence_number;buffer[7..9].copy_from_slice(&packet_sequence_number.to_le_bytes()[0..2]);let timestamp = self.timestamp;buffer[9..13].copy_from_slice(&timestamp.to_le_bytes()[0..4]);let time_offset = self.time_offset;let time_offset = time_offset & 0xffffff;buffer[13..16].copy_from_slice(&time_offset.to_le_bytes()[0..3]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 11;ret}
}
impl Packet for LeReadIsoTxSyncCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadIsoTxSyncCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_read_iso_tx_sync_complete = match &command_complete.child {CommandCompleteDataChild::LeReadIsoTxSyncComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadIsoTxSyncComplete"),};Self {event,command_complete,le_read_iso_tx_sync_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_read_iso_tx_sync_complete.as_ref().connection_handle}
pub fn get_packet_sequence_number(&self) -> u16{ self.le_read_iso_tx_sync_complete.as_ref().packet_sequence_number}
pub fn get_timestamp(&self) -> u32{ self.le_read_iso_tx_sync_complete.as_ref().timestamp}
pub fn get_time_offset(&self) -> u32{ self.le_read_iso_tx_sync_complete.as_ref().time_offset}
}
impl Into<EventPacket> for LeReadIsoTxSyncCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeReadIsoTxSyncCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeReadIsoTxSyncCompleteBuilder {pub fn build(self) -> LeReadIsoTxSyncCompletePacket {let le_read_iso_tx_sync_complete= Arc::new(LeReadIsoTxSyncCompleteData {connection_handle: self.connection_handle, packet_sequence_number: self.packet_sequence_number, timestamp: self.timestamp, time_offset: self.time_offset, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeReadIsoTxSync, child: CommandCompleteDataChild::LeReadIsoTxSyncComplete(le_read_iso_tx_sync_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeReadIsoTxSyncCompletePacket::new(event)}
}
impl Into<EventPacket> for LeReadIsoTxSyncCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeReadIsoTxSyncCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetCigParametersData {cig_id: u8, sdu_interval_m_to_s: u32, sdu_interval_s_to_m: u32, peripherals_clock_accuracy: ClockAccuracy, packing: Packing, framing: Enable, max_transport_latency_m_to_s: u16, max_transport_latency_s_to_m: u16, cis_config: Vec::<CisParametersConfig>, }
#[derive(Debug, Clone)] pub struct LeSetCigParametersPacket {command: Arc<CommandData>,le_iso_command: Arc<LeIsoCommandData>,le_set_cig_parameters: Arc<LeSetCigParametersData>,}
#[derive(Debug)] pub struct LeSetCigParametersBuilder {pub cig_id: u8, pub sdu_interval_m_to_s: u32, pub sdu_interval_s_to_m: u32, pub peripherals_clock_accuracy: ClockAccuracy, pub packing: Packing, pub framing: Enable, pub max_transport_latency_m_to_s: u16, pub max_transport_latency_s_to_m: u16, pub cis_config: Vec::<CisParametersConfig>, }
impl LeSetCigParametersData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetCigParameters".to_string(),    field: "cig_id".to_string(),    wanted: 4,    got: bytes.len()});}let cig_id = u8::from_le_bytes([bytes[3]]);if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeSetCigParameters".to_string(),    field: "sdu_interval_m_to_s".to_string(),    wanted: 7,    got: bytes.len()});}let sdu_interval_m_to_s = u32::from_le_bytes([bytes[4],bytes[5],bytes[6],0]);let sdu_interval_m_to_s = sdu_interval_m_to_s & 0xffffff;if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeSetCigParameters".to_string(),    field: "sdu_interval_s_to_m".to_string(),    wanted: 10,    got: bytes.len()});}let sdu_interval_s_to_m = u32::from_le_bytes([bytes[7],bytes[8],bytes[9],0]);let sdu_interval_s_to_m = sdu_interval_s_to_m & 0xffffff;if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "LeSetCigParameters".to_string(),    field: "peripherals_clock_accuracy".to_string(),    wanted: 11,    got: bytes.len()});}let peripherals_clock_accuracy = u8::from_le_bytes([bytes[10]]);let peripherals_clock_accuracy = ClockAccuracy::from_u8(peripherals_clock_accuracy).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "LeSetCigParameters".to_string(),    field: "packing".to_string(),    wanted: 12,    got: bytes.len()});}let packing = u8::from_le_bytes([bytes[11]]);let packing = Packing::from_u8(packing).unwrap();if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "LeSetCigParameters".to_string(),    field: "framing".to_string(),    wanted: 13,    got: bytes.len()});}let framing = u8::from_le_bytes([bytes[12]]);let framing = Enable::from_u8(framing).unwrap();if bytes.len() < 15 { return Err(Error::InvalidLengthError{    obj: "LeSetCigParameters".to_string(),    field: "max_transport_latency_m_to_s".to_string(),    wanted: 15,    got: bytes.len()});}let max_transport_latency_m_to_s = u16::from_le_bytes([bytes[13],bytes[14]]);if bytes.len() < 17 { return Err(Error::InvalidLengthError{    obj: "LeSetCigParameters".to_string(),    field: "max_transport_latency_s_to_m".to_string(),    wanted: 17,    got: bytes.len()});}let max_transport_latency_s_to_m = u16::from_le_bytes([bytes[15],bytes[16]]);if bytes.len() < 18 { return Err(Error::InvalidLengthError{    obj: "LeSetCigParameters".to_string(),    field: "cis_config_count".to_string(),    wanted: 18,    got: bytes.len()});}let cis_config_count = u8::from_le_bytes([bytes[17]]);let mut cis_config: Vec::<CisParametersConfig> = Vec::new();let mut parsable_ = &bytes[18..];let count_ = cis_config_count as usize;for _ in 0..count_ { match CisParametersConfig::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];cis_config.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {cig_id, sdu_interval_m_to_s, sdu_interval_s_to_m, peripherals_clock_accuracy, packing, framing, max_transport_latency_m_to_s, max_transport_latency_s_to_m, cis_config, })
}
fn write_to(&self, buffer: &mut BytesMut) {let cig_id = self.cig_id;buffer[3..4].copy_from_slice(&cig_id.to_le_bytes()[0..1]);let sdu_interval_m_to_s = self.sdu_interval_m_to_s;let sdu_interval_m_to_s = sdu_interval_m_to_s & 0xffffff;buffer[4..7].copy_from_slice(&sdu_interval_m_to_s.to_le_bytes()[0..3]);let sdu_interval_s_to_m = self.sdu_interval_s_to_m;let sdu_interval_s_to_m = sdu_interval_s_to_m & 0xffffff;buffer[7..10].copy_from_slice(&sdu_interval_s_to_m.to_le_bytes()[0..3]);let peripherals_clock_accuracy = self.peripherals_clock_accuracy.to_u8().unwrap();buffer[10..11].copy_from_slice(&peripherals_clock_accuracy.to_le_bytes()[0..1]);let packing = self.packing.to_u8().unwrap();buffer[11..12].copy_from_slice(&packing.to_le_bytes()[0..1]);let framing = self.framing.to_u8().unwrap();buffer[12..13].copy_from_slice(&framing.to_le_bytes()[0..1]);let max_transport_latency_m_to_s = self.max_transport_latency_m_to_s;buffer[13..15].copy_from_slice(&max_transport_latency_m_to_s.to_le_bytes()[0..2]);let max_transport_latency_s_to_m = self.max_transport_latency_s_to_m;buffer[15..17].copy_from_slice(&max_transport_latency_s_to_m.to_le_bytes()[0..2]);buffer[17..18].copy_from_slice(&(self.cis_config.len() as u8).to_le_bytes());let mut vec_buffer_ = &mut buffer[18..];for e_ in &self.cis_config { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 15;let ret = ret + (self.cis_config.len() * ((/* Bits: */ 72 + /* Dynamic: */ 0) / 8));ret}
}
impl CommandExpectations for LeSetCigParametersPacket { type ResponseType = LeSetCigParametersCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetCigParametersCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetCigParametersPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetCigParametersPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_iso_command = match &command.child {CommandDataChild::LeIsoCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeIsoCommand"),};let le_set_cig_parameters = match &le_iso_command.child {LeIsoCommandDataChild::LeSetCigParameters(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetCigParameters"),};Self {command,le_iso_command,le_set_cig_parameters,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_cig_id(&self) -> u8{ self.le_set_cig_parameters.as_ref().cig_id}
pub fn get_sdu_interval_m_to_s(&self) -> u32{ self.le_set_cig_parameters.as_ref().sdu_interval_m_to_s}
pub fn get_sdu_interval_s_to_m(&self) -> u32{ self.le_set_cig_parameters.as_ref().sdu_interval_s_to_m}
pub fn get_peripherals_clock_accuracy(&self) -> ClockAccuracy{ self.le_set_cig_parameters.as_ref().peripherals_clock_accuracy}
pub fn get_packing(&self) -> Packing{ self.le_set_cig_parameters.as_ref().packing}
pub fn get_framing(&self) -> Enable{ self.le_set_cig_parameters.as_ref().framing}
pub fn get_max_transport_latency_m_to_s(&self) -> u16{ self.le_set_cig_parameters.as_ref().max_transport_latency_m_to_s}
pub fn get_max_transport_latency_s_to_m(&self) -> u16{ self.le_set_cig_parameters.as_ref().max_transport_latency_s_to_m}
pub fn get_cis_config(&self) -> &Vec::<CisParametersConfig>{ &self.le_set_cig_parameters.as_ref().cis_config}
}
impl Into<CommandPacket> for LeSetCigParametersPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeIsoCommandPacket> for LeSetCigParametersPacket { fn into(self) -> LeIsoCommandPacket {LeIsoCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetCigParametersBuilder { type ResponseType = LeSetCigParametersCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetCigParametersCompletePacket::new(pkt.event.clone()) }}impl LeSetCigParametersBuilder {pub fn build(self) -> LeSetCigParametersPacket {let le_set_cig_parameters= Arc::new(LeSetCigParametersData {cig_id: self.cig_id, sdu_interval_m_to_s: self.sdu_interval_m_to_s, sdu_interval_s_to_m: self.sdu_interval_s_to_m, peripherals_clock_accuracy: self.peripherals_clock_accuracy, packing: self.packing, framing: self.framing, max_transport_latency_m_to_s: self.max_transport_latency_m_to_s, max_transport_latency_s_to_m: self.max_transport_latency_s_to_m, cis_config: self.cis_config, });let le_iso_command= Arc::new(LeIsoCommandData {child: LeIsoCommandDataChild::LeSetCigParameters(le_set_cig_parameters),});let command= Arc::new(CommandData {op_code: OpCode::LeSetCigParameters, child: CommandDataChild::LeIsoCommand(le_iso_command),});LeSetCigParametersPacket::new(command)}
}
impl Into<CommandPacket> for LeSetCigParametersBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeIsoCommandPacket> for LeSetCigParametersBuilder { fn into(self) -> LeIsoCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetCigParametersCompleteData {status: ErrorCode, cig_id: u8, connection_handle: Vec::<u16>, }
#[derive(Debug, Clone)] pub struct LeSetCigParametersCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_cig_parameters_complete: Arc<LeSetCigParametersCompleteData>,}
#[derive(Debug)] pub struct LeSetCigParametersCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub cig_id: u8, pub connection_handle: Vec::<u16>, }
impl LeSetCigParametersCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetCigParametersComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeSetCigParametersComplete".to_string(),    field: "cig_id".to_string(),    wanted: 7,    got: bytes.len()});}let cig_id = u8::from_le_bytes([bytes[6]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeSetCigParametersComplete".to_string(),    field: "connection_handle_count".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle_count = u8::from_le_bytes([bytes[7]]);let want_ = 8 + ((connection_handle_count as usize) * 2);if bytes.len() < want_ { return Err(Error::InvalidLengthError{    obj: "LeSetCigParametersComplete".to_string(),    field: "connection_handle".to_string(),    wanted: want_,    got: bytes.len()});}let connection_handle: Vec::<u16> = bytes[8..8 + ((connection_handle_count as usize) * 2)].to_vec().chunks_exact(2).into_iter().map(|i| u16::from_le_bytes([i[0], i[1]])).collect();Ok(Self {status, cig_id, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let cig_id = self.cig_id;buffer[6..7].copy_from_slice(&cig_id.to_le_bytes()[0..1]);buffer[7..8].copy_from_slice(&(self.connection_handle.len() as u8).to_le_bytes());for (i, e) in self.connection_handle.iter().enumerate() {buffer[8+i..8+i+2].copy_from_slice(&e.to_le_bytes())}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;let ret = ret + (self.connection_handle.len() * ((/* Bits: */ 16 + /* Dynamic: */ 0) / 8));ret}
}
impl Packet for LeSetCigParametersCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetCigParametersCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_cig_parameters_complete = match &command_complete.child {CommandCompleteDataChild::LeSetCigParametersComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetCigParametersComplete"),};Self {event,command_complete,le_set_cig_parameters_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_cig_parameters_complete.as_ref().status}
pub fn get_cig_id(&self) -> u8{ self.le_set_cig_parameters_complete.as_ref().cig_id}
pub fn get_connection_handle(&self) -> &Vec::<u16>{ &self.le_set_cig_parameters_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for LeSetCigParametersCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetCigParametersCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetCigParametersCompleteBuilder {pub fn build(self) -> LeSetCigParametersCompletePacket {let le_set_cig_parameters_complete= Arc::new(LeSetCigParametersCompleteData {status: self.status, cig_id: self.cig_id, connection_handle: self.connection_handle, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetCigParameters, child: CommandCompleteDataChild::LeSetCigParametersComplete(le_set_cig_parameters_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetCigParametersCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetCigParametersCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetCigParametersCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetCigParametersTestData {cig_id: u8, sdu_interval_m_to_s: u32, sdu_interval_s_to_m: u32, ft_m_to_s: u8, ft_s_to_m: u8, iso_interval: u16, peripherals_clock_accuracy: ClockAccuracy, packing: Packing, framing: Enable, cis_config: Vec::<LeCisParametersTestConfig>, }
#[derive(Debug, Clone)] pub struct LeSetCigParametersTestPacket {command: Arc<CommandData>,le_iso_command: Arc<LeIsoCommandData>,le_set_cig_parameters_test: Arc<LeSetCigParametersTestData>,}
#[derive(Debug)] pub struct LeSetCigParametersTestBuilder {pub cig_id: u8, pub sdu_interval_m_to_s: u32, pub sdu_interval_s_to_m: u32, pub ft_m_to_s: u8, pub ft_s_to_m: u8, pub iso_interval: u16, pub peripherals_clock_accuracy: ClockAccuracy, pub packing: Packing, pub framing: Enable, pub cis_config: Vec::<LeCisParametersTestConfig>, }
impl LeSetCigParametersTestData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetCigParametersTest".to_string(),    field: "cig_id".to_string(),    wanted: 4,    got: bytes.len()});}let cig_id = u8::from_le_bytes([bytes[3]]);if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeSetCigParametersTest".to_string(),    field: "sdu_interval_m_to_s".to_string(),    wanted: 7,    got: bytes.len()});}let sdu_interval_m_to_s = u32::from_le_bytes([bytes[4],bytes[5],bytes[6],0]);let sdu_interval_m_to_s = sdu_interval_m_to_s & 0xffffff;if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeSetCigParametersTest".to_string(),    field: "sdu_interval_s_to_m".to_string(),    wanted: 10,    got: bytes.len()});}let sdu_interval_s_to_m = u32::from_le_bytes([bytes[7],bytes[8],bytes[9],0]);let sdu_interval_s_to_m = sdu_interval_s_to_m & 0xffffff;if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "LeSetCigParametersTest".to_string(),    field: "ft_m_to_s".to_string(),    wanted: 11,    got: bytes.len()});}let ft_m_to_s = u8::from_le_bytes([bytes[10]]);if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "LeSetCigParametersTest".to_string(),    field: "ft_s_to_m".to_string(),    wanted: 12,    got: bytes.len()});}let ft_s_to_m = u8::from_le_bytes([bytes[11]]);if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "LeSetCigParametersTest".to_string(),    field: "iso_interval".to_string(),    wanted: 14,    got: bytes.len()});}let iso_interval = u16::from_le_bytes([bytes[12],bytes[13]]);if bytes.len() < 15 { return Err(Error::InvalidLengthError{    obj: "LeSetCigParametersTest".to_string(),    field: "peripherals_clock_accuracy".to_string(),    wanted: 15,    got: bytes.len()});}let peripherals_clock_accuracy = u8::from_le_bytes([bytes[14]]);let peripherals_clock_accuracy = ClockAccuracy::from_u8(peripherals_clock_accuracy).unwrap();if bytes.len() < 16 { return Err(Error::InvalidLengthError{    obj: "LeSetCigParametersTest".to_string(),    field: "packing".to_string(),    wanted: 16,    got: bytes.len()});}let packing = u8::from_le_bytes([bytes[15]]);let packing = Packing::from_u8(packing).unwrap();if bytes.len() < 17 { return Err(Error::InvalidLengthError{    obj: "LeSetCigParametersTest".to_string(),    field: "framing".to_string(),    wanted: 17,    got: bytes.len()});}let framing = u8::from_le_bytes([bytes[16]]);let framing = Enable::from_u8(framing).unwrap();if bytes.len() < 18 { return Err(Error::InvalidLengthError{    obj: "LeSetCigParametersTest".to_string(),    field: "cis_config_count".to_string(),    wanted: 18,    got: bytes.len()});}let cis_config_count = u8::from_le_bytes([bytes[17]]);let mut cis_config: Vec::<LeCisParametersTestConfig> = Vec::new();let mut parsable_ = &bytes[18..];let count_ = cis_config_count as usize;for _ in 0..count_ { match LeCisParametersTestConfig::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];cis_config.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {cig_id, sdu_interval_m_to_s, sdu_interval_s_to_m, ft_m_to_s, ft_s_to_m, iso_interval, peripherals_clock_accuracy, packing, framing, cis_config, })
}
fn write_to(&self, buffer: &mut BytesMut) {let cig_id = self.cig_id;buffer[3..4].copy_from_slice(&cig_id.to_le_bytes()[0..1]);let sdu_interval_m_to_s = self.sdu_interval_m_to_s;let sdu_interval_m_to_s = sdu_interval_m_to_s & 0xffffff;buffer[4..7].copy_from_slice(&sdu_interval_m_to_s.to_le_bytes()[0..3]);let sdu_interval_s_to_m = self.sdu_interval_s_to_m;let sdu_interval_s_to_m = sdu_interval_s_to_m & 0xffffff;buffer[7..10].copy_from_slice(&sdu_interval_s_to_m.to_le_bytes()[0..3]);let ft_m_to_s = self.ft_m_to_s;buffer[10..11].copy_from_slice(&ft_m_to_s.to_le_bytes()[0..1]);let ft_s_to_m = self.ft_s_to_m;buffer[11..12].copy_from_slice(&ft_s_to_m.to_le_bytes()[0..1]);let iso_interval = self.iso_interval;buffer[12..14].copy_from_slice(&iso_interval.to_le_bytes()[0..2]);let peripherals_clock_accuracy = self.peripherals_clock_accuracy.to_u8().unwrap();buffer[14..15].copy_from_slice(&peripherals_clock_accuracy.to_le_bytes()[0..1]);let packing = self.packing.to_u8().unwrap();buffer[15..16].copy_from_slice(&packing.to_le_bytes()[0..1]);let framing = self.framing.to_u8().unwrap();buffer[16..17].copy_from_slice(&framing.to_le_bytes()[0..1]);buffer[17..18].copy_from_slice(&(self.cis_config.len() as u8).to_le_bytes());let mut vec_buffer_ = &mut buffer[18..];for e_ in &self.cis_config { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 15;let ret = ret + (self.cis_config.len() * ((/* Bits: */ 112 + /* Dynamic: */ 0) / 8));ret}
}
impl CommandExpectations for LeSetCigParametersTestPacket { type ResponseType = LeSetCigParametersTestCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetCigParametersTestCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetCigParametersTestPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetCigParametersTestPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_iso_command = match &command.child {CommandDataChild::LeIsoCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeIsoCommand"),};let le_set_cig_parameters_test = match &le_iso_command.child {LeIsoCommandDataChild::LeSetCigParametersTest(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetCigParametersTest"),};Self {command,le_iso_command,le_set_cig_parameters_test,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_cig_id(&self) -> u8{ self.le_set_cig_parameters_test.as_ref().cig_id}
pub fn get_sdu_interval_m_to_s(&self) -> u32{ self.le_set_cig_parameters_test.as_ref().sdu_interval_m_to_s}
pub fn get_sdu_interval_s_to_m(&self) -> u32{ self.le_set_cig_parameters_test.as_ref().sdu_interval_s_to_m}
pub fn get_ft_m_to_s(&self) -> u8{ self.le_set_cig_parameters_test.as_ref().ft_m_to_s}
pub fn get_ft_s_to_m(&self) -> u8{ self.le_set_cig_parameters_test.as_ref().ft_s_to_m}
pub fn get_iso_interval(&self) -> u16{ self.le_set_cig_parameters_test.as_ref().iso_interval}
pub fn get_peripherals_clock_accuracy(&self) -> ClockAccuracy{ self.le_set_cig_parameters_test.as_ref().peripherals_clock_accuracy}
pub fn get_packing(&self) -> Packing{ self.le_set_cig_parameters_test.as_ref().packing}
pub fn get_framing(&self) -> Enable{ self.le_set_cig_parameters_test.as_ref().framing}
pub fn get_cis_config(&self) -> &Vec::<LeCisParametersTestConfig>{ &self.le_set_cig_parameters_test.as_ref().cis_config}
}
impl Into<CommandPacket> for LeSetCigParametersTestPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeIsoCommandPacket> for LeSetCigParametersTestPacket { fn into(self) -> LeIsoCommandPacket {LeIsoCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetCigParametersTestBuilder { type ResponseType = LeSetCigParametersTestCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetCigParametersTestCompletePacket::new(pkt.event.clone()) }}impl LeSetCigParametersTestBuilder {pub fn build(self) -> LeSetCigParametersTestPacket {let le_set_cig_parameters_test= Arc::new(LeSetCigParametersTestData {cig_id: self.cig_id, sdu_interval_m_to_s: self.sdu_interval_m_to_s, sdu_interval_s_to_m: self.sdu_interval_s_to_m, ft_m_to_s: self.ft_m_to_s, ft_s_to_m: self.ft_s_to_m, iso_interval: self.iso_interval, peripherals_clock_accuracy: self.peripherals_clock_accuracy, packing: self.packing, framing: self.framing, cis_config: self.cis_config, });let le_iso_command= Arc::new(LeIsoCommandData {child: LeIsoCommandDataChild::LeSetCigParametersTest(le_set_cig_parameters_test),});let command= Arc::new(CommandData {op_code: OpCode::LeSetCigParametersTest, child: CommandDataChild::LeIsoCommand(le_iso_command),});LeSetCigParametersTestPacket::new(command)}
}
impl Into<CommandPacket> for LeSetCigParametersTestBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeIsoCommandPacket> for LeSetCigParametersTestBuilder { fn into(self) -> LeIsoCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetCigParametersTestCompleteData {status: ErrorCode, cig_id: u8, connection_handle: Vec::<u16>, }
#[derive(Debug, Clone)] pub struct LeSetCigParametersTestCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_cig_parameters_test_complete: Arc<LeSetCigParametersTestCompleteData>,}
#[derive(Debug)] pub struct LeSetCigParametersTestCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub cig_id: u8, pub connection_handle: Vec::<u16>, }
impl LeSetCigParametersTestCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetCigParametersTestComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeSetCigParametersTestComplete".to_string(),    field: "cig_id".to_string(),    wanted: 7,    got: bytes.len()});}let cig_id = u8::from_le_bytes([bytes[6]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeSetCigParametersTestComplete".to_string(),    field: "connection_handle_count".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle_count = u8::from_le_bytes([bytes[7]]);let want_ = 8 + ((connection_handle_count as usize) * 2);if bytes.len() < want_ { return Err(Error::InvalidLengthError{    obj: "LeSetCigParametersTestComplete".to_string(),    field: "connection_handle".to_string(),    wanted: want_,    got: bytes.len()});}let connection_handle: Vec::<u16> = bytes[8..8 + ((connection_handle_count as usize) * 2)].to_vec().chunks_exact(2).into_iter().map(|i| u16::from_le_bytes([i[0], i[1]])).collect();Ok(Self {status, cig_id, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let cig_id = self.cig_id;buffer[6..7].copy_from_slice(&cig_id.to_le_bytes()[0..1]);buffer[7..8].copy_from_slice(&(self.connection_handle.len() as u8).to_le_bytes());for (i, e) in self.connection_handle.iter().enumerate() {buffer[8+i..8+i+2].copy_from_slice(&e.to_le_bytes())}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;let ret = ret + (self.connection_handle.len() * ((/* Bits: */ 16 + /* Dynamic: */ 0) / 8));ret}
}
impl Packet for LeSetCigParametersTestCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetCigParametersTestCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_cig_parameters_test_complete = match &command_complete.child {CommandCompleteDataChild::LeSetCigParametersTestComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetCigParametersTestComplete"),};Self {event,command_complete,le_set_cig_parameters_test_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_cig_parameters_test_complete.as_ref().status}
pub fn get_cig_id(&self) -> u8{ self.le_set_cig_parameters_test_complete.as_ref().cig_id}
pub fn get_connection_handle(&self) -> &Vec::<u16>{ &self.le_set_cig_parameters_test_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for LeSetCigParametersTestCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetCigParametersTestCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetCigParametersTestCompleteBuilder {pub fn build(self) -> LeSetCigParametersTestCompletePacket {let le_set_cig_parameters_test_complete= Arc::new(LeSetCigParametersTestCompleteData {status: self.status, cig_id: self.cig_id, connection_handle: self.connection_handle, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetCigParametersTest, child: CommandCompleteDataChild::LeSetCigParametersTestComplete(le_set_cig_parameters_test_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetCigParametersTestCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetCigParametersTestCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetCigParametersTestCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeCreateCisData {cis_config: Vec::<CreateCisConfig>, }
#[derive(Debug, Clone)] pub struct LeCreateCisPacket {command: Arc<CommandData>,le_iso_command: Arc<LeIsoCommandData>,le_create_cis: Arc<LeCreateCisData>,}
#[derive(Debug)] pub struct LeCreateCisBuilder {pub cis_config: Vec::<CreateCisConfig>, }
impl LeCreateCisData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeCreateCis".to_string(),    field: "cis_config_count".to_string(),    wanted: 4,    got: bytes.len()});}let cis_config_count = u8::from_le_bytes([bytes[3]]);let mut cis_config: Vec::<CreateCisConfig> = Vec::new();let mut parsable_ = &bytes[4..];let count_ = cis_config_count as usize;for _ in 0..count_ { match CreateCisConfig::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];cis_config.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {cis_config, })
}
fn write_to(&self, buffer: &mut BytesMut) {buffer[3..4].copy_from_slice(&(self.cis_config.len() as u8).to_le_bytes());let mut vec_buffer_ = &mut buffer[4..];for e_ in &self.cis_config { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;let ret = ret + (self.cis_config.len() * ((/* Bits: */ 32 + /* Dynamic: */ 0) / 8));ret}
}
impl CommandExpectations for LeCreateCisPacket { type ResponseType = LeCreateCisStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeCreateCisStatusPacket::new(pkt.event.clone()) }}impl Packet for LeCreateCisPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeCreateCisPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_iso_command = match &command.child {CommandDataChild::LeIsoCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeIsoCommand"),};let le_create_cis = match &le_iso_command.child {LeIsoCommandDataChild::LeCreateCis(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeCreateCis"),};Self {command,le_iso_command,le_create_cis,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_cis_config(&self) -> &Vec::<CreateCisConfig>{ &self.le_create_cis.as_ref().cis_config}
}
impl Into<CommandPacket> for LeCreateCisPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeIsoCommandPacket> for LeCreateCisPacket { fn into(self) -> LeIsoCommandPacket {LeIsoCommandPacket::new(self.command) }}
impl CommandExpectations for LeCreateCisBuilder { type ResponseType = LeCreateCisStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeCreateCisStatusPacket::new(pkt.event.clone()) }}impl LeCreateCisBuilder {pub fn build(self) -> LeCreateCisPacket {let le_create_cis= Arc::new(LeCreateCisData {cis_config: self.cis_config, });let le_iso_command= Arc::new(LeIsoCommandData {child: LeIsoCommandDataChild::LeCreateCis(le_create_cis),});let command= Arc::new(CommandData {op_code: OpCode::LeCreateCis, child: CommandDataChild::LeIsoCommand(le_iso_command),});LeCreateCisPacket::new(command)}
}
impl Into<CommandPacket> for LeCreateCisBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeIsoCommandPacket> for LeCreateCisBuilder { fn into(self) -> LeIsoCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeCreateCisStatusData {}
#[derive(Debug, Clone)] pub struct LeCreateCisStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,le_create_cis_status: Arc<LeCreateCisStatusData>,}
#[derive(Debug)] pub struct LeCreateCisStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl LeCreateCisStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeCreateCisStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeCreateCisStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let le_create_cis_status = match &command_status.child {CommandStatusDataChild::LeCreateCisStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeCreateCisStatus"),};Self {event,command_status,le_create_cis_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for LeCreateCisStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for LeCreateCisStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl LeCreateCisStatusBuilder {pub fn build(self) -> LeCreateCisStatusPacket {let le_create_cis_status= Arc::new(LeCreateCisStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeCreateCis, child: CommandStatusDataChild::LeCreateCisStatus(le_create_cis_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});LeCreateCisStatusPacket::new(event)}
}
impl Into<EventPacket> for LeCreateCisStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for LeCreateCisStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct LeRemoveCigData {cig_id: u8, }
#[derive(Debug, Clone)] pub struct LeRemoveCigPacket {command: Arc<CommandData>,le_iso_command: Arc<LeIsoCommandData>,le_remove_cig: Arc<LeRemoveCigData>,}
#[derive(Debug)] pub struct LeRemoveCigBuilder {pub cig_id: u8, }
impl LeRemoveCigData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeRemoveCig".to_string(),    field: "cig_id".to_string(),    wanted: 4,    got: bytes.len()});}let cig_id = u8::from_le_bytes([bytes[3]]);Ok(Self {cig_id, })
}
fn write_to(&self, buffer: &mut BytesMut) {let cig_id = self.cig_id;buffer[3..4].copy_from_slice(&cig_id.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for LeRemoveCigPacket { type ResponseType = LeRemoveCigCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeRemoveCigCompletePacket::new(pkt.event.clone()) }}impl Packet for LeRemoveCigPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeRemoveCigPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_iso_command = match &command.child {CommandDataChild::LeIsoCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeIsoCommand"),};let le_remove_cig = match &le_iso_command.child {LeIsoCommandDataChild::LeRemoveCig(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeRemoveCig"),};Self {command,le_iso_command,le_remove_cig,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_cig_id(&self) -> u8{ self.le_remove_cig.as_ref().cig_id}
}
impl Into<CommandPacket> for LeRemoveCigPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeIsoCommandPacket> for LeRemoveCigPacket { fn into(self) -> LeIsoCommandPacket {LeIsoCommandPacket::new(self.command) }}
impl CommandExpectations for LeRemoveCigBuilder { type ResponseType = LeRemoveCigCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeRemoveCigCompletePacket::new(pkt.event.clone()) }}impl LeRemoveCigBuilder {pub fn build(self) -> LeRemoveCigPacket {let le_remove_cig= Arc::new(LeRemoveCigData {cig_id: self.cig_id, });let le_iso_command= Arc::new(LeIsoCommandData {child: LeIsoCommandDataChild::LeRemoveCig(le_remove_cig),});let command= Arc::new(CommandData {op_code: OpCode::LeRemoveCig, child: CommandDataChild::LeIsoCommand(le_iso_command),});LeRemoveCigPacket::new(command)}
}
impl Into<CommandPacket> for LeRemoveCigBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeIsoCommandPacket> for LeRemoveCigBuilder { fn into(self) -> LeIsoCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeRemoveCigCompleteData {status: ErrorCode, cig_id: u8, }
#[derive(Debug, Clone)] pub struct LeRemoveCigCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_remove_cig_complete: Arc<LeRemoveCigCompleteData>,}
#[derive(Debug)] pub struct LeRemoveCigCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub cig_id: u8, }
impl LeRemoveCigCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeRemoveCigComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeRemoveCigComplete".to_string(),    field: "cig_id".to_string(),    wanted: 7,    got: bytes.len()});}let cig_id = u8::from_le_bytes([bytes[6]]);Ok(Self {status, cig_id, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let cig_id = self.cig_id;buffer[6..7].copy_from_slice(&cig_id.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for LeRemoveCigCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeRemoveCigCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_remove_cig_complete = match &command_complete.child {CommandCompleteDataChild::LeRemoveCigComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeRemoveCigComplete"),};Self {event,command_complete,le_remove_cig_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_remove_cig_complete.as_ref().status}
pub fn get_cig_id(&self) -> u8{ self.le_remove_cig_complete.as_ref().cig_id}
}
impl Into<EventPacket> for LeRemoveCigCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeRemoveCigCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeRemoveCigCompleteBuilder {pub fn build(self) -> LeRemoveCigCompletePacket {let le_remove_cig_complete= Arc::new(LeRemoveCigCompleteData {status: self.status, cig_id: self.cig_id, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeRemoveCig, child: CommandCompleteDataChild::LeRemoveCigComplete(le_remove_cig_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeRemoveCigCompletePacket::new(event)}
}
impl Into<EventPacket> for LeRemoveCigCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeRemoveCigCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeAcceptCisRequestData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct LeAcceptCisRequestPacket {command: Arc<CommandData>,le_iso_command: Arc<LeIsoCommandData>,le_accept_cis_request: Arc<LeAcceptCisRequestData>,}
#[derive(Debug)] pub struct LeAcceptCisRequestBuilder {pub connection_handle: u16, }
impl LeAcceptCisRequestData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeAcceptCisRequest".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for LeAcceptCisRequestPacket { type ResponseType = LeAcceptCisRequestStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeAcceptCisRequestStatusPacket::new(pkt.event.clone()) }}impl Packet for LeAcceptCisRequestPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAcceptCisRequestPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_iso_command = match &command.child {CommandDataChild::LeIsoCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeIsoCommand"),};let le_accept_cis_request = match &le_iso_command.child {LeIsoCommandDataChild::LeAcceptCisRequest(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAcceptCisRequest"),};Self {command,le_iso_command,le_accept_cis_request,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_accept_cis_request.as_ref().connection_handle}
}
impl Into<CommandPacket> for LeAcceptCisRequestPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeIsoCommandPacket> for LeAcceptCisRequestPacket { fn into(self) -> LeIsoCommandPacket {LeIsoCommandPacket::new(self.command) }}
impl CommandExpectations for LeAcceptCisRequestBuilder { type ResponseType = LeAcceptCisRequestStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeAcceptCisRequestStatusPacket::new(pkt.event.clone()) }}impl LeAcceptCisRequestBuilder {pub fn build(self) -> LeAcceptCisRequestPacket {let le_accept_cis_request= Arc::new(LeAcceptCisRequestData {connection_handle: self.connection_handle, });let le_iso_command= Arc::new(LeIsoCommandData {child: LeIsoCommandDataChild::LeAcceptCisRequest(le_accept_cis_request),});let command= Arc::new(CommandData {op_code: OpCode::LeAcceptCisRequest, child: CommandDataChild::LeIsoCommand(le_iso_command),});LeAcceptCisRequestPacket::new(command)}
}
impl Into<CommandPacket> for LeAcceptCisRequestBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeIsoCommandPacket> for LeAcceptCisRequestBuilder { fn into(self) -> LeIsoCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeAcceptCisRequestStatusData {}
#[derive(Debug, Clone)] pub struct LeAcceptCisRequestStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,le_accept_cis_request_status: Arc<LeAcceptCisRequestStatusData>,}
#[derive(Debug)] pub struct LeAcceptCisRequestStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl LeAcceptCisRequestStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeAcceptCisRequestStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAcceptCisRequestStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let le_accept_cis_request_status = match &command_status.child {CommandStatusDataChild::LeAcceptCisRequestStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAcceptCisRequestStatus"),};Self {event,command_status,le_accept_cis_request_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for LeAcceptCisRequestStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for LeAcceptCisRequestStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl LeAcceptCisRequestStatusBuilder {pub fn build(self) -> LeAcceptCisRequestStatusPacket {let le_accept_cis_request_status= Arc::new(LeAcceptCisRequestStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeAcceptCisRequest, child: CommandStatusDataChild::LeAcceptCisRequestStatus(le_accept_cis_request_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});LeAcceptCisRequestStatusPacket::new(event)}
}
impl Into<EventPacket> for LeAcceptCisRequestStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for LeAcceptCisRequestStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct LeRejectCisRequestData {connection_handle: u16, reason: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeRejectCisRequestPacket {command: Arc<CommandData>,le_iso_command: Arc<LeIsoCommandData>,le_reject_cis_request: Arc<LeRejectCisRequestData>,}
#[derive(Debug)] pub struct LeRejectCisRequestBuilder {pub connection_handle: u16, pub reason: ErrorCode, }
impl LeRejectCisRequestData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeRejectCisRequest".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeRejectCisRequest".to_string(),    field: "reason".to_string(),    wanted: 6,    got: bytes.len()});}let reason = u8::from_le_bytes([bytes[5]]);let reason = ErrorCode::from_u8(reason).unwrap();Ok(Self {connection_handle, reason, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let reason = self.reason.to_u8().unwrap();buffer[5..6].copy_from_slice(&reason.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl CommandExpectations for LeRejectCisRequestPacket { type ResponseType = LeRejectCisRequestCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeRejectCisRequestCompletePacket::new(pkt.event.clone()) }}impl Packet for LeRejectCisRequestPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeRejectCisRequestPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_iso_command = match &command.child {CommandDataChild::LeIsoCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeIsoCommand"),};let le_reject_cis_request = match &le_iso_command.child {LeIsoCommandDataChild::LeRejectCisRequest(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeRejectCisRequest"),};Self {command,le_iso_command,le_reject_cis_request,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_reject_cis_request.as_ref().connection_handle}
pub fn get_reason(&self) -> ErrorCode{ self.le_reject_cis_request.as_ref().reason}
}
impl Into<CommandPacket> for LeRejectCisRequestPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeIsoCommandPacket> for LeRejectCisRequestPacket { fn into(self) -> LeIsoCommandPacket {LeIsoCommandPacket::new(self.command) }}
impl CommandExpectations for LeRejectCisRequestBuilder { type ResponseType = LeRejectCisRequestCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeRejectCisRequestCompletePacket::new(pkt.event.clone()) }}impl LeRejectCisRequestBuilder {pub fn build(self) -> LeRejectCisRequestPacket {let le_reject_cis_request= Arc::new(LeRejectCisRequestData {connection_handle: self.connection_handle, reason: self.reason, });let le_iso_command= Arc::new(LeIsoCommandData {child: LeIsoCommandDataChild::LeRejectCisRequest(le_reject_cis_request),});let command= Arc::new(CommandData {op_code: OpCode::LeRejectCisRequest, child: CommandDataChild::LeIsoCommand(le_iso_command),});LeRejectCisRequestPacket::new(command)}
}
impl Into<CommandPacket> for LeRejectCisRequestBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeIsoCommandPacket> for LeRejectCisRequestBuilder { fn into(self) -> LeIsoCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeRejectCisRequestCompleteData {status: ErrorCode, connection_handle: u16, }
#[derive(Debug, Clone)] pub struct LeRejectCisRequestCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_reject_cis_request_complete: Arc<LeRejectCisRequestCompleteData>,}
#[derive(Debug)] pub struct LeRejectCisRequestCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, }
impl LeRejectCisRequestCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeRejectCisRequestComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeRejectCisRequestComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;Ok(Self {status, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for LeRejectCisRequestCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeRejectCisRequestCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_reject_cis_request_complete = match &command_complete.child {CommandCompleteDataChild::LeRejectCisRequestComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeRejectCisRequestComplete"),};Self {event,command_complete,le_reject_cis_request_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_reject_cis_request_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_reject_cis_request_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for LeRejectCisRequestCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeRejectCisRequestCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeRejectCisRequestCompleteBuilder {pub fn build(self) -> LeRejectCisRequestCompletePacket {let le_reject_cis_request_complete= Arc::new(LeRejectCisRequestCompleteData {status: self.status, connection_handle: self.connection_handle, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeRejectCisRequest, child: CommandCompleteDataChild::LeRejectCisRequestComplete(le_reject_cis_request_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeRejectCisRequestCompletePacket::new(event)}
}
impl Into<EventPacket> for LeRejectCisRequestCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeRejectCisRequestCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeCreateBigData {big_handle: u8, advertising_handle: u8, num_bis: u8, sdu_interval: u32, max_sdu: u16, max_transport_latency: u16, rtn: u8, phy: SecondaryPhyType, packing: Packing, framing: Enable, encryption: Enable, broadcast_code: Vec::<u16>, }
#[derive(Debug, Clone)] pub struct LeCreateBigPacket {command: Arc<CommandData>,le_iso_command: Arc<LeIsoCommandData>,le_create_big: Arc<LeCreateBigData>,}
#[derive(Debug)] pub struct LeCreateBigBuilder {pub big_handle: u8, pub advertising_handle: u8, pub num_bis: u8, pub sdu_interval: u32, pub max_sdu: u16, pub max_transport_latency: u16, pub rtn: u8, pub phy: SecondaryPhyType, pub packing: Packing, pub framing: Enable, pub encryption: Enable, pub broadcast_code: Vec::<u16>, }
impl LeCreateBigData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeCreateBig".to_string(),    field: "big_handle".to_string(),    wanted: 4,    got: bytes.len()});}let big_handle = u8::from_le_bytes([bytes[3]]);if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeCreateBig".to_string(),    field: "advertising_handle".to_string(),    wanted: 5,    got: bytes.len()});}let advertising_handle = u8::from_le_bytes([bytes[4]]);if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeCreateBig".to_string(),    field: "num_bis".to_string(),    wanted: 6,    got: bytes.len()});}let num_bis = u8::from_le_bytes([bytes[5]]);if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeCreateBig".to_string(),    field: "sdu_interval".to_string(),    wanted: 9,    got: bytes.len()});}let sdu_interval = u32::from_le_bytes([bytes[6],bytes[7],bytes[8],0]);let sdu_interval = sdu_interval & 0xffffff;if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "LeCreateBig".to_string(),    field: "max_sdu".to_string(),    wanted: 11,    got: bytes.len()});}let max_sdu = u16::from_le_bytes([bytes[9],bytes[10]]);if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "LeCreateBig".to_string(),    field: "max_transport_latency".to_string(),    wanted: 13,    got: bytes.len()});}let max_transport_latency = u16::from_le_bytes([bytes[11],bytes[12]]);let rtn = u8::from_le_bytes([bytes[13]]);let rtn = rtn & 0xf;if bytes.len() < 15 { return Err(Error::InvalidLengthError{    obj: "LeCreateBig".to_string(),    field: "phy".to_string(),    wanted: 15,    got: bytes.len()});}let phy = u8::from_le_bytes([bytes[14]]);let phy = SecondaryPhyType::from_u8(phy).unwrap();if bytes.len() < 16 { return Err(Error::InvalidLengthError{    obj: "LeCreateBig".to_string(),    field: "packing".to_string(),    wanted: 16,    got: bytes.len()});}let packing = u8::from_le_bytes([bytes[15]]);let packing = Packing::from_u8(packing).unwrap();if bytes.len() < 17 { return Err(Error::InvalidLengthError{    obj: "LeCreateBig".to_string(),    field: "framing".to_string(),    wanted: 17,    got: bytes.len()});}let framing = u8::from_le_bytes([bytes[16]]);let framing = Enable::from_u8(framing).unwrap();if bytes.len() < 18 { return Err(Error::InvalidLengthError{    obj: "LeCreateBig".to_string(),    field: "encryption".to_string(),    wanted: 18,    got: bytes.len()});}let encryption = u8::from_le_bytes([bytes[17]]);let encryption = Enable::from_u8(encryption).unwrap();let rem_ = (bytes.len() - 18) % 2;if rem_ != 0 { return Err(Error::InvalidLengthError{    obj: "LeCreateBig".to_string(),    field: "broadcast_code".to_string(),    wanted: bytes.len() + rem_,    got: bytes.len()});}let broadcast_code: Vec::<u16> = bytes[18..].to_vec().chunks_exact(2).into_iter().map(|i| u16::from_le_bytes([i[0], i[1]])).collect();Ok(Self {big_handle, advertising_handle, num_bis, sdu_interval, max_sdu, max_transport_latency, rtn, phy, packing, framing, encryption, broadcast_code, })
}
fn write_to(&self, buffer: &mut BytesMut) {let big_handle = self.big_handle;buffer[3..4].copy_from_slice(&big_handle.to_le_bytes()[0..1]);let advertising_handle = self.advertising_handle;buffer[4..5].copy_from_slice(&advertising_handle.to_le_bytes()[0..1]);let num_bis = self.num_bis;buffer[5..6].copy_from_slice(&num_bis.to_le_bytes()[0..1]);let sdu_interval = self.sdu_interval;let sdu_interval = sdu_interval & 0xffffff;buffer[6..9].copy_from_slice(&sdu_interval.to_le_bytes()[0..3]);let max_sdu = self.max_sdu;buffer[9..11].copy_from_slice(&max_sdu.to_le_bytes()[0..2]);let max_transport_latency = self.max_transport_latency;buffer[11..13].copy_from_slice(&max_transport_latency.to_le_bytes()[0..2]);let rtn = self.rtn;let rtn = rtn & 0xf;buffer[13..14].copy_from_slice(&rtn.to_le_bytes()[0..1]);let phy = self.phy.to_u8().unwrap();buffer[14..15].copy_from_slice(&phy.to_le_bytes()[0..1]);let packing = self.packing.to_u8().unwrap();buffer[15..16].copy_from_slice(&packing.to_le_bytes()[0..1]);let framing = self.framing.to_u8().unwrap();buffer[16..17].copy_from_slice(&framing.to_le_bytes()[0..1]);let encryption = self.encryption.to_u8().unwrap();buffer[17..18].copy_from_slice(&encryption.to_le_bytes()[0..1]);for (i, e) in self.broadcast_code.iter().enumerate() {buffer[18+i..18+i+2].copy_from_slice(&e.to_le_bytes())}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 15;let ret = ret + (self.broadcast_code.len() * ((/* Bits: */ 16 + /* Dynamic: */ 0) / 8));ret}
}
impl CommandExpectations for LeCreateBigPacket { type ResponseType = LeCreateBigStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeCreateBigStatusPacket::new(pkt.event.clone()) }}impl Packet for LeCreateBigPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeCreateBigPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_iso_command = match &command.child {CommandDataChild::LeIsoCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeIsoCommand"),};let le_create_big = match &le_iso_command.child {LeIsoCommandDataChild::LeCreateBig(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeCreateBig"),};Self {command,le_iso_command,le_create_big,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_big_handle(&self) -> u8{ self.le_create_big.as_ref().big_handle}
pub fn get_advertising_handle(&self) -> u8{ self.le_create_big.as_ref().advertising_handle}
pub fn get_num_bis(&self) -> u8{ self.le_create_big.as_ref().num_bis}
pub fn get_sdu_interval(&self) -> u32{ self.le_create_big.as_ref().sdu_interval}
pub fn get_max_sdu(&self) -> u16{ self.le_create_big.as_ref().max_sdu}
pub fn get_max_transport_latency(&self) -> u16{ self.le_create_big.as_ref().max_transport_latency}
pub fn get_rtn(&self) -> u8{ self.le_create_big.as_ref().rtn}
pub fn get_phy(&self) -> SecondaryPhyType{ self.le_create_big.as_ref().phy}
pub fn get_packing(&self) -> Packing{ self.le_create_big.as_ref().packing}
pub fn get_framing(&self) -> Enable{ self.le_create_big.as_ref().framing}
pub fn get_encryption(&self) -> Enable{ self.le_create_big.as_ref().encryption}
pub fn get_broadcast_code(&self) -> &Vec::<u16>{ &self.le_create_big.as_ref().broadcast_code}
}
impl Into<CommandPacket> for LeCreateBigPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeIsoCommandPacket> for LeCreateBigPacket { fn into(self) -> LeIsoCommandPacket {LeIsoCommandPacket::new(self.command) }}
impl CommandExpectations for LeCreateBigBuilder { type ResponseType = LeCreateBigStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeCreateBigStatusPacket::new(pkt.event.clone()) }}impl LeCreateBigBuilder {pub fn build(self) -> LeCreateBigPacket {let le_create_big= Arc::new(LeCreateBigData {big_handle: self.big_handle, advertising_handle: self.advertising_handle, num_bis: self.num_bis, sdu_interval: self.sdu_interval, max_sdu: self.max_sdu, max_transport_latency: self.max_transport_latency, rtn: self.rtn, phy: self.phy, packing: self.packing, framing: self.framing, encryption: self.encryption, broadcast_code: self.broadcast_code, });let le_iso_command= Arc::new(LeIsoCommandData {child: LeIsoCommandDataChild::LeCreateBig(le_create_big),});let command= Arc::new(CommandData {op_code: OpCode::LeCreateBig, child: CommandDataChild::LeIsoCommand(le_iso_command),});LeCreateBigPacket::new(command)}
}
impl Into<CommandPacket> for LeCreateBigBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeIsoCommandPacket> for LeCreateBigBuilder { fn into(self) -> LeIsoCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeCreateBigStatusData {}
#[derive(Debug, Clone)] pub struct LeCreateBigStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,le_create_big_status: Arc<LeCreateBigStatusData>,}
#[derive(Debug)] pub struct LeCreateBigStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl LeCreateBigStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeCreateBigStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeCreateBigStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let le_create_big_status = match &command_status.child {CommandStatusDataChild::LeCreateBigStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeCreateBigStatus"),};Self {event,command_status,le_create_big_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for LeCreateBigStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for LeCreateBigStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl LeCreateBigStatusBuilder {pub fn build(self) -> LeCreateBigStatusPacket {let le_create_big_status= Arc::new(LeCreateBigStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeCreateBig, child: CommandStatusDataChild::LeCreateBigStatus(le_create_big_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});LeCreateBigStatusPacket::new(event)}
}
impl Into<EventPacket> for LeCreateBigStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for LeCreateBigStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct LeTerminateBigData {big_handle: u8, reason: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeTerminateBigPacket {command: Arc<CommandData>,le_iso_command: Arc<LeIsoCommandData>,le_terminate_big: Arc<LeTerminateBigData>,}
#[derive(Debug)] pub struct LeTerminateBigBuilder {pub big_handle: u8, pub reason: ErrorCode, }
impl LeTerminateBigData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeTerminateBig".to_string(),    field: "big_handle".to_string(),    wanted: 4,    got: bytes.len()});}let big_handle = u8::from_le_bytes([bytes[3]]);if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeTerminateBig".to_string(),    field: "reason".to_string(),    wanted: 5,    got: bytes.len()});}let reason = u8::from_le_bytes([bytes[4]]);let reason = ErrorCode::from_u8(reason).unwrap();Ok(Self {big_handle, reason, })
}
fn write_to(&self, buffer: &mut BytesMut) {let big_handle = self.big_handle;buffer[3..4].copy_from_slice(&big_handle.to_le_bytes()[0..1]);let reason = self.reason.to_u8().unwrap();buffer[4..5].copy_from_slice(&reason.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for LeTerminateBigPacket { type ResponseType = LeTerminateBigStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeTerminateBigStatusPacket::new(pkt.event.clone()) }}impl Packet for LeTerminateBigPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeTerminateBigPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_iso_command = match &command.child {CommandDataChild::LeIsoCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeIsoCommand"),};let le_terminate_big = match &le_iso_command.child {LeIsoCommandDataChild::LeTerminateBig(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeTerminateBig"),};Self {command,le_iso_command,le_terminate_big,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_big_handle(&self) -> u8{ self.le_terminate_big.as_ref().big_handle}
pub fn get_reason(&self) -> ErrorCode{ self.le_terminate_big.as_ref().reason}
}
impl Into<CommandPacket> for LeTerminateBigPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeIsoCommandPacket> for LeTerminateBigPacket { fn into(self) -> LeIsoCommandPacket {LeIsoCommandPacket::new(self.command) }}
impl CommandExpectations for LeTerminateBigBuilder { type ResponseType = LeTerminateBigStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeTerminateBigStatusPacket::new(pkt.event.clone()) }}impl LeTerminateBigBuilder {pub fn build(self) -> LeTerminateBigPacket {let le_terminate_big= Arc::new(LeTerminateBigData {big_handle: self.big_handle, reason: self.reason, });let le_iso_command= Arc::new(LeIsoCommandData {child: LeIsoCommandDataChild::LeTerminateBig(le_terminate_big),});let command= Arc::new(CommandData {op_code: OpCode::LeTerminateBig, child: CommandDataChild::LeIsoCommand(le_iso_command),});LeTerminateBigPacket::new(command)}
}
impl Into<CommandPacket> for LeTerminateBigBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeIsoCommandPacket> for LeTerminateBigBuilder { fn into(self) -> LeIsoCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeTerminateBigStatusData {}
#[derive(Debug, Clone)] pub struct LeTerminateBigStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,le_terminate_big_status: Arc<LeTerminateBigStatusData>,}
#[derive(Debug)] pub struct LeTerminateBigStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl LeTerminateBigStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeTerminateBigStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeTerminateBigStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let le_terminate_big_status = match &command_status.child {CommandStatusDataChild::LeTerminateBigStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeTerminateBigStatus"),};Self {event,command_status,le_terminate_big_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for LeTerminateBigStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for LeTerminateBigStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl LeTerminateBigStatusBuilder {pub fn build(self) -> LeTerminateBigStatusPacket {let le_terminate_big_status= Arc::new(LeTerminateBigStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeTerminateBig, child: CommandStatusDataChild::LeTerminateBigStatus(le_terminate_big_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});LeTerminateBigStatusPacket::new(event)}
}
impl Into<EventPacket> for LeTerminateBigStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for LeTerminateBigStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct LeBigCreateSyncData {big_handle: u8, sync_handle: u16, encryption: Enable, broadcast_code: Vec::<u16>, mse: u8, big_sync_timeout: u16, bis: Vec::<u8>, }
#[derive(Debug, Clone)] pub struct LeBigCreateSyncPacket {command: Arc<CommandData>,le_iso_command: Arc<LeIsoCommandData>,le_big_create_sync: Arc<LeBigCreateSyncData>,}
#[derive(Debug)] pub struct LeBigCreateSyncBuilder {pub big_handle: u8, pub sync_handle: u16, pub encryption: Enable, pub broadcast_code: Vec::<u16>, pub mse: u8, pub big_sync_timeout: u16, pub bis: Vec::<u8>, }
impl LeBigCreateSyncData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeBigCreateSync".to_string(),    field: "big_handle".to_string(),    wanted: 4,    got: bytes.len()});}let big_handle = u8::from_le_bytes([bytes[3]]);if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeBigCreateSync".to_string(),    field: "sync_handle".to_string(),    wanted: 6,    got: bytes.len()});}let sync_handle = u16::from_le_bytes([bytes[4],bytes[5]]);let sync_handle = sync_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeBigCreateSync".to_string(),    field: "encryption".to_string(),    wanted: 7,    got: bytes.len()});}let encryption = u8::from_le_bytes([bytes[6]]);let encryption = Enable::from_u8(encryption).unwrap();let rem_ = (bytes.len() - 7) % 2;if rem_ != 0 { return Err(Error::InvalidLengthError{    obj: "LeBigCreateSync".to_string(),    field: "broadcast_code".to_string(),    wanted: bytes.len() + rem_,    got: bytes.len()});}let broadcast_code: Vec::<u16> = bytes[7..].to_vec().chunks_exact(2).into_iter().map(|i| u16::from_le_bytes([i[0], i[1]])).collect();let mse = u8::from_le_bytes([bytes[0]]);let mse = mse & 0x1f;if bytes.len() < 2 { return Err(Error::InvalidLengthError{    obj: "LeBigCreateSync".to_string(),    field: "big_sync_timeout".to_string(),    wanted: 2,    got: bytes.len()});}let big_sync_timeout = u16::from_le_bytes([bytes[0],bytes[1]]);if bytes.len() < 1 { return Err(Error::InvalidLengthError{    obj: "LeBigCreateSync".to_string(),    field: "bis_count".to_string(),    wanted: 1,    got: bytes.len()});}let bis_count = u8::from_le_bytes([bytes[0]]);let want_ = 0 + ((bis_count as usize) * 1);if bytes.len() < want_ { return Err(Error::InvalidLengthError{    obj: "LeBigCreateSync".to_string(),    field: "bis".to_string(),    wanted: want_,    got: bytes.len()});}let bis: Vec::<u8> = bytes[0..0 + ((bis_count as usize) * 1)].to_vec().chunks_exact(1).into_iter().map(|i| u8::from_le_bytes([i[0]])).collect();Ok(Self {big_handle, sync_handle, encryption, broadcast_code, mse, big_sync_timeout, bis, })
}
fn write_to(&self, buffer: &mut BytesMut) {let big_handle = self.big_handle;buffer[3..4].copy_from_slice(&big_handle.to_le_bytes()[0..1]);let sync_handle = self.sync_handle;let sync_handle = sync_handle & 0xfff;buffer[4..6].copy_from_slice(&sync_handle.to_le_bytes()[0..2]);let encryption = self.encryption.to_u8().unwrap();buffer[6..7].copy_from_slice(&encryption.to_le_bytes()[0..1]);for (i, e) in self.broadcast_code.iter().enumerate() {buffer[7+i..7+i+2].copy_from_slice(&e.to_le_bytes())}let mse = self.mse;let mse = mse & 0x1f;buffer[0..1].copy_from_slice(&mse.to_le_bytes()[0..1]);let big_sync_timeout = self.big_sync_timeout;buffer[0..2].copy_from_slice(&big_sync_timeout.to_le_bytes()[0..2]);buffer[0..1].copy_from_slice(&(self.bis.len() as u8).to_le_bytes());for (i, e) in self.bis.iter().enumerate() {buffer[0+i..0+i+1].copy_from_slice(&e.to_le_bytes())}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;let ret = ret + (self.broadcast_code.len() * ((/* Bits: */ 16 + /* Dynamic: */ 0) / 8));let ret = ret + 4;let ret = ret + (self.bis.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8));ret}
}
impl CommandExpectations for LeBigCreateSyncPacket { type ResponseType = LeBigCreateSyncStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeBigCreateSyncStatusPacket::new(pkt.event.clone()) }}impl Packet for LeBigCreateSyncPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeBigCreateSyncPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_iso_command = match &command.child {CommandDataChild::LeIsoCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeIsoCommand"),};let le_big_create_sync = match &le_iso_command.child {LeIsoCommandDataChild::LeBigCreateSync(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBigCreateSync"),};Self {command,le_iso_command,le_big_create_sync,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_big_handle(&self) -> u8{ self.le_big_create_sync.as_ref().big_handle}
pub fn get_sync_handle(&self) -> u16{ self.le_big_create_sync.as_ref().sync_handle}
pub fn get_encryption(&self) -> Enable{ self.le_big_create_sync.as_ref().encryption}
pub fn get_broadcast_code(&self) -> &Vec::<u16>{ &self.le_big_create_sync.as_ref().broadcast_code}
pub fn get_mse(&self) -> u8{ self.le_big_create_sync.as_ref().mse}
pub fn get_big_sync_timeout(&self) -> u16{ self.le_big_create_sync.as_ref().big_sync_timeout}
pub fn get_bis(&self) -> &Vec::<u8>{ &self.le_big_create_sync.as_ref().bis}
}
impl Into<CommandPacket> for LeBigCreateSyncPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeIsoCommandPacket> for LeBigCreateSyncPacket { fn into(self) -> LeIsoCommandPacket {LeIsoCommandPacket::new(self.command) }}
impl CommandExpectations for LeBigCreateSyncBuilder { type ResponseType = LeBigCreateSyncStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeBigCreateSyncStatusPacket::new(pkt.event.clone()) }}impl LeBigCreateSyncBuilder {pub fn build(self) -> LeBigCreateSyncPacket {let le_big_create_sync= Arc::new(LeBigCreateSyncData {big_handle: self.big_handle, sync_handle: self.sync_handle, encryption: self.encryption, broadcast_code: self.broadcast_code, mse: self.mse, big_sync_timeout: self.big_sync_timeout, bis: self.bis, });let le_iso_command= Arc::new(LeIsoCommandData {child: LeIsoCommandDataChild::LeBigCreateSync(le_big_create_sync),});let command= Arc::new(CommandData {op_code: OpCode::LeBigCreateSync, child: CommandDataChild::LeIsoCommand(le_iso_command),});LeBigCreateSyncPacket::new(command)}
}
impl Into<CommandPacket> for LeBigCreateSyncBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeIsoCommandPacket> for LeBigCreateSyncBuilder { fn into(self) -> LeIsoCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeBigCreateSyncStatusData {}
#[derive(Debug, Clone)] pub struct LeBigCreateSyncStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,le_big_create_sync_status: Arc<LeBigCreateSyncStatusData>,}
#[derive(Debug)] pub struct LeBigCreateSyncStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl LeBigCreateSyncStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeBigCreateSyncStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeBigCreateSyncStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let le_big_create_sync_status = match &command_status.child {CommandStatusDataChild::LeBigCreateSyncStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBigCreateSyncStatus"),};Self {event,command_status,le_big_create_sync_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for LeBigCreateSyncStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for LeBigCreateSyncStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl LeBigCreateSyncStatusBuilder {pub fn build(self) -> LeBigCreateSyncStatusPacket {let le_big_create_sync_status= Arc::new(LeBigCreateSyncStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeBigCreateSync, child: CommandStatusDataChild::LeBigCreateSyncStatus(le_big_create_sync_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});LeBigCreateSyncStatusPacket::new(event)}
}
impl Into<EventPacket> for LeBigCreateSyncStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for LeBigCreateSyncStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct LeBigTerminateSyncData {big_handle: u8, }
#[derive(Debug, Clone)] pub struct LeBigTerminateSyncPacket {command: Arc<CommandData>,le_iso_command: Arc<LeIsoCommandData>,le_big_terminate_sync: Arc<LeBigTerminateSyncData>,}
#[derive(Debug)] pub struct LeBigTerminateSyncBuilder {pub big_handle: u8, }
impl LeBigTerminateSyncData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeBigTerminateSync".to_string(),    field: "big_handle".to_string(),    wanted: 4,    got: bytes.len()});}let big_handle = u8::from_le_bytes([bytes[3]]);Ok(Self {big_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let big_handle = self.big_handle;buffer[3..4].copy_from_slice(&big_handle.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for LeBigTerminateSyncPacket { type ResponseType = LeBigTerminateSyncCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeBigTerminateSyncCompletePacket::new(pkt.event.clone()) }}impl Packet for LeBigTerminateSyncPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeBigTerminateSyncPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_iso_command = match &command.child {CommandDataChild::LeIsoCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeIsoCommand"),};let le_big_terminate_sync = match &le_iso_command.child {LeIsoCommandDataChild::LeBigTerminateSync(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBigTerminateSync"),};Self {command,le_iso_command,le_big_terminate_sync,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_big_handle(&self) -> u8{ self.le_big_terminate_sync.as_ref().big_handle}
}
impl Into<CommandPacket> for LeBigTerminateSyncPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeIsoCommandPacket> for LeBigTerminateSyncPacket { fn into(self) -> LeIsoCommandPacket {LeIsoCommandPacket::new(self.command) }}
impl CommandExpectations for LeBigTerminateSyncBuilder { type ResponseType = LeBigTerminateSyncCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeBigTerminateSyncCompletePacket::new(pkt.event.clone()) }}impl LeBigTerminateSyncBuilder {pub fn build(self) -> LeBigTerminateSyncPacket {let le_big_terminate_sync= Arc::new(LeBigTerminateSyncData {big_handle: self.big_handle, });let le_iso_command= Arc::new(LeIsoCommandData {child: LeIsoCommandDataChild::LeBigTerminateSync(le_big_terminate_sync),});let command= Arc::new(CommandData {op_code: OpCode::LeBigTerminateSync, child: CommandDataChild::LeIsoCommand(le_iso_command),});LeBigTerminateSyncPacket::new(command)}
}
impl Into<CommandPacket> for LeBigTerminateSyncBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeIsoCommandPacket> for LeBigTerminateSyncBuilder { fn into(self) -> LeIsoCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeBigTerminateSyncCompleteData {status: ErrorCode, big_handle: u8, }
#[derive(Debug, Clone)] pub struct LeBigTerminateSyncCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_big_terminate_sync_complete: Arc<LeBigTerminateSyncCompleteData>,}
#[derive(Debug)] pub struct LeBigTerminateSyncCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub big_handle: u8, }
impl LeBigTerminateSyncCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeBigTerminateSyncComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeBigTerminateSyncComplete".to_string(),    field: "big_handle".to_string(),    wanted: 7,    got: bytes.len()});}let big_handle = u8::from_le_bytes([bytes[6]]);Ok(Self {status, big_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let big_handle = self.big_handle;buffer[6..7].copy_from_slice(&big_handle.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for LeBigTerminateSyncCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeBigTerminateSyncCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_big_terminate_sync_complete = match &command_complete.child {CommandCompleteDataChild::LeBigTerminateSyncComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBigTerminateSyncComplete"),};Self {event,command_complete,le_big_terminate_sync_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_big_terminate_sync_complete.as_ref().status}
pub fn get_big_handle(&self) -> u8{ self.le_big_terminate_sync_complete.as_ref().big_handle}
}
impl Into<EventPacket> for LeBigTerminateSyncCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeBigTerminateSyncCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeBigTerminateSyncCompleteBuilder {pub fn build(self) -> LeBigTerminateSyncCompletePacket {let le_big_terminate_sync_complete= Arc::new(LeBigTerminateSyncCompleteData {status: self.status, big_handle: self.big_handle, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeBigTerminateSync, child: CommandCompleteDataChild::LeBigTerminateSyncComplete(le_big_terminate_sync_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeBigTerminateSyncCompletePacket::new(event)}
}
impl Into<EventPacket> for LeBigTerminateSyncCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeBigTerminateSyncCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeRequestPeerScaData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct LeRequestPeerScaPacket {command: Arc<CommandData>,le_request_peer_sca: Arc<LeRequestPeerScaData>,}
#[derive(Debug)] pub struct LeRequestPeerScaBuilder {pub connection_handle: u16, }
impl LeRequestPeerScaData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeRequestPeerSca".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for LeRequestPeerScaPacket { type ResponseType = LeRequestPeerScaStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeRequestPeerScaStatusPacket::new(pkt.event.clone()) }}impl Packet for LeRequestPeerScaPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeRequestPeerScaPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_request_peer_sca = match &command.child {CommandDataChild::LeRequestPeerSca(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeRequestPeerSca"),};Self {command,le_request_peer_sca,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_request_peer_sca.as_ref().connection_handle}
}
impl Into<CommandPacket> for LeRequestPeerScaPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeRequestPeerScaBuilder { type ResponseType = LeRequestPeerScaStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeRequestPeerScaStatusPacket::new(pkt.event.clone()) }}impl LeRequestPeerScaBuilder {pub fn build(self) -> LeRequestPeerScaPacket {let le_request_peer_sca= Arc::new(LeRequestPeerScaData {connection_handle: self.connection_handle, });let command= Arc::new(CommandData {op_code: OpCode::LeRequestPeerSca, child: CommandDataChild::LeRequestPeerSca(le_request_peer_sca),});LeRequestPeerScaPacket::new(command)}
}
impl Into<CommandPacket> for LeRequestPeerScaBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LeRequestPeerScaStatusData {}
#[derive(Debug, Clone)] pub struct LeRequestPeerScaStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,le_request_peer_sca_status: Arc<LeRequestPeerScaStatusData>,}
#[derive(Debug)] pub struct LeRequestPeerScaStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl LeRequestPeerScaStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeRequestPeerScaStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeRequestPeerScaStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let le_request_peer_sca_status = match &command_status.child {CommandStatusDataChild::LeRequestPeerScaStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeRequestPeerScaStatus"),};Self {event,command_status,le_request_peer_sca_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for LeRequestPeerScaStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for LeRequestPeerScaStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl LeRequestPeerScaStatusBuilder {pub fn build(self) -> LeRequestPeerScaStatusPacket {let le_request_peer_sca_status= Arc::new(LeRequestPeerScaStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeRequestPeerSca, child: CommandStatusDataChild::LeRequestPeerScaStatus(le_request_peer_sca_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});LeRequestPeerScaStatusPacket::new(event)}
}
impl Into<EventPacket> for LeRequestPeerScaStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for LeRequestPeerScaStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct LeSetupIsoDataPathData {connection_handle: u16, data_path_direction: DataPathDirection, data_path_id: u8, codec_id: u64, controller_delay: u32, codec_configuration: Vec::<u8>, }
#[derive(Debug, Clone)] pub struct LeSetupIsoDataPathPacket {command: Arc<CommandData>,le_iso_command: Arc<LeIsoCommandData>,le_setup_iso_data_path: Arc<LeSetupIsoDataPathData>,}
#[derive(Debug)] pub struct LeSetupIsoDataPathBuilder {pub connection_handle: u16, pub data_path_direction: DataPathDirection, pub data_path_id: u8, pub codec_id: u64, pub controller_delay: u32, pub codec_configuration: Vec::<u8>, }
impl LeSetupIsoDataPathData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeSetupIsoDataPath".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetupIsoDataPath".to_string(),    field: "data_path_direction".to_string(),    wanted: 6,    got: bytes.len()});}let data_path_direction = u8::from_le_bytes([bytes[5]]);let data_path_direction = DataPathDirection::from_u8(data_path_direction).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeSetupIsoDataPath".to_string(),    field: "data_path_id".to_string(),    wanted: 7,    got: bytes.len()});}let data_path_id = u8::from_le_bytes([bytes[6]]);if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "LeSetupIsoDataPath".to_string(),    field: "codec_id".to_string(),    wanted: 12,    got: bytes.len()});}let codec_id = u64::from_le_bytes([bytes[7],bytes[8],bytes[9],bytes[10],bytes[11],0,0,0]);let codec_id = codec_id & 0xffffffffff;if bytes.len() < 15 { return Err(Error::InvalidLengthError{    obj: "LeSetupIsoDataPath".to_string(),    field: "controller_delay".to_string(),    wanted: 15,    got: bytes.len()});}let controller_delay = u32::from_le_bytes([bytes[12],bytes[13],bytes[14],0]);let controller_delay = controller_delay & 0xffffff;if bytes.len() < 16 { return Err(Error::InvalidLengthError{    obj: "LeSetupIsoDataPath".to_string(),    field: "codec_configuration_count".to_string(),    wanted: 16,    got: bytes.len()});}let codec_configuration_count = u8::from_le_bytes([bytes[15]]);let want_ = 16 + ((codec_configuration_count as usize) * 1);if bytes.len() < want_ { return Err(Error::InvalidLengthError{    obj: "LeSetupIsoDataPath".to_string(),    field: "codec_configuration".to_string(),    wanted: want_,    got: bytes.len()});}let codec_configuration: Vec::<u8> = bytes[16..16 + ((codec_configuration_count as usize) * 1)].to_vec().chunks_exact(1).into_iter().map(|i| u8::from_le_bytes([i[0]])).collect();Ok(Self {connection_handle, data_path_direction, data_path_id, codec_id, controller_delay, codec_configuration, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let data_path_direction = self.data_path_direction.to_u8().unwrap();buffer[5..6].copy_from_slice(&data_path_direction.to_le_bytes()[0..1]);let data_path_id = self.data_path_id;buffer[6..7].copy_from_slice(&data_path_id.to_le_bytes()[0..1]);let codec_id = self.codec_id;let codec_id = codec_id & 0xffffffffff;buffer[7..12].copy_from_slice(&codec_id.to_le_bytes()[0..5]);let controller_delay = self.controller_delay;let controller_delay = controller_delay & 0xffffff;buffer[12..15].copy_from_slice(&controller_delay.to_le_bytes()[0..3]);buffer[15..16].copy_from_slice(&(self.codec_configuration.len() as u8).to_le_bytes());for (i, e) in self.codec_configuration.iter().enumerate() {buffer[16+i..16+i+1].copy_from_slice(&e.to_le_bytes())}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 13;let ret = ret + (self.codec_configuration.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8));ret}
}
impl CommandExpectations for LeSetupIsoDataPathPacket { type ResponseType = LeSetupIsoDataPathCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetupIsoDataPathCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetupIsoDataPathPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetupIsoDataPathPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_iso_command = match &command.child {CommandDataChild::LeIsoCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeIsoCommand"),};let le_setup_iso_data_path = match &le_iso_command.child {LeIsoCommandDataChild::LeSetupIsoDataPath(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetupIsoDataPath"),};Self {command,le_iso_command,le_setup_iso_data_path,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_setup_iso_data_path.as_ref().connection_handle}
pub fn get_data_path_direction(&self) -> DataPathDirection{ self.le_setup_iso_data_path.as_ref().data_path_direction}
pub fn get_data_path_id(&self) -> u8{ self.le_setup_iso_data_path.as_ref().data_path_id}
pub fn get_codec_id(&self) -> u64{ self.le_setup_iso_data_path.as_ref().codec_id}
pub fn get_controller_delay(&self) -> u32{ self.le_setup_iso_data_path.as_ref().controller_delay}
pub fn get_codec_configuration(&self) -> &Vec::<u8>{ &self.le_setup_iso_data_path.as_ref().codec_configuration}
}
impl Into<CommandPacket> for LeSetupIsoDataPathPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeIsoCommandPacket> for LeSetupIsoDataPathPacket { fn into(self) -> LeIsoCommandPacket {LeIsoCommandPacket::new(self.command) }}
impl CommandExpectations for LeSetupIsoDataPathBuilder { type ResponseType = LeSetupIsoDataPathCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetupIsoDataPathCompletePacket::new(pkt.event.clone()) }}impl LeSetupIsoDataPathBuilder {pub fn build(self) -> LeSetupIsoDataPathPacket {let le_setup_iso_data_path= Arc::new(LeSetupIsoDataPathData {connection_handle: self.connection_handle, data_path_direction: self.data_path_direction, data_path_id: self.data_path_id, codec_id: self.codec_id, controller_delay: self.controller_delay, codec_configuration: self.codec_configuration, });let le_iso_command= Arc::new(LeIsoCommandData {child: LeIsoCommandDataChild::LeSetupIsoDataPath(le_setup_iso_data_path),});let command= Arc::new(CommandData {op_code: OpCode::LeSetupIsoDataPath, child: CommandDataChild::LeIsoCommand(le_iso_command),});LeSetupIsoDataPathPacket::new(command)}
}
impl Into<CommandPacket> for LeSetupIsoDataPathBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeIsoCommandPacket> for LeSetupIsoDataPathBuilder { fn into(self) -> LeIsoCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetupIsoDataPathCompleteData {status: ErrorCode, connection_handle: u16, }
#[derive(Debug, Clone)] pub struct LeSetupIsoDataPathCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_setup_iso_data_path_complete: Arc<LeSetupIsoDataPathCompleteData>,}
#[derive(Debug)] pub struct LeSetupIsoDataPathCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, }
impl LeSetupIsoDataPathCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetupIsoDataPathComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeSetupIsoDataPathComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;Ok(Self {status, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for LeSetupIsoDataPathCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetupIsoDataPathCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_setup_iso_data_path_complete = match &command_complete.child {CommandCompleteDataChild::LeSetupIsoDataPathComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetupIsoDataPathComplete"),};Self {event,command_complete,le_setup_iso_data_path_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_setup_iso_data_path_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_setup_iso_data_path_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for LeSetupIsoDataPathCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetupIsoDataPathCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetupIsoDataPathCompleteBuilder {pub fn build(self) -> LeSetupIsoDataPathCompletePacket {let le_setup_iso_data_path_complete= Arc::new(LeSetupIsoDataPathCompleteData {status: self.status, connection_handle: self.connection_handle, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetupIsoDataPath, child: CommandCompleteDataChild::LeSetupIsoDataPathComplete(le_setup_iso_data_path_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetupIsoDataPathCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetupIsoDataPathCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetupIsoDataPathCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeRemoveIsoDataPathData {connection_handle: u16, data_path_direction: DataPathDirection, }
#[derive(Debug, Clone)] pub struct LeRemoveIsoDataPathPacket {command: Arc<CommandData>,le_iso_command: Arc<LeIsoCommandData>,le_remove_iso_data_path: Arc<LeRemoveIsoDataPathData>,}
#[derive(Debug)] pub struct LeRemoveIsoDataPathBuilder {pub connection_handle: u16, pub data_path_direction: DataPathDirection, }
impl LeRemoveIsoDataPathData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeRemoveIsoDataPath".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeRemoveIsoDataPath".to_string(),    field: "data_path_direction".to_string(),    wanted: 6,    got: bytes.len()});}let data_path_direction = u8::from_le_bytes([bytes[5]]);let data_path_direction = DataPathDirection::from_u8(data_path_direction).unwrap();Ok(Self {connection_handle, data_path_direction, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let data_path_direction = self.data_path_direction.to_u8().unwrap();buffer[5..6].copy_from_slice(&data_path_direction.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl CommandExpectations for LeRemoveIsoDataPathPacket { type ResponseType = LeRemoveIsoDataPathCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeRemoveIsoDataPathCompletePacket::new(pkt.event.clone()) }}impl Packet for LeRemoveIsoDataPathPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeRemoveIsoDataPathPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_iso_command = match &command.child {CommandDataChild::LeIsoCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeIsoCommand"),};let le_remove_iso_data_path = match &le_iso_command.child {LeIsoCommandDataChild::LeRemoveIsoDataPath(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeRemoveIsoDataPath"),};Self {command,le_iso_command,le_remove_iso_data_path,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_remove_iso_data_path.as_ref().connection_handle}
pub fn get_data_path_direction(&self) -> DataPathDirection{ self.le_remove_iso_data_path.as_ref().data_path_direction}
}
impl Into<CommandPacket> for LeRemoveIsoDataPathPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeIsoCommandPacket> for LeRemoveIsoDataPathPacket { fn into(self) -> LeIsoCommandPacket {LeIsoCommandPacket::new(self.command) }}
impl CommandExpectations for LeRemoveIsoDataPathBuilder { type ResponseType = LeRemoveIsoDataPathCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeRemoveIsoDataPathCompletePacket::new(pkt.event.clone()) }}impl LeRemoveIsoDataPathBuilder {pub fn build(self) -> LeRemoveIsoDataPathPacket {let le_remove_iso_data_path= Arc::new(LeRemoveIsoDataPathData {connection_handle: self.connection_handle, data_path_direction: self.data_path_direction, });let le_iso_command= Arc::new(LeIsoCommandData {child: LeIsoCommandDataChild::LeRemoveIsoDataPath(le_remove_iso_data_path),});let command= Arc::new(CommandData {op_code: OpCode::LeRemoveIsoDataPath, child: CommandDataChild::LeIsoCommand(le_iso_command),});LeRemoveIsoDataPathPacket::new(command)}
}
impl Into<CommandPacket> for LeRemoveIsoDataPathBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeIsoCommandPacket> for LeRemoveIsoDataPathBuilder { fn into(self) -> LeIsoCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeRemoveIsoDataPathCompleteData {status: ErrorCode, connection_handle: u16, }
#[derive(Debug, Clone)] pub struct LeRemoveIsoDataPathCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_remove_iso_data_path_complete: Arc<LeRemoveIsoDataPathCompleteData>,}
#[derive(Debug)] pub struct LeRemoveIsoDataPathCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, }
impl LeRemoveIsoDataPathCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeRemoveIsoDataPathComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeRemoveIsoDataPathComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;Ok(Self {status, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for LeRemoveIsoDataPathCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeRemoveIsoDataPathCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_remove_iso_data_path_complete = match &command_complete.child {CommandCompleteDataChild::LeRemoveIsoDataPathComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeRemoveIsoDataPathComplete"),};Self {event,command_complete,le_remove_iso_data_path_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_remove_iso_data_path_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_remove_iso_data_path_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for LeRemoveIsoDataPathCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeRemoveIsoDataPathCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeRemoveIsoDataPathCompleteBuilder {pub fn build(self) -> LeRemoveIsoDataPathCompletePacket {let le_remove_iso_data_path_complete= Arc::new(LeRemoveIsoDataPathCompleteData {status: self.status, connection_handle: self.connection_handle, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeRemoveIsoDataPath, child: CommandCompleteDataChild::LeRemoveIsoDataPathComplete(le_remove_iso_data_path_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeRemoveIsoDataPathCompletePacket::new(event)}
}
impl Into<EventPacket> for LeRemoveIsoDataPathCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeRemoveIsoDataPathCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetHostFeatureData {bit_number: u8, bit_value: Enable, }
#[derive(Debug, Clone)] pub struct LeSetHostFeaturePacket {command: Arc<CommandData>,le_set_host_feature: Arc<LeSetHostFeatureData>,}
#[derive(Debug)] pub struct LeSetHostFeatureBuilder {pub bit_number: u8, pub bit_value: Enable, }
impl LeSetHostFeatureData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeSetHostFeature".to_string(),    field: "bit_number".to_string(),    wanted: 4,    got: bytes.len()});}let bit_number = u8::from_le_bytes([bytes[3]]);if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeSetHostFeature".to_string(),    field: "bit_value".to_string(),    wanted: 5,    got: bytes.len()});}let bit_value = u8::from_le_bytes([bytes[4]]);let bit_value = Enable::from_u8(bit_value).unwrap();Ok(Self {bit_number, bit_value, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bit_number = self.bit_number;buffer[3..4].copy_from_slice(&bit_number.to_le_bytes()[0..1]);let bit_value = self.bit_value.to_u8().unwrap();buffer[4..5].copy_from_slice(&bit_value.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for LeSetHostFeaturePacket { type ResponseType = LeSetHostFeatureCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetHostFeatureCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetHostFeaturePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetHostFeaturePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_set_host_feature = match &command.child {CommandDataChild::LeSetHostFeature(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetHostFeature"),};Self {command,le_set_host_feature,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bit_number(&self) -> u8{ self.le_set_host_feature.as_ref().bit_number}
pub fn get_bit_value(&self) -> Enable{ self.le_set_host_feature.as_ref().bit_value}
}
impl Into<CommandPacket> for LeSetHostFeaturePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeSetHostFeatureBuilder { type ResponseType = LeSetHostFeatureCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetHostFeatureCompletePacket::new(pkt.event.clone()) }}impl LeSetHostFeatureBuilder {pub fn build(self) -> LeSetHostFeaturePacket {let le_set_host_feature= Arc::new(LeSetHostFeatureData {bit_number: self.bit_number, bit_value: self.bit_value, });let command= Arc::new(CommandData {op_code: OpCode::LeSetHostFeature, child: CommandDataChild::LeSetHostFeature(le_set_host_feature),});LeSetHostFeaturePacket::new(command)}
}
impl Into<CommandPacket> for LeSetHostFeatureBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetHostFeatureCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeSetHostFeatureCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_host_feature_complete: Arc<LeSetHostFeatureCompleteData>,}
#[derive(Debug)] pub struct LeSetHostFeatureCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeSetHostFeatureCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetHostFeatureComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeSetHostFeatureCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetHostFeatureCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_host_feature_complete = match &command_complete.child {CommandCompleteDataChild::LeSetHostFeatureComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetHostFeatureComplete"),};Self {event,command_complete,le_set_host_feature_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_host_feature_complete.as_ref().status}
}
impl Into<EventPacket> for LeSetHostFeatureCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetHostFeatureCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetHostFeatureCompleteBuilder {pub fn build(self) -> LeSetHostFeatureCompletePacket {let le_set_host_feature_complete= Arc::new(LeSetHostFeatureCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetHostFeature, child: CommandCompleteDataChild::LeSetHostFeatureComplete(le_set_host_feature_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetHostFeatureCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetHostFeatureCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetHostFeatureCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeReadIsoLinkQualityData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct LeReadIsoLinkQualityPacket {command: Arc<CommandData>,le_iso_command: Arc<LeIsoCommandData>,le_read_iso_link_quality: Arc<LeReadIsoLinkQualityData>,}
#[derive(Debug)] pub struct LeReadIsoLinkQualityBuilder {pub connection_handle: u16, }
impl LeReadIsoLinkQualityData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeReadIsoLinkQuality".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl CommandExpectations for LeReadIsoLinkQualityPacket { type ResponseType = LeReadIsoLinkQualityCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadIsoLinkQualityCompletePacket::new(pkt.event.clone()) }}impl Packet for LeReadIsoLinkQualityPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadIsoLinkQualityPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_iso_command = match &command.child {CommandDataChild::LeIsoCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeIsoCommand"),};let le_read_iso_link_quality = match &le_iso_command.child {LeIsoCommandDataChild::LeReadIsoLinkQuality(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadIsoLinkQuality"),};Self {command,le_iso_command,le_read_iso_link_quality,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_read_iso_link_quality.as_ref().connection_handle}
}
impl Into<CommandPacket> for LeReadIsoLinkQualityPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeIsoCommandPacket> for LeReadIsoLinkQualityPacket { fn into(self) -> LeIsoCommandPacket {LeIsoCommandPacket::new(self.command) }}
impl CommandExpectations for LeReadIsoLinkQualityBuilder { type ResponseType = LeReadIsoLinkQualityCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadIsoLinkQualityCompletePacket::new(pkt.event.clone()) }}impl LeReadIsoLinkQualityBuilder {pub fn build(self) -> LeReadIsoLinkQualityPacket {let le_read_iso_link_quality= Arc::new(LeReadIsoLinkQualityData {connection_handle: self.connection_handle, });let le_iso_command= Arc::new(LeIsoCommandData {child: LeIsoCommandDataChild::LeReadIsoLinkQuality(le_read_iso_link_quality),});let command= Arc::new(CommandData {op_code: OpCode::LeReadIsoLinkQuality, child: CommandDataChild::LeIsoCommand(le_iso_command),});LeReadIsoLinkQualityPacket::new(command)}
}
impl Into<CommandPacket> for LeReadIsoLinkQualityBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeIsoCommandPacket> for LeReadIsoLinkQualityBuilder { fn into(self) -> LeIsoCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeReadIsoLinkQualityCompleteData {status: ErrorCode, connection_handle: u16, tx_unacked_packets: u32, tx_flushed_packets: u32, tx_last_subevent_packets: u32, retransmitted_packets: u32, crc_error_packets: u32, rx_unreceived_packets: u32, duplicate_packets: u32, }
#[derive(Debug, Clone)] pub struct LeReadIsoLinkQualityCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_read_iso_link_quality_complete: Arc<LeReadIsoLinkQualityCompleteData>,}
#[derive(Debug)] pub struct LeReadIsoLinkQualityCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, pub tx_unacked_packets: u32, pub tx_flushed_packets: u32, pub tx_last_subevent_packets: u32, pub retransmitted_packets: u32, pub crc_error_packets: u32, pub rx_unreceived_packets: u32, pub duplicate_packets: u32, }
impl LeReadIsoLinkQualityCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeReadIsoLinkQualityComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeReadIsoLinkQualityComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "LeReadIsoLinkQualityComplete".to_string(),    field: "tx_unacked_packets".to_string(),    wanted: 12,    got: bytes.len()});}let tx_unacked_packets = u32::from_le_bytes([bytes[8],bytes[9],bytes[10],bytes[11]]);if bytes.len() < 16 { return Err(Error::InvalidLengthError{    obj: "LeReadIsoLinkQualityComplete".to_string(),    field: "tx_flushed_packets".to_string(),    wanted: 16,    got: bytes.len()});}let tx_flushed_packets = u32::from_le_bytes([bytes[12],bytes[13],bytes[14],bytes[15]]);if bytes.len() < 20 { return Err(Error::InvalidLengthError{    obj: "LeReadIsoLinkQualityComplete".to_string(),    field: "tx_last_subevent_packets".to_string(),    wanted: 20,    got: bytes.len()});}let tx_last_subevent_packets = u32::from_le_bytes([bytes[16],bytes[17],bytes[18],bytes[19]]);if bytes.len() < 24 { return Err(Error::InvalidLengthError{    obj: "LeReadIsoLinkQualityComplete".to_string(),    field: "retransmitted_packets".to_string(),    wanted: 24,    got: bytes.len()});}let retransmitted_packets = u32::from_le_bytes([bytes[20],bytes[21],bytes[22],bytes[23]]);if bytes.len() < 28 { return Err(Error::InvalidLengthError{    obj: "LeReadIsoLinkQualityComplete".to_string(),    field: "crc_error_packets".to_string(),    wanted: 28,    got: bytes.len()});}let crc_error_packets = u32::from_le_bytes([bytes[24],bytes[25],bytes[26],bytes[27]]);if bytes.len() < 32 { return Err(Error::InvalidLengthError{    obj: "LeReadIsoLinkQualityComplete".to_string(),    field: "rx_unreceived_packets".to_string(),    wanted: 32,    got: bytes.len()});}let rx_unreceived_packets = u32::from_le_bytes([bytes[28],bytes[29],bytes[30],bytes[31]]);if bytes.len() < 36 { return Err(Error::InvalidLengthError{    obj: "LeReadIsoLinkQualityComplete".to_string(),    field: "duplicate_packets".to_string(),    wanted: 36,    got: bytes.len()});}let duplicate_packets = u32::from_le_bytes([bytes[32],bytes[33],bytes[34],bytes[35]]);Ok(Self {status, connection_handle, tx_unacked_packets, tx_flushed_packets, tx_last_subevent_packets, retransmitted_packets, crc_error_packets, rx_unreceived_packets, duplicate_packets, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let tx_unacked_packets = self.tx_unacked_packets;buffer[8..12].copy_from_slice(&tx_unacked_packets.to_le_bytes()[0..4]);let tx_flushed_packets = self.tx_flushed_packets;buffer[12..16].copy_from_slice(&tx_flushed_packets.to_le_bytes()[0..4]);let tx_last_subevent_packets = self.tx_last_subevent_packets;buffer[16..20].copy_from_slice(&tx_last_subevent_packets.to_le_bytes()[0..4]);let retransmitted_packets = self.retransmitted_packets;buffer[20..24].copy_from_slice(&retransmitted_packets.to_le_bytes()[0..4]);let crc_error_packets = self.crc_error_packets;buffer[24..28].copy_from_slice(&crc_error_packets.to_le_bytes()[0..4]);let rx_unreceived_packets = self.rx_unreceived_packets;buffer[28..32].copy_from_slice(&rx_unreceived_packets.to_le_bytes()[0..4]);let duplicate_packets = self.duplicate_packets;buffer[32..36].copy_from_slice(&duplicate_packets.to_le_bytes()[0..4]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 31;ret}
}
impl Packet for LeReadIsoLinkQualityCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadIsoLinkQualityCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_read_iso_link_quality_complete = match &command_complete.child {CommandCompleteDataChild::LeReadIsoLinkQualityComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadIsoLinkQualityComplete"),};Self {event,command_complete,le_read_iso_link_quality_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_read_iso_link_quality_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_read_iso_link_quality_complete.as_ref().connection_handle}
pub fn get_tx_unacked_packets(&self) -> u32{ self.le_read_iso_link_quality_complete.as_ref().tx_unacked_packets}
pub fn get_tx_flushed_packets(&self) -> u32{ self.le_read_iso_link_quality_complete.as_ref().tx_flushed_packets}
pub fn get_tx_last_subevent_packets(&self) -> u32{ self.le_read_iso_link_quality_complete.as_ref().tx_last_subevent_packets}
pub fn get_retransmitted_packets(&self) -> u32{ self.le_read_iso_link_quality_complete.as_ref().retransmitted_packets}
pub fn get_crc_error_packets(&self) -> u32{ self.le_read_iso_link_quality_complete.as_ref().crc_error_packets}
pub fn get_rx_unreceived_packets(&self) -> u32{ self.le_read_iso_link_quality_complete.as_ref().rx_unreceived_packets}
pub fn get_duplicate_packets(&self) -> u32{ self.le_read_iso_link_quality_complete.as_ref().duplicate_packets}
}
impl Into<EventPacket> for LeReadIsoLinkQualityCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeReadIsoLinkQualityCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeReadIsoLinkQualityCompleteBuilder {pub fn build(self) -> LeReadIsoLinkQualityCompletePacket {let le_read_iso_link_quality_complete= Arc::new(LeReadIsoLinkQualityCompleteData {status: self.status, connection_handle: self.connection_handle, tx_unacked_packets: self.tx_unacked_packets, tx_flushed_packets: self.tx_flushed_packets, tx_last_subevent_packets: self.tx_last_subevent_packets, retransmitted_packets: self.retransmitted_packets, crc_error_packets: self.crc_error_packets, rx_unreceived_packets: self.rx_unreceived_packets, duplicate_packets: self.duplicate_packets, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeReadIsoLinkQuality, child: CommandCompleteDataChild::LeReadIsoLinkQualityComplete(le_read_iso_link_quality_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeReadIsoLinkQualityCompletePacket::new(event)}
}
impl Into<EventPacket> for LeReadIsoLinkQualityCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeReadIsoLinkQualityCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeEnhancedReadTransmitPowerLevelData {connection_handle: u16, phy: u8, }
#[derive(Debug, Clone)] pub struct LeEnhancedReadTransmitPowerLevelPacket {command: Arc<CommandData>,le_enhanced_read_transmit_power_level: Arc<LeEnhancedReadTransmitPowerLevelData>,}
#[derive(Debug)] pub struct LeEnhancedReadTransmitPowerLevelBuilder {pub connection_handle: u16, pub phy: u8, }
impl LeEnhancedReadTransmitPowerLevelData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedReadTransmitPowerLevel".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedReadTransmitPowerLevel".to_string(),    field: "phy".to_string(),    wanted: 6,    got: bytes.len()});}let phy = u8::from_le_bytes([bytes[5]]);Ok(Self {connection_handle, phy, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let phy = self.phy;buffer[5..6].copy_from_slice(&phy.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl CommandExpectations for LeEnhancedReadTransmitPowerLevelPacket { type ResponseType = LeEnhancedReadTransmitPowerLevelCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeEnhancedReadTransmitPowerLevelCompletePacket::new(pkt.event.clone()) }}impl Packet for LeEnhancedReadTransmitPowerLevelPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeEnhancedReadTransmitPowerLevelPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_enhanced_read_transmit_power_level = match &command.child {CommandDataChild::LeEnhancedReadTransmitPowerLevel(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeEnhancedReadTransmitPowerLevel"),};Self {command,le_enhanced_read_transmit_power_level,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_enhanced_read_transmit_power_level.as_ref().connection_handle}
pub fn get_phy(&self) -> u8{ self.le_enhanced_read_transmit_power_level.as_ref().phy}
}
impl Into<CommandPacket> for LeEnhancedReadTransmitPowerLevelPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeEnhancedReadTransmitPowerLevelBuilder { type ResponseType = LeEnhancedReadTransmitPowerLevelCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeEnhancedReadTransmitPowerLevelCompletePacket::new(pkt.event.clone()) }}impl LeEnhancedReadTransmitPowerLevelBuilder {pub fn build(self) -> LeEnhancedReadTransmitPowerLevelPacket {let le_enhanced_read_transmit_power_level= Arc::new(LeEnhancedReadTransmitPowerLevelData {connection_handle: self.connection_handle, phy: self.phy, });let command= Arc::new(CommandData {op_code: OpCode::LeEnhancedReadTransmitPowerLevel, child: CommandDataChild::LeEnhancedReadTransmitPowerLevel(le_enhanced_read_transmit_power_level),});LeEnhancedReadTransmitPowerLevelPacket::new(command)}
}
impl Into<CommandPacket> for LeEnhancedReadTransmitPowerLevelBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LeEnhancedReadTransmitPowerLevelCompleteData {status: ErrorCode, connection_handle: u16, phy: PhyWithCodedSpecified, current_transmit_power_level: u8, max_transmit_power_level: u8, }
#[derive(Debug, Clone)] pub struct LeEnhancedReadTransmitPowerLevelCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_enhanced_read_transmit_power_level_complete: Arc<LeEnhancedReadTransmitPowerLevelCompleteData>,}
#[derive(Debug)] pub struct LeEnhancedReadTransmitPowerLevelCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, pub phy: PhyWithCodedSpecified, pub current_transmit_power_level: u8, pub max_transmit_power_level: u8, }
impl LeEnhancedReadTransmitPowerLevelCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedReadTransmitPowerLevelComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedReadTransmitPowerLevelComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedReadTransmitPowerLevelComplete".to_string(),    field: "phy".to_string(),    wanted: 9,    got: bytes.len()});}let phy = u8::from_le_bytes([bytes[8]]);let phy = PhyWithCodedSpecified::from_u8(phy).unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedReadTransmitPowerLevelComplete".to_string(),    field: "current_transmit_power_level".to_string(),    wanted: 10,    got: bytes.len()});}let current_transmit_power_level = u8::from_le_bytes([bytes[9]]);if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedReadTransmitPowerLevelComplete".to_string(),    field: "max_transmit_power_level".to_string(),    wanted: 11,    got: bytes.len()});}let max_transmit_power_level = u8::from_le_bytes([bytes[10]]);Ok(Self {status, connection_handle, phy, current_transmit_power_level, max_transmit_power_level, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let phy = self.phy.to_u8().unwrap();buffer[8..9].copy_from_slice(&phy.to_le_bytes()[0..1]);let current_transmit_power_level = self.current_transmit_power_level;buffer[9..10].copy_from_slice(&current_transmit_power_level.to_le_bytes()[0..1]);let max_transmit_power_level = self.max_transmit_power_level;buffer[10..11].copy_from_slice(&max_transmit_power_level.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl Packet for LeEnhancedReadTransmitPowerLevelCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeEnhancedReadTransmitPowerLevelCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_enhanced_read_transmit_power_level_complete = match &command_complete.child {CommandCompleteDataChild::LeEnhancedReadTransmitPowerLevelComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeEnhancedReadTransmitPowerLevelComplete"),};Self {event,command_complete,le_enhanced_read_transmit_power_level_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_enhanced_read_transmit_power_level_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_enhanced_read_transmit_power_level_complete.as_ref().connection_handle}
pub fn get_phy(&self) -> PhyWithCodedSpecified{ self.le_enhanced_read_transmit_power_level_complete.as_ref().phy}
pub fn get_current_transmit_power_level(&self) -> u8{ self.le_enhanced_read_transmit_power_level_complete.as_ref().current_transmit_power_level}
pub fn get_max_transmit_power_level(&self) -> u8{ self.le_enhanced_read_transmit_power_level_complete.as_ref().max_transmit_power_level}
}
impl Into<EventPacket> for LeEnhancedReadTransmitPowerLevelCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeEnhancedReadTransmitPowerLevelCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeEnhancedReadTransmitPowerLevelCompleteBuilder {pub fn build(self) -> LeEnhancedReadTransmitPowerLevelCompletePacket {let le_enhanced_read_transmit_power_level_complete= Arc::new(LeEnhancedReadTransmitPowerLevelCompleteData {status: self.status, connection_handle: self.connection_handle, phy: self.phy, current_transmit_power_level: self.current_transmit_power_level, max_transmit_power_level: self.max_transmit_power_level, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeEnhancedReadTransmitPowerLevel, child: CommandCompleteDataChild::LeEnhancedReadTransmitPowerLevelComplete(le_enhanced_read_transmit_power_level_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeEnhancedReadTransmitPowerLevelCompletePacket::new(event)}
}
impl Into<EventPacket> for LeEnhancedReadTransmitPowerLevelCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeEnhancedReadTransmitPowerLevelCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeReadRemoteTransmitPowerLevelData {connection_handle: u16, phy: u8, }
#[derive(Debug, Clone)] pub struct LeReadRemoteTransmitPowerLevelPacket {command: Arc<CommandData>,le_read_remote_transmit_power_level: Arc<LeReadRemoteTransmitPowerLevelData>,}
#[derive(Debug)] pub struct LeReadRemoteTransmitPowerLevelBuilder {pub connection_handle: u16, pub phy: u8, }
impl LeReadRemoteTransmitPowerLevelData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeReadRemoteTransmitPowerLevel".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeReadRemoteTransmitPowerLevel".to_string(),    field: "phy".to_string(),    wanted: 6,    got: bytes.len()});}let phy = u8::from_le_bytes([bytes[5]]);Ok(Self {connection_handle, phy, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let phy = self.phy;buffer[5..6].copy_from_slice(&phy.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl CommandExpectations for LeReadRemoteTransmitPowerLevelPacket { type ResponseType = LeReadRemoteTransmitPowerLevelStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadRemoteTransmitPowerLevelStatusPacket::new(pkt.event.clone()) }}impl Packet for LeReadRemoteTransmitPowerLevelPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadRemoteTransmitPowerLevelPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_read_remote_transmit_power_level = match &command.child {CommandDataChild::LeReadRemoteTransmitPowerLevel(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadRemoteTransmitPowerLevel"),};Self {command,le_read_remote_transmit_power_level,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_read_remote_transmit_power_level.as_ref().connection_handle}
pub fn get_phy(&self) -> u8{ self.le_read_remote_transmit_power_level.as_ref().phy}
}
impl Into<CommandPacket> for LeReadRemoteTransmitPowerLevelPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeReadRemoteTransmitPowerLevelBuilder { type ResponseType = LeReadRemoteTransmitPowerLevelStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeReadRemoteTransmitPowerLevelStatusPacket::new(pkt.event.clone()) }}impl LeReadRemoteTransmitPowerLevelBuilder {pub fn build(self) -> LeReadRemoteTransmitPowerLevelPacket {let le_read_remote_transmit_power_level= Arc::new(LeReadRemoteTransmitPowerLevelData {connection_handle: self.connection_handle, phy: self.phy, });let command= Arc::new(CommandData {op_code: OpCode::LeReadRemoteTransmitPowerLevel, child: CommandDataChild::LeReadRemoteTransmitPowerLevel(le_read_remote_transmit_power_level),});LeReadRemoteTransmitPowerLevelPacket::new(command)}
}
impl Into<CommandPacket> for LeReadRemoteTransmitPowerLevelBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LeReadRemoteTransmitPowerLevelStatusData {}
#[derive(Debug, Clone)] pub struct LeReadRemoteTransmitPowerLevelStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,le_read_remote_transmit_power_level_status: Arc<LeReadRemoteTransmitPowerLevelStatusData>,}
#[derive(Debug)] pub struct LeReadRemoteTransmitPowerLevelStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl LeReadRemoteTransmitPowerLevelStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeReadRemoteTransmitPowerLevelStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadRemoteTransmitPowerLevelStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let le_read_remote_transmit_power_level_status = match &command_status.child {CommandStatusDataChild::LeReadRemoteTransmitPowerLevelStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadRemoteTransmitPowerLevelStatus"),};Self {event,command_status,le_read_remote_transmit_power_level_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for LeReadRemoteTransmitPowerLevelStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for LeReadRemoteTransmitPowerLevelStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl LeReadRemoteTransmitPowerLevelStatusBuilder {pub fn build(self) -> LeReadRemoteTransmitPowerLevelStatusPacket {let le_read_remote_transmit_power_level_status= Arc::new(LeReadRemoteTransmitPowerLevelStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeReadRemoteTransmitPowerLevel, child: CommandStatusDataChild::LeReadRemoteTransmitPowerLevelStatus(le_read_remote_transmit_power_level_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});LeReadRemoteTransmitPowerLevelStatusPacket::new(event)}
}
impl Into<EventPacket> for LeReadRemoteTransmitPowerLevelStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for LeReadRemoteTransmitPowerLevelStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct LeSetPathLossReportingParametersData {connection_handle: u16, high_threshold: u8, high_hysteresis: u8, low_threshold: u8, low_hysteresis: u8, min_time_spent: u16, }
#[derive(Debug, Clone)] pub struct LeSetPathLossReportingParametersPacket {command: Arc<CommandData>,le_set_path_loss_reporting_parameters: Arc<LeSetPathLossReportingParametersData>,}
#[derive(Debug)] pub struct LeSetPathLossReportingParametersBuilder {pub connection_handle: u16, pub high_threshold: u8, pub high_hysteresis: u8, pub low_threshold: u8, pub low_hysteresis: u8, pub min_time_spent: u16, }
impl LeSetPathLossReportingParametersData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeSetPathLossReportingParameters".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetPathLossReportingParameters".to_string(),    field: "high_threshold".to_string(),    wanted: 6,    got: bytes.len()});}let high_threshold = u8::from_le_bytes([bytes[5]]);if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeSetPathLossReportingParameters".to_string(),    field: "high_hysteresis".to_string(),    wanted: 7,    got: bytes.len()});}let high_hysteresis = u8::from_le_bytes([bytes[6]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeSetPathLossReportingParameters".to_string(),    field: "low_threshold".to_string(),    wanted: 8,    got: bytes.len()});}let low_threshold = u8::from_le_bytes([bytes[7]]);if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeSetPathLossReportingParameters".to_string(),    field: "low_hysteresis".to_string(),    wanted: 9,    got: bytes.len()});}let low_hysteresis = u8::from_le_bytes([bytes[8]]);if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "LeSetPathLossReportingParameters".to_string(),    field: "min_time_spent".to_string(),    wanted: 11,    got: bytes.len()});}let min_time_spent = u16::from_le_bytes([bytes[9],bytes[10]]);Ok(Self {connection_handle, high_threshold, high_hysteresis, low_threshold, low_hysteresis, min_time_spent, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let high_threshold = self.high_threshold;buffer[5..6].copy_from_slice(&high_threshold.to_le_bytes()[0..1]);let high_hysteresis = self.high_hysteresis;buffer[6..7].copy_from_slice(&high_hysteresis.to_le_bytes()[0..1]);let low_threshold = self.low_threshold;buffer[7..8].copy_from_slice(&low_threshold.to_le_bytes()[0..1]);let low_hysteresis = self.low_hysteresis;buffer[8..9].copy_from_slice(&low_hysteresis.to_le_bytes()[0..1]);let min_time_spent = self.min_time_spent;buffer[9..11].copy_from_slice(&min_time_spent.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 8;ret}
}
impl CommandExpectations for LeSetPathLossReportingParametersPacket { type ResponseType = LeSetPathLossReportingParametersCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetPathLossReportingParametersCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetPathLossReportingParametersPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetPathLossReportingParametersPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_set_path_loss_reporting_parameters = match &command.child {CommandDataChild::LeSetPathLossReportingParameters(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetPathLossReportingParameters"),};Self {command,le_set_path_loss_reporting_parameters,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_set_path_loss_reporting_parameters.as_ref().connection_handle}
pub fn get_high_threshold(&self) -> u8{ self.le_set_path_loss_reporting_parameters.as_ref().high_threshold}
pub fn get_high_hysteresis(&self) -> u8{ self.le_set_path_loss_reporting_parameters.as_ref().high_hysteresis}
pub fn get_low_threshold(&self) -> u8{ self.le_set_path_loss_reporting_parameters.as_ref().low_threshold}
pub fn get_low_hysteresis(&self) -> u8{ self.le_set_path_loss_reporting_parameters.as_ref().low_hysteresis}
pub fn get_min_time_spent(&self) -> u16{ self.le_set_path_loss_reporting_parameters.as_ref().min_time_spent}
}
impl Into<CommandPacket> for LeSetPathLossReportingParametersPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeSetPathLossReportingParametersBuilder { type ResponseType = LeSetPathLossReportingParametersCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetPathLossReportingParametersCompletePacket::new(pkt.event.clone()) }}impl LeSetPathLossReportingParametersBuilder {pub fn build(self) -> LeSetPathLossReportingParametersPacket {let le_set_path_loss_reporting_parameters= Arc::new(LeSetPathLossReportingParametersData {connection_handle: self.connection_handle, high_threshold: self.high_threshold, high_hysteresis: self.high_hysteresis, low_threshold: self.low_threshold, low_hysteresis: self.low_hysteresis, min_time_spent: self.min_time_spent, });let command= Arc::new(CommandData {op_code: OpCode::LeSetPathLossReportingParameters, child: CommandDataChild::LeSetPathLossReportingParameters(le_set_path_loss_reporting_parameters),});LeSetPathLossReportingParametersPacket::new(command)}
}
impl Into<CommandPacket> for LeSetPathLossReportingParametersBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetPathLossReportingParametersCompleteData {status: ErrorCode, connection_handle: u16, }
#[derive(Debug, Clone)] pub struct LeSetPathLossReportingParametersCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_path_loss_reporting_parameters_complete: Arc<LeSetPathLossReportingParametersCompleteData>,}
#[derive(Debug)] pub struct LeSetPathLossReportingParametersCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, }
impl LeSetPathLossReportingParametersCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetPathLossReportingParametersComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeSetPathLossReportingParametersComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;Ok(Self {status, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for LeSetPathLossReportingParametersCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetPathLossReportingParametersCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_path_loss_reporting_parameters_complete = match &command_complete.child {CommandCompleteDataChild::LeSetPathLossReportingParametersComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetPathLossReportingParametersComplete"),};Self {event,command_complete,le_set_path_loss_reporting_parameters_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_path_loss_reporting_parameters_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_set_path_loss_reporting_parameters_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for LeSetPathLossReportingParametersCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetPathLossReportingParametersCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetPathLossReportingParametersCompleteBuilder {pub fn build(self) -> LeSetPathLossReportingParametersCompletePacket {let le_set_path_loss_reporting_parameters_complete= Arc::new(LeSetPathLossReportingParametersCompleteData {status: self.status, connection_handle: self.connection_handle, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetPathLossReportingParameters, child: CommandCompleteDataChild::LeSetPathLossReportingParametersComplete(le_set_path_loss_reporting_parameters_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetPathLossReportingParametersCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetPathLossReportingParametersCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetPathLossReportingParametersCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetPathLossReportingEnableData {connection_handle: u16, enable: u8, }
#[derive(Debug, Clone)] pub struct LeSetPathLossReportingEnablePacket {command: Arc<CommandData>,le_set_path_loss_reporting_enable: Arc<LeSetPathLossReportingEnableData>,}
#[derive(Debug)] pub struct LeSetPathLossReportingEnableBuilder {pub connection_handle: u16, pub enable: u8, }
impl LeSetPathLossReportingEnableData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeSetPathLossReportingEnable".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetPathLossReportingEnable".to_string(),    field: "enable".to_string(),    wanted: 6,    got: bytes.len()});}let enable = u8::from_le_bytes([bytes[5]]);Ok(Self {connection_handle, enable, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let enable = self.enable;buffer[5..6].copy_from_slice(&enable.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl CommandExpectations for LeSetPathLossReportingEnablePacket { type ResponseType = LeSetPathLossReportingEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetPathLossReportingEnableCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetPathLossReportingEnablePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetPathLossReportingEnablePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_set_path_loss_reporting_enable = match &command.child {CommandDataChild::LeSetPathLossReportingEnable(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetPathLossReportingEnable"),};Self {command,le_set_path_loss_reporting_enable,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_set_path_loss_reporting_enable.as_ref().connection_handle}
pub fn get_enable(&self) -> u8{ self.le_set_path_loss_reporting_enable.as_ref().enable}
}
impl Into<CommandPacket> for LeSetPathLossReportingEnablePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeSetPathLossReportingEnableBuilder { type ResponseType = LeSetPathLossReportingEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetPathLossReportingEnableCompletePacket::new(pkt.event.clone()) }}impl LeSetPathLossReportingEnableBuilder {pub fn build(self) -> LeSetPathLossReportingEnablePacket {let le_set_path_loss_reporting_enable= Arc::new(LeSetPathLossReportingEnableData {connection_handle: self.connection_handle, enable: self.enable, });let command= Arc::new(CommandData {op_code: OpCode::LeSetPathLossReportingEnable, child: CommandDataChild::LeSetPathLossReportingEnable(le_set_path_loss_reporting_enable),});LeSetPathLossReportingEnablePacket::new(command)}
}
impl Into<CommandPacket> for LeSetPathLossReportingEnableBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetPathLossReportingEnableCompleteData {status: ErrorCode, connection_handle: u16, }
#[derive(Debug, Clone)] pub struct LeSetPathLossReportingEnableCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_path_loss_reporting_enable_complete: Arc<LeSetPathLossReportingEnableCompleteData>,}
#[derive(Debug)] pub struct LeSetPathLossReportingEnableCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, }
impl LeSetPathLossReportingEnableCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetPathLossReportingEnableComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeSetPathLossReportingEnableComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;Ok(Self {status, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for LeSetPathLossReportingEnableCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetPathLossReportingEnableCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_path_loss_reporting_enable_complete = match &command_complete.child {CommandCompleteDataChild::LeSetPathLossReportingEnableComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetPathLossReportingEnableComplete"),};Self {event,command_complete,le_set_path_loss_reporting_enable_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_path_loss_reporting_enable_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_set_path_loss_reporting_enable_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for LeSetPathLossReportingEnableCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetPathLossReportingEnableCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetPathLossReportingEnableCompleteBuilder {pub fn build(self) -> LeSetPathLossReportingEnableCompletePacket {let le_set_path_loss_reporting_enable_complete= Arc::new(LeSetPathLossReportingEnableCompleteData {status: self.status, connection_handle: self.connection_handle, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetPathLossReportingEnable, child: CommandCompleteDataChild::LeSetPathLossReportingEnableComplete(le_set_path_loss_reporting_enable_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetPathLossReportingEnableCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetPathLossReportingEnableCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetPathLossReportingEnableCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeSetTransmitPowerReportingEnableData {connection_handle: u16, local_enable: u8, remote_enable: u8, }
#[derive(Debug, Clone)] pub struct LeSetTransmitPowerReportingEnablePacket {command: Arc<CommandData>,le_set_transmit_power_reporting_enable: Arc<LeSetTransmitPowerReportingEnableData>,}
#[derive(Debug)] pub struct LeSetTransmitPowerReportingEnableBuilder {pub connection_handle: u16, pub local_enable: u8, pub remote_enable: u8, }
impl LeSetTransmitPowerReportingEnableData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeSetTransmitPowerReportingEnable".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetTransmitPowerReportingEnable".to_string(),    field: "local_enable".to_string(),    wanted: 6,    got: bytes.len()});}let local_enable = u8::from_le_bytes([bytes[5]]);if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeSetTransmitPowerReportingEnable".to_string(),    field: "remote_enable".to_string(),    wanted: 7,    got: bytes.len()});}let remote_enable = u8::from_le_bytes([bytes[6]]);Ok(Self {connection_handle, local_enable, remote_enable, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let local_enable = self.local_enable;buffer[5..6].copy_from_slice(&local_enable.to_le_bytes()[0..1]);let remote_enable = self.remote_enable;buffer[6..7].copy_from_slice(&remote_enable.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl CommandExpectations for LeSetTransmitPowerReportingEnablePacket { type ResponseType = LeSetTransmitPowerReportingEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetTransmitPowerReportingEnableCompletePacket::new(pkt.event.clone()) }}impl Packet for LeSetTransmitPowerReportingEnablePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetTransmitPowerReportingEnablePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_set_transmit_power_reporting_enable = match &command.child {CommandDataChild::LeSetTransmitPowerReportingEnable(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetTransmitPowerReportingEnable"),};Self {command,le_set_transmit_power_reporting_enable,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.le_set_transmit_power_reporting_enable.as_ref().connection_handle}
pub fn get_local_enable(&self) -> u8{ self.le_set_transmit_power_reporting_enable.as_ref().local_enable}
pub fn get_remote_enable(&self) -> u8{ self.le_set_transmit_power_reporting_enable.as_ref().remote_enable}
}
impl Into<CommandPacket> for LeSetTransmitPowerReportingEnablePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for LeSetTransmitPowerReportingEnableBuilder { type ResponseType = LeSetTransmitPowerReportingEnableCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeSetTransmitPowerReportingEnableCompletePacket::new(pkt.event.clone()) }}impl LeSetTransmitPowerReportingEnableBuilder {pub fn build(self) -> LeSetTransmitPowerReportingEnablePacket {let le_set_transmit_power_reporting_enable= Arc::new(LeSetTransmitPowerReportingEnableData {connection_handle: self.connection_handle, local_enable: self.local_enable, remote_enable: self.remote_enable, });let command= Arc::new(CommandData {op_code: OpCode::LeSetTransmitPowerReportingEnable, child: CommandDataChild::LeSetTransmitPowerReportingEnable(le_set_transmit_power_reporting_enable),});LeSetTransmitPowerReportingEnablePacket::new(command)}
}
impl Into<CommandPacket> for LeSetTransmitPowerReportingEnableBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct LeSetTransmitPowerReportingEnableCompleteData {status: ErrorCode, connection_handle: u16, }
#[derive(Debug, Clone)] pub struct LeSetTransmitPowerReportingEnableCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_set_transmit_power_reporting_enable_complete: Arc<LeSetTransmitPowerReportingEnableCompleteData>,}
#[derive(Debug)] pub struct LeSetTransmitPowerReportingEnableCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub connection_handle: u16, }
impl LeSetTransmitPowerReportingEnableCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeSetTransmitPowerReportingEnableComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeSetTransmitPowerReportingEnableComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 8,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[6],bytes[7]]);let connection_handle = connection_handle & 0xfff;Ok(Self {status, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[6..8].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for LeSetTransmitPowerReportingEnableCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeSetTransmitPowerReportingEnableCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_set_transmit_power_reporting_enable_complete = match &command_complete.child {CommandCompleteDataChild::LeSetTransmitPowerReportingEnableComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeSetTransmitPowerReportingEnableComplete"),};Self {event,command_complete,le_set_transmit_power_reporting_enable_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_set_transmit_power_reporting_enable_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_set_transmit_power_reporting_enable_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for LeSetTransmitPowerReportingEnableCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeSetTransmitPowerReportingEnableCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeSetTransmitPowerReportingEnableCompleteBuilder {pub fn build(self) -> LeSetTransmitPowerReportingEnableCompletePacket {let le_set_transmit_power_reporting_enable_complete= Arc::new(LeSetTransmitPowerReportingEnableCompleteData {status: self.status, connection_handle: self.connection_handle, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeSetTransmitPowerReportingEnable, child: CommandCompleteDataChild::LeSetTransmitPowerReportingEnableComplete(le_set_transmit_power_reporting_enable_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeSetTransmitPowerReportingEnableCompletePacket::new(event)}
}
impl Into<EventPacket> for LeSetTransmitPowerReportingEnableCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeSetTransmitPowerReportingEnableCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeGetVendorCapabilitiesData {}
#[derive(Debug, Clone)] pub struct LeGetVendorCapabilitiesPacket {command: Arc<CommandData>,vendor_command: Arc<VendorCommandData>,le_get_vendor_capabilities: Arc<LeGetVendorCapabilitiesData>,}
#[derive(Debug)] pub struct LeGetVendorCapabilitiesBuilder {}
impl LeGetVendorCapabilitiesData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeGetVendorCapabilitiesPacket { type ResponseType = LeGetVendorCapabilitiesCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeGetVendorCapabilitiesCompletePacket::new(pkt.event.clone()) }}impl Packet for LeGetVendorCapabilitiesPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeGetVendorCapabilitiesPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let vendor_command = match &command.child {CommandDataChild::VendorCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not VendorCommand"),};let le_get_vendor_capabilities = match &vendor_command.child {VendorCommandDataChild::LeGetVendorCapabilities(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeGetVendorCapabilities"),};Self {command,vendor_command,le_get_vendor_capabilities,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeGetVendorCapabilitiesPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<VendorCommandPacket> for LeGetVendorCapabilitiesPacket { fn into(self) -> VendorCommandPacket {VendorCommandPacket::new(self.command) }}
impl CommandExpectations for LeGetVendorCapabilitiesBuilder { type ResponseType = LeGetVendorCapabilitiesCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeGetVendorCapabilitiesCompletePacket::new(pkt.event.clone()) }}impl LeGetVendorCapabilitiesBuilder {pub fn build(self) -> LeGetVendorCapabilitiesPacket {let le_get_vendor_capabilities= Arc::new(LeGetVendorCapabilitiesData {});let vendor_command= Arc::new(VendorCommandData {child: VendorCommandDataChild::LeGetVendorCapabilities(le_get_vendor_capabilities),});let command= Arc::new(CommandData {op_code: OpCode::LeGetVendorCapabilities, child: CommandDataChild::VendorCommand(vendor_command),});LeGetVendorCapabilitiesPacket::new(command)}
}
impl Into<CommandPacket> for LeGetVendorCapabilitiesBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<VendorCommandPacket> for LeGetVendorCapabilitiesBuilder { fn into(self) -> VendorCommandPacket { self.build().into() }}
macro_rules! le_get_vendor_capabilities_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::VendorCommand(vendor_command_packet) => {match vendor_command_packet.specialize() {/* (2) */
VendorCommandChild::LeGetVendorCapabilities(packet) => {let rebuilder = LeGetVendorCapabilitiesBuilder {};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse le_get_vendor_capabilities{:02x?}", vendor_command_packet); }}}_ => {println!("Couldn't parse vendor_command{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}le_get_vendor_capabilities_builder_tests! { le_get_vendor_capabilities_builder_test_00: b"\x53\xfd\x00",}


#[derive(Debug)] enum LeGetVendorCapabilitiesCompleteDataChild {LeGetVendorCapabilitiesComplete095(Arc<LeGetVendorCapabilitiesComplete095Data>),Payload(Bytes),None,}
impl LeGetVendorCapabilitiesCompleteDataChild {fn get_total_size(&self) -> usize {match self {LeGetVendorCapabilitiesCompleteDataChild::LeGetVendorCapabilitiesComplete095(value) => value.get_total_size(),LeGetVendorCapabilitiesCompleteDataChild::Payload(p) => p.len(),LeGetVendorCapabilitiesCompleteDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LeGetVendorCapabilitiesCompleteChild {LeGetVendorCapabilitiesComplete095(LeGetVendorCapabilitiesComplete095Packet),Payload(Bytes),None,}
#[derive(Debug)] struct LeGetVendorCapabilitiesCompleteData {status: ErrorCode, base_vendor_capabilities: BaseVendorCapabilities, child: LeGetVendorCapabilitiesCompleteDataChild,}
#[derive(Debug, Clone)] pub struct LeGetVendorCapabilitiesCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_get_vendor_capabilities_complete: Arc<LeGetVendorCapabilitiesCompleteData>,}
#[derive(Debug)] pub struct LeGetVendorCapabilitiesCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub base_vendor_capabilities: BaseVendorCapabilities, pub payload: Option<Bytes>,}
impl LeGetVendorCapabilitiesCompleteData {fn conforms(bytes: &[u8]) -> bool {if !BaseVendorCapabilities::conforms(&bytes[6..14]) { return false; } true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeGetVendorCapabilitiesComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();let base_vendor_capabilities = BaseVendorCapabilities::parse(&bytes[6..14]).unwrap();let payload: Vec::<u8> = bytes[14..].into();let child = match LeGetVendorCapabilitiesComplete095Data::parse(&bytes[..]) { Ok(c) if LeGetVendorCapabilitiesComplete095Data::conforms(&bytes[..]) => {LeGetVendorCapabilitiesCompleteDataChild::LeGetVendorCapabilitiesComplete095(Arc::new(c)) }, Err(Error::InvalidLengthError { .. }) => LeGetVendorCapabilitiesCompleteDataChild::None, _ => return Err(Error::InvalidPacketError),};Ok(Self {status, base_vendor_capabilities, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let base_vendor_capabilities = &mut buffer[6..14];self.base_vendor_capabilities.write_to(base_vendor_capabilities);match &self.child {LeGetVendorCapabilitiesCompleteDataChild::LeGetVendorCapabilitiesComplete095(value) => value.write_to(buffer),LeGetVendorCapabilitiesCompleteDataChild::Payload(p) => buffer[14..].copy_from_slice(&p[..]),LeGetVendorCapabilitiesCompleteDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 9;ret}
}
impl Packet for LeGetVendorCapabilitiesCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeGetVendorCapabilitiesCompletePacket { pub fn specialize(&self) -> LeGetVendorCapabilitiesCompleteChild { match &self.le_get_vendor_capabilities_complete.child {LeGetVendorCapabilitiesCompleteDataChild::LeGetVendorCapabilitiesComplete095(_) => LeGetVendorCapabilitiesCompleteChild::LeGetVendorCapabilitiesComplete095(LeGetVendorCapabilitiesComplete095Packet::new(self.event.clone())),LeGetVendorCapabilitiesCompleteDataChild::Payload(p) => LeGetVendorCapabilitiesCompleteChild::Payload(p.clone()),LeGetVendorCapabilitiesCompleteDataChild::None => LeGetVendorCapabilitiesCompleteChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_get_vendor_capabilities_complete = match &command_complete.child {CommandCompleteDataChild::LeGetVendorCapabilitiesComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeGetVendorCapabilitiesComplete"),};Self {event,command_complete,le_get_vendor_capabilities_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_get_vendor_capabilities_complete.as_ref().status}
pub fn get_base_vendor_capabilities(&self) -> &BaseVendorCapabilities{ &self.le_get_vendor_capabilities_complete.as_ref().base_vendor_capabilities}
}
impl Into<EventPacket> for LeGetVendorCapabilitiesCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeGetVendorCapabilitiesCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeGetVendorCapabilitiesCompleteBuilder {pub fn build(self) -> LeGetVendorCapabilitiesCompletePacket {let le_get_vendor_capabilities_complete= Arc::new(LeGetVendorCapabilitiesCompleteData {status: self.status, base_vendor_capabilities: self.base_vendor_capabilities, child: match self.payload { None => LeGetVendorCapabilitiesCompleteDataChild::None,Some(bytes) => LeGetVendorCapabilitiesCompleteDataChild::Payload(bytes),},});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeGetVendorCapabilities, child: CommandCompleteDataChild::LeGetVendorCapabilitiesComplete(le_get_vendor_capabilities_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeGetVendorCapabilitiesCompletePacket::new(event)}
}
impl Into<EventPacket> for LeGetVendorCapabilitiesCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeGetVendorCapabilitiesCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] enum LeGetVendorCapabilitiesComplete095DataChild {LeGetVendorCapabilitiesComplete096(Arc<LeGetVendorCapabilitiesComplete096Data>),Payload(Bytes),None,}
impl LeGetVendorCapabilitiesComplete095DataChild {fn get_total_size(&self) -> usize {match self {LeGetVendorCapabilitiesComplete095DataChild::LeGetVendorCapabilitiesComplete096(value) => value.get_total_size(),LeGetVendorCapabilitiesComplete095DataChild::Payload(p) => p.len(),LeGetVendorCapabilitiesComplete095DataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LeGetVendorCapabilitiesComplete095Child {LeGetVendorCapabilitiesComplete096(LeGetVendorCapabilitiesComplete096Packet),Payload(Bytes),None,}
#[derive(Debug)] struct LeGetVendorCapabilitiesComplete095Data {version_supported: u16, total_num_of_advt_tracked: u16, extended_scan_support: u8, debug_logging_supported: u8, child: LeGetVendorCapabilitiesComplete095DataChild,}
#[derive(Debug, Clone)] pub struct LeGetVendorCapabilitiesComplete095Packet {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_get_vendor_capabilities_complete: Arc<LeGetVendorCapabilitiesCompleteData>,le_get_vendor_capabilities_complete095: Arc<LeGetVendorCapabilitiesComplete095Data>,}
#[derive(Debug)] pub struct LeGetVendorCapabilitiesComplete095Builder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub base_vendor_capabilities: BaseVendorCapabilities, pub version_supported: u16, pub total_num_of_advt_tracked: u16, pub extended_scan_support: u8, pub debug_logging_supported: u8, pub payload: Option<Bytes>,}
impl LeGetVendorCapabilitiesComplete095Data {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 16 { return Err(Error::InvalidLengthError{    obj: "LeGetVendorCapabilitiesComplete095".to_string(),    field: "version_supported".to_string(),    wanted: 16,    got: bytes.len()});}let version_supported = u16::from_le_bytes([bytes[14],bytes[15]]);if bytes.len() < 18 { return Err(Error::InvalidLengthError{    obj: "LeGetVendorCapabilitiesComplete095".to_string(),    field: "total_num_of_advt_tracked".to_string(),    wanted: 18,    got: bytes.len()});}let total_num_of_advt_tracked = u16::from_le_bytes([bytes[16],bytes[17]]);if bytes.len() < 19 { return Err(Error::InvalidLengthError{    obj: "LeGetVendorCapabilitiesComplete095".to_string(),    field: "extended_scan_support".to_string(),    wanted: 19,    got: bytes.len()});}let extended_scan_support = u8::from_le_bytes([bytes[18]]);if bytes.len() < 20 { return Err(Error::InvalidLengthError{    obj: "LeGetVendorCapabilitiesComplete095".to_string(),    field: "debug_logging_supported".to_string(),    wanted: 20,    got: bytes.len()});}let debug_logging_supported = u8::from_le_bytes([bytes[19]]);let payload: Vec::<u8> = bytes[20..].into();let child = match LeGetVendorCapabilitiesComplete096Data::parse(&bytes[..]) { Ok(c) if LeGetVendorCapabilitiesComplete096Data::conforms(&bytes[..]) => {LeGetVendorCapabilitiesComplete095DataChild::LeGetVendorCapabilitiesComplete096(Arc::new(c)) }, Err(Error::InvalidLengthError { .. }) => LeGetVendorCapabilitiesComplete095DataChild::None, _ => return Err(Error::InvalidPacketError),};Ok(Self {version_supported, total_num_of_advt_tracked, extended_scan_support, debug_logging_supported, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let version_supported = self.version_supported;buffer[14..16].copy_from_slice(&version_supported.to_le_bytes()[0..2]);let total_num_of_advt_tracked = self.total_num_of_advt_tracked;buffer[16..18].copy_from_slice(&total_num_of_advt_tracked.to_le_bytes()[0..2]);let extended_scan_support = self.extended_scan_support;buffer[18..19].copy_from_slice(&extended_scan_support.to_le_bytes()[0..1]);let debug_logging_supported = self.debug_logging_supported;buffer[19..20].copy_from_slice(&debug_logging_supported.to_le_bytes()[0..1]);match &self.child {LeGetVendorCapabilitiesComplete095DataChild::LeGetVendorCapabilitiesComplete096(value) => value.write_to(buffer),LeGetVendorCapabilitiesComplete095DataChild::Payload(p) => buffer[20..].copy_from_slice(&p[..]),LeGetVendorCapabilitiesComplete095DataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl Packet for LeGetVendorCapabilitiesComplete095Packet {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeGetVendorCapabilitiesComplete095Packet { pub fn specialize(&self) -> LeGetVendorCapabilitiesComplete095Child { match &self.le_get_vendor_capabilities_complete095.child {LeGetVendorCapabilitiesComplete095DataChild::LeGetVendorCapabilitiesComplete096(_) => LeGetVendorCapabilitiesComplete095Child::LeGetVendorCapabilitiesComplete096(LeGetVendorCapabilitiesComplete096Packet::new(self.event.clone())),LeGetVendorCapabilitiesComplete095DataChild::Payload(p) => LeGetVendorCapabilitiesComplete095Child::Payload(p.clone()),LeGetVendorCapabilitiesComplete095DataChild::None => LeGetVendorCapabilitiesComplete095Child::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_get_vendor_capabilities_complete = match &command_complete.child {CommandCompleteDataChild::LeGetVendorCapabilitiesComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeGetVendorCapabilitiesComplete"),};let le_get_vendor_capabilities_complete095 = match &le_get_vendor_capabilities_complete.child {LeGetVendorCapabilitiesCompleteDataChild::LeGetVendorCapabilitiesComplete095(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeGetVendorCapabilitiesComplete095"),};Self {event,command_complete,le_get_vendor_capabilities_complete,le_get_vendor_capabilities_complete095,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_get_vendor_capabilities_complete.as_ref().status}
pub fn get_base_vendor_capabilities(&self) -> &BaseVendorCapabilities{ &self.le_get_vendor_capabilities_complete.as_ref().base_vendor_capabilities}
pub fn get_version_supported(&self) -> u16{ self.le_get_vendor_capabilities_complete095.as_ref().version_supported}
pub fn get_total_num_of_advt_tracked(&self) -> u16{ self.le_get_vendor_capabilities_complete095.as_ref().total_num_of_advt_tracked}
pub fn get_extended_scan_support(&self) -> u8{ self.le_get_vendor_capabilities_complete095.as_ref().extended_scan_support}
pub fn get_debug_logging_supported(&self) -> u8{ self.le_get_vendor_capabilities_complete095.as_ref().debug_logging_supported}
}
impl Into<EventPacket> for LeGetVendorCapabilitiesComplete095Packet { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeGetVendorCapabilitiesComplete095Packet { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl Into<LeGetVendorCapabilitiesCompletePacket> for LeGetVendorCapabilitiesComplete095Packet { fn into(self) -> LeGetVendorCapabilitiesCompletePacket {LeGetVendorCapabilitiesCompletePacket::new(self.event) }}
impl LeGetVendorCapabilitiesComplete095Builder {pub fn build(self) -> LeGetVendorCapabilitiesComplete095Packet {let le_get_vendor_capabilities_complete095= Arc::new(LeGetVendorCapabilitiesComplete095Data {version_supported: self.version_supported, total_num_of_advt_tracked: self.total_num_of_advt_tracked, extended_scan_support: self.extended_scan_support, debug_logging_supported: self.debug_logging_supported, child: match self.payload { None => LeGetVendorCapabilitiesComplete095DataChild::None,Some(bytes) => LeGetVendorCapabilitiesComplete095DataChild::Payload(bytes),},});let le_get_vendor_capabilities_complete= Arc::new(LeGetVendorCapabilitiesCompleteData {status: self.status, base_vendor_capabilities: self.base_vendor_capabilities, child: LeGetVendorCapabilitiesCompleteDataChild::LeGetVendorCapabilitiesComplete095(le_get_vendor_capabilities_complete095),});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeGetVendorCapabilities, child: CommandCompleteDataChild::LeGetVendorCapabilitiesComplete(le_get_vendor_capabilities_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeGetVendorCapabilitiesComplete095Packet::new(event)}
}
impl Into<EventPacket> for LeGetVendorCapabilitiesComplete095Builder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeGetVendorCapabilitiesComplete095Builder { fn into(self) -> CommandCompletePacket { self.build().into() }}
impl Into<LeGetVendorCapabilitiesCompletePacket> for LeGetVendorCapabilitiesComplete095Builder { fn into(self) -> LeGetVendorCapabilitiesCompletePacket { self.build().into() }}


#[derive(Debug)] enum LeGetVendorCapabilitiesComplete096DataChild {LeGetVendorCapabilitiesComplete098(Arc<LeGetVendorCapabilitiesComplete098Data>),Payload(Bytes),None,}
impl LeGetVendorCapabilitiesComplete096DataChild {fn get_total_size(&self) -> usize {match self {LeGetVendorCapabilitiesComplete096DataChild::LeGetVendorCapabilitiesComplete098(value) => value.get_total_size(),LeGetVendorCapabilitiesComplete096DataChild::Payload(p) => p.len(),LeGetVendorCapabilitiesComplete096DataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LeGetVendorCapabilitiesComplete096Child {LeGetVendorCapabilitiesComplete098(LeGetVendorCapabilitiesComplete098Packet),Payload(Bytes),None,}
#[derive(Debug)] struct LeGetVendorCapabilitiesComplete096Data {le_address_generation_offloading_support: u8, child: LeGetVendorCapabilitiesComplete096DataChild,}
#[derive(Debug, Clone)] pub struct LeGetVendorCapabilitiesComplete096Packet {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_get_vendor_capabilities_complete: Arc<LeGetVendorCapabilitiesCompleteData>,le_get_vendor_capabilities_complete095: Arc<LeGetVendorCapabilitiesComplete095Data>,le_get_vendor_capabilities_complete096: Arc<LeGetVendorCapabilitiesComplete096Data>,}
#[derive(Debug)] pub struct LeGetVendorCapabilitiesComplete096Builder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub base_vendor_capabilities: BaseVendorCapabilities, pub version_supported: u16, pub total_num_of_advt_tracked: u16, pub extended_scan_support: u8, pub debug_logging_supported: u8, pub le_address_generation_offloading_support: u8, pub payload: Option<Bytes>,}
impl LeGetVendorCapabilitiesComplete096Data {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 21 { return Err(Error::InvalidLengthError{    obj: "LeGetVendorCapabilitiesComplete096".to_string(),    field: "le_address_generation_offloading_support".to_string(),    wanted: 21,    got: bytes.len()});}let le_address_generation_offloading_support = u8::from_le_bytes([bytes[20]]);let payload: Vec::<u8> = bytes[21..].into();let child = match LeGetVendorCapabilitiesComplete098Data::parse(&bytes[..]) { Ok(c) if LeGetVendorCapabilitiesComplete098Data::conforms(&bytes[..]) => {LeGetVendorCapabilitiesComplete096DataChild::LeGetVendorCapabilitiesComplete098(Arc::new(c)) }, Err(Error::InvalidLengthError { .. }) => LeGetVendorCapabilitiesComplete096DataChild::None, _ => return Err(Error::InvalidPacketError),};Ok(Self {le_address_generation_offloading_support, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let le_address_generation_offloading_support = self.le_address_generation_offloading_support;buffer[20..21].copy_from_slice(&le_address_generation_offloading_support.to_le_bytes()[0..1]);match &self.child {LeGetVendorCapabilitiesComplete096DataChild::LeGetVendorCapabilitiesComplete098(value) => value.write_to(buffer),LeGetVendorCapabilitiesComplete096DataChild::Payload(p) => buffer[21..].copy_from_slice(&p[..]),LeGetVendorCapabilitiesComplete096DataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeGetVendorCapabilitiesComplete096Packet {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeGetVendorCapabilitiesComplete096Packet { pub fn specialize(&self) -> LeGetVendorCapabilitiesComplete096Child { match &self.le_get_vendor_capabilities_complete096.child {LeGetVendorCapabilitiesComplete096DataChild::LeGetVendorCapabilitiesComplete098(_) => LeGetVendorCapabilitiesComplete096Child::LeGetVendorCapabilitiesComplete098(LeGetVendorCapabilitiesComplete098Packet::new(self.event.clone())),LeGetVendorCapabilitiesComplete096DataChild::Payload(p) => LeGetVendorCapabilitiesComplete096Child::Payload(p.clone()),LeGetVendorCapabilitiesComplete096DataChild::None => LeGetVendorCapabilitiesComplete096Child::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_get_vendor_capabilities_complete = match &command_complete.child {CommandCompleteDataChild::LeGetVendorCapabilitiesComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeGetVendorCapabilitiesComplete"),};let le_get_vendor_capabilities_complete095 = match &le_get_vendor_capabilities_complete.child {LeGetVendorCapabilitiesCompleteDataChild::LeGetVendorCapabilitiesComplete095(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeGetVendorCapabilitiesComplete095"),};let le_get_vendor_capabilities_complete096 = match &le_get_vendor_capabilities_complete095.child {LeGetVendorCapabilitiesComplete095DataChild::LeGetVendorCapabilitiesComplete096(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeGetVendorCapabilitiesComplete096"),};Self {event,command_complete,le_get_vendor_capabilities_complete,le_get_vendor_capabilities_complete095,le_get_vendor_capabilities_complete096,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_get_vendor_capabilities_complete.as_ref().status}
pub fn get_base_vendor_capabilities(&self) -> &BaseVendorCapabilities{ &self.le_get_vendor_capabilities_complete.as_ref().base_vendor_capabilities}
pub fn get_version_supported(&self) -> u16{ self.le_get_vendor_capabilities_complete095.as_ref().version_supported}
pub fn get_total_num_of_advt_tracked(&self) -> u16{ self.le_get_vendor_capabilities_complete095.as_ref().total_num_of_advt_tracked}
pub fn get_extended_scan_support(&self) -> u8{ self.le_get_vendor_capabilities_complete095.as_ref().extended_scan_support}
pub fn get_debug_logging_supported(&self) -> u8{ self.le_get_vendor_capabilities_complete095.as_ref().debug_logging_supported}
pub fn get_le_address_generation_offloading_support(&self) -> u8{ self.le_get_vendor_capabilities_complete096.as_ref().le_address_generation_offloading_support}
}
impl Into<EventPacket> for LeGetVendorCapabilitiesComplete096Packet { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeGetVendorCapabilitiesComplete096Packet { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl Into<LeGetVendorCapabilitiesCompletePacket> for LeGetVendorCapabilitiesComplete096Packet { fn into(self) -> LeGetVendorCapabilitiesCompletePacket {LeGetVendorCapabilitiesCompletePacket::new(self.event) }}
impl Into<LeGetVendorCapabilitiesComplete095Packet> for LeGetVendorCapabilitiesComplete096Packet { fn into(self) -> LeGetVendorCapabilitiesComplete095Packet {LeGetVendorCapabilitiesComplete095Packet::new(self.event) }}
impl LeGetVendorCapabilitiesComplete096Builder {pub fn build(self) -> LeGetVendorCapabilitiesComplete096Packet {let le_get_vendor_capabilities_complete096= Arc::new(LeGetVendorCapabilitiesComplete096Data {le_address_generation_offloading_support: self.le_address_generation_offloading_support, child: match self.payload { None => LeGetVendorCapabilitiesComplete096DataChild::None,Some(bytes) => LeGetVendorCapabilitiesComplete096DataChild::Payload(bytes),},});let le_get_vendor_capabilities_complete095= Arc::new(LeGetVendorCapabilitiesComplete095Data {version_supported: self.version_supported, total_num_of_advt_tracked: self.total_num_of_advt_tracked, extended_scan_support: self.extended_scan_support, debug_logging_supported: self.debug_logging_supported, child: LeGetVendorCapabilitiesComplete095DataChild::LeGetVendorCapabilitiesComplete096(le_get_vendor_capabilities_complete096),});let le_get_vendor_capabilities_complete= Arc::new(LeGetVendorCapabilitiesCompleteData {status: self.status, base_vendor_capabilities: self.base_vendor_capabilities, child: LeGetVendorCapabilitiesCompleteDataChild::LeGetVendorCapabilitiesComplete095(le_get_vendor_capabilities_complete095),});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeGetVendorCapabilities, child: CommandCompleteDataChild::LeGetVendorCapabilitiesComplete(le_get_vendor_capabilities_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeGetVendorCapabilitiesComplete096Packet::new(event)}
}
impl Into<EventPacket> for LeGetVendorCapabilitiesComplete096Builder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeGetVendorCapabilitiesComplete096Builder { fn into(self) -> CommandCompletePacket { self.build().into() }}
impl Into<LeGetVendorCapabilitiesCompletePacket> for LeGetVendorCapabilitiesComplete096Builder { fn into(self) -> LeGetVendorCapabilitiesCompletePacket { self.build().into() }}
impl Into<LeGetVendorCapabilitiesComplete095Packet> for LeGetVendorCapabilitiesComplete096Builder { fn into(self) -> LeGetVendorCapabilitiesComplete095Packet { self.build().into() }}


#[derive(Debug)] struct LeGetVendorCapabilitiesComplete098Data {a2dp_source_offload_capability_mask: u32, bluetooth_quality_report_support: u8, }
#[derive(Debug, Clone)] pub struct LeGetVendorCapabilitiesComplete098Packet {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_get_vendor_capabilities_complete: Arc<LeGetVendorCapabilitiesCompleteData>,le_get_vendor_capabilities_complete095: Arc<LeGetVendorCapabilitiesComplete095Data>,le_get_vendor_capabilities_complete096: Arc<LeGetVendorCapabilitiesComplete096Data>,le_get_vendor_capabilities_complete098: Arc<LeGetVendorCapabilitiesComplete098Data>,}
#[derive(Debug)] pub struct LeGetVendorCapabilitiesComplete098Builder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub base_vendor_capabilities: BaseVendorCapabilities, pub version_supported: u16, pub total_num_of_advt_tracked: u16, pub extended_scan_support: u8, pub debug_logging_supported: u8, pub le_address_generation_offloading_support: u8, pub a2dp_source_offload_capability_mask: u32, pub bluetooth_quality_report_support: u8, }
impl LeGetVendorCapabilitiesComplete098Data {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 25 { return Err(Error::InvalidLengthError{    obj: "LeGetVendorCapabilitiesComplete098".to_string(),    field: "a2dp_source_offload_capability_mask".to_string(),    wanted: 25,    got: bytes.len()});}let a2dp_source_offload_capability_mask = u32::from_le_bytes([bytes[21],bytes[22],bytes[23],bytes[24]]);if bytes.len() < 26 { return Err(Error::InvalidLengthError{    obj: "LeGetVendorCapabilitiesComplete098".to_string(),    field: "bluetooth_quality_report_support".to_string(),    wanted: 26,    got: bytes.len()});}let bluetooth_quality_report_support = u8::from_le_bytes([bytes[25]]);Ok(Self {a2dp_source_offload_capability_mask, bluetooth_quality_report_support, })
}
fn write_to(&self, buffer: &mut BytesMut) {let a2dp_source_offload_capability_mask = self.a2dp_source_offload_capability_mask;buffer[21..25].copy_from_slice(&a2dp_source_offload_capability_mask.to_le_bytes()[0..4]);let bluetooth_quality_report_support = self.bluetooth_quality_report_support;buffer[25..26].copy_from_slice(&bluetooth_quality_report_support.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 5;ret}
}
impl Packet for LeGetVendorCapabilitiesComplete098Packet {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeGetVendorCapabilitiesComplete098Packet { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_get_vendor_capabilities_complete = match &command_complete.child {CommandCompleteDataChild::LeGetVendorCapabilitiesComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeGetVendorCapabilitiesComplete"),};let le_get_vendor_capabilities_complete095 = match &le_get_vendor_capabilities_complete.child {LeGetVendorCapabilitiesCompleteDataChild::LeGetVendorCapabilitiesComplete095(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeGetVendorCapabilitiesComplete095"),};let le_get_vendor_capabilities_complete096 = match &le_get_vendor_capabilities_complete095.child {LeGetVendorCapabilitiesComplete095DataChild::LeGetVendorCapabilitiesComplete096(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeGetVendorCapabilitiesComplete096"),};let le_get_vendor_capabilities_complete098 = match &le_get_vendor_capabilities_complete096.child {LeGetVendorCapabilitiesComplete096DataChild::LeGetVendorCapabilitiesComplete098(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeGetVendorCapabilitiesComplete098"),};Self {event,command_complete,le_get_vendor_capabilities_complete,le_get_vendor_capabilities_complete095,le_get_vendor_capabilities_complete096,le_get_vendor_capabilities_complete098,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_get_vendor_capabilities_complete.as_ref().status}
pub fn get_base_vendor_capabilities(&self) -> &BaseVendorCapabilities{ &self.le_get_vendor_capabilities_complete.as_ref().base_vendor_capabilities}
pub fn get_version_supported(&self) -> u16{ self.le_get_vendor_capabilities_complete095.as_ref().version_supported}
pub fn get_total_num_of_advt_tracked(&self) -> u16{ self.le_get_vendor_capabilities_complete095.as_ref().total_num_of_advt_tracked}
pub fn get_extended_scan_support(&self) -> u8{ self.le_get_vendor_capabilities_complete095.as_ref().extended_scan_support}
pub fn get_debug_logging_supported(&self) -> u8{ self.le_get_vendor_capabilities_complete095.as_ref().debug_logging_supported}
pub fn get_le_address_generation_offloading_support(&self) -> u8{ self.le_get_vendor_capabilities_complete096.as_ref().le_address_generation_offloading_support}
pub fn get_a2dp_source_offload_capability_mask(&self) -> u32{ self.le_get_vendor_capabilities_complete098.as_ref().a2dp_source_offload_capability_mask}
pub fn get_bluetooth_quality_report_support(&self) -> u8{ self.le_get_vendor_capabilities_complete098.as_ref().bluetooth_quality_report_support}
}
impl Into<EventPacket> for LeGetVendorCapabilitiesComplete098Packet { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeGetVendorCapabilitiesComplete098Packet { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl Into<LeGetVendorCapabilitiesCompletePacket> for LeGetVendorCapabilitiesComplete098Packet { fn into(self) -> LeGetVendorCapabilitiesCompletePacket {LeGetVendorCapabilitiesCompletePacket::new(self.event) }}
impl Into<LeGetVendorCapabilitiesComplete095Packet> for LeGetVendorCapabilitiesComplete098Packet { fn into(self) -> LeGetVendorCapabilitiesComplete095Packet {LeGetVendorCapabilitiesComplete095Packet::new(self.event) }}
impl Into<LeGetVendorCapabilitiesComplete096Packet> for LeGetVendorCapabilitiesComplete098Packet { fn into(self) -> LeGetVendorCapabilitiesComplete096Packet {LeGetVendorCapabilitiesComplete096Packet::new(self.event) }}
impl LeGetVendorCapabilitiesComplete098Builder {pub fn build(self) -> LeGetVendorCapabilitiesComplete098Packet {let le_get_vendor_capabilities_complete098= Arc::new(LeGetVendorCapabilitiesComplete098Data {a2dp_source_offload_capability_mask: self.a2dp_source_offload_capability_mask, bluetooth_quality_report_support: self.bluetooth_quality_report_support, });let le_get_vendor_capabilities_complete096= Arc::new(LeGetVendorCapabilitiesComplete096Data {le_address_generation_offloading_support: self.le_address_generation_offloading_support, child: LeGetVendorCapabilitiesComplete096DataChild::LeGetVendorCapabilitiesComplete098(le_get_vendor_capabilities_complete098),});let le_get_vendor_capabilities_complete095= Arc::new(LeGetVendorCapabilitiesComplete095Data {version_supported: self.version_supported, total_num_of_advt_tracked: self.total_num_of_advt_tracked, extended_scan_support: self.extended_scan_support, debug_logging_supported: self.debug_logging_supported, child: LeGetVendorCapabilitiesComplete095DataChild::LeGetVendorCapabilitiesComplete096(le_get_vendor_capabilities_complete096),});let le_get_vendor_capabilities_complete= Arc::new(LeGetVendorCapabilitiesCompleteData {status: self.status, base_vendor_capabilities: self.base_vendor_capabilities, child: LeGetVendorCapabilitiesCompleteDataChild::LeGetVendorCapabilitiesComplete095(le_get_vendor_capabilities_complete095),});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeGetVendorCapabilities, child: CommandCompleteDataChild::LeGetVendorCapabilitiesComplete(le_get_vendor_capabilities_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeGetVendorCapabilitiesComplete098Packet::new(event)}
}
impl Into<EventPacket> for LeGetVendorCapabilitiesComplete098Builder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeGetVendorCapabilitiesComplete098Builder { fn into(self) -> CommandCompletePacket { self.build().into() }}
impl Into<LeGetVendorCapabilitiesCompletePacket> for LeGetVendorCapabilitiesComplete098Builder { fn into(self) -> LeGetVendorCapabilitiesCompletePacket { self.build().into() }}
impl Into<LeGetVendorCapabilitiesComplete095Packet> for LeGetVendorCapabilitiesComplete098Builder { fn into(self) -> LeGetVendorCapabilitiesComplete095Packet { self.build().into() }}
impl Into<LeGetVendorCapabilitiesComplete096Packet> for LeGetVendorCapabilitiesComplete098Builder { fn into(self) -> LeGetVendorCapabilitiesComplete096Packet { self.build().into() }}


#[derive(Debug)] enum LeMultiAdvtDataChild {LeMultiAdvtParam(Arc<LeMultiAdvtParamData>),LeMultiAdvtSetData(Arc<LeMultiAdvtSetDataData>),LeMultiAdvtSetScanResp(Arc<LeMultiAdvtSetScanRespData>),LeMultiAdvtSetRandomAddr(Arc<LeMultiAdvtSetRandomAddrData>),LeMultiAdvtSetEnable(Arc<LeMultiAdvtSetEnableData>),None,}
impl LeMultiAdvtDataChild {fn get_total_size(&self) -> usize {match self {LeMultiAdvtDataChild::LeMultiAdvtParam(value) => value.get_total_size(),LeMultiAdvtDataChild::LeMultiAdvtSetData(value) => value.get_total_size(),LeMultiAdvtDataChild::LeMultiAdvtSetScanResp(value) => value.get_total_size(),LeMultiAdvtDataChild::LeMultiAdvtSetRandomAddr(value) => value.get_total_size(),LeMultiAdvtDataChild::LeMultiAdvtSetEnable(value) => value.get_total_size(),LeMultiAdvtDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LeMultiAdvtChild {LeMultiAdvtParam(LeMultiAdvtParamPacket),LeMultiAdvtSetData(LeMultiAdvtSetDataPacket),LeMultiAdvtSetScanResp(LeMultiAdvtSetScanRespPacket),LeMultiAdvtSetRandomAddr(LeMultiAdvtSetRandomAddrPacket),LeMultiAdvtSetEnable(LeMultiAdvtSetEnablePacket),None,}
#[derive(Debug)] struct LeMultiAdvtData {sub_cmd: SubOcf, child: LeMultiAdvtDataChild,}
#[derive(Debug, Clone)] pub struct LeMultiAdvtPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_multi_advt: Arc<LeMultiAdvtData>,}
#[derive(Debug)] pub struct LeMultiAdvtBuilder {pub sub_cmd: SubOcf, }
impl LeMultiAdvtData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeMultiAdvt".to_string(),    field: "sub_cmd".to_string(),    wanted: 4,    got: bytes.len()});}let sub_cmd = u8::from_le_bytes([bytes[3]]);let sub_cmd = SubOcf::from_u8(sub_cmd).unwrap();let child = match sub_cmd {SubOcf::SetParam if LeMultiAdvtParamData::conforms(&bytes[..]) => {LeMultiAdvtDataChild::LeMultiAdvtParam(Arc::new(LeMultiAdvtParamData::parse(&bytes[..])?))}
SubOcf::SetData if LeMultiAdvtSetDataData::conforms(&bytes[..]) => {LeMultiAdvtDataChild::LeMultiAdvtSetData(Arc::new(LeMultiAdvtSetDataData::parse(&bytes[..])?))}
SubOcf::SetScanResp if LeMultiAdvtSetScanRespData::conforms(&bytes[..]) => {LeMultiAdvtDataChild::LeMultiAdvtSetScanResp(Arc::new(LeMultiAdvtSetScanRespData::parse(&bytes[..])?))}
SubOcf::SetRandomAddr if LeMultiAdvtSetRandomAddrData::conforms(&bytes[..]) => {LeMultiAdvtDataChild::LeMultiAdvtSetRandomAddr(Arc::new(LeMultiAdvtSetRandomAddrData::parse(&bytes[..])?))}
SubOcf::SetEnable if LeMultiAdvtSetEnableData::conforms(&bytes[..]) => {LeMultiAdvtDataChild::LeMultiAdvtSetEnable(Arc::new(LeMultiAdvtSetEnableData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "sub_cmd".to_string(), value: v as u64}),};
Ok(Self {sub_cmd, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let sub_cmd = self.sub_cmd.to_u8().unwrap();buffer[3..4].copy_from_slice(&sub_cmd.to_le_bytes()[0..1]);match &self.child {LeMultiAdvtDataChild::LeMultiAdvtParam(value) => value.write_to(buffer),LeMultiAdvtDataChild::LeMultiAdvtSetData(value) => value.write_to(buffer),LeMultiAdvtDataChild::LeMultiAdvtSetScanResp(value) => value.write_to(buffer),LeMultiAdvtDataChild::LeMultiAdvtSetRandomAddr(value) => value.write_to(buffer),LeMultiAdvtDataChild::LeMultiAdvtSetEnable(value) => value.write_to(buffer),LeMultiAdvtDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for LeMultiAdvtPacket { type ResponseType = LeMultiAdvtCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeMultiAdvtCompletePacket::new(pkt.event.clone()) }}impl Packet for LeMultiAdvtPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeMultiAdvtPacket { pub fn specialize(&self) -> LeMultiAdvtChild { match &self.le_multi_advt.child {LeMultiAdvtDataChild::LeMultiAdvtParam(_) => LeMultiAdvtChild::LeMultiAdvtParam(LeMultiAdvtParamPacket::new(self.command.clone())),LeMultiAdvtDataChild::LeMultiAdvtSetData(_) => LeMultiAdvtChild::LeMultiAdvtSetData(LeMultiAdvtSetDataPacket::new(self.command.clone())),LeMultiAdvtDataChild::LeMultiAdvtSetScanResp(_) => LeMultiAdvtChild::LeMultiAdvtSetScanResp(LeMultiAdvtSetScanRespPacket::new(self.command.clone())),LeMultiAdvtDataChild::LeMultiAdvtSetRandomAddr(_) => LeMultiAdvtChild::LeMultiAdvtSetRandomAddr(LeMultiAdvtSetRandomAddrPacket::new(self.command.clone())),LeMultiAdvtDataChild::LeMultiAdvtSetEnable(_) => LeMultiAdvtChild::LeMultiAdvtSetEnable(LeMultiAdvtSetEnablePacket::new(self.command.clone())),LeMultiAdvtDataChild::None => LeMultiAdvtChild::None,}} fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_multi_advt = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeMultiAdvt(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMultiAdvt"),};Self {command,le_advertising_command,le_multi_advt,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_sub_cmd(&self) -> SubOcf{ self.le_multi_advt.as_ref().sub_cmd}
}
impl Into<CommandPacket> for LeMultiAdvtPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeMultiAdvtPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl CommandExpectations for LeMultiAdvtBuilder { type ResponseType = LeMultiAdvtCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeMultiAdvtCompletePacket::new(pkt.event.clone()) }}impl LeMultiAdvtBuilder {pub fn build(self) -> LeMultiAdvtPacket {let le_multi_advt= Arc::new(LeMultiAdvtData {sub_cmd: self.sub_cmd, child: LeMultiAdvtDataChild::None,});let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeMultiAdvt(le_multi_advt),});let command= Arc::new(CommandData {op_code: OpCode::LeMultiAdvt, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeMultiAdvtPacket::new(command)}
}
impl Into<CommandPacket> for LeMultiAdvtBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeMultiAdvtBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}


#[derive(Debug)] enum LeMultiAdvtCompleteDataChild {LeMultiAdvtParamComplete(Arc<LeMultiAdvtParamCompleteData>),LeMultiAdvtSetDataComplete(Arc<LeMultiAdvtSetDataCompleteData>),LeMultiAdvtSetScanRespComplete(Arc<LeMultiAdvtSetScanRespCompleteData>),LeMultiAdvtSetRandomAddrComplete(Arc<LeMultiAdvtSetRandomAddrCompleteData>),LeMultiAdvtSetEnableComplete(Arc<LeMultiAdvtSetEnableCompleteData>),None,}
impl LeMultiAdvtCompleteDataChild {fn get_total_size(&self) -> usize {match self {LeMultiAdvtCompleteDataChild::LeMultiAdvtParamComplete(value) => value.get_total_size(),LeMultiAdvtCompleteDataChild::LeMultiAdvtSetDataComplete(value) => value.get_total_size(),LeMultiAdvtCompleteDataChild::LeMultiAdvtSetScanRespComplete(value) => value.get_total_size(),LeMultiAdvtCompleteDataChild::LeMultiAdvtSetRandomAddrComplete(value) => value.get_total_size(),LeMultiAdvtCompleteDataChild::LeMultiAdvtSetEnableComplete(value) => value.get_total_size(),LeMultiAdvtCompleteDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LeMultiAdvtCompleteChild {LeMultiAdvtParamComplete(LeMultiAdvtParamCompletePacket),LeMultiAdvtSetDataComplete(LeMultiAdvtSetDataCompletePacket),LeMultiAdvtSetScanRespComplete(LeMultiAdvtSetScanRespCompletePacket),LeMultiAdvtSetRandomAddrComplete(LeMultiAdvtSetRandomAddrCompletePacket),LeMultiAdvtSetEnableComplete(LeMultiAdvtSetEnableCompletePacket),None,}
#[derive(Debug)] struct LeMultiAdvtCompleteData {status: ErrorCode, sub_cmd: SubOcf, child: LeMultiAdvtCompleteDataChild,}
#[derive(Debug, Clone)] pub struct LeMultiAdvtCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_multi_advt_complete: Arc<LeMultiAdvtCompleteData>,}
#[derive(Debug)] pub struct LeMultiAdvtCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub sub_cmd: SubOcf, }
impl LeMultiAdvtCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeMultiAdvtComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeMultiAdvtComplete".to_string(),    field: "sub_cmd".to_string(),    wanted: 7,    got: bytes.len()});}let sub_cmd = u8::from_le_bytes([bytes[6]]);let sub_cmd = SubOcf::from_u8(sub_cmd).unwrap();let child = match sub_cmd {SubOcf::SetParam if LeMultiAdvtParamCompleteData::conforms(&bytes[..]) => {LeMultiAdvtCompleteDataChild::LeMultiAdvtParamComplete(Arc::new(LeMultiAdvtParamCompleteData::parse(&bytes[..])?))}
SubOcf::SetData if LeMultiAdvtSetDataCompleteData::conforms(&bytes[..]) => {LeMultiAdvtCompleteDataChild::LeMultiAdvtSetDataComplete(Arc::new(LeMultiAdvtSetDataCompleteData::parse(&bytes[..])?))}
SubOcf::SetScanResp if LeMultiAdvtSetScanRespCompleteData::conforms(&bytes[..]) => {LeMultiAdvtCompleteDataChild::LeMultiAdvtSetScanRespComplete(Arc::new(LeMultiAdvtSetScanRespCompleteData::parse(&bytes[..])?))}
SubOcf::SetRandomAddr if LeMultiAdvtSetRandomAddrCompleteData::conforms(&bytes[..]) => {LeMultiAdvtCompleteDataChild::LeMultiAdvtSetRandomAddrComplete(Arc::new(LeMultiAdvtSetRandomAddrCompleteData::parse(&bytes[..])?))}
SubOcf::SetEnable if LeMultiAdvtSetEnableCompleteData::conforms(&bytes[..]) => {LeMultiAdvtCompleteDataChild::LeMultiAdvtSetEnableComplete(Arc::new(LeMultiAdvtSetEnableCompleteData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "sub_cmd".to_string(), value: v as u64}),};
Ok(Self {status, sub_cmd, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let sub_cmd = self.sub_cmd.to_u8().unwrap();buffer[6..7].copy_from_slice(&sub_cmd.to_le_bytes()[0..1]);match &self.child {LeMultiAdvtCompleteDataChild::LeMultiAdvtParamComplete(value) => value.write_to(buffer),LeMultiAdvtCompleteDataChild::LeMultiAdvtSetDataComplete(value) => value.write_to(buffer),LeMultiAdvtCompleteDataChild::LeMultiAdvtSetScanRespComplete(value) => value.write_to(buffer),LeMultiAdvtCompleteDataChild::LeMultiAdvtSetRandomAddrComplete(value) => value.write_to(buffer),LeMultiAdvtCompleteDataChild::LeMultiAdvtSetEnableComplete(value) => value.write_to(buffer),LeMultiAdvtCompleteDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for LeMultiAdvtCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeMultiAdvtCompletePacket { pub fn specialize(&self) -> LeMultiAdvtCompleteChild { match &self.le_multi_advt_complete.child {LeMultiAdvtCompleteDataChild::LeMultiAdvtParamComplete(_) => LeMultiAdvtCompleteChild::LeMultiAdvtParamComplete(LeMultiAdvtParamCompletePacket::new(self.event.clone())),LeMultiAdvtCompleteDataChild::LeMultiAdvtSetDataComplete(_) => LeMultiAdvtCompleteChild::LeMultiAdvtSetDataComplete(LeMultiAdvtSetDataCompletePacket::new(self.event.clone())),LeMultiAdvtCompleteDataChild::LeMultiAdvtSetScanRespComplete(_) => LeMultiAdvtCompleteChild::LeMultiAdvtSetScanRespComplete(LeMultiAdvtSetScanRespCompletePacket::new(self.event.clone())),LeMultiAdvtCompleteDataChild::LeMultiAdvtSetRandomAddrComplete(_) => LeMultiAdvtCompleteChild::LeMultiAdvtSetRandomAddrComplete(LeMultiAdvtSetRandomAddrCompletePacket::new(self.event.clone())),LeMultiAdvtCompleteDataChild::LeMultiAdvtSetEnableComplete(_) => LeMultiAdvtCompleteChild::LeMultiAdvtSetEnableComplete(LeMultiAdvtSetEnableCompletePacket::new(self.event.clone())),LeMultiAdvtCompleteDataChild::None => LeMultiAdvtCompleteChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_multi_advt_complete = match &command_complete.child {CommandCompleteDataChild::LeMultiAdvtComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMultiAdvtComplete"),};Self {event,command_complete,le_multi_advt_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_multi_advt_complete.as_ref().status}
pub fn get_sub_cmd(&self) -> SubOcf{ self.le_multi_advt_complete.as_ref().sub_cmd}
}
impl Into<EventPacket> for LeMultiAdvtCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeMultiAdvtCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeMultiAdvtCompleteBuilder {pub fn build(self) -> LeMultiAdvtCompletePacket {let le_multi_advt_complete= Arc::new(LeMultiAdvtCompleteData {status: self.status, sub_cmd: self.sub_cmd, child: LeMultiAdvtCompleteDataChild::None,});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeMultiAdvt, child: CommandCompleteDataChild::LeMultiAdvtComplete(le_multi_advt_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeMultiAdvtCompletePacket::new(event)}
}
impl Into<EventPacket> for LeMultiAdvtCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeMultiAdvtCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeMultiAdvtParamData {interval_min: u16, interval_max: u16, advt_type: AdvertisingType, own_address_type: OwnAddressType, peer_address_type: PeerAddressType, peer_address: Address, channel_map: u8, filter_policy: AdvertisingFilterPolicy, instance: u8, tx_power: u8, }
#[derive(Debug, Clone)] pub struct LeMultiAdvtParamPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_multi_advt: Arc<LeMultiAdvtData>,le_multi_advt_param: Arc<LeMultiAdvtParamData>,}
#[derive(Debug)] pub struct LeMultiAdvtParamBuilder {pub interval_min: u16, pub interval_max: u16, pub advt_type: AdvertisingType, pub own_address_type: OwnAddressType, pub peer_address_type: PeerAddressType, pub peer_address: Address, pub channel_map: u8, pub filter_policy: AdvertisingFilterPolicy, pub instance: u8, pub tx_power: u8, }
impl LeMultiAdvtParamData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeMultiAdvtParam".to_string(),    field: "interval_min".to_string(),    wanted: 6,    got: bytes.len()});}let interval_min = u16::from_le_bytes([bytes[4],bytes[5]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeMultiAdvtParam".to_string(),    field: "interval_max".to_string(),    wanted: 8,    got: bytes.len()});}let interval_max = u16::from_le_bytes([bytes[6],bytes[7]]);if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeMultiAdvtParam".to_string(),    field: "advt_type".to_string(),    wanted: 9,    got: bytes.len()});}let advt_type = u8::from_le_bytes([bytes[8]]);let advt_type = AdvertisingType::from_u8(advt_type).unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeMultiAdvtParam".to_string(),    field: "own_address_type".to_string(),    wanted: 10,    got: bytes.len()});}let own_address_type = u8::from_le_bytes([bytes[9]]);let own_address_type = OwnAddressType::from_u8(own_address_type).unwrap();if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "LeMultiAdvtParam".to_string(),    field: "peer_address_type".to_string(),    wanted: 11,    got: bytes.len()});}let peer_address_type = u8::from_le_bytes([bytes[10]]);let peer_address_type = PeerAddressType::from_u8(peer_address_type).unwrap();if bytes.len() < 17 { return Err(Error::InvalidLengthError{    obj: "LeMultiAdvtParam".to_string(),    field: "peer_address".to_string(),    wanted: 17,    got: bytes.len()});}let peer_address = bytes[11..17].try_into().unwrap();if bytes.len() < 18 { return Err(Error::InvalidLengthError{    obj: "LeMultiAdvtParam".to_string(),    field: "channel_map".to_string(),    wanted: 18,    got: bytes.len()});}let channel_map = u8::from_le_bytes([bytes[17]]);let filter_policy = u8::from_le_bytes([bytes[18]]);let filter_policy = filter_policy & 0x3;let filter_policy = AdvertisingFilterPolicy::from_u8(filter_policy).unwrap();if bytes.len() < 20 { return Err(Error::InvalidLengthError{    obj: "LeMultiAdvtParam".to_string(),    field: "instance".to_string(),    wanted: 20,    got: bytes.len()});}let instance = u8::from_le_bytes([bytes[19]]);if bytes.len() < 21 { return Err(Error::InvalidLengthError{    obj: "LeMultiAdvtParam".to_string(),    field: "tx_power".to_string(),    wanted: 21,    got: bytes.len()});}let tx_power = u8::from_le_bytes([bytes[20]]);Ok(Self {interval_min, interval_max, advt_type, own_address_type, peer_address_type, peer_address, channel_map, filter_policy, instance, tx_power, })
}
fn write_to(&self, buffer: &mut BytesMut) {let interval_min = self.interval_min;buffer[4..6].copy_from_slice(&interval_min.to_le_bytes()[0..2]);let interval_max = self.interval_max;buffer[6..8].copy_from_slice(&interval_max.to_le_bytes()[0..2]);let advt_type = self.advt_type.to_u8().unwrap();buffer[8..9].copy_from_slice(&advt_type.to_le_bytes()[0..1]);let own_address_type = self.own_address_type.to_u8().unwrap();buffer[9..10].copy_from_slice(&own_address_type.to_le_bytes()[0..1]);let peer_address_type = self.peer_address_type.to_u8().unwrap();buffer[10..11].copy_from_slice(&peer_address_type.to_le_bytes()[0..1]);let peer_address: [u8; 6] = self.peer_address.into();buffer[11..17].copy_from_slice(&peer_address);let channel_map = self.channel_map;buffer[17..18].copy_from_slice(&channel_map.to_le_bytes()[0..1]);let filter_policy = self.filter_policy.to_u8().unwrap();let filter_policy = filter_policy & 0x3;buffer[18..19].copy_from_slice(&filter_policy.to_le_bytes()[0..1]);let instance = self.instance;buffer[19..20].copy_from_slice(&instance.to_le_bytes()[0..1]);let tx_power = self.tx_power;buffer[20..21].copy_from_slice(&tx_power.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 17;ret}
}
impl Packet for LeMultiAdvtParamPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeMultiAdvtParamPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_multi_advt = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeMultiAdvt(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMultiAdvt"),};let le_multi_advt_param = match &le_multi_advt.child {LeMultiAdvtDataChild::LeMultiAdvtParam(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMultiAdvtParam"),};Self {command,le_advertising_command,le_multi_advt,le_multi_advt_param,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_sub_cmd(&self) -> SubOcf{ self.le_multi_advt.as_ref().sub_cmd}
pub fn get_interval_min(&self) -> u16{ self.le_multi_advt_param.as_ref().interval_min}
pub fn get_interval_max(&self) -> u16{ self.le_multi_advt_param.as_ref().interval_max}
pub fn get_advt_type(&self) -> AdvertisingType{ self.le_multi_advt_param.as_ref().advt_type}
pub fn get_own_address_type(&self) -> OwnAddressType{ self.le_multi_advt_param.as_ref().own_address_type}
pub fn get_peer_address_type(&self) -> PeerAddressType{ self.le_multi_advt_param.as_ref().peer_address_type}
pub fn get_peer_address(&self) -> Address{ self.le_multi_advt_param.as_ref().peer_address}
pub fn get_channel_map(&self) -> u8{ self.le_multi_advt_param.as_ref().channel_map}
pub fn get_filter_policy(&self) -> AdvertisingFilterPolicy{ self.le_multi_advt_param.as_ref().filter_policy}
pub fn get_instance(&self) -> u8{ self.le_multi_advt_param.as_ref().instance}
pub fn get_tx_power(&self) -> u8{ self.le_multi_advt_param.as_ref().tx_power}
}
impl Into<CommandPacket> for LeMultiAdvtParamPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeMultiAdvtParamPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl Into<LeMultiAdvtPacket> for LeMultiAdvtParamPacket { fn into(self) -> LeMultiAdvtPacket {LeMultiAdvtPacket::new(self.command) }}
impl LeMultiAdvtParamBuilder {pub fn build(self) -> LeMultiAdvtParamPacket {let le_multi_advt_param= Arc::new(LeMultiAdvtParamData {interval_min: self.interval_min, interval_max: self.interval_max, advt_type: self.advt_type, own_address_type: self.own_address_type, peer_address_type: self.peer_address_type, peer_address: self.peer_address, channel_map: self.channel_map, filter_policy: self.filter_policy, instance: self.instance, tx_power: self.tx_power, });let le_multi_advt= Arc::new(LeMultiAdvtData {sub_cmd: SubOcf::SetParam, child: LeMultiAdvtDataChild::LeMultiAdvtParam(le_multi_advt_param),});let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeMultiAdvt(le_multi_advt),});let command= Arc::new(CommandData {op_code: OpCode::LeMultiAdvt, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeMultiAdvtParamPacket::new(command)}
}
impl Into<CommandPacket> for LeMultiAdvtParamBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeMultiAdvtParamBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}
impl Into<LeMultiAdvtPacket> for LeMultiAdvtParamBuilder { fn into(self) -> LeMultiAdvtPacket { self.build().into() }}


#[derive(Debug)] struct LeMultiAdvtParamCompleteData {}
#[derive(Debug, Clone)] pub struct LeMultiAdvtParamCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_multi_advt_complete: Arc<LeMultiAdvtCompleteData>,le_multi_advt_param_complete: Arc<LeMultiAdvtParamCompleteData>,}
#[derive(Debug)] pub struct LeMultiAdvtParamCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeMultiAdvtParamCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeMultiAdvtParamCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeMultiAdvtParamCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_multi_advt_complete = match &command_complete.child {CommandCompleteDataChild::LeMultiAdvtComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMultiAdvtComplete"),};let le_multi_advt_param_complete = match &le_multi_advt_complete.child {LeMultiAdvtCompleteDataChild::LeMultiAdvtParamComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMultiAdvtParamComplete"),};Self {event,command_complete,le_multi_advt_complete,le_multi_advt_param_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_multi_advt_complete.as_ref().status}
pub fn get_sub_cmd(&self) -> SubOcf{ self.le_multi_advt_complete.as_ref().sub_cmd}
}
impl Into<EventPacket> for LeMultiAdvtParamCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeMultiAdvtParamCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl Into<LeMultiAdvtCompletePacket> for LeMultiAdvtParamCompletePacket { fn into(self) -> LeMultiAdvtCompletePacket {LeMultiAdvtCompletePacket::new(self.event) }}
impl LeMultiAdvtParamCompleteBuilder {pub fn build(self) -> LeMultiAdvtParamCompletePacket {let le_multi_advt_param_complete= Arc::new(LeMultiAdvtParamCompleteData {});let le_multi_advt_complete= Arc::new(LeMultiAdvtCompleteData {status: self.status, sub_cmd: SubOcf::SetParam, child: LeMultiAdvtCompleteDataChild::LeMultiAdvtParamComplete(le_multi_advt_param_complete),});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeMultiAdvt, child: CommandCompleteDataChild::LeMultiAdvtComplete(le_multi_advt_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeMultiAdvtParamCompletePacket::new(event)}
}
impl Into<EventPacket> for LeMultiAdvtParamCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeMultiAdvtParamCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
impl Into<LeMultiAdvtCompletePacket> for LeMultiAdvtParamCompleteBuilder { fn into(self) -> LeMultiAdvtCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeMultiAdvtSetDataData {advertising_data: Vec::<GapData>, advertising_instance: u8, }
#[derive(Debug, Clone)] pub struct LeMultiAdvtSetDataPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_multi_advt: Arc<LeMultiAdvtData>,le_multi_advt_set_data: Arc<LeMultiAdvtSetDataData>,}
#[derive(Debug)] pub struct LeMultiAdvtSetDataBuilder {pub advertising_data: Vec::<GapData>, pub advertising_instance: u8, }
impl LeMultiAdvtSetDataData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeMultiAdvtSetData".to_string(),    field: "advertising_data_size".to_string(),    wanted: 5,    got: bytes.len()});}let advertising_data_size = u8::from_le_bytes([bytes[4]]);let mut advertising_data: Vec::<GapData> = Vec::new();let mut parsable_ = &bytes[5..5 + (advertising_data_size as usize)];while parsable_.len() > 0 { match GapData::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];advertising_data.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}if bytes.len() < 37 { return Err(Error::InvalidLengthError{    obj: "LeMultiAdvtSetData".to_string(),    field: "advertising_instance".to_string(),    wanted: 37,    got: bytes.len()});}let advertising_instance = u8::from_le_bytes([bytes[36]]);Ok(Self {advertising_data, advertising_instance, })
}
fn write_to(&self, buffer: &mut BytesMut) {let advertising_data_bytes = self.advertising_data.iter().fold(0, |acc, x| acc + x.get_total_size());let advertising_data_size = u8::try_from(advertising_data_bytes).expect("payload size did not fit");buffer[4..5].copy_from_slice(&advertising_data_size.to_le_bytes()[0..1]);let mut vec_buffer_ = &mut buffer[5..];for e_ in &self.advertising_data { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}let advertising_instance = self.advertising_instance;buffer[36..37].copy_from_slice(&advertising_instance.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;/* Skipping advertising_data since it is padded */let ret = ret + 33;ret}
}
impl Packet for LeMultiAdvtSetDataPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeMultiAdvtSetDataPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_multi_advt = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeMultiAdvt(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMultiAdvt"),};let le_multi_advt_set_data = match &le_multi_advt.child {LeMultiAdvtDataChild::LeMultiAdvtSetData(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMultiAdvtSetData"),};Self {command,le_advertising_command,le_multi_advt,le_multi_advt_set_data,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_sub_cmd(&self) -> SubOcf{ self.le_multi_advt.as_ref().sub_cmd}
pub fn get_advertising_data(&self) -> &Vec::<GapData>{ &self.le_multi_advt_set_data.as_ref().advertising_data}
pub fn get_advertising_instance(&self) -> u8{ self.le_multi_advt_set_data.as_ref().advertising_instance}
}
impl Into<CommandPacket> for LeMultiAdvtSetDataPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeMultiAdvtSetDataPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl Into<LeMultiAdvtPacket> for LeMultiAdvtSetDataPacket { fn into(self) -> LeMultiAdvtPacket {LeMultiAdvtPacket::new(self.command) }}
impl LeMultiAdvtSetDataBuilder {pub fn build(self) -> LeMultiAdvtSetDataPacket {let le_multi_advt_set_data= Arc::new(LeMultiAdvtSetDataData {advertising_data: self.advertising_data, advertising_instance: self.advertising_instance, });let le_multi_advt= Arc::new(LeMultiAdvtData {sub_cmd: SubOcf::SetData, child: LeMultiAdvtDataChild::LeMultiAdvtSetData(le_multi_advt_set_data),});let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeMultiAdvt(le_multi_advt),});let command= Arc::new(CommandData {op_code: OpCode::LeMultiAdvt, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeMultiAdvtSetDataPacket::new(command)}
}
impl Into<CommandPacket> for LeMultiAdvtSetDataBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeMultiAdvtSetDataBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}
impl Into<LeMultiAdvtPacket> for LeMultiAdvtSetDataBuilder { fn into(self) -> LeMultiAdvtPacket { self.build().into() }}


#[derive(Debug)] struct LeMultiAdvtSetDataCompleteData {}
#[derive(Debug, Clone)] pub struct LeMultiAdvtSetDataCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_multi_advt_complete: Arc<LeMultiAdvtCompleteData>,le_multi_advt_set_data_complete: Arc<LeMultiAdvtSetDataCompleteData>,}
#[derive(Debug)] pub struct LeMultiAdvtSetDataCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeMultiAdvtSetDataCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeMultiAdvtSetDataCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeMultiAdvtSetDataCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_multi_advt_complete = match &command_complete.child {CommandCompleteDataChild::LeMultiAdvtComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMultiAdvtComplete"),};let le_multi_advt_set_data_complete = match &le_multi_advt_complete.child {LeMultiAdvtCompleteDataChild::LeMultiAdvtSetDataComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMultiAdvtSetDataComplete"),};Self {event,command_complete,le_multi_advt_complete,le_multi_advt_set_data_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_multi_advt_complete.as_ref().status}
pub fn get_sub_cmd(&self) -> SubOcf{ self.le_multi_advt_complete.as_ref().sub_cmd}
}
impl Into<EventPacket> for LeMultiAdvtSetDataCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeMultiAdvtSetDataCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl Into<LeMultiAdvtCompletePacket> for LeMultiAdvtSetDataCompletePacket { fn into(self) -> LeMultiAdvtCompletePacket {LeMultiAdvtCompletePacket::new(self.event) }}
impl LeMultiAdvtSetDataCompleteBuilder {pub fn build(self) -> LeMultiAdvtSetDataCompletePacket {let le_multi_advt_set_data_complete= Arc::new(LeMultiAdvtSetDataCompleteData {});let le_multi_advt_complete= Arc::new(LeMultiAdvtCompleteData {status: self.status, sub_cmd: SubOcf::SetData, child: LeMultiAdvtCompleteDataChild::LeMultiAdvtSetDataComplete(le_multi_advt_set_data_complete),});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeMultiAdvt, child: CommandCompleteDataChild::LeMultiAdvtComplete(le_multi_advt_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeMultiAdvtSetDataCompletePacket::new(event)}
}
impl Into<EventPacket> for LeMultiAdvtSetDataCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeMultiAdvtSetDataCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
impl Into<LeMultiAdvtCompletePacket> for LeMultiAdvtSetDataCompleteBuilder { fn into(self) -> LeMultiAdvtCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeMultiAdvtSetScanRespData {advertising_data: Vec::<GapData>, advertising_instance: u8, }
#[derive(Debug, Clone)] pub struct LeMultiAdvtSetScanRespPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_multi_advt: Arc<LeMultiAdvtData>,le_multi_advt_set_scan_resp: Arc<LeMultiAdvtSetScanRespData>,}
#[derive(Debug)] pub struct LeMultiAdvtSetScanRespBuilder {pub advertising_data: Vec::<GapData>, pub advertising_instance: u8, }
impl LeMultiAdvtSetScanRespData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeMultiAdvtSetScanResp".to_string(),    field: "advertising_data_size".to_string(),    wanted: 5,    got: bytes.len()});}let advertising_data_size = u8::from_le_bytes([bytes[4]]);let mut advertising_data: Vec::<GapData> = Vec::new();let mut parsable_ = &bytes[5..5 + (advertising_data_size as usize)];while parsable_.len() > 0 { match GapData::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];advertising_data.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}if bytes.len() < 37 { return Err(Error::InvalidLengthError{    obj: "LeMultiAdvtSetScanResp".to_string(),    field: "advertising_instance".to_string(),    wanted: 37,    got: bytes.len()});}let advertising_instance = u8::from_le_bytes([bytes[36]]);Ok(Self {advertising_data, advertising_instance, })
}
fn write_to(&self, buffer: &mut BytesMut) {let advertising_data_bytes = self.advertising_data.iter().fold(0, |acc, x| acc + x.get_total_size());let advertising_data_size = u8::try_from(advertising_data_bytes).expect("payload size did not fit");buffer[4..5].copy_from_slice(&advertising_data_size.to_le_bytes()[0..1]);let mut vec_buffer_ = &mut buffer[5..];for e_ in &self.advertising_data { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}let advertising_instance = self.advertising_instance;buffer[36..37].copy_from_slice(&advertising_instance.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;/* Skipping advertising_data since it is padded */let ret = ret + 33;ret}
}
impl Packet for LeMultiAdvtSetScanRespPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeMultiAdvtSetScanRespPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_multi_advt = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeMultiAdvt(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMultiAdvt"),};let le_multi_advt_set_scan_resp = match &le_multi_advt.child {LeMultiAdvtDataChild::LeMultiAdvtSetScanResp(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMultiAdvtSetScanResp"),};Self {command,le_advertising_command,le_multi_advt,le_multi_advt_set_scan_resp,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_sub_cmd(&self) -> SubOcf{ self.le_multi_advt.as_ref().sub_cmd}
pub fn get_advertising_data(&self) -> &Vec::<GapData>{ &self.le_multi_advt_set_scan_resp.as_ref().advertising_data}
pub fn get_advertising_instance(&self) -> u8{ self.le_multi_advt_set_scan_resp.as_ref().advertising_instance}
}
impl Into<CommandPacket> for LeMultiAdvtSetScanRespPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeMultiAdvtSetScanRespPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl Into<LeMultiAdvtPacket> for LeMultiAdvtSetScanRespPacket { fn into(self) -> LeMultiAdvtPacket {LeMultiAdvtPacket::new(self.command) }}
impl LeMultiAdvtSetScanRespBuilder {pub fn build(self) -> LeMultiAdvtSetScanRespPacket {let le_multi_advt_set_scan_resp= Arc::new(LeMultiAdvtSetScanRespData {advertising_data: self.advertising_data, advertising_instance: self.advertising_instance, });let le_multi_advt= Arc::new(LeMultiAdvtData {sub_cmd: SubOcf::SetScanResp, child: LeMultiAdvtDataChild::LeMultiAdvtSetScanResp(le_multi_advt_set_scan_resp),});let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeMultiAdvt(le_multi_advt),});let command= Arc::new(CommandData {op_code: OpCode::LeMultiAdvt, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeMultiAdvtSetScanRespPacket::new(command)}
}
impl Into<CommandPacket> for LeMultiAdvtSetScanRespBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeMultiAdvtSetScanRespBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}
impl Into<LeMultiAdvtPacket> for LeMultiAdvtSetScanRespBuilder { fn into(self) -> LeMultiAdvtPacket { self.build().into() }}


#[derive(Debug)] struct LeMultiAdvtSetScanRespCompleteData {}
#[derive(Debug, Clone)] pub struct LeMultiAdvtSetScanRespCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_multi_advt_complete: Arc<LeMultiAdvtCompleteData>,le_multi_advt_set_scan_resp_complete: Arc<LeMultiAdvtSetScanRespCompleteData>,}
#[derive(Debug)] pub struct LeMultiAdvtSetScanRespCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeMultiAdvtSetScanRespCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeMultiAdvtSetScanRespCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeMultiAdvtSetScanRespCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_multi_advt_complete = match &command_complete.child {CommandCompleteDataChild::LeMultiAdvtComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMultiAdvtComplete"),};let le_multi_advt_set_scan_resp_complete = match &le_multi_advt_complete.child {LeMultiAdvtCompleteDataChild::LeMultiAdvtSetScanRespComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMultiAdvtSetScanRespComplete"),};Self {event,command_complete,le_multi_advt_complete,le_multi_advt_set_scan_resp_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_multi_advt_complete.as_ref().status}
pub fn get_sub_cmd(&self) -> SubOcf{ self.le_multi_advt_complete.as_ref().sub_cmd}
}
impl Into<EventPacket> for LeMultiAdvtSetScanRespCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeMultiAdvtSetScanRespCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl Into<LeMultiAdvtCompletePacket> for LeMultiAdvtSetScanRespCompletePacket { fn into(self) -> LeMultiAdvtCompletePacket {LeMultiAdvtCompletePacket::new(self.event) }}
impl LeMultiAdvtSetScanRespCompleteBuilder {pub fn build(self) -> LeMultiAdvtSetScanRespCompletePacket {let le_multi_advt_set_scan_resp_complete= Arc::new(LeMultiAdvtSetScanRespCompleteData {});let le_multi_advt_complete= Arc::new(LeMultiAdvtCompleteData {status: self.status, sub_cmd: SubOcf::SetScanResp, child: LeMultiAdvtCompleteDataChild::LeMultiAdvtSetScanRespComplete(le_multi_advt_set_scan_resp_complete),});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeMultiAdvt, child: CommandCompleteDataChild::LeMultiAdvtComplete(le_multi_advt_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeMultiAdvtSetScanRespCompletePacket::new(event)}
}
impl Into<EventPacket> for LeMultiAdvtSetScanRespCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeMultiAdvtSetScanRespCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
impl Into<LeMultiAdvtCompletePacket> for LeMultiAdvtSetScanRespCompleteBuilder { fn into(self) -> LeMultiAdvtCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeMultiAdvtSetRandomAddrData {random_address: Address, advertising_instance: u8, }
#[derive(Debug, Clone)] pub struct LeMultiAdvtSetRandomAddrPacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_multi_advt: Arc<LeMultiAdvtData>,le_multi_advt_set_random_addr: Arc<LeMultiAdvtSetRandomAddrData>,}
#[derive(Debug)] pub struct LeMultiAdvtSetRandomAddrBuilder {pub random_address: Address, pub advertising_instance: u8, }
impl LeMultiAdvtSetRandomAddrData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeMultiAdvtSetRandomAddr".to_string(),    field: "random_address".to_string(),    wanted: 10,    got: bytes.len()});}let random_address = bytes[4..10].try_into().unwrap();if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "LeMultiAdvtSetRandomAddr".to_string(),    field: "advertising_instance".to_string(),    wanted: 11,    got: bytes.len()});}let advertising_instance = u8::from_le_bytes([bytes[10]]);Ok(Self {random_address, advertising_instance, })
}
fn write_to(&self, buffer: &mut BytesMut) {let random_address: [u8; 6] = self.random_address.into();buffer[4..10].copy_from_slice(&random_address);let advertising_instance = self.advertising_instance;buffer[10..11].copy_from_slice(&advertising_instance.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for LeMultiAdvtSetRandomAddrPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeMultiAdvtSetRandomAddrPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_multi_advt = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeMultiAdvt(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMultiAdvt"),};let le_multi_advt_set_random_addr = match &le_multi_advt.child {LeMultiAdvtDataChild::LeMultiAdvtSetRandomAddr(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMultiAdvtSetRandomAddr"),};Self {command,le_advertising_command,le_multi_advt,le_multi_advt_set_random_addr,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_sub_cmd(&self) -> SubOcf{ self.le_multi_advt.as_ref().sub_cmd}
pub fn get_random_address(&self) -> Address{ self.le_multi_advt_set_random_addr.as_ref().random_address}
pub fn get_advertising_instance(&self) -> u8{ self.le_multi_advt_set_random_addr.as_ref().advertising_instance}
}
impl Into<CommandPacket> for LeMultiAdvtSetRandomAddrPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeMultiAdvtSetRandomAddrPacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl Into<LeMultiAdvtPacket> for LeMultiAdvtSetRandomAddrPacket { fn into(self) -> LeMultiAdvtPacket {LeMultiAdvtPacket::new(self.command) }}
impl LeMultiAdvtSetRandomAddrBuilder {pub fn build(self) -> LeMultiAdvtSetRandomAddrPacket {let le_multi_advt_set_random_addr= Arc::new(LeMultiAdvtSetRandomAddrData {random_address: self.random_address, advertising_instance: self.advertising_instance, });let le_multi_advt= Arc::new(LeMultiAdvtData {sub_cmd: SubOcf::SetRandomAddr, child: LeMultiAdvtDataChild::LeMultiAdvtSetRandomAddr(le_multi_advt_set_random_addr),});let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeMultiAdvt(le_multi_advt),});let command= Arc::new(CommandData {op_code: OpCode::LeMultiAdvt, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeMultiAdvtSetRandomAddrPacket::new(command)}
}
impl Into<CommandPacket> for LeMultiAdvtSetRandomAddrBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeMultiAdvtSetRandomAddrBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}
impl Into<LeMultiAdvtPacket> for LeMultiAdvtSetRandomAddrBuilder { fn into(self) -> LeMultiAdvtPacket { self.build().into() }}


#[derive(Debug)] struct LeMultiAdvtSetRandomAddrCompleteData {}
#[derive(Debug, Clone)] pub struct LeMultiAdvtSetRandomAddrCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_multi_advt_complete: Arc<LeMultiAdvtCompleteData>,le_multi_advt_set_random_addr_complete: Arc<LeMultiAdvtSetRandomAddrCompleteData>,}
#[derive(Debug)] pub struct LeMultiAdvtSetRandomAddrCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeMultiAdvtSetRandomAddrCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeMultiAdvtSetRandomAddrCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeMultiAdvtSetRandomAddrCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_multi_advt_complete = match &command_complete.child {CommandCompleteDataChild::LeMultiAdvtComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMultiAdvtComplete"),};let le_multi_advt_set_random_addr_complete = match &le_multi_advt_complete.child {LeMultiAdvtCompleteDataChild::LeMultiAdvtSetRandomAddrComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMultiAdvtSetRandomAddrComplete"),};Self {event,command_complete,le_multi_advt_complete,le_multi_advt_set_random_addr_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_multi_advt_complete.as_ref().status}
pub fn get_sub_cmd(&self) -> SubOcf{ self.le_multi_advt_complete.as_ref().sub_cmd}
}
impl Into<EventPacket> for LeMultiAdvtSetRandomAddrCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeMultiAdvtSetRandomAddrCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl Into<LeMultiAdvtCompletePacket> for LeMultiAdvtSetRandomAddrCompletePacket { fn into(self) -> LeMultiAdvtCompletePacket {LeMultiAdvtCompletePacket::new(self.event) }}
impl LeMultiAdvtSetRandomAddrCompleteBuilder {pub fn build(self) -> LeMultiAdvtSetRandomAddrCompletePacket {let le_multi_advt_set_random_addr_complete= Arc::new(LeMultiAdvtSetRandomAddrCompleteData {});let le_multi_advt_complete= Arc::new(LeMultiAdvtCompleteData {status: self.status, sub_cmd: SubOcf::SetRandomAddr, child: LeMultiAdvtCompleteDataChild::LeMultiAdvtSetRandomAddrComplete(le_multi_advt_set_random_addr_complete),});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeMultiAdvt, child: CommandCompleteDataChild::LeMultiAdvtComplete(le_multi_advt_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeMultiAdvtSetRandomAddrCompletePacket::new(event)}
}
impl Into<EventPacket> for LeMultiAdvtSetRandomAddrCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeMultiAdvtSetRandomAddrCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
impl Into<LeMultiAdvtCompletePacket> for LeMultiAdvtSetRandomAddrCompleteBuilder { fn into(self) -> LeMultiAdvtCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeMultiAdvtSetEnableData {advertising_enable: Enable, advertising_instance: u8, }
#[derive(Debug, Clone)] pub struct LeMultiAdvtSetEnablePacket {command: Arc<CommandData>,le_advertising_command: Arc<LeAdvertisingCommandData>,le_multi_advt: Arc<LeMultiAdvtData>,le_multi_advt_set_enable: Arc<LeMultiAdvtSetEnableData>,}
#[derive(Debug)] pub struct LeMultiAdvtSetEnableBuilder {pub advertising_enable: Enable, pub advertising_instance: u8, }
impl LeMultiAdvtSetEnableData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeMultiAdvtSetEnable".to_string(),    field: "advertising_enable".to_string(),    wanted: 5,    got: bytes.len()});}let advertising_enable = u8::from_le_bytes([bytes[4]]);let advertising_enable = Enable::from_u8(advertising_enable).unwrap();if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeMultiAdvtSetEnable".to_string(),    field: "advertising_instance".to_string(),    wanted: 6,    got: bytes.len()});}let advertising_instance = u8::from_le_bytes([bytes[5]]);Ok(Self {advertising_enable, advertising_instance, })
}
fn write_to(&self, buffer: &mut BytesMut) {let advertising_enable = self.advertising_enable.to_u8().unwrap();buffer[4..5].copy_from_slice(&advertising_enable.to_le_bytes()[0..1]);let advertising_instance = self.advertising_instance;buffer[5..6].copy_from_slice(&advertising_instance.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for LeMultiAdvtSetEnablePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeMultiAdvtSetEnablePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_advertising_command = match &command.child {CommandDataChild::LeAdvertisingCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingCommand"),};let le_multi_advt = match &le_advertising_command.child {LeAdvertisingCommandDataChild::LeMultiAdvt(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMultiAdvt"),};let le_multi_advt_set_enable = match &le_multi_advt.child {LeMultiAdvtDataChild::LeMultiAdvtSetEnable(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMultiAdvtSetEnable"),};Self {command,le_advertising_command,le_multi_advt,le_multi_advt_set_enable,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_sub_cmd(&self) -> SubOcf{ self.le_multi_advt.as_ref().sub_cmd}
pub fn get_advertising_enable(&self) -> Enable{ self.le_multi_advt_set_enable.as_ref().advertising_enable}
pub fn get_advertising_instance(&self) -> u8{ self.le_multi_advt_set_enable.as_ref().advertising_instance}
}
impl Into<CommandPacket> for LeMultiAdvtSetEnablePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeAdvertisingCommandPacket> for LeMultiAdvtSetEnablePacket { fn into(self) -> LeAdvertisingCommandPacket {LeAdvertisingCommandPacket::new(self.command) }}
impl Into<LeMultiAdvtPacket> for LeMultiAdvtSetEnablePacket { fn into(self) -> LeMultiAdvtPacket {LeMultiAdvtPacket::new(self.command) }}
impl LeMultiAdvtSetEnableBuilder {pub fn build(self) -> LeMultiAdvtSetEnablePacket {let le_multi_advt_set_enable= Arc::new(LeMultiAdvtSetEnableData {advertising_enable: self.advertising_enable, advertising_instance: self.advertising_instance, });let le_multi_advt= Arc::new(LeMultiAdvtData {sub_cmd: SubOcf::SetEnable, child: LeMultiAdvtDataChild::LeMultiAdvtSetEnable(le_multi_advt_set_enable),});let le_advertising_command= Arc::new(LeAdvertisingCommandData {child: LeAdvertisingCommandDataChild::LeMultiAdvt(le_multi_advt),});let command= Arc::new(CommandData {op_code: OpCode::LeMultiAdvt, child: CommandDataChild::LeAdvertisingCommand(le_advertising_command),});LeMultiAdvtSetEnablePacket::new(command)}
}
impl Into<CommandPacket> for LeMultiAdvtSetEnableBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeAdvertisingCommandPacket> for LeMultiAdvtSetEnableBuilder { fn into(self) -> LeAdvertisingCommandPacket { self.build().into() }}
impl Into<LeMultiAdvtPacket> for LeMultiAdvtSetEnableBuilder { fn into(self) -> LeMultiAdvtPacket { self.build().into() }}


#[derive(Debug)] struct LeMultiAdvtSetEnableCompleteData {}
#[derive(Debug, Clone)] pub struct LeMultiAdvtSetEnableCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_multi_advt_complete: Arc<LeMultiAdvtCompleteData>,le_multi_advt_set_enable_complete: Arc<LeMultiAdvtSetEnableCompleteData>,}
#[derive(Debug)] pub struct LeMultiAdvtSetEnableCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeMultiAdvtSetEnableCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeMultiAdvtSetEnableCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeMultiAdvtSetEnableCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_multi_advt_complete = match &command_complete.child {CommandCompleteDataChild::LeMultiAdvtComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMultiAdvtComplete"),};let le_multi_advt_set_enable_complete = match &le_multi_advt_complete.child {LeMultiAdvtCompleteDataChild::LeMultiAdvtSetEnableComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMultiAdvtSetEnableComplete"),};Self {event,command_complete,le_multi_advt_complete,le_multi_advt_set_enable_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_multi_advt_complete.as_ref().status}
pub fn get_sub_cmd(&self) -> SubOcf{ self.le_multi_advt_complete.as_ref().sub_cmd}
}
impl Into<EventPacket> for LeMultiAdvtSetEnableCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeMultiAdvtSetEnableCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl Into<LeMultiAdvtCompletePacket> for LeMultiAdvtSetEnableCompletePacket { fn into(self) -> LeMultiAdvtCompletePacket {LeMultiAdvtCompletePacket::new(self.event) }}
impl LeMultiAdvtSetEnableCompleteBuilder {pub fn build(self) -> LeMultiAdvtSetEnableCompletePacket {let le_multi_advt_set_enable_complete= Arc::new(LeMultiAdvtSetEnableCompleteData {});let le_multi_advt_complete= Arc::new(LeMultiAdvtCompleteData {status: self.status, sub_cmd: SubOcf::SetEnable, child: LeMultiAdvtCompleteDataChild::LeMultiAdvtSetEnableComplete(le_multi_advt_set_enable_complete),});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeMultiAdvt, child: CommandCompleteDataChild::LeMultiAdvtComplete(le_multi_advt_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeMultiAdvtSetEnableCompletePacket::new(event)}
}
impl Into<EventPacket> for LeMultiAdvtSetEnableCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeMultiAdvtSetEnableCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
impl Into<LeMultiAdvtCompletePacket> for LeMultiAdvtSetEnableCompleteBuilder { fn into(self) -> LeMultiAdvtCompletePacket { self.build().into() }}


#[derive(Debug)] enum LeBatchScanDataChild {LeBatchScanEnable(Arc<LeBatchScanEnableData>),LeBatchScanSetStorageParameters(Arc<LeBatchScanSetStorageParametersData>),LeBatchScanSetScanParameters(Arc<LeBatchScanSetScanParametersData>),LeBatchScanReadResultParameters(Arc<LeBatchScanReadResultParametersData>),None,}
impl LeBatchScanDataChild {fn get_total_size(&self) -> usize {match self {LeBatchScanDataChild::LeBatchScanEnable(value) => value.get_total_size(),LeBatchScanDataChild::LeBatchScanSetStorageParameters(value) => value.get_total_size(),LeBatchScanDataChild::LeBatchScanSetScanParameters(value) => value.get_total_size(),LeBatchScanDataChild::LeBatchScanReadResultParameters(value) => value.get_total_size(),LeBatchScanDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LeBatchScanChild {LeBatchScanEnable(LeBatchScanEnablePacket),LeBatchScanSetStorageParameters(LeBatchScanSetStorageParametersPacket),LeBatchScanSetScanParameters(LeBatchScanSetScanParametersPacket),LeBatchScanReadResultParameters(LeBatchScanReadResultParametersPacket),None,}
#[derive(Debug)] struct LeBatchScanData {batch_scan_opcode: BatchScanOpcode, child: LeBatchScanDataChild,}
#[derive(Debug, Clone)] pub struct LeBatchScanPacket {command: Arc<CommandData>,le_scanning_command: Arc<LeScanningCommandData>,le_batch_scan: Arc<LeBatchScanData>,}
#[derive(Debug)] pub struct LeBatchScanBuilder {pub batch_scan_opcode: BatchScanOpcode, }
impl LeBatchScanData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeBatchScan".to_string(),    field: "batch_scan_opcode".to_string(),    wanted: 4,    got: bytes.len()});}let batch_scan_opcode = u8::from_le_bytes([bytes[3]]);let batch_scan_opcode = BatchScanOpcode::from_u8(batch_scan_opcode).unwrap();let child = match batch_scan_opcode {BatchScanOpcode::ReadResultParameters if LeBatchScanReadResultParametersData::conforms(&bytes[..]) => {LeBatchScanDataChild::LeBatchScanReadResultParameters(Arc::new(LeBatchScanReadResultParametersData::parse(&bytes[..])?))}
BatchScanOpcode::Enable if LeBatchScanEnableData::conforms(&bytes[..]) => {LeBatchScanDataChild::LeBatchScanEnable(Arc::new(LeBatchScanEnableData::parse(&bytes[..])?))}
BatchScanOpcode::SetStorageParameters if LeBatchScanSetStorageParametersData::conforms(&bytes[..]) => {LeBatchScanDataChild::LeBatchScanSetStorageParameters(Arc::new(LeBatchScanSetStorageParametersData::parse(&bytes[..])?))}
BatchScanOpcode::SetScanParameters if LeBatchScanSetScanParametersData::conforms(&bytes[..]) => {LeBatchScanDataChild::LeBatchScanSetScanParameters(Arc::new(LeBatchScanSetScanParametersData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "batch_scan_opcode".to_string(), value: v as u64}),};
Ok(Self {batch_scan_opcode, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let batch_scan_opcode = self.batch_scan_opcode.to_u8().unwrap();buffer[3..4].copy_from_slice(&batch_scan_opcode.to_le_bytes()[0..1]);match &self.child {LeBatchScanDataChild::LeBatchScanEnable(value) => value.write_to(buffer),LeBatchScanDataChild::LeBatchScanSetStorageParameters(value) => value.write_to(buffer),LeBatchScanDataChild::LeBatchScanSetScanParameters(value) => value.write_to(buffer),LeBatchScanDataChild::LeBatchScanReadResultParameters(value) => value.write_to(buffer),LeBatchScanDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for LeBatchScanPacket { type ResponseType = LeBatchScanCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeBatchScanCompletePacket::new(pkt.event.clone()) }}impl Packet for LeBatchScanPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeBatchScanPacket { pub fn specialize(&self) -> LeBatchScanChild { match &self.le_batch_scan.child {LeBatchScanDataChild::LeBatchScanEnable(_) => LeBatchScanChild::LeBatchScanEnable(LeBatchScanEnablePacket::new(self.command.clone())),LeBatchScanDataChild::LeBatchScanSetStorageParameters(_) => LeBatchScanChild::LeBatchScanSetStorageParameters(LeBatchScanSetStorageParametersPacket::new(self.command.clone())),LeBatchScanDataChild::LeBatchScanSetScanParameters(_) => LeBatchScanChild::LeBatchScanSetScanParameters(LeBatchScanSetScanParametersPacket::new(self.command.clone())),LeBatchScanDataChild::LeBatchScanReadResultParameters(_) => LeBatchScanChild::LeBatchScanReadResultParameters(LeBatchScanReadResultParametersPacket::new(self.command.clone())),LeBatchScanDataChild::None => LeBatchScanChild::None,}} fn new(root: Arc<CommandData>) -> Self {let command = root;let le_scanning_command = match &command.child {CommandDataChild::LeScanningCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanningCommand"),};let le_batch_scan = match &le_scanning_command.child {LeScanningCommandDataChild::LeBatchScan(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScan"),};Self {command,le_scanning_command,le_batch_scan,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_batch_scan_opcode(&self) -> BatchScanOpcode{ self.le_batch_scan.as_ref().batch_scan_opcode}
}
impl Into<CommandPacket> for LeBatchScanPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeScanningCommandPacket> for LeBatchScanPacket { fn into(self) -> LeScanningCommandPacket {LeScanningCommandPacket::new(self.command) }}
impl CommandExpectations for LeBatchScanBuilder { type ResponseType = LeBatchScanCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeBatchScanCompletePacket::new(pkt.event.clone()) }}impl LeBatchScanBuilder {pub fn build(self) -> LeBatchScanPacket {let le_batch_scan= Arc::new(LeBatchScanData {batch_scan_opcode: self.batch_scan_opcode, child: LeBatchScanDataChild::None,});let le_scanning_command= Arc::new(LeScanningCommandData {child: LeScanningCommandDataChild::LeBatchScan(le_batch_scan),});let command= Arc::new(CommandData {op_code: OpCode::LeBatchScan, child: CommandDataChild::LeScanningCommand(le_scanning_command),});LeBatchScanPacket::new(command)}
}
impl Into<CommandPacket> for LeBatchScanBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeScanningCommandPacket> for LeBatchScanBuilder { fn into(self) -> LeScanningCommandPacket { self.build().into() }}


#[derive(Debug)] enum LeBatchScanCompleteDataChild {LeBatchScanEnableComplete(Arc<LeBatchScanEnableCompleteData>),LeBatchScanSetStorageParametersComplete(Arc<LeBatchScanSetStorageParametersCompleteData>),LeBatchScanSetScanParametersComplete(Arc<LeBatchScanSetScanParametersCompleteData>),LeBatchScanReadResultParametersCompleteRaw(Arc<LeBatchScanReadResultParametersCompleteRawData>),LeBatchScanReadResultParametersComplete(Arc<LeBatchScanReadResultParametersCompleteData>),None,}
impl LeBatchScanCompleteDataChild {fn get_total_size(&self) -> usize {match self {LeBatchScanCompleteDataChild::LeBatchScanEnableComplete(value) => value.get_total_size(),LeBatchScanCompleteDataChild::LeBatchScanSetStorageParametersComplete(value) => value.get_total_size(),LeBatchScanCompleteDataChild::LeBatchScanSetScanParametersComplete(value) => value.get_total_size(),LeBatchScanCompleteDataChild::LeBatchScanReadResultParametersCompleteRaw(value) => value.get_total_size(),LeBatchScanCompleteDataChild::LeBatchScanReadResultParametersComplete(value) => value.get_total_size(),LeBatchScanCompleteDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LeBatchScanCompleteChild {LeBatchScanEnableComplete(LeBatchScanEnableCompletePacket),LeBatchScanSetStorageParametersComplete(LeBatchScanSetStorageParametersCompletePacket),LeBatchScanSetScanParametersComplete(LeBatchScanSetScanParametersCompletePacket),LeBatchScanReadResultParametersCompleteRaw(LeBatchScanReadResultParametersCompleteRawPacket),LeBatchScanReadResultParametersComplete(LeBatchScanReadResultParametersCompletePacket),None,}
#[derive(Debug)] struct LeBatchScanCompleteData {status: ErrorCode, batch_scan_opcode: BatchScanOpcode, child: LeBatchScanCompleteDataChild,}
#[derive(Debug, Clone)] pub struct LeBatchScanCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_batch_scan_complete: Arc<LeBatchScanCompleteData>,}
#[derive(Debug)] pub struct LeBatchScanCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub batch_scan_opcode: BatchScanOpcode, }
impl LeBatchScanCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeBatchScanComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeBatchScanComplete".to_string(),    field: "batch_scan_opcode".to_string(),    wanted: 7,    got: bytes.len()});}let batch_scan_opcode = u8::from_le_bytes([bytes[6]]);let batch_scan_opcode = BatchScanOpcode::from_u8(batch_scan_opcode).unwrap();let child = match batch_scan_opcode {BatchScanOpcode::SetScanParameters if LeBatchScanSetScanParametersCompleteData::conforms(&bytes[..]) => {LeBatchScanCompleteDataChild::LeBatchScanSetScanParametersComplete(Arc::new(LeBatchScanSetScanParametersCompleteData::parse(&bytes[..])?))}
BatchScanOpcode::ReadResultParameters if LeBatchScanReadResultParametersCompleteData::conforms(&bytes[..]) => {LeBatchScanCompleteDataChild::LeBatchScanReadResultParametersComplete(Arc::new(LeBatchScanReadResultParametersCompleteData::parse(&bytes[..])?))}
BatchScanOpcode::ReadResultParameters if LeBatchScanReadResultParametersCompleteRawData::conforms(&bytes[..]) => {LeBatchScanCompleteDataChild::LeBatchScanReadResultParametersCompleteRaw(Arc::new(LeBatchScanReadResultParametersCompleteRawData::parse(&bytes[..])?))}
BatchScanOpcode::Enable if LeBatchScanEnableCompleteData::conforms(&bytes[..]) => {LeBatchScanCompleteDataChild::LeBatchScanEnableComplete(Arc::new(LeBatchScanEnableCompleteData::parse(&bytes[..])?))}
BatchScanOpcode::SetStorageParameters if LeBatchScanSetStorageParametersCompleteData::conforms(&bytes[..]) => {LeBatchScanCompleteDataChild::LeBatchScanSetStorageParametersComplete(Arc::new(LeBatchScanSetStorageParametersCompleteData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "batch_scan_opcode".to_string(), value: v as u64}),};
Ok(Self {status, batch_scan_opcode, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let batch_scan_opcode = self.batch_scan_opcode.to_u8().unwrap();buffer[6..7].copy_from_slice(&batch_scan_opcode.to_le_bytes()[0..1]);match &self.child {LeBatchScanCompleteDataChild::LeBatchScanEnableComplete(value) => value.write_to(buffer),LeBatchScanCompleteDataChild::LeBatchScanSetStorageParametersComplete(value) => value.write_to(buffer),LeBatchScanCompleteDataChild::LeBatchScanSetScanParametersComplete(value) => value.write_to(buffer),LeBatchScanCompleteDataChild::LeBatchScanReadResultParametersCompleteRaw(value) => value.write_to(buffer),LeBatchScanCompleteDataChild::LeBatchScanReadResultParametersComplete(value) => value.write_to(buffer),LeBatchScanCompleteDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for LeBatchScanCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeBatchScanCompletePacket { pub fn specialize(&self) -> LeBatchScanCompleteChild { match &self.le_batch_scan_complete.child {LeBatchScanCompleteDataChild::LeBatchScanEnableComplete(_) => LeBatchScanCompleteChild::LeBatchScanEnableComplete(LeBatchScanEnableCompletePacket::new(self.event.clone())),LeBatchScanCompleteDataChild::LeBatchScanSetStorageParametersComplete(_) => LeBatchScanCompleteChild::LeBatchScanSetStorageParametersComplete(LeBatchScanSetStorageParametersCompletePacket::new(self.event.clone())),LeBatchScanCompleteDataChild::LeBatchScanSetScanParametersComplete(_) => LeBatchScanCompleteChild::LeBatchScanSetScanParametersComplete(LeBatchScanSetScanParametersCompletePacket::new(self.event.clone())),LeBatchScanCompleteDataChild::LeBatchScanReadResultParametersCompleteRaw(_) => LeBatchScanCompleteChild::LeBatchScanReadResultParametersCompleteRaw(LeBatchScanReadResultParametersCompleteRawPacket::new(self.event.clone())),LeBatchScanCompleteDataChild::LeBatchScanReadResultParametersComplete(_) => LeBatchScanCompleteChild::LeBatchScanReadResultParametersComplete(LeBatchScanReadResultParametersCompletePacket::new(self.event.clone())),LeBatchScanCompleteDataChild::None => LeBatchScanCompleteChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_batch_scan_complete = match &command_complete.child {CommandCompleteDataChild::LeBatchScanComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScanComplete"),};Self {event,command_complete,le_batch_scan_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_batch_scan_complete.as_ref().status}
pub fn get_batch_scan_opcode(&self) -> BatchScanOpcode{ self.le_batch_scan_complete.as_ref().batch_scan_opcode}
}
impl Into<EventPacket> for LeBatchScanCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeBatchScanCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeBatchScanCompleteBuilder {pub fn build(self) -> LeBatchScanCompletePacket {let le_batch_scan_complete= Arc::new(LeBatchScanCompleteData {status: self.status, batch_scan_opcode: self.batch_scan_opcode, child: LeBatchScanCompleteDataChild::None,});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeBatchScan, child: CommandCompleteDataChild::LeBatchScanComplete(le_batch_scan_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeBatchScanCompletePacket::new(event)}
}
impl Into<EventPacket> for LeBatchScanCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeBatchScanCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeBatchScanEnableData {enable: Enable, }
#[derive(Debug, Clone)] pub struct LeBatchScanEnablePacket {command: Arc<CommandData>,le_scanning_command: Arc<LeScanningCommandData>,le_batch_scan: Arc<LeBatchScanData>,le_batch_scan_enable: Arc<LeBatchScanEnableData>,}
#[derive(Debug)] pub struct LeBatchScanEnableBuilder {pub enable: Enable, }
impl LeBatchScanEnableData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeBatchScanEnable".to_string(),    field: "enable".to_string(),    wanted: 5,    got: bytes.len()});}let enable = u8::from_le_bytes([bytes[4]]);let enable = Enable::from_u8(enable).unwrap();Ok(Self {enable, })
}
fn write_to(&self, buffer: &mut BytesMut) {let enable = self.enable.to_u8().unwrap();buffer[4..5].copy_from_slice(&enable.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeBatchScanEnablePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeBatchScanEnablePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_scanning_command = match &command.child {CommandDataChild::LeScanningCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanningCommand"),};let le_batch_scan = match &le_scanning_command.child {LeScanningCommandDataChild::LeBatchScan(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScan"),};let le_batch_scan_enable = match &le_batch_scan.child {LeBatchScanDataChild::LeBatchScanEnable(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScanEnable"),};Self {command,le_scanning_command,le_batch_scan,le_batch_scan_enable,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_batch_scan_opcode(&self) -> BatchScanOpcode{ self.le_batch_scan.as_ref().batch_scan_opcode}
pub fn get_enable(&self) -> Enable{ self.le_batch_scan_enable.as_ref().enable}
}
impl Into<CommandPacket> for LeBatchScanEnablePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeScanningCommandPacket> for LeBatchScanEnablePacket { fn into(self) -> LeScanningCommandPacket {LeScanningCommandPacket::new(self.command) }}
impl Into<LeBatchScanPacket> for LeBatchScanEnablePacket { fn into(self) -> LeBatchScanPacket {LeBatchScanPacket::new(self.command) }}
impl LeBatchScanEnableBuilder {pub fn build(self) -> LeBatchScanEnablePacket {let le_batch_scan_enable= Arc::new(LeBatchScanEnableData {enable: self.enable, });let le_batch_scan= Arc::new(LeBatchScanData {batch_scan_opcode: BatchScanOpcode::Enable, child: LeBatchScanDataChild::LeBatchScanEnable(le_batch_scan_enable),});let le_scanning_command= Arc::new(LeScanningCommandData {child: LeScanningCommandDataChild::LeBatchScan(le_batch_scan),});let command= Arc::new(CommandData {op_code: OpCode::LeBatchScan, child: CommandDataChild::LeScanningCommand(le_scanning_command),});LeBatchScanEnablePacket::new(command)}
}
impl Into<CommandPacket> for LeBatchScanEnableBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeScanningCommandPacket> for LeBatchScanEnableBuilder { fn into(self) -> LeScanningCommandPacket { self.build().into() }}
impl Into<LeBatchScanPacket> for LeBatchScanEnableBuilder { fn into(self) -> LeBatchScanPacket { self.build().into() }}


#[derive(Debug)] struct LeBatchScanEnableCompleteData {}
#[derive(Debug, Clone)] pub struct LeBatchScanEnableCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_batch_scan_complete: Arc<LeBatchScanCompleteData>,le_batch_scan_enable_complete: Arc<LeBatchScanEnableCompleteData>,}
#[derive(Debug)] pub struct LeBatchScanEnableCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeBatchScanEnableCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeBatchScanEnableCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeBatchScanEnableCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_batch_scan_complete = match &command_complete.child {CommandCompleteDataChild::LeBatchScanComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScanComplete"),};let le_batch_scan_enable_complete = match &le_batch_scan_complete.child {LeBatchScanCompleteDataChild::LeBatchScanEnableComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScanEnableComplete"),};Self {event,command_complete,le_batch_scan_complete,le_batch_scan_enable_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_batch_scan_complete.as_ref().status}
pub fn get_batch_scan_opcode(&self) -> BatchScanOpcode{ self.le_batch_scan_complete.as_ref().batch_scan_opcode}
}
impl Into<EventPacket> for LeBatchScanEnableCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeBatchScanEnableCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl Into<LeBatchScanCompletePacket> for LeBatchScanEnableCompletePacket { fn into(self) -> LeBatchScanCompletePacket {LeBatchScanCompletePacket::new(self.event) }}
impl LeBatchScanEnableCompleteBuilder {pub fn build(self) -> LeBatchScanEnableCompletePacket {let le_batch_scan_enable_complete= Arc::new(LeBatchScanEnableCompleteData {});let le_batch_scan_complete= Arc::new(LeBatchScanCompleteData {status: self.status, batch_scan_opcode: BatchScanOpcode::Enable, child: LeBatchScanCompleteDataChild::LeBatchScanEnableComplete(le_batch_scan_enable_complete),});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeBatchScan, child: CommandCompleteDataChild::LeBatchScanComplete(le_batch_scan_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeBatchScanEnableCompletePacket::new(event)}
}
impl Into<EventPacket> for LeBatchScanEnableCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeBatchScanEnableCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
impl Into<LeBatchScanCompletePacket> for LeBatchScanEnableCompleteBuilder { fn into(self) -> LeBatchScanCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeBatchScanSetStorageParametersData {batch_scan_full_max_percentage: u8, batch_scan_truncated_max_percentage: u8, batch_scan_notify_threshold_percentage: u8, }
#[derive(Debug, Clone)] pub struct LeBatchScanSetStorageParametersPacket {command: Arc<CommandData>,le_scanning_command: Arc<LeScanningCommandData>,le_batch_scan: Arc<LeBatchScanData>,le_batch_scan_set_storage_parameters: Arc<LeBatchScanSetStorageParametersData>,}
#[derive(Debug)] pub struct LeBatchScanSetStorageParametersBuilder {pub batch_scan_full_max_percentage: u8, pub batch_scan_truncated_max_percentage: u8, pub batch_scan_notify_threshold_percentage: u8, }
impl LeBatchScanSetStorageParametersData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeBatchScanSetStorageParameters".to_string(),    field: "batch_scan_full_max_percentage".to_string(),    wanted: 5,    got: bytes.len()});}let batch_scan_full_max_percentage = u8::from_le_bytes([bytes[4]]);if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeBatchScanSetStorageParameters".to_string(),    field: "batch_scan_truncated_max_percentage".to_string(),    wanted: 6,    got: bytes.len()});}let batch_scan_truncated_max_percentage = u8::from_le_bytes([bytes[5]]);if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeBatchScanSetStorageParameters".to_string(),    field: "batch_scan_notify_threshold_percentage".to_string(),    wanted: 7,    got: bytes.len()});}let batch_scan_notify_threshold_percentage = u8::from_le_bytes([bytes[6]]);Ok(Self {batch_scan_full_max_percentage, batch_scan_truncated_max_percentage, batch_scan_notify_threshold_percentage, })
}
fn write_to(&self, buffer: &mut BytesMut) {let batch_scan_full_max_percentage = self.batch_scan_full_max_percentage;buffer[4..5].copy_from_slice(&batch_scan_full_max_percentage.to_le_bytes()[0..1]);let batch_scan_truncated_max_percentage = self.batch_scan_truncated_max_percentage;buffer[5..6].copy_from_slice(&batch_scan_truncated_max_percentage.to_le_bytes()[0..1]);let batch_scan_notify_threshold_percentage = self.batch_scan_notify_threshold_percentage;buffer[6..7].copy_from_slice(&batch_scan_notify_threshold_percentage.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for LeBatchScanSetStorageParametersPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeBatchScanSetStorageParametersPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_scanning_command = match &command.child {CommandDataChild::LeScanningCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanningCommand"),};let le_batch_scan = match &le_scanning_command.child {LeScanningCommandDataChild::LeBatchScan(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScan"),};let le_batch_scan_set_storage_parameters = match &le_batch_scan.child {LeBatchScanDataChild::LeBatchScanSetStorageParameters(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScanSetStorageParameters"),};Self {command,le_scanning_command,le_batch_scan,le_batch_scan_set_storage_parameters,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_batch_scan_opcode(&self) -> BatchScanOpcode{ self.le_batch_scan.as_ref().batch_scan_opcode}
pub fn get_batch_scan_full_max_percentage(&self) -> u8{ self.le_batch_scan_set_storage_parameters.as_ref().batch_scan_full_max_percentage}
pub fn get_batch_scan_truncated_max_percentage(&self) -> u8{ self.le_batch_scan_set_storage_parameters.as_ref().batch_scan_truncated_max_percentage}
pub fn get_batch_scan_notify_threshold_percentage(&self) -> u8{ self.le_batch_scan_set_storage_parameters.as_ref().batch_scan_notify_threshold_percentage}
}
impl Into<CommandPacket> for LeBatchScanSetStorageParametersPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeScanningCommandPacket> for LeBatchScanSetStorageParametersPacket { fn into(self) -> LeScanningCommandPacket {LeScanningCommandPacket::new(self.command) }}
impl Into<LeBatchScanPacket> for LeBatchScanSetStorageParametersPacket { fn into(self) -> LeBatchScanPacket {LeBatchScanPacket::new(self.command) }}
impl LeBatchScanSetStorageParametersBuilder {pub fn build(self) -> LeBatchScanSetStorageParametersPacket {let le_batch_scan_set_storage_parameters= Arc::new(LeBatchScanSetStorageParametersData {batch_scan_full_max_percentage: self.batch_scan_full_max_percentage, batch_scan_truncated_max_percentage: self.batch_scan_truncated_max_percentage, batch_scan_notify_threshold_percentage: self.batch_scan_notify_threshold_percentage, });let le_batch_scan= Arc::new(LeBatchScanData {batch_scan_opcode: BatchScanOpcode::SetStorageParameters, child: LeBatchScanDataChild::LeBatchScanSetStorageParameters(le_batch_scan_set_storage_parameters),});let le_scanning_command= Arc::new(LeScanningCommandData {child: LeScanningCommandDataChild::LeBatchScan(le_batch_scan),});let command= Arc::new(CommandData {op_code: OpCode::LeBatchScan, child: CommandDataChild::LeScanningCommand(le_scanning_command),});LeBatchScanSetStorageParametersPacket::new(command)}
}
impl Into<CommandPacket> for LeBatchScanSetStorageParametersBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeScanningCommandPacket> for LeBatchScanSetStorageParametersBuilder { fn into(self) -> LeScanningCommandPacket { self.build().into() }}
impl Into<LeBatchScanPacket> for LeBatchScanSetStorageParametersBuilder { fn into(self) -> LeBatchScanPacket { self.build().into() }}


#[derive(Debug)] struct LeBatchScanSetStorageParametersCompleteData {}
#[derive(Debug, Clone)] pub struct LeBatchScanSetStorageParametersCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_batch_scan_complete: Arc<LeBatchScanCompleteData>,le_batch_scan_set_storage_parameters_complete: Arc<LeBatchScanSetStorageParametersCompleteData>,}
#[derive(Debug)] pub struct LeBatchScanSetStorageParametersCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeBatchScanSetStorageParametersCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeBatchScanSetStorageParametersCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeBatchScanSetStorageParametersCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_batch_scan_complete = match &command_complete.child {CommandCompleteDataChild::LeBatchScanComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScanComplete"),};let le_batch_scan_set_storage_parameters_complete = match &le_batch_scan_complete.child {LeBatchScanCompleteDataChild::LeBatchScanSetStorageParametersComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScanSetStorageParametersComplete"),};Self {event,command_complete,le_batch_scan_complete,le_batch_scan_set_storage_parameters_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_batch_scan_complete.as_ref().status}
pub fn get_batch_scan_opcode(&self) -> BatchScanOpcode{ self.le_batch_scan_complete.as_ref().batch_scan_opcode}
}
impl Into<EventPacket> for LeBatchScanSetStorageParametersCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeBatchScanSetStorageParametersCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl Into<LeBatchScanCompletePacket> for LeBatchScanSetStorageParametersCompletePacket { fn into(self) -> LeBatchScanCompletePacket {LeBatchScanCompletePacket::new(self.event) }}
impl LeBatchScanSetStorageParametersCompleteBuilder {pub fn build(self) -> LeBatchScanSetStorageParametersCompletePacket {let le_batch_scan_set_storage_parameters_complete= Arc::new(LeBatchScanSetStorageParametersCompleteData {});let le_batch_scan_complete= Arc::new(LeBatchScanCompleteData {status: self.status, batch_scan_opcode: BatchScanOpcode::SetStorageParameters, child: LeBatchScanCompleteDataChild::LeBatchScanSetStorageParametersComplete(le_batch_scan_set_storage_parameters_complete),});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeBatchScan, child: CommandCompleteDataChild::LeBatchScanComplete(le_batch_scan_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeBatchScanSetStorageParametersCompletePacket::new(event)}
}
impl Into<EventPacket> for LeBatchScanSetStorageParametersCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeBatchScanSetStorageParametersCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
impl Into<LeBatchScanCompletePacket> for LeBatchScanSetStorageParametersCompleteBuilder { fn into(self) -> LeBatchScanCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeBatchScanSetScanParametersData {truncated_mode_enabled: u8, full_mode_enabled: u8, duty_cycle_scan_window_slots: u32, duty_cycle_scan_interval_slots: u32, own_address_type: AdvertisingAddressType, batch_scan_discard_rule: BatchScanDiscardRule, }
#[derive(Debug, Clone)] pub struct LeBatchScanSetScanParametersPacket {command: Arc<CommandData>,le_scanning_command: Arc<LeScanningCommandData>,le_batch_scan: Arc<LeBatchScanData>,le_batch_scan_set_scan_parameters: Arc<LeBatchScanSetScanParametersData>,}
#[derive(Debug)] pub struct LeBatchScanSetScanParametersBuilder {pub truncated_mode_enabled: u8, pub full_mode_enabled: u8, pub duty_cycle_scan_window_slots: u32, pub duty_cycle_scan_interval_slots: u32, pub own_address_type: AdvertisingAddressType, pub batch_scan_discard_rule: BatchScanDiscardRule, }
impl LeBatchScanSetScanParametersData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {let truncated_mode_enabled = u8::from_le_bytes([bytes[4]]);let truncated_mode_enabled = truncated_mode_enabled & 0x1;let full_mode_enabled = u8::from_le_bytes([bytes[4]]);let full_mode_enabled = full_mode_enabled >> 1;let full_mode_enabled = full_mode_enabled & 0x1;if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeBatchScanSetScanParameters".to_string(),    field: "duty_cycle_scan_window_slots".to_string(),    wanted: 9,    got: bytes.len()});}let duty_cycle_scan_window_slots = u32::from_le_bytes([bytes[5],bytes[6],bytes[7],bytes[8]]);if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "LeBatchScanSetScanParameters".to_string(),    field: "duty_cycle_scan_interval_slots".to_string(),    wanted: 13,    got: bytes.len()});}let duty_cycle_scan_interval_slots = u32::from_le_bytes([bytes[9],bytes[10],bytes[11],bytes[12]]);if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "LeBatchScanSetScanParameters".to_string(),    field: "own_address_type".to_string(),    wanted: 14,    got: bytes.len()});}let own_address_type = u8::from_le_bytes([bytes[13]]);let own_address_type = AdvertisingAddressType::from_u8(own_address_type).unwrap();if bytes.len() < 15 { return Err(Error::InvalidLengthError{    obj: "LeBatchScanSetScanParameters".to_string(),    field: "batch_scan_discard_rule".to_string(),    wanted: 15,    got: bytes.len()});}let batch_scan_discard_rule = u8::from_le_bytes([bytes[14]]);let batch_scan_discard_rule = BatchScanDiscardRule::from_u8(batch_scan_discard_rule).unwrap();Ok(Self {truncated_mode_enabled, full_mode_enabled, duty_cycle_scan_window_slots, duty_cycle_scan_interval_slots, own_address_type, batch_scan_discard_rule, })
}
fn write_to(&self, buffer: &mut BytesMut) {let truncated_mode_enabled = self.truncated_mode_enabled;let truncated_mode_enabled = truncated_mode_enabled & 0x1;buffer[4..5].copy_from_slice(&truncated_mode_enabled.to_le_bytes()[0..1]);let full_mode_enabled = self.full_mode_enabled;let full_mode_enabled = full_mode_enabled & 0x1;let full_mode_enabled = (full_mode_enabled << 1) | ((buffer[4] as u8) & 0x1);buffer[4..5].copy_from_slice(&full_mode_enabled.to_le_bytes()[0..1]);let duty_cycle_scan_window_slots = self.duty_cycle_scan_window_slots;buffer[5..9].copy_from_slice(&duty_cycle_scan_window_slots.to_le_bytes()[0..4]);let duty_cycle_scan_interval_slots = self.duty_cycle_scan_interval_slots;buffer[9..13].copy_from_slice(&duty_cycle_scan_interval_slots.to_le_bytes()[0..4]);let own_address_type = self.own_address_type.to_u8().unwrap();buffer[13..14].copy_from_slice(&own_address_type.to_le_bytes()[0..1]);let batch_scan_discard_rule = self.batch_scan_discard_rule.to_u8().unwrap();buffer[14..15].copy_from_slice(&batch_scan_discard_rule.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 11;ret}
}
impl Packet for LeBatchScanSetScanParametersPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeBatchScanSetScanParametersPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_scanning_command = match &command.child {CommandDataChild::LeScanningCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanningCommand"),};let le_batch_scan = match &le_scanning_command.child {LeScanningCommandDataChild::LeBatchScan(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScan"),};let le_batch_scan_set_scan_parameters = match &le_batch_scan.child {LeBatchScanDataChild::LeBatchScanSetScanParameters(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScanSetScanParameters"),};Self {command,le_scanning_command,le_batch_scan,le_batch_scan_set_scan_parameters,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_batch_scan_opcode(&self) -> BatchScanOpcode{ self.le_batch_scan.as_ref().batch_scan_opcode}
pub fn get_truncated_mode_enabled(&self) -> u8{ self.le_batch_scan_set_scan_parameters.as_ref().truncated_mode_enabled}
pub fn get_full_mode_enabled(&self) -> u8{ self.le_batch_scan_set_scan_parameters.as_ref().full_mode_enabled}
pub fn get_duty_cycle_scan_window_slots(&self) -> u32{ self.le_batch_scan_set_scan_parameters.as_ref().duty_cycle_scan_window_slots}
pub fn get_duty_cycle_scan_interval_slots(&self) -> u32{ self.le_batch_scan_set_scan_parameters.as_ref().duty_cycle_scan_interval_slots}
pub fn get_own_address_type(&self) -> AdvertisingAddressType{ self.le_batch_scan_set_scan_parameters.as_ref().own_address_type}
pub fn get_batch_scan_discard_rule(&self) -> BatchScanDiscardRule{ self.le_batch_scan_set_scan_parameters.as_ref().batch_scan_discard_rule}
}
impl Into<CommandPacket> for LeBatchScanSetScanParametersPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeScanningCommandPacket> for LeBatchScanSetScanParametersPacket { fn into(self) -> LeScanningCommandPacket {LeScanningCommandPacket::new(self.command) }}
impl Into<LeBatchScanPacket> for LeBatchScanSetScanParametersPacket { fn into(self) -> LeBatchScanPacket {LeBatchScanPacket::new(self.command) }}
impl LeBatchScanSetScanParametersBuilder {pub fn build(self) -> LeBatchScanSetScanParametersPacket {let le_batch_scan_set_scan_parameters= Arc::new(LeBatchScanSetScanParametersData {truncated_mode_enabled: self.truncated_mode_enabled, full_mode_enabled: self.full_mode_enabled, duty_cycle_scan_window_slots: self.duty_cycle_scan_window_slots, duty_cycle_scan_interval_slots: self.duty_cycle_scan_interval_slots, own_address_type: self.own_address_type, batch_scan_discard_rule: self.batch_scan_discard_rule, });let le_batch_scan= Arc::new(LeBatchScanData {batch_scan_opcode: BatchScanOpcode::SetScanParameters, child: LeBatchScanDataChild::LeBatchScanSetScanParameters(le_batch_scan_set_scan_parameters),});let le_scanning_command= Arc::new(LeScanningCommandData {child: LeScanningCommandDataChild::LeBatchScan(le_batch_scan),});let command= Arc::new(CommandData {op_code: OpCode::LeBatchScan, child: CommandDataChild::LeScanningCommand(le_scanning_command),});LeBatchScanSetScanParametersPacket::new(command)}
}
impl Into<CommandPacket> for LeBatchScanSetScanParametersBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeScanningCommandPacket> for LeBatchScanSetScanParametersBuilder { fn into(self) -> LeScanningCommandPacket { self.build().into() }}
impl Into<LeBatchScanPacket> for LeBatchScanSetScanParametersBuilder { fn into(self) -> LeBatchScanPacket { self.build().into() }}


#[derive(Debug)] struct LeBatchScanSetScanParametersCompleteData {}
#[derive(Debug, Clone)] pub struct LeBatchScanSetScanParametersCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_batch_scan_complete: Arc<LeBatchScanCompleteData>,le_batch_scan_set_scan_parameters_complete: Arc<LeBatchScanSetScanParametersCompleteData>,}
#[derive(Debug)] pub struct LeBatchScanSetScanParametersCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeBatchScanSetScanParametersCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeBatchScanSetScanParametersCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeBatchScanSetScanParametersCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_batch_scan_complete = match &command_complete.child {CommandCompleteDataChild::LeBatchScanComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScanComplete"),};let le_batch_scan_set_scan_parameters_complete = match &le_batch_scan_complete.child {LeBatchScanCompleteDataChild::LeBatchScanSetScanParametersComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScanSetScanParametersComplete"),};Self {event,command_complete,le_batch_scan_complete,le_batch_scan_set_scan_parameters_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_batch_scan_complete.as_ref().status}
pub fn get_batch_scan_opcode(&self) -> BatchScanOpcode{ self.le_batch_scan_complete.as_ref().batch_scan_opcode}
}
impl Into<EventPacket> for LeBatchScanSetScanParametersCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeBatchScanSetScanParametersCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl Into<LeBatchScanCompletePacket> for LeBatchScanSetScanParametersCompletePacket { fn into(self) -> LeBatchScanCompletePacket {LeBatchScanCompletePacket::new(self.event) }}
impl LeBatchScanSetScanParametersCompleteBuilder {pub fn build(self) -> LeBatchScanSetScanParametersCompletePacket {let le_batch_scan_set_scan_parameters_complete= Arc::new(LeBatchScanSetScanParametersCompleteData {});let le_batch_scan_complete= Arc::new(LeBatchScanCompleteData {status: self.status, batch_scan_opcode: BatchScanOpcode::SetScanParameters, child: LeBatchScanCompleteDataChild::LeBatchScanSetScanParametersComplete(le_batch_scan_set_scan_parameters_complete),});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeBatchScan, child: CommandCompleteDataChild::LeBatchScanComplete(le_batch_scan_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeBatchScanSetScanParametersCompletePacket::new(event)}
}
impl Into<EventPacket> for LeBatchScanSetScanParametersCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeBatchScanSetScanParametersCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
impl Into<LeBatchScanCompletePacket> for LeBatchScanSetScanParametersCompleteBuilder { fn into(self) -> LeBatchScanCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeBatchScanReadResultParametersData {batch_scan_data_read: BatchScanDataRead, }
#[derive(Debug, Clone)] pub struct LeBatchScanReadResultParametersPacket {command: Arc<CommandData>,le_scanning_command: Arc<LeScanningCommandData>,le_batch_scan: Arc<LeBatchScanData>,le_batch_scan_read_result_parameters: Arc<LeBatchScanReadResultParametersData>,}
#[derive(Debug)] pub struct LeBatchScanReadResultParametersBuilder {pub batch_scan_data_read: BatchScanDataRead, }
impl LeBatchScanReadResultParametersData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeBatchScanReadResultParameters".to_string(),    field: "batch_scan_data_read".to_string(),    wanted: 5,    got: bytes.len()});}let batch_scan_data_read = u8::from_le_bytes([bytes[4]]);let batch_scan_data_read = BatchScanDataRead::from_u8(batch_scan_data_read).unwrap();Ok(Self {batch_scan_data_read, })
}
fn write_to(&self, buffer: &mut BytesMut) {let batch_scan_data_read = self.batch_scan_data_read.to_u8().unwrap();buffer[4..5].copy_from_slice(&batch_scan_data_read.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeBatchScanReadResultParametersPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeBatchScanReadResultParametersPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_scanning_command = match &command.child {CommandDataChild::LeScanningCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanningCommand"),};let le_batch_scan = match &le_scanning_command.child {LeScanningCommandDataChild::LeBatchScan(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScan"),};let le_batch_scan_read_result_parameters = match &le_batch_scan.child {LeBatchScanDataChild::LeBatchScanReadResultParameters(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScanReadResultParameters"),};Self {command,le_scanning_command,le_batch_scan,le_batch_scan_read_result_parameters,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_batch_scan_opcode(&self) -> BatchScanOpcode{ self.le_batch_scan.as_ref().batch_scan_opcode}
pub fn get_batch_scan_data_read(&self) -> BatchScanDataRead{ self.le_batch_scan_read_result_parameters.as_ref().batch_scan_data_read}
}
impl Into<CommandPacket> for LeBatchScanReadResultParametersPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeScanningCommandPacket> for LeBatchScanReadResultParametersPacket { fn into(self) -> LeScanningCommandPacket {LeScanningCommandPacket::new(self.command) }}
impl Into<LeBatchScanPacket> for LeBatchScanReadResultParametersPacket { fn into(self) -> LeBatchScanPacket {LeBatchScanPacket::new(self.command) }}
impl LeBatchScanReadResultParametersBuilder {pub fn build(self) -> LeBatchScanReadResultParametersPacket {let le_batch_scan_read_result_parameters= Arc::new(LeBatchScanReadResultParametersData {batch_scan_data_read: self.batch_scan_data_read, });let le_batch_scan= Arc::new(LeBatchScanData {batch_scan_opcode: BatchScanOpcode::ReadResultParameters, child: LeBatchScanDataChild::LeBatchScanReadResultParameters(le_batch_scan_read_result_parameters),});let le_scanning_command= Arc::new(LeScanningCommandData {child: LeScanningCommandDataChild::LeBatchScan(le_batch_scan),});let command= Arc::new(CommandData {op_code: OpCode::LeBatchScan, child: CommandDataChild::LeScanningCommand(le_scanning_command),});LeBatchScanReadResultParametersPacket::new(command)}
}
impl Into<CommandPacket> for LeBatchScanReadResultParametersBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeScanningCommandPacket> for LeBatchScanReadResultParametersBuilder { fn into(self) -> LeScanningCommandPacket { self.build().into() }}
impl Into<LeBatchScanPacket> for LeBatchScanReadResultParametersBuilder { fn into(self) -> LeBatchScanPacket { self.build().into() }}


#[derive(Debug)] struct LeBatchScanReadResultParametersCompleteRawData {batch_scan_data_read: BatchScanDataRead, num_of_records: u8, raw_data: Vec::<u8>, }
#[derive(Debug, Clone)] pub struct LeBatchScanReadResultParametersCompleteRawPacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_batch_scan_complete: Arc<LeBatchScanCompleteData>,le_batch_scan_read_result_parameters_complete_raw: Arc<LeBatchScanReadResultParametersCompleteRawData>,}
#[derive(Debug)] pub struct LeBatchScanReadResultParametersCompleteRawBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub batch_scan_data_read: BatchScanDataRead, pub num_of_records: u8, pub raw_data: Vec::<u8>, }
impl LeBatchScanReadResultParametersCompleteRawData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeBatchScanReadResultParametersCompleteRaw".to_string(),    field: "batch_scan_data_read".to_string(),    wanted: 8,    got: bytes.len()});}let batch_scan_data_read = u8::from_le_bytes([bytes[7]]);let batch_scan_data_read = BatchScanDataRead::from_u8(batch_scan_data_read).unwrap();if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeBatchScanReadResultParametersCompleteRaw".to_string(),    field: "num_of_records".to_string(),    wanted: 9,    got: bytes.len()});}let num_of_records = u8::from_le_bytes([bytes[8]]);let rem_ = (bytes.len() - 9) % 1;if rem_ != 0 { return Err(Error::InvalidLengthError{    obj: "LeBatchScanReadResultParametersCompleteRaw".to_string(),    field: "raw_data".to_string(),    wanted: bytes.len() + rem_,    got: bytes.len()});}let raw_data: Vec::<u8> = bytes[9..].to_vec().chunks_exact(1).into_iter().map(|i| u8::from_le_bytes([i[0]])).collect();Ok(Self {batch_scan_data_read, num_of_records, raw_data, })
}
fn write_to(&self, buffer: &mut BytesMut) {let batch_scan_data_read = self.batch_scan_data_read.to_u8().unwrap();buffer[7..8].copy_from_slice(&batch_scan_data_read.to_le_bytes()[0..1]);let num_of_records = self.num_of_records;buffer[8..9].copy_from_slice(&num_of_records.to_le_bytes()[0..1]);for (i, e) in self.raw_data.iter().enumerate() {buffer[9+i..9+i+1].copy_from_slice(&e.to_le_bytes())}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;let ret = ret + (self.raw_data.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8));ret}
}
impl Packet for LeBatchScanReadResultParametersCompleteRawPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeBatchScanReadResultParametersCompleteRawPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_batch_scan_complete = match &command_complete.child {CommandCompleteDataChild::LeBatchScanComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScanComplete"),};let le_batch_scan_read_result_parameters_complete_raw = match &le_batch_scan_complete.child {LeBatchScanCompleteDataChild::LeBatchScanReadResultParametersCompleteRaw(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScanReadResultParametersCompleteRaw"),};Self {event,command_complete,le_batch_scan_complete,le_batch_scan_read_result_parameters_complete_raw,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_batch_scan_complete.as_ref().status}
pub fn get_batch_scan_opcode(&self) -> BatchScanOpcode{ self.le_batch_scan_complete.as_ref().batch_scan_opcode}
pub fn get_batch_scan_data_read(&self) -> BatchScanDataRead{ self.le_batch_scan_read_result_parameters_complete_raw.as_ref().batch_scan_data_read}
pub fn get_num_of_records(&self) -> u8{ self.le_batch_scan_read_result_parameters_complete_raw.as_ref().num_of_records}
pub fn get_raw_data(&self) -> &Vec::<u8>{ &self.le_batch_scan_read_result_parameters_complete_raw.as_ref().raw_data}
}
impl Into<EventPacket> for LeBatchScanReadResultParametersCompleteRawPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeBatchScanReadResultParametersCompleteRawPacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl Into<LeBatchScanCompletePacket> for LeBatchScanReadResultParametersCompleteRawPacket { fn into(self) -> LeBatchScanCompletePacket {LeBatchScanCompletePacket::new(self.event) }}
impl LeBatchScanReadResultParametersCompleteRawBuilder {pub fn build(self) -> LeBatchScanReadResultParametersCompleteRawPacket {let le_batch_scan_read_result_parameters_complete_raw= Arc::new(LeBatchScanReadResultParametersCompleteRawData {batch_scan_data_read: self.batch_scan_data_read, num_of_records: self.num_of_records, raw_data: self.raw_data, });let le_batch_scan_complete= Arc::new(LeBatchScanCompleteData {status: self.status, batch_scan_opcode: BatchScanOpcode::ReadResultParameters, child: LeBatchScanCompleteDataChild::LeBatchScanReadResultParametersCompleteRaw(le_batch_scan_read_result_parameters_complete_raw),});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeBatchScan, child: CommandCompleteDataChild::LeBatchScanComplete(le_batch_scan_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeBatchScanReadResultParametersCompleteRawPacket::new(event)}
}
impl Into<EventPacket> for LeBatchScanReadResultParametersCompleteRawBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeBatchScanReadResultParametersCompleteRawBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
impl Into<LeBatchScanCompletePacket> for LeBatchScanReadResultParametersCompleteRawBuilder { fn into(self) -> LeBatchScanCompletePacket { self.build().into() }}


#[derive(Debug)] enum LeBatchScanReadResultParametersCompleteDataChild {LeBatchScanReadTruncatedResultParametersComplete(Arc<LeBatchScanReadTruncatedResultParametersCompleteData>),LeBatchScanReadFullResultParametersComplete(Arc<LeBatchScanReadFullResultParametersCompleteData>),None,}
impl LeBatchScanReadResultParametersCompleteDataChild {fn get_total_size(&self) -> usize {match self {LeBatchScanReadResultParametersCompleteDataChild::LeBatchScanReadTruncatedResultParametersComplete(value) => value.get_total_size(),LeBatchScanReadResultParametersCompleteDataChild::LeBatchScanReadFullResultParametersComplete(value) => value.get_total_size(),LeBatchScanReadResultParametersCompleteDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LeBatchScanReadResultParametersCompleteChild {LeBatchScanReadTruncatedResultParametersComplete(LeBatchScanReadTruncatedResultParametersCompletePacket),LeBatchScanReadFullResultParametersComplete(LeBatchScanReadFullResultParametersCompletePacket),None,}
#[derive(Debug)] struct LeBatchScanReadResultParametersCompleteData {batch_scan_data_read: BatchScanDataRead, child: LeBatchScanReadResultParametersCompleteDataChild,}
#[derive(Debug, Clone)] pub struct LeBatchScanReadResultParametersCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_batch_scan_complete: Arc<LeBatchScanCompleteData>,le_batch_scan_read_result_parameters_complete: Arc<LeBatchScanReadResultParametersCompleteData>,}
#[derive(Debug)] pub struct LeBatchScanReadResultParametersCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub batch_scan_data_read: BatchScanDataRead, }
impl LeBatchScanReadResultParametersCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeBatchScanReadResultParametersComplete".to_string(),    field: "batch_scan_data_read".to_string(),    wanted: 8,    got: bytes.len()});}let batch_scan_data_read = u8::from_le_bytes([bytes[7]]);let batch_scan_data_read = BatchScanDataRead::from_u8(batch_scan_data_read).unwrap();let child = match batch_scan_data_read {BatchScanDataRead::FullModeData if LeBatchScanReadFullResultParametersCompleteData::conforms(&bytes[..]) => {LeBatchScanReadResultParametersCompleteDataChild::LeBatchScanReadFullResultParametersComplete(Arc::new(LeBatchScanReadFullResultParametersCompleteData::parse(&bytes[..])?))}
BatchScanDataRead::TruncatedModeData if LeBatchScanReadTruncatedResultParametersCompleteData::conforms(&bytes[..]) => {LeBatchScanReadResultParametersCompleteDataChild::LeBatchScanReadTruncatedResultParametersComplete(Arc::new(LeBatchScanReadTruncatedResultParametersCompleteData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "batch_scan_data_read".to_string(), value: v as u64}),};
Ok(Self {batch_scan_data_read, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let batch_scan_data_read = self.batch_scan_data_read.to_u8().unwrap();buffer[7..8].copy_from_slice(&batch_scan_data_read.to_le_bytes()[0..1]);match &self.child {LeBatchScanReadResultParametersCompleteDataChild::LeBatchScanReadTruncatedResultParametersComplete(value) => value.write_to(buffer),LeBatchScanReadResultParametersCompleteDataChild::LeBatchScanReadFullResultParametersComplete(value) => value.write_to(buffer),LeBatchScanReadResultParametersCompleteDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeBatchScanReadResultParametersCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeBatchScanReadResultParametersCompletePacket { pub fn specialize(&self) -> LeBatchScanReadResultParametersCompleteChild { match &self.le_batch_scan_read_result_parameters_complete.child {LeBatchScanReadResultParametersCompleteDataChild::LeBatchScanReadTruncatedResultParametersComplete(_) => LeBatchScanReadResultParametersCompleteChild::LeBatchScanReadTruncatedResultParametersComplete(LeBatchScanReadTruncatedResultParametersCompletePacket::new(self.event.clone())),LeBatchScanReadResultParametersCompleteDataChild::LeBatchScanReadFullResultParametersComplete(_) => LeBatchScanReadResultParametersCompleteChild::LeBatchScanReadFullResultParametersComplete(LeBatchScanReadFullResultParametersCompletePacket::new(self.event.clone())),LeBatchScanReadResultParametersCompleteDataChild::None => LeBatchScanReadResultParametersCompleteChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_batch_scan_complete = match &command_complete.child {CommandCompleteDataChild::LeBatchScanComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScanComplete"),};let le_batch_scan_read_result_parameters_complete = match &le_batch_scan_complete.child {LeBatchScanCompleteDataChild::LeBatchScanReadResultParametersComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScanReadResultParametersComplete"),};Self {event,command_complete,le_batch_scan_complete,le_batch_scan_read_result_parameters_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_batch_scan_complete.as_ref().status}
pub fn get_batch_scan_opcode(&self) -> BatchScanOpcode{ self.le_batch_scan_complete.as_ref().batch_scan_opcode}
pub fn get_batch_scan_data_read(&self) -> BatchScanDataRead{ self.le_batch_scan_read_result_parameters_complete.as_ref().batch_scan_data_read}
}
impl Into<EventPacket> for LeBatchScanReadResultParametersCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeBatchScanReadResultParametersCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl Into<LeBatchScanCompletePacket> for LeBatchScanReadResultParametersCompletePacket { fn into(self) -> LeBatchScanCompletePacket {LeBatchScanCompletePacket::new(self.event) }}
impl LeBatchScanReadResultParametersCompleteBuilder {pub fn build(self) -> LeBatchScanReadResultParametersCompletePacket {let le_batch_scan_read_result_parameters_complete= Arc::new(LeBatchScanReadResultParametersCompleteData {batch_scan_data_read: self.batch_scan_data_read, child: LeBatchScanReadResultParametersCompleteDataChild::None,});let le_batch_scan_complete= Arc::new(LeBatchScanCompleteData {status: self.status, batch_scan_opcode: BatchScanOpcode::ReadResultParameters, child: LeBatchScanCompleteDataChild::LeBatchScanReadResultParametersComplete(le_batch_scan_read_result_parameters_complete),});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeBatchScan, child: CommandCompleteDataChild::LeBatchScanComplete(le_batch_scan_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeBatchScanReadResultParametersCompletePacket::new(event)}
}
impl Into<EventPacket> for LeBatchScanReadResultParametersCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeBatchScanReadResultParametersCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
impl Into<LeBatchScanCompletePacket> for LeBatchScanReadResultParametersCompleteBuilder { fn into(self) -> LeBatchScanCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeBatchScanReadTruncatedResultParametersCompleteData {results: Vec::<TruncatedResult>, }
#[derive(Debug, Clone)] pub struct LeBatchScanReadTruncatedResultParametersCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_batch_scan_complete: Arc<LeBatchScanCompleteData>,le_batch_scan_read_result_parameters_complete: Arc<LeBatchScanReadResultParametersCompleteData>,le_batch_scan_read_truncated_result_parameters_complete: Arc<LeBatchScanReadTruncatedResultParametersCompleteData>,}
#[derive(Debug)] pub struct LeBatchScanReadTruncatedResultParametersCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub results: Vec::<TruncatedResult>, }
impl LeBatchScanReadTruncatedResultParametersCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeBatchScanReadTruncatedResultParametersComplete".to_string(),    field: "results_count".to_string(),    wanted: 9,    got: bytes.len()});}let results_count = u8::from_le_bytes([bytes[8]]);let mut results: Vec::<TruncatedResult> = Vec::new();let mut parsable_ = &bytes[9..];let count_ = results_count as usize;for _ in 0..count_ { match TruncatedResult::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];results.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {results, })
}
fn write_to(&self, buffer: &mut BytesMut) {buffer[8..9].copy_from_slice(&(self.results.len() as u8).to_le_bytes());let mut vec_buffer_ = &mut buffer[9..];for e_ in &self.results { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;let ret = ret + (self.results.len() * ((/* Bits: */ 88 + /* Dynamic: */ 0) / 8));ret}
}
impl Packet for LeBatchScanReadTruncatedResultParametersCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeBatchScanReadTruncatedResultParametersCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_batch_scan_complete = match &command_complete.child {CommandCompleteDataChild::LeBatchScanComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScanComplete"),};let le_batch_scan_read_result_parameters_complete = match &le_batch_scan_complete.child {LeBatchScanCompleteDataChild::LeBatchScanReadResultParametersComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScanReadResultParametersComplete"),};let le_batch_scan_read_truncated_result_parameters_complete = match &le_batch_scan_read_result_parameters_complete.child {LeBatchScanReadResultParametersCompleteDataChild::LeBatchScanReadTruncatedResultParametersComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScanReadTruncatedResultParametersComplete"),};Self {event,command_complete,le_batch_scan_complete,le_batch_scan_read_result_parameters_complete,le_batch_scan_read_truncated_result_parameters_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_batch_scan_complete.as_ref().status}
pub fn get_batch_scan_opcode(&self) -> BatchScanOpcode{ self.le_batch_scan_complete.as_ref().batch_scan_opcode}
pub fn get_batch_scan_data_read(&self) -> BatchScanDataRead{ self.le_batch_scan_read_result_parameters_complete.as_ref().batch_scan_data_read}
pub fn get_results(&self) -> &Vec::<TruncatedResult>{ &self.le_batch_scan_read_truncated_result_parameters_complete.as_ref().results}
}
impl Into<EventPacket> for LeBatchScanReadTruncatedResultParametersCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeBatchScanReadTruncatedResultParametersCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl Into<LeBatchScanCompletePacket> for LeBatchScanReadTruncatedResultParametersCompletePacket { fn into(self) -> LeBatchScanCompletePacket {LeBatchScanCompletePacket::new(self.event) }}
impl Into<LeBatchScanReadResultParametersCompletePacket> for LeBatchScanReadTruncatedResultParametersCompletePacket { fn into(self) -> LeBatchScanReadResultParametersCompletePacket {LeBatchScanReadResultParametersCompletePacket::new(self.event) }}
impl LeBatchScanReadTruncatedResultParametersCompleteBuilder {pub fn build(self) -> LeBatchScanReadTruncatedResultParametersCompletePacket {let le_batch_scan_read_truncated_result_parameters_complete= Arc::new(LeBatchScanReadTruncatedResultParametersCompleteData {results: self.results, });let le_batch_scan_read_result_parameters_complete= Arc::new(LeBatchScanReadResultParametersCompleteData {batch_scan_data_read: BatchScanDataRead::TruncatedModeData, child: LeBatchScanReadResultParametersCompleteDataChild::LeBatchScanReadTruncatedResultParametersComplete(le_batch_scan_read_truncated_result_parameters_complete),});let le_batch_scan_complete= Arc::new(LeBatchScanCompleteData {status: self.status, batch_scan_opcode: BatchScanOpcode::ReadResultParameters, child: LeBatchScanCompleteDataChild::LeBatchScanReadResultParametersComplete(le_batch_scan_read_result_parameters_complete),});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeBatchScan, child: CommandCompleteDataChild::LeBatchScanComplete(le_batch_scan_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeBatchScanReadTruncatedResultParametersCompletePacket::new(event)}
}
impl Into<EventPacket> for LeBatchScanReadTruncatedResultParametersCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeBatchScanReadTruncatedResultParametersCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
impl Into<LeBatchScanCompletePacket> for LeBatchScanReadTruncatedResultParametersCompleteBuilder { fn into(self) -> LeBatchScanCompletePacket { self.build().into() }}
impl Into<LeBatchScanReadResultParametersCompletePacket> for LeBatchScanReadTruncatedResultParametersCompleteBuilder { fn into(self) -> LeBatchScanReadResultParametersCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeBatchScanReadFullResultParametersCompleteData {results: Vec::<FullResult>, }
#[derive(Debug, Clone)] pub struct LeBatchScanReadFullResultParametersCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_batch_scan_complete: Arc<LeBatchScanCompleteData>,le_batch_scan_read_result_parameters_complete: Arc<LeBatchScanReadResultParametersCompleteData>,le_batch_scan_read_full_result_parameters_complete: Arc<LeBatchScanReadFullResultParametersCompleteData>,}
#[derive(Debug)] pub struct LeBatchScanReadFullResultParametersCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub results: Vec::<FullResult>, }
impl LeBatchScanReadFullResultParametersCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeBatchScanReadFullResultParametersComplete".to_string(),    field: "results_count".to_string(),    wanted: 9,    got: bytes.len()});}let results_count = u8::from_le_bytes([bytes[8]]);let mut results: Vec::<FullResult> = Vec::new();let mut parsable_ = &bytes[9..];let count_ = results_count as usize;for _ in 0..count_ { match FullResult::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];results.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {results, })
}
fn write_to(&self, buffer: &mut BytesMut) {buffer[8..9].copy_from_slice(&(self.results.len() as u8).to_le_bytes());let mut vec_buffer_ = &mut buffer[9..];for e_ in &self.results { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;let ret = ret + self.results.iter().fold(0, |acc, x| acc + x.get_total_size());ret}
}
impl Packet for LeBatchScanReadFullResultParametersCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeBatchScanReadFullResultParametersCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_batch_scan_complete = match &command_complete.child {CommandCompleteDataChild::LeBatchScanComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScanComplete"),};let le_batch_scan_read_result_parameters_complete = match &le_batch_scan_complete.child {LeBatchScanCompleteDataChild::LeBatchScanReadResultParametersComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScanReadResultParametersComplete"),};let le_batch_scan_read_full_result_parameters_complete = match &le_batch_scan_read_result_parameters_complete.child {LeBatchScanReadResultParametersCompleteDataChild::LeBatchScanReadFullResultParametersComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBatchScanReadFullResultParametersComplete"),};Self {event,command_complete,le_batch_scan_complete,le_batch_scan_read_result_parameters_complete,le_batch_scan_read_full_result_parameters_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_batch_scan_complete.as_ref().status}
pub fn get_batch_scan_opcode(&self) -> BatchScanOpcode{ self.le_batch_scan_complete.as_ref().batch_scan_opcode}
pub fn get_batch_scan_data_read(&self) -> BatchScanDataRead{ self.le_batch_scan_read_result_parameters_complete.as_ref().batch_scan_data_read}
pub fn get_results(&self) -> &Vec::<FullResult>{ &self.le_batch_scan_read_full_result_parameters_complete.as_ref().results}
}
impl Into<EventPacket> for LeBatchScanReadFullResultParametersCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeBatchScanReadFullResultParametersCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl Into<LeBatchScanCompletePacket> for LeBatchScanReadFullResultParametersCompletePacket { fn into(self) -> LeBatchScanCompletePacket {LeBatchScanCompletePacket::new(self.event) }}
impl Into<LeBatchScanReadResultParametersCompletePacket> for LeBatchScanReadFullResultParametersCompletePacket { fn into(self) -> LeBatchScanReadResultParametersCompletePacket {LeBatchScanReadResultParametersCompletePacket::new(self.event) }}
impl LeBatchScanReadFullResultParametersCompleteBuilder {pub fn build(self) -> LeBatchScanReadFullResultParametersCompletePacket {let le_batch_scan_read_full_result_parameters_complete= Arc::new(LeBatchScanReadFullResultParametersCompleteData {results: self.results, });let le_batch_scan_read_result_parameters_complete= Arc::new(LeBatchScanReadResultParametersCompleteData {batch_scan_data_read: BatchScanDataRead::FullModeData, child: LeBatchScanReadResultParametersCompleteDataChild::LeBatchScanReadFullResultParametersComplete(le_batch_scan_read_full_result_parameters_complete),});let le_batch_scan_complete= Arc::new(LeBatchScanCompleteData {status: self.status, batch_scan_opcode: BatchScanOpcode::ReadResultParameters, child: LeBatchScanCompleteDataChild::LeBatchScanReadResultParametersComplete(le_batch_scan_read_result_parameters_complete),});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeBatchScan, child: CommandCompleteDataChild::LeBatchScanComplete(le_batch_scan_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeBatchScanReadFullResultParametersCompletePacket::new(event)}
}
impl Into<EventPacket> for LeBatchScanReadFullResultParametersCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeBatchScanReadFullResultParametersCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
impl Into<LeBatchScanCompletePacket> for LeBatchScanReadFullResultParametersCompleteBuilder { fn into(self) -> LeBatchScanCompletePacket { self.build().into() }}
impl Into<LeBatchScanReadResultParametersCompletePacket> for LeBatchScanReadFullResultParametersCompleteBuilder { fn into(self) -> LeBatchScanReadResultParametersCompletePacket { self.build().into() }}


#[derive(Debug)] enum LeAdvFilterDataChild {LeAdvFilterEnable(Arc<LeAdvFilterEnableData>),LeAdvFilterSetFilteringParameters(Arc<LeAdvFilterSetFilteringParametersData>),LeAdvFilterBroadcasterAddress(Arc<LeAdvFilterBroadcasterAddressData>),LeAdvFilterClearBroadcasterAddress(Arc<LeAdvFilterClearBroadcasterAddressData>),LeAdvFilterServiceUuid(Arc<LeAdvFilterServiceUuidData>),LeAdvFilterSolicitationUuid(Arc<LeAdvFilterSolicitationUuidData>),LeAdvFilterLocalName(Arc<LeAdvFilterLocalNameData>),LeAdvFilterManufacturerData(Arc<LeAdvFilterManufacturerDataData>),LeAdvFilterServiceData(Arc<LeAdvFilterServiceDataData>),None,}
impl LeAdvFilterDataChild {fn get_total_size(&self) -> usize {match self {LeAdvFilterDataChild::LeAdvFilterEnable(value) => value.get_total_size(),LeAdvFilterDataChild::LeAdvFilterSetFilteringParameters(value) => value.get_total_size(),LeAdvFilterDataChild::LeAdvFilterBroadcasterAddress(value) => value.get_total_size(),LeAdvFilterDataChild::LeAdvFilterClearBroadcasterAddress(value) => value.get_total_size(),LeAdvFilterDataChild::LeAdvFilterServiceUuid(value) => value.get_total_size(),LeAdvFilterDataChild::LeAdvFilterSolicitationUuid(value) => value.get_total_size(),LeAdvFilterDataChild::LeAdvFilterLocalName(value) => value.get_total_size(),LeAdvFilterDataChild::LeAdvFilterManufacturerData(value) => value.get_total_size(),LeAdvFilterDataChild::LeAdvFilterServiceData(value) => value.get_total_size(),LeAdvFilterDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LeAdvFilterChild {LeAdvFilterEnable(LeAdvFilterEnablePacket),LeAdvFilterSetFilteringParameters(LeAdvFilterSetFilteringParametersPacket),LeAdvFilterBroadcasterAddress(LeAdvFilterBroadcasterAddressPacket),LeAdvFilterClearBroadcasterAddress(LeAdvFilterClearBroadcasterAddressPacket),LeAdvFilterServiceUuid(LeAdvFilterServiceUuidPacket),LeAdvFilterSolicitationUuid(LeAdvFilterSolicitationUuidPacket),LeAdvFilterLocalName(LeAdvFilterLocalNamePacket),LeAdvFilterManufacturerData(LeAdvFilterManufacturerDataPacket),LeAdvFilterServiceData(LeAdvFilterServiceDataPacket),None,}
#[derive(Debug)] struct LeAdvFilterData {apcf_opcode: ApcfOpcode, child: LeAdvFilterDataChild,}
#[derive(Debug, Clone)] pub struct LeAdvFilterPacket {command: Arc<CommandData>,le_scanning_command: Arc<LeScanningCommandData>,le_adv_filter: Arc<LeAdvFilterData>,}
#[derive(Debug)] pub struct LeAdvFilterBuilder {pub apcf_opcode: ApcfOpcode, }
impl LeAdvFilterData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilter".to_string(),    field: "apcf_opcode".to_string(),    wanted: 4,    got: bytes.len()});}let apcf_opcode = u8::from_le_bytes([bytes[3]]);let apcf_opcode = ApcfOpcode::from_u8(apcf_opcode).unwrap();let child = match apcf_opcode {ApcfOpcode::BroadcasterAddress if LeAdvFilterBroadcasterAddressData::conforms(&bytes[..]) => {LeAdvFilterDataChild::LeAdvFilterBroadcasterAddress(Arc::new(LeAdvFilterBroadcasterAddressData::parse(&bytes[..])?))}
ApcfOpcode::ManufacturerData if LeAdvFilterManufacturerDataData::conforms(&bytes[..]) => {LeAdvFilterDataChild::LeAdvFilterManufacturerData(Arc::new(LeAdvFilterManufacturerDataData::parse(&bytes[..])?))}
ApcfOpcode::ServiceUuid if LeAdvFilterServiceUuidData::conforms(&bytes[..]) => {LeAdvFilterDataChild::LeAdvFilterServiceUuid(Arc::new(LeAdvFilterServiceUuidData::parse(&bytes[..])?))}
ApcfOpcode::ServiceSolicitationUuid if LeAdvFilterSolicitationUuidData::conforms(&bytes[..]) => {LeAdvFilterDataChild::LeAdvFilterSolicitationUuid(Arc::new(LeAdvFilterSolicitationUuidData::parse(&bytes[..])?))}
ApcfOpcode::ServiceData if LeAdvFilterServiceDataData::conforms(&bytes[..]) => {LeAdvFilterDataChild::LeAdvFilterServiceData(Arc::new(LeAdvFilterServiceDataData::parse(&bytes[..])?))}
ApcfOpcode::LocalName if LeAdvFilterLocalNameData::conforms(&bytes[..]) => {LeAdvFilterDataChild::LeAdvFilterLocalName(Arc::new(LeAdvFilterLocalNameData::parse(&bytes[..])?))}
ApcfOpcode::BroadcasterAddress if LeAdvFilterClearBroadcasterAddressData::conforms(&bytes[..]) => {LeAdvFilterDataChild::LeAdvFilterClearBroadcasterAddress(Arc::new(LeAdvFilterClearBroadcasterAddressData::parse(&bytes[..])?))}
ApcfOpcode::Enable if LeAdvFilterEnableData::conforms(&bytes[..]) => {LeAdvFilterDataChild::LeAdvFilterEnable(Arc::new(LeAdvFilterEnableData::parse(&bytes[..])?))}
ApcfOpcode::SetFilteringParameters if LeAdvFilterSetFilteringParametersData::conforms(&bytes[..]) => {LeAdvFilterDataChild::LeAdvFilterSetFilteringParameters(Arc::new(LeAdvFilterSetFilteringParametersData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "apcf_opcode".to_string(), value: v as u64}),};
Ok(Self {apcf_opcode, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let apcf_opcode = self.apcf_opcode.to_u8().unwrap();buffer[3..4].copy_from_slice(&apcf_opcode.to_le_bytes()[0..1]);match &self.child {LeAdvFilterDataChild::LeAdvFilterEnable(value) => value.write_to(buffer),LeAdvFilterDataChild::LeAdvFilterSetFilteringParameters(value) => value.write_to(buffer),LeAdvFilterDataChild::LeAdvFilterBroadcasterAddress(value) => value.write_to(buffer),LeAdvFilterDataChild::LeAdvFilterClearBroadcasterAddress(value) => value.write_to(buffer),LeAdvFilterDataChild::LeAdvFilterServiceUuid(value) => value.write_to(buffer),LeAdvFilterDataChild::LeAdvFilterSolicitationUuid(value) => value.write_to(buffer),LeAdvFilterDataChild::LeAdvFilterLocalName(value) => value.write_to(buffer),LeAdvFilterDataChild::LeAdvFilterManufacturerData(value) => value.write_to(buffer),LeAdvFilterDataChild::LeAdvFilterServiceData(value) => value.write_to(buffer),LeAdvFilterDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl CommandExpectations for LeAdvFilterPacket { type ResponseType = LeAdvFilterCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeAdvFilterCompletePacket::new(pkt.event.clone()) }}impl Packet for LeAdvFilterPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAdvFilterPacket { pub fn specialize(&self) -> LeAdvFilterChild { match &self.le_adv_filter.child {LeAdvFilterDataChild::LeAdvFilterEnable(_) => LeAdvFilterChild::LeAdvFilterEnable(LeAdvFilterEnablePacket::new(self.command.clone())),LeAdvFilterDataChild::LeAdvFilterSetFilteringParameters(_) => LeAdvFilterChild::LeAdvFilterSetFilteringParameters(LeAdvFilterSetFilteringParametersPacket::new(self.command.clone())),LeAdvFilterDataChild::LeAdvFilterBroadcasterAddress(_) => LeAdvFilterChild::LeAdvFilterBroadcasterAddress(LeAdvFilterBroadcasterAddressPacket::new(self.command.clone())),LeAdvFilterDataChild::LeAdvFilterClearBroadcasterAddress(_) => LeAdvFilterChild::LeAdvFilterClearBroadcasterAddress(LeAdvFilterClearBroadcasterAddressPacket::new(self.command.clone())),LeAdvFilterDataChild::LeAdvFilterServiceUuid(_) => LeAdvFilterChild::LeAdvFilterServiceUuid(LeAdvFilterServiceUuidPacket::new(self.command.clone())),LeAdvFilterDataChild::LeAdvFilterSolicitationUuid(_) => LeAdvFilterChild::LeAdvFilterSolicitationUuid(LeAdvFilterSolicitationUuidPacket::new(self.command.clone())),LeAdvFilterDataChild::LeAdvFilterLocalName(_) => LeAdvFilterChild::LeAdvFilterLocalName(LeAdvFilterLocalNamePacket::new(self.command.clone())),LeAdvFilterDataChild::LeAdvFilterManufacturerData(_) => LeAdvFilterChild::LeAdvFilterManufacturerData(LeAdvFilterManufacturerDataPacket::new(self.command.clone())),LeAdvFilterDataChild::LeAdvFilterServiceData(_) => LeAdvFilterChild::LeAdvFilterServiceData(LeAdvFilterServiceDataPacket::new(self.command.clone())),LeAdvFilterDataChild::None => LeAdvFilterChild::None,}} fn new(root: Arc<CommandData>) -> Self {let command = root;let le_scanning_command = match &command.child {CommandDataChild::LeScanningCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanningCommand"),};let le_adv_filter = match &le_scanning_command.child {LeScanningCommandDataChild::LeAdvFilter(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilter"),};Self {command,le_scanning_command,le_adv_filter,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_apcf_opcode(&self) -> ApcfOpcode{ self.le_adv_filter.as_ref().apcf_opcode}
}
impl Into<CommandPacket> for LeAdvFilterPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeScanningCommandPacket> for LeAdvFilterPacket { fn into(self) -> LeScanningCommandPacket {LeScanningCommandPacket::new(self.command) }}
impl CommandExpectations for LeAdvFilterBuilder { type ResponseType = LeAdvFilterCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeAdvFilterCompletePacket::new(pkt.event.clone()) }}impl LeAdvFilterBuilder {pub fn build(self) -> LeAdvFilterPacket {let le_adv_filter= Arc::new(LeAdvFilterData {apcf_opcode: self.apcf_opcode, child: LeAdvFilterDataChild::None,});let le_scanning_command= Arc::new(LeScanningCommandData {child: LeScanningCommandDataChild::LeAdvFilter(le_adv_filter),});let command= Arc::new(CommandData {op_code: OpCode::LeAdvFilter, child: CommandDataChild::LeScanningCommand(le_scanning_command),});LeAdvFilterPacket::new(command)}
}
impl Into<CommandPacket> for LeAdvFilterBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeScanningCommandPacket> for LeAdvFilterBuilder { fn into(self) -> LeScanningCommandPacket { self.build().into() }}


#[derive(Debug)] enum LeAdvFilterCompleteDataChild {LeAdvFilterEnableComplete(Arc<LeAdvFilterEnableCompleteData>),LeAdvFilterSetFilteringParametersComplete(Arc<LeAdvFilterSetFilteringParametersCompleteData>),LeAdvFilterBroadcasterAddressComplete(Arc<LeAdvFilterBroadcasterAddressCompleteData>),LeAdvFilterServiceUuidComplete(Arc<LeAdvFilterServiceUuidCompleteData>),LeAdvFilterSolicitationUuidComplete(Arc<LeAdvFilterSolicitationUuidCompleteData>),LeAdvFilterLocalNameComplete(Arc<LeAdvFilterLocalNameCompleteData>),LeAdvFilterManufacturerDataComplete(Arc<LeAdvFilterManufacturerDataCompleteData>),LeAdvFilterServiceDataComplete(Arc<LeAdvFilterServiceDataCompleteData>),None,}
impl LeAdvFilterCompleteDataChild {fn get_total_size(&self) -> usize {match self {LeAdvFilterCompleteDataChild::LeAdvFilterEnableComplete(value) => value.get_total_size(),LeAdvFilterCompleteDataChild::LeAdvFilterSetFilteringParametersComplete(value) => value.get_total_size(),LeAdvFilterCompleteDataChild::LeAdvFilterBroadcasterAddressComplete(value) => value.get_total_size(),LeAdvFilterCompleteDataChild::LeAdvFilterServiceUuidComplete(value) => value.get_total_size(),LeAdvFilterCompleteDataChild::LeAdvFilterSolicitationUuidComplete(value) => value.get_total_size(),LeAdvFilterCompleteDataChild::LeAdvFilterLocalNameComplete(value) => value.get_total_size(),LeAdvFilterCompleteDataChild::LeAdvFilterManufacturerDataComplete(value) => value.get_total_size(),LeAdvFilterCompleteDataChild::LeAdvFilterServiceDataComplete(value) => value.get_total_size(),LeAdvFilterCompleteDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LeAdvFilterCompleteChild {LeAdvFilterEnableComplete(LeAdvFilterEnableCompletePacket),LeAdvFilterSetFilteringParametersComplete(LeAdvFilterSetFilteringParametersCompletePacket),LeAdvFilterBroadcasterAddressComplete(LeAdvFilterBroadcasterAddressCompletePacket),LeAdvFilterServiceUuidComplete(LeAdvFilterServiceUuidCompletePacket),LeAdvFilterSolicitationUuidComplete(LeAdvFilterSolicitationUuidCompletePacket),LeAdvFilterLocalNameComplete(LeAdvFilterLocalNameCompletePacket),LeAdvFilterManufacturerDataComplete(LeAdvFilterManufacturerDataCompletePacket),LeAdvFilterServiceDataComplete(LeAdvFilterServiceDataCompletePacket),None,}
#[derive(Debug)] struct LeAdvFilterCompleteData {status: ErrorCode, apcf_opcode: ApcfOpcode, child: LeAdvFilterCompleteDataChild,}
#[derive(Debug, Clone)] pub struct LeAdvFilterCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_adv_filter_complete: Arc<LeAdvFilterCompleteData>,}
#[derive(Debug)] pub struct LeAdvFilterCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub apcf_opcode: ApcfOpcode, }
impl LeAdvFilterCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterComplete".to_string(),    field: "apcf_opcode".to_string(),    wanted: 7,    got: bytes.len()});}let apcf_opcode = u8::from_le_bytes([bytes[6]]);let apcf_opcode = ApcfOpcode::from_u8(apcf_opcode).unwrap();let child = match apcf_opcode {ApcfOpcode::ServiceUuid if LeAdvFilterServiceUuidCompleteData::conforms(&bytes[..]) => {LeAdvFilterCompleteDataChild::LeAdvFilterServiceUuidComplete(Arc::new(LeAdvFilterServiceUuidCompleteData::parse(&bytes[..])?))}
ApcfOpcode::LocalName if LeAdvFilterLocalNameCompleteData::conforms(&bytes[..]) => {LeAdvFilterCompleteDataChild::LeAdvFilterLocalNameComplete(Arc::new(LeAdvFilterLocalNameCompleteData::parse(&bytes[..])?))}
ApcfOpcode::ManufacturerData if LeAdvFilterManufacturerDataCompleteData::conforms(&bytes[..]) => {LeAdvFilterCompleteDataChild::LeAdvFilterManufacturerDataComplete(Arc::new(LeAdvFilterManufacturerDataCompleteData::parse(&bytes[..])?))}
ApcfOpcode::ServiceSolicitationUuid if LeAdvFilterSolicitationUuidCompleteData::conforms(&bytes[..]) => {LeAdvFilterCompleteDataChild::LeAdvFilterSolicitationUuidComplete(Arc::new(LeAdvFilterSolicitationUuidCompleteData::parse(&bytes[..])?))}
ApcfOpcode::ServiceData if LeAdvFilterServiceDataCompleteData::conforms(&bytes[..]) => {LeAdvFilterCompleteDataChild::LeAdvFilterServiceDataComplete(Arc::new(LeAdvFilterServiceDataCompleteData::parse(&bytes[..])?))}
ApcfOpcode::BroadcasterAddress if LeAdvFilterBroadcasterAddressCompleteData::conforms(&bytes[..]) => {LeAdvFilterCompleteDataChild::LeAdvFilterBroadcasterAddressComplete(Arc::new(LeAdvFilterBroadcasterAddressCompleteData::parse(&bytes[..])?))}
ApcfOpcode::SetFilteringParameters if LeAdvFilterSetFilteringParametersCompleteData::conforms(&bytes[..]) => {LeAdvFilterCompleteDataChild::LeAdvFilterSetFilteringParametersComplete(Arc::new(LeAdvFilterSetFilteringParametersCompleteData::parse(&bytes[..])?))}
ApcfOpcode::Enable if LeAdvFilterEnableCompleteData::conforms(&bytes[..]) => {LeAdvFilterCompleteDataChild::LeAdvFilterEnableComplete(Arc::new(LeAdvFilterEnableCompleteData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "apcf_opcode".to_string(), value: v as u64}),};
Ok(Self {status, apcf_opcode, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let apcf_opcode = self.apcf_opcode.to_u8().unwrap();buffer[6..7].copy_from_slice(&apcf_opcode.to_le_bytes()[0..1]);match &self.child {LeAdvFilterCompleteDataChild::LeAdvFilterEnableComplete(value) => value.write_to(buffer),LeAdvFilterCompleteDataChild::LeAdvFilterSetFilteringParametersComplete(value) => value.write_to(buffer),LeAdvFilterCompleteDataChild::LeAdvFilterBroadcasterAddressComplete(value) => value.write_to(buffer),LeAdvFilterCompleteDataChild::LeAdvFilterServiceUuidComplete(value) => value.write_to(buffer),LeAdvFilterCompleteDataChild::LeAdvFilterSolicitationUuidComplete(value) => value.write_to(buffer),LeAdvFilterCompleteDataChild::LeAdvFilterLocalNameComplete(value) => value.write_to(buffer),LeAdvFilterCompleteDataChild::LeAdvFilterManufacturerDataComplete(value) => value.write_to(buffer),LeAdvFilterCompleteDataChild::LeAdvFilterServiceDataComplete(value) => value.write_to(buffer),LeAdvFilterCompleteDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for LeAdvFilterCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAdvFilterCompletePacket { pub fn specialize(&self) -> LeAdvFilterCompleteChild { match &self.le_adv_filter_complete.child {LeAdvFilterCompleteDataChild::LeAdvFilterEnableComplete(_) => LeAdvFilterCompleteChild::LeAdvFilterEnableComplete(LeAdvFilterEnableCompletePacket::new(self.event.clone())),LeAdvFilterCompleteDataChild::LeAdvFilterSetFilteringParametersComplete(_) => LeAdvFilterCompleteChild::LeAdvFilterSetFilteringParametersComplete(LeAdvFilterSetFilteringParametersCompletePacket::new(self.event.clone())),LeAdvFilterCompleteDataChild::LeAdvFilterBroadcasterAddressComplete(_) => LeAdvFilterCompleteChild::LeAdvFilterBroadcasterAddressComplete(LeAdvFilterBroadcasterAddressCompletePacket::new(self.event.clone())),LeAdvFilterCompleteDataChild::LeAdvFilterServiceUuidComplete(_) => LeAdvFilterCompleteChild::LeAdvFilterServiceUuidComplete(LeAdvFilterServiceUuidCompletePacket::new(self.event.clone())),LeAdvFilterCompleteDataChild::LeAdvFilterSolicitationUuidComplete(_) => LeAdvFilterCompleteChild::LeAdvFilterSolicitationUuidComplete(LeAdvFilterSolicitationUuidCompletePacket::new(self.event.clone())),LeAdvFilterCompleteDataChild::LeAdvFilterLocalNameComplete(_) => LeAdvFilterCompleteChild::LeAdvFilterLocalNameComplete(LeAdvFilterLocalNameCompletePacket::new(self.event.clone())),LeAdvFilterCompleteDataChild::LeAdvFilterManufacturerDataComplete(_) => LeAdvFilterCompleteChild::LeAdvFilterManufacturerDataComplete(LeAdvFilterManufacturerDataCompletePacket::new(self.event.clone())),LeAdvFilterCompleteDataChild::LeAdvFilterServiceDataComplete(_) => LeAdvFilterCompleteChild::LeAdvFilterServiceDataComplete(LeAdvFilterServiceDataCompletePacket::new(self.event.clone())),LeAdvFilterCompleteDataChild::None => LeAdvFilterCompleteChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_adv_filter_complete = match &command_complete.child {CommandCompleteDataChild::LeAdvFilterComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterComplete"),};Self {event,command_complete,le_adv_filter_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_adv_filter_complete.as_ref().status}
pub fn get_apcf_opcode(&self) -> ApcfOpcode{ self.le_adv_filter_complete.as_ref().apcf_opcode}
}
impl Into<EventPacket> for LeAdvFilterCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeAdvFilterCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeAdvFilterCompleteBuilder {pub fn build(self) -> LeAdvFilterCompletePacket {let le_adv_filter_complete= Arc::new(LeAdvFilterCompleteData {status: self.status, apcf_opcode: self.apcf_opcode, child: LeAdvFilterCompleteDataChild::None,});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeAdvFilter, child: CommandCompleteDataChild::LeAdvFilterComplete(le_adv_filter_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeAdvFilterCompletePacket::new(event)}
}
impl Into<EventPacket> for LeAdvFilterCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeAdvFilterCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeAdvFilterEnableData {apcf_enable: Enable, }
#[derive(Debug, Clone)] pub struct LeAdvFilterEnablePacket {command: Arc<CommandData>,le_scanning_command: Arc<LeScanningCommandData>,le_adv_filter: Arc<LeAdvFilterData>,le_adv_filter_enable: Arc<LeAdvFilterEnableData>,}
#[derive(Debug)] pub struct LeAdvFilterEnableBuilder {pub apcf_enable: Enable, }
impl LeAdvFilterEnableData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterEnable".to_string(),    field: "apcf_enable".to_string(),    wanted: 5,    got: bytes.len()});}let apcf_enable = u8::from_le_bytes([bytes[4]]);let apcf_enable = Enable::from_u8(apcf_enable).unwrap();Ok(Self {apcf_enable, })
}
fn write_to(&self, buffer: &mut BytesMut) {let apcf_enable = self.apcf_enable.to_u8().unwrap();buffer[4..5].copy_from_slice(&apcf_enable.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeAdvFilterEnablePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAdvFilterEnablePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_scanning_command = match &command.child {CommandDataChild::LeScanningCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanningCommand"),};let le_adv_filter = match &le_scanning_command.child {LeScanningCommandDataChild::LeAdvFilter(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilter"),};let le_adv_filter_enable = match &le_adv_filter.child {LeAdvFilterDataChild::LeAdvFilterEnable(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterEnable"),};Self {command,le_scanning_command,le_adv_filter,le_adv_filter_enable,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_apcf_opcode(&self) -> ApcfOpcode{ self.le_adv_filter.as_ref().apcf_opcode}
pub fn get_apcf_enable(&self) -> Enable{ self.le_adv_filter_enable.as_ref().apcf_enable}
}
impl Into<CommandPacket> for LeAdvFilterEnablePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeScanningCommandPacket> for LeAdvFilterEnablePacket { fn into(self) -> LeScanningCommandPacket {LeScanningCommandPacket::new(self.command) }}
impl Into<LeAdvFilterPacket> for LeAdvFilterEnablePacket { fn into(self) -> LeAdvFilterPacket {LeAdvFilterPacket::new(self.command) }}
impl LeAdvFilterEnableBuilder {pub fn build(self) -> LeAdvFilterEnablePacket {let le_adv_filter_enable= Arc::new(LeAdvFilterEnableData {apcf_enable: self.apcf_enable, });let le_adv_filter= Arc::new(LeAdvFilterData {apcf_opcode: ApcfOpcode::Enable, child: LeAdvFilterDataChild::LeAdvFilterEnable(le_adv_filter_enable),});let le_scanning_command= Arc::new(LeScanningCommandData {child: LeScanningCommandDataChild::LeAdvFilter(le_adv_filter),});let command= Arc::new(CommandData {op_code: OpCode::LeAdvFilter, child: CommandDataChild::LeScanningCommand(le_scanning_command),});LeAdvFilterEnablePacket::new(command)}
}
impl Into<CommandPacket> for LeAdvFilterEnableBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeScanningCommandPacket> for LeAdvFilterEnableBuilder { fn into(self) -> LeScanningCommandPacket { self.build().into() }}
impl Into<LeAdvFilterPacket> for LeAdvFilterEnableBuilder { fn into(self) -> LeAdvFilterPacket { self.build().into() }}


#[derive(Debug)] struct LeAdvFilterEnableCompleteData {apcf_enable: Enable, }
#[derive(Debug, Clone)] pub struct LeAdvFilterEnableCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_adv_filter_complete: Arc<LeAdvFilterCompleteData>,le_adv_filter_enable_complete: Arc<LeAdvFilterEnableCompleteData>,}
#[derive(Debug)] pub struct LeAdvFilterEnableCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub apcf_enable: Enable, }
impl LeAdvFilterEnableCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterEnableComplete".to_string(),    field: "apcf_enable".to_string(),    wanted: 8,    got: bytes.len()});}let apcf_enable = u8::from_le_bytes([bytes[7]]);let apcf_enable = Enable::from_u8(apcf_enable).unwrap();Ok(Self {apcf_enable, })
}
fn write_to(&self, buffer: &mut BytesMut) {let apcf_enable = self.apcf_enable.to_u8().unwrap();buffer[7..8].copy_from_slice(&apcf_enable.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeAdvFilterEnableCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAdvFilterEnableCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_adv_filter_complete = match &command_complete.child {CommandCompleteDataChild::LeAdvFilterComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterComplete"),};let le_adv_filter_enable_complete = match &le_adv_filter_complete.child {LeAdvFilterCompleteDataChild::LeAdvFilterEnableComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterEnableComplete"),};Self {event,command_complete,le_adv_filter_complete,le_adv_filter_enable_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_adv_filter_complete.as_ref().status}
pub fn get_apcf_opcode(&self) -> ApcfOpcode{ self.le_adv_filter_complete.as_ref().apcf_opcode}
pub fn get_apcf_enable(&self) -> Enable{ self.le_adv_filter_enable_complete.as_ref().apcf_enable}
}
impl Into<EventPacket> for LeAdvFilterEnableCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeAdvFilterEnableCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl Into<LeAdvFilterCompletePacket> for LeAdvFilterEnableCompletePacket { fn into(self) -> LeAdvFilterCompletePacket {LeAdvFilterCompletePacket::new(self.event) }}
impl LeAdvFilterEnableCompleteBuilder {pub fn build(self) -> LeAdvFilterEnableCompletePacket {let le_adv_filter_enable_complete= Arc::new(LeAdvFilterEnableCompleteData {apcf_enable: self.apcf_enable, });let le_adv_filter_complete= Arc::new(LeAdvFilterCompleteData {status: self.status, apcf_opcode: ApcfOpcode::Enable, child: LeAdvFilterCompleteDataChild::LeAdvFilterEnableComplete(le_adv_filter_enable_complete),});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeAdvFilter, child: CommandCompleteDataChild::LeAdvFilterComplete(le_adv_filter_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeAdvFilterEnableCompletePacket::new(event)}
}
impl Into<EventPacket> for LeAdvFilterEnableCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeAdvFilterEnableCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
impl Into<LeAdvFilterCompletePacket> for LeAdvFilterEnableCompleteBuilder { fn into(self) -> LeAdvFilterCompletePacket { self.build().into() }}


#[derive(Debug)] enum LeAdvFilterSetFilteringParametersDataChild {LeAdvFilterAddFilteringParameters(Arc<LeAdvFilterAddFilteringParametersData>),LeAdvFilterDeleteFilteringParameters(Arc<LeAdvFilterDeleteFilteringParametersData>),LeAdvFilterClearFilteringParameters(Arc<LeAdvFilterClearFilteringParametersData>),None,}
impl LeAdvFilterSetFilteringParametersDataChild {fn get_total_size(&self) -> usize {match self {LeAdvFilterSetFilteringParametersDataChild::LeAdvFilterAddFilteringParameters(value) => value.get_total_size(),LeAdvFilterSetFilteringParametersDataChild::LeAdvFilterDeleteFilteringParameters(value) => value.get_total_size(),LeAdvFilterSetFilteringParametersDataChild::LeAdvFilterClearFilteringParameters(value) => value.get_total_size(),LeAdvFilterSetFilteringParametersDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LeAdvFilterSetFilteringParametersChild {LeAdvFilterAddFilteringParameters(LeAdvFilterAddFilteringParametersPacket),LeAdvFilterDeleteFilteringParameters(LeAdvFilterDeleteFilteringParametersPacket),LeAdvFilterClearFilteringParameters(LeAdvFilterClearFilteringParametersPacket),None,}
#[derive(Debug)] struct LeAdvFilterSetFilteringParametersData {apcf_action: ApcfAction, child: LeAdvFilterSetFilteringParametersDataChild,}
#[derive(Debug, Clone)] pub struct LeAdvFilterSetFilteringParametersPacket {command: Arc<CommandData>,le_scanning_command: Arc<LeScanningCommandData>,le_adv_filter: Arc<LeAdvFilterData>,le_adv_filter_set_filtering_parameters: Arc<LeAdvFilterSetFilteringParametersData>,}
#[derive(Debug)] pub struct LeAdvFilterSetFilteringParametersBuilder {pub apcf_action: ApcfAction, }
impl LeAdvFilterSetFilteringParametersData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterSetFilteringParameters".to_string(),    field: "apcf_action".to_string(),    wanted: 5,    got: bytes.len()});}let apcf_action = u8::from_le_bytes([bytes[4]]);let apcf_action = ApcfAction::from_u8(apcf_action).unwrap();let child = match apcf_action {ApcfAction::Clear if LeAdvFilterClearFilteringParametersData::conforms(&bytes[..]) => {LeAdvFilterSetFilteringParametersDataChild::LeAdvFilterClearFilteringParameters(Arc::new(LeAdvFilterClearFilteringParametersData::parse(&bytes[..])?))}
ApcfAction::Delete if LeAdvFilterDeleteFilteringParametersData::conforms(&bytes[..]) => {LeAdvFilterSetFilteringParametersDataChild::LeAdvFilterDeleteFilteringParameters(Arc::new(LeAdvFilterDeleteFilteringParametersData::parse(&bytes[..])?))}
ApcfAction::Add if LeAdvFilterAddFilteringParametersData::conforms(&bytes[..]) => {LeAdvFilterSetFilteringParametersDataChild::LeAdvFilterAddFilteringParameters(Arc::new(LeAdvFilterAddFilteringParametersData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "apcf_action".to_string(), value: v as u64}),};
Ok(Self {apcf_action, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let apcf_action = self.apcf_action.to_u8().unwrap();buffer[4..5].copy_from_slice(&apcf_action.to_le_bytes()[0..1]);match &self.child {LeAdvFilterSetFilteringParametersDataChild::LeAdvFilterAddFilteringParameters(value) => value.write_to(buffer),LeAdvFilterSetFilteringParametersDataChild::LeAdvFilterDeleteFilteringParameters(value) => value.write_to(buffer),LeAdvFilterSetFilteringParametersDataChild::LeAdvFilterClearFilteringParameters(value) => value.write_to(buffer),LeAdvFilterSetFilteringParametersDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeAdvFilterSetFilteringParametersPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAdvFilterSetFilteringParametersPacket { pub fn specialize(&self) -> LeAdvFilterSetFilteringParametersChild { match &self.le_adv_filter_set_filtering_parameters.child {LeAdvFilterSetFilteringParametersDataChild::LeAdvFilterAddFilteringParameters(_) => LeAdvFilterSetFilteringParametersChild::LeAdvFilterAddFilteringParameters(LeAdvFilterAddFilteringParametersPacket::new(self.command.clone())),LeAdvFilterSetFilteringParametersDataChild::LeAdvFilterDeleteFilteringParameters(_) => LeAdvFilterSetFilteringParametersChild::LeAdvFilterDeleteFilteringParameters(LeAdvFilterDeleteFilteringParametersPacket::new(self.command.clone())),LeAdvFilterSetFilteringParametersDataChild::LeAdvFilterClearFilteringParameters(_) => LeAdvFilterSetFilteringParametersChild::LeAdvFilterClearFilteringParameters(LeAdvFilterClearFilteringParametersPacket::new(self.command.clone())),LeAdvFilterSetFilteringParametersDataChild::None => LeAdvFilterSetFilteringParametersChild::None,}} fn new(root: Arc<CommandData>) -> Self {let command = root;let le_scanning_command = match &command.child {CommandDataChild::LeScanningCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanningCommand"),};let le_adv_filter = match &le_scanning_command.child {LeScanningCommandDataChild::LeAdvFilter(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilter"),};let le_adv_filter_set_filtering_parameters = match &le_adv_filter.child {LeAdvFilterDataChild::LeAdvFilterSetFilteringParameters(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterSetFilteringParameters"),};Self {command,le_scanning_command,le_adv_filter,le_adv_filter_set_filtering_parameters,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_apcf_opcode(&self) -> ApcfOpcode{ self.le_adv_filter.as_ref().apcf_opcode}
pub fn get_apcf_action(&self) -> ApcfAction{ self.le_adv_filter_set_filtering_parameters.as_ref().apcf_action}
}
impl Into<CommandPacket> for LeAdvFilterSetFilteringParametersPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeScanningCommandPacket> for LeAdvFilterSetFilteringParametersPacket { fn into(self) -> LeScanningCommandPacket {LeScanningCommandPacket::new(self.command) }}
impl Into<LeAdvFilterPacket> for LeAdvFilterSetFilteringParametersPacket { fn into(self) -> LeAdvFilterPacket {LeAdvFilterPacket::new(self.command) }}
impl LeAdvFilterSetFilteringParametersBuilder {pub fn build(self) -> LeAdvFilterSetFilteringParametersPacket {let le_adv_filter_set_filtering_parameters= Arc::new(LeAdvFilterSetFilteringParametersData {apcf_action: self.apcf_action, child: LeAdvFilterSetFilteringParametersDataChild::None,});let le_adv_filter= Arc::new(LeAdvFilterData {apcf_opcode: ApcfOpcode::SetFilteringParameters, child: LeAdvFilterDataChild::LeAdvFilterSetFilteringParameters(le_adv_filter_set_filtering_parameters),});let le_scanning_command= Arc::new(LeScanningCommandData {child: LeScanningCommandDataChild::LeAdvFilter(le_adv_filter),});let command= Arc::new(CommandData {op_code: OpCode::LeAdvFilter, child: CommandDataChild::LeScanningCommand(le_scanning_command),});LeAdvFilterSetFilteringParametersPacket::new(command)}
}
impl Into<CommandPacket> for LeAdvFilterSetFilteringParametersBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeScanningCommandPacket> for LeAdvFilterSetFilteringParametersBuilder { fn into(self) -> LeScanningCommandPacket { self.build().into() }}
impl Into<LeAdvFilterPacket> for LeAdvFilterSetFilteringParametersBuilder { fn into(self) -> LeAdvFilterPacket { self.build().into() }}


#[derive(Debug)] struct LeAdvFilterAddFilteringParametersData {apcf_filter_index: u8, apcf_feature_selection: u16, apcf_list_logic_type: u16, apcf_filter_logic_type: u8, rssi_high_thresh: u8, delivery_mode: DeliveryMode, onfound_timeout: u16, onfound_timeout_cnt: u8, rssi_low_thresh: u8, onlost_timeout: u16, num_of_tracking_entries: u16, }
#[derive(Debug, Clone)] pub struct LeAdvFilterAddFilteringParametersPacket {command: Arc<CommandData>,le_scanning_command: Arc<LeScanningCommandData>,le_adv_filter: Arc<LeAdvFilterData>,le_adv_filter_set_filtering_parameters: Arc<LeAdvFilterSetFilteringParametersData>,le_adv_filter_add_filtering_parameters: Arc<LeAdvFilterAddFilteringParametersData>,}
#[derive(Debug)] pub struct LeAdvFilterAddFilteringParametersBuilder {pub apcf_filter_index: u8, pub apcf_feature_selection: u16, pub apcf_list_logic_type: u16, pub apcf_filter_logic_type: u8, pub rssi_high_thresh: u8, pub delivery_mode: DeliveryMode, pub onfound_timeout: u16, pub onfound_timeout_cnt: u8, pub rssi_low_thresh: u8, pub onlost_timeout: u16, pub num_of_tracking_entries: u16, }
impl LeAdvFilterAddFilteringParametersData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterAddFilteringParameters".to_string(),    field: "apcf_filter_index".to_string(),    wanted: 6,    got: bytes.len()});}let apcf_filter_index = u8::from_le_bytes([bytes[5]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterAddFilteringParameters".to_string(),    field: "apcf_feature_selection".to_string(),    wanted: 8,    got: bytes.len()});}let apcf_feature_selection = u16::from_le_bytes([bytes[6],bytes[7]]);if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterAddFilteringParameters".to_string(),    field: "apcf_list_logic_type".to_string(),    wanted: 10,    got: bytes.len()});}let apcf_list_logic_type = u16::from_le_bytes([bytes[8],bytes[9]]);if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterAddFilteringParameters".to_string(),    field: "apcf_filter_logic_type".to_string(),    wanted: 11,    got: bytes.len()});}let apcf_filter_logic_type = u8::from_le_bytes([bytes[10]]);if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterAddFilteringParameters".to_string(),    field: "rssi_high_thresh".to_string(),    wanted: 12,    got: bytes.len()});}let rssi_high_thresh = u8::from_le_bytes([bytes[11]]);if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterAddFilteringParameters".to_string(),    field: "delivery_mode".to_string(),    wanted: 13,    got: bytes.len()});}let delivery_mode = u8::from_le_bytes([bytes[12]]);let delivery_mode = DeliveryMode::from_u8(delivery_mode).unwrap();if bytes.len() < 15 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterAddFilteringParameters".to_string(),    field: "onfound_timeout".to_string(),    wanted: 15,    got: bytes.len()});}let onfound_timeout = u16::from_le_bytes([bytes[13],bytes[14]]);if bytes.len() < 16 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterAddFilteringParameters".to_string(),    field: "onfound_timeout_cnt".to_string(),    wanted: 16,    got: bytes.len()});}let onfound_timeout_cnt = u8::from_le_bytes([bytes[15]]);if bytes.len() < 17 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterAddFilteringParameters".to_string(),    field: "rssi_low_thresh".to_string(),    wanted: 17,    got: bytes.len()});}let rssi_low_thresh = u8::from_le_bytes([bytes[16]]);if bytes.len() < 19 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterAddFilteringParameters".to_string(),    field: "onlost_timeout".to_string(),    wanted: 19,    got: bytes.len()});}let onlost_timeout = u16::from_le_bytes([bytes[17],bytes[18]]);if bytes.len() < 21 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterAddFilteringParameters".to_string(),    field: "num_of_tracking_entries".to_string(),    wanted: 21,    got: bytes.len()});}let num_of_tracking_entries = u16::from_le_bytes([bytes[19],bytes[20]]);Ok(Self {apcf_filter_index, apcf_feature_selection, apcf_list_logic_type, apcf_filter_logic_type, rssi_high_thresh, delivery_mode, onfound_timeout, onfound_timeout_cnt, rssi_low_thresh, onlost_timeout, num_of_tracking_entries, })
}
fn write_to(&self, buffer: &mut BytesMut) {let apcf_filter_index = self.apcf_filter_index;buffer[5..6].copy_from_slice(&apcf_filter_index.to_le_bytes()[0..1]);let apcf_feature_selection = self.apcf_feature_selection;buffer[6..8].copy_from_slice(&apcf_feature_selection.to_le_bytes()[0..2]);let apcf_list_logic_type = self.apcf_list_logic_type;buffer[8..10].copy_from_slice(&apcf_list_logic_type.to_le_bytes()[0..2]);let apcf_filter_logic_type = self.apcf_filter_logic_type;buffer[10..11].copy_from_slice(&apcf_filter_logic_type.to_le_bytes()[0..1]);let rssi_high_thresh = self.rssi_high_thresh;buffer[11..12].copy_from_slice(&rssi_high_thresh.to_le_bytes()[0..1]);let delivery_mode = self.delivery_mode.to_u8().unwrap();buffer[12..13].copy_from_slice(&delivery_mode.to_le_bytes()[0..1]);let onfound_timeout = self.onfound_timeout;buffer[13..15].copy_from_slice(&onfound_timeout.to_le_bytes()[0..2]);let onfound_timeout_cnt = self.onfound_timeout_cnt;buffer[15..16].copy_from_slice(&onfound_timeout_cnt.to_le_bytes()[0..1]);let rssi_low_thresh = self.rssi_low_thresh;buffer[16..17].copy_from_slice(&rssi_low_thresh.to_le_bytes()[0..1]);let onlost_timeout = self.onlost_timeout;buffer[17..19].copy_from_slice(&onlost_timeout.to_le_bytes()[0..2]);let num_of_tracking_entries = self.num_of_tracking_entries;buffer[19..21].copy_from_slice(&num_of_tracking_entries.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 16;ret}
}
impl Packet for LeAdvFilterAddFilteringParametersPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAdvFilterAddFilteringParametersPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_scanning_command = match &command.child {CommandDataChild::LeScanningCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanningCommand"),};let le_adv_filter = match &le_scanning_command.child {LeScanningCommandDataChild::LeAdvFilter(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilter"),};let le_adv_filter_set_filtering_parameters = match &le_adv_filter.child {LeAdvFilterDataChild::LeAdvFilterSetFilteringParameters(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterSetFilteringParameters"),};let le_adv_filter_add_filtering_parameters = match &le_adv_filter_set_filtering_parameters.child {LeAdvFilterSetFilteringParametersDataChild::LeAdvFilterAddFilteringParameters(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterAddFilteringParameters"),};Self {command,le_scanning_command,le_adv_filter,le_adv_filter_set_filtering_parameters,le_adv_filter_add_filtering_parameters,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_apcf_opcode(&self) -> ApcfOpcode{ self.le_adv_filter.as_ref().apcf_opcode}
pub fn get_apcf_action(&self) -> ApcfAction{ self.le_adv_filter_set_filtering_parameters.as_ref().apcf_action}
pub fn get_apcf_filter_index(&self) -> u8{ self.le_adv_filter_add_filtering_parameters.as_ref().apcf_filter_index}
pub fn get_apcf_feature_selection(&self) -> u16{ self.le_adv_filter_add_filtering_parameters.as_ref().apcf_feature_selection}
pub fn get_apcf_list_logic_type(&self) -> u16{ self.le_adv_filter_add_filtering_parameters.as_ref().apcf_list_logic_type}
pub fn get_apcf_filter_logic_type(&self) -> u8{ self.le_adv_filter_add_filtering_parameters.as_ref().apcf_filter_logic_type}
pub fn get_rssi_high_thresh(&self) -> u8{ self.le_adv_filter_add_filtering_parameters.as_ref().rssi_high_thresh}
pub fn get_delivery_mode(&self) -> DeliveryMode{ self.le_adv_filter_add_filtering_parameters.as_ref().delivery_mode}
pub fn get_onfound_timeout(&self) -> u16{ self.le_adv_filter_add_filtering_parameters.as_ref().onfound_timeout}
pub fn get_onfound_timeout_cnt(&self) -> u8{ self.le_adv_filter_add_filtering_parameters.as_ref().onfound_timeout_cnt}
pub fn get_rssi_low_thresh(&self) -> u8{ self.le_adv_filter_add_filtering_parameters.as_ref().rssi_low_thresh}
pub fn get_onlost_timeout(&self) -> u16{ self.le_adv_filter_add_filtering_parameters.as_ref().onlost_timeout}
pub fn get_num_of_tracking_entries(&self) -> u16{ self.le_adv_filter_add_filtering_parameters.as_ref().num_of_tracking_entries}
}
impl Into<CommandPacket> for LeAdvFilterAddFilteringParametersPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeScanningCommandPacket> for LeAdvFilterAddFilteringParametersPacket { fn into(self) -> LeScanningCommandPacket {LeScanningCommandPacket::new(self.command) }}
impl Into<LeAdvFilterPacket> for LeAdvFilterAddFilteringParametersPacket { fn into(self) -> LeAdvFilterPacket {LeAdvFilterPacket::new(self.command) }}
impl Into<LeAdvFilterSetFilteringParametersPacket> for LeAdvFilterAddFilteringParametersPacket { fn into(self) -> LeAdvFilterSetFilteringParametersPacket {LeAdvFilterSetFilteringParametersPacket::new(self.command) }}
impl LeAdvFilterAddFilteringParametersBuilder {pub fn build(self) -> LeAdvFilterAddFilteringParametersPacket {let le_adv_filter_add_filtering_parameters= Arc::new(LeAdvFilterAddFilteringParametersData {apcf_filter_index: self.apcf_filter_index, apcf_feature_selection: self.apcf_feature_selection, apcf_list_logic_type: self.apcf_list_logic_type, apcf_filter_logic_type: self.apcf_filter_logic_type, rssi_high_thresh: self.rssi_high_thresh, delivery_mode: self.delivery_mode, onfound_timeout: self.onfound_timeout, onfound_timeout_cnt: self.onfound_timeout_cnt, rssi_low_thresh: self.rssi_low_thresh, onlost_timeout: self.onlost_timeout, num_of_tracking_entries: self.num_of_tracking_entries, });let le_adv_filter_set_filtering_parameters= Arc::new(LeAdvFilterSetFilteringParametersData {apcf_action: ApcfAction::Add, child: LeAdvFilterSetFilteringParametersDataChild::LeAdvFilterAddFilteringParameters(le_adv_filter_add_filtering_parameters),});let le_adv_filter= Arc::new(LeAdvFilterData {apcf_opcode: ApcfOpcode::SetFilteringParameters, child: LeAdvFilterDataChild::LeAdvFilterSetFilteringParameters(le_adv_filter_set_filtering_parameters),});let le_scanning_command= Arc::new(LeScanningCommandData {child: LeScanningCommandDataChild::LeAdvFilter(le_adv_filter),});let command= Arc::new(CommandData {op_code: OpCode::LeAdvFilter, child: CommandDataChild::LeScanningCommand(le_scanning_command),});LeAdvFilterAddFilteringParametersPacket::new(command)}
}
impl Into<CommandPacket> for LeAdvFilterAddFilteringParametersBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeScanningCommandPacket> for LeAdvFilterAddFilteringParametersBuilder { fn into(self) -> LeScanningCommandPacket { self.build().into() }}
impl Into<LeAdvFilterPacket> for LeAdvFilterAddFilteringParametersBuilder { fn into(self) -> LeAdvFilterPacket { self.build().into() }}
impl Into<LeAdvFilterSetFilteringParametersPacket> for LeAdvFilterAddFilteringParametersBuilder { fn into(self) -> LeAdvFilterSetFilteringParametersPacket { self.build().into() }}


#[derive(Debug)] struct LeAdvFilterDeleteFilteringParametersData {apcf_filter_index: u8, }
#[derive(Debug, Clone)] pub struct LeAdvFilterDeleteFilteringParametersPacket {command: Arc<CommandData>,le_scanning_command: Arc<LeScanningCommandData>,le_adv_filter: Arc<LeAdvFilterData>,le_adv_filter_set_filtering_parameters: Arc<LeAdvFilterSetFilteringParametersData>,le_adv_filter_delete_filtering_parameters: Arc<LeAdvFilterDeleteFilteringParametersData>,}
#[derive(Debug)] pub struct LeAdvFilterDeleteFilteringParametersBuilder {pub apcf_filter_index: u8, }
impl LeAdvFilterDeleteFilteringParametersData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterDeleteFilteringParameters".to_string(),    field: "apcf_filter_index".to_string(),    wanted: 6,    got: bytes.len()});}let apcf_filter_index = u8::from_le_bytes([bytes[5]]);Ok(Self {apcf_filter_index, })
}
fn write_to(&self, buffer: &mut BytesMut) {let apcf_filter_index = self.apcf_filter_index;buffer[5..6].copy_from_slice(&apcf_filter_index.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeAdvFilterDeleteFilteringParametersPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAdvFilterDeleteFilteringParametersPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_scanning_command = match &command.child {CommandDataChild::LeScanningCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanningCommand"),};let le_adv_filter = match &le_scanning_command.child {LeScanningCommandDataChild::LeAdvFilter(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilter"),};let le_adv_filter_set_filtering_parameters = match &le_adv_filter.child {LeAdvFilterDataChild::LeAdvFilterSetFilteringParameters(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterSetFilteringParameters"),};let le_adv_filter_delete_filtering_parameters = match &le_adv_filter_set_filtering_parameters.child {LeAdvFilterSetFilteringParametersDataChild::LeAdvFilterDeleteFilteringParameters(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterDeleteFilteringParameters"),};Self {command,le_scanning_command,le_adv_filter,le_adv_filter_set_filtering_parameters,le_adv_filter_delete_filtering_parameters,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_apcf_opcode(&self) -> ApcfOpcode{ self.le_adv_filter.as_ref().apcf_opcode}
pub fn get_apcf_action(&self) -> ApcfAction{ self.le_adv_filter_set_filtering_parameters.as_ref().apcf_action}
pub fn get_apcf_filter_index(&self) -> u8{ self.le_adv_filter_delete_filtering_parameters.as_ref().apcf_filter_index}
}
impl Into<CommandPacket> for LeAdvFilterDeleteFilteringParametersPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeScanningCommandPacket> for LeAdvFilterDeleteFilteringParametersPacket { fn into(self) -> LeScanningCommandPacket {LeScanningCommandPacket::new(self.command) }}
impl Into<LeAdvFilterPacket> for LeAdvFilterDeleteFilteringParametersPacket { fn into(self) -> LeAdvFilterPacket {LeAdvFilterPacket::new(self.command) }}
impl Into<LeAdvFilterSetFilteringParametersPacket> for LeAdvFilterDeleteFilteringParametersPacket { fn into(self) -> LeAdvFilterSetFilteringParametersPacket {LeAdvFilterSetFilteringParametersPacket::new(self.command) }}
impl LeAdvFilterDeleteFilteringParametersBuilder {pub fn build(self) -> LeAdvFilterDeleteFilteringParametersPacket {let le_adv_filter_delete_filtering_parameters= Arc::new(LeAdvFilterDeleteFilteringParametersData {apcf_filter_index: self.apcf_filter_index, });let le_adv_filter_set_filtering_parameters= Arc::new(LeAdvFilterSetFilteringParametersData {apcf_action: ApcfAction::Delete, child: LeAdvFilterSetFilteringParametersDataChild::LeAdvFilterDeleteFilteringParameters(le_adv_filter_delete_filtering_parameters),});let le_adv_filter= Arc::new(LeAdvFilterData {apcf_opcode: ApcfOpcode::SetFilteringParameters, child: LeAdvFilterDataChild::LeAdvFilterSetFilteringParameters(le_adv_filter_set_filtering_parameters),});let le_scanning_command= Arc::new(LeScanningCommandData {child: LeScanningCommandDataChild::LeAdvFilter(le_adv_filter),});let command= Arc::new(CommandData {op_code: OpCode::LeAdvFilter, child: CommandDataChild::LeScanningCommand(le_scanning_command),});LeAdvFilterDeleteFilteringParametersPacket::new(command)}
}
impl Into<CommandPacket> for LeAdvFilterDeleteFilteringParametersBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeScanningCommandPacket> for LeAdvFilterDeleteFilteringParametersBuilder { fn into(self) -> LeScanningCommandPacket { self.build().into() }}
impl Into<LeAdvFilterPacket> for LeAdvFilterDeleteFilteringParametersBuilder { fn into(self) -> LeAdvFilterPacket { self.build().into() }}
impl Into<LeAdvFilterSetFilteringParametersPacket> for LeAdvFilterDeleteFilteringParametersBuilder { fn into(self) -> LeAdvFilterSetFilteringParametersPacket { self.build().into() }}


#[derive(Debug)] struct LeAdvFilterClearFilteringParametersData {}
#[derive(Debug, Clone)] pub struct LeAdvFilterClearFilteringParametersPacket {command: Arc<CommandData>,le_scanning_command: Arc<LeScanningCommandData>,le_adv_filter: Arc<LeAdvFilterData>,le_adv_filter_set_filtering_parameters: Arc<LeAdvFilterSetFilteringParametersData>,le_adv_filter_clear_filtering_parameters: Arc<LeAdvFilterClearFilteringParametersData>,}
#[derive(Debug)] pub struct LeAdvFilterClearFilteringParametersBuilder {}
impl LeAdvFilterClearFilteringParametersData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeAdvFilterClearFilteringParametersPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAdvFilterClearFilteringParametersPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_scanning_command = match &command.child {CommandDataChild::LeScanningCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanningCommand"),};let le_adv_filter = match &le_scanning_command.child {LeScanningCommandDataChild::LeAdvFilter(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilter"),};let le_adv_filter_set_filtering_parameters = match &le_adv_filter.child {LeAdvFilterDataChild::LeAdvFilterSetFilteringParameters(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterSetFilteringParameters"),};let le_adv_filter_clear_filtering_parameters = match &le_adv_filter_set_filtering_parameters.child {LeAdvFilterSetFilteringParametersDataChild::LeAdvFilterClearFilteringParameters(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterClearFilteringParameters"),};Self {command,le_scanning_command,le_adv_filter,le_adv_filter_set_filtering_parameters,le_adv_filter_clear_filtering_parameters,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_apcf_opcode(&self) -> ApcfOpcode{ self.le_adv_filter.as_ref().apcf_opcode}
pub fn get_apcf_action(&self) -> ApcfAction{ self.le_adv_filter_set_filtering_parameters.as_ref().apcf_action}
}
impl Into<CommandPacket> for LeAdvFilterClearFilteringParametersPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeScanningCommandPacket> for LeAdvFilterClearFilteringParametersPacket { fn into(self) -> LeScanningCommandPacket {LeScanningCommandPacket::new(self.command) }}
impl Into<LeAdvFilterPacket> for LeAdvFilterClearFilteringParametersPacket { fn into(self) -> LeAdvFilterPacket {LeAdvFilterPacket::new(self.command) }}
impl Into<LeAdvFilterSetFilteringParametersPacket> for LeAdvFilterClearFilteringParametersPacket { fn into(self) -> LeAdvFilterSetFilteringParametersPacket {LeAdvFilterSetFilteringParametersPacket::new(self.command) }}
impl LeAdvFilterClearFilteringParametersBuilder {pub fn build(self) -> LeAdvFilterClearFilteringParametersPacket {let le_adv_filter_clear_filtering_parameters= Arc::new(LeAdvFilterClearFilteringParametersData {});let le_adv_filter_set_filtering_parameters= Arc::new(LeAdvFilterSetFilteringParametersData {apcf_action: ApcfAction::Clear, child: LeAdvFilterSetFilteringParametersDataChild::LeAdvFilterClearFilteringParameters(le_adv_filter_clear_filtering_parameters),});let le_adv_filter= Arc::new(LeAdvFilterData {apcf_opcode: ApcfOpcode::SetFilteringParameters, child: LeAdvFilterDataChild::LeAdvFilterSetFilteringParameters(le_adv_filter_set_filtering_parameters),});let le_scanning_command= Arc::new(LeScanningCommandData {child: LeScanningCommandDataChild::LeAdvFilter(le_adv_filter),});let command= Arc::new(CommandData {op_code: OpCode::LeAdvFilter, child: CommandDataChild::LeScanningCommand(le_scanning_command),});LeAdvFilterClearFilteringParametersPacket::new(command)}
}
impl Into<CommandPacket> for LeAdvFilterClearFilteringParametersBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeScanningCommandPacket> for LeAdvFilterClearFilteringParametersBuilder { fn into(self) -> LeScanningCommandPacket { self.build().into() }}
impl Into<LeAdvFilterPacket> for LeAdvFilterClearFilteringParametersBuilder { fn into(self) -> LeAdvFilterPacket { self.build().into() }}
impl Into<LeAdvFilterSetFilteringParametersPacket> for LeAdvFilterClearFilteringParametersBuilder { fn into(self) -> LeAdvFilterSetFilteringParametersPacket { self.build().into() }}


#[derive(Debug)] struct LeAdvFilterSetFilteringParametersCompleteData {apcf_action: ApcfAction, apcf_available_spaces: u8, }
#[derive(Debug, Clone)] pub struct LeAdvFilterSetFilteringParametersCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_adv_filter_complete: Arc<LeAdvFilterCompleteData>,le_adv_filter_set_filtering_parameters_complete: Arc<LeAdvFilterSetFilteringParametersCompleteData>,}
#[derive(Debug)] pub struct LeAdvFilterSetFilteringParametersCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub apcf_action: ApcfAction, pub apcf_available_spaces: u8, }
impl LeAdvFilterSetFilteringParametersCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterSetFilteringParametersComplete".to_string(),    field: "apcf_action".to_string(),    wanted: 8,    got: bytes.len()});}let apcf_action = u8::from_le_bytes([bytes[7]]);let apcf_action = ApcfAction::from_u8(apcf_action).unwrap();if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterSetFilteringParametersComplete".to_string(),    field: "apcf_available_spaces".to_string(),    wanted: 9,    got: bytes.len()});}let apcf_available_spaces = u8::from_le_bytes([bytes[8]]);Ok(Self {apcf_action, apcf_available_spaces, })
}
fn write_to(&self, buffer: &mut BytesMut) {let apcf_action = self.apcf_action.to_u8().unwrap();buffer[7..8].copy_from_slice(&apcf_action.to_le_bytes()[0..1]);let apcf_available_spaces = self.apcf_available_spaces;buffer[8..9].copy_from_slice(&apcf_available_spaces.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for LeAdvFilterSetFilteringParametersCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAdvFilterSetFilteringParametersCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_adv_filter_complete = match &command_complete.child {CommandCompleteDataChild::LeAdvFilterComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterComplete"),};let le_adv_filter_set_filtering_parameters_complete = match &le_adv_filter_complete.child {LeAdvFilterCompleteDataChild::LeAdvFilterSetFilteringParametersComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterSetFilteringParametersComplete"),};Self {event,command_complete,le_adv_filter_complete,le_adv_filter_set_filtering_parameters_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_adv_filter_complete.as_ref().status}
pub fn get_apcf_opcode(&self) -> ApcfOpcode{ self.le_adv_filter_complete.as_ref().apcf_opcode}
pub fn get_apcf_action(&self) -> ApcfAction{ self.le_adv_filter_set_filtering_parameters_complete.as_ref().apcf_action}
pub fn get_apcf_available_spaces(&self) -> u8{ self.le_adv_filter_set_filtering_parameters_complete.as_ref().apcf_available_spaces}
}
impl Into<EventPacket> for LeAdvFilterSetFilteringParametersCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeAdvFilterSetFilteringParametersCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl Into<LeAdvFilterCompletePacket> for LeAdvFilterSetFilteringParametersCompletePacket { fn into(self) -> LeAdvFilterCompletePacket {LeAdvFilterCompletePacket::new(self.event) }}
impl LeAdvFilterSetFilteringParametersCompleteBuilder {pub fn build(self) -> LeAdvFilterSetFilteringParametersCompletePacket {let le_adv_filter_set_filtering_parameters_complete= Arc::new(LeAdvFilterSetFilteringParametersCompleteData {apcf_action: self.apcf_action, apcf_available_spaces: self.apcf_available_spaces, });let le_adv_filter_complete= Arc::new(LeAdvFilterCompleteData {status: self.status, apcf_opcode: ApcfOpcode::SetFilteringParameters, child: LeAdvFilterCompleteDataChild::LeAdvFilterSetFilteringParametersComplete(le_adv_filter_set_filtering_parameters_complete),});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeAdvFilter, child: CommandCompleteDataChild::LeAdvFilterComplete(le_adv_filter_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeAdvFilterSetFilteringParametersCompletePacket::new(event)}
}
impl Into<EventPacket> for LeAdvFilterSetFilteringParametersCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeAdvFilterSetFilteringParametersCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
impl Into<LeAdvFilterCompletePacket> for LeAdvFilterSetFilteringParametersCompleteBuilder { fn into(self) -> LeAdvFilterCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeAdvFilterBroadcasterAddressData {apcf_action: ApcfAction, apcf_filter_index: u8, apcf_broadcaster_address: Address, apcf_application_address_type: ApcfApplicationAddressType, }
#[derive(Debug, Clone)] pub struct LeAdvFilterBroadcasterAddressPacket {command: Arc<CommandData>,le_scanning_command: Arc<LeScanningCommandData>,le_adv_filter: Arc<LeAdvFilterData>,le_adv_filter_broadcaster_address: Arc<LeAdvFilterBroadcasterAddressData>,}
#[derive(Debug)] pub struct LeAdvFilterBroadcasterAddressBuilder {pub apcf_action: ApcfAction, pub apcf_filter_index: u8, pub apcf_broadcaster_address: Address, pub apcf_application_address_type: ApcfApplicationAddressType, }
impl LeAdvFilterBroadcasterAddressData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterBroadcasterAddress".to_string(),    field: "apcf_action".to_string(),    wanted: 5,    got: bytes.len()});}let apcf_action = u8::from_le_bytes([bytes[4]]);let apcf_action = ApcfAction::from_u8(apcf_action).unwrap();if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterBroadcasterAddress".to_string(),    field: "apcf_filter_index".to_string(),    wanted: 6,    got: bytes.len()});}let apcf_filter_index = u8::from_le_bytes([bytes[5]]);if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterBroadcasterAddress".to_string(),    field: "apcf_broadcaster_address".to_string(),    wanted: 12,    got: bytes.len()});}let apcf_broadcaster_address = bytes[6..12].try_into().unwrap();if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterBroadcasterAddress".to_string(),    field: "apcf_application_address_type".to_string(),    wanted: 13,    got: bytes.len()});}let apcf_application_address_type = u8::from_le_bytes([bytes[12]]);let apcf_application_address_type = ApcfApplicationAddressType::from_u8(apcf_application_address_type).unwrap();Ok(Self {apcf_action, apcf_filter_index, apcf_broadcaster_address, apcf_application_address_type, })
}
fn write_to(&self, buffer: &mut BytesMut) {let apcf_action = self.apcf_action.to_u8().unwrap();buffer[4..5].copy_from_slice(&apcf_action.to_le_bytes()[0..1]);let apcf_filter_index = self.apcf_filter_index;buffer[5..6].copy_from_slice(&apcf_filter_index.to_le_bytes()[0..1]);let apcf_broadcaster_address: [u8; 6] = self.apcf_broadcaster_address.into();buffer[6..12].copy_from_slice(&apcf_broadcaster_address);let apcf_application_address_type = self.apcf_application_address_type.to_u8().unwrap();buffer[12..13].copy_from_slice(&apcf_application_address_type.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 9;ret}
}
impl Packet for LeAdvFilterBroadcasterAddressPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAdvFilterBroadcasterAddressPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_scanning_command = match &command.child {CommandDataChild::LeScanningCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanningCommand"),};let le_adv_filter = match &le_scanning_command.child {LeScanningCommandDataChild::LeAdvFilter(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilter"),};let le_adv_filter_broadcaster_address = match &le_adv_filter.child {LeAdvFilterDataChild::LeAdvFilterBroadcasterAddress(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterBroadcasterAddress"),};Self {command,le_scanning_command,le_adv_filter,le_adv_filter_broadcaster_address,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_apcf_opcode(&self) -> ApcfOpcode{ self.le_adv_filter.as_ref().apcf_opcode}
pub fn get_apcf_action(&self) -> ApcfAction{ self.le_adv_filter_broadcaster_address.as_ref().apcf_action}
pub fn get_apcf_filter_index(&self) -> u8{ self.le_adv_filter_broadcaster_address.as_ref().apcf_filter_index}
pub fn get_apcf_broadcaster_address(&self) -> Address{ self.le_adv_filter_broadcaster_address.as_ref().apcf_broadcaster_address}
pub fn get_apcf_application_address_type(&self) -> ApcfApplicationAddressType{ self.le_adv_filter_broadcaster_address.as_ref().apcf_application_address_type}
}
impl Into<CommandPacket> for LeAdvFilterBroadcasterAddressPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeScanningCommandPacket> for LeAdvFilterBroadcasterAddressPacket { fn into(self) -> LeScanningCommandPacket {LeScanningCommandPacket::new(self.command) }}
impl Into<LeAdvFilterPacket> for LeAdvFilterBroadcasterAddressPacket { fn into(self) -> LeAdvFilterPacket {LeAdvFilterPacket::new(self.command) }}
impl LeAdvFilterBroadcasterAddressBuilder {pub fn build(self) -> LeAdvFilterBroadcasterAddressPacket {let le_adv_filter_broadcaster_address= Arc::new(LeAdvFilterBroadcasterAddressData {apcf_action: self.apcf_action, apcf_filter_index: self.apcf_filter_index, apcf_broadcaster_address: self.apcf_broadcaster_address, apcf_application_address_type: self.apcf_application_address_type, });let le_adv_filter= Arc::new(LeAdvFilterData {apcf_opcode: ApcfOpcode::BroadcasterAddress, child: LeAdvFilterDataChild::LeAdvFilterBroadcasterAddress(le_adv_filter_broadcaster_address),});let le_scanning_command= Arc::new(LeScanningCommandData {child: LeScanningCommandDataChild::LeAdvFilter(le_adv_filter),});let command= Arc::new(CommandData {op_code: OpCode::LeAdvFilter, child: CommandDataChild::LeScanningCommand(le_scanning_command),});LeAdvFilterBroadcasterAddressPacket::new(command)}
}
impl Into<CommandPacket> for LeAdvFilterBroadcasterAddressBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeScanningCommandPacket> for LeAdvFilterBroadcasterAddressBuilder { fn into(self) -> LeScanningCommandPacket { self.build().into() }}
impl Into<LeAdvFilterPacket> for LeAdvFilterBroadcasterAddressBuilder { fn into(self) -> LeAdvFilterPacket { self.build().into() }}


#[derive(Debug)] struct LeAdvFilterClearBroadcasterAddressData {apcf_filter_index: u8, }
#[derive(Debug, Clone)] pub struct LeAdvFilterClearBroadcasterAddressPacket {command: Arc<CommandData>,le_scanning_command: Arc<LeScanningCommandData>,le_adv_filter: Arc<LeAdvFilterData>,le_adv_filter_clear_broadcaster_address: Arc<LeAdvFilterClearBroadcasterAddressData>,}
#[derive(Debug)] pub struct LeAdvFilterClearBroadcasterAddressBuilder {pub apcf_filter_index: u8, }
impl LeAdvFilterClearBroadcasterAddressData {fn conforms(bytes: &[u8]) -> bool {let fixed_scalar10 = u8::from_le_bytes([bytes[4]]);if fixed_scalar10 != 2 { return false; }  true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterClearBroadcasterAddress".to_string(),    field: "fixed_scalar10".to_string(),    wanted: 5,    got: bytes.len()});}let fixed_scalar10 = u8::from_le_bytes([bytes[4]]);if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterClearBroadcasterAddress".to_string(),    field: "apcf_filter_index".to_string(),    wanted: 6,    got: bytes.len()});}let apcf_filter_index = u8::from_le_bytes([bytes[5]]);Ok(Self {apcf_filter_index, })
}
fn write_to(&self, buffer: &mut BytesMut) {let fixed_scalar10: u8 = 2;buffer[4..5].copy_from_slice(&fixed_scalar10.to_le_bytes()[0..1]);let apcf_filter_index = self.apcf_filter_index;buffer[5..6].copy_from_slice(&apcf_filter_index.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for LeAdvFilterClearBroadcasterAddressPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAdvFilterClearBroadcasterAddressPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_scanning_command = match &command.child {CommandDataChild::LeScanningCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanningCommand"),};let le_adv_filter = match &le_scanning_command.child {LeScanningCommandDataChild::LeAdvFilter(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilter"),};let le_adv_filter_clear_broadcaster_address = match &le_adv_filter.child {LeAdvFilterDataChild::LeAdvFilterClearBroadcasterAddress(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterClearBroadcasterAddress"),};Self {command,le_scanning_command,le_adv_filter,le_adv_filter_clear_broadcaster_address,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_apcf_opcode(&self) -> ApcfOpcode{ self.le_adv_filter.as_ref().apcf_opcode}
pub fn get_apcf_filter_index(&self) -> u8{ self.le_adv_filter_clear_broadcaster_address.as_ref().apcf_filter_index}
}
impl Into<CommandPacket> for LeAdvFilterClearBroadcasterAddressPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeScanningCommandPacket> for LeAdvFilterClearBroadcasterAddressPacket { fn into(self) -> LeScanningCommandPacket {LeScanningCommandPacket::new(self.command) }}
impl Into<LeAdvFilterPacket> for LeAdvFilterClearBroadcasterAddressPacket { fn into(self) -> LeAdvFilterPacket {LeAdvFilterPacket::new(self.command) }}
impl LeAdvFilterClearBroadcasterAddressBuilder {pub fn build(self) -> LeAdvFilterClearBroadcasterAddressPacket {let le_adv_filter_clear_broadcaster_address= Arc::new(LeAdvFilterClearBroadcasterAddressData {apcf_filter_index: self.apcf_filter_index, });let le_adv_filter= Arc::new(LeAdvFilterData {apcf_opcode: ApcfOpcode::BroadcasterAddress, child: LeAdvFilterDataChild::LeAdvFilterClearBroadcasterAddress(le_adv_filter_clear_broadcaster_address),});let le_scanning_command= Arc::new(LeScanningCommandData {child: LeScanningCommandDataChild::LeAdvFilter(le_adv_filter),});let command= Arc::new(CommandData {op_code: OpCode::LeAdvFilter, child: CommandDataChild::LeScanningCommand(le_scanning_command),});LeAdvFilterClearBroadcasterAddressPacket::new(command)}
}
impl Into<CommandPacket> for LeAdvFilterClearBroadcasterAddressBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeScanningCommandPacket> for LeAdvFilterClearBroadcasterAddressBuilder { fn into(self) -> LeScanningCommandPacket { self.build().into() }}
impl Into<LeAdvFilterPacket> for LeAdvFilterClearBroadcasterAddressBuilder { fn into(self) -> LeAdvFilterPacket { self.build().into() }}


#[derive(Debug)] struct LeAdvFilterBroadcasterAddressCompleteData {apcf_action: ApcfAction, apcf_available_spaces: u8, }
#[derive(Debug, Clone)] pub struct LeAdvFilterBroadcasterAddressCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_adv_filter_complete: Arc<LeAdvFilterCompleteData>,le_adv_filter_broadcaster_address_complete: Arc<LeAdvFilterBroadcasterAddressCompleteData>,}
#[derive(Debug)] pub struct LeAdvFilterBroadcasterAddressCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub apcf_action: ApcfAction, pub apcf_available_spaces: u8, }
impl LeAdvFilterBroadcasterAddressCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterBroadcasterAddressComplete".to_string(),    field: "apcf_action".to_string(),    wanted: 8,    got: bytes.len()});}let apcf_action = u8::from_le_bytes([bytes[7]]);let apcf_action = ApcfAction::from_u8(apcf_action).unwrap();if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterBroadcasterAddressComplete".to_string(),    field: "apcf_available_spaces".to_string(),    wanted: 9,    got: bytes.len()});}let apcf_available_spaces = u8::from_le_bytes([bytes[8]]);Ok(Self {apcf_action, apcf_available_spaces, })
}
fn write_to(&self, buffer: &mut BytesMut) {let apcf_action = self.apcf_action.to_u8().unwrap();buffer[7..8].copy_from_slice(&apcf_action.to_le_bytes()[0..1]);let apcf_available_spaces = self.apcf_available_spaces;buffer[8..9].copy_from_slice(&apcf_available_spaces.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for LeAdvFilterBroadcasterAddressCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAdvFilterBroadcasterAddressCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_adv_filter_complete = match &command_complete.child {CommandCompleteDataChild::LeAdvFilterComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterComplete"),};let le_adv_filter_broadcaster_address_complete = match &le_adv_filter_complete.child {LeAdvFilterCompleteDataChild::LeAdvFilterBroadcasterAddressComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterBroadcasterAddressComplete"),};Self {event,command_complete,le_adv_filter_complete,le_adv_filter_broadcaster_address_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_adv_filter_complete.as_ref().status}
pub fn get_apcf_opcode(&self) -> ApcfOpcode{ self.le_adv_filter_complete.as_ref().apcf_opcode}
pub fn get_apcf_action(&self) -> ApcfAction{ self.le_adv_filter_broadcaster_address_complete.as_ref().apcf_action}
pub fn get_apcf_available_spaces(&self) -> u8{ self.le_adv_filter_broadcaster_address_complete.as_ref().apcf_available_spaces}
}
impl Into<EventPacket> for LeAdvFilterBroadcasterAddressCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeAdvFilterBroadcasterAddressCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl Into<LeAdvFilterCompletePacket> for LeAdvFilterBroadcasterAddressCompletePacket { fn into(self) -> LeAdvFilterCompletePacket {LeAdvFilterCompletePacket::new(self.event) }}
impl LeAdvFilterBroadcasterAddressCompleteBuilder {pub fn build(self) -> LeAdvFilterBroadcasterAddressCompletePacket {let le_adv_filter_broadcaster_address_complete= Arc::new(LeAdvFilterBroadcasterAddressCompleteData {apcf_action: self.apcf_action, apcf_available_spaces: self.apcf_available_spaces, });let le_adv_filter_complete= Arc::new(LeAdvFilterCompleteData {status: self.status, apcf_opcode: ApcfOpcode::BroadcasterAddress, child: LeAdvFilterCompleteDataChild::LeAdvFilterBroadcasterAddressComplete(le_adv_filter_broadcaster_address_complete),});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeAdvFilter, child: CommandCompleteDataChild::LeAdvFilterComplete(le_adv_filter_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeAdvFilterBroadcasterAddressCompletePacket::new(event)}
}
impl Into<EventPacket> for LeAdvFilterBroadcasterAddressCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeAdvFilterBroadcasterAddressCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
impl Into<LeAdvFilterCompletePacket> for LeAdvFilterBroadcasterAddressCompleteBuilder { fn into(self) -> LeAdvFilterCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeAdvFilterServiceUuidData {apcf_action: ApcfAction, apcf_filter_index: u8, acpf_uuid_data: Vec::<u8>, }
#[derive(Debug, Clone)] pub struct LeAdvFilterServiceUuidPacket {command: Arc<CommandData>,le_scanning_command: Arc<LeScanningCommandData>,le_adv_filter: Arc<LeAdvFilterData>,le_adv_filter_service_uuid: Arc<LeAdvFilterServiceUuidData>,}
#[derive(Debug)] pub struct LeAdvFilterServiceUuidBuilder {pub apcf_action: ApcfAction, pub apcf_filter_index: u8, pub acpf_uuid_data: Vec::<u8>, }
impl LeAdvFilterServiceUuidData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterServiceUuid".to_string(),    field: "apcf_action".to_string(),    wanted: 5,    got: bytes.len()});}let apcf_action = u8::from_le_bytes([bytes[4]]);let apcf_action = ApcfAction::from_u8(apcf_action).unwrap();if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterServiceUuid".to_string(),    field: "apcf_filter_index".to_string(),    wanted: 6,    got: bytes.len()});}let apcf_filter_index = u8::from_le_bytes([bytes[5]]);let rem_ = (bytes.len() - 6) % 1;if rem_ != 0 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterServiceUuid".to_string(),    field: "acpf_uuid_data".to_string(),    wanted: bytes.len() + rem_,    got: bytes.len()});}let acpf_uuid_data: Vec::<u8> = bytes[6..].to_vec().chunks_exact(1).into_iter().map(|i| u8::from_le_bytes([i[0]])).collect();Ok(Self {apcf_action, apcf_filter_index, acpf_uuid_data, })
}
fn write_to(&self, buffer: &mut BytesMut) {let apcf_action = self.apcf_action.to_u8().unwrap();buffer[4..5].copy_from_slice(&apcf_action.to_le_bytes()[0..1]);let apcf_filter_index = self.apcf_filter_index;buffer[5..6].copy_from_slice(&apcf_filter_index.to_le_bytes()[0..1]);for (i, e) in self.acpf_uuid_data.iter().enumerate() {buffer[6+i..6+i+1].copy_from_slice(&e.to_le_bytes())}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;let ret = ret + (self.acpf_uuid_data.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8));ret}
}
impl Packet for LeAdvFilterServiceUuidPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAdvFilterServiceUuidPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_scanning_command = match &command.child {CommandDataChild::LeScanningCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanningCommand"),};let le_adv_filter = match &le_scanning_command.child {LeScanningCommandDataChild::LeAdvFilter(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilter"),};let le_adv_filter_service_uuid = match &le_adv_filter.child {LeAdvFilterDataChild::LeAdvFilterServiceUuid(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterServiceUuid"),};Self {command,le_scanning_command,le_adv_filter,le_adv_filter_service_uuid,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_apcf_opcode(&self) -> ApcfOpcode{ self.le_adv_filter.as_ref().apcf_opcode}
pub fn get_apcf_action(&self) -> ApcfAction{ self.le_adv_filter_service_uuid.as_ref().apcf_action}
pub fn get_apcf_filter_index(&self) -> u8{ self.le_adv_filter_service_uuid.as_ref().apcf_filter_index}
pub fn get_acpf_uuid_data(&self) -> &Vec::<u8>{ &self.le_adv_filter_service_uuid.as_ref().acpf_uuid_data}
}
impl Into<CommandPacket> for LeAdvFilterServiceUuidPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeScanningCommandPacket> for LeAdvFilterServiceUuidPacket { fn into(self) -> LeScanningCommandPacket {LeScanningCommandPacket::new(self.command) }}
impl Into<LeAdvFilterPacket> for LeAdvFilterServiceUuidPacket { fn into(self) -> LeAdvFilterPacket {LeAdvFilterPacket::new(self.command) }}
impl LeAdvFilterServiceUuidBuilder {pub fn build(self) -> LeAdvFilterServiceUuidPacket {let le_adv_filter_service_uuid= Arc::new(LeAdvFilterServiceUuidData {apcf_action: self.apcf_action, apcf_filter_index: self.apcf_filter_index, acpf_uuid_data: self.acpf_uuid_data, });let le_adv_filter= Arc::new(LeAdvFilterData {apcf_opcode: ApcfOpcode::ServiceUuid, child: LeAdvFilterDataChild::LeAdvFilterServiceUuid(le_adv_filter_service_uuid),});let le_scanning_command= Arc::new(LeScanningCommandData {child: LeScanningCommandDataChild::LeAdvFilter(le_adv_filter),});let command= Arc::new(CommandData {op_code: OpCode::LeAdvFilter, child: CommandDataChild::LeScanningCommand(le_scanning_command),});LeAdvFilterServiceUuidPacket::new(command)}
}
impl Into<CommandPacket> for LeAdvFilterServiceUuidBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeScanningCommandPacket> for LeAdvFilterServiceUuidBuilder { fn into(self) -> LeScanningCommandPacket { self.build().into() }}
impl Into<LeAdvFilterPacket> for LeAdvFilterServiceUuidBuilder { fn into(self) -> LeAdvFilterPacket { self.build().into() }}


#[derive(Debug)] struct LeAdvFilterServiceUuidCompleteData {apcf_action: ApcfAction, apcf_available_spaces: u8, }
#[derive(Debug, Clone)] pub struct LeAdvFilterServiceUuidCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_adv_filter_complete: Arc<LeAdvFilterCompleteData>,le_adv_filter_service_uuid_complete: Arc<LeAdvFilterServiceUuidCompleteData>,}
#[derive(Debug)] pub struct LeAdvFilterServiceUuidCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub apcf_action: ApcfAction, pub apcf_available_spaces: u8, }
impl LeAdvFilterServiceUuidCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterServiceUuidComplete".to_string(),    field: "apcf_action".to_string(),    wanted: 8,    got: bytes.len()});}let apcf_action = u8::from_le_bytes([bytes[7]]);let apcf_action = ApcfAction::from_u8(apcf_action).unwrap();if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterServiceUuidComplete".to_string(),    field: "apcf_available_spaces".to_string(),    wanted: 9,    got: bytes.len()});}let apcf_available_spaces = u8::from_le_bytes([bytes[8]]);Ok(Self {apcf_action, apcf_available_spaces, })
}
fn write_to(&self, buffer: &mut BytesMut) {let apcf_action = self.apcf_action.to_u8().unwrap();buffer[7..8].copy_from_slice(&apcf_action.to_le_bytes()[0..1]);let apcf_available_spaces = self.apcf_available_spaces;buffer[8..9].copy_from_slice(&apcf_available_spaces.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for LeAdvFilterServiceUuidCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAdvFilterServiceUuidCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_adv_filter_complete = match &command_complete.child {CommandCompleteDataChild::LeAdvFilterComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterComplete"),};let le_adv_filter_service_uuid_complete = match &le_adv_filter_complete.child {LeAdvFilterCompleteDataChild::LeAdvFilterServiceUuidComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterServiceUuidComplete"),};Self {event,command_complete,le_adv_filter_complete,le_adv_filter_service_uuid_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_adv_filter_complete.as_ref().status}
pub fn get_apcf_opcode(&self) -> ApcfOpcode{ self.le_adv_filter_complete.as_ref().apcf_opcode}
pub fn get_apcf_action(&self) -> ApcfAction{ self.le_adv_filter_service_uuid_complete.as_ref().apcf_action}
pub fn get_apcf_available_spaces(&self) -> u8{ self.le_adv_filter_service_uuid_complete.as_ref().apcf_available_spaces}
}
impl Into<EventPacket> for LeAdvFilterServiceUuidCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeAdvFilterServiceUuidCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl Into<LeAdvFilterCompletePacket> for LeAdvFilterServiceUuidCompletePacket { fn into(self) -> LeAdvFilterCompletePacket {LeAdvFilterCompletePacket::new(self.event) }}
impl LeAdvFilterServiceUuidCompleteBuilder {pub fn build(self) -> LeAdvFilterServiceUuidCompletePacket {let le_adv_filter_service_uuid_complete= Arc::new(LeAdvFilterServiceUuidCompleteData {apcf_action: self.apcf_action, apcf_available_spaces: self.apcf_available_spaces, });let le_adv_filter_complete= Arc::new(LeAdvFilterCompleteData {status: self.status, apcf_opcode: ApcfOpcode::ServiceUuid, child: LeAdvFilterCompleteDataChild::LeAdvFilterServiceUuidComplete(le_adv_filter_service_uuid_complete),});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeAdvFilter, child: CommandCompleteDataChild::LeAdvFilterComplete(le_adv_filter_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeAdvFilterServiceUuidCompletePacket::new(event)}
}
impl Into<EventPacket> for LeAdvFilterServiceUuidCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeAdvFilterServiceUuidCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
impl Into<LeAdvFilterCompletePacket> for LeAdvFilterServiceUuidCompleteBuilder { fn into(self) -> LeAdvFilterCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeAdvFilterSolicitationUuidData {apcf_action: ApcfAction, apcf_filter_index: u8, acpf_uuid_data: Vec::<u8>, }
#[derive(Debug, Clone)] pub struct LeAdvFilterSolicitationUuidPacket {command: Arc<CommandData>,le_scanning_command: Arc<LeScanningCommandData>,le_adv_filter: Arc<LeAdvFilterData>,le_adv_filter_solicitation_uuid: Arc<LeAdvFilterSolicitationUuidData>,}
#[derive(Debug)] pub struct LeAdvFilterSolicitationUuidBuilder {pub apcf_action: ApcfAction, pub apcf_filter_index: u8, pub acpf_uuid_data: Vec::<u8>, }
impl LeAdvFilterSolicitationUuidData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterSolicitationUuid".to_string(),    field: "apcf_action".to_string(),    wanted: 5,    got: bytes.len()});}let apcf_action = u8::from_le_bytes([bytes[4]]);let apcf_action = ApcfAction::from_u8(apcf_action).unwrap();if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterSolicitationUuid".to_string(),    field: "apcf_filter_index".to_string(),    wanted: 6,    got: bytes.len()});}let apcf_filter_index = u8::from_le_bytes([bytes[5]]);let rem_ = (bytes.len() - 6) % 1;if rem_ != 0 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterSolicitationUuid".to_string(),    field: "acpf_uuid_data".to_string(),    wanted: bytes.len() + rem_,    got: bytes.len()});}let acpf_uuid_data: Vec::<u8> = bytes[6..].to_vec().chunks_exact(1).into_iter().map(|i| u8::from_le_bytes([i[0]])).collect();Ok(Self {apcf_action, apcf_filter_index, acpf_uuid_data, })
}
fn write_to(&self, buffer: &mut BytesMut) {let apcf_action = self.apcf_action.to_u8().unwrap();buffer[4..5].copy_from_slice(&apcf_action.to_le_bytes()[0..1]);let apcf_filter_index = self.apcf_filter_index;buffer[5..6].copy_from_slice(&apcf_filter_index.to_le_bytes()[0..1]);for (i, e) in self.acpf_uuid_data.iter().enumerate() {buffer[6+i..6+i+1].copy_from_slice(&e.to_le_bytes())}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;let ret = ret + (self.acpf_uuid_data.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8));ret}
}
impl Packet for LeAdvFilterSolicitationUuidPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAdvFilterSolicitationUuidPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_scanning_command = match &command.child {CommandDataChild::LeScanningCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanningCommand"),};let le_adv_filter = match &le_scanning_command.child {LeScanningCommandDataChild::LeAdvFilter(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilter"),};let le_adv_filter_solicitation_uuid = match &le_adv_filter.child {LeAdvFilterDataChild::LeAdvFilterSolicitationUuid(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterSolicitationUuid"),};Self {command,le_scanning_command,le_adv_filter,le_adv_filter_solicitation_uuid,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_apcf_opcode(&self) -> ApcfOpcode{ self.le_adv_filter.as_ref().apcf_opcode}
pub fn get_apcf_action(&self) -> ApcfAction{ self.le_adv_filter_solicitation_uuid.as_ref().apcf_action}
pub fn get_apcf_filter_index(&self) -> u8{ self.le_adv_filter_solicitation_uuid.as_ref().apcf_filter_index}
pub fn get_acpf_uuid_data(&self) -> &Vec::<u8>{ &self.le_adv_filter_solicitation_uuid.as_ref().acpf_uuid_data}
}
impl Into<CommandPacket> for LeAdvFilterSolicitationUuidPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeScanningCommandPacket> for LeAdvFilterSolicitationUuidPacket { fn into(self) -> LeScanningCommandPacket {LeScanningCommandPacket::new(self.command) }}
impl Into<LeAdvFilterPacket> for LeAdvFilterSolicitationUuidPacket { fn into(self) -> LeAdvFilterPacket {LeAdvFilterPacket::new(self.command) }}
impl LeAdvFilterSolicitationUuidBuilder {pub fn build(self) -> LeAdvFilterSolicitationUuidPacket {let le_adv_filter_solicitation_uuid= Arc::new(LeAdvFilterSolicitationUuidData {apcf_action: self.apcf_action, apcf_filter_index: self.apcf_filter_index, acpf_uuid_data: self.acpf_uuid_data, });let le_adv_filter= Arc::new(LeAdvFilterData {apcf_opcode: ApcfOpcode::ServiceSolicitationUuid, child: LeAdvFilterDataChild::LeAdvFilterSolicitationUuid(le_adv_filter_solicitation_uuid),});let le_scanning_command= Arc::new(LeScanningCommandData {child: LeScanningCommandDataChild::LeAdvFilter(le_adv_filter),});let command= Arc::new(CommandData {op_code: OpCode::LeAdvFilter, child: CommandDataChild::LeScanningCommand(le_scanning_command),});LeAdvFilterSolicitationUuidPacket::new(command)}
}
impl Into<CommandPacket> for LeAdvFilterSolicitationUuidBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeScanningCommandPacket> for LeAdvFilterSolicitationUuidBuilder { fn into(self) -> LeScanningCommandPacket { self.build().into() }}
impl Into<LeAdvFilterPacket> for LeAdvFilterSolicitationUuidBuilder { fn into(self) -> LeAdvFilterPacket { self.build().into() }}


#[derive(Debug)] struct LeAdvFilterSolicitationUuidCompleteData {apcf_action: ApcfAction, apcf_available_spaces: u8, }
#[derive(Debug, Clone)] pub struct LeAdvFilterSolicitationUuidCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_adv_filter_complete: Arc<LeAdvFilterCompleteData>,le_adv_filter_solicitation_uuid_complete: Arc<LeAdvFilterSolicitationUuidCompleteData>,}
#[derive(Debug)] pub struct LeAdvFilterSolicitationUuidCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub apcf_action: ApcfAction, pub apcf_available_spaces: u8, }
impl LeAdvFilterSolicitationUuidCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterSolicitationUuidComplete".to_string(),    field: "apcf_action".to_string(),    wanted: 8,    got: bytes.len()});}let apcf_action = u8::from_le_bytes([bytes[7]]);let apcf_action = ApcfAction::from_u8(apcf_action).unwrap();if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterSolicitationUuidComplete".to_string(),    field: "apcf_available_spaces".to_string(),    wanted: 9,    got: bytes.len()});}let apcf_available_spaces = u8::from_le_bytes([bytes[8]]);Ok(Self {apcf_action, apcf_available_spaces, })
}
fn write_to(&self, buffer: &mut BytesMut) {let apcf_action = self.apcf_action.to_u8().unwrap();buffer[7..8].copy_from_slice(&apcf_action.to_le_bytes()[0..1]);let apcf_available_spaces = self.apcf_available_spaces;buffer[8..9].copy_from_slice(&apcf_available_spaces.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for LeAdvFilterSolicitationUuidCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAdvFilterSolicitationUuidCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_adv_filter_complete = match &command_complete.child {CommandCompleteDataChild::LeAdvFilterComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterComplete"),};let le_adv_filter_solicitation_uuid_complete = match &le_adv_filter_complete.child {LeAdvFilterCompleteDataChild::LeAdvFilterSolicitationUuidComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterSolicitationUuidComplete"),};Self {event,command_complete,le_adv_filter_complete,le_adv_filter_solicitation_uuid_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_adv_filter_complete.as_ref().status}
pub fn get_apcf_opcode(&self) -> ApcfOpcode{ self.le_adv_filter_complete.as_ref().apcf_opcode}
pub fn get_apcf_action(&self) -> ApcfAction{ self.le_adv_filter_solicitation_uuid_complete.as_ref().apcf_action}
pub fn get_apcf_available_spaces(&self) -> u8{ self.le_adv_filter_solicitation_uuid_complete.as_ref().apcf_available_spaces}
}
impl Into<EventPacket> for LeAdvFilterSolicitationUuidCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeAdvFilterSolicitationUuidCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl Into<LeAdvFilterCompletePacket> for LeAdvFilterSolicitationUuidCompletePacket { fn into(self) -> LeAdvFilterCompletePacket {LeAdvFilterCompletePacket::new(self.event) }}
impl LeAdvFilterSolicitationUuidCompleteBuilder {pub fn build(self) -> LeAdvFilterSolicitationUuidCompletePacket {let le_adv_filter_solicitation_uuid_complete= Arc::new(LeAdvFilterSolicitationUuidCompleteData {apcf_action: self.apcf_action, apcf_available_spaces: self.apcf_available_spaces, });let le_adv_filter_complete= Arc::new(LeAdvFilterCompleteData {status: self.status, apcf_opcode: ApcfOpcode::ServiceSolicitationUuid, child: LeAdvFilterCompleteDataChild::LeAdvFilterSolicitationUuidComplete(le_adv_filter_solicitation_uuid_complete),});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeAdvFilter, child: CommandCompleteDataChild::LeAdvFilterComplete(le_adv_filter_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeAdvFilterSolicitationUuidCompletePacket::new(event)}
}
impl Into<EventPacket> for LeAdvFilterSolicitationUuidCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeAdvFilterSolicitationUuidCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
impl Into<LeAdvFilterCompletePacket> for LeAdvFilterSolicitationUuidCompleteBuilder { fn into(self) -> LeAdvFilterCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeAdvFilterLocalNameData {apcf_action: ApcfAction, apcf_filter_index: u8, apcf_local_name: Vec::<u8>, }
#[derive(Debug, Clone)] pub struct LeAdvFilterLocalNamePacket {command: Arc<CommandData>,le_scanning_command: Arc<LeScanningCommandData>,le_adv_filter: Arc<LeAdvFilterData>,le_adv_filter_local_name: Arc<LeAdvFilterLocalNameData>,}
#[derive(Debug)] pub struct LeAdvFilterLocalNameBuilder {pub apcf_action: ApcfAction, pub apcf_filter_index: u8, pub apcf_local_name: Vec::<u8>, }
impl LeAdvFilterLocalNameData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterLocalName".to_string(),    field: "apcf_action".to_string(),    wanted: 5,    got: bytes.len()});}let apcf_action = u8::from_le_bytes([bytes[4]]);let apcf_action = ApcfAction::from_u8(apcf_action).unwrap();if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterLocalName".to_string(),    field: "apcf_filter_index".to_string(),    wanted: 6,    got: bytes.len()});}let apcf_filter_index = u8::from_le_bytes([bytes[5]]);let rem_ = (bytes.len() - 6) % 1;if rem_ != 0 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterLocalName".to_string(),    field: "apcf_local_name".to_string(),    wanted: bytes.len() + rem_,    got: bytes.len()});}let apcf_local_name: Vec::<u8> = bytes[6..].to_vec().chunks_exact(1).into_iter().map(|i| u8::from_le_bytes([i[0]])).collect();Ok(Self {apcf_action, apcf_filter_index, apcf_local_name, })
}
fn write_to(&self, buffer: &mut BytesMut) {let apcf_action = self.apcf_action.to_u8().unwrap();buffer[4..5].copy_from_slice(&apcf_action.to_le_bytes()[0..1]);let apcf_filter_index = self.apcf_filter_index;buffer[5..6].copy_from_slice(&apcf_filter_index.to_le_bytes()[0..1]);for (i, e) in self.apcf_local_name.iter().enumerate() {buffer[6+i..6+i+1].copy_from_slice(&e.to_le_bytes())}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;let ret = ret + (self.apcf_local_name.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8));ret}
}
impl Packet for LeAdvFilterLocalNamePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAdvFilterLocalNamePacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_scanning_command = match &command.child {CommandDataChild::LeScanningCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanningCommand"),};let le_adv_filter = match &le_scanning_command.child {LeScanningCommandDataChild::LeAdvFilter(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilter"),};let le_adv_filter_local_name = match &le_adv_filter.child {LeAdvFilterDataChild::LeAdvFilterLocalName(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterLocalName"),};Self {command,le_scanning_command,le_adv_filter,le_adv_filter_local_name,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_apcf_opcode(&self) -> ApcfOpcode{ self.le_adv_filter.as_ref().apcf_opcode}
pub fn get_apcf_action(&self) -> ApcfAction{ self.le_adv_filter_local_name.as_ref().apcf_action}
pub fn get_apcf_filter_index(&self) -> u8{ self.le_adv_filter_local_name.as_ref().apcf_filter_index}
pub fn get_apcf_local_name(&self) -> &Vec::<u8>{ &self.le_adv_filter_local_name.as_ref().apcf_local_name}
}
impl Into<CommandPacket> for LeAdvFilterLocalNamePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeScanningCommandPacket> for LeAdvFilterLocalNamePacket { fn into(self) -> LeScanningCommandPacket {LeScanningCommandPacket::new(self.command) }}
impl Into<LeAdvFilterPacket> for LeAdvFilterLocalNamePacket { fn into(self) -> LeAdvFilterPacket {LeAdvFilterPacket::new(self.command) }}
impl LeAdvFilterLocalNameBuilder {pub fn build(self) -> LeAdvFilterLocalNamePacket {let le_adv_filter_local_name= Arc::new(LeAdvFilterLocalNameData {apcf_action: self.apcf_action, apcf_filter_index: self.apcf_filter_index, apcf_local_name: self.apcf_local_name, });let le_adv_filter= Arc::new(LeAdvFilterData {apcf_opcode: ApcfOpcode::LocalName, child: LeAdvFilterDataChild::LeAdvFilterLocalName(le_adv_filter_local_name),});let le_scanning_command= Arc::new(LeScanningCommandData {child: LeScanningCommandDataChild::LeAdvFilter(le_adv_filter),});let command= Arc::new(CommandData {op_code: OpCode::LeAdvFilter, child: CommandDataChild::LeScanningCommand(le_scanning_command),});LeAdvFilterLocalNamePacket::new(command)}
}
impl Into<CommandPacket> for LeAdvFilterLocalNameBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeScanningCommandPacket> for LeAdvFilterLocalNameBuilder { fn into(self) -> LeScanningCommandPacket { self.build().into() }}
impl Into<LeAdvFilterPacket> for LeAdvFilterLocalNameBuilder { fn into(self) -> LeAdvFilterPacket { self.build().into() }}


#[derive(Debug)] struct LeAdvFilterLocalNameCompleteData {apcf_action: ApcfAction, apcf_available_spaces: u8, }
#[derive(Debug, Clone)] pub struct LeAdvFilterLocalNameCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_adv_filter_complete: Arc<LeAdvFilterCompleteData>,le_adv_filter_local_name_complete: Arc<LeAdvFilterLocalNameCompleteData>,}
#[derive(Debug)] pub struct LeAdvFilterLocalNameCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub apcf_action: ApcfAction, pub apcf_available_spaces: u8, }
impl LeAdvFilterLocalNameCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterLocalNameComplete".to_string(),    field: "apcf_action".to_string(),    wanted: 8,    got: bytes.len()});}let apcf_action = u8::from_le_bytes([bytes[7]]);let apcf_action = ApcfAction::from_u8(apcf_action).unwrap();if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterLocalNameComplete".to_string(),    field: "apcf_available_spaces".to_string(),    wanted: 9,    got: bytes.len()});}let apcf_available_spaces = u8::from_le_bytes([bytes[8]]);Ok(Self {apcf_action, apcf_available_spaces, })
}
fn write_to(&self, buffer: &mut BytesMut) {let apcf_action = self.apcf_action.to_u8().unwrap();buffer[7..8].copy_from_slice(&apcf_action.to_le_bytes()[0..1]);let apcf_available_spaces = self.apcf_available_spaces;buffer[8..9].copy_from_slice(&apcf_available_spaces.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for LeAdvFilterLocalNameCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAdvFilterLocalNameCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_adv_filter_complete = match &command_complete.child {CommandCompleteDataChild::LeAdvFilterComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterComplete"),};let le_adv_filter_local_name_complete = match &le_adv_filter_complete.child {LeAdvFilterCompleteDataChild::LeAdvFilterLocalNameComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterLocalNameComplete"),};Self {event,command_complete,le_adv_filter_complete,le_adv_filter_local_name_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_adv_filter_complete.as_ref().status}
pub fn get_apcf_opcode(&self) -> ApcfOpcode{ self.le_adv_filter_complete.as_ref().apcf_opcode}
pub fn get_apcf_action(&self) -> ApcfAction{ self.le_adv_filter_local_name_complete.as_ref().apcf_action}
pub fn get_apcf_available_spaces(&self) -> u8{ self.le_adv_filter_local_name_complete.as_ref().apcf_available_spaces}
}
impl Into<EventPacket> for LeAdvFilterLocalNameCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeAdvFilterLocalNameCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl Into<LeAdvFilterCompletePacket> for LeAdvFilterLocalNameCompletePacket { fn into(self) -> LeAdvFilterCompletePacket {LeAdvFilterCompletePacket::new(self.event) }}
impl LeAdvFilterLocalNameCompleteBuilder {pub fn build(self) -> LeAdvFilterLocalNameCompletePacket {let le_adv_filter_local_name_complete= Arc::new(LeAdvFilterLocalNameCompleteData {apcf_action: self.apcf_action, apcf_available_spaces: self.apcf_available_spaces, });let le_adv_filter_complete= Arc::new(LeAdvFilterCompleteData {status: self.status, apcf_opcode: ApcfOpcode::LocalName, child: LeAdvFilterCompleteDataChild::LeAdvFilterLocalNameComplete(le_adv_filter_local_name_complete),});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeAdvFilter, child: CommandCompleteDataChild::LeAdvFilterComplete(le_adv_filter_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeAdvFilterLocalNameCompletePacket::new(event)}
}
impl Into<EventPacket> for LeAdvFilterLocalNameCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeAdvFilterLocalNameCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
impl Into<LeAdvFilterCompletePacket> for LeAdvFilterLocalNameCompleteBuilder { fn into(self) -> LeAdvFilterCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeAdvFilterManufacturerDataData {apcf_action: ApcfAction, apcf_filter_index: u8, apcf_manufacturer_data: Vec::<u8>, }
#[derive(Debug, Clone)] pub struct LeAdvFilterManufacturerDataPacket {command: Arc<CommandData>,le_scanning_command: Arc<LeScanningCommandData>,le_adv_filter: Arc<LeAdvFilterData>,le_adv_filter_manufacturer_data: Arc<LeAdvFilterManufacturerDataData>,}
#[derive(Debug)] pub struct LeAdvFilterManufacturerDataBuilder {pub apcf_action: ApcfAction, pub apcf_filter_index: u8, pub apcf_manufacturer_data: Vec::<u8>, }
impl LeAdvFilterManufacturerDataData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterManufacturerData".to_string(),    field: "apcf_action".to_string(),    wanted: 5,    got: bytes.len()});}let apcf_action = u8::from_le_bytes([bytes[4]]);let apcf_action = ApcfAction::from_u8(apcf_action).unwrap();if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterManufacturerData".to_string(),    field: "apcf_filter_index".to_string(),    wanted: 6,    got: bytes.len()});}let apcf_filter_index = u8::from_le_bytes([bytes[5]]);let rem_ = (bytes.len() - 6) % 1;if rem_ != 0 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterManufacturerData".to_string(),    field: "apcf_manufacturer_data".to_string(),    wanted: bytes.len() + rem_,    got: bytes.len()});}let apcf_manufacturer_data: Vec::<u8> = bytes[6..].to_vec().chunks_exact(1).into_iter().map(|i| u8::from_le_bytes([i[0]])).collect();Ok(Self {apcf_action, apcf_filter_index, apcf_manufacturer_data, })
}
fn write_to(&self, buffer: &mut BytesMut) {let apcf_action = self.apcf_action.to_u8().unwrap();buffer[4..5].copy_from_slice(&apcf_action.to_le_bytes()[0..1]);let apcf_filter_index = self.apcf_filter_index;buffer[5..6].copy_from_slice(&apcf_filter_index.to_le_bytes()[0..1]);for (i, e) in self.apcf_manufacturer_data.iter().enumerate() {buffer[6+i..6+i+1].copy_from_slice(&e.to_le_bytes())}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;let ret = ret + (self.apcf_manufacturer_data.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8));ret}
}
impl Packet for LeAdvFilterManufacturerDataPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAdvFilterManufacturerDataPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_scanning_command = match &command.child {CommandDataChild::LeScanningCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanningCommand"),};let le_adv_filter = match &le_scanning_command.child {LeScanningCommandDataChild::LeAdvFilter(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilter"),};let le_adv_filter_manufacturer_data = match &le_adv_filter.child {LeAdvFilterDataChild::LeAdvFilterManufacturerData(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterManufacturerData"),};Self {command,le_scanning_command,le_adv_filter,le_adv_filter_manufacturer_data,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_apcf_opcode(&self) -> ApcfOpcode{ self.le_adv_filter.as_ref().apcf_opcode}
pub fn get_apcf_action(&self) -> ApcfAction{ self.le_adv_filter_manufacturer_data.as_ref().apcf_action}
pub fn get_apcf_filter_index(&self) -> u8{ self.le_adv_filter_manufacturer_data.as_ref().apcf_filter_index}
pub fn get_apcf_manufacturer_data(&self) -> &Vec::<u8>{ &self.le_adv_filter_manufacturer_data.as_ref().apcf_manufacturer_data}
}
impl Into<CommandPacket> for LeAdvFilterManufacturerDataPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeScanningCommandPacket> for LeAdvFilterManufacturerDataPacket { fn into(self) -> LeScanningCommandPacket {LeScanningCommandPacket::new(self.command) }}
impl Into<LeAdvFilterPacket> for LeAdvFilterManufacturerDataPacket { fn into(self) -> LeAdvFilterPacket {LeAdvFilterPacket::new(self.command) }}
impl LeAdvFilterManufacturerDataBuilder {pub fn build(self) -> LeAdvFilterManufacturerDataPacket {let le_adv_filter_manufacturer_data= Arc::new(LeAdvFilterManufacturerDataData {apcf_action: self.apcf_action, apcf_filter_index: self.apcf_filter_index, apcf_manufacturer_data: self.apcf_manufacturer_data, });let le_adv_filter= Arc::new(LeAdvFilterData {apcf_opcode: ApcfOpcode::ManufacturerData, child: LeAdvFilterDataChild::LeAdvFilterManufacturerData(le_adv_filter_manufacturer_data),});let le_scanning_command= Arc::new(LeScanningCommandData {child: LeScanningCommandDataChild::LeAdvFilter(le_adv_filter),});let command= Arc::new(CommandData {op_code: OpCode::LeAdvFilter, child: CommandDataChild::LeScanningCommand(le_scanning_command),});LeAdvFilterManufacturerDataPacket::new(command)}
}
impl Into<CommandPacket> for LeAdvFilterManufacturerDataBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeScanningCommandPacket> for LeAdvFilterManufacturerDataBuilder { fn into(self) -> LeScanningCommandPacket { self.build().into() }}
impl Into<LeAdvFilterPacket> for LeAdvFilterManufacturerDataBuilder { fn into(self) -> LeAdvFilterPacket { self.build().into() }}


#[derive(Debug)] struct LeAdvFilterManufacturerDataCompleteData {apcf_action: ApcfAction, apcf_available_spaces: u8, }
#[derive(Debug, Clone)] pub struct LeAdvFilterManufacturerDataCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_adv_filter_complete: Arc<LeAdvFilterCompleteData>,le_adv_filter_manufacturer_data_complete: Arc<LeAdvFilterManufacturerDataCompleteData>,}
#[derive(Debug)] pub struct LeAdvFilterManufacturerDataCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub apcf_action: ApcfAction, pub apcf_available_spaces: u8, }
impl LeAdvFilterManufacturerDataCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterManufacturerDataComplete".to_string(),    field: "apcf_action".to_string(),    wanted: 8,    got: bytes.len()});}let apcf_action = u8::from_le_bytes([bytes[7]]);let apcf_action = ApcfAction::from_u8(apcf_action).unwrap();if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterManufacturerDataComplete".to_string(),    field: "apcf_available_spaces".to_string(),    wanted: 9,    got: bytes.len()});}let apcf_available_spaces = u8::from_le_bytes([bytes[8]]);Ok(Self {apcf_action, apcf_available_spaces, })
}
fn write_to(&self, buffer: &mut BytesMut) {let apcf_action = self.apcf_action.to_u8().unwrap();buffer[7..8].copy_from_slice(&apcf_action.to_le_bytes()[0..1]);let apcf_available_spaces = self.apcf_available_spaces;buffer[8..9].copy_from_slice(&apcf_available_spaces.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for LeAdvFilterManufacturerDataCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAdvFilterManufacturerDataCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_adv_filter_complete = match &command_complete.child {CommandCompleteDataChild::LeAdvFilterComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterComplete"),};let le_adv_filter_manufacturer_data_complete = match &le_adv_filter_complete.child {LeAdvFilterCompleteDataChild::LeAdvFilterManufacturerDataComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterManufacturerDataComplete"),};Self {event,command_complete,le_adv_filter_complete,le_adv_filter_manufacturer_data_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_adv_filter_complete.as_ref().status}
pub fn get_apcf_opcode(&self) -> ApcfOpcode{ self.le_adv_filter_complete.as_ref().apcf_opcode}
pub fn get_apcf_action(&self) -> ApcfAction{ self.le_adv_filter_manufacturer_data_complete.as_ref().apcf_action}
pub fn get_apcf_available_spaces(&self) -> u8{ self.le_adv_filter_manufacturer_data_complete.as_ref().apcf_available_spaces}
}
impl Into<EventPacket> for LeAdvFilterManufacturerDataCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeAdvFilterManufacturerDataCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl Into<LeAdvFilterCompletePacket> for LeAdvFilterManufacturerDataCompletePacket { fn into(self) -> LeAdvFilterCompletePacket {LeAdvFilterCompletePacket::new(self.event) }}
impl LeAdvFilterManufacturerDataCompleteBuilder {pub fn build(self) -> LeAdvFilterManufacturerDataCompletePacket {let le_adv_filter_manufacturer_data_complete= Arc::new(LeAdvFilterManufacturerDataCompleteData {apcf_action: self.apcf_action, apcf_available_spaces: self.apcf_available_spaces, });let le_adv_filter_complete= Arc::new(LeAdvFilterCompleteData {status: self.status, apcf_opcode: ApcfOpcode::ManufacturerData, child: LeAdvFilterCompleteDataChild::LeAdvFilterManufacturerDataComplete(le_adv_filter_manufacturer_data_complete),});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeAdvFilter, child: CommandCompleteDataChild::LeAdvFilterComplete(le_adv_filter_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeAdvFilterManufacturerDataCompletePacket::new(event)}
}
impl Into<EventPacket> for LeAdvFilterManufacturerDataCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeAdvFilterManufacturerDataCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
impl Into<LeAdvFilterCompletePacket> for LeAdvFilterManufacturerDataCompleteBuilder { fn into(self) -> LeAdvFilterCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeAdvFilterServiceDataData {apcf_action: ApcfAction, apcf_filter_index: u8, apcf_service_data: Vec::<u8>, }
#[derive(Debug, Clone)] pub struct LeAdvFilterServiceDataPacket {command: Arc<CommandData>,le_scanning_command: Arc<LeScanningCommandData>,le_adv_filter: Arc<LeAdvFilterData>,le_adv_filter_service_data: Arc<LeAdvFilterServiceDataData>,}
#[derive(Debug)] pub struct LeAdvFilterServiceDataBuilder {pub apcf_action: ApcfAction, pub apcf_filter_index: u8, pub apcf_service_data: Vec::<u8>, }
impl LeAdvFilterServiceDataData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterServiceData".to_string(),    field: "apcf_action".to_string(),    wanted: 5,    got: bytes.len()});}let apcf_action = u8::from_le_bytes([bytes[4]]);let apcf_action = ApcfAction::from_u8(apcf_action).unwrap();if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterServiceData".to_string(),    field: "apcf_filter_index".to_string(),    wanted: 6,    got: bytes.len()});}let apcf_filter_index = u8::from_le_bytes([bytes[5]]);let rem_ = (bytes.len() - 6) % 1;if rem_ != 0 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterServiceData".to_string(),    field: "apcf_service_data".to_string(),    wanted: bytes.len() + rem_,    got: bytes.len()});}let apcf_service_data: Vec::<u8> = bytes[6..].to_vec().chunks_exact(1).into_iter().map(|i| u8::from_le_bytes([i[0]])).collect();Ok(Self {apcf_action, apcf_filter_index, apcf_service_data, })
}
fn write_to(&self, buffer: &mut BytesMut) {let apcf_action = self.apcf_action.to_u8().unwrap();buffer[4..5].copy_from_slice(&apcf_action.to_le_bytes()[0..1]);let apcf_filter_index = self.apcf_filter_index;buffer[5..6].copy_from_slice(&apcf_filter_index.to_le_bytes()[0..1]);for (i, e) in self.apcf_service_data.iter().enumerate() {buffer[6+i..6+i+1].copy_from_slice(&e.to_le_bytes())}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;let ret = ret + (self.apcf_service_data.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8));ret}
}
impl Packet for LeAdvFilterServiceDataPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAdvFilterServiceDataPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_scanning_command = match &command.child {CommandDataChild::LeScanningCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanningCommand"),};let le_adv_filter = match &le_scanning_command.child {LeScanningCommandDataChild::LeAdvFilter(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilter"),};let le_adv_filter_service_data = match &le_adv_filter.child {LeAdvFilterDataChild::LeAdvFilterServiceData(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterServiceData"),};Self {command,le_scanning_command,le_adv_filter,le_adv_filter_service_data,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_apcf_opcode(&self) -> ApcfOpcode{ self.le_adv_filter.as_ref().apcf_opcode}
pub fn get_apcf_action(&self) -> ApcfAction{ self.le_adv_filter_service_data.as_ref().apcf_action}
pub fn get_apcf_filter_index(&self) -> u8{ self.le_adv_filter_service_data.as_ref().apcf_filter_index}
pub fn get_apcf_service_data(&self) -> &Vec::<u8>{ &self.le_adv_filter_service_data.as_ref().apcf_service_data}
}
impl Into<CommandPacket> for LeAdvFilterServiceDataPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeScanningCommandPacket> for LeAdvFilterServiceDataPacket { fn into(self) -> LeScanningCommandPacket {LeScanningCommandPacket::new(self.command) }}
impl Into<LeAdvFilterPacket> for LeAdvFilterServiceDataPacket { fn into(self) -> LeAdvFilterPacket {LeAdvFilterPacket::new(self.command) }}
impl LeAdvFilterServiceDataBuilder {pub fn build(self) -> LeAdvFilterServiceDataPacket {let le_adv_filter_service_data= Arc::new(LeAdvFilterServiceDataData {apcf_action: self.apcf_action, apcf_filter_index: self.apcf_filter_index, apcf_service_data: self.apcf_service_data, });let le_adv_filter= Arc::new(LeAdvFilterData {apcf_opcode: ApcfOpcode::ServiceData, child: LeAdvFilterDataChild::LeAdvFilterServiceData(le_adv_filter_service_data),});let le_scanning_command= Arc::new(LeScanningCommandData {child: LeScanningCommandDataChild::LeAdvFilter(le_adv_filter),});let command= Arc::new(CommandData {op_code: OpCode::LeAdvFilter, child: CommandDataChild::LeScanningCommand(le_scanning_command),});LeAdvFilterServiceDataPacket::new(command)}
}
impl Into<CommandPacket> for LeAdvFilterServiceDataBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeScanningCommandPacket> for LeAdvFilterServiceDataBuilder { fn into(self) -> LeScanningCommandPacket { self.build().into() }}
impl Into<LeAdvFilterPacket> for LeAdvFilterServiceDataBuilder { fn into(self) -> LeAdvFilterPacket { self.build().into() }}


#[derive(Debug)] struct LeAdvFilterServiceDataCompleteData {apcf_action: ApcfAction, apcf_available_spaces: u8, }
#[derive(Debug, Clone)] pub struct LeAdvFilterServiceDataCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_adv_filter_complete: Arc<LeAdvFilterCompleteData>,le_adv_filter_service_data_complete: Arc<LeAdvFilterServiceDataCompleteData>,}
#[derive(Debug)] pub struct LeAdvFilterServiceDataCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub apcf_action: ApcfAction, pub apcf_available_spaces: u8, }
impl LeAdvFilterServiceDataCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterServiceDataComplete".to_string(),    field: "apcf_action".to_string(),    wanted: 8,    got: bytes.len()});}let apcf_action = u8::from_le_bytes([bytes[7]]);let apcf_action = ApcfAction::from_u8(apcf_action).unwrap();if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeAdvFilterServiceDataComplete".to_string(),    field: "apcf_available_spaces".to_string(),    wanted: 9,    got: bytes.len()});}let apcf_available_spaces = u8::from_le_bytes([bytes[8]]);Ok(Self {apcf_action, apcf_available_spaces, })
}
fn write_to(&self, buffer: &mut BytesMut) {let apcf_action = self.apcf_action.to_u8().unwrap();buffer[7..8].copy_from_slice(&apcf_action.to_le_bytes()[0..1]);let apcf_available_spaces = self.apcf_available_spaces;buffer[8..9].copy_from_slice(&apcf_available_spaces.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for LeAdvFilterServiceDataCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAdvFilterServiceDataCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_adv_filter_complete = match &command_complete.child {CommandCompleteDataChild::LeAdvFilterComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterComplete"),};let le_adv_filter_service_data_complete = match &le_adv_filter_complete.child {LeAdvFilterCompleteDataChild::LeAdvFilterServiceDataComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvFilterServiceDataComplete"),};Self {event,command_complete,le_adv_filter_complete,le_adv_filter_service_data_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_adv_filter_complete.as_ref().status}
pub fn get_apcf_opcode(&self) -> ApcfOpcode{ self.le_adv_filter_complete.as_ref().apcf_opcode}
pub fn get_apcf_action(&self) -> ApcfAction{ self.le_adv_filter_service_data_complete.as_ref().apcf_action}
pub fn get_apcf_available_spaces(&self) -> u8{ self.le_adv_filter_service_data_complete.as_ref().apcf_available_spaces}
}
impl Into<EventPacket> for LeAdvFilterServiceDataCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeAdvFilterServiceDataCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl Into<LeAdvFilterCompletePacket> for LeAdvFilterServiceDataCompletePacket { fn into(self) -> LeAdvFilterCompletePacket {LeAdvFilterCompletePacket::new(self.event) }}
impl LeAdvFilterServiceDataCompleteBuilder {pub fn build(self) -> LeAdvFilterServiceDataCompletePacket {let le_adv_filter_service_data_complete= Arc::new(LeAdvFilterServiceDataCompleteData {apcf_action: self.apcf_action, apcf_available_spaces: self.apcf_available_spaces, });let le_adv_filter_complete= Arc::new(LeAdvFilterCompleteData {status: self.status, apcf_opcode: ApcfOpcode::ServiceData, child: LeAdvFilterCompleteDataChild::LeAdvFilterServiceDataComplete(le_adv_filter_service_data_complete),});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeAdvFilter, child: CommandCompleteDataChild::LeAdvFilterComplete(le_adv_filter_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeAdvFilterServiceDataCompletePacket::new(event)}
}
impl Into<EventPacket> for LeAdvFilterServiceDataCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeAdvFilterServiceDataCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
impl Into<LeAdvFilterCompletePacket> for LeAdvFilterServiceDataCompleteBuilder { fn into(self) -> LeAdvFilterCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeEnergyInfoData {}
#[derive(Debug, Clone)] pub struct LeEnergyInfoPacket {command: Arc<CommandData>,vendor_command: Arc<VendorCommandData>,le_energy_info: Arc<LeEnergyInfoData>,}
#[derive(Debug)] pub struct LeEnergyInfoBuilder {}
impl LeEnergyInfoData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for LeEnergyInfoPacket { type ResponseType = LeEnergyInfoCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeEnergyInfoCompletePacket::new(pkt.event.clone()) }}impl Packet for LeEnergyInfoPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeEnergyInfoPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let vendor_command = match &command.child {CommandDataChild::VendorCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not VendorCommand"),};let le_energy_info = match &vendor_command.child {VendorCommandDataChild::LeEnergyInfo(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeEnergyInfo"),};Self {command,vendor_command,le_energy_info,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for LeEnergyInfoPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<VendorCommandPacket> for LeEnergyInfoPacket { fn into(self) -> VendorCommandPacket {VendorCommandPacket::new(self.command) }}
impl CommandExpectations for LeEnergyInfoBuilder { type ResponseType = LeEnergyInfoCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeEnergyInfoCompletePacket::new(pkt.event.clone()) }}impl LeEnergyInfoBuilder {pub fn build(self) -> LeEnergyInfoPacket {let le_energy_info= Arc::new(LeEnergyInfoData {});let vendor_command= Arc::new(VendorCommandData {child: VendorCommandDataChild::LeEnergyInfo(le_energy_info),});let command= Arc::new(CommandData {op_code: OpCode::LeEnergyInfo, child: CommandDataChild::VendorCommand(vendor_command),});LeEnergyInfoPacket::new(command)}
}
impl Into<CommandPacket> for LeEnergyInfoBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<VendorCommandPacket> for LeEnergyInfoBuilder { fn into(self) -> VendorCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeEnergyInfoCompleteData {status: ErrorCode, total_tx_time_ms: u32, total_rx_time_ms: u32, total_idle_time_ms: u32, total_energy_used_ma_v_ms: u32, }
#[derive(Debug, Clone)] pub struct LeEnergyInfoCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_energy_info_complete: Arc<LeEnergyInfoCompleteData>,}
#[derive(Debug)] pub struct LeEnergyInfoCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub total_tx_time_ms: u32, pub total_rx_time_ms: u32, pub total_idle_time_ms: u32, pub total_energy_used_ma_v_ms: u32, }
impl LeEnergyInfoCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeEnergyInfoComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeEnergyInfoComplete".to_string(),    field: "total_tx_time_ms".to_string(),    wanted: 10,    got: bytes.len()});}let total_tx_time_ms = u32::from_le_bytes([bytes[6],bytes[7],bytes[8],bytes[9]]);if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "LeEnergyInfoComplete".to_string(),    field: "total_rx_time_ms".to_string(),    wanted: 14,    got: bytes.len()});}let total_rx_time_ms = u32::from_le_bytes([bytes[10],bytes[11],bytes[12],bytes[13]]);if bytes.len() < 18 { return Err(Error::InvalidLengthError{    obj: "LeEnergyInfoComplete".to_string(),    field: "total_idle_time_ms".to_string(),    wanted: 18,    got: bytes.len()});}let total_idle_time_ms = u32::from_le_bytes([bytes[14],bytes[15],bytes[16],bytes[17]]);if bytes.len() < 22 { return Err(Error::InvalidLengthError{    obj: "LeEnergyInfoComplete".to_string(),    field: "total_energy_used_ma_v_ms".to_string(),    wanted: 22,    got: bytes.len()});}let total_energy_used_ma_v_ms = u32::from_le_bytes([bytes[18],bytes[19],bytes[20],bytes[21]]);Ok(Self {status, total_tx_time_ms, total_rx_time_ms, total_idle_time_ms, total_energy_used_ma_v_ms, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let total_tx_time_ms = self.total_tx_time_ms;buffer[6..10].copy_from_slice(&total_tx_time_ms.to_le_bytes()[0..4]);let total_rx_time_ms = self.total_rx_time_ms;buffer[10..14].copy_from_slice(&total_rx_time_ms.to_le_bytes()[0..4]);let total_idle_time_ms = self.total_idle_time_ms;buffer[14..18].copy_from_slice(&total_idle_time_ms.to_le_bytes()[0..4]);let total_energy_used_ma_v_ms = self.total_energy_used_ma_v_ms;buffer[18..22].copy_from_slice(&total_energy_used_ma_v_ms.to_le_bytes()[0..4]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 17;ret}
}
impl Packet for LeEnergyInfoCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeEnergyInfoCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_energy_info_complete = match &command_complete.child {CommandCompleteDataChild::LeEnergyInfoComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeEnergyInfoComplete"),};Self {event,command_complete,le_energy_info_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_energy_info_complete.as_ref().status}
pub fn get_total_tx_time_ms(&self) -> u32{ self.le_energy_info_complete.as_ref().total_tx_time_ms}
pub fn get_total_rx_time_ms(&self) -> u32{ self.le_energy_info_complete.as_ref().total_rx_time_ms}
pub fn get_total_idle_time_ms(&self) -> u32{ self.le_energy_info_complete.as_ref().total_idle_time_ms}
pub fn get_total_energy_used_ma_v_ms(&self) -> u32{ self.le_energy_info_complete.as_ref().total_energy_used_ma_v_ms}
}
impl Into<EventPacket> for LeEnergyInfoCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeEnergyInfoCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeEnergyInfoCompleteBuilder {pub fn build(self) -> LeEnergyInfoCompletePacket {let le_energy_info_complete= Arc::new(LeEnergyInfoCompleteData {status: self.status, total_tx_time_ms: self.total_tx_time_ms, total_rx_time_ms: self.total_rx_time_ms, total_idle_time_ms: self.total_idle_time_ms, total_energy_used_ma_v_ms: self.total_energy_used_ma_v_ms, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeEnergyInfo, child: CommandCompleteDataChild::LeEnergyInfoComplete(le_energy_info_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeEnergyInfoCompletePacket::new(event)}
}
impl Into<EventPacket> for LeEnergyInfoCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeEnergyInfoCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct LeExtendedScanParamsData {le_scan_type: LeScanType, le_scan_interval: u32, le_scan_window: u32, own_address_type: OwnAddressType, scanning_filter_policy: LeScanningFilterPolicy, }
#[derive(Debug, Clone)] pub struct LeExtendedScanParamsPacket {command: Arc<CommandData>,le_scanning_command: Arc<LeScanningCommandData>,le_extended_scan_params: Arc<LeExtendedScanParamsData>,}
#[derive(Debug)] pub struct LeExtendedScanParamsBuilder {pub le_scan_type: LeScanType, pub le_scan_interval: u32, pub le_scan_window: u32, pub own_address_type: OwnAddressType, pub scanning_filter_policy: LeScanningFilterPolicy, }
impl LeExtendedScanParamsData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeExtendedScanParams".to_string(),    field: "le_scan_type".to_string(),    wanted: 4,    got: bytes.len()});}let le_scan_type = u8::from_le_bytes([bytes[3]]);let le_scan_type = LeScanType::from_u8(le_scan_type).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeExtendedScanParams".to_string(),    field: "le_scan_interval".to_string(),    wanted: 8,    got: bytes.len()});}let le_scan_interval = u32::from_le_bytes([bytes[4],bytes[5],bytes[6],bytes[7]]);if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "LeExtendedScanParams".to_string(),    field: "le_scan_window".to_string(),    wanted: 12,    got: bytes.len()});}let le_scan_window = u32::from_le_bytes([bytes[8],bytes[9],bytes[10],bytes[11]]);if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "LeExtendedScanParams".to_string(),    field: "own_address_type".to_string(),    wanted: 13,    got: bytes.len()});}let own_address_type = u8::from_le_bytes([bytes[12]]);let own_address_type = OwnAddressType::from_u8(own_address_type).unwrap();if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "LeExtendedScanParams".to_string(),    field: "scanning_filter_policy".to_string(),    wanted: 14,    got: bytes.len()});}let scanning_filter_policy = u8::from_le_bytes([bytes[13]]);let scanning_filter_policy = LeScanningFilterPolicy::from_u8(scanning_filter_policy).unwrap();Ok(Self {le_scan_type, le_scan_interval, le_scan_window, own_address_type, scanning_filter_policy, })
}
fn write_to(&self, buffer: &mut BytesMut) {let le_scan_type = self.le_scan_type.to_u8().unwrap();buffer[3..4].copy_from_slice(&le_scan_type.to_le_bytes()[0..1]);let le_scan_interval = self.le_scan_interval;buffer[4..8].copy_from_slice(&le_scan_interval.to_le_bytes()[0..4]);let le_scan_window = self.le_scan_window;buffer[8..12].copy_from_slice(&le_scan_window.to_le_bytes()[0..4]);let own_address_type = self.own_address_type.to_u8().unwrap();buffer[12..13].copy_from_slice(&own_address_type.to_le_bytes()[0..1]);let scanning_filter_policy = self.scanning_filter_policy.to_u8().unwrap();buffer[13..14].copy_from_slice(&scanning_filter_policy.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 11;ret}
}
impl CommandExpectations for LeExtendedScanParamsPacket { type ResponseType = LeExtendedScanParamsCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeExtendedScanParamsCompletePacket::new(pkt.event.clone()) }}impl Packet for LeExtendedScanParamsPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeExtendedScanParamsPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let le_scanning_command = match &command.child {CommandDataChild::LeScanningCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanningCommand"),};let le_extended_scan_params = match &le_scanning_command.child {LeScanningCommandDataChild::LeExtendedScanParams(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeExtendedScanParams"),};Self {command,le_scanning_command,le_extended_scan_params,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_le_scan_type(&self) -> LeScanType{ self.le_extended_scan_params.as_ref().le_scan_type}
pub fn get_le_scan_interval(&self) -> u32{ self.le_extended_scan_params.as_ref().le_scan_interval}
pub fn get_le_scan_window(&self) -> u32{ self.le_extended_scan_params.as_ref().le_scan_window}
pub fn get_own_address_type(&self) -> OwnAddressType{ self.le_extended_scan_params.as_ref().own_address_type}
pub fn get_scanning_filter_policy(&self) -> LeScanningFilterPolicy{ self.le_extended_scan_params.as_ref().scanning_filter_policy}
}
impl Into<CommandPacket> for LeExtendedScanParamsPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<LeScanningCommandPacket> for LeExtendedScanParamsPacket { fn into(self) -> LeScanningCommandPacket {LeScanningCommandPacket::new(self.command) }}
impl CommandExpectations for LeExtendedScanParamsBuilder { type ResponseType = LeExtendedScanParamsCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { LeExtendedScanParamsCompletePacket::new(pkt.event.clone()) }}impl LeExtendedScanParamsBuilder {pub fn build(self) -> LeExtendedScanParamsPacket {let le_extended_scan_params= Arc::new(LeExtendedScanParamsData {le_scan_type: self.le_scan_type, le_scan_interval: self.le_scan_interval, le_scan_window: self.le_scan_window, own_address_type: self.own_address_type, scanning_filter_policy: self.scanning_filter_policy, });let le_scanning_command= Arc::new(LeScanningCommandData {child: LeScanningCommandDataChild::LeExtendedScanParams(le_extended_scan_params),});let command= Arc::new(CommandData {op_code: OpCode::LeExtendedScanParams, child: CommandDataChild::LeScanningCommand(le_scanning_command),});LeExtendedScanParamsPacket::new(command)}
}
impl Into<CommandPacket> for LeExtendedScanParamsBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<LeScanningCommandPacket> for LeExtendedScanParamsBuilder { fn into(self) -> LeScanningCommandPacket { self.build().into() }}


#[derive(Debug)] struct LeExtendedScanParamsCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeExtendedScanParamsCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,le_extended_scan_params_complete: Arc<LeExtendedScanParamsCompleteData>,}
#[derive(Debug)] pub struct LeExtendedScanParamsCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl LeExtendedScanParamsCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeExtendedScanParamsComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeExtendedScanParamsCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeExtendedScanParamsCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let le_extended_scan_params_complete = match &command_complete.child {CommandCompleteDataChild::LeExtendedScanParamsComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeExtendedScanParamsComplete"),};Self {event,command_complete,le_extended_scan_params_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.le_extended_scan_params_complete.as_ref().status}
}
impl Into<EventPacket> for LeExtendedScanParamsCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for LeExtendedScanParamsCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl LeExtendedScanParamsCompleteBuilder {pub fn build(self) -> LeExtendedScanParamsCompletePacket {let le_extended_scan_params_complete= Arc::new(LeExtendedScanParamsCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::LeExtendedScanParams, child: CommandCompleteDataChild::LeExtendedScanParamsComplete(le_extended_scan_params_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});LeExtendedScanParamsCompletePacket::new(event)}
}
impl Into<EventPacket> for LeExtendedScanParamsCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for LeExtendedScanParamsCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ControllerDebugInfoData {}
#[derive(Debug, Clone)] pub struct ControllerDebugInfoPacket {command: Arc<CommandData>,vendor_command: Arc<VendorCommandData>,controller_debug_info: Arc<ControllerDebugInfoData>,}
#[derive(Debug)] pub struct ControllerDebugInfoBuilder {}
impl ControllerDebugInfoData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ControllerDebugInfoPacket { type ResponseType = ControllerDebugInfoCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ControllerDebugInfoCompletePacket::new(pkt.event.clone()) }}impl Packet for ControllerDebugInfoPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ControllerDebugInfoPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let vendor_command = match &command.child {CommandDataChild::VendorCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not VendorCommand"),};let controller_debug_info = match &vendor_command.child {VendorCommandDataChild::ControllerDebugInfo(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ControllerDebugInfo"),};Self {command,vendor_command,controller_debug_info,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ControllerDebugInfoPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<VendorCommandPacket> for ControllerDebugInfoPacket { fn into(self) -> VendorCommandPacket {VendorCommandPacket::new(self.command) }}
impl CommandExpectations for ControllerDebugInfoBuilder { type ResponseType = ControllerDebugInfoCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ControllerDebugInfoCompletePacket::new(pkt.event.clone()) }}impl ControllerDebugInfoBuilder {pub fn build(self) -> ControllerDebugInfoPacket {let controller_debug_info= Arc::new(ControllerDebugInfoData {});let vendor_command= Arc::new(VendorCommandData {child: VendorCommandDataChild::ControllerDebugInfo(controller_debug_info),});let command= Arc::new(CommandData {op_code: OpCode::ControllerDebugInfo, child: CommandDataChild::VendorCommand(vendor_command),});ControllerDebugInfoPacket::new(command)}
}
impl Into<CommandPacket> for ControllerDebugInfoBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<VendorCommandPacket> for ControllerDebugInfoBuilder { fn into(self) -> VendorCommandPacket { self.build().into() }}


#[derive(Debug)] struct ControllerDebugInfoCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct ControllerDebugInfoCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,controller_debug_info_complete: Arc<ControllerDebugInfoCompleteData>,}
#[derive(Debug)] pub struct ControllerDebugInfoCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, }
impl ControllerDebugInfoCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ControllerDebugInfoComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for ControllerDebugInfoCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ControllerDebugInfoCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let controller_debug_info_complete = match &command_complete.child {CommandCompleteDataChild::ControllerDebugInfoComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ControllerDebugInfoComplete"),};Self {event,command_complete,controller_debug_info_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.controller_debug_info_complete.as_ref().status}
}
impl Into<EventPacket> for ControllerDebugInfoCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ControllerDebugInfoCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ControllerDebugInfoCompleteBuilder {pub fn build(self) -> ControllerDebugInfoCompletePacket {let controller_debug_info_complete= Arc::new(ControllerDebugInfoCompleteData {status: self.status, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ControllerDebugInfo, child: CommandCompleteDataChild::ControllerDebugInfoComplete(controller_debug_info_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ControllerDebugInfoCompletePacket::new(event)}
}
impl Into<EventPacket> for ControllerDebugInfoCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ControllerDebugInfoCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] enum ControllerA2DPOpcodeDataChild {Payload(Bytes),None,}
impl ControllerA2DPOpcodeDataChild {fn get_total_size(&self) -> usize {match self {ControllerA2DPOpcodeDataChild::Payload(p) => p.len(),ControllerA2DPOpcodeDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum ControllerA2DPOpcodeChild {Payload(Bytes),None,}
#[derive(Debug)] struct ControllerA2DPOpcodeData {child: ControllerA2DPOpcodeDataChild,}
#[derive(Debug, Clone)] pub struct ControllerA2DPOpcodePacket {command: Arc<CommandData>,vendor_command: Arc<VendorCommandData>,controller_a2_d_p_opcode: Arc<ControllerA2DPOpcodeData>,}
#[derive(Debug)] pub struct ControllerA2DPOpcodeBuilder {pub payload: Option<Bytes>,}
impl ControllerA2DPOpcodeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {let payload: Vec::<u8> = bytes[3..].into();let child = if payload.len() > 0 {ControllerA2DPOpcodeDataChild::Payload(Bytes::from(payload))} else {ControllerA2DPOpcodeDataChild::None};Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {ControllerA2DPOpcodeDataChild::Payload(p) => buffer[3..].copy_from_slice(&p[..]),ControllerA2DPOpcodeDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl CommandExpectations for ControllerA2DPOpcodePacket { type ResponseType = ControllerA2DPOpcodeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ControllerA2DPOpcodeCompletePacket::new(pkt.event.clone()) }}impl Packet for ControllerA2DPOpcodePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ControllerA2DPOpcodePacket { pub fn specialize(&self) -> ControllerA2DPOpcodeChild { match &self.controller_a2_d_p_opcode.child {ControllerA2DPOpcodeDataChild::Payload(p) => ControllerA2DPOpcodeChild::Payload(p.clone()),ControllerA2DPOpcodeDataChild::None => ControllerA2DPOpcodeChild::None,}} fn new(root: Arc<CommandData>) -> Self {let command = root;let vendor_command = match &command.child {CommandDataChild::VendorCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not VendorCommand"),};let controller_a2_d_p_opcode = match &vendor_command.child {VendorCommandDataChild::ControllerA2DPOpcode(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ControllerA2DPOpcode"),};Self {command,vendor_command,controller_a2_d_p_opcode,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
}
impl Into<CommandPacket> for ControllerA2DPOpcodePacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<VendorCommandPacket> for ControllerA2DPOpcodePacket { fn into(self) -> VendorCommandPacket {VendorCommandPacket::new(self.command) }}
impl CommandExpectations for ControllerA2DPOpcodeBuilder { type ResponseType = ControllerA2DPOpcodeCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ControllerA2DPOpcodeCompletePacket::new(pkt.event.clone()) }}impl ControllerA2DPOpcodeBuilder {pub fn build(self) -> ControllerA2DPOpcodePacket {let controller_a2_d_p_opcode= Arc::new(ControllerA2DPOpcodeData {child: match self.payload { None => ControllerA2DPOpcodeDataChild::None,Some(bytes) => ControllerA2DPOpcodeDataChild::Payload(bytes),},});let vendor_command= Arc::new(VendorCommandData {child: VendorCommandDataChild::ControllerA2DPOpcode(controller_a2_d_p_opcode),});let command= Arc::new(CommandData {op_code: OpCode::ControllerA2dpOpcode, child: CommandDataChild::VendorCommand(vendor_command),});ControllerA2DPOpcodePacket::new(command)}
}
impl Into<CommandPacket> for ControllerA2DPOpcodeBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<VendorCommandPacket> for ControllerA2DPOpcodeBuilder { fn into(self) -> VendorCommandPacket { self.build().into() }}


#[derive(Debug)] enum ControllerA2DPOpcodeCompleteDataChild {Payload(Bytes),None,}
impl ControllerA2DPOpcodeCompleteDataChild {fn get_total_size(&self) -> usize {match self {ControllerA2DPOpcodeCompleteDataChild::Payload(p) => p.len(),ControllerA2DPOpcodeCompleteDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum ControllerA2DPOpcodeCompleteChild {Payload(Bytes),None,}
#[derive(Debug)] struct ControllerA2DPOpcodeCompleteData {child: ControllerA2DPOpcodeCompleteDataChild,}
#[derive(Debug, Clone)] pub struct ControllerA2DPOpcodeCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,controller_a2_d_p_opcode_complete: Arc<ControllerA2DPOpcodeCompleteData>,}
#[derive(Debug)] pub struct ControllerA2DPOpcodeCompleteBuilder {pub num_hci_command_packets: u8, pub payload: Option<Bytes>,}
impl ControllerA2DPOpcodeCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {let payload: Vec::<u8> = bytes[5..].into();let child = if payload.len() > 0 {ControllerA2DPOpcodeCompleteDataChild::Payload(Bytes::from(payload))} else {ControllerA2DPOpcodeCompleteDataChild::None};Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {ControllerA2DPOpcodeCompleteDataChild::Payload(p) => buffer[5..].copy_from_slice(&p[..]),ControllerA2DPOpcodeCompleteDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for ControllerA2DPOpcodeCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ControllerA2DPOpcodeCompletePacket { pub fn specialize(&self) -> ControllerA2DPOpcodeCompleteChild { match &self.controller_a2_d_p_opcode_complete.child {ControllerA2DPOpcodeCompleteDataChild::Payload(p) => ControllerA2DPOpcodeCompleteChild::Payload(p.clone()),ControllerA2DPOpcodeCompleteDataChild::None => ControllerA2DPOpcodeCompleteChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let controller_a2_d_p_opcode_complete = match &command_complete.child {CommandCompleteDataChild::ControllerA2DPOpcodeComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ControllerA2DPOpcodeComplete"),};Self {event,command_complete,controller_a2_d_p_opcode_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
}
impl Into<EventPacket> for ControllerA2DPOpcodeCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ControllerA2DPOpcodeCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ControllerA2DPOpcodeCompleteBuilder {pub fn build(self) -> ControllerA2DPOpcodeCompletePacket {let controller_a2_d_p_opcode_complete= Arc::new(ControllerA2DPOpcodeCompleteData {child: match self.payload { None => ControllerA2DPOpcodeCompleteDataChild::None,Some(bytes) => ControllerA2DPOpcodeCompleteDataChild::Payload(bytes),},});let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ControllerA2dpOpcode, child: CommandCompleteDataChild::ControllerA2DPOpcodeComplete(controller_a2_d_p_opcode_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ControllerA2DPOpcodeCompletePacket::new(event)}
}
impl Into<EventPacket> for ControllerA2DPOpcodeCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ControllerA2DPOpcodeCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}


#[derive(Debug)] struct ControllerBqrData {bqr_report_action: BqrReportAction, bqr_quality_event_mask: u32, bqr_minimum_report_interval: u16, }
#[derive(Debug, Clone)] pub struct ControllerBqrPacket {command: Arc<CommandData>,vendor_command: Arc<VendorCommandData>,controller_bqr: Arc<ControllerBqrData>,}
#[derive(Debug)] pub struct ControllerBqrBuilder {pub bqr_report_action: BqrReportAction, pub bqr_quality_event_mask: u32, pub bqr_minimum_report_interval: u16, }
impl ControllerBqrData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "ControllerBqr".to_string(),    field: "bqr_report_action".to_string(),    wanted: 4,    got: bytes.len()});}let bqr_report_action = u8::from_le_bytes([bytes[3]]);let bqr_report_action = BqrReportAction::from_u8(bqr_report_action).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ControllerBqr".to_string(),    field: "bqr_quality_event_mask".to_string(),    wanted: 8,    got: bytes.len()});}let bqr_quality_event_mask = u32::from_le_bytes([bytes[4],bytes[5],bytes[6],bytes[7]]);if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "ControllerBqr".to_string(),    field: "bqr_minimum_report_interval".to_string(),    wanted: 10,    got: bytes.len()});}let bqr_minimum_report_interval = u16::from_le_bytes([bytes[8],bytes[9]]);Ok(Self {bqr_report_action, bqr_quality_event_mask, bqr_minimum_report_interval, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bqr_report_action = self.bqr_report_action.to_u8().unwrap();buffer[3..4].copy_from_slice(&bqr_report_action.to_le_bytes()[0..1]);let bqr_quality_event_mask = self.bqr_quality_event_mask;buffer[4..8].copy_from_slice(&bqr_quality_event_mask.to_le_bytes()[0..4]);let bqr_minimum_report_interval = self.bqr_minimum_report_interval;buffer[8..10].copy_from_slice(&bqr_minimum_report_interval.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl CommandExpectations for ControllerBqrPacket { type ResponseType = ControllerBqrCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ControllerBqrCompletePacket::new(pkt.event.clone()) }}impl Packet for ControllerBqrPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ControllerBqrPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let vendor_command = match &command.child {CommandDataChild::VendorCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not VendorCommand"),};let controller_bqr = match &vendor_command.child {VendorCommandDataChild::ControllerBqr(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ControllerBqr"),};Self {command,vendor_command,controller_bqr,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_bqr_report_action(&self) -> BqrReportAction{ self.controller_bqr.as_ref().bqr_report_action}
pub fn get_bqr_quality_event_mask(&self) -> u32{ self.controller_bqr.as_ref().bqr_quality_event_mask}
pub fn get_bqr_minimum_report_interval(&self) -> u16{ self.controller_bqr.as_ref().bqr_minimum_report_interval}
}
impl Into<CommandPacket> for ControllerBqrPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl Into<VendorCommandPacket> for ControllerBqrPacket { fn into(self) -> VendorCommandPacket {VendorCommandPacket::new(self.command) }}
impl CommandExpectations for ControllerBqrBuilder { type ResponseType = ControllerBqrCompletePacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { ControllerBqrCompletePacket::new(pkt.event.clone()) }}impl ControllerBqrBuilder {pub fn build(self) -> ControllerBqrPacket {let controller_bqr= Arc::new(ControllerBqrData {bqr_report_action: self.bqr_report_action, bqr_quality_event_mask: self.bqr_quality_event_mask, bqr_minimum_report_interval: self.bqr_minimum_report_interval, });let vendor_command= Arc::new(VendorCommandData {child: VendorCommandDataChild::ControllerBqr(controller_bqr),});let command= Arc::new(CommandData {op_code: OpCode::ControllerBqr, child: CommandDataChild::VendorCommand(vendor_command),});ControllerBqrPacket::new(command)}
}
impl Into<CommandPacket> for ControllerBqrBuilder { fn into(self) -> CommandPacket { self.build().into() }}
impl Into<VendorCommandPacket> for ControllerBqrBuilder { fn into(self) -> VendorCommandPacket { self.build().into() }}
macro_rules! controller_bqr_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match CommandPacket::parse(raw_bytes) {Ok(command_packet) => {match command_packet.specialize() {/* (1) */
CommandChild::VendorCommand(vendor_command_packet) => {match vendor_command_packet.specialize() {/* (2) */
VendorCommandChild::ControllerBqr(packet) => {let rebuilder = ControllerBqrBuilder {bqr_report_action : packet.get_bqr_report_action(),bqr_quality_event_mask : packet.get_bqr_quality_event_mask(),bqr_minimum_report_interval : packet.get_bqr_minimum_report_interval(),};let rebuilder_base : CommandPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse controller_bqr{:02x?}", vendor_command_packet); }}}_ => {println!("Couldn't parse vendor_command{:02x?}", command_packet); }}},Err(e) => panic!("could not parse Command: {:?} {:02x?}", e, raw_bytes),}})*}}controller_bqr_builder_tests! { controller_bqr_builder_test_00: b"\x5e\xfd\x07\x00\x1f\x00\x07\x00\x88\x13",}


#[derive(Debug)] struct ControllerBqrCompleteData {status: ErrorCode, current_quality_event_mask: u32, }
#[derive(Debug, Clone)] pub struct ControllerBqrCompletePacket {event: Arc<EventData>,command_complete: Arc<CommandCompleteData>,controller_bqr_complete: Arc<ControllerBqrCompleteData>,}
#[derive(Debug)] pub struct ControllerBqrCompleteBuilder {pub num_hci_command_packets: u8, pub status: ErrorCode, pub current_quality_event_mask: u32, }
impl ControllerBqrCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ControllerBqrComplete".to_string(),    field: "status".to_string(),    wanted: 6,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[5]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "ControllerBqrComplete".to_string(),    field: "current_quality_event_mask".to_string(),    wanted: 10,    got: bytes.len()});}let current_quality_event_mask = u32::from_le_bytes([bytes[6],bytes[7],bytes[8],bytes[9]]);Ok(Self {status, current_quality_event_mask, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[5..6].copy_from_slice(&status.to_le_bytes()[0..1]);let current_quality_event_mask = self.current_quality_event_mask;buffer[6..10].copy_from_slice(&current_quality_event_mask.to_le_bytes()[0..4]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 5;ret}
}
impl Packet for ControllerBqrCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ControllerBqrCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_complete = match &event.child {EventDataChild::CommandComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandComplete"),};let controller_bqr_complete = match &command_complete.child {CommandCompleteDataChild::ControllerBqrComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ControllerBqrComplete"),};Self {event,command_complete,controller_bqr_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_complete.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_complete.as_ref().command_op_code}
pub fn get_status(&self) -> ErrorCode{ self.controller_bqr_complete.as_ref().status}
pub fn get_current_quality_event_mask(&self) -> u32{ self.controller_bqr_complete.as_ref().current_quality_event_mask}
}
impl Into<EventPacket> for ControllerBqrCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandCompletePacket> for ControllerBqrCompletePacket { fn into(self) -> CommandCompletePacket {CommandCompletePacket::new(self.event) }}
impl ControllerBqrCompleteBuilder {pub fn build(self) -> ControllerBqrCompletePacket {let controller_bqr_complete= Arc::new(ControllerBqrCompleteData {status: self.status, current_quality_event_mask: self.current_quality_event_mask, });let command_complete= Arc::new(CommandCompleteData {num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::ControllerBqr, child: CommandCompleteDataChild::ControllerBqrComplete(controller_bqr_complete),});let event= Arc::new(EventData {event_code: EventCode::CommandComplete, child: EventDataChild::CommandComplete(command_complete),});ControllerBqrCompletePacket::new(event)}
}
impl Into<EventPacket> for ControllerBqrCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandCompletePacket> for ControllerBqrCompleteBuilder { fn into(self) -> CommandCompletePacket { self.build().into() }}
macro_rules! controller_bqr_complete_builder_tests { ($($name:ident: $byte_string:expr,)*) => {$(
#[test]
pub fn $name() { let raw_bytes = $byte_string;/* (0) */
match EventPacket::parse(raw_bytes) {Ok(event_packet) => {match event_packet.specialize() {/* (1) */
EventChild::CommandComplete(command_complete_packet) => {match command_complete_packet.specialize() {/* (2) */
CommandCompleteChild::ControllerBqrComplete(packet) => {let rebuilder = ControllerBqrCompleteBuilder {num_hci_command_packets : packet.get_num_hci_command_packets(),status : packet.get_status(),current_quality_event_mask : packet.get_current_quality_event_mask(),};let rebuilder_base : EventPacket = rebuilder.into();let rebuilder_bytes : &[u8] = &rebuilder_base.to_bytes();assert_eq!(rebuilder_bytes, raw_bytes);}_ => {println!("Couldn't parse controller_bqr_complete{:02x?}", command_complete_packet); }}}_ => {println!("Couldn't parse command_complete{:02x?}", event_packet); }}},Err(e) => panic!("could not parse Event: {:?} {:02x?}", e, raw_bytes),}})*}}controller_bqr_complete_builder_tests! { controller_bqr_complete_builder_test_00: b"\x0e\x08\x01\x5e\xfd\x00\x1f\x00\x07\x00",}


#[derive(Debug)] struct InquiryCompleteData {status: ErrorCode, }
#[derive(Debug, Clone)] pub struct InquiryCompletePacket {event: Arc<EventData>,inquiry_complete: Arc<InquiryCompleteData>,}
#[derive(Debug)] pub struct InquiryCompleteBuilder {pub status: ErrorCode, }
impl InquiryCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "InquiryComplete".to_string(),    field: "status".to_string(),    wanted: 3,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[2]]);let status = ErrorCode::from_u8(status).unwrap();Ok(Self {status, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[2..3].copy_from_slice(&status.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for InquiryCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl InquiryCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let inquiry_complete = match &event.child {EventDataChild::InquiryComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not InquiryComplete"),};Self {event,inquiry_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.inquiry_complete.as_ref().status}
}
impl Into<EventPacket> for InquiryCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl InquiryCompleteBuilder {pub fn build(self) -> InquiryCompletePacket {let inquiry_complete= Arc::new(InquiryCompleteData {status: self.status, });let event= Arc::new(EventData {event_code: EventCode::InquiryComplete, child: EventDataChild::InquiryComplete(inquiry_complete),});InquiryCompletePacket::new(event)}
}
impl Into<EventPacket> for InquiryCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct InquiryResultData {inquiry_results: Vec::<InquiryResult>, }
#[derive(Debug, Clone)] pub struct InquiryResultPacket {event: Arc<EventData>,inquiry_result: Arc<InquiryResultData>,}
#[derive(Debug)] pub struct InquiryResultBuilder {pub inquiry_results: Vec::<InquiryResult>, }
impl InquiryResultData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "InquiryResult".to_string(),    field: "inquiry_results_count".to_string(),    wanted: 3,    got: bytes.len()});}let inquiry_results_count = u8::from_le_bytes([bytes[2]]);let mut inquiry_results: Vec::<InquiryResult> = Vec::new();let mut parsable_ = &bytes[3..];let count_ = inquiry_results_count as usize;for _ in 0..count_ { match InquiryResult::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];inquiry_results.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {inquiry_results, })
}
fn write_to(&self, buffer: &mut BytesMut) {buffer[2..3].copy_from_slice(&(self.inquiry_results.len() as u8).to_le_bytes());let mut vec_buffer_ = &mut buffer[3..];for e_ in &self.inquiry_results { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;let ret = ret + (self.inquiry_results.len() * ((/* Bits: */ 112 + /* Dynamic: */ 0) / 8));ret}
}
impl Packet for InquiryResultPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl InquiryResultPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let inquiry_result = match &event.child {EventDataChild::InquiryResult(value) => (*value).clone(),_ => panic!("inconsistent state - child was not InquiryResult"),};Self {event,inquiry_result,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_inquiry_results(&self) -> &Vec::<InquiryResult>{ &self.inquiry_result.as_ref().inquiry_results}
}
impl Into<EventPacket> for InquiryResultPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl InquiryResultBuilder {pub fn build(self) -> InquiryResultPacket {let inquiry_result= Arc::new(InquiryResultData {inquiry_results: self.inquiry_results, });let event= Arc::new(EventData {event_code: EventCode::InquiryResult, child: EventDataChild::InquiryResult(inquiry_result),});InquiryResultPacket::new(event)}
}
impl Into<EventPacket> for InquiryResultBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct ConnectionCompleteData {status: ErrorCode, connection_handle: u16, bd_addr: Address, link_type: LinkType, encryption_enabled: Enable, }
#[derive(Debug, Clone)] pub struct ConnectionCompletePacket {event: Arc<EventData>,connection_complete: Arc<ConnectionCompleteData>,}
#[derive(Debug)] pub struct ConnectionCompleteBuilder {pub status: ErrorCode, pub connection_handle: u16, pub bd_addr: Address, pub link_type: LinkType, pub encryption_enabled: Enable, }
impl ConnectionCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "ConnectionComplete".to_string(),    field: "status".to_string(),    wanted: 3,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[2]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ConnectionComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "ConnectionComplete".to_string(),    field: "bd_addr".to_string(),    wanted: 11,    got: bytes.len()});}let bd_addr = bytes[5..11].try_into().unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "ConnectionComplete".to_string(),    field: "link_type".to_string(),    wanted: 12,    got: bytes.len()});}let link_type = u8::from_le_bytes([bytes[11]]);let link_type = LinkType::from_u8(link_type).unwrap();if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "ConnectionComplete".to_string(),    field: "encryption_enabled".to_string(),    wanted: 13,    got: bytes.len()});}let encryption_enabled = u8::from_le_bytes([bytes[12]]);let encryption_enabled = Enable::from_u8(encryption_enabled).unwrap();Ok(Self {status, connection_handle, bd_addr, link_type, encryption_enabled, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[2..3].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let bd_addr: [u8; 6] = self.bd_addr.into();buffer[5..11].copy_from_slice(&bd_addr);let link_type = self.link_type.to_u8().unwrap();buffer[11..12].copy_from_slice(&link_type.to_le_bytes()[0..1]);let encryption_enabled = self.encryption_enabled.to_u8().unwrap();buffer[12..13].copy_from_slice(&encryption_enabled.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 11;ret}
}
impl Packet for ConnectionCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ConnectionCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let connection_complete = match &event.child {EventDataChild::ConnectionComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionComplete"),};Self {event,connection_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.connection_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.connection_complete.as_ref().connection_handle}
pub fn get_bd_addr(&self) -> Address{ self.connection_complete.as_ref().bd_addr}
pub fn get_link_type(&self) -> LinkType{ self.connection_complete.as_ref().link_type}
pub fn get_encryption_enabled(&self) -> Enable{ self.connection_complete.as_ref().encryption_enabled}
}
impl Into<EventPacket> for ConnectionCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl ConnectionCompleteBuilder {pub fn build(self) -> ConnectionCompletePacket {let connection_complete= Arc::new(ConnectionCompleteData {status: self.status, connection_handle: self.connection_handle, bd_addr: self.bd_addr, link_type: self.link_type, encryption_enabled: self.encryption_enabled, });let event= Arc::new(EventData {event_code: EventCode::ConnectionComplete, child: EventDataChild::ConnectionComplete(connection_complete),});ConnectionCompletePacket::new(event)}
}
impl Into<EventPacket> for ConnectionCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct ConnectionRequestData {bd_addr: Address, class_of_device: ClassOfDevice, link_type: ConnectionRequestLinkType, }
#[derive(Debug, Clone)] pub struct ConnectionRequestPacket {event: Arc<EventData>,connection_request: Arc<ConnectionRequestData>,}
#[derive(Debug)] pub struct ConnectionRequestBuilder {pub bd_addr: Address, pub class_of_device: ClassOfDevice, pub link_type: ConnectionRequestLinkType, }
impl ConnectionRequestData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ConnectionRequest".to_string(),    field: "bd_addr".to_string(),    wanted: 8,    got: bytes.len()});}let bd_addr = bytes[2..8].try_into().unwrap();if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "ConnectionRequest".to_string(),    field: "class_of_device".to_string(),    wanted: 11,    got: bytes.len()});}let class_of_device = bytes[8..11].try_into().unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "ConnectionRequest".to_string(),    field: "link_type".to_string(),    wanted: 12,    got: bytes.len()});}let link_type = u8::from_le_bytes([bytes[11]]);let link_type = ConnectionRequestLinkType::from_u8(link_type).unwrap();Ok(Self {bd_addr, class_of_device, link_type, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[2..8].copy_from_slice(&bd_addr);let class_of_device: [u8; 3] = self.class_of_device.into();buffer[8..11].copy_from_slice(&class_of_device);let link_type = self.link_type.to_u8().unwrap();buffer[11..12].copy_from_slice(&link_type.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 10;ret}
}
impl Packet for ConnectionRequestPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ConnectionRequestPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let connection_request = match &event.child {EventDataChild::ConnectionRequest(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionRequest"),};Self {event,connection_request,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_bd_addr(&self) -> Address{ self.connection_request.as_ref().bd_addr}
pub fn get_class_of_device(&self) -> ClassOfDevice{ self.connection_request.as_ref().class_of_device}
pub fn get_link_type(&self) -> ConnectionRequestLinkType{ self.connection_request.as_ref().link_type}
}
impl Into<EventPacket> for ConnectionRequestPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl ConnectionRequestBuilder {pub fn build(self) -> ConnectionRequestPacket {let connection_request= Arc::new(ConnectionRequestData {bd_addr: self.bd_addr, class_of_device: self.class_of_device, link_type: self.link_type, });let event= Arc::new(EventData {event_code: EventCode::ConnectionRequest, child: EventDataChild::ConnectionRequest(connection_request),});ConnectionRequestPacket::new(event)}
}
impl Into<EventPacket> for ConnectionRequestBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct DisconnectionCompleteData {status: ErrorCode, connection_handle: u16, reason: ErrorCode, }
#[derive(Debug, Clone)] pub struct DisconnectionCompletePacket {event: Arc<EventData>,disconnection_complete: Arc<DisconnectionCompleteData>,}
#[derive(Debug)] pub struct DisconnectionCompleteBuilder {pub status: ErrorCode, pub connection_handle: u16, pub reason: ErrorCode, }
impl DisconnectionCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "DisconnectionComplete".to_string(),    field: "status".to_string(),    wanted: 3,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[2]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "DisconnectionComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "DisconnectionComplete".to_string(),    field: "reason".to_string(),    wanted: 6,    got: bytes.len()});}let reason = u8::from_le_bytes([bytes[5]]);let reason = ErrorCode::from_u8(reason).unwrap();Ok(Self {status, connection_handle, reason, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[2..3].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let reason = self.reason.to_u8().unwrap();buffer[5..6].copy_from_slice(&reason.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl Packet for DisconnectionCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl DisconnectionCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let disconnection_complete = match &event.child {EventDataChild::DisconnectionComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DisconnectionComplete"),};Self {event,disconnection_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.disconnection_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.disconnection_complete.as_ref().connection_handle}
pub fn get_reason(&self) -> ErrorCode{ self.disconnection_complete.as_ref().reason}
}
impl Into<EventPacket> for DisconnectionCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl DisconnectionCompleteBuilder {pub fn build(self) -> DisconnectionCompletePacket {let disconnection_complete= Arc::new(DisconnectionCompleteData {status: self.status, connection_handle: self.connection_handle, reason: self.reason, });let event= Arc::new(EventData {event_code: EventCode::DisconnectionComplete, child: EventDataChild::DisconnectionComplete(disconnection_complete),});DisconnectionCompletePacket::new(event)}
}
impl Into<EventPacket> for DisconnectionCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct AuthenticationCompleteData {status: ErrorCode, connection_handle: u16, }
#[derive(Debug, Clone)] pub struct AuthenticationCompletePacket {event: Arc<EventData>,authentication_complete: Arc<AuthenticationCompleteData>,}
#[derive(Debug)] pub struct AuthenticationCompleteBuilder {pub status: ErrorCode, pub connection_handle: u16, }
impl AuthenticationCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "AuthenticationComplete".to_string(),    field: "status".to_string(),    wanted: 3,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[2]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "AuthenticationComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {status, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[2..3].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for AuthenticationCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl AuthenticationCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let authentication_complete = match &event.child {EventDataChild::AuthenticationComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not AuthenticationComplete"),};Self {event,authentication_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.authentication_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.authentication_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for AuthenticationCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl AuthenticationCompleteBuilder {pub fn build(self) -> AuthenticationCompletePacket {let authentication_complete= Arc::new(AuthenticationCompleteData {status: self.status, connection_handle: self.connection_handle, });let event= Arc::new(EventData {event_code: EventCode::AuthenticationComplete, child: EventDataChild::AuthenticationComplete(authentication_complete),});AuthenticationCompletePacket::new(event)}
}
impl Into<EventPacket> for AuthenticationCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct RemoteNameRequestCompleteData {status: ErrorCode, bd_addr: Address, remote_name: [u8; 248], }
#[derive(Debug, Clone)] pub struct RemoteNameRequestCompletePacket {event: Arc<EventData>,remote_name_request_complete: Arc<RemoteNameRequestCompleteData>,}
#[derive(Debug)] pub struct RemoteNameRequestCompleteBuilder {pub status: ErrorCode, pub bd_addr: Address, pub remote_name: [u8; 248], }
impl RemoteNameRequestCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "RemoteNameRequestComplete".to_string(),    field: "status".to_string(),    wanted: 3,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[2]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "RemoteNameRequestComplete".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();if bytes.len() < 257 { return Err(Error::InvalidLengthError{    obj: "RemoteNameRequestComplete".to_string(),    field: "remote_name".to_string(),    wanted: 257,    got: bytes.len()});}let remote_name = bytes[9..257].try_into().unwrap();Ok(Self {status, bd_addr, remote_name, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[2..3].copy_from_slice(&status.to_le_bytes()[0..1]);let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);&buffer[9..257].copy_from_slice(&self.remote_name);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 255;ret}
}
impl Packet for RemoteNameRequestCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl RemoteNameRequestCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let remote_name_request_complete = match &event.child {EventDataChild::RemoteNameRequestComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not RemoteNameRequestComplete"),};Self {event,remote_name_request_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.remote_name_request_complete.as_ref().status}
pub fn get_bd_addr(&self) -> Address{ self.remote_name_request_complete.as_ref().bd_addr}
pub fn get_remote_name(&self) -> &[u8; 248]{ &self.remote_name_request_complete.as_ref().remote_name}
}
impl Into<EventPacket> for RemoteNameRequestCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl RemoteNameRequestCompleteBuilder {pub fn build(self) -> RemoteNameRequestCompletePacket {let remote_name_request_complete= Arc::new(RemoteNameRequestCompleteData {status: self.status, bd_addr: self.bd_addr, remote_name: self.remote_name, });let event= Arc::new(EventData {event_code: EventCode::RemoteNameRequestComplete, child: EventDataChild::RemoteNameRequestComplete(remote_name_request_complete),});RemoteNameRequestCompletePacket::new(event)}
}
impl Into<EventPacket> for RemoteNameRequestCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct EncryptionChangeData {status: ErrorCode, connection_handle: u16, encryption_enabled: EncryptionEnabled, }
#[derive(Debug, Clone)] pub struct EncryptionChangePacket {event: Arc<EventData>,encryption_change: Arc<EncryptionChangeData>,}
#[derive(Debug)] pub struct EncryptionChangeBuilder {pub status: ErrorCode, pub connection_handle: u16, pub encryption_enabled: EncryptionEnabled, }
impl EncryptionChangeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "EncryptionChange".to_string(),    field: "status".to_string(),    wanted: 3,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[2]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "EncryptionChange".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "EncryptionChange".to_string(),    field: "encryption_enabled".to_string(),    wanted: 6,    got: bytes.len()});}let encryption_enabled = u8::from_le_bytes([bytes[5]]);let encryption_enabled = EncryptionEnabled::from_u8(encryption_enabled).unwrap();Ok(Self {status, connection_handle, encryption_enabled, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[2..3].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let encryption_enabled = self.encryption_enabled.to_u8().unwrap();buffer[5..6].copy_from_slice(&encryption_enabled.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl Packet for EncryptionChangePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl EncryptionChangePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let encryption_change = match &event.child {EventDataChild::EncryptionChange(value) => (*value).clone(),_ => panic!("inconsistent state - child was not EncryptionChange"),};Self {event,encryption_change,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.encryption_change.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.encryption_change.as_ref().connection_handle}
pub fn get_encryption_enabled(&self) -> EncryptionEnabled{ self.encryption_change.as_ref().encryption_enabled}
}
impl Into<EventPacket> for EncryptionChangePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl EncryptionChangeBuilder {pub fn build(self) -> EncryptionChangePacket {let encryption_change= Arc::new(EncryptionChangeData {status: self.status, connection_handle: self.connection_handle, encryption_enabled: self.encryption_enabled, });let event= Arc::new(EventData {event_code: EventCode::EncryptionChange, child: EventDataChild::EncryptionChange(encryption_change),});EncryptionChangePacket::new(event)}
}
impl Into<EventPacket> for EncryptionChangeBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct ChangeConnectionLinkKeyCompleteData {status: ErrorCode, connection_handle: u16, }
#[derive(Debug, Clone)] pub struct ChangeConnectionLinkKeyCompletePacket {event: Arc<EventData>,change_connection_link_key_complete: Arc<ChangeConnectionLinkKeyCompleteData>,}
#[derive(Debug)] pub struct ChangeConnectionLinkKeyCompleteBuilder {pub status: ErrorCode, pub connection_handle: u16, }
impl ChangeConnectionLinkKeyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "ChangeConnectionLinkKeyComplete".to_string(),    field: "status".to_string(),    wanted: 3,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[2]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ChangeConnectionLinkKeyComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {status, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[2..3].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for ChangeConnectionLinkKeyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ChangeConnectionLinkKeyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let change_connection_link_key_complete = match &event.child {EventDataChild::ChangeConnectionLinkKeyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ChangeConnectionLinkKeyComplete"),};Self {event,change_connection_link_key_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.change_connection_link_key_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.change_connection_link_key_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for ChangeConnectionLinkKeyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl ChangeConnectionLinkKeyCompleteBuilder {pub fn build(self) -> ChangeConnectionLinkKeyCompletePacket {let change_connection_link_key_complete= Arc::new(ChangeConnectionLinkKeyCompleteData {status: self.status, connection_handle: self.connection_handle, });let event= Arc::new(EventData {event_code: EventCode::ChangeConnectionLinkKeyComplete, child: EventDataChild::ChangeConnectionLinkKeyComplete(change_connection_link_key_complete),});ChangeConnectionLinkKeyCompletePacket::new(event)}
}
impl Into<EventPacket> for ChangeConnectionLinkKeyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct CentralLinkKeyCompleteData {status: ErrorCode, connection_handle: u16, key_flag: KeyFlag, }
#[derive(Debug, Clone)] pub struct CentralLinkKeyCompletePacket {event: Arc<EventData>,central_link_key_complete: Arc<CentralLinkKeyCompleteData>,}
#[derive(Debug)] pub struct CentralLinkKeyCompleteBuilder {pub status: ErrorCode, pub connection_handle: u16, pub key_flag: KeyFlag, }
impl CentralLinkKeyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "CentralLinkKeyComplete".to_string(),    field: "status".to_string(),    wanted: 3,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[2]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "CentralLinkKeyComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "CentralLinkKeyComplete".to_string(),    field: "key_flag".to_string(),    wanted: 6,    got: bytes.len()});}let key_flag = u8::from_le_bytes([bytes[5]]);let key_flag = KeyFlag::from_u8(key_flag).unwrap();Ok(Self {status, connection_handle, key_flag, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[2..3].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let key_flag = self.key_flag.to_u8().unwrap();buffer[5..6].copy_from_slice(&key_flag.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl Packet for CentralLinkKeyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl CentralLinkKeyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let central_link_key_complete = match &event.child {EventDataChild::CentralLinkKeyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CentralLinkKeyComplete"),};Self {event,central_link_key_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.central_link_key_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.central_link_key_complete.as_ref().connection_handle}
pub fn get_key_flag(&self) -> KeyFlag{ self.central_link_key_complete.as_ref().key_flag}
}
impl Into<EventPacket> for CentralLinkKeyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl CentralLinkKeyCompleteBuilder {pub fn build(self) -> CentralLinkKeyCompletePacket {let central_link_key_complete= Arc::new(CentralLinkKeyCompleteData {status: self.status, connection_handle: self.connection_handle, key_flag: self.key_flag, });let event= Arc::new(EventData {event_code: EventCode::CentralLinkKeyComplete, child: EventDataChild::CentralLinkKeyComplete(central_link_key_complete),});CentralLinkKeyCompletePacket::new(event)}
}
impl Into<EventPacket> for CentralLinkKeyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct ReadRemoteSupportedFeaturesCompleteData {status: ErrorCode, connection_handle: u16, lmp_features: u64, }
#[derive(Debug, Clone)] pub struct ReadRemoteSupportedFeaturesCompletePacket {event: Arc<EventData>,read_remote_supported_features_complete: Arc<ReadRemoteSupportedFeaturesCompleteData>,}
#[derive(Debug)] pub struct ReadRemoteSupportedFeaturesCompleteBuilder {pub status: ErrorCode, pub connection_handle: u16, pub lmp_features: u64, }
impl ReadRemoteSupportedFeaturesCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "ReadRemoteSupportedFeaturesComplete".to_string(),    field: "status".to_string(),    wanted: 3,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[2]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ReadRemoteSupportedFeaturesComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "ReadRemoteSupportedFeaturesComplete".to_string(),    field: "lmp_features".to_string(),    wanted: 13,    got: bytes.len()});}let lmp_features = u64::from_le_bytes([bytes[5],bytes[6],bytes[7],bytes[8],bytes[9],bytes[10],bytes[11],bytes[12]]);Ok(Self {status, connection_handle, lmp_features, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[2..3].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let lmp_features = self.lmp_features;buffer[5..13].copy_from_slice(&lmp_features.to_le_bytes()[0..8]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 11;ret}
}
impl Packet for ReadRemoteSupportedFeaturesCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadRemoteSupportedFeaturesCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let read_remote_supported_features_complete = match &event.child {EventDataChild::ReadRemoteSupportedFeaturesComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadRemoteSupportedFeaturesComplete"),};Self {event,read_remote_supported_features_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.read_remote_supported_features_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.read_remote_supported_features_complete.as_ref().connection_handle}
pub fn get_lmp_features(&self) -> u64{ self.read_remote_supported_features_complete.as_ref().lmp_features}
}
impl Into<EventPacket> for ReadRemoteSupportedFeaturesCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl ReadRemoteSupportedFeaturesCompleteBuilder {pub fn build(self) -> ReadRemoteSupportedFeaturesCompletePacket {let read_remote_supported_features_complete= Arc::new(ReadRemoteSupportedFeaturesCompleteData {status: self.status, connection_handle: self.connection_handle, lmp_features: self.lmp_features, });let event= Arc::new(EventData {event_code: EventCode::ReadRemoteSupportedFeaturesComplete, child: EventDataChild::ReadRemoteSupportedFeaturesComplete(read_remote_supported_features_complete),});ReadRemoteSupportedFeaturesCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadRemoteSupportedFeaturesCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct ReadRemoteVersionInformationCompleteData {status: ErrorCode, connection_handle: u16, version: u8, manufacturer_name: u16, sub_version: u16, }
#[derive(Debug, Clone)] pub struct ReadRemoteVersionInformationCompletePacket {event: Arc<EventData>,read_remote_version_information_complete: Arc<ReadRemoteVersionInformationCompleteData>,}
#[derive(Debug)] pub struct ReadRemoteVersionInformationCompleteBuilder {pub status: ErrorCode, pub connection_handle: u16, pub version: u8, pub manufacturer_name: u16, pub sub_version: u16, }
impl ReadRemoteVersionInformationCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "ReadRemoteVersionInformationComplete".to_string(),    field: "status".to_string(),    wanted: 3,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[2]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ReadRemoteVersionInformationComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadRemoteVersionInformationComplete".to_string(),    field: "version".to_string(),    wanted: 6,    got: bytes.len()});}let version = u8::from_le_bytes([bytes[5]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ReadRemoteVersionInformationComplete".to_string(),    field: "manufacturer_name".to_string(),    wanted: 8,    got: bytes.len()});}let manufacturer_name = u16::from_le_bytes([bytes[6],bytes[7]]);if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "ReadRemoteVersionInformationComplete".to_string(),    field: "sub_version".to_string(),    wanted: 10,    got: bytes.len()});}let sub_version = u16::from_le_bytes([bytes[8],bytes[9]]);Ok(Self {status, connection_handle, version, manufacturer_name, sub_version, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[2..3].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let version = self.version;buffer[5..6].copy_from_slice(&version.to_le_bytes()[0..1]);let manufacturer_name = self.manufacturer_name;buffer[6..8].copy_from_slice(&manufacturer_name.to_le_bytes()[0..2]);let sub_version = self.sub_version;buffer[8..10].copy_from_slice(&sub_version.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 8;ret}
}
impl Packet for ReadRemoteVersionInformationCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadRemoteVersionInformationCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let read_remote_version_information_complete = match &event.child {EventDataChild::ReadRemoteVersionInformationComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadRemoteVersionInformationComplete"),};Self {event,read_remote_version_information_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.read_remote_version_information_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.read_remote_version_information_complete.as_ref().connection_handle}
pub fn get_version(&self) -> u8{ self.read_remote_version_information_complete.as_ref().version}
pub fn get_manufacturer_name(&self) -> u16{ self.read_remote_version_information_complete.as_ref().manufacturer_name}
pub fn get_sub_version(&self) -> u16{ self.read_remote_version_information_complete.as_ref().sub_version}
}
impl Into<EventPacket> for ReadRemoteVersionInformationCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl ReadRemoteVersionInformationCompleteBuilder {pub fn build(self) -> ReadRemoteVersionInformationCompletePacket {let read_remote_version_information_complete= Arc::new(ReadRemoteVersionInformationCompleteData {status: self.status, connection_handle: self.connection_handle, version: self.version, manufacturer_name: self.manufacturer_name, sub_version: self.sub_version, });let event= Arc::new(EventData {event_code: EventCode::ReadRemoteVersionInformationComplete, child: EventDataChild::ReadRemoteVersionInformationComplete(read_remote_version_information_complete),});ReadRemoteVersionInformationCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadRemoteVersionInformationCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct QosSetupCompleteData {status: ErrorCode, connection_handle: u16, service_type: ServiceType, token_rate: u32, peak_bandwidth: u32, latency: u32, delay_variation: u32, }
#[derive(Debug, Clone)] pub struct QosSetupCompletePacket {event: Arc<EventData>,qos_setup_complete: Arc<QosSetupCompleteData>,}
#[derive(Debug)] pub struct QosSetupCompleteBuilder {pub status: ErrorCode, pub connection_handle: u16, pub service_type: ServiceType, pub token_rate: u32, pub peak_bandwidth: u32, pub latency: u32, pub delay_variation: u32, }
impl QosSetupCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "QosSetupComplete".to_string(),    field: "status".to_string(),    wanted: 3,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[2]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "QosSetupComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "QosSetupComplete".to_string(),    field: "service_type".to_string(),    wanted: 7,    got: bytes.len()});}let service_type = u8::from_le_bytes([bytes[6]]);let service_type = ServiceType::from_u8(service_type).unwrap();if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "QosSetupComplete".to_string(),    field: "token_rate".to_string(),    wanted: 11,    got: bytes.len()});}let token_rate = u32::from_le_bytes([bytes[7],bytes[8],bytes[9],bytes[10]]);if bytes.len() < 15 { return Err(Error::InvalidLengthError{    obj: "QosSetupComplete".to_string(),    field: "peak_bandwidth".to_string(),    wanted: 15,    got: bytes.len()});}let peak_bandwidth = u32::from_le_bytes([bytes[11],bytes[12],bytes[13],bytes[14]]);if bytes.len() < 19 { return Err(Error::InvalidLengthError{    obj: "QosSetupComplete".to_string(),    field: "latency".to_string(),    wanted: 19,    got: bytes.len()});}let latency = u32::from_le_bytes([bytes[15],bytes[16],bytes[17],bytes[18]]);if bytes.len() < 23 { return Err(Error::InvalidLengthError{    obj: "QosSetupComplete".to_string(),    field: "delay_variation".to_string(),    wanted: 23,    got: bytes.len()});}let delay_variation = u32::from_le_bytes([bytes[19],bytes[20],bytes[21],bytes[22]]);Ok(Self {status, connection_handle, service_type, token_rate, peak_bandwidth, latency, delay_variation, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[2..3].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let service_type = self.service_type.to_u8().unwrap();buffer[6..7].copy_from_slice(&service_type.to_le_bytes()[0..1]);let token_rate = self.token_rate;buffer[7..11].copy_from_slice(&token_rate.to_le_bytes()[0..4]);let peak_bandwidth = self.peak_bandwidth;buffer[11..15].copy_from_slice(&peak_bandwidth.to_le_bytes()[0..4]);let latency = self.latency;buffer[15..19].copy_from_slice(&latency.to_le_bytes()[0..4]);let delay_variation = self.delay_variation;buffer[19..23].copy_from_slice(&delay_variation.to_le_bytes()[0..4]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 21;ret}
}
impl Packet for QosSetupCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl QosSetupCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let qos_setup_complete = match &event.child {EventDataChild::QosSetupComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not QosSetupComplete"),};Self {event,qos_setup_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.qos_setup_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.qos_setup_complete.as_ref().connection_handle}
pub fn get_service_type(&self) -> ServiceType{ self.qos_setup_complete.as_ref().service_type}
pub fn get_token_rate(&self) -> u32{ self.qos_setup_complete.as_ref().token_rate}
pub fn get_peak_bandwidth(&self) -> u32{ self.qos_setup_complete.as_ref().peak_bandwidth}
pub fn get_latency(&self) -> u32{ self.qos_setup_complete.as_ref().latency}
pub fn get_delay_variation(&self) -> u32{ self.qos_setup_complete.as_ref().delay_variation}
}
impl Into<EventPacket> for QosSetupCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl QosSetupCompleteBuilder {pub fn build(self) -> QosSetupCompletePacket {let qos_setup_complete= Arc::new(QosSetupCompleteData {status: self.status, connection_handle: self.connection_handle, service_type: self.service_type, token_rate: self.token_rate, peak_bandwidth: self.peak_bandwidth, latency: self.latency, delay_variation: self.delay_variation, });let event= Arc::new(EventData {event_code: EventCode::QosSetupComplete, child: EventDataChild::QosSetupComplete(qos_setup_complete),});QosSetupCompletePacket::new(event)}
}
impl Into<EventPacket> for QosSetupCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct HardwareErrorData {hardware_code: u8, }
#[derive(Debug, Clone)] pub struct HardwareErrorPacket {event: Arc<EventData>,hardware_error: Arc<HardwareErrorData>,}
#[derive(Debug)] pub struct HardwareErrorBuilder {pub hardware_code: u8, }
impl HardwareErrorData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "HardwareError".to_string(),    field: "hardware_code".to_string(),    wanted: 3,    got: bytes.len()});}let hardware_code = u8::from_le_bytes([bytes[2]]);Ok(Self {hardware_code, })
}
fn write_to(&self, buffer: &mut BytesMut) {let hardware_code = self.hardware_code;buffer[2..3].copy_from_slice(&hardware_code.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for HardwareErrorPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl HardwareErrorPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let hardware_error = match &event.child {EventDataChild::HardwareError(value) => (*value).clone(),_ => panic!("inconsistent state - child was not HardwareError"),};Self {event,hardware_error,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_hardware_code(&self) -> u8{ self.hardware_error.as_ref().hardware_code}
}
impl Into<EventPacket> for HardwareErrorPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl HardwareErrorBuilder {pub fn build(self) -> HardwareErrorPacket {let hardware_error= Arc::new(HardwareErrorData {hardware_code: self.hardware_code, });let event= Arc::new(EventData {event_code: EventCode::HardwareError, child: EventDataChild::HardwareError(hardware_error),});HardwareErrorPacket::new(event)}
}
impl Into<EventPacket> for HardwareErrorBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct FlushOccurredData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct FlushOccurredPacket {event: Arc<EventData>,flush_occurred: Arc<FlushOccurredData>,}
#[derive(Debug)] pub struct FlushOccurredBuilder {pub connection_handle: u16, }
impl FlushOccurredData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "FlushOccurred".to_string(),    field: "connection_handle".to_string(),    wanted: 4,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[2],bytes[3]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[2..4].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for FlushOccurredPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl FlushOccurredPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let flush_occurred = match &event.child {EventDataChild::FlushOccurred(value) => (*value).clone(),_ => panic!("inconsistent state - child was not FlushOccurred"),};Self {event,flush_occurred,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_connection_handle(&self) -> u16{ self.flush_occurred.as_ref().connection_handle}
}
impl Into<EventPacket> for FlushOccurredPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl FlushOccurredBuilder {pub fn build(self) -> FlushOccurredPacket {let flush_occurred= Arc::new(FlushOccurredData {connection_handle: self.connection_handle, });let event= Arc::new(EventData {event_code: EventCode::FlushOccurred, child: EventDataChild::FlushOccurred(flush_occurred),});FlushOccurredPacket::new(event)}
}
impl Into<EventPacket> for FlushOccurredBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct RoleChangeData {status: ErrorCode, bd_addr: Address, new_role: Role, }
#[derive(Debug, Clone)] pub struct RoleChangePacket {event: Arc<EventData>,role_change: Arc<RoleChangeData>,}
#[derive(Debug)] pub struct RoleChangeBuilder {pub status: ErrorCode, pub bd_addr: Address, pub new_role: Role, }
impl RoleChangeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "RoleChange".to_string(),    field: "status".to_string(),    wanted: 3,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[2]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "RoleChange".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "RoleChange".to_string(),    field: "new_role".to_string(),    wanted: 10,    got: bytes.len()});}let new_role = u8::from_le_bytes([bytes[9]]);let new_role = Role::from_u8(new_role).unwrap();Ok(Self {status, bd_addr, new_role, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[2..3].copy_from_slice(&status.to_le_bytes()[0..1]);let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);let new_role = self.new_role.to_u8().unwrap();buffer[9..10].copy_from_slice(&new_role.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 8;ret}
}
impl Packet for RoleChangePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl RoleChangePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let role_change = match &event.child {EventDataChild::RoleChange(value) => (*value).clone(),_ => panic!("inconsistent state - child was not RoleChange"),};Self {event,role_change,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.role_change.as_ref().status}
pub fn get_bd_addr(&self) -> Address{ self.role_change.as_ref().bd_addr}
pub fn get_new_role(&self) -> Role{ self.role_change.as_ref().new_role}
}
impl Into<EventPacket> for RoleChangePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl RoleChangeBuilder {pub fn build(self) -> RoleChangePacket {let role_change= Arc::new(RoleChangeData {status: self.status, bd_addr: self.bd_addr, new_role: self.new_role, });let event= Arc::new(EventData {event_code: EventCode::RoleChange, child: EventDataChild::RoleChange(role_change),});RoleChangePacket::new(event)}
}
impl Into<EventPacket> for RoleChangeBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct NumberOfCompletedPacketsData {completed_packets: Vec::<CompletedPackets>, }
#[derive(Debug, Clone)] pub struct NumberOfCompletedPacketsPacket {event: Arc<EventData>,number_of_completed_packets: Arc<NumberOfCompletedPacketsData>,}
#[derive(Debug)] pub struct NumberOfCompletedPacketsBuilder {pub completed_packets: Vec::<CompletedPackets>, }
impl NumberOfCompletedPacketsData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "NumberOfCompletedPackets".to_string(),    field: "completed_packets_count".to_string(),    wanted: 3,    got: bytes.len()});}let completed_packets_count = u8::from_le_bytes([bytes[2]]);let mut completed_packets: Vec::<CompletedPackets> = Vec::new();let mut parsable_ = &bytes[3..];let count_ = completed_packets_count as usize;for _ in 0..count_ { match CompletedPackets::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];completed_packets.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {completed_packets, })
}
fn write_to(&self, buffer: &mut BytesMut) {buffer[2..3].copy_from_slice(&(self.completed_packets.len() as u8).to_le_bytes());let mut vec_buffer_ = &mut buffer[3..];for e_ in &self.completed_packets { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;let ret = ret + (self.completed_packets.len() * ((/* Bits: */ 32 + /* Dynamic: */ 0) / 8));ret}
}
impl Packet for NumberOfCompletedPacketsPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl NumberOfCompletedPacketsPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let number_of_completed_packets = match &event.child {EventDataChild::NumberOfCompletedPackets(value) => (*value).clone(),_ => panic!("inconsistent state - child was not NumberOfCompletedPackets"),};Self {event,number_of_completed_packets,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_completed_packets(&self) -> &Vec::<CompletedPackets>{ &self.number_of_completed_packets.as_ref().completed_packets}
}
impl Into<EventPacket> for NumberOfCompletedPacketsPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl NumberOfCompletedPacketsBuilder {pub fn build(self) -> NumberOfCompletedPacketsPacket {let number_of_completed_packets= Arc::new(NumberOfCompletedPacketsData {completed_packets: self.completed_packets, });let event= Arc::new(EventData {event_code: EventCode::NumberOfCompletedPackets, child: EventDataChild::NumberOfCompletedPackets(number_of_completed_packets),});NumberOfCompletedPacketsPacket::new(event)}
}
impl Into<EventPacket> for NumberOfCompletedPacketsBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct ModeChangeData {status: ErrorCode, connection_handle: u16, current_mode: Mode, interval: u16, }
#[derive(Debug, Clone)] pub struct ModeChangePacket {event: Arc<EventData>,mode_change: Arc<ModeChangeData>,}
#[derive(Debug)] pub struct ModeChangeBuilder {pub status: ErrorCode, pub connection_handle: u16, pub current_mode: Mode, pub interval: u16, }
impl ModeChangeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "ModeChange".to_string(),    field: "status".to_string(),    wanted: 3,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[2]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ModeChange".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ModeChange".to_string(),    field: "current_mode".to_string(),    wanted: 6,    got: bytes.len()});}let current_mode = u8::from_le_bytes([bytes[5]]);let current_mode = Mode::from_u8(current_mode).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "ModeChange".to_string(),    field: "interval".to_string(),    wanted: 8,    got: bytes.len()});}let interval = u16::from_le_bytes([bytes[6],bytes[7]]);Ok(Self {status, connection_handle, current_mode, interval, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[2..3].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let current_mode = self.current_mode.to_u8().unwrap();buffer[5..6].copy_from_slice(&current_mode.to_le_bytes()[0..1]);let interval = self.interval;buffer[6..8].copy_from_slice(&interval.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl Packet for ModeChangePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ModeChangePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let mode_change = match &event.child {EventDataChild::ModeChange(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ModeChange"),};Self {event,mode_change,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.mode_change.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.mode_change.as_ref().connection_handle}
pub fn get_current_mode(&self) -> Mode{ self.mode_change.as_ref().current_mode}
pub fn get_interval(&self) -> u16{ self.mode_change.as_ref().interval}
}
impl Into<EventPacket> for ModeChangePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl ModeChangeBuilder {pub fn build(self) -> ModeChangePacket {let mode_change= Arc::new(ModeChangeData {status: self.status, connection_handle: self.connection_handle, current_mode: self.current_mode, interval: self.interval, });let event= Arc::new(EventData {event_code: EventCode::ModeChange, child: EventDataChild::ModeChange(mode_change),});ModeChangePacket::new(event)}
}
impl Into<EventPacket> for ModeChangeBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct ReturnLinkKeysData {keys: Vec::<ZeroKeyAndAddress>, }
#[derive(Debug, Clone)] pub struct ReturnLinkKeysPacket {event: Arc<EventData>,return_link_keys: Arc<ReturnLinkKeysData>,}
#[derive(Debug)] pub struct ReturnLinkKeysBuilder {pub keys: Vec::<ZeroKeyAndAddress>, }
impl ReturnLinkKeysData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "ReturnLinkKeys".to_string(),    field: "keys_count".to_string(),    wanted: 3,    got: bytes.len()});}let keys_count = u8::from_le_bytes([bytes[2]]);let mut keys: Vec::<ZeroKeyAndAddress> = Vec::new();let mut parsable_ = &bytes[3..];let count_ = keys_count as usize;for _ in 0..count_ { match ZeroKeyAndAddress::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];keys.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {keys, })
}
fn write_to(&self, buffer: &mut BytesMut) {buffer[2..3].copy_from_slice(&(self.keys.len() as u8).to_le_bytes());let mut vec_buffer_ = &mut buffer[3..];for e_ in &self.keys { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;let ret = ret + (self.keys.len() * ((/* Bits: */ 176 + /* Dynamic: */ 0) / 8));ret}
}
impl Packet for ReturnLinkKeysPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReturnLinkKeysPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let return_link_keys = match &event.child {EventDataChild::ReturnLinkKeys(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReturnLinkKeys"),};Self {event,return_link_keys,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_keys(&self) -> &Vec::<ZeroKeyAndAddress>{ &self.return_link_keys.as_ref().keys}
}
impl Into<EventPacket> for ReturnLinkKeysPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl ReturnLinkKeysBuilder {pub fn build(self) -> ReturnLinkKeysPacket {let return_link_keys= Arc::new(ReturnLinkKeysData {keys: self.keys, });let event= Arc::new(EventData {event_code: EventCode::ReturnLinkKeys, child: EventDataChild::ReturnLinkKeys(return_link_keys),});ReturnLinkKeysPacket::new(event)}
}
impl Into<EventPacket> for ReturnLinkKeysBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct PinCodeRequestData {bd_addr: Address, }
#[derive(Debug, Clone)] pub struct PinCodeRequestPacket {event: Arc<EventData>,pin_code_request: Arc<PinCodeRequestData>,}
#[derive(Debug)] pub struct PinCodeRequestBuilder {pub bd_addr: Address, }
impl PinCodeRequestData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "PinCodeRequest".to_string(),    field: "bd_addr".to_string(),    wanted: 8,    got: bytes.len()});}let bd_addr = bytes[2..8].try_into().unwrap();Ok(Self {bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[2..8].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl Packet for PinCodeRequestPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl PinCodeRequestPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let pin_code_request = match &event.child {EventDataChild::PinCodeRequest(value) => (*value).clone(),_ => panic!("inconsistent state - child was not PinCodeRequest"),};Self {event,pin_code_request,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_bd_addr(&self) -> Address{ self.pin_code_request.as_ref().bd_addr}
}
impl Into<EventPacket> for PinCodeRequestPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl PinCodeRequestBuilder {pub fn build(self) -> PinCodeRequestPacket {let pin_code_request= Arc::new(PinCodeRequestData {bd_addr: self.bd_addr, });let event= Arc::new(EventData {event_code: EventCode::PinCodeRequest, child: EventDataChild::PinCodeRequest(pin_code_request),});PinCodeRequestPacket::new(event)}
}
impl Into<EventPacket> for PinCodeRequestBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct LinkKeyRequestData {bd_addr: Address, }
#[derive(Debug, Clone)] pub struct LinkKeyRequestPacket {event: Arc<EventData>,link_key_request: Arc<LinkKeyRequestData>,}
#[derive(Debug)] pub struct LinkKeyRequestBuilder {pub bd_addr: Address, }
impl LinkKeyRequestData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LinkKeyRequest".to_string(),    field: "bd_addr".to_string(),    wanted: 8,    got: bytes.len()});}let bd_addr = bytes[2..8].try_into().unwrap();Ok(Self {bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[2..8].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl Packet for LinkKeyRequestPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LinkKeyRequestPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let link_key_request = match &event.child {EventDataChild::LinkKeyRequest(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LinkKeyRequest"),};Self {event,link_key_request,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_bd_addr(&self) -> Address{ self.link_key_request.as_ref().bd_addr}
}
impl Into<EventPacket> for LinkKeyRequestPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl LinkKeyRequestBuilder {pub fn build(self) -> LinkKeyRequestPacket {let link_key_request= Arc::new(LinkKeyRequestData {bd_addr: self.bd_addr, });let event= Arc::new(EventData {event_code: EventCode::LinkKeyRequest, child: EventDataChild::LinkKeyRequest(link_key_request),});LinkKeyRequestPacket::new(event)}
}
impl Into<EventPacket> for LinkKeyRequestBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct LinkKeyNotificationData {bd_addr: Address, link_key: [u8; 16], key_type: KeyType, }
#[derive(Debug, Clone)] pub struct LinkKeyNotificationPacket {event: Arc<EventData>,link_key_notification: Arc<LinkKeyNotificationData>,}
#[derive(Debug)] pub struct LinkKeyNotificationBuilder {pub bd_addr: Address, pub link_key: [u8; 16], pub key_type: KeyType, }
impl LinkKeyNotificationData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LinkKeyNotification".to_string(),    field: "bd_addr".to_string(),    wanted: 8,    got: bytes.len()});}let bd_addr = bytes[2..8].try_into().unwrap();if bytes.len() < 24 { return Err(Error::InvalidLengthError{    obj: "LinkKeyNotification".to_string(),    field: "link_key".to_string(),    wanted: 24,    got: bytes.len()});}let link_key = bytes[8..24].try_into().unwrap();if bytes.len() < 25 { return Err(Error::InvalidLengthError{    obj: "LinkKeyNotification".to_string(),    field: "key_type".to_string(),    wanted: 25,    got: bytes.len()});}let key_type = u8::from_le_bytes([bytes[24]]);let key_type = KeyType::from_u8(key_type).unwrap();Ok(Self {bd_addr, link_key, key_type, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[2..8].copy_from_slice(&bd_addr);&buffer[8..24].copy_from_slice(&self.link_key);let key_type = self.key_type.to_u8().unwrap();buffer[24..25].copy_from_slice(&key_type.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 23;ret}
}
impl Packet for LinkKeyNotificationPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LinkKeyNotificationPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let link_key_notification = match &event.child {EventDataChild::LinkKeyNotification(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LinkKeyNotification"),};Self {event,link_key_notification,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_bd_addr(&self) -> Address{ self.link_key_notification.as_ref().bd_addr}
pub fn get_link_key(&self) -> &[u8; 16]{ &self.link_key_notification.as_ref().link_key}
pub fn get_key_type(&self) -> KeyType{ self.link_key_notification.as_ref().key_type}
}
impl Into<EventPacket> for LinkKeyNotificationPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl LinkKeyNotificationBuilder {pub fn build(self) -> LinkKeyNotificationPacket {let link_key_notification= Arc::new(LinkKeyNotificationData {bd_addr: self.bd_addr, link_key: self.link_key, key_type: self.key_type, });let event= Arc::new(EventData {event_code: EventCode::LinkKeyNotification, child: EventDataChild::LinkKeyNotification(link_key_notification),});LinkKeyNotificationPacket::new(event)}
}
impl Into<EventPacket> for LinkKeyNotificationBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] enum LoopbackCommandDataChild {Payload(Bytes),None,}
impl LoopbackCommandDataChild {fn get_total_size(&self) -> usize {match self {LoopbackCommandDataChild::Payload(p) => p.len(),LoopbackCommandDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LoopbackCommandChild {Payload(Bytes),None,}
#[derive(Debug)] struct LoopbackCommandData {child: LoopbackCommandDataChild,}
#[derive(Debug, Clone)] pub struct LoopbackCommandPacket {event: Arc<EventData>,loopback_command: Arc<LoopbackCommandData>,}
#[derive(Debug)] pub struct LoopbackCommandBuilder {pub payload: Option<Bytes>,}
impl LoopbackCommandData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {let payload: Vec::<u8> = bytes[2..].into();let child = if payload.len() > 0 {LoopbackCommandDataChild::Payload(Bytes::from(payload))} else {LoopbackCommandDataChild::None};Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {LoopbackCommandDataChild::Payload(p) => buffer[2..].copy_from_slice(&p[..]),LoopbackCommandDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LoopbackCommandPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LoopbackCommandPacket { pub fn specialize(&self) -> LoopbackCommandChild { match &self.loopback_command.child {LoopbackCommandDataChild::Payload(p) => LoopbackCommandChild::Payload(p.clone()),LoopbackCommandDataChild::None => LoopbackCommandChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let loopback_command = match &event.child {EventDataChild::LoopbackCommand(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LoopbackCommand"),};Self {event,loopback_command,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
}
impl Into<EventPacket> for LoopbackCommandPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl LoopbackCommandBuilder {pub fn build(self) -> LoopbackCommandPacket {let loopback_command= Arc::new(LoopbackCommandData {child: match self.payload { None => LoopbackCommandDataChild::None,Some(bytes) => LoopbackCommandDataChild::Payload(bytes),},});let event= Arc::new(EventData {event_code: EventCode::LoopbackCommand, child: EventDataChild::LoopbackCommand(loopback_command),});LoopbackCommandPacket::new(event)}
}
impl Into<EventPacket> for LoopbackCommandBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct DataBufferOverflowData {link_type: LinkType, }
#[derive(Debug, Clone)] pub struct DataBufferOverflowPacket {event: Arc<EventData>,data_buffer_overflow: Arc<DataBufferOverflowData>,}
#[derive(Debug)] pub struct DataBufferOverflowBuilder {pub link_type: LinkType, }
impl DataBufferOverflowData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "DataBufferOverflow".to_string(),    field: "link_type".to_string(),    wanted: 3,    got: bytes.len()});}let link_type = u8::from_le_bytes([bytes[2]]);let link_type = LinkType::from_u8(link_type).unwrap();Ok(Self {link_type, })
}
fn write_to(&self, buffer: &mut BytesMut) {let link_type = self.link_type.to_u8().unwrap();buffer[2..3].copy_from_slice(&link_type.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for DataBufferOverflowPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl DataBufferOverflowPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let data_buffer_overflow = match &event.child {EventDataChild::DataBufferOverflow(value) => (*value).clone(),_ => panic!("inconsistent state - child was not DataBufferOverflow"),};Self {event,data_buffer_overflow,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_link_type(&self) -> LinkType{ self.data_buffer_overflow.as_ref().link_type}
}
impl Into<EventPacket> for DataBufferOverflowPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl DataBufferOverflowBuilder {pub fn build(self) -> DataBufferOverflowPacket {let data_buffer_overflow= Arc::new(DataBufferOverflowData {link_type: self.link_type, });let event= Arc::new(EventData {event_code: EventCode::DataBufferOverflow, child: EventDataChild::DataBufferOverflow(data_buffer_overflow),});DataBufferOverflowPacket::new(event)}
}
impl Into<EventPacket> for DataBufferOverflowBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct MaxSlotsChangeData {connection_handle: u16, lmp_max_slots: u8, }
#[derive(Debug, Clone)] pub struct MaxSlotsChangePacket {event: Arc<EventData>,max_slots_change: Arc<MaxSlotsChangeData>,}
#[derive(Debug)] pub struct MaxSlotsChangeBuilder {pub connection_handle: u16, pub lmp_max_slots: u8, }
impl MaxSlotsChangeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "MaxSlotsChange".to_string(),    field: "connection_handle".to_string(),    wanted: 4,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[2],bytes[3]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "MaxSlotsChange".to_string(),    field: "lmp_max_slots".to_string(),    wanted: 5,    got: bytes.len()});}let lmp_max_slots = u8::from_le_bytes([bytes[4]]);Ok(Self {connection_handle, lmp_max_slots, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[2..4].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let lmp_max_slots = self.lmp_max_slots;buffer[4..5].copy_from_slice(&lmp_max_slots.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for MaxSlotsChangePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl MaxSlotsChangePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let max_slots_change = match &event.child {EventDataChild::MaxSlotsChange(value) => (*value).clone(),_ => panic!("inconsistent state - child was not MaxSlotsChange"),};Self {event,max_slots_change,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_connection_handle(&self) -> u16{ self.max_slots_change.as_ref().connection_handle}
pub fn get_lmp_max_slots(&self) -> u8{ self.max_slots_change.as_ref().lmp_max_slots}
}
impl Into<EventPacket> for MaxSlotsChangePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl MaxSlotsChangeBuilder {pub fn build(self) -> MaxSlotsChangePacket {let max_slots_change= Arc::new(MaxSlotsChangeData {connection_handle: self.connection_handle, lmp_max_slots: self.lmp_max_slots, });let event= Arc::new(EventData {event_code: EventCode::MaxSlotsChange, child: EventDataChild::MaxSlotsChange(max_slots_change),});MaxSlotsChangePacket::new(event)}
}
impl Into<EventPacket> for MaxSlotsChangeBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct ReadClockOffsetCompleteData {status: ErrorCode, connection_handle: u16, clock_offset: u16, }
#[derive(Debug, Clone)] pub struct ReadClockOffsetCompletePacket {event: Arc<EventData>,read_clock_offset_complete: Arc<ReadClockOffsetCompleteData>,}
#[derive(Debug)] pub struct ReadClockOffsetCompleteBuilder {pub status: ErrorCode, pub connection_handle: u16, pub clock_offset: u16, }
impl ReadClockOffsetCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "ReadClockOffsetComplete".to_string(),    field: "status".to_string(),    wanted: 3,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[2]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ReadClockOffsetComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ReadClockOffsetComplete".to_string(),    field: "clock_offset".to_string(),    wanted: 7,    got: bytes.len()});}let clock_offset = u16::from_le_bytes([bytes[5],bytes[6]]);let clock_offset = clock_offset & 0x7fff;Ok(Self {status, connection_handle, clock_offset, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[2..3].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let clock_offset = self.clock_offset;let clock_offset = clock_offset & 0x7fff;buffer[5..7].copy_from_slice(&clock_offset.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 5;ret}
}
impl Packet for ReadClockOffsetCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadClockOffsetCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let read_clock_offset_complete = match &event.child {EventDataChild::ReadClockOffsetComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadClockOffsetComplete"),};Self {event,read_clock_offset_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.read_clock_offset_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.read_clock_offset_complete.as_ref().connection_handle}
pub fn get_clock_offset(&self) -> u16{ self.read_clock_offset_complete.as_ref().clock_offset}
}
impl Into<EventPacket> for ReadClockOffsetCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl ReadClockOffsetCompleteBuilder {pub fn build(self) -> ReadClockOffsetCompletePacket {let read_clock_offset_complete= Arc::new(ReadClockOffsetCompleteData {status: self.status, connection_handle: self.connection_handle, clock_offset: self.clock_offset, });let event= Arc::new(EventData {event_code: EventCode::ReadClockOffsetComplete, child: EventDataChild::ReadClockOffsetComplete(read_clock_offset_complete),});ReadClockOffsetCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadClockOffsetCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct ConnectionPacketTypeChangedData {status: ErrorCode, connection_handle: u16, packet_type: u16, }
#[derive(Debug, Clone)] pub struct ConnectionPacketTypeChangedPacket {event: Arc<EventData>,connection_packet_type_changed: Arc<ConnectionPacketTypeChangedData>,}
#[derive(Debug)] pub struct ConnectionPacketTypeChangedBuilder {pub status: ErrorCode, pub connection_handle: u16, pub packet_type: u16, }
impl ConnectionPacketTypeChangedData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "ConnectionPacketTypeChanged".to_string(),    field: "status".to_string(),    wanted: 3,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[2]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ConnectionPacketTypeChanged".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ConnectionPacketTypeChanged".to_string(),    field: "packet_type".to_string(),    wanted: 7,    got: bytes.len()});}let packet_type = u16::from_le_bytes([bytes[5],bytes[6]]);Ok(Self {status, connection_handle, packet_type, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[2..3].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let packet_type = self.packet_type;buffer[5..7].copy_from_slice(&packet_type.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 5;ret}
}
impl Packet for ConnectionPacketTypeChangedPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ConnectionPacketTypeChangedPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let connection_packet_type_changed = match &event.child {EventDataChild::ConnectionPacketTypeChanged(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ConnectionPacketTypeChanged"),};Self {event,connection_packet_type_changed,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.connection_packet_type_changed.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.connection_packet_type_changed.as_ref().connection_handle}
pub fn get_packet_type(&self) -> u16{ self.connection_packet_type_changed.as_ref().packet_type}
}
impl Into<EventPacket> for ConnectionPacketTypeChangedPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl ConnectionPacketTypeChangedBuilder {pub fn build(self) -> ConnectionPacketTypeChangedPacket {let connection_packet_type_changed= Arc::new(ConnectionPacketTypeChangedData {status: self.status, connection_handle: self.connection_handle, packet_type: self.packet_type, });let event= Arc::new(EventData {event_code: EventCode::ConnectionPacketTypeChanged, child: EventDataChild::ConnectionPacketTypeChanged(connection_packet_type_changed),});ConnectionPacketTypeChangedPacket::new(event)}
}
impl Into<EventPacket> for ConnectionPacketTypeChangedBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct QosViolationData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct QosViolationPacket {event: Arc<EventData>,qos_violation: Arc<QosViolationData>,}
#[derive(Debug)] pub struct QosViolationBuilder {pub connection_handle: u16, }
impl QosViolationData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "QosViolation".to_string(),    field: "connection_handle".to_string(),    wanted: 4,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[2],bytes[3]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[2..4].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for QosViolationPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl QosViolationPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let qos_violation = match &event.child {EventDataChild::QosViolation(value) => (*value).clone(),_ => panic!("inconsistent state - child was not QosViolation"),};Self {event,qos_violation,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_connection_handle(&self) -> u16{ self.qos_violation.as_ref().connection_handle}
}
impl Into<EventPacket> for QosViolationPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl QosViolationBuilder {pub fn build(self) -> QosViolationPacket {let qos_violation= Arc::new(QosViolationData {connection_handle: self.connection_handle, });let event= Arc::new(EventData {event_code: EventCode::QosViolation, child: EventDataChild::QosViolation(qos_violation),});QosViolationPacket::new(event)}
}
impl Into<EventPacket> for QosViolationBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct PageScanRepetitionModeChangeData {bd_addr: Address, page_scan_repetition_mode: PageScanRepetitionMode, }
#[derive(Debug, Clone)] pub struct PageScanRepetitionModeChangePacket {event: Arc<EventData>,page_scan_repetition_mode_change: Arc<PageScanRepetitionModeChangeData>,}
#[derive(Debug)] pub struct PageScanRepetitionModeChangeBuilder {pub bd_addr: Address, pub page_scan_repetition_mode: PageScanRepetitionMode, }
impl PageScanRepetitionModeChangeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "PageScanRepetitionModeChange".to_string(),    field: "bd_addr".to_string(),    wanted: 8,    got: bytes.len()});}let bd_addr = bytes[2..8].try_into().unwrap();if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "PageScanRepetitionModeChange".to_string(),    field: "page_scan_repetition_mode".to_string(),    wanted: 9,    got: bytes.len()});}let page_scan_repetition_mode = u8::from_le_bytes([bytes[8]]);let page_scan_repetition_mode = PageScanRepetitionMode::from_u8(page_scan_repetition_mode).unwrap();Ok(Self {bd_addr, page_scan_repetition_mode, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[2..8].copy_from_slice(&bd_addr);let page_scan_repetition_mode = self.page_scan_repetition_mode.to_u8().unwrap();buffer[8..9].copy_from_slice(&page_scan_repetition_mode.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for PageScanRepetitionModeChangePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl PageScanRepetitionModeChangePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let page_scan_repetition_mode_change = match &event.child {EventDataChild::PageScanRepetitionModeChange(value) => (*value).clone(),_ => panic!("inconsistent state - child was not PageScanRepetitionModeChange"),};Self {event,page_scan_repetition_mode_change,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_bd_addr(&self) -> Address{ self.page_scan_repetition_mode_change.as_ref().bd_addr}
pub fn get_page_scan_repetition_mode(&self) -> PageScanRepetitionMode{ self.page_scan_repetition_mode_change.as_ref().page_scan_repetition_mode}
}
impl Into<EventPacket> for PageScanRepetitionModeChangePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl PageScanRepetitionModeChangeBuilder {pub fn build(self) -> PageScanRepetitionModeChangePacket {let page_scan_repetition_mode_change= Arc::new(PageScanRepetitionModeChangeData {bd_addr: self.bd_addr, page_scan_repetition_mode: self.page_scan_repetition_mode, });let event= Arc::new(EventData {event_code: EventCode::PageScanRepetitionModeChange, child: EventDataChild::PageScanRepetitionModeChange(page_scan_repetition_mode_change),});PageScanRepetitionModeChangePacket::new(event)}
}
impl Into<EventPacket> for PageScanRepetitionModeChangeBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct FlowSpecificationCompleteData {status: ErrorCode, connection_handle: u16, flow_direction: FlowDirection, service_type: ServiceType, token_rate: u32, token_bucket_size: u32, peak_bandwidth: u32, access_latency: u32, }
#[derive(Debug, Clone)] pub struct FlowSpecificationCompletePacket {event: Arc<EventData>,flow_specification_complete: Arc<FlowSpecificationCompleteData>,}
#[derive(Debug)] pub struct FlowSpecificationCompleteBuilder {pub status: ErrorCode, pub connection_handle: u16, pub flow_direction: FlowDirection, pub service_type: ServiceType, pub token_rate: u32, pub token_bucket_size: u32, pub peak_bandwidth: u32, pub access_latency: u32, }
impl FlowSpecificationCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "FlowSpecificationComplete".to_string(),    field: "status".to_string(),    wanted: 3,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[2]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "FlowSpecificationComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "FlowSpecificationComplete".to_string(),    field: "flow_direction".to_string(),    wanted: 7,    got: bytes.len()});}let flow_direction = u8::from_le_bytes([bytes[6]]);let flow_direction = FlowDirection::from_u8(flow_direction).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "FlowSpecificationComplete".to_string(),    field: "service_type".to_string(),    wanted: 8,    got: bytes.len()});}let service_type = u8::from_le_bytes([bytes[7]]);let service_type = ServiceType::from_u8(service_type).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "FlowSpecificationComplete".to_string(),    field: "token_rate".to_string(),    wanted: 12,    got: bytes.len()});}let token_rate = u32::from_le_bytes([bytes[8],bytes[9],bytes[10],bytes[11]]);if bytes.len() < 16 { return Err(Error::InvalidLengthError{    obj: "FlowSpecificationComplete".to_string(),    field: "token_bucket_size".to_string(),    wanted: 16,    got: bytes.len()});}let token_bucket_size = u32::from_le_bytes([bytes[12],bytes[13],bytes[14],bytes[15]]);if bytes.len() < 20 { return Err(Error::InvalidLengthError{    obj: "FlowSpecificationComplete".to_string(),    field: "peak_bandwidth".to_string(),    wanted: 20,    got: bytes.len()});}let peak_bandwidth = u32::from_le_bytes([bytes[16],bytes[17],bytes[18],bytes[19]]);if bytes.len() < 24 { return Err(Error::InvalidLengthError{    obj: "FlowSpecificationComplete".to_string(),    field: "access_latency".to_string(),    wanted: 24,    got: bytes.len()});}let access_latency = u32::from_le_bytes([bytes[20],bytes[21],bytes[22],bytes[23]]);Ok(Self {status, connection_handle, flow_direction, service_type, token_rate, token_bucket_size, peak_bandwidth, access_latency, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[2..3].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let flow_direction = self.flow_direction.to_u8().unwrap();buffer[6..7].copy_from_slice(&flow_direction.to_le_bytes()[0..1]);let service_type = self.service_type.to_u8().unwrap();buffer[7..8].copy_from_slice(&service_type.to_le_bytes()[0..1]);let token_rate = self.token_rate;buffer[8..12].copy_from_slice(&token_rate.to_le_bytes()[0..4]);let token_bucket_size = self.token_bucket_size;buffer[12..16].copy_from_slice(&token_bucket_size.to_le_bytes()[0..4]);let peak_bandwidth = self.peak_bandwidth;buffer[16..20].copy_from_slice(&peak_bandwidth.to_le_bytes()[0..4]);let access_latency = self.access_latency;buffer[20..24].copy_from_slice(&access_latency.to_le_bytes()[0..4]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 22;ret}
}
impl Packet for FlowSpecificationCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl FlowSpecificationCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let flow_specification_complete = match &event.child {EventDataChild::FlowSpecificationComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not FlowSpecificationComplete"),};Self {event,flow_specification_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.flow_specification_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.flow_specification_complete.as_ref().connection_handle}
pub fn get_flow_direction(&self) -> FlowDirection{ self.flow_specification_complete.as_ref().flow_direction}
pub fn get_service_type(&self) -> ServiceType{ self.flow_specification_complete.as_ref().service_type}
pub fn get_token_rate(&self) -> u32{ self.flow_specification_complete.as_ref().token_rate}
pub fn get_token_bucket_size(&self) -> u32{ self.flow_specification_complete.as_ref().token_bucket_size}
pub fn get_peak_bandwidth(&self) -> u32{ self.flow_specification_complete.as_ref().peak_bandwidth}
pub fn get_access_latency(&self) -> u32{ self.flow_specification_complete.as_ref().access_latency}
}
impl Into<EventPacket> for FlowSpecificationCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl FlowSpecificationCompleteBuilder {pub fn build(self) -> FlowSpecificationCompletePacket {let flow_specification_complete= Arc::new(FlowSpecificationCompleteData {status: self.status, connection_handle: self.connection_handle, flow_direction: self.flow_direction, service_type: self.service_type, token_rate: self.token_rate, token_bucket_size: self.token_bucket_size, peak_bandwidth: self.peak_bandwidth, access_latency: self.access_latency, });let event= Arc::new(EventData {event_code: EventCode::FlowSpecificationComplete, child: EventDataChild::FlowSpecificationComplete(flow_specification_complete),});FlowSpecificationCompletePacket::new(event)}
}
impl Into<EventPacket> for FlowSpecificationCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct InquiryResultWithRssiData {inquiry_results: Vec::<InquiryResultWithRssi>, }
#[derive(Debug, Clone)] pub struct InquiryResultWithRssiPacket {event: Arc<EventData>,inquiry_result_with_rssi: Arc<InquiryResultWithRssiData>,}
#[derive(Debug)] pub struct InquiryResultWithRssiBuilder {pub inquiry_results: Vec::<InquiryResultWithRssi>, }
impl InquiryResultWithRssiData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "InquiryResultWithRssi".to_string(),    field: "inquiry_results_count".to_string(),    wanted: 3,    got: bytes.len()});}let inquiry_results_count = u8::from_le_bytes([bytes[2]]);let mut inquiry_results: Vec::<InquiryResultWithRssi> = Vec::new();let mut parsable_ = &bytes[3..];let count_ = inquiry_results_count as usize;for _ in 0..count_ { match InquiryResultWithRssi::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];inquiry_results.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {inquiry_results, })
}
fn write_to(&self, buffer: &mut BytesMut) {buffer[2..3].copy_from_slice(&(self.inquiry_results.len() as u8).to_le_bytes());let mut vec_buffer_ = &mut buffer[3..];for e_ in &self.inquiry_results { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;let ret = ret + (self.inquiry_results.len() * ((/* Bits: */ 112 + /* Dynamic: */ 0) / 8));ret}
}
impl Packet for InquiryResultWithRssiPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl InquiryResultWithRssiPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let inquiry_result_with_rssi = match &event.child {EventDataChild::InquiryResultWithRssi(value) => (*value).clone(),_ => panic!("inconsistent state - child was not InquiryResultWithRssi"),};Self {event,inquiry_result_with_rssi,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_inquiry_results(&self) -> &Vec::<InquiryResultWithRssi>{ &self.inquiry_result_with_rssi.as_ref().inquiry_results}
}
impl Into<EventPacket> for InquiryResultWithRssiPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl InquiryResultWithRssiBuilder {pub fn build(self) -> InquiryResultWithRssiPacket {let inquiry_result_with_rssi= Arc::new(InquiryResultWithRssiData {inquiry_results: self.inquiry_results, });let event= Arc::new(EventData {event_code: EventCode::InquiryResultWithRssi, child: EventDataChild::InquiryResultWithRssi(inquiry_result_with_rssi),});InquiryResultWithRssiPacket::new(event)}
}
impl Into<EventPacket> for InquiryResultWithRssiBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct ReadRemoteExtendedFeaturesCompleteData {status: ErrorCode, connection_handle: u16, page_number: u8, maximum_page_number: u8, extended_lmp_features: u64, }
#[derive(Debug, Clone)] pub struct ReadRemoteExtendedFeaturesCompletePacket {event: Arc<EventData>,read_remote_extended_features_complete: Arc<ReadRemoteExtendedFeaturesCompleteData>,}
#[derive(Debug)] pub struct ReadRemoteExtendedFeaturesCompleteBuilder {pub status: ErrorCode, pub connection_handle: u16, pub page_number: u8, pub maximum_page_number: u8, pub extended_lmp_features: u64, }
impl ReadRemoteExtendedFeaturesCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "ReadRemoteExtendedFeaturesComplete".to_string(),    field: "status".to_string(),    wanted: 3,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[2]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "ReadRemoteExtendedFeaturesComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "ReadRemoteExtendedFeaturesComplete".to_string(),    field: "page_number".to_string(),    wanted: 6,    got: bytes.len()});}let page_number = u8::from_le_bytes([bytes[5]]);if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "ReadRemoteExtendedFeaturesComplete".to_string(),    field: "maximum_page_number".to_string(),    wanted: 7,    got: bytes.len()});}let maximum_page_number = u8::from_le_bytes([bytes[6]]);if bytes.len() < 15 { return Err(Error::InvalidLengthError{    obj: "ReadRemoteExtendedFeaturesComplete".to_string(),    field: "extended_lmp_features".to_string(),    wanted: 15,    got: bytes.len()});}let extended_lmp_features = u64::from_le_bytes([bytes[7],bytes[8],bytes[9],bytes[10],bytes[11],bytes[12],bytes[13],bytes[14]]);Ok(Self {status, connection_handle, page_number, maximum_page_number, extended_lmp_features, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[2..3].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let page_number = self.page_number;buffer[5..6].copy_from_slice(&page_number.to_le_bytes()[0..1]);let maximum_page_number = self.maximum_page_number;buffer[6..7].copy_from_slice(&maximum_page_number.to_le_bytes()[0..1]);let extended_lmp_features = self.extended_lmp_features;buffer[7..15].copy_from_slice(&extended_lmp_features.to_le_bytes()[0..8]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 13;ret}
}
impl Packet for ReadRemoteExtendedFeaturesCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadRemoteExtendedFeaturesCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let read_remote_extended_features_complete = match &event.child {EventDataChild::ReadRemoteExtendedFeaturesComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadRemoteExtendedFeaturesComplete"),};Self {event,read_remote_extended_features_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.read_remote_extended_features_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.read_remote_extended_features_complete.as_ref().connection_handle}
pub fn get_page_number(&self) -> u8{ self.read_remote_extended_features_complete.as_ref().page_number}
pub fn get_maximum_page_number(&self) -> u8{ self.read_remote_extended_features_complete.as_ref().maximum_page_number}
pub fn get_extended_lmp_features(&self) -> u64{ self.read_remote_extended_features_complete.as_ref().extended_lmp_features}
}
impl Into<EventPacket> for ReadRemoteExtendedFeaturesCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl ReadRemoteExtendedFeaturesCompleteBuilder {pub fn build(self) -> ReadRemoteExtendedFeaturesCompletePacket {let read_remote_extended_features_complete= Arc::new(ReadRemoteExtendedFeaturesCompleteData {status: self.status, connection_handle: self.connection_handle, page_number: self.page_number, maximum_page_number: self.maximum_page_number, extended_lmp_features: self.extended_lmp_features, });let event= Arc::new(EventData {event_code: EventCode::ReadRemoteExtendedFeaturesComplete, child: EventDataChild::ReadRemoteExtendedFeaturesComplete(read_remote_extended_features_complete),});ReadRemoteExtendedFeaturesCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadRemoteExtendedFeaturesCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct SynchronousConnectionCompleteData {status: ErrorCode, connection_handle: u16, bd_addr: Address, link_type: ScoLinkType, transmission_interval_slots: u8, retransmission_window_slots: u8, rx_packet_length: u16, tx_packet_length: u16, air_mode: ScoAirMode, }
#[derive(Debug, Clone)] pub struct SynchronousConnectionCompletePacket {event: Arc<EventData>,synchronous_connection_complete: Arc<SynchronousConnectionCompleteData>,}
#[derive(Debug)] pub struct SynchronousConnectionCompleteBuilder {pub status: ErrorCode, pub connection_handle: u16, pub bd_addr: Address, pub link_type: ScoLinkType, pub transmission_interval_slots: u8, pub retransmission_window_slots: u8, pub rx_packet_length: u16, pub tx_packet_length: u16, pub air_mode: ScoAirMode, }
impl SynchronousConnectionCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "SynchronousConnectionComplete".to_string(),    field: "status".to_string(),    wanted: 3,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[2]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "SynchronousConnectionComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "SynchronousConnectionComplete".to_string(),    field: "bd_addr".to_string(),    wanted: 11,    got: bytes.len()});}let bd_addr = bytes[5..11].try_into().unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "SynchronousConnectionComplete".to_string(),    field: "link_type".to_string(),    wanted: 12,    got: bytes.len()});}let link_type = u8::from_le_bytes([bytes[11]]);let link_type = ScoLinkType::from_u8(link_type).unwrap();if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "SynchronousConnectionComplete".to_string(),    field: "transmission_interval_slots".to_string(),    wanted: 13,    got: bytes.len()});}let transmission_interval_slots = u8::from_le_bytes([bytes[12]]);if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "SynchronousConnectionComplete".to_string(),    field: "retransmission_window_slots".to_string(),    wanted: 14,    got: bytes.len()});}let retransmission_window_slots = u8::from_le_bytes([bytes[13]]);if bytes.len() < 16 { return Err(Error::InvalidLengthError{    obj: "SynchronousConnectionComplete".to_string(),    field: "rx_packet_length".to_string(),    wanted: 16,    got: bytes.len()});}let rx_packet_length = u16::from_le_bytes([bytes[14],bytes[15]]);if bytes.len() < 18 { return Err(Error::InvalidLengthError{    obj: "SynchronousConnectionComplete".to_string(),    field: "tx_packet_length".to_string(),    wanted: 18,    got: bytes.len()});}let tx_packet_length = u16::from_le_bytes([bytes[16],bytes[17]]);if bytes.len() < 19 { return Err(Error::InvalidLengthError{    obj: "SynchronousConnectionComplete".to_string(),    field: "air_mode".to_string(),    wanted: 19,    got: bytes.len()});}let air_mode = u8::from_le_bytes([bytes[18]]);let air_mode = ScoAirMode::from_u8(air_mode).unwrap();Ok(Self {status, connection_handle, bd_addr, link_type, transmission_interval_slots, retransmission_window_slots, rx_packet_length, tx_packet_length, air_mode, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[2..3].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let bd_addr: [u8; 6] = self.bd_addr.into();buffer[5..11].copy_from_slice(&bd_addr);let link_type = self.link_type.to_u8().unwrap();buffer[11..12].copy_from_slice(&link_type.to_le_bytes()[0..1]);let transmission_interval_slots = self.transmission_interval_slots;buffer[12..13].copy_from_slice(&transmission_interval_slots.to_le_bytes()[0..1]);let retransmission_window_slots = self.retransmission_window_slots;buffer[13..14].copy_from_slice(&retransmission_window_slots.to_le_bytes()[0..1]);let rx_packet_length = self.rx_packet_length;buffer[14..16].copy_from_slice(&rx_packet_length.to_le_bytes()[0..2]);let tx_packet_length = self.tx_packet_length;buffer[16..18].copy_from_slice(&tx_packet_length.to_le_bytes()[0..2]);let air_mode = self.air_mode.to_u8().unwrap();buffer[18..19].copy_from_slice(&air_mode.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 17;ret}
}
impl Packet for SynchronousConnectionCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SynchronousConnectionCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let synchronous_connection_complete = match &event.child {EventDataChild::SynchronousConnectionComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SynchronousConnectionComplete"),};Self {event,synchronous_connection_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.synchronous_connection_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.synchronous_connection_complete.as_ref().connection_handle}
pub fn get_bd_addr(&self) -> Address{ self.synchronous_connection_complete.as_ref().bd_addr}
pub fn get_link_type(&self) -> ScoLinkType{ self.synchronous_connection_complete.as_ref().link_type}
pub fn get_transmission_interval_slots(&self) -> u8{ self.synchronous_connection_complete.as_ref().transmission_interval_slots}
pub fn get_retransmission_window_slots(&self) -> u8{ self.synchronous_connection_complete.as_ref().retransmission_window_slots}
pub fn get_rx_packet_length(&self) -> u16{ self.synchronous_connection_complete.as_ref().rx_packet_length}
pub fn get_tx_packet_length(&self) -> u16{ self.synchronous_connection_complete.as_ref().tx_packet_length}
pub fn get_air_mode(&self) -> ScoAirMode{ self.synchronous_connection_complete.as_ref().air_mode}
}
impl Into<EventPacket> for SynchronousConnectionCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl SynchronousConnectionCompleteBuilder {pub fn build(self) -> SynchronousConnectionCompletePacket {let synchronous_connection_complete= Arc::new(SynchronousConnectionCompleteData {status: self.status, connection_handle: self.connection_handle, bd_addr: self.bd_addr, link_type: self.link_type, transmission_interval_slots: self.transmission_interval_slots, retransmission_window_slots: self.retransmission_window_slots, rx_packet_length: self.rx_packet_length, tx_packet_length: self.tx_packet_length, air_mode: self.air_mode, });let event= Arc::new(EventData {event_code: EventCode::SynchronousConnectionComplete, child: EventDataChild::SynchronousConnectionComplete(synchronous_connection_complete),});SynchronousConnectionCompletePacket::new(event)}
}
impl Into<EventPacket> for SynchronousConnectionCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct SynchronousConnectionChangedData {status: ErrorCode, connection_handle: u16, transmission_interval_slots: u8, retransmission_window_slots: u8, rx_packet_length: u16, tx_packet_length: u16, }
#[derive(Debug, Clone)] pub struct SynchronousConnectionChangedPacket {event: Arc<EventData>,synchronous_connection_changed: Arc<SynchronousConnectionChangedData>,}
#[derive(Debug)] pub struct SynchronousConnectionChangedBuilder {pub status: ErrorCode, pub connection_handle: u16, pub transmission_interval_slots: u8, pub retransmission_window_slots: u8, pub rx_packet_length: u16, pub tx_packet_length: u16, }
impl SynchronousConnectionChangedData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "SynchronousConnectionChanged".to_string(),    field: "status".to_string(),    wanted: 3,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[2]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "SynchronousConnectionChanged".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "SynchronousConnectionChanged".to_string(),    field: "transmission_interval_slots".to_string(),    wanted: 6,    got: bytes.len()});}let transmission_interval_slots = u8::from_le_bytes([bytes[5]]);if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "SynchronousConnectionChanged".to_string(),    field: "retransmission_window_slots".to_string(),    wanted: 7,    got: bytes.len()});}let retransmission_window_slots = u8::from_le_bytes([bytes[6]]);if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "SynchronousConnectionChanged".to_string(),    field: "rx_packet_length".to_string(),    wanted: 9,    got: bytes.len()});}let rx_packet_length = u16::from_le_bytes([bytes[7],bytes[8]]);if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "SynchronousConnectionChanged".to_string(),    field: "tx_packet_length".to_string(),    wanted: 11,    got: bytes.len()});}let tx_packet_length = u16::from_le_bytes([bytes[9],bytes[10]]);Ok(Self {status, connection_handle, transmission_interval_slots, retransmission_window_slots, rx_packet_length, tx_packet_length, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[2..3].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let transmission_interval_slots = self.transmission_interval_slots;buffer[5..6].copy_from_slice(&transmission_interval_slots.to_le_bytes()[0..1]);let retransmission_window_slots = self.retransmission_window_slots;buffer[6..7].copy_from_slice(&retransmission_window_slots.to_le_bytes()[0..1]);let rx_packet_length = self.rx_packet_length;buffer[7..9].copy_from_slice(&rx_packet_length.to_le_bytes()[0..2]);let tx_packet_length = self.tx_packet_length;buffer[9..11].copy_from_slice(&tx_packet_length.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 9;ret}
}
impl Packet for SynchronousConnectionChangedPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SynchronousConnectionChangedPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let synchronous_connection_changed = match &event.child {EventDataChild::SynchronousConnectionChanged(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SynchronousConnectionChanged"),};Self {event,synchronous_connection_changed,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.synchronous_connection_changed.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.synchronous_connection_changed.as_ref().connection_handle}
pub fn get_transmission_interval_slots(&self) -> u8{ self.synchronous_connection_changed.as_ref().transmission_interval_slots}
pub fn get_retransmission_window_slots(&self) -> u8{ self.synchronous_connection_changed.as_ref().retransmission_window_slots}
pub fn get_rx_packet_length(&self) -> u16{ self.synchronous_connection_changed.as_ref().rx_packet_length}
pub fn get_tx_packet_length(&self) -> u16{ self.synchronous_connection_changed.as_ref().tx_packet_length}
}
impl Into<EventPacket> for SynchronousConnectionChangedPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl SynchronousConnectionChangedBuilder {pub fn build(self) -> SynchronousConnectionChangedPacket {let synchronous_connection_changed= Arc::new(SynchronousConnectionChangedData {status: self.status, connection_handle: self.connection_handle, transmission_interval_slots: self.transmission_interval_slots, retransmission_window_slots: self.retransmission_window_slots, rx_packet_length: self.rx_packet_length, tx_packet_length: self.tx_packet_length, });let event= Arc::new(EventData {event_code: EventCode::SynchronousConnectionChanged, child: EventDataChild::SynchronousConnectionChanged(synchronous_connection_changed),});SynchronousConnectionChangedPacket::new(event)}
}
impl Into<EventPacket> for SynchronousConnectionChangedBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct SniffSubratingEventData {status: ErrorCode, connection_handle: u16, maximum_transmit_latency: u16, maximum_receive_latency: u16, minimum_remote_timeout: u16, minimum_local_timeout: u16, }
#[derive(Debug, Clone)] pub struct SniffSubratingEventPacket {event: Arc<EventData>,sniff_subrating_event: Arc<SniffSubratingEventData>,}
#[derive(Debug)] pub struct SniffSubratingEventBuilder {pub status: ErrorCode, pub connection_handle: u16, pub maximum_transmit_latency: u16, pub maximum_receive_latency: u16, pub minimum_remote_timeout: u16, pub minimum_local_timeout: u16, }
impl SniffSubratingEventData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "SniffSubratingEvent".to_string(),    field: "status".to_string(),    wanted: 3,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[2]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "SniffSubratingEvent".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "SniffSubratingEvent".to_string(),    field: "maximum_transmit_latency".to_string(),    wanted: 7,    got: bytes.len()});}let maximum_transmit_latency = u16::from_le_bytes([bytes[5],bytes[6]]);if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "SniffSubratingEvent".to_string(),    field: "maximum_receive_latency".to_string(),    wanted: 9,    got: bytes.len()});}let maximum_receive_latency = u16::from_le_bytes([bytes[7],bytes[8]]);if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "SniffSubratingEvent".to_string(),    field: "minimum_remote_timeout".to_string(),    wanted: 11,    got: bytes.len()});}let minimum_remote_timeout = u16::from_le_bytes([bytes[9],bytes[10]]);if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "SniffSubratingEvent".to_string(),    field: "minimum_local_timeout".to_string(),    wanted: 13,    got: bytes.len()});}let minimum_local_timeout = u16::from_le_bytes([bytes[11],bytes[12]]);Ok(Self {status, connection_handle, maximum_transmit_latency, maximum_receive_latency, minimum_remote_timeout, minimum_local_timeout, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[2..3].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let maximum_transmit_latency = self.maximum_transmit_latency;buffer[5..7].copy_from_slice(&maximum_transmit_latency.to_le_bytes()[0..2]);let maximum_receive_latency = self.maximum_receive_latency;buffer[7..9].copy_from_slice(&maximum_receive_latency.to_le_bytes()[0..2]);let minimum_remote_timeout = self.minimum_remote_timeout;buffer[9..11].copy_from_slice(&minimum_remote_timeout.to_le_bytes()[0..2]);let minimum_local_timeout = self.minimum_local_timeout;buffer[11..13].copy_from_slice(&minimum_local_timeout.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 11;ret}
}
impl Packet for SniffSubratingEventPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SniffSubratingEventPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let sniff_subrating_event = match &event.child {EventDataChild::SniffSubratingEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SniffSubratingEvent"),};Self {event,sniff_subrating_event,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.sniff_subrating_event.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.sniff_subrating_event.as_ref().connection_handle}
pub fn get_maximum_transmit_latency(&self) -> u16{ self.sniff_subrating_event.as_ref().maximum_transmit_latency}
pub fn get_maximum_receive_latency(&self) -> u16{ self.sniff_subrating_event.as_ref().maximum_receive_latency}
pub fn get_minimum_remote_timeout(&self) -> u16{ self.sniff_subrating_event.as_ref().minimum_remote_timeout}
pub fn get_minimum_local_timeout(&self) -> u16{ self.sniff_subrating_event.as_ref().minimum_local_timeout}
}
impl Into<EventPacket> for SniffSubratingEventPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl SniffSubratingEventBuilder {pub fn build(self) -> SniffSubratingEventPacket {let sniff_subrating_event= Arc::new(SniffSubratingEventData {status: self.status, connection_handle: self.connection_handle, maximum_transmit_latency: self.maximum_transmit_latency, maximum_receive_latency: self.maximum_receive_latency, minimum_remote_timeout: self.minimum_remote_timeout, minimum_local_timeout: self.minimum_local_timeout, });let event= Arc::new(EventData {event_code: EventCode::SniffSubrating, child: EventDataChild::SniffSubratingEvent(sniff_subrating_event),});SniffSubratingEventPacket::new(event)}
}
impl Into<EventPacket> for SniffSubratingEventBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct ExtendedInquiryResultData {address: Address, page_scan_repetition_mode: PageScanRepetitionMode, class_of_device: ClassOfDevice, clock_offset: u16, rssi: u8, extended_inquiry_response: Vec::<GapData>, }
#[derive(Debug, Clone)] pub struct ExtendedInquiryResultPacket {event: Arc<EventData>,extended_inquiry_result: Arc<ExtendedInquiryResultData>,}
#[derive(Debug)] pub struct ExtendedInquiryResultBuilder {pub address: Address, pub page_scan_repetition_mode: PageScanRepetitionMode, pub class_of_device: ClassOfDevice, pub clock_offset: u16, pub rssi: u8, pub extended_inquiry_response: Vec::<GapData>, }
impl ExtendedInquiryResultData {fn conforms(bytes: &[u8]) -> bool {let fixed_scalar13 = u8::from_le_bytes([bytes[2]]);if fixed_scalar13 != 1 { return false; }  true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "ExtendedInquiryResult".to_string(),    field: "fixed_scalar13".to_string(),    wanted: 3,    got: bytes.len()});}let fixed_scalar13 = u8::from_le_bytes([bytes[2]]);if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "ExtendedInquiryResult".to_string(),    field: "address".to_string(),    wanted: 9,    got: bytes.len()});}let address = bytes[3..9].try_into().unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "ExtendedInquiryResult".to_string(),    field: "page_scan_repetition_mode".to_string(),    wanted: 10,    got: bytes.len()});}let page_scan_repetition_mode = u8::from_le_bytes([bytes[9]]);let page_scan_repetition_mode = PageScanRepetitionMode::from_u8(page_scan_repetition_mode).unwrap();if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "ExtendedInquiryResult".to_string(),    field: "class_of_device".to_string(),    wanted: 14,    got: bytes.len()});}let class_of_device = bytes[11..14].try_into().unwrap();if bytes.len() < 16 { return Err(Error::InvalidLengthError{    obj: "ExtendedInquiryResult".to_string(),    field: "clock_offset".to_string(),    wanted: 16,    got: bytes.len()});}let clock_offset = u16::from_le_bytes([bytes[14],bytes[15]]);let clock_offset = clock_offset & 0x7fff;if bytes.len() < 17 { return Err(Error::InvalidLengthError{    obj: "ExtendedInquiryResult".to_string(),    field: "rssi".to_string(),    wanted: 17,    got: bytes.len()});}let rssi = u8::from_le_bytes([bytes[16]]);let mut extended_inquiry_response: Vec::<GapData> = Vec::new();let mut parsable_ = &bytes[17..];while parsable_.len() > 0 { match GapData::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];extended_inquiry_response.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {address, page_scan_repetition_mode, class_of_device, clock_offset, rssi, extended_inquiry_response, })
}
fn write_to(&self, buffer: &mut BytesMut) {let fixed_scalar13: u8 = 1;buffer[2..3].copy_from_slice(&fixed_scalar13.to_le_bytes()[0..1]);let address: [u8; 6] = self.address.into();buffer[3..9].copy_from_slice(&address);let page_scan_repetition_mode = self.page_scan_repetition_mode.to_u8().unwrap();buffer[9..10].copy_from_slice(&page_scan_repetition_mode.to_le_bytes()[0..1]);let class_of_device: [u8; 3] = self.class_of_device.into();buffer[11..14].copy_from_slice(&class_of_device);let clock_offset = self.clock_offset;let clock_offset = clock_offset & 0x7fff;buffer[14..16].copy_from_slice(&clock_offset.to_le_bytes()[0..2]);let rssi = self.rssi;buffer[16..17].copy_from_slice(&rssi.to_le_bytes()[0..1]);let mut vec_buffer_ = &mut buffer[17..];for e_ in &self.extended_inquiry_response { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;/* Skipping extended_inquiry_response since it is padded */let ret = ret + 255;ret}
}
impl Packet for ExtendedInquiryResultPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ExtendedInquiryResultPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let extended_inquiry_result = match &event.child {EventDataChild::ExtendedInquiryResult(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ExtendedInquiryResult"),};Self {event,extended_inquiry_result,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_address(&self) -> Address{ self.extended_inquiry_result.as_ref().address}
pub fn get_page_scan_repetition_mode(&self) -> PageScanRepetitionMode{ self.extended_inquiry_result.as_ref().page_scan_repetition_mode}
pub fn get_class_of_device(&self) -> ClassOfDevice{ self.extended_inquiry_result.as_ref().class_of_device}
pub fn get_clock_offset(&self) -> u16{ self.extended_inquiry_result.as_ref().clock_offset}
pub fn get_rssi(&self) -> u8{ self.extended_inquiry_result.as_ref().rssi}
pub fn get_extended_inquiry_response(&self) -> &Vec::<GapData>{ &self.extended_inquiry_result.as_ref().extended_inquiry_response}
}
impl Into<EventPacket> for ExtendedInquiryResultPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl ExtendedInquiryResultBuilder {pub fn build(self) -> ExtendedInquiryResultPacket {let extended_inquiry_result= Arc::new(ExtendedInquiryResultData {address: self.address, page_scan_repetition_mode: self.page_scan_repetition_mode, class_of_device: self.class_of_device, clock_offset: self.clock_offset, rssi: self.rssi, extended_inquiry_response: self.extended_inquiry_response, });let event= Arc::new(EventData {event_code: EventCode::ExtendedInquiryResult, child: EventDataChild::ExtendedInquiryResult(extended_inquiry_result),});ExtendedInquiryResultPacket::new(event)}
}
impl Into<EventPacket> for ExtendedInquiryResultBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct EncryptionKeyRefreshCompleteData {status: ErrorCode, connection_handle: u16, }
#[derive(Debug, Clone)] pub struct EncryptionKeyRefreshCompletePacket {event: Arc<EventData>,encryption_key_refresh_complete: Arc<EncryptionKeyRefreshCompleteData>,}
#[derive(Debug)] pub struct EncryptionKeyRefreshCompleteBuilder {pub status: ErrorCode, pub connection_handle: u16, }
impl EncryptionKeyRefreshCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "EncryptionKeyRefreshComplete".to_string(),    field: "status".to_string(),    wanted: 3,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[2]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "EncryptionKeyRefreshComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;Ok(Self {status, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[2..3].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for EncryptionKeyRefreshCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl EncryptionKeyRefreshCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let encryption_key_refresh_complete = match &event.child {EventDataChild::EncryptionKeyRefreshComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not EncryptionKeyRefreshComplete"),};Self {event,encryption_key_refresh_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.encryption_key_refresh_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.encryption_key_refresh_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for EncryptionKeyRefreshCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl EncryptionKeyRefreshCompleteBuilder {pub fn build(self) -> EncryptionKeyRefreshCompletePacket {let encryption_key_refresh_complete= Arc::new(EncryptionKeyRefreshCompleteData {status: self.status, connection_handle: self.connection_handle, });let event= Arc::new(EventData {event_code: EventCode::EncryptionKeyRefreshComplete, child: EventDataChild::EncryptionKeyRefreshComplete(encryption_key_refresh_complete),});EncryptionKeyRefreshCompletePacket::new(event)}
}
impl Into<EventPacket> for EncryptionKeyRefreshCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct IoCapabilityRequestData {bd_addr: Address, }
#[derive(Debug, Clone)] pub struct IoCapabilityRequestPacket {event: Arc<EventData>,io_capability_request: Arc<IoCapabilityRequestData>,}
#[derive(Debug)] pub struct IoCapabilityRequestBuilder {pub bd_addr: Address, }
impl IoCapabilityRequestData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "IoCapabilityRequest".to_string(),    field: "bd_addr".to_string(),    wanted: 8,    got: bytes.len()});}let bd_addr = bytes[2..8].try_into().unwrap();Ok(Self {bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[2..8].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl Packet for IoCapabilityRequestPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl IoCapabilityRequestPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let io_capability_request = match &event.child {EventDataChild::IoCapabilityRequest(value) => (*value).clone(),_ => panic!("inconsistent state - child was not IoCapabilityRequest"),};Self {event,io_capability_request,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_bd_addr(&self) -> Address{ self.io_capability_request.as_ref().bd_addr}
}
impl Into<EventPacket> for IoCapabilityRequestPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl IoCapabilityRequestBuilder {pub fn build(self) -> IoCapabilityRequestPacket {let io_capability_request= Arc::new(IoCapabilityRequestData {bd_addr: self.bd_addr, });let event= Arc::new(EventData {event_code: EventCode::IoCapabilityRequest, child: EventDataChild::IoCapabilityRequest(io_capability_request),});IoCapabilityRequestPacket::new(event)}
}
impl Into<EventPacket> for IoCapabilityRequestBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct IoCapabilityResponseData {bd_addr: Address, io_capability: IoCapability, oob_data_present: OobDataPresent, authentication_requirements: AuthenticationRequirements, }
#[derive(Debug, Clone)] pub struct IoCapabilityResponsePacket {event: Arc<EventData>,io_capability_response: Arc<IoCapabilityResponseData>,}
#[derive(Debug)] pub struct IoCapabilityResponseBuilder {pub bd_addr: Address, pub io_capability: IoCapability, pub oob_data_present: OobDataPresent, pub authentication_requirements: AuthenticationRequirements, }
impl IoCapabilityResponseData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "IoCapabilityResponse".to_string(),    field: "bd_addr".to_string(),    wanted: 8,    got: bytes.len()});}let bd_addr = bytes[2..8].try_into().unwrap();if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "IoCapabilityResponse".to_string(),    field: "io_capability".to_string(),    wanted: 9,    got: bytes.len()});}let io_capability = u8::from_le_bytes([bytes[8]]);let io_capability = IoCapability::from_u8(io_capability).unwrap();if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "IoCapabilityResponse".to_string(),    field: "oob_data_present".to_string(),    wanted: 10,    got: bytes.len()});}let oob_data_present = u8::from_le_bytes([bytes[9]]);let oob_data_present = OobDataPresent::from_u8(oob_data_present).unwrap();if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "IoCapabilityResponse".to_string(),    field: "authentication_requirements".to_string(),    wanted: 11,    got: bytes.len()});}let authentication_requirements = u8::from_le_bytes([bytes[10]]);let authentication_requirements = AuthenticationRequirements::from_u8(authentication_requirements).unwrap();Ok(Self {bd_addr, io_capability, oob_data_present, authentication_requirements, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[2..8].copy_from_slice(&bd_addr);let io_capability = self.io_capability.to_u8().unwrap();buffer[8..9].copy_from_slice(&io_capability.to_le_bytes()[0..1]);let oob_data_present = self.oob_data_present.to_u8().unwrap();buffer[9..10].copy_from_slice(&oob_data_present.to_le_bytes()[0..1]);let authentication_requirements = self.authentication_requirements.to_u8().unwrap();buffer[10..11].copy_from_slice(&authentication_requirements.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 9;ret}
}
impl Packet for IoCapabilityResponsePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl IoCapabilityResponsePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let io_capability_response = match &event.child {EventDataChild::IoCapabilityResponse(value) => (*value).clone(),_ => panic!("inconsistent state - child was not IoCapabilityResponse"),};Self {event,io_capability_response,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_bd_addr(&self) -> Address{ self.io_capability_response.as_ref().bd_addr}
pub fn get_io_capability(&self) -> IoCapability{ self.io_capability_response.as_ref().io_capability}
pub fn get_oob_data_present(&self) -> OobDataPresent{ self.io_capability_response.as_ref().oob_data_present}
pub fn get_authentication_requirements(&self) -> AuthenticationRequirements{ self.io_capability_response.as_ref().authentication_requirements}
}
impl Into<EventPacket> for IoCapabilityResponsePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl IoCapabilityResponseBuilder {pub fn build(self) -> IoCapabilityResponsePacket {let io_capability_response= Arc::new(IoCapabilityResponseData {bd_addr: self.bd_addr, io_capability: self.io_capability, oob_data_present: self.oob_data_present, authentication_requirements: self.authentication_requirements, });let event= Arc::new(EventData {event_code: EventCode::IoCapabilityResponse, child: EventDataChild::IoCapabilityResponse(io_capability_response),});IoCapabilityResponsePacket::new(event)}
}
impl Into<EventPacket> for IoCapabilityResponseBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct UserConfirmationRequestData {bd_addr: Address, numeric_value: u32, }
#[derive(Debug, Clone)] pub struct UserConfirmationRequestPacket {event: Arc<EventData>,user_confirmation_request: Arc<UserConfirmationRequestData>,}
#[derive(Debug)] pub struct UserConfirmationRequestBuilder {pub bd_addr: Address, pub numeric_value: u32, }
impl UserConfirmationRequestData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "UserConfirmationRequest".to_string(),    field: "bd_addr".to_string(),    wanted: 8,    got: bytes.len()});}let bd_addr = bytes[2..8].try_into().unwrap();if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "UserConfirmationRequest".to_string(),    field: "numeric_value".to_string(),    wanted: 11,    got: bytes.len()});}let numeric_value = u32::from_le_bytes([bytes[8],bytes[9],bytes[10],0]);let numeric_value = numeric_value & 0xfffff;Ok(Self {bd_addr, numeric_value, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[2..8].copy_from_slice(&bd_addr);let numeric_value = self.numeric_value;let numeric_value = numeric_value & 0xfffff;buffer[8..11].copy_from_slice(&numeric_value.to_le_bytes()[0..3]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 10;ret}
}
impl Packet for UserConfirmationRequestPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl UserConfirmationRequestPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let user_confirmation_request = match &event.child {EventDataChild::UserConfirmationRequest(value) => (*value).clone(),_ => panic!("inconsistent state - child was not UserConfirmationRequest"),};Self {event,user_confirmation_request,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_bd_addr(&self) -> Address{ self.user_confirmation_request.as_ref().bd_addr}
pub fn get_numeric_value(&self) -> u32{ self.user_confirmation_request.as_ref().numeric_value}
}
impl Into<EventPacket> for UserConfirmationRequestPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl UserConfirmationRequestBuilder {pub fn build(self) -> UserConfirmationRequestPacket {let user_confirmation_request= Arc::new(UserConfirmationRequestData {bd_addr: self.bd_addr, numeric_value: self.numeric_value, });let event= Arc::new(EventData {event_code: EventCode::UserConfirmationRequest, child: EventDataChild::UserConfirmationRequest(user_confirmation_request),});UserConfirmationRequestPacket::new(event)}
}
impl Into<EventPacket> for UserConfirmationRequestBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct UserPasskeyRequestData {bd_addr: Address, }
#[derive(Debug, Clone)] pub struct UserPasskeyRequestPacket {event: Arc<EventData>,user_passkey_request: Arc<UserPasskeyRequestData>,}
#[derive(Debug)] pub struct UserPasskeyRequestBuilder {pub bd_addr: Address, }
impl UserPasskeyRequestData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "UserPasskeyRequest".to_string(),    field: "bd_addr".to_string(),    wanted: 8,    got: bytes.len()});}let bd_addr = bytes[2..8].try_into().unwrap();Ok(Self {bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[2..8].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl Packet for UserPasskeyRequestPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl UserPasskeyRequestPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let user_passkey_request = match &event.child {EventDataChild::UserPasskeyRequest(value) => (*value).clone(),_ => panic!("inconsistent state - child was not UserPasskeyRequest"),};Self {event,user_passkey_request,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_bd_addr(&self) -> Address{ self.user_passkey_request.as_ref().bd_addr}
}
impl Into<EventPacket> for UserPasskeyRequestPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl UserPasskeyRequestBuilder {pub fn build(self) -> UserPasskeyRequestPacket {let user_passkey_request= Arc::new(UserPasskeyRequestData {bd_addr: self.bd_addr, });let event= Arc::new(EventData {event_code: EventCode::UserPasskeyRequest, child: EventDataChild::UserPasskeyRequest(user_passkey_request),});UserPasskeyRequestPacket::new(event)}
}
impl Into<EventPacket> for UserPasskeyRequestBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct RemoteOobDataRequestData {bd_addr: Address, }
#[derive(Debug, Clone)] pub struct RemoteOobDataRequestPacket {event: Arc<EventData>,remote_oob_data_request: Arc<RemoteOobDataRequestData>,}
#[derive(Debug)] pub struct RemoteOobDataRequestBuilder {pub bd_addr: Address, }
impl RemoteOobDataRequestData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "RemoteOobDataRequest".to_string(),    field: "bd_addr".to_string(),    wanted: 8,    got: bytes.len()});}let bd_addr = bytes[2..8].try_into().unwrap();Ok(Self {bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[2..8].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl Packet for RemoteOobDataRequestPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl RemoteOobDataRequestPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let remote_oob_data_request = match &event.child {EventDataChild::RemoteOobDataRequest(value) => (*value).clone(),_ => panic!("inconsistent state - child was not RemoteOobDataRequest"),};Self {event,remote_oob_data_request,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_bd_addr(&self) -> Address{ self.remote_oob_data_request.as_ref().bd_addr}
}
impl Into<EventPacket> for RemoteOobDataRequestPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl RemoteOobDataRequestBuilder {pub fn build(self) -> RemoteOobDataRequestPacket {let remote_oob_data_request= Arc::new(RemoteOobDataRequestData {bd_addr: self.bd_addr, });let event= Arc::new(EventData {event_code: EventCode::RemoteOobDataRequest, child: EventDataChild::RemoteOobDataRequest(remote_oob_data_request),});RemoteOobDataRequestPacket::new(event)}
}
impl Into<EventPacket> for RemoteOobDataRequestBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct SimplePairingCompleteData {status: ErrorCode, bd_addr: Address, }
#[derive(Debug, Clone)] pub struct SimplePairingCompletePacket {event: Arc<EventData>,simple_pairing_complete: Arc<SimplePairingCompleteData>,}
#[derive(Debug)] pub struct SimplePairingCompleteBuilder {pub status: ErrorCode, pub bd_addr: Address, }
impl SimplePairingCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "SimplePairingComplete".to_string(),    field: "status".to_string(),    wanted: 3,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[2]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "SimplePairingComplete".to_string(),    field: "bd_addr".to_string(),    wanted: 9,    got: bytes.len()});}let bd_addr = bytes[3..9].try_into().unwrap();Ok(Self {status, bd_addr, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[2..3].copy_from_slice(&status.to_le_bytes()[0..1]);let bd_addr: [u8; 6] = self.bd_addr.into();buffer[3..9].copy_from_slice(&bd_addr);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for SimplePairingCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl SimplePairingCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let simple_pairing_complete = match &event.child {EventDataChild::SimplePairingComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not SimplePairingComplete"),};Self {event,simple_pairing_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.simple_pairing_complete.as_ref().status}
pub fn get_bd_addr(&self) -> Address{ self.simple_pairing_complete.as_ref().bd_addr}
}
impl Into<EventPacket> for SimplePairingCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl SimplePairingCompleteBuilder {pub fn build(self) -> SimplePairingCompletePacket {let simple_pairing_complete= Arc::new(SimplePairingCompleteData {status: self.status, bd_addr: self.bd_addr, });let event= Arc::new(EventData {event_code: EventCode::SimplePairingComplete, child: EventDataChild::SimplePairingComplete(simple_pairing_complete),});SimplePairingCompletePacket::new(event)}
}
impl Into<EventPacket> for SimplePairingCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct LinkSupervisionTimeoutChangedData {connection_handle: u16, link_supervision_timeout: u16, }
#[derive(Debug, Clone)] pub struct LinkSupervisionTimeoutChangedPacket {event: Arc<EventData>,link_supervision_timeout_changed: Arc<LinkSupervisionTimeoutChangedData>,}
#[derive(Debug)] pub struct LinkSupervisionTimeoutChangedBuilder {pub connection_handle: u16, pub link_supervision_timeout: u16, }
impl LinkSupervisionTimeoutChangedData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LinkSupervisionTimeoutChanged".to_string(),    field: "connection_handle".to_string(),    wanted: 4,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[2],bytes[3]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LinkSupervisionTimeoutChanged".to_string(),    field: "link_supervision_timeout".to_string(),    wanted: 6,    got: bytes.len()});}let link_supervision_timeout = u16::from_le_bytes([bytes[4],bytes[5]]);Ok(Self {connection_handle, link_supervision_timeout, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[2..4].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let link_supervision_timeout = self.link_supervision_timeout;buffer[4..6].copy_from_slice(&link_supervision_timeout.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl Packet for LinkSupervisionTimeoutChangedPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LinkSupervisionTimeoutChangedPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let link_supervision_timeout_changed = match &event.child {EventDataChild::LinkSupervisionTimeoutChanged(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LinkSupervisionTimeoutChanged"),};Self {event,link_supervision_timeout_changed,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_connection_handle(&self) -> u16{ self.link_supervision_timeout_changed.as_ref().connection_handle}
pub fn get_link_supervision_timeout(&self) -> u16{ self.link_supervision_timeout_changed.as_ref().link_supervision_timeout}
}
impl Into<EventPacket> for LinkSupervisionTimeoutChangedPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl LinkSupervisionTimeoutChangedBuilder {pub fn build(self) -> LinkSupervisionTimeoutChangedPacket {let link_supervision_timeout_changed= Arc::new(LinkSupervisionTimeoutChangedData {connection_handle: self.connection_handle, link_supervision_timeout: self.link_supervision_timeout, });let event= Arc::new(EventData {event_code: EventCode::LinkSupervisionTimeoutChanged, child: EventDataChild::LinkSupervisionTimeoutChanged(link_supervision_timeout_changed),});LinkSupervisionTimeoutChangedPacket::new(event)}
}
impl Into<EventPacket> for LinkSupervisionTimeoutChangedBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct EnhancedFlushData {connection_handle: u16, packet_type: FlushablePacketType, }
#[derive(Debug, Clone)] pub struct EnhancedFlushPacket {command: Arc<CommandData>,enhanced_flush: Arc<EnhancedFlushData>,}
#[derive(Debug)] pub struct EnhancedFlushBuilder {pub connection_handle: u16, pub packet_type: FlushablePacketType, }
impl EnhancedFlushData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "EnhancedFlush".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "EnhancedFlush".to_string(),    field: "packet_type".to_string(),    wanted: 6,    got: bytes.len()});}let packet_type = u8::from_le_bytes([bytes[5]]);let packet_type = FlushablePacketType::from_u8(packet_type).unwrap();Ok(Self {connection_handle, packet_type, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let packet_type = self.packet_type.to_u8().unwrap();buffer[5..6].copy_from_slice(&packet_type.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl CommandExpectations for EnhancedFlushPacket { type ResponseType = EnhancedFlushStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { EnhancedFlushStatusPacket::new(pkt.event.clone()) }}impl Packet for EnhancedFlushPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.command.get_total_size(), 0); self.command.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl EnhancedFlushPacket { fn new(root: Arc<CommandData>) -> Self {let command = root;let enhanced_flush = match &command.child {CommandDataChild::EnhancedFlush(value) => (*value).clone(),_ => panic!("inconsistent state - child was not EnhancedFlush"),};Self {command,enhanced_flush,}}pub fn get_op_code(&self) -> OpCode{ self.command.as_ref().op_code}
pub fn get_connection_handle(&self) -> u16{ self.enhanced_flush.as_ref().connection_handle}
pub fn get_packet_type(&self) -> FlushablePacketType{ self.enhanced_flush.as_ref().packet_type}
}
impl Into<CommandPacket> for EnhancedFlushPacket { fn into(self) -> CommandPacket {CommandPacket::new(self.command) }}
impl CommandExpectations for EnhancedFlushBuilder { type ResponseType = EnhancedFlushStatusPacket; fn _to_response_type(pkt: EventPacket) -> Self::ResponseType { EnhancedFlushStatusPacket::new(pkt.event.clone()) }}impl EnhancedFlushBuilder {pub fn build(self) -> EnhancedFlushPacket {let enhanced_flush= Arc::new(EnhancedFlushData {connection_handle: self.connection_handle, packet_type: self.packet_type, });let command= Arc::new(CommandData {op_code: OpCode::EnhancedFlush, child: CommandDataChild::EnhancedFlush(enhanced_flush),});EnhancedFlushPacket::new(command)}
}
impl Into<CommandPacket> for EnhancedFlushBuilder { fn into(self) -> CommandPacket { self.build().into() }}


#[derive(Debug)] struct EnhancedFlushStatusData {}
#[derive(Debug, Clone)] pub struct EnhancedFlushStatusPacket {event: Arc<EventData>,command_status: Arc<CommandStatusData>,enhanced_flush_status: Arc<EnhancedFlushStatusData>,}
#[derive(Debug)] pub struct EnhancedFlushStatusBuilder {pub status: ErrorCode, pub num_hci_command_packets: u8, }
impl EnhancedFlushStatusData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for EnhancedFlushStatusPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl EnhancedFlushStatusPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let command_status = match &event.child {EventDataChild::CommandStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not CommandStatus"),};let enhanced_flush_status = match &command_status.child {CommandStatusDataChild::EnhancedFlushStatus(value) => (*value).clone(),_ => panic!("inconsistent state - child was not EnhancedFlushStatus"),};Self {event,command_status,enhanced_flush_status,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_status(&self) -> ErrorCode{ self.command_status.as_ref().status}
pub fn get_num_hci_command_packets(&self) -> u8{ self.command_status.as_ref().num_hci_command_packets}
pub fn get_command_op_code(&self) -> OpCode{ self.command_status.as_ref().command_op_code}
}
impl Into<EventPacket> for EnhancedFlushStatusPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<CommandStatusPacket> for EnhancedFlushStatusPacket { fn into(self) -> CommandStatusPacket {CommandStatusPacket::new(self.event) }}
impl EnhancedFlushStatusBuilder {pub fn build(self) -> EnhancedFlushStatusPacket {let enhanced_flush_status= Arc::new(EnhancedFlushStatusData {});let command_status= Arc::new(CommandStatusData {status: self.status, num_hci_command_packets: self.num_hci_command_packets, command_op_code: OpCode::EnhancedFlush, child: CommandStatusDataChild::EnhancedFlushStatus(enhanced_flush_status),});let event= Arc::new(EventData {event_code: EventCode::CommandStatus, child: EventDataChild::CommandStatus(command_status),});EnhancedFlushStatusPacket::new(event)}
}
impl Into<EventPacket> for EnhancedFlushStatusBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<CommandStatusPacket> for EnhancedFlushStatusBuilder { fn into(self) -> CommandStatusPacket { self.build().into() }}


#[derive(Debug)] struct EnhancedFlushCompleteData {connection_handle: u16, }
#[derive(Debug, Clone)] pub struct EnhancedFlushCompletePacket {event: Arc<EventData>,enhanced_flush_complete: Arc<EnhancedFlushCompleteData>,}
#[derive(Debug)] pub struct EnhancedFlushCompleteBuilder {pub connection_handle: u16, }
impl EnhancedFlushCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "EnhancedFlushComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 4,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[2],bytes[3]]);let connection_handle = connection_handle & 0xfff;Ok(Self {connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[2..4].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for EnhancedFlushCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl EnhancedFlushCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let enhanced_flush_complete = match &event.child {EventDataChild::EnhancedFlushComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not EnhancedFlushComplete"),};Self {event,enhanced_flush_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_connection_handle(&self) -> u16{ self.enhanced_flush_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for EnhancedFlushCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl EnhancedFlushCompleteBuilder {pub fn build(self) -> EnhancedFlushCompletePacket {let enhanced_flush_complete= Arc::new(EnhancedFlushCompleteData {connection_handle: self.connection_handle, });let event= Arc::new(EventData {event_code: EventCode::EnhancedFlushComplete, child: EventDataChild::EnhancedFlushComplete(enhanced_flush_complete),});EnhancedFlushCompletePacket::new(event)}
}
impl Into<EventPacket> for EnhancedFlushCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct UserPasskeyNotificationData {bd_addr: Address, passkey: u32, }
#[derive(Debug, Clone)] pub struct UserPasskeyNotificationPacket {event: Arc<EventData>,user_passkey_notification: Arc<UserPasskeyNotificationData>,}
#[derive(Debug)] pub struct UserPasskeyNotificationBuilder {pub bd_addr: Address, pub passkey: u32, }
impl UserPasskeyNotificationData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "UserPasskeyNotification".to_string(),    field: "bd_addr".to_string(),    wanted: 8,    got: bytes.len()});}let bd_addr = bytes[2..8].try_into().unwrap();if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "UserPasskeyNotification".to_string(),    field: "passkey".to_string(),    wanted: 11,    got: bytes.len()});}let passkey = u32::from_le_bytes([bytes[8],bytes[9],bytes[10],0]);let passkey = passkey & 0xfffff;Ok(Self {bd_addr, passkey, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[2..8].copy_from_slice(&bd_addr);let passkey = self.passkey;let passkey = passkey & 0xfffff;buffer[8..11].copy_from_slice(&passkey.to_le_bytes()[0..3]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 10;ret}
}
impl Packet for UserPasskeyNotificationPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl UserPasskeyNotificationPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let user_passkey_notification = match &event.child {EventDataChild::UserPasskeyNotification(value) => (*value).clone(),_ => panic!("inconsistent state - child was not UserPasskeyNotification"),};Self {event,user_passkey_notification,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_bd_addr(&self) -> Address{ self.user_passkey_notification.as_ref().bd_addr}
pub fn get_passkey(&self) -> u32{ self.user_passkey_notification.as_ref().passkey}
}
impl Into<EventPacket> for UserPasskeyNotificationPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl UserPasskeyNotificationBuilder {pub fn build(self) -> UserPasskeyNotificationPacket {let user_passkey_notification= Arc::new(UserPasskeyNotificationData {bd_addr: self.bd_addr, passkey: self.passkey, });let event= Arc::new(EventData {event_code: EventCode::UserPasskeyNotification, child: EventDataChild::UserPasskeyNotification(user_passkey_notification),});UserPasskeyNotificationPacket::new(event)}
}
impl Into<EventPacket> for UserPasskeyNotificationBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct KeypressNotificationData {bd_addr: Address, notification_type: KeypressNotificationType, }
#[derive(Debug, Clone)] pub struct KeypressNotificationPacket {event: Arc<EventData>,keypress_notification: Arc<KeypressNotificationData>,}
#[derive(Debug)] pub struct KeypressNotificationBuilder {pub bd_addr: Address, pub notification_type: KeypressNotificationType, }
impl KeypressNotificationData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "KeypressNotification".to_string(),    field: "bd_addr".to_string(),    wanted: 8,    got: bytes.len()});}let bd_addr = bytes[2..8].try_into().unwrap();if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "KeypressNotification".to_string(),    field: "notification_type".to_string(),    wanted: 9,    got: bytes.len()});}let notification_type = u8::from_le_bytes([bytes[8]]);let notification_type = KeypressNotificationType::from_u8(notification_type).unwrap();Ok(Self {bd_addr, notification_type, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[2..8].copy_from_slice(&bd_addr);let notification_type = self.notification_type.to_u8().unwrap();buffer[8..9].copy_from_slice(&notification_type.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 7;ret}
}
impl Packet for KeypressNotificationPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl KeypressNotificationPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let keypress_notification = match &event.child {EventDataChild::KeypressNotification(value) => (*value).clone(),_ => panic!("inconsistent state - child was not KeypressNotification"),};Self {event,keypress_notification,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_bd_addr(&self) -> Address{ self.keypress_notification.as_ref().bd_addr}
pub fn get_notification_type(&self) -> KeypressNotificationType{ self.keypress_notification.as_ref().notification_type}
}
impl Into<EventPacket> for KeypressNotificationPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl KeypressNotificationBuilder {pub fn build(self) -> KeypressNotificationPacket {let keypress_notification= Arc::new(KeypressNotificationData {bd_addr: self.bd_addr, notification_type: self.notification_type, });let event= Arc::new(EventData {event_code: EventCode::KeypressNotification, child: EventDataChild::KeypressNotification(keypress_notification),});KeypressNotificationPacket::new(event)}
}
impl Into<EventPacket> for KeypressNotificationBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct RemoteHostSupportedFeaturesNotificationData {bd_addr: Address, host_supported_features: u64, }
#[derive(Debug, Clone)] pub struct RemoteHostSupportedFeaturesNotificationPacket {event: Arc<EventData>,remote_host_supported_features_notification: Arc<RemoteHostSupportedFeaturesNotificationData>,}
#[derive(Debug)] pub struct RemoteHostSupportedFeaturesNotificationBuilder {pub bd_addr: Address, pub host_supported_features: u64, }
impl RemoteHostSupportedFeaturesNotificationData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "RemoteHostSupportedFeaturesNotification".to_string(),    field: "bd_addr".to_string(),    wanted: 8,    got: bytes.len()});}let bd_addr = bytes[2..8].try_into().unwrap();if bytes.len() < 16 { return Err(Error::InvalidLengthError{    obj: "RemoteHostSupportedFeaturesNotification".to_string(),    field: "host_supported_features".to_string(),    wanted: 16,    got: bytes.len()});}let host_supported_features = u64::from_le_bytes([bytes[8],bytes[9],bytes[10],bytes[11],bytes[12],bytes[13],bytes[14],bytes[15]]);Ok(Self {bd_addr, host_supported_features, })
}
fn write_to(&self, buffer: &mut BytesMut) {let bd_addr: [u8; 6] = self.bd_addr.into();buffer[2..8].copy_from_slice(&bd_addr);let host_supported_features = self.host_supported_features;buffer[8..16].copy_from_slice(&host_supported_features.to_le_bytes()[0..8]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 14;ret}
}
impl Packet for RemoteHostSupportedFeaturesNotificationPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl RemoteHostSupportedFeaturesNotificationPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let remote_host_supported_features_notification = match &event.child {EventDataChild::RemoteHostSupportedFeaturesNotification(value) => (*value).clone(),_ => panic!("inconsistent state - child was not RemoteHostSupportedFeaturesNotification"),};Self {event,remote_host_supported_features_notification,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_bd_addr(&self) -> Address{ self.remote_host_supported_features_notification.as_ref().bd_addr}
pub fn get_host_supported_features(&self) -> u64{ self.remote_host_supported_features_notification.as_ref().host_supported_features}
}
impl Into<EventPacket> for RemoteHostSupportedFeaturesNotificationPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl RemoteHostSupportedFeaturesNotificationBuilder {pub fn build(self) -> RemoteHostSupportedFeaturesNotificationPacket {let remote_host_supported_features_notification= Arc::new(RemoteHostSupportedFeaturesNotificationData {bd_addr: self.bd_addr, host_supported_features: self.host_supported_features, });let event= Arc::new(EventData {event_code: EventCode::RemoteHostSupportedFeaturesNotification, child: EventDataChild::RemoteHostSupportedFeaturesNotification(remote_host_supported_features_notification),});RemoteHostSupportedFeaturesNotificationPacket::new(event)}
}
impl Into<EventPacket> for RemoteHostSupportedFeaturesNotificationBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] enum LeMetaEventDataChild {LeConnectionComplete(Arc<LeConnectionCompleteData>),LeAdvertisingReport(Arc<LeAdvertisingReportData>),LeConnectionUpdateComplete(Arc<LeConnectionUpdateCompleteData>),LeReadRemoteFeaturesComplete(Arc<LeReadRemoteFeaturesCompleteData>),LeLongTermKeyRequest(Arc<LeLongTermKeyRequestData>),LeRemoteConnectionParameterRequest(Arc<LeRemoteConnectionParameterRequestData>),LeDataLengthChange(Arc<LeDataLengthChangeData>),ReadLocalP256PublicKeyComplete(Arc<ReadLocalP256PublicKeyCompleteData>),GenerateDhKeyComplete(Arc<GenerateDhKeyCompleteData>),LeEnhancedConnectionComplete(Arc<LeEnhancedConnectionCompleteData>),LeDirectedAdvertisingReport(Arc<LeDirectedAdvertisingReportData>),LePhyUpdateComplete(Arc<LePhyUpdateCompleteData>),LeExtendedAdvertisingReport(Arc<LeExtendedAdvertisingReportData>),LePeriodicAdvertisingSyncEstablished(Arc<LePeriodicAdvertisingSyncEstablishedData>),LePeriodicAdvertisingReport(Arc<LePeriodicAdvertisingReportData>),LePeriodicAdvertisingSyncLost(Arc<LePeriodicAdvertisingSyncLostData>),LeScanTimeout(Arc<LeScanTimeoutData>),LeAdvertisingSetTerminated(Arc<LeAdvertisingSetTerminatedData>),LeScanRequestReceived(Arc<LeScanRequestReceivedData>),LeChannelSelectionAlgorithm(Arc<LeChannelSelectionAlgorithmData>),LeConnectionlessIqReport(Arc<LeConnectionlessIqReportData>),LeConnectionIqReport(Arc<LeConnectionIqReportData>),LeCteRequestFailed(Arc<LeCteRequestFailedData>),LePeriodicAdvertisingSyncTransferReceived(Arc<LePeriodicAdvertisingSyncTransferReceivedData>),LeCisEstablished(Arc<LeCisEstablishedData>),LeCisRequest(Arc<LeCisRequestData>),LeCreateBigComplete(Arc<LeCreateBigCompleteData>),LeTerminateBigComplete(Arc<LeTerminateBigCompleteData>),LeBigSyncEstablished(Arc<LeBigSyncEstablishedData>),LeBigSyncLost(Arc<LeBigSyncLostData>),LeRequestPeerScaComplete(Arc<LeRequestPeerScaCompleteData>),LePathLossThreshold(Arc<LePathLossThresholdData>),LeTransmitPowerReporting(Arc<LeTransmitPowerReportingData>),LeBigInfoAdvertisingReport(Arc<LeBigInfoAdvertisingReportData>),None,}
impl LeMetaEventDataChild {fn get_total_size(&self) -> usize {match self {LeMetaEventDataChild::LeConnectionComplete(value) => value.get_total_size(),LeMetaEventDataChild::LeAdvertisingReport(value) => value.get_total_size(),LeMetaEventDataChild::LeConnectionUpdateComplete(value) => value.get_total_size(),LeMetaEventDataChild::LeReadRemoteFeaturesComplete(value) => value.get_total_size(),LeMetaEventDataChild::LeLongTermKeyRequest(value) => value.get_total_size(),LeMetaEventDataChild::LeRemoteConnectionParameterRequest(value) => value.get_total_size(),LeMetaEventDataChild::LeDataLengthChange(value) => value.get_total_size(),LeMetaEventDataChild::ReadLocalP256PublicKeyComplete(value) => value.get_total_size(),LeMetaEventDataChild::GenerateDhKeyComplete(value) => value.get_total_size(),LeMetaEventDataChild::LeEnhancedConnectionComplete(value) => value.get_total_size(),LeMetaEventDataChild::LeDirectedAdvertisingReport(value) => value.get_total_size(),LeMetaEventDataChild::LePhyUpdateComplete(value) => value.get_total_size(),LeMetaEventDataChild::LeExtendedAdvertisingReport(value) => value.get_total_size(),LeMetaEventDataChild::LePeriodicAdvertisingSyncEstablished(value) => value.get_total_size(),LeMetaEventDataChild::LePeriodicAdvertisingReport(value) => value.get_total_size(),LeMetaEventDataChild::LePeriodicAdvertisingSyncLost(value) => value.get_total_size(),LeMetaEventDataChild::LeScanTimeout(value) => value.get_total_size(),LeMetaEventDataChild::LeAdvertisingSetTerminated(value) => value.get_total_size(),LeMetaEventDataChild::LeScanRequestReceived(value) => value.get_total_size(),LeMetaEventDataChild::LeChannelSelectionAlgorithm(value) => value.get_total_size(),LeMetaEventDataChild::LeConnectionlessIqReport(value) => value.get_total_size(),LeMetaEventDataChild::LeConnectionIqReport(value) => value.get_total_size(),LeMetaEventDataChild::LeCteRequestFailed(value) => value.get_total_size(),LeMetaEventDataChild::LePeriodicAdvertisingSyncTransferReceived(value) => value.get_total_size(),LeMetaEventDataChild::LeCisEstablished(value) => value.get_total_size(),LeMetaEventDataChild::LeCisRequest(value) => value.get_total_size(),LeMetaEventDataChild::LeCreateBigComplete(value) => value.get_total_size(),LeMetaEventDataChild::LeTerminateBigComplete(value) => value.get_total_size(),LeMetaEventDataChild::LeBigSyncEstablished(value) => value.get_total_size(),LeMetaEventDataChild::LeBigSyncLost(value) => value.get_total_size(),LeMetaEventDataChild::LeRequestPeerScaComplete(value) => value.get_total_size(),LeMetaEventDataChild::LePathLossThreshold(value) => value.get_total_size(),LeMetaEventDataChild::LeTransmitPowerReporting(value) => value.get_total_size(),LeMetaEventDataChild::LeBigInfoAdvertisingReport(value) => value.get_total_size(),LeMetaEventDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LeMetaEventChild {LeConnectionComplete(LeConnectionCompletePacket),LeAdvertisingReport(LeAdvertisingReportPacket),LeConnectionUpdateComplete(LeConnectionUpdateCompletePacket),LeReadRemoteFeaturesComplete(LeReadRemoteFeaturesCompletePacket),LeLongTermKeyRequest(LeLongTermKeyRequestPacket),LeRemoteConnectionParameterRequest(LeRemoteConnectionParameterRequestPacket),LeDataLengthChange(LeDataLengthChangePacket),ReadLocalP256PublicKeyComplete(ReadLocalP256PublicKeyCompletePacket),GenerateDhKeyComplete(GenerateDhKeyCompletePacket),LeEnhancedConnectionComplete(LeEnhancedConnectionCompletePacket),LeDirectedAdvertisingReport(LeDirectedAdvertisingReportPacket),LePhyUpdateComplete(LePhyUpdateCompletePacket),LeExtendedAdvertisingReport(LeExtendedAdvertisingReportPacket),LePeriodicAdvertisingSyncEstablished(LePeriodicAdvertisingSyncEstablishedPacket),LePeriodicAdvertisingReport(LePeriodicAdvertisingReportPacket),LePeriodicAdvertisingSyncLost(LePeriodicAdvertisingSyncLostPacket),LeScanTimeout(LeScanTimeoutPacket),LeAdvertisingSetTerminated(LeAdvertisingSetTerminatedPacket),LeScanRequestReceived(LeScanRequestReceivedPacket),LeChannelSelectionAlgorithm(LeChannelSelectionAlgorithmPacket),LeConnectionlessIqReport(LeConnectionlessIqReportPacket),LeConnectionIqReport(LeConnectionIqReportPacket),LeCteRequestFailed(LeCteRequestFailedPacket),LePeriodicAdvertisingSyncTransferReceived(LePeriodicAdvertisingSyncTransferReceivedPacket),LeCisEstablished(LeCisEstablishedPacket),LeCisRequest(LeCisRequestPacket),LeCreateBigComplete(LeCreateBigCompletePacket),LeTerminateBigComplete(LeTerminateBigCompletePacket),LeBigSyncEstablished(LeBigSyncEstablishedPacket),LeBigSyncLost(LeBigSyncLostPacket),LeRequestPeerScaComplete(LeRequestPeerScaCompletePacket),LePathLossThreshold(LePathLossThresholdPacket),LeTransmitPowerReporting(LeTransmitPowerReportingPacket),LeBigInfoAdvertisingReport(LeBigInfoAdvertisingReportPacket),None,}
#[derive(Debug)] struct LeMetaEventData {subevent_code: SubeventCode, child: LeMetaEventDataChild,}
#[derive(Debug, Clone)] pub struct LeMetaEventPacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,}
#[derive(Debug)] pub struct LeMetaEventBuilder {pub subevent_code: SubeventCode, }
impl LeMetaEventData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "LeMetaEvent".to_string(),    field: "subevent_code".to_string(),    wanted: 3,    got: bytes.len()});}let subevent_code = u8::from_le_bytes([bytes[2]]);let subevent_code = SubeventCode::from_u8(subevent_code).unwrap();let child = match subevent_code {SubeventCode::ConnectionComplete if LeConnectionCompleteData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeConnectionComplete(Arc::new(LeConnectionCompleteData::parse(&bytes[..])?))}
SubeventCode::ConnectionUpdateComplete if LeConnectionUpdateCompleteData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeConnectionUpdateComplete(Arc::new(LeConnectionUpdateCompleteData::parse(&bytes[..])?))}
SubeventCode::AdvertisingReport if LeAdvertisingReportData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeAdvertisingReport(Arc::new(LeAdvertisingReportData::parse(&bytes[..])?))}
SubeventCode::ReadRemoteFeaturesComplete if LeReadRemoteFeaturesCompleteData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeReadRemoteFeaturesComplete(Arc::new(LeReadRemoteFeaturesCompleteData::parse(&bytes[..])?))}
SubeventCode::LongTermKeyRequest if LeLongTermKeyRequestData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeLongTermKeyRequest(Arc::new(LeLongTermKeyRequestData::parse(&bytes[..])?))}
SubeventCode::RemoteConnectionParameterRequest if LeRemoteConnectionParameterRequestData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeRemoteConnectionParameterRequest(Arc::new(LeRemoteConnectionParameterRequestData::parse(&bytes[..])?))}
SubeventCode::DataLengthChange if LeDataLengthChangeData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeDataLengthChange(Arc::new(LeDataLengthChangeData::parse(&bytes[..])?))}
SubeventCode::ReadLocalP256PublicKeyComplete if ReadLocalP256PublicKeyCompleteData::conforms(&bytes[..]) => {LeMetaEventDataChild::ReadLocalP256PublicKeyComplete(Arc::new(ReadLocalP256PublicKeyCompleteData::parse(&bytes[..])?))}
SubeventCode::GenerateDhkeyComplete if GenerateDhKeyCompleteData::conforms(&bytes[..]) => {LeMetaEventDataChild::GenerateDhKeyComplete(Arc::new(GenerateDhKeyCompleteData::parse(&bytes[..])?))}
SubeventCode::EnhancedConnectionComplete if LeEnhancedConnectionCompleteData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeEnhancedConnectionComplete(Arc::new(LeEnhancedConnectionCompleteData::parse(&bytes[..])?))}
SubeventCode::DirectedAdvertisingReport if LeDirectedAdvertisingReportData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeDirectedAdvertisingReport(Arc::new(LeDirectedAdvertisingReportData::parse(&bytes[..])?))}
SubeventCode::PhyUpdateComplete if LePhyUpdateCompleteData::conforms(&bytes[..]) => {LeMetaEventDataChild::LePhyUpdateComplete(Arc::new(LePhyUpdateCompleteData::parse(&bytes[..])?))}
SubeventCode::ExtendedAdvertisingReport if LeExtendedAdvertisingReportData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeExtendedAdvertisingReport(Arc::new(LeExtendedAdvertisingReportData::parse(&bytes[..])?))}
SubeventCode::PeriodicAdvertisingSyncEstablished if LePeriodicAdvertisingSyncEstablishedData::conforms(&bytes[..]) => {LeMetaEventDataChild::LePeriodicAdvertisingSyncEstablished(Arc::new(LePeriodicAdvertisingSyncEstablishedData::parse(&bytes[..])?))}
SubeventCode::PeriodicAdvertisingReport if LePeriodicAdvertisingReportData::conforms(&bytes[..]) => {LeMetaEventDataChild::LePeriodicAdvertisingReport(Arc::new(LePeriodicAdvertisingReportData::parse(&bytes[..])?))}
SubeventCode::PeriodicAdvertisingSyncLost if LePeriodicAdvertisingSyncLostData::conforms(&bytes[..]) => {LeMetaEventDataChild::LePeriodicAdvertisingSyncLost(Arc::new(LePeriodicAdvertisingSyncLostData::parse(&bytes[..])?))}
SubeventCode::ScanTimeout if LeScanTimeoutData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeScanTimeout(Arc::new(LeScanTimeoutData::parse(&bytes[..])?))}
SubeventCode::AdvertisingSetTerminated if LeAdvertisingSetTerminatedData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeAdvertisingSetTerminated(Arc::new(LeAdvertisingSetTerminatedData::parse(&bytes[..])?))}
SubeventCode::ScanRequestReceived if LeScanRequestReceivedData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeScanRequestReceived(Arc::new(LeScanRequestReceivedData::parse(&bytes[..])?))}
SubeventCode::ChannelSelectionAlgorithm if LeChannelSelectionAlgorithmData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeChannelSelectionAlgorithm(Arc::new(LeChannelSelectionAlgorithmData::parse(&bytes[..])?))}
SubeventCode::ConnectionlessIqReport if LeConnectionlessIqReportData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeConnectionlessIqReport(Arc::new(LeConnectionlessIqReportData::parse(&bytes[..])?))}
SubeventCode::ConnectionIqReport if LeConnectionIqReportData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeConnectionIqReport(Arc::new(LeConnectionIqReportData::parse(&bytes[..])?))}
SubeventCode::CteRequestFailed if LeCteRequestFailedData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeCteRequestFailed(Arc::new(LeCteRequestFailedData::parse(&bytes[..])?))}
SubeventCode::PeriodicAdvertisingSyncTransferReceived if LePeriodicAdvertisingSyncTransferReceivedData::conforms(&bytes[..]) => {LeMetaEventDataChild::LePeriodicAdvertisingSyncTransferReceived(Arc::new(LePeriodicAdvertisingSyncTransferReceivedData::parse(&bytes[..])?))}
SubeventCode::CisEstablished if LeCisEstablishedData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeCisEstablished(Arc::new(LeCisEstablishedData::parse(&bytes[..])?))}
SubeventCode::CisRequest if LeCisRequestData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeCisRequest(Arc::new(LeCisRequestData::parse(&bytes[..])?))}
SubeventCode::CreateBigComplete if LeCreateBigCompleteData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeCreateBigComplete(Arc::new(LeCreateBigCompleteData::parse(&bytes[..])?))}
SubeventCode::TerminateBigComplete if LeTerminateBigCompleteData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeTerminateBigComplete(Arc::new(LeTerminateBigCompleteData::parse(&bytes[..])?))}
SubeventCode::BigSyncEstablished if LeBigSyncEstablishedData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeBigSyncEstablished(Arc::new(LeBigSyncEstablishedData::parse(&bytes[..])?))}
SubeventCode::BigSyncLost if LeBigSyncLostData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeBigSyncLost(Arc::new(LeBigSyncLostData::parse(&bytes[..])?))}
SubeventCode::RequestPeerScaComplete if LeRequestPeerScaCompleteData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeRequestPeerScaComplete(Arc::new(LeRequestPeerScaCompleteData::parse(&bytes[..])?))}
SubeventCode::PathLossThreshold if LePathLossThresholdData::conforms(&bytes[..]) => {LeMetaEventDataChild::LePathLossThreshold(Arc::new(LePathLossThresholdData::parse(&bytes[..])?))}
SubeventCode::TransmitPowerReporting if LeTransmitPowerReportingData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeTransmitPowerReporting(Arc::new(LeTransmitPowerReportingData::parse(&bytes[..])?))}
SubeventCode::BigInfoAdvertisingReport if LeBigInfoAdvertisingReportData::conforms(&bytes[..]) => {LeMetaEventDataChild::LeBigInfoAdvertisingReport(Arc::new(LeBigInfoAdvertisingReportData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "subevent_code".to_string(), value: v as u64}),};
Ok(Self {subevent_code, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let subevent_code = self.subevent_code.to_u8().unwrap();buffer[2..3].copy_from_slice(&subevent_code.to_le_bytes()[0..1]);match &self.child {LeMetaEventDataChild::LeConnectionComplete(value) => value.write_to(buffer),LeMetaEventDataChild::LeAdvertisingReport(value) => value.write_to(buffer),LeMetaEventDataChild::LeConnectionUpdateComplete(value) => value.write_to(buffer),LeMetaEventDataChild::LeReadRemoteFeaturesComplete(value) => value.write_to(buffer),LeMetaEventDataChild::LeLongTermKeyRequest(value) => value.write_to(buffer),LeMetaEventDataChild::LeRemoteConnectionParameterRequest(value) => value.write_to(buffer),LeMetaEventDataChild::LeDataLengthChange(value) => value.write_to(buffer),LeMetaEventDataChild::ReadLocalP256PublicKeyComplete(value) => value.write_to(buffer),LeMetaEventDataChild::GenerateDhKeyComplete(value) => value.write_to(buffer),LeMetaEventDataChild::LeEnhancedConnectionComplete(value) => value.write_to(buffer),LeMetaEventDataChild::LeDirectedAdvertisingReport(value) => value.write_to(buffer),LeMetaEventDataChild::LePhyUpdateComplete(value) => value.write_to(buffer),LeMetaEventDataChild::LeExtendedAdvertisingReport(value) => value.write_to(buffer),LeMetaEventDataChild::LePeriodicAdvertisingSyncEstablished(value) => value.write_to(buffer),LeMetaEventDataChild::LePeriodicAdvertisingReport(value) => value.write_to(buffer),LeMetaEventDataChild::LePeriodicAdvertisingSyncLost(value) => value.write_to(buffer),LeMetaEventDataChild::LeScanTimeout(value) => value.write_to(buffer),LeMetaEventDataChild::LeAdvertisingSetTerminated(value) => value.write_to(buffer),LeMetaEventDataChild::LeScanRequestReceived(value) => value.write_to(buffer),LeMetaEventDataChild::LeChannelSelectionAlgorithm(value) => value.write_to(buffer),LeMetaEventDataChild::LeConnectionlessIqReport(value) => value.write_to(buffer),LeMetaEventDataChild::LeConnectionIqReport(value) => value.write_to(buffer),LeMetaEventDataChild::LeCteRequestFailed(value) => value.write_to(buffer),LeMetaEventDataChild::LePeriodicAdvertisingSyncTransferReceived(value) => value.write_to(buffer),LeMetaEventDataChild::LeCisEstablished(value) => value.write_to(buffer),LeMetaEventDataChild::LeCisRequest(value) => value.write_to(buffer),LeMetaEventDataChild::LeCreateBigComplete(value) => value.write_to(buffer),LeMetaEventDataChild::LeTerminateBigComplete(value) => value.write_to(buffer),LeMetaEventDataChild::LeBigSyncEstablished(value) => value.write_to(buffer),LeMetaEventDataChild::LeBigSyncLost(value) => value.write_to(buffer),LeMetaEventDataChild::LeRequestPeerScaComplete(value) => value.write_to(buffer),LeMetaEventDataChild::LePathLossThreshold(value) => value.write_to(buffer),LeMetaEventDataChild::LeTransmitPowerReporting(value) => value.write_to(buffer),LeMetaEventDataChild::LeBigInfoAdvertisingReport(value) => value.write_to(buffer),LeMetaEventDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for LeMetaEventPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeMetaEventPacket { pub fn specialize(&self) -> LeMetaEventChild { match &self.le_meta_event.child {LeMetaEventDataChild::LeConnectionComplete(_) => LeMetaEventChild::LeConnectionComplete(LeConnectionCompletePacket::new(self.event.clone())),LeMetaEventDataChild::LeAdvertisingReport(_) => LeMetaEventChild::LeAdvertisingReport(LeAdvertisingReportPacket::new(self.event.clone())),LeMetaEventDataChild::LeConnectionUpdateComplete(_) => LeMetaEventChild::LeConnectionUpdateComplete(LeConnectionUpdateCompletePacket::new(self.event.clone())),LeMetaEventDataChild::LeReadRemoteFeaturesComplete(_) => LeMetaEventChild::LeReadRemoteFeaturesComplete(LeReadRemoteFeaturesCompletePacket::new(self.event.clone())),LeMetaEventDataChild::LeLongTermKeyRequest(_) => LeMetaEventChild::LeLongTermKeyRequest(LeLongTermKeyRequestPacket::new(self.event.clone())),LeMetaEventDataChild::LeRemoteConnectionParameterRequest(_) => LeMetaEventChild::LeRemoteConnectionParameterRequest(LeRemoteConnectionParameterRequestPacket::new(self.event.clone())),LeMetaEventDataChild::LeDataLengthChange(_) => LeMetaEventChild::LeDataLengthChange(LeDataLengthChangePacket::new(self.event.clone())),LeMetaEventDataChild::ReadLocalP256PublicKeyComplete(_) => LeMetaEventChild::ReadLocalP256PublicKeyComplete(ReadLocalP256PublicKeyCompletePacket::new(self.event.clone())),LeMetaEventDataChild::GenerateDhKeyComplete(_) => LeMetaEventChild::GenerateDhKeyComplete(GenerateDhKeyCompletePacket::new(self.event.clone())),LeMetaEventDataChild::LeEnhancedConnectionComplete(_) => LeMetaEventChild::LeEnhancedConnectionComplete(LeEnhancedConnectionCompletePacket::new(self.event.clone())),LeMetaEventDataChild::LeDirectedAdvertisingReport(_) => LeMetaEventChild::LeDirectedAdvertisingReport(LeDirectedAdvertisingReportPacket::new(self.event.clone())),LeMetaEventDataChild::LePhyUpdateComplete(_) => LeMetaEventChild::LePhyUpdateComplete(LePhyUpdateCompletePacket::new(self.event.clone())),LeMetaEventDataChild::LeExtendedAdvertisingReport(_) => LeMetaEventChild::LeExtendedAdvertisingReport(LeExtendedAdvertisingReportPacket::new(self.event.clone())),LeMetaEventDataChild::LePeriodicAdvertisingSyncEstablished(_) => LeMetaEventChild::LePeriodicAdvertisingSyncEstablished(LePeriodicAdvertisingSyncEstablishedPacket::new(self.event.clone())),LeMetaEventDataChild::LePeriodicAdvertisingReport(_) => LeMetaEventChild::LePeriodicAdvertisingReport(LePeriodicAdvertisingReportPacket::new(self.event.clone())),LeMetaEventDataChild::LePeriodicAdvertisingSyncLost(_) => LeMetaEventChild::LePeriodicAdvertisingSyncLost(LePeriodicAdvertisingSyncLostPacket::new(self.event.clone())),LeMetaEventDataChild::LeScanTimeout(_) => LeMetaEventChild::LeScanTimeout(LeScanTimeoutPacket::new(self.event.clone())),LeMetaEventDataChild::LeAdvertisingSetTerminated(_) => LeMetaEventChild::LeAdvertisingSetTerminated(LeAdvertisingSetTerminatedPacket::new(self.event.clone())),LeMetaEventDataChild::LeScanRequestReceived(_) => LeMetaEventChild::LeScanRequestReceived(LeScanRequestReceivedPacket::new(self.event.clone())),LeMetaEventDataChild::LeChannelSelectionAlgorithm(_) => LeMetaEventChild::LeChannelSelectionAlgorithm(LeChannelSelectionAlgorithmPacket::new(self.event.clone())),LeMetaEventDataChild::LeConnectionlessIqReport(_) => LeMetaEventChild::LeConnectionlessIqReport(LeConnectionlessIqReportPacket::new(self.event.clone())),LeMetaEventDataChild::LeConnectionIqReport(_) => LeMetaEventChild::LeConnectionIqReport(LeConnectionIqReportPacket::new(self.event.clone())),LeMetaEventDataChild::LeCteRequestFailed(_) => LeMetaEventChild::LeCteRequestFailed(LeCteRequestFailedPacket::new(self.event.clone())),LeMetaEventDataChild::LePeriodicAdvertisingSyncTransferReceived(_) => LeMetaEventChild::LePeriodicAdvertisingSyncTransferReceived(LePeriodicAdvertisingSyncTransferReceivedPacket::new(self.event.clone())),LeMetaEventDataChild::LeCisEstablished(_) => LeMetaEventChild::LeCisEstablished(LeCisEstablishedPacket::new(self.event.clone())),LeMetaEventDataChild::LeCisRequest(_) => LeMetaEventChild::LeCisRequest(LeCisRequestPacket::new(self.event.clone())),LeMetaEventDataChild::LeCreateBigComplete(_) => LeMetaEventChild::LeCreateBigComplete(LeCreateBigCompletePacket::new(self.event.clone())),LeMetaEventDataChild::LeTerminateBigComplete(_) => LeMetaEventChild::LeTerminateBigComplete(LeTerminateBigCompletePacket::new(self.event.clone())),LeMetaEventDataChild::LeBigSyncEstablished(_) => LeMetaEventChild::LeBigSyncEstablished(LeBigSyncEstablishedPacket::new(self.event.clone())),LeMetaEventDataChild::LeBigSyncLost(_) => LeMetaEventChild::LeBigSyncLost(LeBigSyncLostPacket::new(self.event.clone())),LeMetaEventDataChild::LeRequestPeerScaComplete(_) => LeMetaEventChild::LeRequestPeerScaComplete(LeRequestPeerScaCompletePacket::new(self.event.clone())),LeMetaEventDataChild::LePathLossThreshold(_) => LeMetaEventChild::LePathLossThreshold(LePathLossThresholdPacket::new(self.event.clone())),LeMetaEventDataChild::LeTransmitPowerReporting(_) => LeMetaEventChild::LeTransmitPowerReporting(LeTransmitPowerReportingPacket::new(self.event.clone())),LeMetaEventDataChild::LeBigInfoAdvertisingReport(_) => LeMetaEventChild::LeBigInfoAdvertisingReport(LeBigInfoAdvertisingReportPacket::new(self.event.clone())),LeMetaEventDataChild::None => LeMetaEventChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};Self {event,le_meta_event,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
}
impl Into<EventPacket> for LeMetaEventPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl LeMetaEventBuilder {pub fn build(self) -> LeMetaEventPacket {let le_meta_event= Arc::new(LeMetaEventData {subevent_code: self.subevent_code, child: LeMetaEventDataChild::None,});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeMetaEventPacket::new(event)}
}
impl Into<EventPacket> for LeMetaEventBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] enum NumberOfCompletedDataBlocksDataChild {Payload(Bytes),None,}
impl NumberOfCompletedDataBlocksDataChild {fn get_total_size(&self) -> usize {match self {NumberOfCompletedDataBlocksDataChild::Payload(p) => p.len(),NumberOfCompletedDataBlocksDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum NumberOfCompletedDataBlocksChild {Payload(Bytes),None,}
#[derive(Debug)] struct NumberOfCompletedDataBlocksData {total_num_data_blocks: u16, child: NumberOfCompletedDataBlocksDataChild,}
#[derive(Debug, Clone)] pub struct NumberOfCompletedDataBlocksPacket {event: Arc<EventData>,number_of_completed_data_blocks: Arc<NumberOfCompletedDataBlocksData>,}
#[derive(Debug)] pub struct NumberOfCompletedDataBlocksBuilder {pub total_num_data_blocks: u16, pub payload: Option<Bytes>,}
impl NumberOfCompletedDataBlocksData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "NumberOfCompletedDataBlocks".to_string(),    field: "total_num_data_blocks".to_string(),    wanted: 4,    got: bytes.len()});}let total_num_data_blocks = u16::from_le_bytes([bytes[2],bytes[3]]);let payload: Vec::<u8> = bytes[4..].into();let child = if payload.len() > 0 {NumberOfCompletedDataBlocksDataChild::Payload(Bytes::from(payload))} else {NumberOfCompletedDataBlocksDataChild::None};Ok(Self {total_num_data_blocks, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let total_num_data_blocks = self.total_num_data_blocks;buffer[2..4].copy_from_slice(&total_num_data_blocks.to_le_bytes()[0..2]);match &self.child {NumberOfCompletedDataBlocksDataChild::Payload(p) => buffer[4..].copy_from_slice(&p[..]),NumberOfCompletedDataBlocksDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for NumberOfCompletedDataBlocksPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl NumberOfCompletedDataBlocksPacket { pub fn specialize(&self) -> NumberOfCompletedDataBlocksChild { match &self.number_of_completed_data_blocks.child {NumberOfCompletedDataBlocksDataChild::Payload(p) => NumberOfCompletedDataBlocksChild::Payload(p.clone()),NumberOfCompletedDataBlocksDataChild::None => NumberOfCompletedDataBlocksChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let number_of_completed_data_blocks = match &event.child {EventDataChild::NumberOfCompletedDataBlocks(value) => (*value).clone(),_ => panic!("inconsistent state - child was not NumberOfCompletedDataBlocks"),};Self {event,number_of_completed_data_blocks,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_total_num_data_blocks(&self) -> u16{ self.number_of_completed_data_blocks.as_ref().total_num_data_blocks}
}
impl Into<EventPacket> for NumberOfCompletedDataBlocksPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl NumberOfCompletedDataBlocksBuilder {pub fn build(self) -> NumberOfCompletedDataBlocksPacket {let number_of_completed_data_blocks= Arc::new(NumberOfCompletedDataBlocksData {total_num_data_blocks: self.total_num_data_blocks, child: match self.payload { None => NumberOfCompletedDataBlocksDataChild::None,Some(bytes) => NumberOfCompletedDataBlocksDataChild::Payload(bytes),},});let event= Arc::new(EventData {event_code: EventCode::NumberOfCompletedDataBlocks, child: EventDataChild::NumberOfCompletedDataBlocks(number_of_completed_data_blocks),});NumberOfCompletedDataBlocksPacket::new(event)}
}
impl Into<EventPacket> for NumberOfCompletedDataBlocksBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct LeConnectionCompleteData {status: ErrorCode, connection_handle: u16, role: Role, peer_address_type: AddressType, peer_address: Address, conn_interval: u16, conn_latency: u16, supervision_timeout: u16, central_clock_accuracy: ClockAccuracy, }
#[derive(Debug, Clone)] pub struct LeConnectionCompletePacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_connection_complete: Arc<LeConnectionCompleteData>,}
#[derive(Debug)] pub struct LeConnectionCompleteBuilder {pub status: ErrorCode, pub connection_handle: u16, pub role: Role, pub peer_address_type: AddressType, pub peer_address: Address, pub conn_interval: u16, pub conn_latency: u16, pub supervision_timeout: u16, pub central_clock_accuracy: ClockAccuracy, }
impl LeConnectionCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeConnectionComplete".to_string(),    field: "status".to_string(),    wanted: 4,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[3]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeConnectionComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 6,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[4],bytes[5]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeConnectionComplete".to_string(),    field: "role".to_string(),    wanted: 7,    got: bytes.len()});}let role = u8::from_le_bytes([bytes[6]]);let role = Role::from_u8(role).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeConnectionComplete".to_string(),    field: "peer_address_type".to_string(),    wanted: 8,    got: bytes.len()});}let peer_address_type = u8::from_le_bytes([bytes[7]]);let peer_address_type = AddressType::from_u8(peer_address_type).unwrap();if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "LeConnectionComplete".to_string(),    field: "peer_address".to_string(),    wanted: 14,    got: bytes.len()});}let peer_address = bytes[8..14].try_into().unwrap();if bytes.len() < 16 { return Err(Error::InvalidLengthError{    obj: "LeConnectionComplete".to_string(),    field: "conn_interval".to_string(),    wanted: 16,    got: bytes.len()});}let conn_interval = u16::from_le_bytes([bytes[14],bytes[15]]);if bytes.len() < 18 { return Err(Error::InvalidLengthError{    obj: "LeConnectionComplete".to_string(),    field: "conn_latency".to_string(),    wanted: 18,    got: bytes.len()});}let conn_latency = u16::from_le_bytes([bytes[16],bytes[17]]);if bytes.len() < 20 { return Err(Error::InvalidLengthError{    obj: "LeConnectionComplete".to_string(),    field: "supervision_timeout".to_string(),    wanted: 20,    got: bytes.len()});}let supervision_timeout = u16::from_le_bytes([bytes[18],bytes[19]]);if bytes.len() < 21 { return Err(Error::InvalidLengthError{    obj: "LeConnectionComplete".to_string(),    field: "central_clock_accuracy".to_string(),    wanted: 21,    got: bytes.len()});}let central_clock_accuracy = u8::from_le_bytes([bytes[20]]);let central_clock_accuracy = ClockAccuracy::from_u8(central_clock_accuracy).unwrap();Ok(Self {status, connection_handle, role, peer_address_type, peer_address, conn_interval, conn_latency, supervision_timeout, central_clock_accuracy, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[3..4].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[4..6].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let role = self.role.to_u8().unwrap();buffer[6..7].copy_from_slice(&role.to_le_bytes()[0..1]);let peer_address_type = self.peer_address_type.to_u8().unwrap();buffer[7..8].copy_from_slice(&peer_address_type.to_le_bytes()[0..1]);let peer_address: [u8; 6] = self.peer_address.into();buffer[8..14].copy_from_slice(&peer_address);let conn_interval = self.conn_interval;buffer[14..16].copy_from_slice(&conn_interval.to_le_bytes()[0..2]);let conn_latency = self.conn_latency;buffer[16..18].copy_from_slice(&conn_latency.to_le_bytes()[0..2]);let supervision_timeout = self.supervision_timeout;buffer[18..20].copy_from_slice(&supervision_timeout.to_le_bytes()[0..2]);let central_clock_accuracy = self.central_clock_accuracy.to_u8().unwrap();buffer[20..21].copy_from_slice(&central_clock_accuracy.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 18;ret}
}
impl Packet for LeConnectionCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeConnectionCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_connection_complete = match &le_meta_event.child {LeMetaEventDataChild::LeConnectionComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeConnectionComplete"),};Self {event,le_meta_event,le_connection_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_status(&self) -> ErrorCode{ self.le_connection_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_connection_complete.as_ref().connection_handle}
pub fn get_role(&self) -> Role{ self.le_connection_complete.as_ref().role}
pub fn get_peer_address_type(&self) -> AddressType{ self.le_connection_complete.as_ref().peer_address_type}
pub fn get_peer_address(&self) -> Address{ self.le_connection_complete.as_ref().peer_address}
pub fn get_conn_interval(&self) -> u16{ self.le_connection_complete.as_ref().conn_interval}
pub fn get_conn_latency(&self) -> u16{ self.le_connection_complete.as_ref().conn_latency}
pub fn get_supervision_timeout(&self) -> u16{ self.le_connection_complete.as_ref().supervision_timeout}
pub fn get_central_clock_accuracy(&self) -> ClockAccuracy{ self.le_connection_complete.as_ref().central_clock_accuracy}
}
impl Into<EventPacket> for LeConnectionCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeConnectionCompletePacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeConnectionCompleteBuilder {pub fn build(self) -> LeConnectionCompletePacket {let le_connection_complete= Arc::new(LeConnectionCompleteData {status: self.status, connection_handle: self.connection_handle, role: self.role, peer_address_type: self.peer_address_type, peer_address: self.peer_address, conn_interval: self.conn_interval, conn_latency: self.conn_latency, supervision_timeout: self.supervision_timeout, central_clock_accuracy: self.central_clock_accuracy, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::ConnectionComplete, child: LeMetaEventDataChild::LeConnectionComplete(le_connection_complete),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeConnectionCompletePacket::new(event)}
}
impl Into<EventPacket> for LeConnectionCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeConnectionCompleteBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct LeAdvertisingReportData {advertising_reports: Vec::<LeAdvertisingReport>, }
#[derive(Debug, Clone)] pub struct LeAdvertisingReportPacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_advertising_report: Arc<LeAdvertisingReportData>,}
#[derive(Debug)] pub struct LeAdvertisingReportBuilder {pub advertising_reports: Vec::<LeAdvertisingReport>, }
impl LeAdvertisingReportData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeAdvertisingReport".to_string(),    field: "advertising_reports_count".to_string(),    wanted: 4,    got: bytes.len()});}let advertising_reports_count = u8::from_le_bytes([bytes[3]]);let mut advertising_reports: Vec::<LeAdvertisingReport> = Vec::new();let mut parsable_ = &bytes[4..];let count_ = advertising_reports_count as usize;for _ in 0..count_ { match LeAdvertisingReport::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];advertising_reports.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {advertising_reports, })
}
fn write_to(&self, buffer: &mut BytesMut) {buffer[3..4].copy_from_slice(&(self.advertising_reports.len() as u8).to_le_bytes());let mut vec_buffer_ = &mut buffer[4..];for e_ in &self.advertising_reports { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;let ret = ret + self.advertising_reports.iter().fold(0, |acc, x| acc + x.get_total_size());ret}
}
impl Packet for LeAdvertisingReportPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAdvertisingReportPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_advertising_report = match &le_meta_event.child {LeMetaEventDataChild::LeAdvertisingReport(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingReport"),};Self {event,le_meta_event,le_advertising_report,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_advertising_reports(&self) -> &Vec::<LeAdvertisingReport>{ &self.le_advertising_report.as_ref().advertising_reports}
}
impl Into<EventPacket> for LeAdvertisingReportPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeAdvertisingReportPacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeAdvertisingReportBuilder {pub fn build(self) -> LeAdvertisingReportPacket {let le_advertising_report= Arc::new(LeAdvertisingReportData {advertising_reports: self.advertising_reports, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::AdvertisingReport, child: LeMetaEventDataChild::LeAdvertisingReport(le_advertising_report),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeAdvertisingReportPacket::new(event)}
}
impl Into<EventPacket> for LeAdvertisingReportBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeAdvertisingReportBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct LeConnectionUpdateCompleteData {status: ErrorCode, connection_handle: u16, conn_interval: u16, conn_latency: u16, supervision_timeout: u16, }
#[derive(Debug, Clone)] pub struct LeConnectionUpdateCompletePacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_connection_update_complete: Arc<LeConnectionUpdateCompleteData>,}
#[derive(Debug)] pub struct LeConnectionUpdateCompleteBuilder {pub status: ErrorCode, pub connection_handle: u16, pub conn_interval: u16, pub conn_latency: u16, pub supervision_timeout: u16, }
impl LeConnectionUpdateCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeConnectionUpdateComplete".to_string(),    field: "status".to_string(),    wanted: 4,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[3]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeConnectionUpdateComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 6,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[4],bytes[5]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeConnectionUpdateComplete".to_string(),    field: "conn_interval".to_string(),    wanted: 8,    got: bytes.len()});}let conn_interval = u16::from_le_bytes([bytes[6],bytes[7]]);if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeConnectionUpdateComplete".to_string(),    field: "conn_latency".to_string(),    wanted: 10,    got: bytes.len()});}let conn_latency = u16::from_le_bytes([bytes[8],bytes[9]]);if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "LeConnectionUpdateComplete".to_string(),    field: "supervision_timeout".to_string(),    wanted: 12,    got: bytes.len()});}let supervision_timeout = u16::from_le_bytes([bytes[10],bytes[11]]);Ok(Self {status, connection_handle, conn_interval, conn_latency, supervision_timeout, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[3..4].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[4..6].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let conn_interval = self.conn_interval;buffer[6..8].copy_from_slice(&conn_interval.to_le_bytes()[0..2]);let conn_latency = self.conn_latency;buffer[8..10].copy_from_slice(&conn_latency.to_le_bytes()[0..2]);let supervision_timeout = self.supervision_timeout;buffer[10..12].copy_from_slice(&supervision_timeout.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 9;ret}
}
impl Packet for LeConnectionUpdateCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeConnectionUpdateCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_connection_update_complete = match &le_meta_event.child {LeMetaEventDataChild::LeConnectionUpdateComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeConnectionUpdateComplete"),};Self {event,le_meta_event,le_connection_update_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_status(&self) -> ErrorCode{ self.le_connection_update_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_connection_update_complete.as_ref().connection_handle}
pub fn get_conn_interval(&self) -> u16{ self.le_connection_update_complete.as_ref().conn_interval}
pub fn get_conn_latency(&self) -> u16{ self.le_connection_update_complete.as_ref().conn_latency}
pub fn get_supervision_timeout(&self) -> u16{ self.le_connection_update_complete.as_ref().supervision_timeout}
}
impl Into<EventPacket> for LeConnectionUpdateCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeConnectionUpdateCompletePacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeConnectionUpdateCompleteBuilder {pub fn build(self) -> LeConnectionUpdateCompletePacket {let le_connection_update_complete= Arc::new(LeConnectionUpdateCompleteData {status: self.status, connection_handle: self.connection_handle, conn_interval: self.conn_interval, conn_latency: self.conn_latency, supervision_timeout: self.supervision_timeout, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::ConnectionUpdateComplete, child: LeMetaEventDataChild::LeConnectionUpdateComplete(le_connection_update_complete),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeConnectionUpdateCompletePacket::new(event)}
}
impl Into<EventPacket> for LeConnectionUpdateCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeConnectionUpdateCompleteBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct LeReadRemoteFeaturesCompleteData {status: ErrorCode, connection_handle: u16, le_features: u64, }
#[derive(Debug, Clone)] pub struct LeReadRemoteFeaturesCompletePacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_read_remote_features_complete: Arc<LeReadRemoteFeaturesCompleteData>,}
#[derive(Debug)] pub struct LeReadRemoteFeaturesCompleteBuilder {pub status: ErrorCode, pub connection_handle: u16, pub le_features: u64, }
impl LeReadRemoteFeaturesCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeReadRemoteFeaturesComplete".to_string(),    field: "status".to_string(),    wanted: 4,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[3]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeReadRemoteFeaturesComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 6,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[4],bytes[5]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "LeReadRemoteFeaturesComplete".to_string(),    field: "le_features".to_string(),    wanted: 14,    got: bytes.len()});}let le_features = u64::from_le_bytes([bytes[6],bytes[7],bytes[8],bytes[9],bytes[10],bytes[11],bytes[12],bytes[13]]);Ok(Self {status, connection_handle, le_features, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[3..4].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[4..6].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let le_features = self.le_features;buffer[6..14].copy_from_slice(&le_features.to_le_bytes()[0..8]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 11;ret}
}
impl Packet for LeReadRemoteFeaturesCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeReadRemoteFeaturesCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_read_remote_features_complete = match &le_meta_event.child {LeMetaEventDataChild::LeReadRemoteFeaturesComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeReadRemoteFeaturesComplete"),};Self {event,le_meta_event,le_read_remote_features_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_status(&self) -> ErrorCode{ self.le_read_remote_features_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_read_remote_features_complete.as_ref().connection_handle}
pub fn get_le_features(&self) -> u64{ self.le_read_remote_features_complete.as_ref().le_features}
}
impl Into<EventPacket> for LeReadRemoteFeaturesCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeReadRemoteFeaturesCompletePacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeReadRemoteFeaturesCompleteBuilder {pub fn build(self) -> LeReadRemoteFeaturesCompletePacket {let le_read_remote_features_complete= Arc::new(LeReadRemoteFeaturesCompleteData {status: self.status, connection_handle: self.connection_handle, le_features: self.le_features, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::ReadRemoteFeaturesComplete, child: LeMetaEventDataChild::LeReadRemoteFeaturesComplete(le_read_remote_features_complete),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeReadRemoteFeaturesCompletePacket::new(event)}
}
impl Into<EventPacket> for LeReadRemoteFeaturesCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeReadRemoteFeaturesCompleteBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct LeLongTermKeyRequestData {connection_handle: u16, random_number: [u8; 8], encrypted_diversifier: u16, }
#[derive(Debug, Clone)] pub struct LeLongTermKeyRequestPacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_long_term_key_request: Arc<LeLongTermKeyRequestData>,}
#[derive(Debug)] pub struct LeLongTermKeyRequestBuilder {pub connection_handle: u16, pub random_number: [u8; 8], pub encrypted_diversifier: u16, }
impl LeLongTermKeyRequestData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeLongTermKeyRequest".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "LeLongTermKeyRequest".to_string(),    field: "random_number".to_string(),    wanted: 13,    got: bytes.len()});}let random_number = bytes[5..13].try_into().unwrap();if bytes.len() < 15 { return Err(Error::InvalidLengthError{    obj: "LeLongTermKeyRequest".to_string(),    field: "encrypted_diversifier".to_string(),    wanted: 15,    got: bytes.len()});}let encrypted_diversifier = u16::from_le_bytes([bytes[13],bytes[14]]);Ok(Self {connection_handle, random_number, encrypted_diversifier, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);&buffer[5..13].copy_from_slice(&self.random_number);let encrypted_diversifier = self.encrypted_diversifier;buffer[13..15].copy_from_slice(&encrypted_diversifier.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 12;ret}
}
impl Packet for LeLongTermKeyRequestPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeLongTermKeyRequestPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_long_term_key_request = match &le_meta_event.child {LeMetaEventDataChild::LeLongTermKeyRequest(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeLongTermKeyRequest"),};Self {event,le_meta_event,le_long_term_key_request,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_connection_handle(&self) -> u16{ self.le_long_term_key_request.as_ref().connection_handle}
pub fn get_random_number(&self) -> &[u8; 8]{ &self.le_long_term_key_request.as_ref().random_number}
pub fn get_encrypted_diversifier(&self) -> u16{ self.le_long_term_key_request.as_ref().encrypted_diversifier}
}
impl Into<EventPacket> for LeLongTermKeyRequestPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeLongTermKeyRequestPacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeLongTermKeyRequestBuilder {pub fn build(self) -> LeLongTermKeyRequestPacket {let le_long_term_key_request= Arc::new(LeLongTermKeyRequestData {connection_handle: self.connection_handle, random_number: self.random_number, encrypted_diversifier: self.encrypted_diversifier, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::LongTermKeyRequest, child: LeMetaEventDataChild::LeLongTermKeyRequest(le_long_term_key_request),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeLongTermKeyRequestPacket::new(event)}
}
impl Into<EventPacket> for LeLongTermKeyRequestBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeLongTermKeyRequestBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct LeRemoteConnectionParameterRequestData {connection_handle: u16, interval_min: u16, interval_max: u16, latency: u16, timeout: u16, }
#[derive(Debug, Clone)] pub struct LeRemoteConnectionParameterRequestPacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_remote_connection_parameter_request: Arc<LeRemoteConnectionParameterRequestData>,}
#[derive(Debug)] pub struct LeRemoteConnectionParameterRequestBuilder {pub connection_handle: u16, pub interval_min: u16, pub interval_max: u16, pub latency: u16, pub timeout: u16, }
impl LeRemoteConnectionParameterRequestData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeRemoteConnectionParameterRequest".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeRemoteConnectionParameterRequest".to_string(),    field: "interval_min".to_string(),    wanted: 7,    got: bytes.len()});}let interval_min = u16::from_le_bytes([bytes[5],bytes[6]]);if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeRemoteConnectionParameterRequest".to_string(),    field: "interval_max".to_string(),    wanted: 9,    got: bytes.len()});}let interval_max = u16::from_le_bytes([bytes[7],bytes[8]]);if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "LeRemoteConnectionParameterRequest".to_string(),    field: "latency".to_string(),    wanted: 11,    got: bytes.len()});}let latency = u16::from_le_bytes([bytes[9],bytes[10]]);if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "LeRemoteConnectionParameterRequest".to_string(),    field: "timeout".to_string(),    wanted: 13,    got: bytes.len()});}let timeout = u16::from_le_bytes([bytes[11],bytes[12]]);Ok(Self {connection_handle, interval_min, interval_max, latency, timeout, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let interval_min = self.interval_min;buffer[5..7].copy_from_slice(&interval_min.to_le_bytes()[0..2]);let interval_max = self.interval_max;buffer[7..9].copy_from_slice(&interval_max.to_le_bytes()[0..2]);let latency = self.latency;buffer[9..11].copy_from_slice(&latency.to_le_bytes()[0..2]);let timeout = self.timeout;buffer[11..13].copy_from_slice(&timeout.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 10;ret}
}
impl Packet for LeRemoteConnectionParameterRequestPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeRemoteConnectionParameterRequestPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_remote_connection_parameter_request = match &le_meta_event.child {LeMetaEventDataChild::LeRemoteConnectionParameterRequest(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeRemoteConnectionParameterRequest"),};Self {event,le_meta_event,le_remote_connection_parameter_request,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_connection_handle(&self) -> u16{ self.le_remote_connection_parameter_request.as_ref().connection_handle}
pub fn get_interval_min(&self) -> u16{ self.le_remote_connection_parameter_request.as_ref().interval_min}
pub fn get_interval_max(&self) -> u16{ self.le_remote_connection_parameter_request.as_ref().interval_max}
pub fn get_latency(&self) -> u16{ self.le_remote_connection_parameter_request.as_ref().latency}
pub fn get_timeout(&self) -> u16{ self.le_remote_connection_parameter_request.as_ref().timeout}
}
impl Into<EventPacket> for LeRemoteConnectionParameterRequestPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeRemoteConnectionParameterRequestPacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeRemoteConnectionParameterRequestBuilder {pub fn build(self) -> LeRemoteConnectionParameterRequestPacket {let le_remote_connection_parameter_request= Arc::new(LeRemoteConnectionParameterRequestData {connection_handle: self.connection_handle, interval_min: self.interval_min, interval_max: self.interval_max, latency: self.latency, timeout: self.timeout, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::RemoteConnectionParameterRequest, child: LeMetaEventDataChild::LeRemoteConnectionParameterRequest(le_remote_connection_parameter_request),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeRemoteConnectionParameterRequestPacket::new(event)}
}
impl Into<EventPacket> for LeRemoteConnectionParameterRequestBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeRemoteConnectionParameterRequestBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct LeDataLengthChangeData {connection_handle: u16, max_tx_octets: u16, max_tx_time: u16, max_rx_octets: u16, max_rx_time: u16, }
#[derive(Debug, Clone)] pub struct LeDataLengthChangePacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_data_length_change: Arc<LeDataLengthChangeData>,}
#[derive(Debug)] pub struct LeDataLengthChangeBuilder {pub connection_handle: u16, pub max_tx_octets: u16, pub max_tx_time: u16, pub max_rx_octets: u16, pub max_rx_time: u16, }
impl LeDataLengthChangeData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeDataLengthChange".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeDataLengthChange".to_string(),    field: "max_tx_octets".to_string(),    wanted: 7,    got: bytes.len()});}let max_tx_octets = u16::from_le_bytes([bytes[5],bytes[6]]);if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeDataLengthChange".to_string(),    field: "max_tx_time".to_string(),    wanted: 9,    got: bytes.len()});}let max_tx_time = u16::from_le_bytes([bytes[7],bytes[8]]);if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "LeDataLengthChange".to_string(),    field: "max_rx_octets".to_string(),    wanted: 11,    got: bytes.len()});}let max_rx_octets = u16::from_le_bytes([bytes[9],bytes[10]]);if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "LeDataLengthChange".to_string(),    field: "max_rx_time".to_string(),    wanted: 13,    got: bytes.len()});}let max_rx_time = u16::from_le_bytes([bytes[11],bytes[12]]);Ok(Self {connection_handle, max_tx_octets, max_tx_time, max_rx_octets, max_rx_time, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let max_tx_octets = self.max_tx_octets;buffer[5..7].copy_from_slice(&max_tx_octets.to_le_bytes()[0..2]);let max_tx_time = self.max_tx_time;buffer[7..9].copy_from_slice(&max_tx_time.to_le_bytes()[0..2]);let max_rx_octets = self.max_rx_octets;buffer[9..11].copy_from_slice(&max_rx_octets.to_le_bytes()[0..2]);let max_rx_time = self.max_rx_time;buffer[11..13].copy_from_slice(&max_rx_time.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 10;ret}
}
impl Packet for LeDataLengthChangePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeDataLengthChangePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_data_length_change = match &le_meta_event.child {LeMetaEventDataChild::LeDataLengthChange(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeDataLengthChange"),};Self {event,le_meta_event,le_data_length_change,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_connection_handle(&self) -> u16{ self.le_data_length_change.as_ref().connection_handle}
pub fn get_max_tx_octets(&self) -> u16{ self.le_data_length_change.as_ref().max_tx_octets}
pub fn get_max_tx_time(&self) -> u16{ self.le_data_length_change.as_ref().max_tx_time}
pub fn get_max_rx_octets(&self) -> u16{ self.le_data_length_change.as_ref().max_rx_octets}
pub fn get_max_rx_time(&self) -> u16{ self.le_data_length_change.as_ref().max_rx_time}
}
impl Into<EventPacket> for LeDataLengthChangePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeDataLengthChangePacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeDataLengthChangeBuilder {pub fn build(self) -> LeDataLengthChangePacket {let le_data_length_change= Arc::new(LeDataLengthChangeData {connection_handle: self.connection_handle, max_tx_octets: self.max_tx_octets, max_tx_time: self.max_tx_time, max_rx_octets: self.max_rx_octets, max_rx_time: self.max_rx_time, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::DataLengthChange, child: LeMetaEventDataChild::LeDataLengthChange(le_data_length_change),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeDataLengthChangePacket::new(event)}
}
impl Into<EventPacket> for LeDataLengthChangeBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeDataLengthChangeBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct ReadLocalP256PublicKeyCompleteData {status: ErrorCode, local_p_256_public_key: [u8; 64], }
#[derive(Debug, Clone)] pub struct ReadLocalP256PublicKeyCompletePacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,read_local_p256_public_key_complete: Arc<ReadLocalP256PublicKeyCompleteData>,}
#[derive(Debug)] pub struct ReadLocalP256PublicKeyCompleteBuilder {pub status: ErrorCode, pub local_p_256_public_key: [u8; 64], }
impl ReadLocalP256PublicKeyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "ReadLocalP256PublicKeyComplete".to_string(),    field: "status".to_string(),    wanted: 4,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[3]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 68 { return Err(Error::InvalidLengthError{    obj: "ReadLocalP256PublicKeyComplete".to_string(),    field: "local_p_256_public_key".to_string(),    wanted: 68,    got: bytes.len()});}let local_p_256_public_key = bytes[4..68].try_into().unwrap();Ok(Self {status, local_p_256_public_key, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[3..4].copy_from_slice(&status.to_le_bytes()[0..1]);&buffer[4..68].copy_from_slice(&self.local_p_256_public_key);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 65;ret}
}
impl Packet for ReadLocalP256PublicKeyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl ReadLocalP256PublicKeyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let read_local_p256_public_key_complete = match &le_meta_event.child {LeMetaEventDataChild::ReadLocalP256PublicKeyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not ReadLocalP256PublicKeyComplete"),};Self {event,le_meta_event,read_local_p256_public_key_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_status(&self) -> ErrorCode{ self.read_local_p256_public_key_complete.as_ref().status}
pub fn get_local_p_256_public_key(&self) -> &[u8; 64]{ &self.read_local_p256_public_key_complete.as_ref().local_p_256_public_key}
}
impl Into<EventPacket> for ReadLocalP256PublicKeyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for ReadLocalP256PublicKeyCompletePacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl ReadLocalP256PublicKeyCompleteBuilder {pub fn build(self) -> ReadLocalP256PublicKeyCompletePacket {let read_local_p256_public_key_complete= Arc::new(ReadLocalP256PublicKeyCompleteData {status: self.status, local_p_256_public_key: self.local_p_256_public_key, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::ReadLocalP256PublicKeyComplete, child: LeMetaEventDataChild::ReadLocalP256PublicKeyComplete(read_local_p256_public_key_complete),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});ReadLocalP256PublicKeyCompletePacket::new(event)}
}
impl Into<EventPacket> for ReadLocalP256PublicKeyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for ReadLocalP256PublicKeyCompleteBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct GenerateDhKeyCompleteData {status: ErrorCode, dh_key: [u8; 32], }
#[derive(Debug, Clone)] pub struct GenerateDhKeyCompletePacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,generate_dh_key_complete: Arc<GenerateDhKeyCompleteData>,}
#[derive(Debug)] pub struct GenerateDhKeyCompleteBuilder {pub status: ErrorCode, pub dh_key: [u8; 32], }
impl GenerateDhKeyCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "GenerateDhKeyComplete".to_string(),    field: "status".to_string(),    wanted: 4,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[3]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 36 { return Err(Error::InvalidLengthError{    obj: "GenerateDhKeyComplete".to_string(),    field: "dh_key".to_string(),    wanted: 36,    got: bytes.len()});}let dh_key = bytes[4..36].try_into().unwrap();Ok(Self {status, dh_key, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[3..4].copy_from_slice(&status.to_le_bytes()[0..1]);&buffer[4..36].copy_from_slice(&self.dh_key);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 33;ret}
}
impl Packet for GenerateDhKeyCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl GenerateDhKeyCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let generate_dh_key_complete = match &le_meta_event.child {LeMetaEventDataChild::GenerateDhKeyComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not GenerateDhKeyComplete"),};Self {event,le_meta_event,generate_dh_key_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_status(&self) -> ErrorCode{ self.generate_dh_key_complete.as_ref().status}
pub fn get_dh_key(&self) -> &[u8; 32]{ &self.generate_dh_key_complete.as_ref().dh_key}
}
impl Into<EventPacket> for GenerateDhKeyCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for GenerateDhKeyCompletePacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl GenerateDhKeyCompleteBuilder {pub fn build(self) -> GenerateDhKeyCompletePacket {let generate_dh_key_complete= Arc::new(GenerateDhKeyCompleteData {status: self.status, dh_key: self.dh_key, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::GenerateDhkeyComplete, child: LeMetaEventDataChild::GenerateDhKeyComplete(generate_dh_key_complete),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});GenerateDhKeyCompletePacket::new(event)}
}
impl Into<EventPacket> for GenerateDhKeyCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for GenerateDhKeyCompleteBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct LeEnhancedConnectionCompleteData {status: ErrorCode, connection_handle: u16, role: Role, peer_address_type: AddressType, peer_address: Address, local_resolvable_private_address: Address, peer_resolvable_private_address: Address, conn_interval: u16, conn_latency: u16, supervision_timeout: u16, central_clock_accuracy: ClockAccuracy, }
#[derive(Debug, Clone)] pub struct LeEnhancedConnectionCompletePacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_enhanced_connection_complete: Arc<LeEnhancedConnectionCompleteData>,}
#[derive(Debug)] pub struct LeEnhancedConnectionCompleteBuilder {pub status: ErrorCode, pub connection_handle: u16, pub role: Role, pub peer_address_type: AddressType, pub peer_address: Address, pub local_resolvable_private_address: Address, pub peer_resolvable_private_address: Address, pub conn_interval: u16, pub conn_latency: u16, pub supervision_timeout: u16, pub central_clock_accuracy: ClockAccuracy, }
impl LeEnhancedConnectionCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedConnectionComplete".to_string(),    field: "status".to_string(),    wanted: 4,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[3]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedConnectionComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 6,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[4],bytes[5]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedConnectionComplete".to_string(),    field: "role".to_string(),    wanted: 7,    got: bytes.len()});}let role = u8::from_le_bytes([bytes[6]]);let role = Role::from_u8(role).unwrap();if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedConnectionComplete".to_string(),    field: "peer_address_type".to_string(),    wanted: 8,    got: bytes.len()});}let peer_address_type = u8::from_le_bytes([bytes[7]]);let peer_address_type = AddressType::from_u8(peer_address_type).unwrap();if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedConnectionComplete".to_string(),    field: "peer_address".to_string(),    wanted: 14,    got: bytes.len()});}let peer_address = bytes[8..14].try_into().unwrap();if bytes.len() < 20 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedConnectionComplete".to_string(),    field: "local_resolvable_private_address".to_string(),    wanted: 20,    got: bytes.len()});}let local_resolvable_private_address = bytes[14..20].try_into().unwrap();if bytes.len() < 26 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedConnectionComplete".to_string(),    field: "peer_resolvable_private_address".to_string(),    wanted: 26,    got: bytes.len()});}let peer_resolvable_private_address = bytes[20..26].try_into().unwrap();if bytes.len() < 28 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedConnectionComplete".to_string(),    field: "conn_interval".to_string(),    wanted: 28,    got: bytes.len()});}let conn_interval = u16::from_le_bytes([bytes[26],bytes[27]]);if bytes.len() < 30 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedConnectionComplete".to_string(),    field: "conn_latency".to_string(),    wanted: 30,    got: bytes.len()});}let conn_latency = u16::from_le_bytes([bytes[28],bytes[29]]);if bytes.len() < 32 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedConnectionComplete".to_string(),    field: "supervision_timeout".to_string(),    wanted: 32,    got: bytes.len()});}let supervision_timeout = u16::from_le_bytes([bytes[30],bytes[31]]);if bytes.len() < 33 { return Err(Error::InvalidLengthError{    obj: "LeEnhancedConnectionComplete".to_string(),    field: "central_clock_accuracy".to_string(),    wanted: 33,    got: bytes.len()});}let central_clock_accuracy = u8::from_le_bytes([bytes[32]]);let central_clock_accuracy = ClockAccuracy::from_u8(central_clock_accuracy).unwrap();Ok(Self {status, connection_handle, role, peer_address_type, peer_address, local_resolvable_private_address, peer_resolvable_private_address, conn_interval, conn_latency, supervision_timeout, central_clock_accuracy, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[3..4].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[4..6].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let role = self.role.to_u8().unwrap();buffer[6..7].copy_from_slice(&role.to_le_bytes()[0..1]);let peer_address_type = self.peer_address_type.to_u8().unwrap();buffer[7..8].copy_from_slice(&peer_address_type.to_le_bytes()[0..1]);let peer_address: [u8; 6] = self.peer_address.into();buffer[8..14].copy_from_slice(&peer_address);let local_resolvable_private_address: [u8; 6] = self.local_resolvable_private_address.into();buffer[14..20].copy_from_slice(&local_resolvable_private_address);let peer_resolvable_private_address: [u8; 6] = self.peer_resolvable_private_address.into();buffer[20..26].copy_from_slice(&peer_resolvable_private_address);let conn_interval = self.conn_interval;buffer[26..28].copy_from_slice(&conn_interval.to_le_bytes()[0..2]);let conn_latency = self.conn_latency;buffer[28..30].copy_from_slice(&conn_latency.to_le_bytes()[0..2]);let supervision_timeout = self.supervision_timeout;buffer[30..32].copy_from_slice(&supervision_timeout.to_le_bytes()[0..2]);let central_clock_accuracy = self.central_clock_accuracy.to_u8().unwrap();buffer[32..33].copy_from_slice(&central_clock_accuracy.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 30;ret}
}
impl Packet for LeEnhancedConnectionCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeEnhancedConnectionCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_enhanced_connection_complete = match &le_meta_event.child {LeMetaEventDataChild::LeEnhancedConnectionComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeEnhancedConnectionComplete"),};Self {event,le_meta_event,le_enhanced_connection_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_status(&self) -> ErrorCode{ self.le_enhanced_connection_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_enhanced_connection_complete.as_ref().connection_handle}
pub fn get_role(&self) -> Role{ self.le_enhanced_connection_complete.as_ref().role}
pub fn get_peer_address_type(&self) -> AddressType{ self.le_enhanced_connection_complete.as_ref().peer_address_type}
pub fn get_peer_address(&self) -> Address{ self.le_enhanced_connection_complete.as_ref().peer_address}
pub fn get_local_resolvable_private_address(&self) -> Address{ self.le_enhanced_connection_complete.as_ref().local_resolvable_private_address}
pub fn get_peer_resolvable_private_address(&self) -> Address{ self.le_enhanced_connection_complete.as_ref().peer_resolvable_private_address}
pub fn get_conn_interval(&self) -> u16{ self.le_enhanced_connection_complete.as_ref().conn_interval}
pub fn get_conn_latency(&self) -> u16{ self.le_enhanced_connection_complete.as_ref().conn_latency}
pub fn get_supervision_timeout(&self) -> u16{ self.le_enhanced_connection_complete.as_ref().supervision_timeout}
pub fn get_central_clock_accuracy(&self) -> ClockAccuracy{ self.le_enhanced_connection_complete.as_ref().central_clock_accuracy}
}
impl Into<EventPacket> for LeEnhancedConnectionCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeEnhancedConnectionCompletePacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeEnhancedConnectionCompleteBuilder {pub fn build(self) -> LeEnhancedConnectionCompletePacket {let le_enhanced_connection_complete= Arc::new(LeEnhancedConnectionCompleteData {status: self.status, connection_handle: self.connection_handle, role: self.role, peer_address_type: self.peer_address_type, peer_address: self.peer_address, local_resolvable_private_address: self.local_resolvable_private_address, peer_resolvable_private_address: self.peer_resolvable_private_address, conn_interval: self.conn_interval, conn_latency: self.conn_latency, supervision_timeout: self.supervision_timeout, central_clock_accuracy: self.central_clock_accuracy, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::EnhancedConnectionComplete, child: LeMetaEventDataChild::LeEnhancedConnectionComplete(le_enhanced_connection_complete),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeEnhancedConnectionCompletePacket::new(event)}
}
impl Into<EventPacket> for LeEnhancedConnectionCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeEnhancedConnectionCompleteBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct LeDirectedAdvertisingReportData {advertising_reports: Vec::<LeDirectedAdvertisingReport>, }
#[derive(Debug, Clone)] pub struct LeDirectedAdvertisingReportPacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_directed_advertising_report: Arc<LeDirectedAdvertisingReportData>,}
#[derive(Debug)] pub struct LeDirectedAdvertisingReportBuilder {pub advertising_reports: Vec::<LeDirectedAdvertisingReport>, }
impl LeDirectedAdvertisingReportData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeDirectedAdvertisingReport".to_string(),    field: "advertising_reports_count".to_string(),    wanted: 4,    got: bytes.len()});}let advertising_reports_count = u8::from_le_bytes([bytes[3]]);let mut advertising_reports: Vec::<LeDirectedAdvertisingReport> = Vec::new();let mut parsable_ = &bytes[4..];let count_ = advertising_reports_count as usize;for _ in 0..count_ { match LeDirectedAdvertisingReport::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];advertising_reports.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {advertising_reports, })
}
fn write_to(&self, buffer: &mut BytesMut) {buffer[3..4].copy_from_slice(&(self.advertising_reports.len() as u8).to_le_bytes());let mut vec_buffer_ = &mut buffer[4..];for e_ in &self.advertising_reports { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;let ret = ret + (self.advertising_reports.len() * ((/* Bits: */ 128 + /* Dynamic: */ 0) / 8));ret}
}
impl Packet for LeDirectedAdvertisingReportPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeDirectedAdvertisingReportPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_directed_advertising_report = match &le_meta_event.child {LeMetaEventDataChild::LeDirectedAdvertisingReport(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeDirectedAdvertisingReport"),};Self {event,le_meta_event,le_directed_advertising_report,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_advertising_reports(&self) -> &Vec::<LeDirectedAdvertisingReport>{ &self.le_directed_advertising_report.as_ref().advertising_reports}
}
impl Into<EventPacket> for LeDirectedAdvertisingReportPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeDirectedAdvertisingReportPacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeDirectedAdvertisingReportBuilder {pub fn build(self) -> LeDirectedAdvertisingReportPacket {let le_directed_advertising_report= Arc::new(LeDirectedAdvertisingReportData {advertising_reports: self.advertising_reports, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::DirectedAdvertisingReport, child: LeMetaEventDataChild::LeDirectedAdvertisingReport(le_directed_advertising_report),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeDirectedAdvertisingReportPacket::new(event)}
}
impl Into<EventPacket> for LeDirectedAdvertisingReportBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeDirectedAdvertisingReportBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct LePhyUpdateCompleteData {status: ErrorCode, connection_handle: u16, tx_phy: u8, rx_phy: u8, }
#[derive(Debug, Clone)] pub struct LePhyUpdateCompletePacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_phy_update_complete: Arc<LePhyUpdateCompleteData>,}
#[derive(Debug)] pub struct LePhyUpdateCompleteBuilder {pub status: ErrorCode, pub connection_handle: u16, pub tx_phy: u8, pub rx_phy: u8, }
impl LePhyUpdateCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LePhyUpdateComplete".to_string(),    field: "status".to_string(),    wanted: 4,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[3]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LePhyUpdateComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 6,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[4],bytes[5]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LePhyUpdateComplete".to_string(),    field: "tx_phy".to_string(),    wanted: 7,    got: bytes.len()});}let tx_phy = u8::from_le_bytes([bytes[6]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LePhyUpdateComplete".to_string(),    field: "rx_phy".to_string(),    wanted: 8,    got: bytes.len()});}let rx_phy = u8::from_le_bytes([bytes[7]]);Ok(Self {status, connection_handle, tx_phy, rx_phy, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[3..4].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[4..6].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let tx_phy = self.tx_phy;buffer[6..7].copy_from_slice(&tx_phy.to_le_bytes()[0..1]);let rx_phy = self.rx_phy;buffer[7..8].copy_from_slice(&rx_phy.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 5;ret}
}
impl Packet for LePhyUpdateCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LePhyUpdateCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_phy_update_complete = match &le_meta_event.child {LeMetaEventDataChild::LePhyUpdateComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LePhyUpdateComplete"),};Self {event,le_meta_event,le_phy_update_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_status(&self) -> ErrorCode{ self.le_phy_update_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_phy_update_complete.as_ref().connection_handle}
pub fn get_tx_phy(&self) -> u8{ self.le_phy_update_complete.as_ref().tx_phy}
pub fn get_rx_phy(&self) -> u8{ self.le_phy_update_complete.as_ref().rx_phy}
}
impl Into<EventPacket> for LePhyUpdateCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LePhyUpdateCompletePacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LePhyUpdateCompleteBuilder {pub fn build(self) -> LePhyUpdateCompletePacket {let le_phy_update_complete= Arc::new(LePhyUpdateCompleteData {status: self.status, connection_handle: self.connection_handle, tx_phy: self.tx_phy, rx_phy: self.rx_phy, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::PhyUpdateComplete, child: LeMetaEventDataChild::LePhyUpdateComplete(le_phy_update_complete),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LePhyUpdateCompletePacket::new(event)}
}
impl Into<EventPacket> for LePhyUpdateCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LePhyUpdateCompleteBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct LeExtendedAdvertisingReportData {advertising_reports: Vec::<LeExtendedAdvertisingReport>, }
#[derive(Debug, Clone)] pub struct LeExtendedAdvertisingReportPacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_extended_advertising_report: Arc<LeExtendedAdvertisingReportData>,}
#[derive(Debug)] pub struct LeExtendedAdvertisingReportBuilder {pub advertising_reports: Vec::<LeExtendedAdvertisingReport>, }
impl LeExtendedAdvertisingReportData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeExtendedAdvertisingReport".to_string(),    field: "advertising_reports_count".to_string(),    wanted: 4,    got: bytes.len()});}let advertising_reports_count = u8::from_le_bytes([bytes[3]]);let mut advertising_reports: Vec::<LeExtendedAdvertisingReport> = Vec::new();let mut parsable_ = &bytes[4..];let count_ = advertising_reports_count as usize;for _ in 0..count_ { match LeExtendedAdvertisingReport::parse(&parsable_) {  Ok(parsed) => {   parsable_ = &parsable_[parsed.get_total_size()..];advertising_reports.push(parsed);  },  Err(Error::ImpossibleStructError) => break,  Err(e) => return Err(e), }}Ok(Self {advertising_reports, })
}
fn write_to(&self, buffer: &mut BytesMut) {buffer[3..4].copy_from_slice(&(self.advertising_reports.len() as u8).to_le_bytes());let mut vec_buffer_ = &mut buffer[4..];for e_ in &self.advertising_reports { e_.write_to(&mut vec_buffer_[0..e_.get_total_size()]); vec_buffer_ = &mut vec_buffer_[e_.get_total_size()..];}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;let ret = ret + self.advertising_reports.iter().fold(0, |acc, x| acc + x.get_total_size());ret}
}
impl Packet for LeExtendedAdvertisingReportPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeExtendedAdvertisingReportPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_extended_advertising_report = match &le_meta_event.child {LeMetaEventDataChild::LeExtendedAdvertisingReport(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeExtendedAdvertisingReport"),};Self {event,le_meta_event,le_extended_advertising_report,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_advertising_reports(&self) -> &Vec::<LeExtendedAdvertisingReport>{ &self.le_extended_advertising_report.as_ref().advertising_reports}
}
impl Into<EventPacket> for LeExtendedAdvertisingReportPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeExtendedAdvertisingReportPacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeExtendedAdvertisingReportBuilder {pub fn build(self) -> LeExtendedAdvertisingReportPacket {let le_extended_advertising_report= Arc::new(LeExtendedAdvertisingReportData {advertising_reports: self.advertising_reports, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::ExtendedAdvertisingReport, child: LeMetaEventDataChild::LeExtendedAdvertisingReport(le_extended_advertising_report),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeExtendedAdvertisingReportPacket::new(event)}
}
impl Into<EventPacket> for LeExtendedAdvertisingReportBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeExtendedAdvertisingReportBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] enum LePeriodicAdvertisingSyncEstablishedDataChild {Payload(Bytes),None,}
impl LePeriodicAdvertisingSyncEstablishedDataChild {fn get_total_size(&self) -> usize {match self {LePeriodicAdvertisingSyncEstablishedDataChild::Payload(p) => p.len(),LePeriodicAdvertisingSyncEstablishedDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LePeriodicAdvertisingSyncEstablishedChild {Payload(Bytes),None,}
#[derive(Debug)] struct LePeriodicAdvertisingSyncEstablishedData {child: LePeriodicAdvertisingSyncEstablishedDataChild,}
#[derive(Debug, Clone)] pub struct LePeriodicAdvertisingSyncEstablishedPacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_periodic_advertising_sync_established: Arc<LePeriodicAdvertisingSyncEstablishedData>,}
#[derive(Debug)] pub struct LePeriodicAdvertisingSyncEstablishedBuilder {pub payload: Option<Bytes>,}
impl LePeriodicAdvertisingSyncEstablishedData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {let payload: Vec::<u8> = bytes[3..].into();let child = if payload.len() > 0 {LePeriodicAdvertisingSyncEstablishedDataChild::Payload(Bytes::from(payload))} else {LePeriodicAdvertisingSyncEstablishedDataChild::None};Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {LePeriodicAdvertisingSyncEstablishedDataChild::Payload(p) => buffer[3..].copy_from_slice(&p[..]),LePeriodicAdvertisingSyncEstablishedDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LePeriodicAdvertisingSyncEstablishedPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LePeriodicAdvertisingSyncEstablishedPacket { pub fn specialize(&self) -> LePeriodicAdvertisingSyncEstablishedChild { match &self.le_periodic_advertising_sync_established.child {LePeriodicAdvertisingSyncEstablishedDataChild::Payload(p) => LePeriodicAdvertisingSyncEstablishedChild::Payload(p.clone()),LePeriodicAdvertisingSyncEstablishedDataChild::None => LePeriodicAdvertisingSyncEstablishedChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_periodic_advertising_sync_established = match &le_meta_event.child {LeMetaEventDataChild::LePeriodicAdvertisingSyncEstablished(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LePeriodicAdvertisingSyncEstablished"),};Self {event,le_meta_event,le_periodic_advertising_sync_established,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
}
impl Into<EventPacket> for LePeriodicAdvertisingSyncEstablishedPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LePeriodicAdvertisingSyncEstablishedPacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LePeriodicAdvertisingSyncEstablishedBuilder {pub fn build(self) -> LePeriodicAdvertisingSyncEstablishedPacket {let le_periodic_advertising_sync_established= Arc::new(LePeriodicAdvertisingSyncEstablishedData {child: match self.payload { None => LePeriodicAdvertisingSyncEstablishedDataChild::None,Some(bytes) => LePeriodicAdvertisingSyncEstablishedDataChild::Payload(bytes),},});let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::PeriodicAdvertisingSyncEstablished, child: LeMetaEventDataChild::LePeriodicAdvertisingSyncEstablished(le_periodic_advertising_sync_established),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LePeriodicAdvertisingSyncEstablishedPacket::new(event)}
}
impl Into<EventPacket> for LePeriodicAdvertisingSyncEstablishedBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LePeriodicAdvertisingSyncEstablishedBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] enum LePeriodicAdvertisingReportDataChild {Payload(Bytes),None,}
impl LePeriodicAdvertisingReportDataChild {fn get_total_size(&self) -> usize {match self {LePeriodicAdvertisingReportDataChild::Payload(p) => p.len(),LePeriodicAdvertisingReportDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LePeriodicAdvertisingReportChild {Payload(Bytes),None,}
#[derive(Debug)] struct LePeriodicAdvertisingReportData {child: LePeriodicAdvertisingReportDataChild,}
#[derive(Debug, Clone)] pub struct LePeriodicAdvertisingReportPacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_periodic_advertising_report: Arc<LePeriodicAdvertisingReportData>,}
#[derive(Debug)] pub struct LePeriodicAdvertisingReportBuilder {pub payload: Option<Bytes>,}
impl LePeriodicAdvertisingReportData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {let payload: Vec::<u8> = bytes[3..].into();let child = if payload.len() > 0 {LePeriodicAdvertisingReportDataChild::Payload(Bytes::from(payload))} else {LePeriodicAdvertisingReportDataChild::None};Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {LePeriodicAdvertisingReportDataChild::Payload(p) => buffer[3..].copy_from_slice(&p[..]),LePeriodicAdvertisingReportDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LePeriodicAdvertisingReportPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LePeriodicAdvertisingReportPacket { pub fn specialize(&self) -> LePeriodicAdvertisingReportChild { match &self.le_periodic_advertising_report.child {LePeriodicAdvertisingReportDataChild::Payload(p) => LePeriodicAdvertisingReportChild::Payload(p.clone()),LePeriodicAdvertisingReportDataChild::None => LePeriodicAdvertisingReportChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_periodic_advertising_report = match &le_meta_event.child {LeMetaEventDataChild::LePeriodicAdvertisingReport(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LePeriodicAdvertisingReport"),};Self {event,le_meta_event,le_periodic_advertising_report,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
}
impl Into<EventPacket> for LePeriodicAdvertisingReportPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LePeriodicAdvertisingReportPacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LePeriodicAdvertisingReportBuilder {pub fn build(self) -> LePeriodicAdvertisingReportPacket {let le_periodic_advertising_report= Arc::new(LePeriodicAdvertisingReportData {child: match self.payload { None => LePeriodicAdvertisingReportDataChild::None,Some(bytes) => LePeriodicAdvertisingReportDataChild::Payload(bytes),},});let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::PeriodicAdvertisingReport, child: LeMetaEventDataChild::LePeriodicAdvertisingReport(le_periodic_advertising_report),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LePeriodicAdvertisingReportPacket::new(event)}
}
impl Into<EventPacket> for LePeriodicAdvertisingReportBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LePeriodicAdvertisingReportBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] enum LePeriodicAdvertisingSyncLostDataChild {Payload(Bytes),None,}
impl LePeriodicAdvertisingSyncLostDataChild {fn get_total_size(&self) -> usize {match self {LePeriodicAdvertisingSyncLostDataChild::Payload(p) => p.len(),LePeriodicAdvertisingSyncLostDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LePeriodicAdvertisingSyncLostChild {Payload(Bytes),None,}
#[derive(Debug)] struct LePeriodicAdvertisingSyncLostData {child: LePeriodicAdvertisingSyncLostDataChild,}
#[derive(Debug, Clone)] pub struct LePeriodicAdvertisingSyncLostPacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_periodic_advertising_sync_lost: Arc<LePeriodicAdvertisingSyncLostData>,}
#[derive(Debug)] pub struct LePeriodicAdvertisingSyncLostBuilder {pub payload: Option<Bytes>,}
impl LePeriodicAdvertisingSyncLostData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {let payload: Vec::<u8> = bytes[3..].into();let child = if payload.len() > 0 {LePeriodicAdvertisingSyncLostDataChild::Payload(Bytes::from(payload))} else {LePeriodicAdvertisingSyncLostDataChild::None};Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {LePeriodicAdvertisingSyncLostDataChild::Payload(p) => buffer[3..].copy_from_slice(&p[..]),LePeriodicAdvertisingSyncLostDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LePeriodicAdvertisingSyncLostPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LePeriodicAdvertisingSyncLostPacket { pub fn specialize(&self) -> LePeriodicAdvertisingSyncLostChild { match &self.le_periodic_advertising_sync_lost.child {LePeriodicAdvertisingSyncLostDataChild::Payload(p) => LePeriodicAdvertisingSyncLostChild::Payload(p.clone()),LePeriodicAdvertisingSyncLostDataChild::None => LePeriodicAdvertisingSyncLostChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_periodic_advertising_sync_lost = match &le_meta_event.child {LeMetaEventDataChild::LePeriodicAdvertisingSyncLost(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LePeriodicAdvertisingSyncLost"),};Self {event,le_meta_event,le_periodic_advertising_sync_lost,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
}
impl Into<EventPacket> for LePeriodicAdvertisingSyncLostPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LePeriodicAdvertisingSyncLostPacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LePeriodicAdvertisingSyncLostBuilder {pub fn build(self) -> LePeriodicAdvertisingSyncLostPacket {let le_periodic_advertising_sync_lost= Arc::new(LePeriodicAdvertisingSyncLostData {child: match self.payload { None => LePeriodicAdvertisingSyncLostDataChild::None,Some(bytes) => LePeriodicAdvertisingSyncLostDataChild::Payload(bytes),},});let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::PeriodicAdvertisingSyncLost, child: LeMetaEventDataChild::LePeriodicAdvertisingSyncLost(le_periodic_advertising_sync_lost),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LePeriodicAdvertisingSyncLostPacket::new(event)}
}
impl Into<EventPacket> for LePeriodicAdvertisingSyncLostBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LePeriodicAdvertisingSyncLostBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct LeScanTimeoutData {}
#[derive(Debug, Clone)] pub struct LeScanTimeoutPacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_scan_timeout: Arc<LeScanTimeoutData>,}
#[derive(Debug)] pub struct LeScanTimeoutBuilder {}
impl LeScanTimeoutData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeScanTimeoutPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeScanTimeoutPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_scan_timeout = match &le_meta_event.child {LeMetaEventDataChild::LeScanTimeout(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanTimeout"),};Self {event,le_meta_event,le_scan_timeout,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
}
impl Into<EventPacket> for LeScanTimeoutPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeScanTimeoutPacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeScanTimeoutBuilder {pub fn build(self) -> LeScanTimeoutPacket {let le_scan_timeout= Arc::new(LeScanTimeoutData {});let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::ScanTimeout, child: LeMetaEventDataChild::LeScanTimeout(le_scan_timeout),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeScanTimeoutPacket::new(event)}
}
impl Into<EventPacket> for LeScanTimeoutBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeScanTimeoutBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct LeAdvertisingSetTerminatedData {status: ErrorCode, advertising_handle: u8, connection_handle: u16, num_completed_extended_advertising_events: u8, }
#[derive(Debug, Clone)] pub struct LeAdvertisingSetTerminatedPacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_advertising_set_terminated: Arc<LeAdvertisingSetTerminatedData>,}
#[derive(Debug)] pub struct LeAdvertisingSetTerminatedBuilder {pub status: ErrorCode, pub advertising_handle: u8, pub connection_handle: u16, pub num_completed_extended_advertising_events: u8, }
impl LeAdvertisingSetTerminatedData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeAdvertisingSetTerminated".to_string(),    field: "status".to_string(),    wanted: 4,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[3]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeAdvertisingSetTerminated".to_string(),    field: "advertising_handle".to_string(),    wanted: 5,    got: bytes.len()});}let advertising_handle = u8::from_le_bytes([bytes[4]]);if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeAdvertisingSetTerminated".to_string(),    field: "connection_handle".to_string(),    wanted: 7,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[5],bytes[6]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeAdvertisingSetTerminated".to_string(),    field: "num_completed_extended_advertising_events".to_string(),    wanted: 8,    got: bytes.len()});}let num_completed_extended_advertising_events = u8::from_le_bytes([bytes[7]]);Ok(Self {status, advertising_handle, connection_handle, num_completed_extended_advertising_events, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[3..4].copy_from_slice(&status.to_le_bytes()[0..1]);let advertising_handle = self.advertising_handle;buffer[4..5].copy_from_slice(&advertising_handle.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[5..7].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let num_completed_extended_advertising_events = self.num_completed_extended_advertising_events;buffer[7..8].copy_from_slice(&num_completed_extended_advertising_events.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 5;ret}
}
impl Packet for LeAdvertisingSetTerminatedPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeAdvertisingSetTerminatedPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_advertising_set_terminated = match &le_meta_event.child {LeMetaEventDataChild::LeAdvertisingSetTerminated(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeAdvertisingSetTerminated"),};Self {event,le_meta_event,le_advertising_set_terminated,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_status(&self) -> ErrorCode{ self.le_advertising_set_terminated.as_ref().status}
pub fn get_advertising_handle(&self) -> u8{ self.le_advertising_set_terminated.as_ref().advertising_handle}
pub fn get_connection_handle(&self) -> u16{ self.le_advertising_set_terminated.as_ref().connection_handle}
pub fn get_num_completed_extended_advertising_events(&self) -> u8{ self.le_advertising_set_terminated.as_ref().num_completed_extended_advertising_events}
}
impl Into<EventPacket> for LeAdvertisingSetTerminatedPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeAdvertisingSetTerminatedPacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeAdvertisingSetTerminatedBuilder {pub fn build(self) -> LeAdvertisingSetTerminatedPacket {let le_advertising_set_terminated= Arc::new(LeAdvertisingSetTerminatedData {status: self.status, advertising_handle: self.advertising_handle, connection_handle: self.connection_handle, num_completed_extended_advertising_events: self.num_completed_extended_advertising_events, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::AdvertisingSetTerminated, child: LeMetaEventDataChild::LeAdvertisingSetTerminated(le_advertising_set_terminated),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeAdvertisingSetTerminatedPacket::new(event)}
}
impl Into<EventPacket> for LeAdvertisingSetTerminatedBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeAdvertisingSetTerminatedBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct LeScanRequestReceivedData {advertising_handle: u8, scanner_address_type: AddressType, scanner_address: Address, }
#[derive(Debug, Clone)] pub struct LeScanRequestReceivedPacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_scan_request_received: Arc<LeScanRequestReceivedData>,}
#[derive(Debug)] pub struct LeScanRequestReceivedBuilder {pub advertising_handle: u8, pub scanner_address_type: AddressType, pub scanner_address: Address, }
impl LeScanRequestReceivedData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeScanRequestReceived".to_string(),    field: "advertising_handle".to_string(),    wanted: 4,    got: bytes.len()});}let advertising_handle = u8::from_le_bytes([bytes[3]]);if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeScanRequestReceived".to_string(),    field: "scanner_address_type".to_string(),    wanted: 5,    got: bytes.len()});}let scanner_address_type = u8::from_le_bytes([bytes[4]]);let scanner_address_type = AddressType::from_u8(scanner_address_type).unwrap();if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "LeScanRequestReceived".to_string(),    field: "scanner_address".to_string(),    wanted: 11,    got: bytes.len()});}let scanner_address = bytes[5..11].try_into().unwrap();Ok(Self {advertising_handle, scanner_address_type, scanner_address, })
}
fn write_to(&self, buffer: &mut BytesMut) {let advertising_handle = self.advertising_handle;buffer[3..4].copy_from_slice(&advertising_handle.to_le_bytes()[0..1]);let scanner_address_type = self.scanner_address_type.to_u8().unwrap();buffer[4..5].copy_from_slice(&scanner_address_type.to_le_bytes()[0..1]);let scanner_address: [u8; 6] = self.scanner_address.into();buffer[5..11].copy_from_slice(&scanner_address);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 8;ret}
}
impl Packet for LeScanRequestReceivedPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeScanRequestReceivedPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_scan_request_received = match &le_meta_event.child {LeMetaEventDataChild::LeScanRequestReceived(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeScanRequestReceived"),};Self {event,le_meta_event,le_scan_request_received,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_advertising_handle(&self) -> u8{ self.le_scan_request_received.as_ref().advertising_handle}
pub fn get_scanner_address_type(&self) -> AddressType{ self.le_scan_request_received.as_ref().scanner_address_type}
pub fn get_scanner_address(&self) -> Address{ self.le_scan_request_received.as_ref().scanner_address}
}
impl Into<EventPacket> for LeScanRequestReceivedPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeScanRequestReceivedPacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeScanRequestReceivedBuilder {pub fn build(self) -> LeScanRequestReceivedPacket {let le_scan_request_received= Arc::new(LeScanRequestReceivedData {advertising_handle: self.advertising_handle, scanner_address_type: self.scanner_address_type, scanner_address: self.scanner_address, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::ScanRequestReceived, child: LeMetaEventDataChild::LeScanRequestReceived(le_scan_request_received),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeScanRequestReceivedPacket::new(event)}
}
impl Into<EventPacket> for LeScanRequestReceivedBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeScanRequestReceivedBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct LeChannelSelectionAlgorithmData {connection_handle: u16, channel_selection_algorithm: ChannelSelectionAlgorithm, }
#[derive(Debug, Clone)] pub struct LeChannelSelectionAlgorithmPacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_channel_selection_algorithm: Arc<LeChannelSelectionAlgorithmData>,}
#[derive(Debug)] pub struct LeChannelSelectionAlgorithmBuilder {pub connection_handle: u16, pub channel_selection_algorithm: ChannelSelectionAlgorithm, }
impl LeChannelSelectionAlgorithmData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeChannelSelectionAlgorithm".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeChannelSelectionAlgorithm".to_string(),    field: "channel_selection_algorithm".to_string(),    wanted: 6,    got: bytes.len()});}let channel_selection_algorithm = u8::from_le_bytes([bytes[5]]);let channel_selection_algorithm = ChannelSelectionAlgorithm::from_u8(channel_selection_algorithm).unwrap();Ok(Self {connection_handle, channel_selection_algorithm, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let channel_selection_algorithm = self.channel_selection_algorithm.to_u8().unwrap();buffer[5..6].copy_from_slice(&channel_selection_algorithm.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 3;ret}
}
impl Packet for LeChannelSelectionAlgorithmPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeChannelSelectionAlgorithmPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_channel_selection_algorithm = match &le_meta_event.child {LeMetaEventDataChild::LeChannelSelectionAlgorithm(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeChannelSelectionAlgorithm"),};Self {event,le_meta_event,le_channel_selection_algorithm,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_connection_handle(&self) -> u16{ self.le_channel_selection_algorithm.as_ref().connection_handle}
pub fn get_channel_selection_algorithm(&self) -> ChannelSelectionAlgorithm{ self.le_channel_selection_algorithm.as_ref().channel_selection_algorithm}
}
impl Into<EventPacket> for LeChannelSelectionAlgorithmPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeChannelSelectionAlgorithmPacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeChannelSelectionAlgorithmBuilder {pub fn build(self) -> LeChannelSelectionAlgorithmPacket {let le_channel_selection_algorithm= Arc::new(LeChannelSelectionAlgorithmData {connection_handle: self.connection_handle, channel_selection_algorithm: self.channel_selection_algorithm, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::ChannelSelectionAlgorithm, child: LeMetaEventDataChild::LeChannelSelectionAlgorithm(le_channel_selection_algorithm),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeChannelSelectionAlgorithmPacket::new(event)}
}
impl Into<EventPacket> for LeChannelSelectionAlgorithmBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeChannelSelectionAlgorithmBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] enum LeConnectionlessIqReportDataChild {Payload(Bytes),None,}
impl LeConnectionlessIqReportDataChild {fn get_total_size(&self) -> usize {match self {LeConnectionlessIqReportDataChild::Payload(p) => p.len(),LeConnectionlessIqReportDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LeConnectionlessIqReportChild {Payload(Bytes),None,}
#[derive(Debug)] struct LeConnectionlessIqReportData {child: LeConnectionlessIqReportDataChild,}
#[derive(Debug, Clone)] pub struct LeConnectionlessIqReportPacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_connectionless_iq_report: Arc<LeConnectionlessIqReportData>,}
#[derive(Debug)] pub struct LeConnectionlessIqReportBuilder {pub payload: Option<Bytes>,}
impl LeConnectionlessIqReportData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {let payload: Vec::<u8> = bytes[3..].into();let child = if payload.len() > 0 {LeConnectionlessIqReportDataChild::Payload(Bytes::from(payload))} else {LeConnectionlessIqReportDataChild::None};Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {LeConnectionlessIqReportDataChild::Payload(p) => buffer[3..].copy_from_slice(&p[..]),LeConnectionlessIqReportDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeConnectionlessIqReportPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeConnectionlessIqReportPacket { pub fn specialize(&self) -> LeConnectionlessIqReportChild { match &self.le_connectionless_iq_report.child {LeConnectionlessIqReportDataChild::Payload(p) => LeConnectionlessIqReportChild::Payload(p.clone()),LeConnectionlessIqReportDataChild::None => LeConnectionlessIqReportChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_connectionless_iq_report = match &le_meta_event.child {LeMetaEventDataChild::LeConnectionlessIqReport(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeConnectionlessIqReport"),};Self {event,le_meta_event,le_connectionless_iq_report,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
}
impl Into<EventPacket> for LeConnectionlessIqReportPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeConnectionlessIqReportPacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeConnectionlessIqReportBuilder {pub fn build(self) -> LeConnectionlessIqReportPacket {let le_connectionless_iq_report= Arc::new(LeConnectionlessIqReportData {child: match self.payload { None => LeConnectionlessIqReportDataChild::None,Some(bytes) => LeConnectionlessIqReportDataChild::Payload(bytes),},});let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::ConnectionlessIqReport, child: LeMetaEventDataChild::LeConnectionlessIqReport(le_connectionless_iq_report),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeConnectionlessIqReportPacket::new(event)}
}
impl Into<EventPacket> for LeConnectionlessIqReportBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeConnectionlessIqReportBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] enum LeConnectionIqReportDataChild {Payload(Bytes),None,}
impl LeConnectionIqReportDataChild {fn get_total_size(&self) -> usize {match self {LeConnectionIqReportDataChild::Payload(p) => p.len(),LeConnectionIqReportDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LeConnectionIqReportChild {Payload(Bytes),None,}
#[derive(Debug)] struct LeConnectionIqReportData {child: LeConnectionIqReportDataChild,}
#[derive(Debug, Clone)] pub struct LeConnectionIqReportPacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_connection_iq_report: Arc<LeConnectionIqReportData>,}
#[derive(Debug)] pub struct LeConnectionIqReportBuilder {pub payload: Option<Bytes>,}
impl LeConnectionIqReportData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {let payload: Vec::<u8> = bytes[3..].into();let child = if payload.len() > 0 {LeConnectionIqReportDataChild::Payload(Bytes::from(payload))} else {LeConnectionIqReportDataChild::None};Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {LeConnectionIqReportDataChild::Payload(p) => buffer[3..].copy_from_slice(&p[..]),LeConnectionIqReportDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeConnectionIqReportPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeConnectionIqReportPacket { pub fn specialize(&self) -> LeConnectionIqReportChild { match &self.le_connection_iq_report.child {LeConnectionIqReportDataChild::Payload(p) => LeConnectionIqReportChild::Payload(p.clone()),LeConnectionIqReportDataChild::None => LeConnectionIqReportChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_connection_iq_report = match &le_meta_event.child {LeMetaEventDataChild::LeConnectionIqReport(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeConnectionIqReport"),};Self {event,le_meta_event,le_connection_iq_report,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
}
impl Into<EventPacket> for LeConnectionIqReportPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeConnectionIqReportPacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeConnectionIqReportBuilder {pub fn build(self) -> LeConnectionIqReportPacket {let le_connection_iq_report= Arc::new(LeConnectionIqReportData {child: match self.payload { None => LeConnectionIqReportDataChild::None,Some(bytes) => LeConnectionIqReportDataChild::Payload(bytes),},});let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::ConnectionIqReport, child: LeMetaEventDataChild::LeConnectionIqReport(le_connection_iq_report),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeConnectionIqReportPacket::new(event)}
}
impl Into<EventPacket> for LeConnectionIqReportBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeConnectionIqReportBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] enum LeCteRequestFailedDataChild {Payload(Bytes),None,}
impl LeCteRequestFailedDataChild {fn get_total_size(&self) -> usize {match self {LeCteRequestFailedDataChild::Payload(p) => p.len(),LeCteRequestFailedDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LeCteRequestFailedChild {Payload(Bytes),None,}
#[derive(Debug)] struct LeCteRequestFailedData {child: LeCteRequestFailedDataChild,}
#[derive(Debug, Clone)] pub struct LeCteRequestFailedPacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_cte_request_failed: Arc<LeCteRequestFailedData>,}
#[derive(Debug)] pub struct LeCteRequestFailedBuilder {pub payload: Option<Bytes>,}
impl LeCteRequestFailedData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {let payload: Vec::<u8> = bytes[3..].into();let child = if payload.len() > 0 {LeCteRequestFailedDataChild::Payload(Bytes::from(payload))} else {LeCteRequestFailedDataChild::None};Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {LeCteRequestFailedDataChild::Payload(p) => buffer[3..].copy_from_slice(&p[..]),LeCteRequestFailedDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for LeCteRequestFailedPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeCteRequestFailedPacket { pub fn specialize(&self) -> LeCteRequestFailedChild { match &self.le_cte_request_failed.child {LeCteRequestFailedDataChild::Payload(p) => LeCteRequestFailedChild::Payload(p.clone()),LeCteRequestFailedDataChild::None => LeCteRequestFailedChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_cte_request_failed = match &le_meta_event.child {LeMetaEventDataChild::LeCteRequestFailed(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeCteRequestFailed"),};Self {event,le_meta_event,le_cte_request_failed,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
}
impl Into<EventPacket> for LeCteRequestFailedPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeCteRequestFailedPacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeCteRequestFailedBuilder {pub fn build(self) -> LeCteRequestFailedPacket {let le_cte_request_failed= Arc::new(LeCteRequestFailedData {child: match self.payload { None => LeCteRequestFailedDataChild::None,Some(bytes) => LeCteRequestFailedDataChild::Payload(bytes),},});let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::CteRequestFailed, child: LeMetaEventDataChild::LeCteRequestFailed(le_cte_request_failed),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeCteRequestFailedPacket::new(event)}
}
impl Into<EventPacket> for LeCteRequestFailedBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeCteRequestFailedBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct LePeriodicAdvertisingSyncTransferReceivedData {status: ErrorCode, connection_handle: u16, service_data: u16, sync_handle: u16, advertising_sid: u8, advertiser_address_type: AddressType, advertiser_address: Address, advertiser_phy: SecondaryPhyType, periodic_advertising_interval: u16, advertiser_clock_accuracy: ClockAccuracy, }
#[derive(Debug, Clone)] pub struct LePeriodicAdvertisingSyncTransferReceivedPacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_periodic_advertising_sync_transfer_received: Arc<LePeriodicAdvertisingSyncTransferReceivedData>,}
#[derive(Debug)] pub struct LePeriodicAdvertisingSyncTransferReceivedBuilder {pub status: ErrorCode, pub connection_handle: u16, pub service_data: u16, pub sync_handle: u16, pub advertising_sid: u8, pub advertiser_address_type: AddressType, pub advertiser_address: Address, pub advertiser_phy: SecondaryPhyType, pub periodic_advertising_interval: u16, pub advertiser_clock_accuracy: ClockAccuracy, }
impl LePeriodicAdvertisingSyncTransferReceivedData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LePeriodicAdvertisingSyncTransferReceived".to_string(),    field: "status".to_string(),    wanted: 4,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[3]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LePeriodicAdvertisingSyncTransferReceived".to_string(),    field: "connection_handle".to_string(),    wanted: 6,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[4],bytes[5]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LePeriodicAdvertisingSyncTransferReceived".to_string(),    field: "service_data".to_string(),    wanted: 8,    got: bytes.len()});}let service_data = u16::from_le_bytes([bytes[6],bytes[7]]);if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LePeriodicAdvertisingSyncTransferReceived".to_string(),    field: "sync_handle".to_string(),    wanted: 10,    got: bytes.len()});}let sync_handle = u16::from_le_bytes([bytes[8],bytes[9]]);let sync_handle = sync_handle & 0xfff;let advertising_sid = u8::from_le_bytes([bytes[10]]);let advertising_sid = advertising_sid & 0xf;if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "LePeriodicAdvertisingSyncTransferReceived".to_string(),    field: "advertiser_address_type".to_string(),    wanted: 12,    got: bytes.len()});}let advertiser_address_type = u8::from_le_bytes([bytes[11]]);let advertiser_address_type = AddressType::from_u8(advertiser_address_type).unwrap();if bytes.len() < 18 { return Err(Error::InvalidLengthError{    obj: "LePeriodicAdvertisingSyncTransferReceived".to_string(),    field: "advertiser_address".to_string(),    wanted: 18,    got: bytes.len()});}let advertiser_address = bytes[12..18].try_into().unwrap();if bytes.len() < 19 { return Err(Error::InvalidLengthError{    obj: "LePeriodicAdvertisingSyncTransferReceived".to_string(),    field: "advertiser_phy".to_string(),    wanted: 19,    got: bytes.len()});}let advertiser_phy = u8::from_le_bytes([bytes[18]]);let advertiser_phy = SecondaryPhyType::from_u8(advertiser_phy).unwrap();if bytes.len() < 21 { return Err(Error::InvalidLengthError{    obj: "LePeriodicAdvertisingSyncTransferReceived".to_string(),    field: "periodic_advertising_interval".to_string(),    wanted: 21,    got: bytes.len()});}let periodic_advertising_interval = u16::from_le_bytes([bytes[19],bytes[20]]);if bytes.len() < 22 { return Err(Error::InvalidLengthError{    obj: "LePeriodicAdvertisingSyncTransferReceived".to_string(),    field: "advertiser_clock_accuracy".to_string(),    wanted: 22,    got: bytes.len()});}let advertiser_clock_accuracy = u8::from_le_bytes([bytes[21]]);let advertiser_clock_accuracy = ClockAccuracy::from_u8(advertiser_clock_accuracy).unwrap();Ok(Self {status, connection_handle, service_data, sync_handle, advertising_sid, advertiser_address_type, advertiser_address, advertiser_phy, periodic_advertising_interval, advertiser_clock_accuracy, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[3..4].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[4..6].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let service_data = self.service_data;buffer[6..8].copy_from_slice(&service_data.to_le_bytes()[0..2]);let sync_handle = self.sync_handle;let sync_handle = sync_handle & 0xfff;buffer[8..10].copy_from_slice(&sync_handle.to_le_bytes()[0..2]);let advertising_sid = self.advertising_sid;let advertising_sid = advertising_sid & 0xf;buffer[10..11].copy_from_slice(&advertising_sid.to_le_bytes()[0..1]);let advertiser_address_type = self.advertiser_address_type.to_u8().unwrap();buffer[11..12].copy_from_slice(&advertiser_address_type.to_le_bytes()[0..1]);let advertiser_address: [u8; 6] = self.advertiser_address.into();buffer[12..18].copy_from_slice(&advertiser_address);let advertiser_phy = self.advertiser_phy.to_u8().unwrap();buffer[18..19].copy_from_slice(&advertiser_phy.to_le_bytes()[0..1]);let periodic_advertising_interval = self.periodic_advertising_interval;buffer[19..21].copy_from_slice(&periodic_advertising_interval.to_le_bytes()[0..2]);let advertiser_clock_accuracy = self.advertiser_clock_accuracy.to_u8().unwrap();buffer[21..22].copy_from_slice(&advertiser_clock_accuracy.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 19;ret}
}
impl Packet for LePeriodicAdvertisingSyncTransferReceivedPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LePeriodicAdvertisingSyncTransferReceivedPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_periodic_advertising_sync_transfer_received = match &le_meta_event.child {LeMetaEventDataChild::LePeriodicAdvertisingSyncTransferReceived(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LePeriodicAdvertisingSyncTransferReceived"),};Self {event,le_meta_event,le_periodic_advertising_sync_transfer_received,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_status(&self) -> ErrorCode{ self.le_periodic_advertising_sync_transfer_received.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_periodic_advertising_sync_transfer_received.as_ref().connection_handle}
pub fn get_service_data(&self) -> u16{ self.le_periodic_advertising_sync_transfer_received.as_ref().service_data}
pub fn get_sync_handle(&self) -> u16{ self.le_periodic_advertising_sync_transfer_received.as_ref().sync_handle}
pub fn get_advertising_sid(&self) -> u8{ self.le_periodic_advertising_sync_transfer_received.as_ref().advertising_sid}
pub fn get_advertiser_address_type(&self) -> AddressType{ self.le_periodic_advertising_sync_transfer_received.as_ref().advertiser_address_type}
pub fn get_advertiser_address(&self) -> Address{ self.le_periodic_advertising_sync_transfer_received.as_ref().advertiser_address}
pub fn get_advertiser_phy(&self) -> SecondaryPhyType{ self.le_periodic_advertising_sync_transfer_received.as_ref().advertiser_phy}
pub fn get_periodic_advertising_interval(&self) -> u16{ self.le_periodic_advertising_sync_transfer_received.as_ref().periodic_advertising_interval}
pub fn get_advertiser_clock_accuracy(&self) -> ClockAccuracy{ self.le_periodic_advertising_sync_transfer_received.as_ref().advertiser_clock_accuracy}
}
impl Into<EventPacket> for LePeriodicAdvertisingSyncTransferReceivedPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LePeriodicAdvertisingSyncTransferReceivedPacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LePeriodicAdvertisingSyncTransferReceivedBuilder {pub fn build(self) -> LePeriodicAdvertisingSyncTransferReceivedPacket {let le_periodic_advertising_sync_transfer_received= Arc::new(LePeriodicAdvertisingSyncTransferReceivedData {status: self.status, connection_handle: self.connection_handle, service_data: self.service_data, sync_handle: self.sync_handle, advertising_sid: self.advertising_sid, advertiser_address_type: self.advertiser_address_type, advertiser_address: self.advertiser_address, advertiser_phy: self.advertiser_phy, periodic_advertising_interval: self.periodic_advertising_interval, advertiser_clock_accuracy: self.advertiser_clock_accuracy, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::PeriodicAdvertisingSyncTransferReceived, child: LeMetaEventDataChild::LePeriodicAdvertisingSyncTransferReceived(le_periodic_advertising_sync_transfer_received),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LePeriodicAdvertisingSyncTransferReceivedPacket::new(event)}
}
impl Into<EventPacket> for LePeriodicAdvertisingSyncTransferReceivedBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LePeriodicAdvertisingSyncTransferReceivedBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct LeCisEstablishedData {status: ErrorCode, connection_handle: u16, cig_sync_delay: u32, cis_sync_delay: u32, transport_latency_m_to_s: u32, transport_latency_s_to_m: u32, phy_m_to_s: SecondaryPhyType, phy_s_to_m: SecondaryPhyType, nse: u8, bn_m_to_s: u8, bn_s_to_m: u8, ft_m_to_s: u8, ft_s_to_m: u8, max_pdu_m_to_s: u8, max_pdu_s_to_m: u8, iso_interval: u16, }
#[derive(Debug, Clone)] pub struct LeCisEstablishedPacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_cis_established: Arc<LeCisEstablishedData>,}
#[derive(Debug)] pub struct LeCisEstablishedBuilder {pub status: ErrorCode, pub connection_handle: u16, pub cig_sync_delay: u32, pub cis_sync_delay: u32, pub transport_latency_m_to_s: u32, pub transport_latency_s_to_m: u32, pub phy_m_to_s: SecondaryPhyType, pub phy_s_to_m: SecondaryPhyType, pub nse: u8, pub bn_m_to_s: u8, pub bn_s_to_m: u8, pub ft_m_to_s: u8, pub ft_s_to_m: u8, pub max_pdu_m_to_s: u8, pub max_pdu_s_to_m: u8, pub iso_interval: u16, }
impl LeCisEstablishedData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeCisEstablished".to_string(),    field: "status".to_string(),    wanted: 4,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[3]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeCisEstablished".to_string(),    field: "connection_handle".to_string(),    wanted: 6,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[4],bytes[5]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeCisEstablished".to_string(),    field: "cig_sync_delay".to_string(),    wanted: 9,    got: bytes.len()});}let cig_sync_delay = u32::from_le_bytes([bytes[6],bytes[7],bytes[8],0]);let cig_sync_delay = cig_sync_delay & 0xffffff;if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "LeCisEstablished".to_string(),    field: "cis_sync_delay".to_string(),    wanted: 12,    got: bytes.len()});}let cis_sync_delay = u32::from_le_bytes([bytes[9],bytes[10],bytes[11],0]);let cis_sync_delay = cis_sync_delay & 0xffffff;if bytes.len() < 15 { return Err(Error::InvalidLengthError{    obj: "LeCisEstablished".to_string(),    field: "transport_latency_m_to_s".to_string(),    wanted: 15,    got: bytes.len()});}let transport_latency_m_to_s = u32::from_le_bytes([bytes[12],bytes[13],bytes[14],0]);let transport_latency_m_to_s = transport_latency_m_to_s & 0xffffff;if bytes.len() < 18 { return Err(Error::InvalidLengthError{    obj: "LeCisEstablished".to_string(),    field: "transport_latency_s_to_m".to_string(),    wanted: 18,    got: bytes.len()});}let transport_latency_s_to_m = u32::from_le_bytes([bytes[15],bytes[16],bytes[17],0]);let transport_latency_s_to_m = transport_latency_s_to_m & 0xffffff;if bytes.len() < 19 { return Err(Error::InvalidLengthError{    obj: "LeCisEstablished".to_string(),    field: "phy_m_to_s".to_string(),    wanted: 19,    got: bytes.len()});}let phy_m_to_s = u8::from_le_bytes([bytes[18]]);let phy_m_to_s = SecondaryPhyType::from_u8(phy_m_to_s).unwrap();if bytes.len() < 20 { return Err(Error::InvalidLengthError{    obj: "LeCisEstablished".to_string(),    field: "phy_s_to_m".to_string(),    wanted: 20,    got: bytes.len()});}let phy_s_to_m = u8::from_le_bytes([bytes[19]]);let phy_s_to_m = SecondaryPhyType::from_u8(phy_s_to_m).unwrap();if bytes.len() < 21 { return Err(Error::InvalidLengthError{    obj: "LeCisEstablished".to_string(),    field: "nse".to_string(),    wanted: 21,    got: bytes.len()});}let nse = u8::from_le_bytes([bytes[20]]);let bn_m_to_s = u8::from_le_bytes([bytes[21]]);let bn_m_to_s = bn_m_to_s & 0xf;let bn_s_to_m = u8::from_le_bytes([bytes[22]]);let bn_s_to_m = bn_s_to_m & 0xf;if bytes.len() < 24 { return Err(Error::InvalidLengthError{    obj: "LeCisEstablished".to_string(),    field: "ft_m_to_s".to_string(),    wanted: 24,    got: bytes.len()});}let ft_m_to_s = u8::from_le_bytes([bytes[23]]);if bytes.len() < 25 { return Err(Error::InvalidLengthError{    obj: "LeCisEstablished".to_string(),    field: "ft_s_to_m".to_string(),    wanted: 25,    got: bytes.len()});}let ft_s_to_m = u8::from_le_bytes([bytes[24]]);if bytes.len() < 26 { return Err(Error::InvalidLengthError{    obj: "LeCisEstablished".to_string(),    field: "max_pdu_m_to_s".to_string(),    wanted: 26,    got: bytes.len()});}let max_pdu_m_to_s = u8::from_le_bytes([bytes[25]]);if bytes.len() < 28 { return Err(Error::InvalidLengthError{    obj: "LeCisEstablished".to_string(),    field: "max_pdu_s_to_m".to_string(),    wanted: 28,    got: bytes.len()});}let max_pdu_s_to_m = u8::from_le_bytes([bytes[27]]);if bytes.len() < 31 { return Err(Error::InvalidLengthError{    obj: "LeCisEstablished".to_string(),    field: "iso_interval".to_string(),    wanted: 31,    got: bytes.len()});}let iso_interval = u16::from_le_bytes([bytes[29],bytes[30]]);Ok(Self {status, connection_handle, cig_sync_delay, cis_sync_delay, transport_latency_m_to_s, transport_latency_s_to_m, phy_m_to_s, phy_s_to_m, nse, bn_m_to_s, bn_s_to_m, ft_m_to_s, ft_s_to_m, max_pdu_m_to_s, max_pdu_s_to_m, iso_interval, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[3..4].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[4..6].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let cig_sync_delay = self.cig_sync_delay;let cig_sync_delay = cig_sync_delay & 0xffffff;buffer[6..9].copy_from_slice(&cig_sync_delay.to_le_bytes()[0..3]);let cis_sync_delay = self.cis_sync_delay;let cis_sync_delay = cis_sync_delay & 0xffffff;buffer[9..12].copy_from_slice(&cis_sync_delay.to_le_bytes()[0..3]);let transport_latency_m_to_s = self.transport_latency_m_to_s;let transport_latency_m_to_s = transport_latency_m_to_s & 0xffffff;buffer[12..15].copy_from_slice(&transport_latency_m_to_s.to_le_bytes()[0..3]);let transport_latency_s_to_m = self.transport_latency_s_to_m;let transport_latency_s_to_m = transport_latency_s_to_m & 0xffffff;buffer[15..18].copy_from_slice(&transport_latency_s_to_m.to_le_bytes()[0..3]);let phy_m_to_s = self.phy_m_to_s.to_u8().unwrap();buffer[18..19].copy_from_slice(&phy_m_to_s.to_le_bytes()[0..1]);let phy_s_to_m = self.phy_s_to_m.to_u8().unwrap();buffer[19..20].copy_from_slice(&phy_s_to_m.to_le_bytes()[0..1]);let nse = self.nse;buffer[20..21].copy_from_slice(&nse.to_le_bytes()[0..1]);let bn_m_to_s = self.bn_m_to_s;let bn_m_to_s = bn_m_to_s & 0xf;buffer[21..22].copy_from_slice(&bn_m_to_s.to_le_bytes()[0..1]);let bn_s_to_m = self.bn_s_to_m;let bn_s_to_m = bn_s_to_m & 0xf;buffer[22..23].copy_from_slice(&bn_s_to_m.to_le_bytes()[0..1]);let ft_m_to_s = self.ft_m_to_s;buffer[23..24].copy_from_slice(&ft_m_to_s.to_le_bytes()[0..1]);let ft_s_to_m = self.ft_s_to_m;buffer[24..25].copy_from_slice(&ft_s_to_m.to_le_bytes()[0..1]);let max_pdu_m_to_s = self.max_pdu_m_to_s;buffer[25..26].copy_from_slice(&max_pdu_m_to_s.to_le_bytes()[0..1]);let max_pdu_s_to_m = self.max_pdu_s_to_m;buffer[27..28].copy_from_slice(&max_pdu_s_to_m.to_le_bytes()[0..1]);let iso_interval = self.iso_interval;buffer[29..31].copy_from_slice(&iso_interval.to_le_bytes()[0..2]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 28;ret}
}
impl Packet for LeCisEstablishedPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeCisEstablishedPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_cis_established = match &le_meta_event.child {LeMetaEventDataChild::LeCisEstablished(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeCisEstablished"),};Self {event,le_meta_event,le_cis_established,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_status(&self) -> ErrorCode{ self.le_cis_established.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_cis_established.as_ref().connection_handle}
pub fn get_cig_sync_delay(&self) -> u32{ self.le_cis_established.as_ref().cig_sync_delay}
pub fn get_cis_sync_delay(&self) -> u32{ self.le_cis_established.as_ref().cis_sync_delay}
pub fn get_transport_latency_m_to_s(&self) -> u32{ self.le_cis_established.as_ref().transport_latency_m_to_s}
pub fn get_transport_latency_s_to_m(&self) -> u32{ self.le_cis_established.as_ref().transport_latency_s_to_m}
pub fn get_phy_m_to_s(&self) -> SecondaryPhyType{ self.le_cis_established.as_ref().phy_m_to_s}
pub fn get_phy_s_to_m(&self) -> SecondaryPhyType{ self.le_cis_established.as_ref().phy_s_to_m}
pub fn get_nse(&self) -> u8{ self.le_cis_established.as_ref().nse}
pub fn get_bn_m_to_s(&self) -> u8{ self.le_cis_established.as_ref().bn_m_to_s}
pub fn get_bn_s_to_m(&self) -> u8{ self.le_cis_established.as_ref().bn_s_to_m}
pub fn get_ft_m_to_s(&self) -> u8{ self.le_cis_established.as_ref().ft_m_to_s}
pub fn get_ft_s_to_m(&self) -> u8{ self.le_cis_established.as_ref().ft_s_to_m}
pub fn get_max_pdu_m_to_s(&self) -> u8{ self.le_cis_established.as_ref().max_pdu_m_to_s}
pub fn get_max_pdu_s_to_m(&self) -> u8{ self.le_cis_established.as_ref().max_pdu_s_to_m}
pub fn get_iso_interval(&self) -> u16{ self.le_cis_established.as_ref().iso_interval}
}
impl Into<EventPacket> for LeCisEstablishedPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeCisEstablishedPacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeCisEstablishedBuilder {pub fn build(self) -> LeCisEstablishedPacket {let le_cis_established= Arc::new(LeCisEstablishedData {status: self.status, connection_handle: self.connection_handle, cig_sync_delay: self.cig_sync_delay, cis_sync_delay: self.cis_sync_delay, transport_latency_m_to_s: self.transport_latency_m_to_s, transport_latency_s_to_m: self.transport_latency_s_to_m, phy_m_to_s: self.phy_m_to_s, phy_s_to_m: self.phy_s_to_m, nse: self.nse, bn_m_to_s: self.bn_m_to_s, bn_s_to_m: self.bn_s_to_m, ft_m_to_s: self.ft_m_to_s, ft_s_to_m: self.ft_s_to_m, max_pdu_m_to_s: self.max_pdu_m_to_s, max_pdu_s_to_m: self.max_pdu_s_to_m, iso_interval: self.iso_interval, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::CisEstablished, child: LeMetaEventDataChild::LeCisEstablished(le_cis_established),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeCisEstablishedPacket::new(event)}
}
impl Into<EventPacket> for LeCisEstablishedBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeCisEstablishedBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct LeCisRequestData {acl_connection_handle: u16, cis_connection_handle: u16, cig_id: u8, cis_id: u8, }
#[derive(Debug, Clone)] pub struct LeCisRequestPacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_cis_request: Arc<LeCisRequestData>,}
#[derive(Debug)] pub struct LeCisRequestBuilder {pub acl_connection_handle: u16, pub cis_connection_handle: u16, pub cig_id: u8, pub cis_id: u8, }
impl LeCisRequestData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeCisRequest".to_string(),    field: "acl_connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let acl_connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let acl_connection_handle = acl_connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeCisRequest".to_string(),    field: "cis_connection_handle".to_string(),    wanted: 7,    got: bytes.len()});}let cis_connection_handle = u16::from_le_bytes([bytes[5],bytes[6]]);let cis_connection_handle = cis_connection_handle & 0xfff;if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeCisRequest".to_string(),    field: "cig_id".to_string(),    wanted: 8,    got: bytes.len()});}let cig_id = u8::from_le_bytes([bytes[7]]);if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeCisRequest".to_string(),    field: "cis_id".to_string(),    wanted: 9,    got: bytes.len()});}let cis_id = u8::from_le_bytes([bytes[8]]);Ok(Self {acl_connection_handle, cis_connection_handle, cig_id, cis_id, })
}
fn write_to(&self, buffer: &mut BytesMut) {let acl_connection_handle = self.acl_connection_handle;let acl_connection_handle = acl_connection_handle & 0xfff;buffer[3..5].copy_from_slice(&acl_connection_handle.to_le_bytes()[0..2]);let cis_connection_handle = self.cis_connection_handle;let cis_connection_handle = cis_connection_handle & 0xfff;buffer[5..7].copy_from_slice(&cis_connection_handle.to_le_bytes()[0..2]);let cig_id = self.cig_id;buffer[7..8].copy_from_slice(&cig_id.to_le_bytes()[0..1]);let cis_id = self.cis_id;buffer[8..9].copy_from_slice(&cis_id.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 6;ret}
}
impl Packet for LeCisRequestPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeCisRequestPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_cis_request = match &le_meta_event.child {LeMetaEventDataChild::LeCisRequest(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeCisRequest"),};Self {event,le_meta_event,le_cis_request,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_acl_connection_handle(&self) -> u16{ self.le_cis_request.as_ref().acl_connection_handle}
pub fn get_cis_connection_handle(&self) -> u16{ self.le_cis_request.as_ref().cis_connection_handle}
pub fn get_cig_id(&self) -> u8{ self.le_cis_request.as_ref().cig_id}
pub fn get_cis_id(&self) -> u8{ self.le_cis_request.as_ref().cis_id}
}
impl Into<EventPacket> for LeCisRequestPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeCisRequestPacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeCisRequestBuilder {pub fn build(self) -> LeCisRequestPacket {let le_cis_request= Arc::new(LeCisRequestData {acl_connection_handle: self.acl_connection_handle, cis_connection_handle: self.cis_connection_handle, cig_id: self.cig_id, cis_id: self.cis_id, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::CisRequest, child: LeMetaEventDataChild::LeCisRequest(le_cis_request),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeCisRequestPacket::new(event)}
}
impl Into<EventPacket> for LeCisRequestBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeCisRequestBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct LeCreateBigCompleteData {status: ErrorCode, big_handle: u8, big_sync_delay: u32, transport_latency_big: u32, phy: SecondaryPhyType, nse: u8, bn: u8, pto: u8, irc: u8, max_pdu: u16, iso_interval: u16, connection_handle: Vec::<u16>, }
#[derive(Debug, Clone)] pub struct LeCreateBigCompletePacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_create_big_complete: Arc<LeCreateBigCompleteData>,}
#[derive(Debug)] pub struct LeCreateBigCompleteBuilder {pub status: ErrorCode, pub big_handle: u8, pub big_sync_delay: u32, pub transport_latency_big: u32, pub phy: SecondaryPhyType, pub nse: u8, pub bn: u8, pub pto: u8, pub irc: u8, pub max_pdu: u16, pub iso_interval: u16, pub connection_handle: Vec::<u16>, }
impl LeCreateBigCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeCreateBigComplete".to_string(),    field: "status".to_string(),    wanted: 4,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[3]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeCreateBigComplete".to_string(),    field: "big_handle".to_string(),    wanted: 5,    got: bytes.len()});}let big_handle = u8::from_le_bytes([bytes[4]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeCreateBigComplete".to_string(),    field: "big_sync_delay".to_string(),    wanted: 8,    got: bytes.len()});}let big_sync_delay = u32::from_le_bytes([bytes[5],bytes[6],bytes[7],0]);let big_sync_delay = big_sync_delay & 0xffffff;if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "LeCreateBigComplete".to_string(),    field: "transport_latency_big".to_string(),    wanted: 11,    got: bytes.len()});}let transport_latency_big = u32::from_le_bytes([bytes[8],bytes[9],bytes[10],0]);let transport_latency_big = transport_latency_big & 0xffffff;if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "LeCreateBigComplete".to_string(),    field: "phy".to_string(),    wanted: 12,    got: bytes.len()});}let phy = u8::from_le_bytes([bytes[11]]);let phy = SecondaryPhyType::from_u8(phy).unwrap();if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "LeCreateBigComplete".to_string(),    field: "nse".to_string(),    wanted: 13,    got: bytes.len()});}let nse = u8::from_le_bytes([bytes[12]]);if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "LeCreateBigComplete".to_string(),    field: "bn".to_string(),    wanted: 14,    got: bytes.len()});}let bn = u8::from_le_bytes([bytes[13]]);if bytes.len() < 15 { return Err(Error::InvalidLengthError{    obj: "LeCreateBigComplete".to_string(),    field: "pto".to_string(),    wanted: 15,    got: bytes.len()});}let pto = u8::from_le_bytes([bytes[14]]);if bytes.len() < 16 { return Err(Error::InvalidLengthError{    obj: "LeCreateBigComplete".to_string(),    field: "irc".to_string(),    wanted: 16,    got: bytes.len()});}let irc = u8::from_le_bytes([bytes[15]]);if bytes.len() < 18 { return Err(Error::InvalidLengthError{    obj: "LeCreateBigComplete".to_string(),    field: "max_pdu".to_string(),    wanted: 18,    got: bytes.len()});}let max_pdu = u16::from_le_bytes([bytes[16],bytes[17]]);if bytes.len() < 20 { return Err(Error::InvalidLengthError{    obj: "LeCreateBigComplete".to_string(),    field: "iso_interval".to_string(),    wanted: 20,    got: bytes.len()});}let iso_interval = u16::from_le_bytes([bytes[18],bytes[19]]);if bytes.len() < 21 { return Err(Error::InvalidLengthError{    obj: "LeCreateBigComplete".to_string(),    field: "connection_handle_size".to_string(),    wanted: 21,    got: bytes.len()});}let connection_handle_size = u8::from_le_bytes([bytes[20]]);let want_ = 21 + (connection_handle_size as usize);if bytes.len() < want_ { return Err(Error::InvalidLengthError{    obj: "LeCreateBigComplete".to_string(),    field: "connection_handle".to_string(),    wanted: want_,    got: bytes.len()});}let connection_handle: Vec::<u16> = bytes[21..(21 + connection_handle_size as usize)].to_vec().chunks_exact(2).into_iter().map(|i| u16::from_le_bytes([i[0], i[1]])).collect();Ok(Self {status, big_handle, big_sync_delay, transport_latency_big, phy, nse, bn, pto, irc, max_pdu, iso_interval, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[3..4].copy_from_slice(&status.to_le_bytes()[0..1]);let big_handle = self.big_handle;buffer[4..5].copy_from_slice(&big_handle.to_le_bytes()[0..1]);let big_sync_delay = self.big_sync_delay;let big_sync_delay = big_sync_delay & 0xffffff;buffer[5..8].copy_from_slice(&big_sync_delay.to_le_bytes()[0..3]);let transport_latency_big = self.transport_latency_big;let transport_latency_big = transport_latency_big & 0xffffff;buffer[8..11].copy_from_slice(&transport_latency_big.to_le_bytes()[0..3]);let phy = self.phy.to_u8().unwrap();buffer[11..12].copy_from_slice(&phy.to_le_bytes()[0..1]);let nse = self.nse;buffer[12..13].copy_from_slice(&nse.to_le_bytes()[0..1]);let bn = self.bn;buffer[13..14].copy_from_slice(&bn.to_le_bytes()[0..1]);let pto = self.pto;buffer[14..15].copy_from_slice(&pto.to_le_bytes()[0..1]);let irc = self.irc;buffer[15..16].copy_from_slice(&irc.to_le_bytes()[0..1]);let max_pdu = self.max_pdu;buffer[16..18].copy_from_slice(&max_pdu.to_le_bytes()[0..2]);let iso_interval = self.iso_interval;buffer[18..20].copy_from_slice(&iso_interval.to_le_bytes()[0..2]);let connection_handle_bytes = self.connection_handle.len() * ((/* Bits: */ 16 + /* Dynamic: */ 0) / 8);let connection_handle_size = u8::try_from(connection_handle_bytes).expect("payload size did not fit");buffer[20..21].copy_from_slice(&connection_handle_size.to_le_bytes()[0..1]);for (i, e) in self.connection_handle.iter().enumerate() {buffer[21+i..21+i+2].copy_from_slice(&e.to_le_bytes())}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 18;let ret = ret + (self.connection_handle.len() * ((/* Bits: */ 16 + /* Dynamic: */ 0) / 8));ret}
}
impl Packet for LeCreateBigCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeCreateBigCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_create_big_complete = match &le_meta_event.child {LeMetaEventDataChild::LeCreateBigComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeCreateBigComplete"),};Self {event,le_meta_event,le_create_big_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_status(&self) -> ErrorCode{ self.le_create_big_complete.as_ref().status}
pub fn get_big_handle(&self) -> u8{ self.le_create_big_complete.as_ref().big_handle}
pub fn get_big_sync_delay(&self) -> u32{ self.le_create_big_complete.as_ref().big_sync_delay}
pub fn get_transport_latency_big(&self) -> u32{ self.le_create_big_complete.as_ref().transport_latency_big}
pub fn get_phy(&self) -> SecondaryPhyType{ self.le_create_big_complete.as_ref().phy}
pub fn get_nse(&self) -> u8{ self.le_create_big_complete.as_ref().nse}
pub fn get_bn(&self) -> u8{ self.le_create_big_complete.as_ref().bn}
pub fn get_pto(&self) -> u8{ self.le_create_big_complete.as_ref().pto}
pub fn get_irc(&self) -> u8{ self.le_create_big_complete.as_ref().irc}
pub fn get_max_pdu(&self) -> u16{ self.le_create_big_complete.as_ref().max_pdu}
pub fn get_iso_interval(&self) -> u16{ self.le_create_big_complete.as_ref().iso_interval}
pub fn get_connection_handle(&self) -> &Vec::<u16>{ &self.le_create_big_complete.as_ref().connection_handle}
}
impl Into<EventPacket> for LeCreateBigCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeCreateBigCompletePacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeCreateBigCompleteBuilder {pub fn build(self) -> LeCreateBigCompletePacket {let le_create_big_complete= Arc::new(LeCreateBigCompleteData {status: self.status, big_handle: self.big_handle, big_sync_delay: self.big_sync_delay, transport_latency_big: self.transport_latency_big, phy: self.phy, nse: self.nse, bn: self.bn, pto: self.pto, irc: self.irc, max_pdu: self.max_pdu, iso_interval: self.iso_interval, connection_handle: self.connection_handle, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::CreateBigComplete, child: LeMetaEventDataChild::LeCreateBigComplete(le_create_big_complete),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeCreateBigCompletePacket::new(event)}
}
impl Into<EventPacket> for LeCreateBigCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeCreateBigCompleteBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct LeTerminateBigCompleteData {big_handle: u8, reason: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeTerminateBigCompletePacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_terminate_big_complete: Arc<LeTerminateBigCompleteData>,}
#[derive(Debug)] pub struct LeTerminateBigCompleteBuilder {pub big_handle: u8, pub reason: ErrorCode, }
impl LeTerminateBigCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeTerminateBigComplete".to_string(),    field: "big_handle".to_string(),    wanted: 4,    got: bytes.len()});}let big_handle = u8::from_le_bytes([bytes[3]]);if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeTerminateBigComplete".to_string(),    field: "reason".to_string(),    wanted: 5,    got: bytes.len()});}let reason = u8::from_le_bytes([bytes[4]]);let reason = ErrorCode::from_u8(reason).unwrap();Ok(Self {big_handle, reason, })
}
fn write_to(&self, buffer: &mut BytesMut) {let big_handle = self.big_handle;buffer[3..4].copy_from_slice(&big_handle.to_le_bytes()[0..1]);let reason = self.reason.to_u8().unwrap();buffer[4..5].copy_from_slice(&reason.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for LeTerminateBigCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeTerminateBigCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_terminate_big_complete = match &le_meta_event.child {LeMetaEventDataChild::LeTerminateBigComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeTerminateBigComplete"),};Self {event,le_meta_event,le_terminate_big_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_big_handle(&self) -> u8{ self.le_terminate_big_complete.as_ref().big_handle}
pub fn get_reason(&self) -> ErrorCode{ self.le_terminate_big_complete.as_ref().reason}
}
impl Into<EventPacket> for LeTerminateBigCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeTerminateBigCompletePacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeTerminateBigCompleteBuilder {pub fn build(self) -> LeTerminateBigCompletePacket {let le_terminate_big_complete= Arc::new(LeTerminateBigCompleteData {big_handle: self.big_handle, reason: self.reason, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::TerminateBigComplete, child: LeMetaEventDataChild::LeTerminateBigComplete(le_terminate_big_complete),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeTerminateBigCompletePacket::new(event)}
}
impl Into<EventPacket> for LeTerminateBigCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeTerminateBigCompleteBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct LeBigSyncEstablishedData {status: ErrorCode, big_handle: u8, transport_latency_big: u32, nse: u8, bn: u8, pto: u8, irc: u8, max_pdu: u16, iso_interval: u16, connection_handle: Vec::<u16>, }
#[derive(Debug, Clone)] pub struct LeBigSyncEstablishedPacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_big_sync_established: Arc<LeBigSyncEstablishedData>,}
#[derive(Debug)] pub struct LeBigSyncEstablishedBuilder {pub status: ErrorCode, pub big_handle: u8, pub transport_latency_big: u32, pub nse: u8, pub bn: u8, pub pto: u8, pub irc: u8, pub max_pdu: u16, pub iso_interval: u16, pub connection_handle: Vec::<u16>, }
impl LeBigSyncEstablishedData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeBigSyncEstablished".to_string(),    field: "status".to_string(),    wanted: 4,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[3]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeBigSyncEstablished".to_string(),    field: "big_handle".to_string(),    wanted: 5,    got: bytes.len()});}let big_handle = u8::from_le_bytes([bytes[4]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeBigSyncEstablished".to_string(),    field: "transport_latency_big".to_string(),    wanted: 8,    got: bytes.len()});}let transport_latency_big = u32::from_le_bytes([bytes[5],bytes[6],bytes[7],0]);let transport_latency_big = transport_latency_big & 0xffffff;if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeBigSyncEstablished".to_string(),    field: "nse".to_string(),    wanted: 9,    got: bytes.len()});}let nse = u8::from_le_bytes([bytes[8]]);if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeBigSyncEstablished".to_string(),    field: "bn".to_string(),    wanted: 10,    got: bytes.len()});}let bn = u8::from_le_bytes([bytes[9]]);if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "LeBigSyncEstablished".to_string(),    field: "pto".to_string(),    wanted: 11,    got: bytes.len()});}let pto = u8::from_le_bytes([bytes[10]]);if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "LeBigSyncEstablished".to_string(),    field: "irc".to_string(),    wanted: 12,    got: bytes.len()});}let irc = u8::from_le_bytes([bytes[11]]);if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "LeBigSyncEstablished".to_string(),    field: "max_pdu".to_string(),    wanted: 14,    got: bytes.len()});}let max_pdu = u16::from_le_bytes([bytes[12],bytes[13]]);if bytes.len() < 16 { return Err(Error::InvalidLengthError{    obj: "LeBigSyncEstablished".to_string(),    field: "iso_interval".to_string(),    wanted: 16,    got: bytes.len()});}let iso_interval = u16::from_le_bytes([bytes[14],bytes[15]]);if bytes.len() < 17 { return Err(Error::InvalidLengthError{    obj: "LeBigSyncEstablished".to_string(),    field: "connection_handle_size".to_string(),    wanted: 17,    got: bytes.len()});}let connection_handle_size = u8::from_le_bytes([bytes[16]]);let want_ = 17 + (connection_handle_size as usize);if bytes.len() < want_ { return Err(Error::InvalidLengthError{    obj: "LeBigSyncEstablished".to_string(),    field: "connection_handle".to_string(),    wanted: want_,    got: bytes.len()});}let connection_handle: Vec::<u16> = bytes[17..(17 + connection_handle_size as usize)].to_vec().chunks_exact(2).into_iter().map(|i| u16::from_le_bytes([i[0], i[1]])).collect();Ok(Self {status, big_handle, transport_latency_big, nse, bn, pto, irc, max_pdu, iso_interval, connection_handle, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[3..4].copy_from_slice(&status.to_le_bytes()[0..1]);let big_handle = self.big_handle;buffer[4..5].copy_from_slice(&big_handle.to_le_bytes()[0..1]);let transport_latency_big = self.transport_latency_big;let transport_latency_big = transport_latency_big & 0xffffff;buffer[5..8].copy_from_slice(&transport_latency_big.to_le_bytes()[0..3]);let nse = self.nse;buffer[8..9].copy_from_slice(&nse.to_le_bytes()[0..1]);let bn = self.bn;buffer[9..10].copy_from_slice(&bn.to_le_bytes()[0..1]);let pto = self.pto;buffer[10..11].copy_from_slice(&pto.to_le_bytes()[0..1]);let irc = self.irc;buffer[11..12].copy_from_slice(&irc.to_le_bytes()[0..1]);let max_pdu = self.max_pdu;buffer[12..14].copy_from_slice(&max_pdu.to_le_bytes()[0..2]);let iso_interval = self.iso_interval;buffer[14..16].copy_from_slice(&iso_interval.to_le_bytes()[0..2]);let connection_handle_bytes = self.connection_handle.len() * ((/* Bits: */ 16 + /* Dynamic: */ 0) / 8);let connection_handle_size = u8::try_from(connection_handle_bytes).expect("payload size did not fit");buffer[16..17].copy_from_slice(&connection_handle_size.to_le_bytes()[0..1]);for (i, e) in self.connection_handle.iter().enumerate() {buffer[17+i..17+i+2].copy_from_slice(&e.to_le_bytes())}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 14;let ret = ret + (self.connection_handle.len() * ((/* Bits: */ 16 + /* Dynamic: */ 0) / 8));ret}
}
impl Packet for LeBigSyncEstablishedPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeBigSyncEstablishedPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_big_sync_established = match &le_meta_event.child {LeMetaEventDataChild::LeBigSyncEstablished(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBigSyncEstablished"),};Self {event,le_meta_event,le_big_sync_established,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_status(&self) -> ErrorCode{ self.le_big_sync_established.as_ref().status}
pub fn get_big_handle(&self) -> u8{ self.le_big_sync_established.as_ref().big_handle}
pub fn get_transport_latency_big(&self) -> u32{ self.le_big_sync_established.as_ref().transport_latency_big}
pub fn get_nse(&self) -> u8{ self.le_big_sync_established.as_ref().nse}
pub fn get_bn(&self) -> u8{ self.le_big_sync_established.as_ref().bn}
pub fn get_pto(&self) -> u8{ self.le_big_sync_established.as_ref().pto}
pub fn get_irc(&self) -> u8{ self.le_big_sync_established.as_ref().irc}
pub fn get_max_pdu(&self) -> u16{ self.le_big_sync_established.as_ref().max_pdu}
pub fn get_iso_interval(&self) -> u16{ self.le_big_sync_established.as_ref().iso_interval}
pub fn get_connection_handle(&self) -> &Vec::<u16>{ &self.le_big_sync_established.as_ref().connection_handle}
}
impl Into<EventPacket> for LeBigSyncEstablishedPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeBigSyncEstablishedPacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeBigSyncEstablishedBuilder {pub fn build(self) -> LeBigSyncEstablishedPacket {let le_big_sync_established= Arc::new(LeBigSyncEstablishedData {status: self.status, big_handle: self.big_handle, transport_latency_big: self.transport_latency_big, nse: self.nse, bn: self.bn, pto: self.pto, irc: self.irc, max_pdu: self.max_pdu, iso_interval: self.iso_interval, connection_handle: self.connection_handle, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::BigSyncEstablished, child: LeMetaEventDataChild::LeBigSyncEstablished(le_big_sync_established),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeBigSyncEstablishedPacket::new(event)}
}
impl Into<EventPacket> for LeBigSyncEstablishedBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeBigSyncEstablishedBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct LeBigSyncLostData {big_handle: u8, reason: ErrorCode, }
#[derive(Debug, Clone)] pub struct LeBigSyncLostPacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_big_sync_lost: Arc<LeBigSyncLostData>,}
#[derive(Debug)] pub struct LeBigSyncLostBuilder {pub big_handle: u8, pub reason: ErrorCode, }
impl LeBigSyncLostData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeBigSyncLost".to_string(),    field: "big_handle".to_string(),    wanted: 4,    got: bytes.len()});}let big_handle = u8::from_le_bytes([bytes[3]]);if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeBigSyncLost".to_string(),    field: "reason".to_string(),    wanted: 5,    got: bytes.len()});}let reason = u8::from_le_bytes([bytes[4]]);let reason = ErrorCode::from_u8(reason).unwrap();Ok(Self {big_handle, reason, })
}
fn write_to(&self, buffer: &mut BytesMut) {let big_handle = self.big_handle;buffer[3..4].copy_from_slice(&big_handle.to_le_bytes()[0..1]);let reason = self.reason.to_u8().unwrap();buffer[4..5].copy_from_slice(&reason.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for LeBigSyncLostPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeBigSyncLostPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_big_sync_lost = match &le_meta_event.child {LeMetaEventDataChild::LeBigSyncLost(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBigSyncLost"),};Self {event,le_meta_event,le_big_sync_lost,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_big_handle(&self) -> u8{ self.le_big_sync_lost.as_ref().big_handle}
pub fn get_reason(&self) -> ErrorCode{ self.le_big_sync_lost.as_ref().reason}
}
impl Into<EventPacket> for LeBigSyncLostPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeBigSyncLostPacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeBigSyncLostBuilder {pub fn build(self) -> LeBigSyncLostPacket {let le_big_sync_lost= Arc::new(LeBigSyncLostData {big_handle: self.big_handle, reason: self.reason, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::BigSyncLost, child: LeMetaEventDataChild::LeBigSyncLost(le_big_sync_lost),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeBigSyncLostPacket::new(event)}
}
impl Into<EventPacket> for LeBigSyncLostBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeBigSyncLostBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct LeRequestPeerScaCompleteData {status: ErrorCode, connection_handle: u16, peer_clock_accuracy: ClockAccuracy, }
#[derive(Debug, Clone)] pub struct LeRequestPeerScaCompletePacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_request_peer_sca_complete: Arc<LeRequestPeerScaCompleteData>,}
#[derive(Debug)] pub struct LeRequestPeerScaCompleteBuilder {pub status: ErrorCode, pub connection_handle: u16, pub peer_clock_accuracy: ClockAccuracy, }
impl LeRequestPeerScaCompleteData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeRequestPeerScaComplete".to_string(),    field: "status".to_string(),    wanted: 4,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[3]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeRequestPeerScaComplete".to_string(),    field: "connection_handle".to_string(),    wanted: 6,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[4],bytes[5]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeRequestPeerScaComplete".to_string(),    field: "peer_clock_accuracy".to_string(),    wanted: 7,    got: bytes.len()});}let peer_clock_accuracy = u8::from_le_bytes([bytes[6]]);let peer_clock_accuracy = ClockAccuracy::from_u8(peer_clock_accuracy).unwrap();Ok(Self {status, connection_handle, peer_clock_accuracy, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[3..4].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[4..6].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let peer_clock_accuracy = self.peer_clock_accuracy.to_u8().unwrap();buffer[6..7].copy_from_slice(&peer_clock_accuracy.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl Packet for LeRequestPeerScaCompletePacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeRequestPeerScaCompletePacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_request_peer_sca_complete = match &le_meta_event.child {LeMetaEventDataChild::LeRequestPeerScaComplete(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeRequestPeerScaComplete"),};Self {event,le_meta_event,le_request_peer_sca_complete,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_status(&self) -> ErrorCode{ self.le_request_peer_sca_complete.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_request_peer_sca_complete.as_ref().connection_handle}
pub fn get_peer_clock_accuracy(&self) -> ClockAccuracy{ self.le_request_peer_sca_complete.as_ref().peer_clock_accuracy}
}
impl Into<EventPacket> for LeRequestPeerScaCompletePacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeRequestPeerScaCompletePacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeRequestPeerScaCompleteBuilder {pub fn build(self) -> LeRequestPeerScaCompletePacket {let le_request_peer_sca_complete= Arc::new(LeRequestPeerScaCompleteData {status: self.status, connection_handle: self.connection_handle, peer_clock_accuracy: self.peer_clock_accuracy, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::RequestPeerScaComplete, child: LeMetaEventDataChild::LeRequestPeerScaComplete(le_request_peer_sca_complete),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeRequestPeerScaCompletePacket::new(event)}
}
impl Into<EventPacket> for LeRequestPeerScaCompleteBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeRequestPeerScaCompleteBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct LePathLossThresholdData {connection_handle: u16, current_path_loss: u8, zone_entered: PathLossZone, }
#[derive(Debug, Clone)] pub struct LePathLossThresholdPacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_path_loss_threshold: Arc<LePathLossThresholdData>,}
#[derive(Debug)] pub struct LePathLossThresholdBuilder {pub connection_handle: u16, pub current_path_loss: u8, pub zone_entered: PathLossZone, }
impl LePathLossThresholdData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LePathLossThreshold".to_string(),    field: "connection_handle".to_string(),    wanted: 5,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LePathLossThreshold".to_string(),    field: "current_path_loss".to_string(),    wanted: 6,    got: bytes.len()});}let current_path_loss = u8::from_le_bytes([bytes[5]]);if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LePathLossThreshold".to_string(),    field: "zone_entered".to_string(),    wanted: 7,    got: bytes.len()});}let zone_entered = u8::from_le_bytes([bytes[6]]);let zone_entered = PathLossZone::from_u8(zone_entered).unwrap();Ok(Self {connection_handle, current_path_loss, zone_entered, })
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[3..5].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let current_path_loss = self.current_path_loss;buffer[5..6].copy_from_slice(&current_path_loss.to_le_bytes()[0..1]);let zone_entered = self.zone_entered.to_u8().unwrap();buffer[6..7].copy_from_slice(&zone_entered.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl Packet for LePathLossThresholdPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LePathLossThresholdPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_path_loss_threshold = match &le_meta_event.child {LeMetaEventDataChild::LePathLossThreshold(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LePathLossThreshold"),};Self {event,le_meta_event,le_path_loss_threshold,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_connection_handle(&self) -> u16{ self.le_path_loss_threshold.as_ref().connection_handle}
pub fn get_current_path_loss(&self) -> u8{ self.le_path_loss_threshold.as_ref().current_path_loss}
pub fn get_zone_entered(&self) -> PathLossZone{ self.le_path_loss_threshold.as_ref().zone_entered}
}
impl Into<EventPacket> for LePathLossThresholdPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LePathLossThresholdPacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LePathLossThresholdBuilder {pub fn build(self) -> LePathLossThresholdPacket {let le_path_loss_threshold= Arc::new(LePathLossThresholdData {connection_handle: self.connection_handle, current_path_loss: self.current_path_loss, zone_entered: self.zone_entered, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::PathLossThreshold, child: LeMetaEventDataChild::LePathLossThreshold(le_path_loss_threshold),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LePathLossThresholdPacket::new(event)}
}
impl Into<EventPacket> for LePathLossThresholdBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LePathLossThresholdBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct LeTransmitPowerReportingData {status: ErrorCode, connection_handle: u16, reason: u8, phy: u8, transmit_power_level: u8, transmit_power_level_flag: u8, delta: u8, }
#[derive(Debug, Clone)] pub struct LeTransmitPowerReportingPacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_transmit_power_reporting: Arc<LeTransmitPowerReportingData>,}
#[derive(Debug)] pub struct LeTransmitPowerReportingBuilder {pub status: ErrorCode, pub connection_handle: u16, pub reason: u8, pub phy: u8, pub transmit_power_level: u8, pub transmit_power_level_flag: u8, pub delta: u8, }
impl LeTransmitPowerReportingData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LeTransmitPowerReporting".to_string(),    field: "status".to_string(),    wanted: 4,    got: bytes.len()});}let status = u8::from_le_bytes([bytes[3]]);let status = ErrorCode::from_u8(status).unwrap();if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeTransmitPowerReporting".to_string(),    field: "connection_handle".to_string(),    wanted: 6,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[4],bytes[5]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeTransmitPowerReporting".to_string(),    field: "reason".to_string(),    wanted: 7,    got: bytes.len()});}let reason = u8::from_le_bytes([bytes[6]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "LeTransmitPowerReporting".to_string(),    field: "phy".to_string(),    wanted: 8,    got: bytes.len()});}let phy = u8::from_le_bytes([bytes[7]]);if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeTransmitPowerReporting".to_string(),    field: "transmit_power_level".to_string(),    wanted: 9,    got: bytes.len()});}let transmit_power_level = u8::from_le_bytes([bytes[8]]);if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeTransmitPowerReporting".to_string(),    field: "transmit_power_level_flag".to_string(),    wanted: 10,    got: bytes.len()});}let transmit_power_level_flag = u8::from_le_bytes([bytes[9]]);if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "LeTransmitPowerReporting".to_string(),    field: "delta".to_string(),    wanted: 11,    got: bytes.len()});}let delta = u8::from_le_bytes([bytes[10]]);Ok(Self {status, connection_handle, reason, phy, transmit_power_level, transmit_power_level_flag, delta, })
}
fn write_to(&self, buffer: &mut BytesMut) {let status = self.status.to_u8().unwrap();buffer[3..4].copy_from_slice(&status.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[4..6].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let reason = self.reason;buffer[6..7].copy_from_slice(&reason.to_le_bytes()[0..1]);let phy = self.phy;buffer[7..8].copy_from_slice(&phy.to_le_bytes()[0..1]);let transmit_power_level = self.transmit_power_level;buffer[8..9].copy_from_slice(&transmit_power_level.to_le_bytes()[0..1]);let transmit_power_level_flag = self.transmit_power_level_flag;buffer[9..10].copy_from_slice(&transmit_power_level_flag.to_le_bytes()[0..1]);let delta = self.delta;buffer[10..11].copy_from_slice(&delta.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 8;ret}
}
impl Packet for LeTransmitPowerReportingPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeTransmitPowerReportingPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_transmit_power_reporting = match &le_meta_event.child {LeMetaEventDataChild::LeTransmitPowerReporting(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeTransmitPowerReporting"),};Self {event,le_meta_event,le_transmit_power_reporting,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_status(&self) -> ErrorCode{ self.le_transmit_power_reporting.as_ref().status}
pub fn get_connection_handle(&self) -> u16{ self.le_transmit_power_reporting.as_ref().connection_handle}
pub fn get_reason(&self) -> u8{ self.le_transmit_power_reporting.as_ref().reason}
pub fn get_phy(&self) -> u8{ self.le_transmit_power_reporting.as_ref().phy}
pub fn get_transmit_power_level(&self) -> u8{ self.le_transmit_power_reporting.as_ref().transmit_power_level}
pub fn get_transmit_power_level_flag(&self) -> u8{ self.le_transmit_power_reporting.as_ref().transmit_power_level_flag}
pub fn get_delta(&self) -> u8{ self.le_transmit_power_reporting.as_ref().delta}
}
impl Into<EventPacket> for LeTransmitPowerReportingPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeTransmitPowerReportingPacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeTransmitPowerReportingBuilder {pub fn build(self) -> LeTransmitPowerReportingPacket {let le_transmit_power_reporting= Arc::new(LeTransmitPowerReportingData {status: self.status, connection_handle: self.connection_handle, reason: self.reason, phy: self.phy, transmit_power_level: self.transmit_power_level, transmit_power_level_flag: self.transmit_power_level_flag, delta: self.delta, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::TransmitPowerReporting, child: LeMetaEventDataChild::LeTransmitPowerReporting(le_transmit_power_reporting),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeTransmitPowerReportingPacket::new(event)}
}
impl Into<EventPacket> for LeTransmitPowerReportingBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeTransmitPowerReportingBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] struct LeBigInfoAdvertisingReportData {sync_handle: u16, num_bis: u8, nse: u8, iso_interval: u16, bn: u8, pto: u8, irc: u8, max_pdu: u16, sdu_interval: u32, max_sdu: u16, phy: SecondaryPhyType, framing: Enable, encryption: Enable, }
#[derive(Debug, Clone)] pub struct LeBigInfoAdvertisingReportPacket {event: Arc<EventData>,le_meta_event: Arc<LeMetaEventData>,le_big_info_advertising_report: Arc<LeBigInfoAdvertisingReportData>,}
#[derive(Debug)] pub struct LeBigInfoAdvertisingReportBuilder {pub sync_handle: u16, pub num_bis: u8, pub nse: u8, pub iso_interval: u16, pub bn: u8, pub pto: u8, pub irc: u8, pub max_pdu: u16, pub sdu_interval: u32, pub max_sdu: u16, pub phy: SecondaryPhyType, pub framing: Enable, pub encryption: Enable, }
impl LeBigInfoAdvertisingReportData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LeBigInfoAdvertisingReport".to_string(),    field: "sync_handle".to_string(),    wanted: 5,    got: bytes.len()});}let sync_handle = u16::from_le_bytes([bytes[3],bytes[4]]);let sync_handle = sync_handle & 0xfff;if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LeBigInfoAdvertisingReport".to_string(),    field: "num_bis".to_string(),    wanted: 6,    got: bytes.len()});}let num_bis = u8::from_le_bytes([bytes[5]]);if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "LeBigInfoAdvertisingReport".to_string(),    field: "nse".to_string(),    wanted: 7,    got: bytes.len()});}let nse = u8::from_le_bytes([bytes[6]]);if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "LeBigInfoAdvertisingReport".to_string(),    field: "iso_interval".to_string(),    wanted: 9,    got: bytes.len()});}let iso_interval = u16::from_le_bytes([bytes[7],bytes[8]]);if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "LeBigInfoAdvertisingReport".to_string(),    field: "bn".to_string(),    wanted: 10,    got: bytes.len()});}let bn = u8::from_le_bytes([bytes[9]]);if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "LeBigInfoAdvertisingReport".to_string(),    field: "pto".to_string(),    wanted: 11,    got: bytes.len()});}let pto = u8::from_le_bytes([bytes[10]]);if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "LeBigInfoAdvertisingReport".to_string(),    field: "irc".to_string(),    wanted: 12,    got: bytes.len()});}let irc = u8::from_le_bytes([bytes[11]]);if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "LeBigInfoAdvertisingReport".to_string(),    field: "max_pdu".to_string(),    wanted: 14,    got: bytes.len()});}let max_pdu = u16::from_le_bytes([bytes[12],bytes[13]]);if bytes.len() < 17 { return Err(Error::InvalidLengthError{    obj: "LeBigInfoAdvertisingReport".to_string(),    field: "sdu_interval".to_string(),    wanted: 17,    got: bytes.len()});}let sdu_interval = u32::from_le_bytes([bytes[14],bytes[15],bytes[16],0]);let sdu_interval = sdu_interval & 0xffffff;if bytes.len() < 19 { return Err(Error::InvalidLengthError{    obj: "LeBigInfoAdvertisingReport".to_string(),    field: "max_sdu".to_string(),    wanted: 19,    got: bytes.len()});}let max_sdu = u16::from_le_bytes([bytes[17],bytes[18]]);if bytes.len() < 20 { return Err(Error::InvalidLengthError{    obj: "LeBigInfoAdvertisingReport".to_string(),    field: "phy".to_string(),    wanted: 20,    got: bytes.len()});}let phy = u8::from_le_bytes([bytes[19]]);let phy = SecondaryPhyType::from_u8(phy).unwrap();if bytes.len() < 21 { return Err(Error::InvalidLengthError{    obj: "LeBigInfoAdvertisingReport".to_string(),    field: "framing".to_string(),    wanted: 21,    got: bytes.len()});}let framing = u8::from_le_bytes([bytes[20]]);let framing = Enable::from_u8(framing).unwrap();if bytes.len() < 22 { return Err(Error::InvalidLengthError{    obj: "LeBigInfoAdvertisingReport".to_string(),    field: "encryption".to_string(),    wanted: 22,    got: bytes.len()});}let encryption = u8::from_le_bytes([bytes[21]]);let encryption = Enable::from_u8(encryption).unwrap();Ok(Self {sync_handle, num_bis, nse, iso_interval, bn, pto, irc, max_pdu, sdu_interval, max_sdu, phy, framing, encryption, })
}
fn write_to(&self, buffer: &mut BytesMut) {let sync_handle = self.sync_handle;let sync_handle = sync_handle & 0xfff;buffer[3..5].copy_from_slice(&sync_handle.to_le_bytes()[0..2]);let num_bis = self.num_bis;buffer[5..6].copy_from_slice(&num_bis.to_le_bytes()[0..1]);let nse = self.nse;buffer[6..7].copy_from_slice(&nse.to_le_bytes()[0..1]);let iso_interval = self.iso_interval;buffer[7..9].copy_from_slice(&iso_interval.to_le_bytes()[0..2]);let bn = self.bn;buffer[9..10].copy_from_slice(&bn.to_le_bytes()[0..1]);let pto = self.pto;buffer[10..11].copy_from_slice(&pto.to_le_bytes()[0..1]);let irc = self.irc;buffer[11..12].copy_from_slice(&irc.to_le_bytes()[0..1]);let max_pdu = self.max_pdu;buffer[12..14].copy_from_slice(&max_pdu.to_le_bytes()[0..2]);let sdu_interval = self.sdu_interval;let sdu_interval = sdu_interval & 0xffffff;buffer[14..17].copy_from_slice(&sdu_interval.to_le_bytes()[0..3]);let max_sdu = self.max_sdu;buffer[17..19].copy_from_slice(&max_sdu.to_le_bytes()[0..2]);let phy = self.phy.to_u8().unwrap();buffer[19..20].copy_from_slice(&phy.to_le_bytes()[0..1]);let framing = self.framing.to_u8().unwrap();buffer[20..21].copy_from_slice(&framing.to_le_bytes()[0..1]);let encryption = self.encryption.to_u8().unwrap();buffer[21..22].copy_from_slice(&encryption.to_le_bytes()[0..1]);}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 19;ret}
}
impl Packet for LeBigInfoAdvertisingReportPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LeBigInfoAdvertisingReportPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let le_meta_event = match &event.child {EventDataChild::LeMetaEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeMetaEvent"),};let le_big_info_advertising_report = match &le_meta_event.child {LeMetaEventDataChild::LeBigInfoAdvertisingReport(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LeBigInfoAdvertisingReport"),};Self {event,le_meta_event,le_big_info_advertising_report,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> SubeventCode{ self.le_meta_event.as_ref().subevent_code}
pub fn get_sync_handle(&self) -> u16{ self.le_big_info_advertising_report.as_ref().sync_handle}
pub fn get_num_bis(&self) -> u8{ self.le_big_info_advertising_report.as_ref().num_bis}
pub fn get_nse(&self) -> u8{ self.le_big_info_advertising_report.as_ref().nse}
pub fn get_iso_interval(&self) -> u16{ self.le_big_info_advertising_report.as_ref().iso_interval}
pub fn get_bn(&self) -> u8{ self.le_big_info_advertising_report.as_ref().bn}
pub fn get_pto(&self) -> u8{ self.le_big_info_advertising_report.as_ref().pto}
pub fn get_irc(&self) -> u8{ self.le_big_info_advertising_report.as_ref().irc}
pub fn get_max_pdu(&self) -> u16{ self.le_big_info_advertising_report.as_ref().max_pdu}
pub fn get_sdu_interval(&self) -> u32{ self.le_big_info_advertising_report.as_ref().sdu_interval}
pub fn get_max_sdu(&self) -> u16{ self.le_big_info_advertising_report.as_ref().max_sdu}
pub fn get_phy(&self) -> SecondaryPhyType{ self.le_big_info_advertising_report.as_ref().phy}
pub fn get_framing(&self) -> Enable{ self.le_big_info_advertising_report.as_ref().framing}
pub fn get_encryption(&self) -> Enable{ self.le_big_info_advertising_report.as_ref().encryption}
}
impl Into<EventPacket> for LeBigInfoAdvertisingReportPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<LeMetaEventPacket> for LeBigInfoAdvertisingReportPacket { fn into(self) -> LeMetaEventPacket {LeMetaEventPacket::new(self.event) }}
impl LeBigInfoAdvertisingReportBuilder {pub fn build(self) -> LeBigInfoAdvertisingReportPacket {let le_big_info_advertising_report= Arc::new(LeBigInfoAdvertisingReportData {sync_handle: self.sync_handle, num_bis: self.num_bis, nse: self.nse, iso_interval: self.iso_interval, bn: self.bn, pto: self.pto, irc: self.irc, max_pdu: self.max_pdu, sdu_interval: self.sdu_interval, max_sdu: self.max_sdu, phy: self.phy, framing: self.framing, encryption: self.encryption, });let le_meta_event= Arc::new(LeMetaEventData {subevent_code: SubeventCode::BigInfoAdvertisingReport, child: LeMetaEventDataChild::LeBigInfoAdvertisingReport(le_big_info_advertising_report),});let event= Arc::new(EventData {event_code: EventCode::LeMetaEvent, child: EventDataChild::LeMetaEvent(le_meta_event),});LeBigInfoAdvertisingReportPacket::new(event)}
}
impl Into<EventPacket> for LeBigInfoAdvertisingReportBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<LeMetaEventPacket> for LeBigInfoAdvertisingReportBuilder { fn into(self) -> LeMetaEventPacket { self.build().into() }}


#[derive(Debug)] enum VendorSpecificEventDataChild {StorageThresholdBreachEvent(Arc<StorageThresholdBreachEventData>),LEAdvertisementTrackingEvent(Arc<LEAdvertisementTrackingEventData>),BqrEvent(Arc<BqrEventData>),Payload(Bytes),None,}
impl VendorSpecificEventDataChild {fn get_total_size(&self) -> usize {match self {VendorSpecificEventDataChild::StorageThresholdBreachEvent(value) => value.get_total_size(),VendorSpecificEventDataChild::LEAdvertisementTrackingEvent(value) => value.get_total_size(),VendorSpecificEventDataChild::BqrEvent(value) => value.get_total_size(),VendorSpecificEventDataChild::Payload(p) => p.len(),VendorSpecificEventDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum VendorSpecificEventChild {StorageThresholdBreachEvent(StorageThresholdBreachEventPacket),LEAdvertisementTrackingEvent(LEAdvertisementTrackingEventPacket),BqrEvent(BqrEventPacket),Payload(Bytes),None,}
#[derive(Debug)] struct VendorSpecificEventData {subevent_code: VseSubeventCode, child: VendorSpecificEventDataChild,}
#[derive(Debug, Clone)] pub struct VendorSpecificEventPacket {event: Arc<EventData>,vendor_specific_event: Arc<VendorSpecificEventData>,}
#[derive(Debug)] pub struct VendorSpecificEventBuilder {pub subevent_code: VseSubeventCode, pub payload: Option<Bytes>,}
impl VendorSpecificEventData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 3 { return Err(Error::InvalidLengthError{    obj: "VendorSpecificEvent".to_string(),    field: "subevent_code".to_string(),    wanted: 3,    got: bytes.len()});}let subevent_code = u8::from_le_bytes([bytes[2]]);let subevent_code = VseSubeventCode::from_u8(subevent_code).unwrap();let payload: Vec::<u8> = bytes[3..].into();let child = match subevent_code {VseSubeventCode::BqrEvent if BqrEventData::conforms(&bytes[..]) => {VendorSpecificEventDataChild::BqrEvent(Arc::new(BqrEventData::parse(&bytes[..])?))}
VseSubeventCode::BleThreshold if StorageThresholdBreachEventData::conforms(&bytes[..]) => {VendorSpecificEventDataChild::StorageThresholdBreachEvent(Arc::new(StorageThresholdBreachEventData::parse(&bytes[..])?))}
VseSubeventCode::BleTracking if LEAdvertisementTrackingEventData::conforms(&bytes[..]) => {VendorSpecificEventDataChild::LEAdvertisementTrackingEvent(Arc::new(LEAdvertisementTrackingEventData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "subevent_code".to_string(), value: v as u64}),};
Ok(Self {subevent_code, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let subevent_code = self.subevent_code.to_u8().unwrap();buffer[2..3].copy_from_slice(&subevent_code.to_le_bytes()[0..1]);match &self.child {VendorSpecificEventDataChild::StorageThresholdBreachEvent(value) => value.write_to(buffer),VendorSpecificEventDataChild::LEAdvertisementTrackingEvent(value) => value.write_to(buffer),VendorSpecificEventDataChild::BqrEvent(value) => value.write_to(buffer),VendorSpecificEventDataChild::Payload(p) => buffer[3..].copy_from_slice(&p[..]),VendorSpecificEventDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for VendorSpecificEventPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl VendorSpecificEventPacket { pub fn specialize(&self) -> VendorSpecificEventChild { match &self.vendor_specific_event.child {VendorSpecificEventDataChild::StorageThresholdBreachEvent(_) => VendorSpecificEventChild::StorageThresholdBreachEvent(StorageThresholdBreachEventPacket::new(self.event.clone())),VendorSpecificEventDataChild::LEAdvertisementTrackingEvent(_) => VendorSpecificEventChild::LEAdvertisementTrackingEvent(LEAdvertisementTrackingEventPacket::new(self.event.clone())),VendorSpecificEventDataChild::BqrEvent(_) => VendorSpecificEventChild::BqrEvent(BqrEventPacket::new(self.event.clone())),VendorSpecificEventDataChild::Payload(p) => VendorSpecificEventChild::Payload(p.clone()),VendorSpecificEventDataChild::None => VendorSpecificEventChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let vendor_specific_event = match &event.child {EventDataChild::VendorSpecificEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not VendorSpecificEvent"),};Self {event,vendor_specific_event,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> VseSubeventCode{ self.vendor_specific_event.as_ref().subevent_code}
}
impl Into<EventPacket> for VendorSpecificEventPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl VendorSpecificEventBuilder {pub fn build(self) -> VendorSpecificEventPacket {let vendor_specific_event= Arc::new(VendorSpecificEventData {subevent_code: self.subevent_code, child: match self.payload { None => VendorSpecificEventDataChild::None,Some(bytes) => VendorSpecificEventDataChild::Payload(bytes),},});let event= Arc::new(EventData {event_code: EventCode::VendorSpecific, child: EventDataChild::VendorSpecificEvent(vendor_specific_event),});VendorSpecificEventPacket::new(event)}
}
impl Into<EventPacket> for VendorSpecificEventBuilder { fn into(self) -> EventPacket { self.build().into() }}


#[derive(Debug)] struct StorageThresholdBreachEventData {}
#[derive(Debug, Clone)] pub struct StorageThresholdBreachEventPacket {event: Arc<EventData>,vendor_specific_event: Arc<VendorSpecificEventData>,storage_threshold_breach_event: Arc<StorageThresholdBreachEventData>,}
#[derive(Debug)] pub struct StorageThresholdBreachEventBuilder {}
impl StorageThresholdBreachEventData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {Ok(Self {})
}
fn write_to(&self, buffer: &mut BytesMut) {}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for StorageThresholdBreachEventPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl StorageThresholdBreachEventPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let vendor_specific_event = match &event.child {EventDataChild::VendorSpecificEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not VendorSpecificEvent"),};let storage_threshold_breach_event = match &vendor_specific_event.child {VendorSpecificEventDataChild::StorageThresholdBreachEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not StorageThresholdBreachEvent"),};Self {event,vendor_specific_event,storage_threshold_breach_event,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> VseSubeventCode{ self.vendor_specific_event.as_ref().subevent_code}
}
impl Into<EventPacket> for StorageThresholdBreachEventPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<VendorSpecificEventPacket> for StorageThresholdBreachEventPacket { fn into(self) -> VendorSpecificEventPacket {VendorSpecificEventPacket::new(self.event) }}
impl StorageThresholdBreachEventBuilder {pub fn build(self) -> StorageThresholdBreachEventPacket {let storage_threshold_breach_event= Arc::new(StorageThresholdBreachEventData {});let vendor_specific_event= Arc::new(VendorSpecificEventData {subevent_code: VseSubeventCode::BleThreshold, child: VendorSpecificEventDataChild::StorageThresholdBreachEvent(storage_threshold_breach_event),});let event= Arc::new(EventData {event_code: EventCode::VendorSpecific, child: EventDataChild::VendorSpecificEvent(vendor_specific_event),});StorageThresholdBreachEventPacket::new(event)}
}
impl Into<EventPacket> for StorageThresholdBreachEventBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<VendorSpecificEventPacket> for StorageThresholdBreachEventBuilder { fn into(self) -> VendorSpecificEventPacket { self.build().into() }}


#[derive(Debug)] enum LEAdvertisementTrackingEventDataChild {LEAdvertisementTrackingWithInfoEvent(Arc<LEAdvertisementTrackingWithInfoEventData>),None,}
impl LEAdvertisementTrackingEventDataChild {fn get_total_size(&self) -> usize {match self {LEAdvertisementTrackingEventDataChild::LEAdvertisementTrackingWithInfoEvent(value) => value.get_total_size(),LEAdvertisementTrackingEventDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum LEAdvertisementTrackingEventChild {LEAdvertisementTrackingWithInfoEvent(LEAdvertisementTrackingWithInfoEventPacket),None,}
#[derive(Debug)] struct LEAdvertisementTrackingEventData {apcf_filter_index: u8, advertiser_state: u8, advt_info_present: AdvtInfoPresent, advertiser_address: Address, advertiser_address_type: u8, child: LEAdvertisementTrackingEventDataChild,}
#[derive(Debug, Clone)] pub struct LEAdvertisementTrackingEventPacket {event: Arc<EventData>,vendor_specific_event: Arc<VendorSpecificEventData>,l_e_advertisement_tracking_event: Arc<LEAdvertisementTrackingEventData>,}
#[derive(Debug)] pub struct LEAdvertisementTrackingEventBuilder {pub apcf_filter_index: u8, pub advertiser_state: u8, pub advt_info_present: AdvtInfoPresent, pub advertiser_address: Address, pub advertiser_address_type: u8, }
impl LEAdvertisementTrackingEventData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "LEAdvertisementTrackingEvent".to_string(),    field: "apcf_filter_index".to_string(),    wanted: 4,    got: bytes.len()});}let apcf_filter_index = u8::from_le_bytes([bytes[3]]);if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "LEAdvertisementTrackingEvent".to_string(),    field: "advertiser_state".to_string(),    wanted: 5,    got: bytes.len()});}let advertiser_state = u8::from_le_bytes([bytes[4]]);if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "LEAdvertisementTrackingEvent".to_string(),    field: "advt_info_present".to_string(),    wanted: 6,    got: bytes.len()});}let advt_info_present = u8::from_le_bytes([bytes[5]]);let advt_info_present = AdvtInfoPresent::from_u8(advt_info_present).unwrap();if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "LEAdvertisementTrackingEvent".to_string(),    field: "advertiser_address".to_string(),    wanted: 12,    got: bytes.len()});}let advertiser_address = bytes[6..12].try_into().unwrap();if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "LEAdvertisementTrackingEvent".to_string(),    field: "advertiser_address_type".to_string(),    wanted: 13,    got: bytes.len()});}let advertiser_address_type = u8::from_le_bytes([bytes[12]]);let child = match LEAdvertisementTrackingWithInfoEventData::parse(&bytes[..]) { Ok(c) if LEAdvertisementTrackingWithInfoEventData::conforms(&bytes[..]) => {LEAdvertisementTrackingEventDataChild::LEAdvertisementTrackingWithInfoEvent(Arc::new(c)) }, Err(Error::InvalidLengthError { .. }) => LEAdvertisementTrackingEventDataChild::None, _ => return Err(Error::InvalidPacketError),};Ok(Self {apcf_filter_index, advertiser_state, advt_info_present, advertiser_address, advertiser_address_type, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let apcf_filter_index = self.apcf_filter_index;buffer[3..4].copy_from_slice(&apcf_filter_index.to_le_bytes()[0..1]);let advertiser_state = self.advertiser_state;buffer[4..5].copy_from_slice(&advertiser_state.to_le_bytes()[0..1]);let advt_info_present = self.advt_info_present.to_u8().unwrap();buffer[5..6].copy_from_slice(&advt_info_present.to_le_bytes()[0..1]);let advertiser_address: [u8; 6] = self.advertiser_address.into();buffer[6..12].copy_from_slice(&advertiser_address);let advertiser_address_type = self.advertiser_address_type;buffer[12..13].copy_from_slice(&advertiser_address_type.to_le_bytes()[0..1]);match &self.child {LEAdvertisementTrackingEventDataChild::LEAdvertisementTrackingWithInfoEvent(value) => value.write_to(buffer),LEAdvertisementTrackingEventDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 10;ret}
}
impl Packet for LEAdvertisementTrackingEventPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LEAdvertisementTrackingEventPacket { pub fn specialize(&self) -> LEAdvertisementTrackingEventChild { match &self.l_e_advertisement_tracking_event.child {LEAdvertisementTrackingEventDataChild::LEAdvertisementTrackingWithInfoEvent(_) => LEAdvertisementTrackingEventChild::LEAdvertisementTrackingWithInfoEvent(LEAdvertisementTrackingWithInfoEventPacket::new(self.event.clone())),LEAdvertisementTrackingEventDataChild::None => LEAdvertisementTrackingEventChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let vendor_specific_event = match &event.child {EventDataChild::VendorSpecificEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not VendorSpecificEvent"),};let l_e_advertisement_tracking_event = match &vendor_specific_event.child {VendorSpecificEventDataChild::LEAdvertisementTrackingEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LEAdvertisementTrackingEvent"),};Self {event,vendor_specific_event,l_e_advertisement_tracking_event,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> VseSubeventCode{ self.vendor_specific_event.as_ref().subevent_code}
pub fn get_apcf_filter_index(&self) -> u8{ self.l_e_advertisement_tracking_event.as_ref().apcf_filter_index}
pub fn get_advertiser_state(&self) -> u8{ self.l_e_advertisement_tracking_event.as_ref().advertiser_state}
pub fn get_advt_info_present(&self) -> AdvtInfoPresent{ self.l_e_advertisement_tracking_event.as_ref().advt_info_present}
pub fn get_advertiser_address(&self) -> Address{ self.l_e_advertisement_tracking_event.as_ref().advertiser_address}
pub fn get_advertiser_address_type(&self) -> u8{ self.l_e_advertisement_tracking_event.as_ref().advertiser_address_type}
}
impl Into<EventPacket> for LEAdvertisementTrackingEventPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<VendorSpecificEventPacket> for LEAdvertisementTrackingEventPacket { fn into(self) -> VendorSpecificEventPacket {VendorSpecificEventPacket::new(self.event) }}
impl LEAdvertisementTrackingEventBuilder {pub fn build(self) -> LEAdvertisementTrackingEventPacket {let l_e_advertisement_tracking_event= Arc::new(LEAdvertisementTrackingEventData {apcf_filter_index: self.apcf_filter_index, advertiser_state: self.advertiser_state, advt_info_present: self.advt_info_present, advertiser_address: self.advertiser_address, advertiser_address_type: self.advertiser_address_type, child: LEAdvertisementTrackingEventDataChild::None,});let vendor_specific_event= Arc::new(VendorSpecificEventData {subevent_code: VseSubeventCode::BleTracking, child: VendorSpecificEventDataChild::LEAdvertisementTrackingEvent(l_e_advertisement_tracking_event),});let event= Arc::new(EventData {event_code: EventCode::VendorSpecific, child: EventDataChild::VendorSpecificEvent(vendor_specific_event),});LEAdvertisementTrackingEventPacket::new(event)}
}
impl Into<EventPacket> for LEAdvertisementTrackingEventBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<VendorSpecificEventPacket> for LEAdvertisementTrackingEventBuilder { fn into(self) -> VendorSpecificEventPacket { self.build().into() }}


#[derive(Debug)] struct LEAdvertisementTrackingWithInfoEventData {tx_power: u8, rssi: u8, timestamp: u16, adv_packet: Vec::<u8>, scan_response: Vec::<u8>, }
#[derive(Debug, Clone)] pub struct LEAdvertisementTrackingWithInfoEventPacket {event: Arc<EventData>,vendor_specific_event: Arc<VendorSpecificEventData>,l_e_advertisement_tracking_event: Arc<LEAdvertisementTrackingEventData>,l_e_advertisement_tracking_with_info_event: Arc<LEAdvertisementTrackingWithInfoEventData>,}
#[derive(Debug)] pub struct LEAdvertisementTrackingWithInfoEventBuilder {pub apcf_filter_index: u8, pub advertiser_state: u8, pub advt_info_present: AdvtInfoPresent, pub advertiser_address: Address, pub advertiser_address_type: u8, pub tx_power: u8, pub rssi: u8, pub timestamp: u16, pub adv_packet: Vec::<u8>, pub scan_response: Vec::<u8>, }
impl LEAdvertisementTrackingWithInfoEventData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 14 { return Err(Error::InvalidLengthError{    obj: "LEAdvertisementTrackingWithInfoEvent".to_string(),    field: "tx_power".to_string(),    wanted: 14,    got: bytes.len()});}let tx_power = u8::from_le_bytes([bytes[13]]);if bytes.len() < 15 { return Err(Error::InvalidLengthError{    obj: "LEAdvertisementTrackingWithInfoEvent".to_string(),    field: "rssi".to_string(),    wanted: 15,    got: bytes.len()});}let rssi = u8::from_le_bytes([bytes[14]]);if bytes.len() < 17 { return Err(Error::InvalidLengthError{    obj: "LEAdvertisementTrackingWithInfoEvent".to_string(),    field: "timestamp".to_string(),    wanted: 17,    got: bytes.len()});}let timestamp = u16::from_le_bytes([bytes[15],bytes[16]]);if bytes.len() < 18 { return Err(Error::InvalidLengthError{    obj: "LEAdvertisementTrackingWithInfoEvent".to_string(),    field: "adv_packet_size".to_string(),    wanted: 18,    got: bytes.len()});}let adv_packet_size = u8::from_le_bytes([bytes[17]]);let want_ = 18 + (adv_packet_size as usize);if bytes.len() < want_ { return Err(Error::InvalidLengthError{    obj: "LEAdvertisementTrackingWithInfoEvent".to_string(),    field: "adv_packet".to_string(),    wanted: want_,    got: bytes.len()});}let adv_packet: Vec::<u8> = bytes[18..(18 + adv_packet_size as usize)].to_vec().chunks_exact(1).into_iter().map(|i| u8::from_le_bytes([i[0]])).collect();if bytes.len() < 19 { return Err(Error::InvalidLengthError{    obj: "LEAdvertisementTrackingWithInfoEvent".to_string(),    field: "scan_response_size".to_string(),    wanted: 19,    got: bytes.len()});}let scan_response_size = u8::from_le_bytes([bytes[18]]);let want_ = 19 + (scan_response_size as usize);if bytes.len() < want_ { return Err(Error::InvalidLengthError{    obj: "LEAdvertisementTrackingWithInfoEvent".to_string(),    field: "scan_response".to_string(),    wanted: want_,    got: bytes.len()});}let scan_response: Vec::<u8> = bytes[19..(19 + scan_response_size as usize)].to_vec().chunks_exact(1).into_iter().map(|i| u8::from_le_bytes([i[0]])).collect();Ok(Self {tx_power, rssi, timestamp, adv_packet, scan_response, })
}
fn write_to(&self, buffer: &mut BytesMut) {let tx_power = self.tx_power;buffer[13..14].copy_from_slice(&tx_power.to_le_bytes()[0..1]);let rssi = self.rssi;buffer[14..15].copy_from_slice(&rssi.to_le_bytes()[0..1]);let timestamp = self.timestamp;buffer[15..17].copy_from_slice(&timestamp.to_le_bytes()[0..2]);let adv_packet_bytes = self.adv_packet.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8);let adv_packet_size = u8::try_from(adv_packet_bytes).expect("payload size did not fit");buffer[17..18].copy_from_slice(&adv_packet_size.to_le_bytes()[0..1]);for (i, e) in self.adv_packet.iter().enumerate() {buffer[18+i..18+i+1].copy_from_slice(&e.to_le_bytes())}let scan_response_bytes = self.scan_response.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8);let scan_response_size = u8::try_from(scan_response_bytes).expect("payload size did not fit");buffer[18..19].copy_from_slice(&scan_response_size.to_le_bytes()[0..1]);for (i, e) in self.scan_response.iter().enumerate() {buffer[19+i..19+i+1].copy_from_slice(&e.to_le_bytes())}}
fn get_total_size(&self) -> usize {self.get_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 5;let ret = ret + (self.adv_packet.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8));let ret = ret + 1;let ret = ret + (self.scan_response.len() * ((/* Bits: */ 8 + /* Dynamic: */ 0) / 8));ret}
}
impl Packet for LEAdvertisementTrackingWithInfoEventPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl LEAdvertisementTrackingWithInfoEventPacket { fn new(root: Arc<EventData>) -> Self {let event = root;let vendor_specific_event = match &event.child {EventDataChild::VendorSpecificEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not VendorSpecificEvent"),};let l_e_advertisement_tracking_event = match &vendor_specific_event.child {VendorSpecificEventDataChild::LEAdvertisementTrackingEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LEAdvertisementTrackingEvent"),};let l_e_advertisement_tracking_with_info_event = match &l_e_advertisement_tracking_event.child {LEAdvertisementTrackingEventDataChild::LEAdvertisementTrackingWithInfoEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not LEAdvertisementTrackingWithInfoEvent"),};Self {event,vendor_specific_event,l_e_advertisement_tracking_event,l_e_advertisement_tracking_with_info_event,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> VseSubeventCode{ self.vendor_specific_event.as_ref().subevent_code}
pub fn get_apcf_filter_index(&self) -> u8{ self.l_e_advertisement_tracking_event.as_ref().apcf_filter_index}
pub fn get_advertiser_state(&self) -> u8{ self.l_e_advertisement_tracking_event.as_ref().advertiser_state}
pub fn get_advt_info_present(&self) -> AdvtInfoPresent{ self.l_e_advertisement_tracking_event.as_ref().advt_info_present}
pub fn get_advertiser_address(&self) -> Address{ self.l_e_advertisement_tracking_event.as_ref().advertiser_address}
pub fn get_advertiser_address_type(&self) -> u8{ self.l_e_advertisement_tracking_event.as_ref().advertiser_address_type}
pub fn get_tx_power(&self) -> u8{ self.l_e_advertisement_tracking_with_info_event.as_ref().tx_power}
pub fn get_rssi(&self) -> u8{ self.l_e_advertisement_tracking_with_info_event.as_ref().rssi}
pub fn get_timestamp(&self) -> u16{ self.l_e_advertisement_tracking_with_info_event.as_ref().timestamp}
pub fn get_adv_packet(&self) -> &Vec::<u8>{ &self.l_e_advertisement_tracking_with_info_event.as_ref().adv_packet}
pub fn get_scan_response(&self) -> &Vec::<u8>{ &self.l_e_advertisement_tracking_with_info_event.as_ref().scan_response}
}
impl Into<EventPacket> for LEAdvertisementTrackingWithInfoEventPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<VendorSpecificEventPacket> for LEAdvertisementTrackingWithInfoEventPacket { fn into(self) -> VendorSpecificEventPacket {VendorSpecificEventPacket::new(self.event) }}
impl Into<LEAdvertisementTrackingEventPacket> for LEAdvertisementTrackingWithInfoEventPacket { fn into(self) -> LEAdvertisementTrackingEventPacket {LEAdvertisementTrackingEventPacket::new(self.event) }}
impl LEAdvertisementTrackingWithInfoEventBuilder {pub fn build(self) -> LEAdvertisementTrackingWithInfoEventPacket {let l_e_advertisement_tracking_with_info_event= Arc::new(LEAdvertisementTrackingWithInfoEventData {tx_power: self.tx_power, rssi: self.rssi, timestamp: self.timestamp, adv_packet: self.adv_packet, scan_response: self.scan_response, });let l_e_advertisement_tracking_event= Arc::new(LEAdvertisementTrackingEventData {apcf_filter_index: self.apcf_filter_index, advertiser_state: self.advertiser_state, advt_info_present: self.advt_info_present, advertiser_address: self.advertiser_address, advertiser_address_type: self.advertiser_address_type, child: LEAdvertisementTrackingEventDataChild::LEAdvertisementTrackingWithInfoEvent(l_e_advertisement_tracking_with_info_event),});let vendor_specific_event= Arc::new(VendorSpecificEventData {subevent_code: VseSubeventCode::BleTracking, child: VendorSpecificEventDataChild::LEAdvertisementTrackingEvent(l_e_advertisement_tracking_event),});let event= Arc::new(EventData {event_code: EventCode::VendorSpecific, child: EventDataChild::VendorSpecificEvent(vendor_specific_event),});LEAdvertisementTrackingWithInfoEventPacket::new(event)}
}
impl Into<EventPacket> for LEAdvertisementTrackingWithInfoEventBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<VendorSpecificEventPacket> for LEAdvertisementTrackingWithInfoEventBuilder { fn into(self) -> VendorSpecificEventPacket { self.build().into() }}
impl Into<LEAdvertisementTrackingEventPacket> for LEAdvertisementTrackingWithInfoEventBuilder { fn into(self) -> LEAdvertisementTrackingEventPacket { self.build().into() }}


#[derive(Debug)] enum BqrEventDataChild {BqrLinkQualityEvent(Arc<BqrLinkQualityEventData>),BqrRootInflammationEvent(Arc<BqrRootInflammationEventData>),BqrLogDumpEvent(Arc<BqrLogDumpEventData>),Payload(Bytes),None,}
impl BqrEventDataChild {fn get_total_size(&self) -> usize {match self {BqrEventDataChild::BqrLinkQualityEvent(value) => value.get_total_size(),BqrEventDataChild::BqrRootInflammationEvent(value) => value.get_total_size(),BqrEventDataChild::BqrLogDumpEvent(value) => value.get_total_size(),BqrEventDataChild::Payload(p) => p.len(),BqrEventDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum BqrEventChild {BqrLinkQualityEvent(BqrLinkQualityEventPacket),BqrRootInflammationEvent(BqrRootInflammationEventPacket),BqrLogDumpEvent(BqrLogDumpEventPacket),Payload(Bytes),None,}
#[derive(Debug)] struct BqrEventData {quality_report_id: QualityReportId, child: BqrEventDataChild,}
#[derive(Debug, Clone)] pub struct BqrEventPacket {event: Arc<EventData>,vendor_specific_event: Arc<VendorSpecificEventData>,bqr_event: Arc<BqrEventData>,}
#[derive(Debug)] pub struct BqrEventBuilder {pub quality_report_id: QualityReportId, pub payload: Option<Bytes>,}
impl BqrEventData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "BqrEvent".to_string(),    field: "quality_report_id".to_string(),    wanted: 4,    got: bytes.len()});}let quality_report_id = u8::from_le_bytes([bytes[3]]);let quality_report_id = QualityReportId::from_u8(quality_report_id).unwrap();let payload: Vec::<u8> = bytes[4..].into();let child = match quality_report_id {QualityReportId::MonitorMode if BqrLinkQualityEventData::conforms(&bytes[..]) => {BqrEventDataChild::BqrLinkQualityEvent(Arc::new(BqrLinkQualityEventData::parse(&bytes[..], QualityReportId::MonitorMode)?))}
QualityReportId::ApproachLsto if BqrLinkQualityEventData::conforms(&bytes[..]) => {BqrEventDataChild::BqrLinkQualityEvent(Arc::new(BqrLinkQualityEventData::parse(&bytes[..], QualityReportId::ApproachLsto)?))}
QualityReportId::A2dpAudioChoppy if BqrLinkQualityEventData::conforms(&bytes[..]) => {BqrEventDataChild::BqrLinkQualityEvent(Arc::new(BqrLinkQualityEventData::parse(&bytes[..], QualityReportId::A2dpAudioChoppy)?))}
QualityReportId::ScoVoiceChoppy if BqrLinkQualityEventData::conforms(&bytes[..]) => {BqrEventDataChild::BqrLinkQualityEvent(Arc::new(BqrLinkQualityEventData::parse(&bytes[..], QualityReportId::ScoVoiceChoppy)?))}
QualityReportId::RootInflammation if BqrRootInflammationEventData::conforms(&bytes[..]) => {BqrEventDataChild::BqrRootInflammationEvent(Arc::new(BqrRootInflammationEventData::parse(&bytes[..])?))}
QualityReportId::LmpLlMessageTrace if BqrLogDumpEventData::conforms(&bytes[..]) => {BqrEventDataChild::BqrLogDumpEvent(Arc::new(BqrLogDumpEventData::parse(&bytes[..], QualityReportId::LmpLlMessageTrace)?))}
QualityReportId::BtSchedulingTrace if BqrLogDumpEventData::conforms(&bytes[..]) => {BqrEventDataChild::BqrLogDumpEvent(Arc::new(BqrLogDumpEventData::parse(&bytes[..], QualityReportId::BtSchedulingTrace)?))}
QualityReportId::ControllerDbgInfo if BqrLogDumpEventData::conforms(&bytes[..]) => {BqrEventDataChild::BqrLogDumpEvent(Arc::new(BqrLogDumpEventData::parse(&bytes[..], QualityReportId::ControllerDbgInfo)?))}
v => return Err(Error::ConstraintOutOfBounds{field: "quality_report_id".to_string(), value: v as u64}),};
Ok(Self {quality_report_id, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let quality_report_id = self.quality_report_id.to_u8().unwrap();buffer[3..4].copy_from_slice(&quality_report_id.to_le_bytes()[0..1]);match &self.child {BqrEventDataChild::BqrLinkQualityEvent(value) => value.write_to(buffer),BqrEventDataChild::BqrRootInflammationEvent(value) => value.write_to(buffer),BqrEventDataChild::BqrLogDumpEvent(value) => value.write_to(buffer),BqrEventDataChild::Payload(p) => buffer[4..].copy_from_slice(&p[..]),BqrEventDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 1;ret}
}
impl Packet for BqrEventPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl BqrEventPacket { pub fn specialize(&self) -> BqrEventChild { match &self.bqr_event.child {BqrEventDataChild::BqrLinkQualityEvent(_) => BqrEventChild::BqrLinkQualityEvent(BqrLinkQualityEventPacket::new(self.event.clone())),BqrEventDataChild::BqrRootInflammationEvent(_) => BqrEventChild::BqrRootInflammationEvent(BqrRootInflammationEventPacket::new(self.event.clone())),BqrEventDataChild::BqrLogDumpEvent(_) => BqrEventChild::BqrLogDumpEvent(BqrLogDumpEventPacket::new(self.event.clone())),BqrEventDataChild::Payload(p) => BqrEventChild::Payload(p.clone()),BqrEventDataChild::None => BqrEventChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let vendor_specific_event = match &event.child {EventDataChild::VendorSpecificEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not VendorSpecificEvent"),};let bqr_event = match &vendor_specific_event.child {VendorSpecificEventDataChild::BqrEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrEvent"),};Self {event,vendor_specific_event,bqr_event,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> VseSubeventCode{ self.vendor_specific_event.as_ref().subevent_code}
pub fn get_quality_report_id(&self) -> QualityReportId{ self.bqr_event.as_ref().quality_report_id}
}
impl Into<EventPacket> for BqrEventPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<VendorSpecificEventPacket> for BqrEventPacket { fn into(self) -> VendorSpecificEventPacket {VendorSpecificEventPacket::new(self.event) }}
impl BqrEventBuilder {pub fn build(self) -> BqrEventPacket {let bqr_event= Arc::new(BqrEventData {quality_report_id: self.quality_report_id, child: match self.payload { None => BqrEventDataChild::None,Some(bytes) => BqrEventDataChild::Payload(bytes),},});let vendor_specific_event= Arc::new(VendorSpecificEventData {subevent_code: VseSubeventCode::BqrEvent, child: VendorSpecificEventDataChild::BqrEvent(bqr_event),});let event= Arc::new(EventData {event_code: EventCode::VendorSpecific, child: EventDataChild::VendorSpecificEvent(vendor_specific_event),});BqrEventPacket::new(event)}
}
impl Into<EventPacket> for BqrEventBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<VendorSpecificEventPacket> for BqrEventBuilder { fn into(self) -> VendorSpecificEventPacket { self.build().into() }}


#[derive(Debug)] enum BqrLinkQualityEventDataChild {BqrMonitorModeEvent(Arc<BqrMonitorModeEventData>),BqrApproachLstoEvent(Arc<BqrApproachLstoEventData>),BqrA2dpAudioChoppyEvent(Arc<BqrA2dpAudioChoppyEventData>),BqrScoVoiceChoppyEvent(Arc<BqrScoVoiceChoppyEventData>),Payload(Bytes),None,}
impl BqrLinkQualityEventDataChild {fn get_total_size(&self) -> usize {match self {BqrLinkQualityEventDataChild::BqrMonitorModeEvent(value) => value.get_total_size(),BqrLinkQualityEventDataChild::BqrApproachLstoEvent(value) => value.get_total_size(),BqrLinkQualityEventDataChild::BqrA2dpAudioChoppyEvent(value) => value.get_total_size(),BqrLinkQualityEventDataChild::BqrScoVoiceChoppyEvent(value) => value.get_total_size(),BqrLinkQualityEventDataChild::Payload(p) => p.len(),BqrLinkQualityEventDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum BqrLinkQualityEventChild {BqrMonitorModeEvent(BqrMonitorModeEventPacket),BqrApproachLstoEvent(BqrApproachLstoEventPacket),BqrA2dpAudioChoppyEvent(BqrA2dpAudioChoppyEventPacket),BqrScoVoiceChoppyEvent(BqrScoVoiceChoppyEventPacket),Payload(Bytes),None,}
#[derive(Debug)] struct BqrLinkQualityEventData {packet_type: BqrPacketType, connection_handle: u16, connection_role: Role, tx_power_level: u8, rssi: u8, snr: u8, unused_afh_channel_count: u8, afh_select_unideal_channel_count: u8, lsto: u16, connection_piconet_clock: u32, retransmission_count: u32, no_rx_count: u32, nak_count: u32, last_tx_ack_timestamp: u32, flow_off_count: u32, last_flow_on_timestamp: u32, buffer_overflow_bytes: u32, buffer_underflow_bytes: u32, child: BqrLinkQualityEventDataChild,}
#[derive(Debug, Clone)] pub struct BqrLinkQualityEventPacket {event: Arc<EventData>,vendor_specific_event: Arc<VendorSpecificEventData>,bqr_event: Arc<BqrEventData>,bqr_link_quality_event: Arc<BqrLinkQualityEventData>,}
#[derive(Debug)] pub struct BqrLinkQualityEventBuilder {pub quality_report_id: QualityReportId, pub packet_type: BqrPacketType, pub connection_handle: u16, pub connection_role: Role, pub tx_power_level: u8, pub rssi: u8, pub snr: u8, pub unused_afh_channel_count: u8, pub afh_select_unideal_channel_count: u8, pub lsto: u16, pub connection_piconet_clock: u32, pub retransmission_count: u32, pub no_rx_count: u32, pub nak_count: u32, pub last_tx_ack_timestamp: u32, pub flow_off_count: u32, pub last_flow_on_timestamp: u32, pub buffer_overflow_bytes: u32, pub buffer_underflow_bytes: u32, pub payload: Option<Bytes>,}
impl BqrLinkQualityEventData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8], quality_report_id: QualityReportId) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "BqrLinkQualityEvent".to_string(),    field: "packet_type".to_string(),    wanted: 5,    got: bytes.len()});}let packet_type = u8::from_le_bytes([bytes[4]]);let packet_type = BqrPacketType::from_u8(packet_type).unwrap();if bytes.len() < 7 { return Err(Error::InvalidLengthError{    obj: "BqrLinkQualityEvent".to_string(),    field: "connection_handle".to_string(),    wanted: 7,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[5],bytes[6]]);let connection_handle = connection_handle & 0xfff;if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "BqrLinkQualityEvent".to_string(),    field: "connection_role".to_string(),    wanted: 8,    got: bytes.len()});}let connection_role = u8::from_le_bytes([bytes[7]]);let connection_role = Role::from_u8(connection_role).unwrap();if bytes.len() < 9 { return Err(Error::InvalidLengthError{    obj: "BqrLinkQualityEvent".to_string(),    field: "tx_power_level".to_string(),    wanted: 9,    got: bytes.len()});}let tx_power_level = u8::from_le_bytes([bytes[8]]);if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "BqrLinkQualityEvent".to_string(),    field: "rssi".to_string(),    wanted: 10,    got: bytes.len()});}let rssi = u8::from_le_bytes([bytes[9]]);if bytes.len() < 11 { return Err(Error::InvalidLengthError{    obj: "BqrLinkQualityEvent".to_string(),    field: "snr".to_string(),    wanted: 11,    got: bytes.len()});}let snr = u8::from_le_bytes([bytes[10]]);if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "BqrLinkQualityEvent".to_string(),    field: "unused_afh_channel_count".to_string(),    wanted: 12,    got: bytes.len()});}let unused_afh_channel_count = u8::from_le_bytes([bytes[11]]);if bytes.len() < 13 { return Err(Error::InvalidLengthError{    obj: "BqrLinkQualityEvent".to_string(),    field: "afh_select_unideal_channel_count".to_string(),    wanted: 13,    got: bytes.len()});}let afh_select_unideal_channel_count = u8::from_le_bytes([bytes[12]]);if bytes.len() < 15 { return Err(Error::InvalidLengthError{    obj: "BqrLinkQualityEvent".to_string(),    field: "lsto".to_string(),    wanted: 15,    got: bytes.len()});}let lsto = u16::from_le_bytes([bytes[13],bytes[14]]);if bytes.len() < 19 { return Err(Error::InvalidLengthError{    obj: "BqrLinkQualityEvent".to_string(),    field: "connection_piconet_clock".to_string(),    wanted: 19,    got: bytes.len()});}let connection_piconet_clock = u32::from_le_bytes([bytes[15],bytes[16],bytes[17],bytes[18]]);if bytes.len() < 23 { return Err(Error::InvalidLengthError{    obj: "BqrLinkQualityEvent".to_string(),    field: "retransmission_count".to_string(),    wanted: 23,    got: bytes.len()});}let retransmission_count = u32::from_le_bytes([bytes[19],bytes[20],bytes[21],bytes[22]]);if bytes.len() < 27 { return Err(Error::InvalidLengthError{    obj: "BqrLinkQualityEvent".to_string(),    field: "no_rx_count".to_string(),    wanted: 27,    got: bytes.len()});}let no_rx_count = u32::from_le_bytes([bytes[23],bytes[24],bytes[25],bytes[26]]);if bytes.len() < 31 { return Err(Error::InvalidLengthError{    obj: "BqrLinkQualityEvent".to_string(),    field: "nak_count".to_string(),    wanted: 31,    got: bytes.len()});}let nak_count = u32::from_le_bytes([bytes[27],bytes[28],bytes[29],bytes[30]]);if bytes.len() < 35 { return Err(Error::InvalidLengthError{    obj: "BqrLinkQualityEvent".to_string(),    field: "last_tx_ack_timestamp".to_string(),    wanted: 35,    got: bytes.len()});}let last_tx_ack_timestamp = u32::from_le_bytes([bytes[31],bytes[32],bytes[33],bytes[34]]);if bytes.len() < 39 { return Err(Error::InvalidLengthError{    obj: "BqrLinkQualityEvent".to_string(),    field: "flow_off_count".to_string(),    wanted: 39,    got: bytes.len()});}let flow_off_count = u32::from_le_bytes([bytes[35],bytes[36],bytes[37],bytes[38]]);if bytes.len() < 43 { return Err(Error::InvalidLengthError{    obj: "BqrLinkQualityEvent".to_string(),    field: "last_flow_on_timestamp".to_string(),    wanted: 43,    got: bytes.len()});}let last_flow_on_timestamp = u32::from_le_bytes([bytes[39],bytes[40],bytes[41],bytes[42]]);if bytes.len() < 47 { return Err(Error::InvalidLengthError{    obj: "BqrLinkQualityEvent".to_string(),    field: "buffer_overflow_bytes".to_string(),    wanted: 47,    got: bytes.len()});}let buffer_overflow_bytes = u32::from_le_bytes([bytes[43],bytes[44],bytes[45],bytes[46]]);if bytes.len() < 51 { return Err(Error::InvalidLengthError{    obj: "BqrLinkQualityEvent".to_string(),    field: "buffer_underflow_bytes".to_string(),    wanted: 51,    got: bytes.len()});}let buffer_underflow_bytes = u32::from_le_bytes([bytes[47],bytes[48],bytes[49],bytes[50]]);let payload: Vec::<u8> = bytes[51..].into();let child = match quality_report_id {QualityReportId::MonitorMode if BqrMonitorModeEventData::conforms(&bytes[..]) => {BqrLinkQualityEventDataChild::BqrMonitorModeEvent(Arc::new(BqrMonitorModeEventData::parse(&bytes[..])?))}
QualityReportId::ApproachLsto if BqrApproachLstoEventData::conforms(&bytes[..]) => {BqrLinkQualityEventDataChild::BqrApproachLstoEvent(Arc::new(BqrApproachLstoEventData::parse(&bytes[..])?))}
QualityReportId::A2dpAudioChoppy if BqrA2dpAudioChoppyEventData::conforms(&bytes[..]) => {BqrLinkQualityEventDataChild::BqrA2dpAudioChoppyEvent(Arc::new(BqrA2dpAudioChoppyEventData::parse(&bytes[..])?))}
QualityReportId::ScoVoiceChoppy if BqrScoVoiceChoppyEventData::conforms(&bytes[..]) => {BqrLinkQualityEventDataChild::BqrScoVoiceChoppyEvent(Arc::new(BqrScoVoiceChoppyEventData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "quality_report_id".to_string(), value: v as u64}),};
Ok(Self {packet_type, connection_handle, connection_role, tx_power_level, rssi, snr, unused_afh_channel_count, afh_select_unideal_channel_count, lsto, connection_piconet_clock, retransmission_count, no_rx_count, nak_count, last_tx_ack_timestamp, flow_off_count, last_flow_on_timestamp, buffer_overflow_bytes, buffer_underflow_bytes, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let packet_type = self.packet_type.to_u8().unwrap();buffer[4..5].copy_from_slice(&packet_type.to_le_bytes()[0..1]);let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[5..7].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let connection_role = self.connection_role.to_u8().unwrap();buffer[7..8].copy_from_slice(&connection_role.to_le_bytes()[0..1]);let tx_power_level = self.tx_power_level;buffer[8..9].copy_from_slice(&tx_power_level.to_le_bytes()[0..1]);let rssi = self.rssi;buffer[9..10].copy_from_slice(&rssi.to_le_bytes()[0..1]);let snr = self.snr;buffer[10..11].copy_from_slice(&snr.to_le_bytes()[0..1]);let unused_afh_channel_count = self.unused_afh_channel_count;buffer[11..12].copy_from_slice(&unused_afh_channel_count.to_le_bytes()[0..1]);let afh_select_unideal_channel_count = self.afh_select_unideal_channel_count;buffer[12..13].copy_from_slice(&afh_select_unideal_channel_count.to_le_bytes()[0..1]);let lsto = self.lsto;buffer[13..15].copy_from_slice(&lsto.to_le_bytes()[0..2]);let connection_piconet_clock = self.connection_piconet_clock;buffer[15..19].copy_from_slice(&connection_piconet_clock.to_le_bytes()[0..4]);let retransmission_count = self.retransmission_count;buffer[19..23].copy_from_slice(&retransmission_count.to_le_bytes()[0..4]);let no_rx_count = self.no_rx_count;buffer[23..27].copy_from_slice(&no_rx_count.to_le_bytes()[0..4]);let nak_count = self.nak_count;buffer[27..31].copy_from_slice(&nak_count.to_le_bytes()[0..4]);let last_tx_ack_timestamp = self.last_tx_ack_timestamp;buffer[31..35].copy_from_slice(&last_tx_ack_timestamp.to_le_bytes()[0..4]);let flow_off_count = self.flow_off_count;buffer[35..39].copy_from_slice(&flow_off_count.to_le_bytes()[0..4]);let last_flow_on_timestamp = self.last_flow_on_timestamp;buffer[39..43].copy_from_slice(&last_flow_on_timestamp.to_le_bytes()[0..4]);let buffer_overflow_bytes = self.buffer_overflow_bytes;buffer[43..47].copy_from_slice(&buffer_overflow_bytes.to_le_bytes()[0..4]);let buffer_underflow_bytes = self.buffer_underflow_bytes;buffer[47..51].copy_from_slice(&buffer_underflow_bytes.to_le_bytes()[0..4]);match &self.child {BqrLinkQualityEventDataChild::BqrMonitorModeEvent(value) => value.write_to(buffer),BqrLinkQualityEventDataChild::BqrApproachLstoEvent(value) => value.write_to(buffer),BqrLinkQualityEventDataChild::BqrA2dpAudioChoppyEvent(value) => value.write_to(buffer),BqrLinkQualityEventDataChild::BqrScoVoiceChoppyEvent(value) => value.write_to(buffer),BqrLinkQualityEventDataChild::Payload(p) => buffer[51..].copy_from_slice(&p[..]),BqrLinkQualityEventDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 47;ret}
}
impl Packet for BqrLinkQualityEventPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl BqrLinkQualityEventPacket { pub fn specialize(&self) -> BqrLinkQualityEventChild { match &self.bqr_link_quality_event.child {BqrLinkQualityEventDataChild::BqrMonitorModeEvent(_) => BqrLinkQualityEventChild::BqrMonitorModeEvent(BqrMonitorModeEventPacket::new(self.event.clone())),BqrLinkQualityEventDataChild::BqrApproachLstoEvent(_) => BqrLinkQualityEventChild::BqrApproachLstoEvent(BqrApproachLstoEventPacket::new(self.event.clone())),BqrLinkQualityEventDataChild::BqrA2dpAudioChoppyEvent(_) => BqrLinkQualityEventChild::BqrA2dpAudioChoppyEvent(BqrA2dpAudioChoppyEventPacket::new(self.event.clone())),BqrLinkQualityEventDataChild::BqrScoVoiceChoppyEvent(_) => BqrLinkQualityEventChild::BqrScoVoiceChoppyEvent(BqrScoVoiceChoppyEventPacket::new(self.event.clone())),BqrLinkQualityEventDataChild::Payload(p) => BqrLinkQualityEventChild::Payload(p.clone()),BqrLinkQualityEventDataChild::None => BqrLinkQualityEventChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let vendor_specific_event = match &event.child {EventDataChild::VendorSpecificEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not VendorSpecificEvent"),};let bqr_event = match &vendor_specific_event.child {VendorSpecificEventDataChild::BqrEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrEvent"),};let bqr_link_quality_event = match &bqr_event.child {BqrEventDataChild::BqrLinkQualityEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrLinkQualityEvent"),};Self {event,vendor_specific_event,bqr_event,bqr_link_quality_event,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> VseSubeventCode{ self.vendor_specific_event.as_ref().subevent_code}
pub fn get_quality_report_id(&self) -> QualityReportId{ self.bqr_event.as_ref().quality_report_id}
pub fn get_packet_type(&self) -> BqrPacketType{ self.bqr_link_quality_event.as_ref().packet_type}
pub fn get_connection_handle(&self) -> u16{ self.bqr_link_quality_event.as_ref().connection_handle}
pub fn get_connection_role(&self) -> Role{ self.bqr_link_quality_event.as_ref().connection_role}
pub fn get_tx_power_level(&self) -> u8{ self.bqr_link_quality_event.as_ref().tx_power_level}
pub fn get_rssi(&self) -> u8{ self.bqr_link_quality_event.as_ref().rssi}
pub fn get_snr(&self) -> u8{ self.bqr_link_quality_event.as_ref().snr}
pub fn get_unused_afh_channel_count(&self) -> u8{ self.bqr_link_quality_event.as_ref().unused_afh_channel_count}
pub fn get_afh_select_unideal_channel_count(&self) -> u8{ self.bqr_link_quality_event.as_ref().afh_select_unideal_channel_count}
pub fn get_lsto(&self) -> u16{ self.bqr_link_quality_event.as_ref().lsto}
pub fn get_connection_piconet_clock(&self) -> u32{ self.bqr_link_quality_event.as_ref().connection_piconet_clock}
pub fn get_retransmission_count(&self) -> u32{ self.bqr_link_quality_event.as_ref().retransmission_count}
pub fn get_no_rx_count(&self) -> u32{ self.bqr_link_quality_event.as_ref().no_rx_count}
pub fn get_nak_count(&self) -> u32{ self.bqr_link_quality_event.as_ref().nak_count}
pub fn get_last_tx_ack_timestamp(&self) -> u32{ self.bqr_link_quality_event.as_ref().last_tx_ack_timestamp}
pub fn get_flow_off_count(&self) -> u32{ self.bqr_link_quality_event.as_ref().flow_off_count}
pub fn get_last_flow_on_timestamp(&self) -> u32{ self.bqr_link_quality_event.as_ref().last_flow_on_timestamp}
pub fn get_buffer_overflow_bytes(&self) -> u32{ self.bqr_link_quality_event.as_ref().buffer_overflow_bytes}
pub fn get_buffer_underflow_bytes(&self) -> u32{ self.bqr_link_quality_event.as_ref().buffer_underflow_bytes}
}
impl Into<EventPacket> for BqrLinkQualityEventPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<VendorSpecificEventPacket> for BqrLinkQualityEventPacket { fn into(self) -> VendorSpecificEventPacket {VendorSpecificEventPacket::new(self.event) }}
impl Into<BqrEventPacket> for BqrLinkQualityEventPacket { fn into(self) -> BqrEventPacket {BqrEventPacket::new(self.event) }}
impl BqrLinkQualityEventBuilder {pub fn build(self) -> BqrLinkQualityEventPacket {let bqr_link_quality_event= Arc::new(BqrLinkQualityEventData {packet_type: self.packet_type, connection_handle: self.connection_handle, connection_role: self.connection_role, tx_power_level: self.tx_power_level, rssi: self.rssi, snr: self.snr, unused_afh_channel_count: self.unused_afh_channel_count, afh_select_unideal_channel_count: self.afh_select_unideal_channel_count, lsto: self.lsto, connection_piconet_clock: self.connection_piconet_clock, retransmission_count: self.retransmission_count, no_rx_count: self.no_rx_count, nak_count: self.nak_count, last_tx_ack_timestamp: self.last_tx_ack_timestamp, flow_off_count: self.flow_off_count, last_flow_on_timestamp: self.last_flow_on_timestamp, buffer_overflow_bytes: self.buffer_overflow_bytes, buffer_underflow_bytes: self.buffer_underflow_bytes, child: match self.payload { None => BqrLinkQualityEventDataChild::None,Some(bytes) => BqrLinkQualityEventDataChild::Payload(bytes),},});let bqr_event= Arc::new(BqrEventData {quality_report_id: self.quality_report_id, child: BqrEventDataChild::BqrLinkQualityEvent(bqr_link_quality_event),});let vendor_specific_event= Arc::new(VendorSpecificEventData {subevent_code: VseSubeventCode::BqrEvent, child: VendorSpecificEventDataChild::BqrEvent(bqr_event),});let event= Arc::new(EventData {event_code: EventCode::VendorSpecific, child: EventDataChild::VendorSpecificEvent(vendor_specific_event),});BqrLinkQualityEventPacket::new(event)}
}
impl Into<EventPacket> for BqrLinkQualityEventBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<VendorSpecificEventPacket> for BqrLinkQualityEventBuilder { fn into(self) -> VendorSpecificEventPacket { self.build().into() }}
impl Into<BqrEventPacket> for BqrLinkQualityEventBuilder { fn into(self) -> BqrEventPacket { self.build().into() }}


#[derive(Debug)] enum BqrMonitorModeEventDataChild {Payload(Bytes),None,}
impl BqrMonitorModeEventDataChild {fn get_total_size(&self) -> usize {match self {BqrMonitorModeEventDataChild::Payload(p) => p.len(),BqrMonitorModeEventDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum BqrMonitorModeEventChild {Payload(Bytes),None,}
#[derive(Debug)] struct BqrMonitorModeEventData {child: BqrMonitorModeEventDataChild,}
#[derive(Debug, Clone)] pub struct BqrMonitorModeEventPacket {event: Arc<EventData>,vendor_specific_event: Arc<VendorSpecificEventData>,bqr_event: Arc<BqrEventData>,bqr_link_quality_event: Arc<BqrLinkQualityEventData>,bqr_monitor_mode_event: Arc<BqrMonitorModeEventData>,}
#[derive(Debug)] pub struct BqrMonitorModeEventBuilder {pub packet_type: BqrPacketType, pub connection_handle: u16, pub connection_role: Role, pub tx_power_level: u8, pub rssi: u8, pub snr: u8, pub unused_afh_channel_count: u8, pub afh_select_unideal_channel_count: u8, pub lsto: u16, pub connection_piconet_clock: u32, pub retransmission_count: u32, pub no_rx_count: u32, pub nak_count: u32, pub last_tx_ack_timestamp: u32, pub flow_off_count: u32, pub last_flow_on_timestamp: u32, pub buffer_overflow_bytes: u32, pub buffer_underflow_bytes: u32, pub payload: Option<Bytes>,}
impl BqrMonitorModeEventData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {let payload: Vec::<u8> = bytes[51..].into();let child = if payload.len() > 0 {BqrMonitorModeEventDataChild::Payload(Bytes::from(payload))} else {BqrMonitorModeEventDataChild::None};Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {BqrMonitorModeEventDataChild::Payload(p) => buffer[51..].copy_from_slice(&p[..]),BqrMonitorModeEventDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for BqrMonitorModeEventPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl BqrMonitorModeEventPacket { pub fn specialize(&self) -> BqrMonitorModeEventChild { match &self.bqr_monitor_mode_event.child {BqrMonitorModeEventDataChild::Payload(p) => BqrMonitorModeEventChild::Payload(p.clone()),BqrMonitorModeEventDataChild::None => BqrMonitorModeEventChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let vendor_specific_event = match &event.child {EventDataChild::VendorSpecificEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not VendorSpecificEvent"),};let bqr_event = match &vendor_specific_event.child {VendorSpecificEventDataChild::BqrEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrEvent"),};let bqr_link_quality_event = match &bqr_event.child {BqrEventDataChild::BqrLinkQualityEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrLinkQualityEvent"),};let bqr_monitor_mode_event = match &bqr_link_quality_event.child {BqrLinkQualityEventDataChild::BqrMonitorModeEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrMonitorModeEvent"),};Self {event,vendor_specific_event,bqr_event,bqr_link_quality_event,bqr_monitor_mode_event,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> VseSubeventCode{ self.vendor_specific_event.as_ref().subevent_code}
pub fn get_quality_report_id(&self) -> QualityReportId{ self.bqr_event.as_ref().quality_report_id}
pub fn get_packet_type(&self) -> BqrPacketType{ self.bqr_link_quality_event.as_ref().packet_type}
pub fn get_connection_handle(&self) -> u16{ self.bqr_link_quality_event.as_ref().connection_handle}
pub fn get_connection_role(&self) -> Role{ self.bqr_link_quality_event.as_ref().connection_role}
pub fn get_tx_power_level(&self) -> u8{ self.bqr_link_quality_event.as_ref().tx_power_level}
pub fn get_rssi(&self) -> u8{ self.bqr_link_quality_event.as_ref().rssi}
pub fn get_snr(&self) -> u8{ self.bqr_link_quality_event.as_ref().snr}
pub fn get_unused_afh_channel_count(&self) -> u8{ self.bqr_link_quality_event.as_ref().unused_afh_channel_count}
pub fn get_afh_select_unideal_channel_count(&self) -> u8{ self.bqr_link_quality_event.as_ref().afh_select_unideal_channel_count}
pub fn get_lsto(&self) -> u16{ self.bqr_link_quality_event.as_ref().lsto}
pub fn get_connection_piconet_clock(&self) -> u32{ self.bqr_link_quality_event.as_ref().connection_piconet_clock}
pub fn get_retransmission_count(&self) -> u32{ self.bqr_link_quality_event.as_ref().retransmission_count}
pub fn get_no_rx_count(&self) -> u32{ self.bqr_link_quality_event.as_ref().no_rx_count}
pub fn get_nak_count(&self) -> u32{ self.bqr_link_quality_event.as_ref().nak_count}
pub fn get_last_tx_ack_timestamp(&self) -> u32{ self.bqr_link_quality_event.as_ref().last_tx_ack_timestamp}
pub fn get_flow_off_count(&self) -> u32{ self.bqr_link_quality_event.as_ref().flow_off_count}
pub fn get_last_flow_on_timestamp(&self) -> u32{ self.bqr_link_quality_event.as_ref().last_flow_on_timestamp}
pub fn get_buffer_overflow_bytes(&self) -> u32{ self.bqr_link_quality_event.as_ref().buffer_overflow_bytes}
pub fn get_buffer_underflow_bytes(&self) -> u32{ self.bqr_link_quality_event.as_ref().buffer_underflow_bytes}
}
impl Into<EventPacket> for BqrMonitorModeEventPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<VendorSpecificEventPacket> for BqrMonitorModeEventPacket { fn into(self) -> VendorSpecificEventPacket {VendorSpecificEventPacket::new(self.event) }}
impl Into<BqrEventPacket> for BqrMonitorModeEventPacket { fn into(self) -> BqrEventPacket {BqrEventPacket::new(self.event) }}
impl Into<BqrLinkQualityEventPacket> for BqrMonitorModeEventPacket { fn into(self) -> BqrLinkQualityEventPacket {BqrLinkQualityEventPacket::new(self.event) }}
impl BqrMonitorModeEventBuilder {pub fn build(self) -> BqrMonitorModeEventPacket {let bqr_monitor_mode_event= Arc::new(BqrMonitorModeEventData {child: match self.payload { None => BqrMonitorModeEventDataChild::None,Some(bytes) => BqrMonitorModeEventDataChild::Payload(bytes),},});let bqr_link_quality_event= Arc::new(BqrLinkQualityEventData {packet_type: self.packet_type, connection_handle: self.connection_handle, connection_role: self.connection_role, tx_power_level: self.tx_power_level, rssi: self.rssi, snr: self.snr, unused_afh_channel_count: self.unused_afh_channel_count, afh_select_unideal_channel_count: self.afh_select_unideal_channel_count, lsto: self.lsto, connection_piconet_clock: self.connection_piconet_clock, retransmission_count: self.retransmission_count, no_rx_count: self.no_rx_count, nak_count: self.nak_count, last_tx_ack_timestamp: self.last_tx_ack_timestamp, flow_off_count: self.flow_off_count, last_flow_on_timestamp: self.last_flow_on_timestamp, buffer_overflow_bytes: self.buffer_overflow_bytes, buffer_underflow_bytes: self.buffer_underflow_bytes, child: BqrLinkQualityEventDataChild::BqrMonitorModeEvent(bqr_monitor_mode_event),});let bqr_event= Arc::new(BqrEventData {quality_report_id: QualityReportId::MonitorMode, child: BqrEventDataChild::BqrLinkQualityEvent(bqr_link_quality_event),});let vendor_specific_event= Arc::new(VendorSpecificEventData {subevent_code: VseSubeventCode::BqrEvent, child: VendorSpecificEventDataChild::BqrEvent(bqr_event),});let event= Arc::new(EventData {event_code: EventCode::VendorSpecific, child: EventDataChild::VendorSpecificEvent(vendor_specific_event),});BqrMonitorModeEventPacket::new(event)}
}
impl Into<EventPacket> for BqrMonitorModeEventBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<VendorSpecificEventPacket> for BqrMonitorModeEventBuilder { fn into(self) -> VendorSpecificEventPacket { self.build().into() }}
impl Into<BqrEventPacket> for BqrMonitorModeEventBuilder { fn into(self) -> BqrEventPacket { self.build().into() }}
impl Into<BqrLinkQualityEventPacket> for BqrMonitorModeEventBuilder { fn into(self) -> BqrLinkQualityEventPacket { self.build().into() }}


#[derive(Debug)] enum BqrApproachLstoEventDataChild {Payload(Bytes),None,}
impl BqrApproachLstoEventDataChild {fn get_total_size(&self) -> usize {match self {BqrApproachLstoEventDataChild::Payload(p) => p.len(),BqrApproachLstoEventDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum BqrApproachLstoEventChild {Payload(Bytes),None,}
#[derive(Debug)] struct BqrApproachLstoEventData {child: BqrApproachLstoEventDataChild,}
#[derive(Debug, Clone)] pub struct BqrApproachLstoEventPacket {event: Arc<EventData>,vendor_specific_event: Arc<VendorSpecificEventData>,bqr_event: Arc<BqrEventData>,bqr_link_quality_event: Arc<BqrLinkQualityEventData>,bqr_approach_lsto_event: Arc<BqrApproachLstoEventData>,}
#[derive(Debug)] pub struct BqrApproachLstoEventBuilder {pub packet_type: BqrPacketType, pub connection_handle: u16, pub connection_role: Role, pub tx_power_level: u8, pub rssi: u8, pub snr: u8, pub unused_afh_channel_count: u8, pub afh_select_unideal_channel_count: u8, pub lsto: u16, pub connection_piconet_clock: u32, pub retransmission_count: u32, pub no_rx_count: u32, pub nak_count: u32, pub last_tx_ack_timestamp: u32, pub flow_off_count: u32, pub last_flow_on_timestamp: u32, pub buffer_overflow_bytes: u32, pub buffer_underflow_bytes: u32, pub payload: Option<Bytes>,}
impl BqrApproachLstoEventData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {let payload: Vec::<u8> = bytes[51..].into();let child = if payload.len() > 0 {BqrApproachLstoEventDataChild::Payload(Bytes::from(payload))} else {BqrApproachLstoEventDataChild::None};Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {BqrApproachLstoEventDataChild::Payload(p) => buffer[51..].copy_from_slice(&p[..]),BqrApproachLstoEventDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for BqrApproachLstoEventPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl BqrApproachLstoEventPacket { pub fn specialize(&self) -> BqrApproachLstoEventChild { match &self.bqr_approach_lsto_event.child {BqrApproachLstoEventDataChild::Payload(p) => BqrApproachLstoEventChild::Payload(p.clone()),BqrApproachLstoEventDataChild::None => BqrApproachLstoEventChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let vendor_specific_event = match &event.child {EventDataChild::VendorSpecificEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not VendorSpecificEvent"),};let bqr_event = match &vendor_specific_event.child {VendorSpecificEventDataChild::BqrEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrEvent"),};let bqr_link_quality_event = match &bqr_event.child {BqrEventDataChild::BqrLinkQualityEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrLinkQualityEvent"),};let bqr_approach_lsto_event = match &bqr_link_quality_event.child {BqrLinkQualityEventDataChild::BqrApproachLstoEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrApproachLstoEvent"),};Self {event,vendor_specific_event,bqr_event,bqr_link_quality_event,bqr_approach_lsto_event,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> VseSubeventCode{ self.vendor_specific_event.as_ref().subevent_code}
pub fn get_quality_report_id(&self) -> QualityReportId{ self.bqr_event.as_ref().quality_report_id}
pub fn get_packet_type(&self) -> BqrPacketType{ self.bqr_link_quality_event.as_ref().packet_type}
pub fn get_connection_handle(&self) -> u16{ self.bqr_link_quality_event.as_ref().connection_handle}
pub fn get_connection_role(&self) -> Role{ self.bqr_link_quality_event.as_ref().connection_role}
pub fn get_tx_power_level(&self) -> u8{ self.bqr_link_quality_event.as_ref().tx_power_level}
pub fn get_rssi(&self) -> u8{ self.bqr_link_quality_event.as_ref().rssi}
pub fn get_snr(&self) -> u8{ self.bqr_link_quality_event.as_ref().snr}
pub fn get_unused_afh_channel_count(&self) -> u8{ self.bqr_link_quality_event.as_ref().unused_afh_channel_count}
pub fn get_afh_select_unideal_channel_count(&self) -> u8{ self.bqr_link_quality_event.as_ref().afh_select_unideal_channel_count}
pub fn get_lsto(&self) -> u16{ self.bqr_link_quality_event.as_ref().lsto}
pub fn get_connection_piconet_clock(&self) -> u32{ self.bqr_link_quality_event.as_ref().connection_piconet_clock}
pub fn get_retransmission_count(&self) -> u32{ self.bqr_link_quality_event.as_ref().retransmission_count}
pub fn get_no_rx_count(&self) -> u32{ self.bqr_link_quality_event.as_ref().no_rx_count}
pub fn get_nak_count(&self) -> u32{ self.bqr_link_quality_event.as_ref().nak_count}
pub fn get_last_tx_ack_timestamp(&self) -> u32{ self.bqr_link_quality_event.as_ref().last_tx_ack_timestamp}
pub fn get_flow_off_count(&self) -> u32{ self.bqr_link_quality_event.as_ref().flow_off_count}
pub fn get_last_flow_on_timestamp(&self) -> u32{ self.bqr_link_quality_event.as_ref().last_flow_on_timestamp}
pub fn get_buffer_overflow_bytes(&self) -> u32{ self.bqr_link_quality_event.as_ref().buffer_overflow_bytes}
pub fn get_buffer_underflow_bytes(&self) -> u32{ self.bqr_link_quality_event.as_ref().buffer_underflow_bytes}
}
impl Into<EventPacket> for BqrApproachLstoEventPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<VendorSpecificEventPacket> for BqrApproachLstoEventPacket { fn into(self) -> VendorSpecificEventPacket {VendorSpecificEventPacket::new(self.event) }}
impl Into<BqrEventPacket> for BqrApproachLstoEventPacket { fn into(self) -> BqrEventPacket {BqrEventPacket::new(self.event) }}
impl Into<BqrLinkQualityEventPacket> for BqrApproachLstoEventPacket { fn into(self) -> BqrLinkQualityEventPacket {BqrLinkQualityEventPacket::new(self.event) }}
impl BqrApproachLstoEventBuilder {pub fn build(self) -> BqrApproachLstoEventPacket {let bqr_approach_lsto_event= Arc::new(BqrApproachLstoEventData {child: match self.payload { None => BqrApproachLstoEventDataChild::None,Some(bytes) => BqrApproachLstoEventDataChild::Payload(bytes),},});let bqr_link_quality_event= Arc::new(BqrLinkQualityEventData {packet_type: self.packet_type, connection_handle: self.connection_handle, connection_role: self.connection_role, tx_power_level: self.tx_power_level, rssi: self.rssi, snr: self.snr, unused_afh_channel_count: self.unused_afh_channel_count, afh_select_unideal_channel_count: self.afh_select_unideal_channel_count, lsto: self.lsto, connection_piconet_clock: self.connection_piconet_clock, retransmission_count: self.retransmission_count, no_rx_count: self.no_rx_count, nak_count: self.nak_count, last_tx_ack_timestamp: self.last_tx_ack_timestamp, flow_off_count: self.flow_off_count, last_flow_on_timestamp: self.last_flow_on_timestamp, buffer_overflow_bytes: self.buffer_overflow_bytes, buffer_underflow_bytes: self.buffer_underflow_bytes, child: BqrLinkQualityEventDataChild::BqrApproachLstoEvent(bqr_approach_lsto_event),});let bqr_event= Arc::new(BqrEventData {quality_report_id: QualityReportId::ApproachLsto, child: BqrEventDataChild::BqrLinkQualityEvent(bqr_link_quality_event),});let vendor_specific_event= Arc::new(VendorSpecificEventData {subevent_code: VseSubeventCode::BqrEvent, child: VendorSpecificEventDataChild::BqrEvent(bqr_event),});let event= Arc::new(EventData {event_code: EventCode::VendorSpecific, child: EventDataChild::VendorSpecificEvent(vendor_specific_event),});BqrApproachLstoEventPacket::new(event)}
}
impl Into<EventPacket> for BqrApproachLstoEventBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<VendorSpecificEventPacket> for BqrApproachLstoEventBuilder { fn into(self) -> VendorSpecificEventPacket { self.build().into() }}
impl Into<BqrEventPacket> for BqrApproachLstoEventBuilder { fn into(self) -> BqrEventPacket { self.build().into() }}
impl Into<BqrLinkQualityEventPacket> for BqrApproachLstoEventBuilder { fn into(self) -> BqrLinkQualityEventPacket { self.build().into() }}


#[derive(Debug)] enum BqrA2dpAudioChoppyEventDataChild {Payload(Bytes),None,}
impl BqrA2dpAudioChoppyEventDataChild {fn get_total_size(&self) -> usize {match self {BqrA2dpAudioChoppyEventDataChild::Payload(p) => p.len(),BqrA2dpAudioChoppyEventDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum BqrA2dpAudioChoppyEventChild {Payload(Bytes),None,}
#[derive(Debug)] struct BqrA2dpAudioChoppyEventData {child: BqrA2dpAudioChoppyEventDataChild,}
#[derive(Debug, Clone)] pub struct BqrA2dpAudioChoppyEventPacket {event: Arc<EventData>,vendor_specific_event: Arc<VendorSpecificEventData>,bqr_event: Arc<BqrEventData>,bqr_link_quality_event: Arc<BqrLinkQualityEventData>,bqr_a2dp_audio_choppy_event: Arc<BqrA2dpAudioChoppyEventData>,}
#[derive(Debug)] pub struct BqrA2dpAudioChoppyEventBuilder {pub packet_type: BqrPacketType, pub connection_handle: u16, pub connection_role: Role, pub tx_power_level: u8, pub rssi: u8, pub snr: u8, pub unused_afh_channel_count: u8, pub afh_select_unideal_channel_count: u8, pub lsto: u16, pub connection_piconet_clock: u32, pub retransmission_count: u32, pub no_rx_count: u32, pub nak_count: u32, pub last_tx_ack_timestamp: u32, pub flow_off_count: u32, pub last_flow_on_timestamp: u32, pub buffer_overflow_bytes: u32, pub buffer_underflow_bytes: u32, pub payload: Option<Bytes>,}
impl BqrA2dpAudioChoppyEventData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {let payload: Vec::<u8> = bytes[51..].into();let child = if payload.len() > 0 {BqrA2dpAudioChoppyEventDataChild::Payload(Bytes::from(payload))} else {BqrA2dpAudioChoppyEventDataChild::None};Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {BqrA2dpAudioChoppyEventDataChild::Payload(p) => buffer[51..].copy_from_slice(&p[..]),BqrA2dpAudioChoppyEventDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for BqrA2dpAudioChoppyEventPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl BqrA2dpAudioChoppyEventPacket { pub fn specialize(&self) -> BqrA2dpAudioChoppyEventChild { match &self.bqr_a2dp_audio_choppy_event.child {BqrA2dpAudioChoppyEventDataChild::Payload(p) => BqrA2dpAudioChoppyEventChild::Payload(p.clone()),BqrA2dpAudioChoppyEventDataChild::None => BqrA2dpAudioChoppyEventChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let vendor_specific_event = match &event.child {EventDataChild::VendorSpecificEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not VendorSpecificEvent"),};let bqr_event = match &vendor_specific_event.child {VendorSpecificEventDataChild::BqrEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrEvent"),};let bqr_link_quality_event = match &bqr_event.child {BqrEventDataChild::BqrLinkQualityEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrLinkQualityEvent"),};let bqr_a2dp_audio_choppy_event = match &bqr_link_quality_event.child {BqrLinkQualityEventDataChild::BqrA2dpAudioChoppyEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrA2dpAudioChoppyEvent"),};Self {event,vendor_specific_event,bqr_event,bqr_link_quality_event,bqr_a2dp_audio_choppy_event,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> VseSubeventCode{ self.vendor_specific_event.as_ref().subevent_code}
pub fn get_quality_report_id(&self) -> QualityReportId{ self.bqr_event.as_ref().quality_report_id}
pub fn get_packet_type(&self) -> BqrPacketType{ self.bqr_link_quality_event.as_ref().packet_type}
pub fn get_connection_handle(&self) -> u16{ self.bqr_link_quality_event.as_ref().connection_handle}
pub fn get_connection_role(&self) -> Role{ self.bqr_link_quality_event.as_ref().connection_role}
pub fn get_tx_power_level(&self) -> u8{ self.bqr_link_quality_event.as_ref().tx_power_level}
pub fn get_rssi(&self) -> u8{ self.bqr_link_quality_event.as_ref().rssi}
pub fn get_snr(&self) -> u8{ self.bqr_link_quality_event.as_ref().snr}
pub fn get_unused_afh_channel_count(&self) -> u8{ self.bqr_link_quality_event.as_ref().unused_afh_channel_count}
pub fn get_afh_select_unideal_channel_count(&self) -> u8{ self.bqr_link_quality_event.as_ref().afh_select_unideal_channel_count}
pub fn get_lsto(&self) -> u16{ self.bqr_link_quality_event.as_ref().lsto}
pub fn get_connection_piconet_clock(&self) -> u32{ self.bqr_link_quality_event.as_ref().connection_piconet_clock}
pub fn get_retransmission_count(&self) -> u32{ self.bqr_link_quality_event.as_ref().retransmission_count}
pub fn get_no_rx_count(&self) -> u32{ self.bqr_link_quality_event.as_ref().no_rx_count}
pub fn get_nak_count(&self) -> u32{ self.bqr_link_quality_event.as_ref().nak_count}
pub fn get_last_tx_ack_timestamp(&self) -> u32{ self.bqr_link_quality_event.as_ref().last_tx_ack_timestamp}
pub fn get_flow_off_count(&self) -> u32{ self.bqr_link_quality_event.as_ref().flow_off_count}
pub fn get_last_flow_on_timestamp(&self) -> u32{ self.bqr_link_quality_event.as_ref().last_flow_on_timestamp}
pub fn get_buffer_overflow_bytes(&self) -> u32{ self.bqr_link_quality_event.as_ref().buffer_overflow_bytes}
pub fn get_buffer_underflow_bytes(&self) -> u32{ self.bqr_link_quality_event.as_ref().buffer_underflow_bytes}
}
impl Into<EventPacket> for BqrA2dpAudioChoppyEventPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<VendorSpecificEventPacket> for BqrA2dpAudioChoppyEventPacket { fn into(self) -> VendorSpecificEventPacket {VendorSpecificEventPacket::new(self.event) }}
impl Into<BqrEventPacket> for BqrA2dpAudioChoppyEventPacket { fn into(self) -> BqrEventPacket {BqrEventPacket::new(self.event) }}
impl Into<BqrLinkQualityEventPacket> for BqrA2dpAudioChoppyEventPacket { fn into(self) -> BqrLinkQualityEventPacket {BqrLinkQualityEventPacket::new(self.event) }}
impl BqrA2dpAudioChoppyEventBuilder {pub fn build(self) -> BqrA2dpAudioChoppyEventPacket {let bqr_a2dp_audio_choppy_event= Arc::new(BqrA2dpAudioChoppyEventData {child: match self.payload { None => BqrA2dpAudioChoppyEventDataChild::None,Some(bytes) => BqrA2dpAudioChoppyEventDataChild::Payload(bytes),},});let bqr_link_quality_event= Arc::new(BqrLinkQualityEventData {packet_type: self.packet_type, connection_handle: self.connection_handle, connection_role: self.connection_role, tx_power_level: self.tx_power_level, rssi: self.rssi, snr: self.snr, unused_afh_channel_count: self.unused_afh_channel_count, afh_select_unideal_channel_count: self.afh_select_unideal_channel_count, lsto: self.lsto, connection_piconet_clock: self.connection_piconet_clock, retransmission_count: self.retransmission_count, no_rx_count: self.no_rx_count, nak_count: self.nak_count, last_tx_ack_timestamp: self.last_tx_ack_timestamp, flow_off_count: self.flow_off_count, last_flow_on_timestamp: self.last_flow_on_timestamp, buffer_overflow_bytes: self.buffer_overflow_bytes, buffer_underflow_bytes: self.buffer_underflow_bytes, child: BqrLinkQualityEventDataChild::BqrA2dpAudioChoppyEvent(bqr_a2dp_audio_choppy_event),});let bqr_event= Arc::new(BqrEventData {quality_report_id: QualityReportId::A2dpAudioChoppy, child: BqrEventDataChild::BqrLinkQualityEvent(bqr_link_quality_event),});let vendor_specific_event= Arc::new(VendorSpecificEventData {subevent_code: VseSubeventCode::BqrEvent, child: VendorSpecificEventDataChild::BqrEvent(bqr_event),});let event= Arc::new(EventData {event_code: EventCode::VendorSpecific, child: EventDataChild::VendorSpecificEvent(vendor_specific_event),});BqrA2dpAudioChoppyEventPacket::new(event)}
}
impl Into<EventPacket> for BqrA2dpAudioChoppyEventBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<VendorSpecificEventPacket> for BqrA2dpAudioChoppyEventBuilder { fn into(self) -> VendorSpecificEventPacket { self.build().into() }}
impl Into<BqrEventPacket> for BqrA2dpAudioChoppyEventBuilder { fn into(self) -> BqrEventPacket { self.build().into() }}
impl Into<BqrLinkQualityEventPacket> for BqrA2dpAudioChoppyEventBuilder { fn into(self) -> BqrLinkQualityEventPacket { self.build().into() }}


#[derive(Debug)] enum BqrScoVoiceChoppyEventDataChild {Payload(Bytes),None,}
impl BqrScoVoiceChoppyEventDataChild {fn get_total_size(&self) -> usize {match self {BqrScoVoiceChoppyEventDataChild::Payload(p) => p.len(),BqrScoVoiceChoppyEventDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum BqrScoVoiceChoppyEventChild {Payload(Bytes),None,}
#[derive(Debug)] struct BqrScoVoiceChoppyEventData {child: BqrScoVoiceChoppyEventDataChild,}
#[derive(Debug, Clone)] pub struct BqrScoVoiceChoppyEventPacket {event: Arc<EventData>,vendor_specific_event: Arc<VendorSpecificEventData>,bqr_event: Arc<BqrEventData>,bqr_link_quality_event: Arc<BqrLinkQualityEventData>,bqr_sco_voice_choppy_event: Arc<BqrScoVoiceChoppyEventData>,}
#[derive(Debug)] pub struct BqrScoVoiceChoppyEventBuilder {pub packet_type: BqrPacketType, pub connection_handle: u16, pub connection_role: Role, pub tx_power_level: u8, pub rssi: u8, pub snr: u8, pub unused_afh_channel_count: u8, pub afh_select_unideal_channel_count: u8, pub lsto: u16, pub connection_piconet_clock: u32, pub retransmission_count: u32, pub no_rx_count: u32, pub nak_count: u32, pub last_tx_ack_timestamp: u32, pub flow_off_count: u32, pub last_flow_on_timestamp: u32, pub buffer_overflow_bytes: u32, pub buffer_underflow_bytes: u32, pub payload: Option<Bytes>,}
impl BqrScoVoiceChoppyEventData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {let payload: Vec::<u8> = bytes[51..].into();let child = if payload.len() > 0 {BqrScoVoiceChoppyEventDataChild::Payload(Bytes::from(payload))} else {BqrScoVoiceChoppyEventDataChild::None};Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {BqrScoVoiceChoppyEventDataChild::Payload(p) => buffer[51..].copy_from_slice(&p[..]),BqrScoVoiceChoppyEventDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for BqrScoVoiceChoppyEventPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl BqrScoVoiceChoppyEventPacket { pub fn specialize(&self) -> BqrScoVoiceChoppyEventChild { match &self.bqr_sco_voice_choppy_event.child {BqrScoVoiceChoppyEventDataChild::Payload(p) => BqrScoVoiceChoppyEventChild::Payload(p.clone()),BqrScoVoiceChoppyEventDataChild::None => BqrScoVoiceChoppyEventChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let vendor_specific_event = match &event.child {EventDataChild::VendorSpecificEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not VendorSpecificEvent"),};let bqr_event = match &vendor_specific_event.child {VendorSpecificEventDataChild::BqrEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrEvent"),};let bqr_link_quality_event = match &bqr_event.child {BqrEventDataChild::BqrLinkQualityEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrLinkQualityEvent"),};let bqr_sco_voice_choppy_event = match &bqr_link_quality_event.child {BqrLinkQualityEventDataChild::BqrScoVoiceChoppyEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrScoVoiceChoppyEvent"),};Self {event,vendor_specific_event,bqr_event,bqr_link_quality_event,bqr_sco_voice_choppy_event,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> VseSubeventCode{ self.vendor_specific_event.as_ref().subevent_code}
pub fn get_quality_report_id(&self) -> QualityReportId{ self.bqr_event.as_ref().quality_report_id}
pub fn get_packet_type(&self) -> BqrPacketType{ self.bqr_link_quality_event.as_ref().packet_type}
pub fn get_connection_handle(&self) -> u16{ self.bqr_link_quality_event.as_ref().connection_handle}
pub fn get_connection_role(&self) -> Role{ self.bqr_link_quality_event.as_ref().connection_role}
pub fn get_tx_power_level(&self) -> u8{ self.bqr_link_quality_event.as_ref().tx_power_level}
pub fn get_rssi(&self) -> u8{ self.bqr_link_quality_event.as_ref().rssi}
pub fn get_snr(&self) -> u8{ self.bqr_link_quality_event.as_ref().snr}
pub fn get_unused_afh_channel_count(&self) -> u8{ self.bqr_link_quality_event.as_ref().unused_afh_channel_count}
pub fn get_afh_select_unideal_channel_count(&self) -> u8{ self.bqr_link_quality_event.as_ref().afh_select_unideal_channel_count}
pub fn get_lsto(&self) -> u16{ self.bqr_link_quality_event.as_ref().lsto}
pub fn get_connection_piconet_clock(&self) -> u32{ self.bqr_link_quality_event.as_ref().connection_piconet_clock}
pub fn get_retransmission_count(&self) -> u32{ self.bqr_link_quality_event.as_ref().retransmission_count}
pub fn get_no_rx_count(&self) -> u32{ self.bqr_link_quality_event.as_ref().no_rx_count}
pub fn get_nak_count(&self) -> u32{ self.bqr_link_quality_event.as_ref().nak_count}
pub fn get_last_tx_ack_timestamp(&self) -> u32{ self.bqr_link_quality_event.as_ref().last_tx_ack_timestamp}
pub fn get_flow_off_count(&self) -> u32{ self.bqr_link_quality_event.as_ref().flow_off_count}
pub fn get_last_flow_on_timestamp(&self) -> u32{ self.bqr_link_quality_event.as_ref().last_flow_on_timestamp}
pub fn get_buffer_overflow_bytes(&self) -> u32{ self.bqr_link_quality_event.as_ref().buffer_overflow_bytes}
pub fn get_buffer_underflow_bytes(&self) -> u32{ self.bqr_link_quality_event.as_ref().buffer_underflow_bytes}
}
impl Into<EventPacket> for BqrScoVoiceChoppyEventPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<VendorSpecificEventPacket> for BqrScoVoiceChoppyEventPacket { fn into(self) -> VendorSpecificEventPacket {VendorSpecificEventPacket::new(self.event) }}
impl Into<BqrEventPacket> for BqrScoVoiceChoppyEventPacket { fn into(self) -> BqrEventPacket {BqrEventPacket::new(self.event) }}
impl Into<BqrLinkQualityEventPacket> for BqrScoVoiceChoppyEventPacket { fn into(self) -> BqrLinkQualityEventPacket {BqrLinkQualityEventPacket::new(self.event) }}
impl BqrScoVoiceChoppyEventBuilder {pub fn build(self) -> BqrScoVoiceChoppyEventPacket {let bqr_sco_voice_choppy_event= Arc::new(BqrScoVoiceChoppyEventData {child: match self.payload { None => BqrScoVoiceChoppyEventDataChild::None,Some(bytes) => BqrScoVoiceChoppyEventDataChild::Payload(bytes),},});let bqr_link_quality_event= Arc::new(BqrLinkQualityEventData {packet_type: self.packet_type, connection_handle: self.connection_handle, connection_role: self.connection_role, tx_power_level: self.tx_power_level, rssi: self.rssi, snr: self.snr, unused_afh_channel_count: self.unused_afh_channel_count, afh_select_unideal_channel_count: self.afh_select_unideal_channel_count, lsto: self.lsto, connection_piconet_clock: self.connection_piconet_clock, retransmission_count: self.retransmission_count, no_rx_count: self.no_rx_count, nak_count: self.nak_count, last_tx_ack_timestamp: self.last_tx_ack_timestamp, flow_off_count: self.flow_off_count, last_flow_on_timestamp: self.last_flow_on_timestamp, buffer_overflow_bytes: self.buffer_overflow_bytes, buffer_underflow_bytes: self.buffer_underflow_bytes, child: BqrLinkQualityEventDataChild::BqrScoVoiceChoppyEvent(bqr_sco_voice_choppy_event),});let bqr_event= Arc::new(BqrEventData {quality_report_id: QualityReportId::ScoVoiceChoppy, child: BqrEventDataChild::BqrLinkQualityEvent(bqr_link_quality_event),});let vendor_specific_event= Arc::new(VendorSpecificEventData {subevent_code: VseSubeventCode::BqrEvent, child: VendorSpecificEventDataChild::BqrEvent(bqr_event),});let event= Arc::new(EventData {event_code: EventCode::VendorSpecific, child: EventDataChild::VendorSpecificEvent(vendor_specific_event),});BqrScoVoiceChoppyEventPacket::new(event)}
}
impl Into<EventPacket> for BqrScoVoiceChoppyEventBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<VendorSpecificEventPacket> for BqrScoVoiceChoppyEventBuilder { fn into(self) -> VendorSpecificEventPacket { self.build().into() }}
impl Into<BqrEventPacket> for BqrScoVoiceChoppyEventBuilder { fn into(self) -> BqrEventPacket { self.build().into() }}
impl Into<BqrLinkQualityEventPacket> for BqrScoVoiceChoppyEventBuilder { fn into(self) -> BqrLinkQualityEventPacket { self.build().into() }}


#[derive(Debug)] enum BqrRootInflammationEventDataChild {Payload(Bytes),None,}
impl BqrRootInflammationEventDataChild {fn get_total_size(&self) -> usize {match self {BqrRootInflammationEventDataChild::Payload(p) => p.len(),BqrRootInflammationEventDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum BqrRootInflammationEventChild {Payload(Bytes),None,}
#[derive(Debug)] struct BqrRootInflammationEventData {error_code: u8, vendor_specific_error_code: u8, child: BqrRootInflammationEventDataChild,}
#[derive(Debug, Clone)] pub struct BqrRootInflammationEventPacket {event: Arc<EventData>,vendor_specific_event: Arc<VendorSpecificEventData>,bqr_event: Arc<BqrEventData>,bqr_root_inflammation_event: Arc<BqrRootInflammationEventData>,}
#[derive(Debug)] pub struct BqrRootInflammationEventBuilder {pub error_code: u8, pub vendor_specific_error_code: u8, pub payload: Option<Bytes>,}
impl BqrRootInflammationEventData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 5 { return Err(Error::InvalidLengthError{    obj: "BqrRootInflammationEvent".to_string(),    field: "error_code".to_string(),    wanted: 5,    got: bytes.len()});}let error_code = u8::from_le_bytes([bytes[4]]);if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "BqrRootInflammationEvent".to_string(),    field: "vendor_specific_error_code".to_string(),    wanted: 6,    got: bytes.len()});}let vendor_specific_error_code = u8::from_le_bytes([bytes[5]]);let payload: Vec::<u8> = bytes[6..].into();let child = if payload.len() > 0 {BqrRootInflammationEventDataChild::Payload(Bytes::from(payload))} else {BqrRootInflammationEventDataChild::None};Ok(Self {error_code, vendor_specific_error_code, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let error_code = self.error_code;buffer[4..5].copy_from_slice(&error_code.to_le_bytes()[0..1]);let vendor_specific_error_code = self.vendor_specific_error_code;buffer[5..6].copy_from_slice(&vendor_specific_error_code.to_le_bytes()[0..1]);match &self.child {BqrRootInflammationEventDataChild::Payload(p) => buffer[6..].copy_from_slice(&p[..]),BqrRootInflammationEventDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for BqrRootInflammationEventPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl BqrRootInflammationEventPacket { pub fn specialize(&self) -> BqrRootInflammationEventChild { match &self.bqr_root_inflammation_event.child {BqrRootInflammationEventDataChild::Payload(p) => BqrRootInflammationEventChild::Payload(p.clone()),BqrRootInflammationEventDataChild::None => BqrRootInflammationEventChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let vendor_specific_event = match &event.child {EventDataChild::VendorSpecificEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not VendorSpecificEvent"),};let bqr_event = match &vendor_specific_event.child {VendorSpecificEventDataChild::BqrEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrEvent"),};let bqr_root_inflammation_event = match &bqr_event.child {BqrEventDataChild::BqrRootInflammationEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrRootInflammationEvent"),};Self {event,vendor_specific_event,bqr_event,bqr_root_inflammation_event,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> VseSubeventCode{ self.vendor_specific_event.as_ref().subevent_code}
pub fn get_quality_report_id(&self) -> QualityReportId{ self.bqr_event.as_ref().quality_report_id}
pub fn get_error_code(&self) -> u8{ self.bqr_root_inflammation_event.as_ref().error_code}
pub fn get_vendor_specific_error_code(&self) -> u8{ self.bqr_root_inflammation_event.as_ref().vendor_specific_error_code}
}
impl Into<EventPacket> for BqrRootInflammationEventPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<VendorSpecificEventPacket> for BqrRootInflammationEventPacket { fn into(self) -> VendorSpecificEventPacket {VendorSpecificEventPacket::new(self.event) }}
impl Into<BqrEventPacket> for BqrRootInflammationEventPacket { fn into(self) -> BqrEventPacket {BqrEventPacket::new(self.event) }}
impl BqrRootInflammationEventBuilder {pub fn build(self) -> BqrRootInflammationEventPacket {let bqr_root_inflammation_event= Arc::new(BqrRootInflammationEventData {error_code: self.error_code, vendor_specific_error_code: self.vendor_specific_error_code, child: match self.payload { None => BqrRootInflammationEventDataChild::None,Some(bytes) => BqrRootInflammationEventDataChild::Payload(bytes),},});let bqr_event= Arc::new(BqrEventData {quality_report_id: QualityReportId::RootInflammation, child: BqrEventDataChild::BqrRootInflammationEvent(bqr_root_inflammation_event),});let vendor_specific_event= Arc::new(VendorSpecificEventData {subevent_code: VseSubeventCode::BqrEvent, child: VendorSpecificEventDataChild::BqrEvent(bqr_event),});let event= Arc::new(EventData {event_code: EventCode::VendorSpecific, child: EventDataChild::VendorSpecificEvent(vendor_specific_event),});BqrRootInflammationEventPacket::new(event)}
}
impl Into<EventPacket> for BqrRootInflammationEventBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<VendorSpecificEventPacket> for BqrRootInflammationEventBuilder { fn into(self) -> VendorSpecificEventPacket { self.build().into() }}
impl Into<BqrEventPacket> for BqrRootInflammationEventBuilder { fn into(self) -> BqrEventPacket { self.build().into() }}


#[derive(Debug)] enum BqrLogDumpEventDataChild {BqrLmpLlMessageTraceEvent(Arc<BqrLmpLlMessageTraceEventData>),BqrBtSchedulingTraceEvent(Arc<BqrBtSchedulingTraceEventData>),BqrControllerDbgInfoEvent(Arc<BqrControllerDbgInfoEventData>),Payload(Bytes),None,}
impl BqrLogDumpEventDataChild {fn get_total_size(&self) -> usize {match self {BqrLogDumpEventDataChild::BqrLmpLlMessageTraceEvent(value) => value.get_total_size(),BqrLogDumpEventDataChild::BqrBtSchedulingTraceEvent(value) => value.get_total_size(),BqrLogDumpEventDataChild::BqrControllerDbgInfoEvent(value) => value.get_total_size(),BqrLogDumpEventDataChild::Payload(p) => p.len(),BqrLogDumpEventDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum BqrLogDumpEventChild {BqrLmpLlMessageTraceEvent(BqrLmpLlMessageTraceEventPacket),BqrBtSchedulingTraceEvent(BqrBtSchedulingTraceEventPacket),BqrControllerDbgInfoEvent(BqrControllerDbgInfoEventPacket),Payload(Bytes),None,}
#[derive(Debug)] struct BqrLogDumpEventData {connection_handle: u16, child: BqrLogDumpEventDataChild,}
#[derive(Debug, Clone)] pub struct BqrLogDumpEventPacket {event: Arc<EventData>,vendor_specific_event: Arc<VendorSpecificEventData>,bqr_event: Arc<BqrEventData>,bqr_log_dump_event: Arc<BqrLogDumpEventData>,}
#[derive(Debug)] pub struct BqrLogDumpEventBuilder {pub quality_report_id: QualityReportId, pub connection_handle: u16, pub payload: Option<Bytes>,}
impl BqrLogDumpEventData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8], quality_report_id: QualityReportId) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "BqrLogDumpEvent".to_string(),    field: "connection_handle".to_string(),    wanted: 6,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[4],bytes[5]]);let connection_handle = connection_handle & 0xfff;let payload: Vec::<u8> = bytes[6..].into();let child = match quality_report_id {QualityReportId::LmpLlMessageTrace if BqrLmpLlMessageTraceEventData::conforms(&bytes[..]) => {BqrLogDumpEventDataChild::BqrLmpLlMessageTraceEvent(Arc::new(BqrLmpLlMessageTraceEventData::parse(&bytes[..])?))}
QualityReportId::BtSchedulingTrace if BqrBtSchedulingTraceEventData::conforms(&bytes[..]) => {BqrLogDumpEventDataChild::BqrBtSchedulingTraceEvent(Arc::new(BqrBtSchedulingTraceEventData::parse(&bytes[..])?))}
QualityReportId::ControllerDbgInfo if BqrControllerDbgInfoEventData::conforms(&bytes[..]) => {BqrLogDumpEventDataChild::BqrControllerDbgInfoEvent(Arc::new(BqrControllerDbgInfoEventData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "quality_report_id".to_string(), value: v as u64}),};
Ok(Self {connection_handle, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[4..6].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);match &self.child {BqrLogDumpEventDataChild::BqrLmpLlMessageTraceEvent(value) => value.write_to(buffer),BqrLogDumpEventDataChild::BqrBtSchedulingTraceEvent(value) => value.write_to(buffer),BqrLogDumpEventDataChild::BqrControllerDbgInfoEvent(value) => value.write_to(buffer),BqrLogDumpEventDataChild::Payload(p) => buffer[6..].copy_from_slice(&p[..]),BqrLogDumpEventDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 2;ret}
}
impl Packet for BqrLogDumpEventPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl BqrLogDumpEventPacket { pub fn specialize(&self) -> BqrLogDumpEventChild { match &self.bqr_log_dump_event.child {BqrLogDumpEventDataChild::BqrLmpLlMessageTraceEvent(_) => BqrLogDumpEventChild::BqrLmpLlMessageTraceEvent(BqrLmpLlMessageTraceEventPacket::new(self.event.clone())),BqrLogDumpEventDataChild::BqrBtSchedulingTraceEvent(_) => BqrLogDumpEventChild::BqrBtSchedulingTraceEvent(BqrBtSchedulingTraceEventPacket::new(self.event.clone())),BqrLogDumpEventDataChild::BqrControllerDbgInfoEvent(_) => BqrLogDumpEventChild::BqrControllerDbgInfoEvent(BqrControllerDbgInfoEventPacket::new(self.event.clone())),BqrLogDumpEventDataChild::Payload(p) => BqrLogDumpEventChild::Payload(p.clone()),BqrLogDumpEventDataChild::None => BqrLogDumpEventChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let vendor_specific_event = match &event.child {EventDataChild::VendorSpecificEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not VendorSpecificEvent"),};let bqr_event = match &vendor_specific_event.child {VendorSpecificEventDataChild::BqrEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrEvent"),};let bqr_log_dump_event = match &bqr_event.child {BqrEventDataChild::BqrLogDumpEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrLogDumpEvent"),};Self {event,vendor_specific_event,bqr_event,bqr_log_dump_event,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> VseSubeventCode{ self.vendor_specific_event.as_ref().subevent_code}
pub fn get_quality_report_id(&self) -> QualityReportId{ self.bqr_event.as_ref().quality_report_id}
pub fn get_connection_handle(&self) -> u16{ self.bqr_log_dump_event.as_ref().connection_handle}
}
impl Into<EventPacket> for BqrLogDumpEventPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<VendorSpecificEventPacket> for BqrLogDumpEventPacket { fn into(self) -> VendorSpecificEventPacket {VendorSpecificEventPacket::new(self.event) }}
impl Into<BqrEventPacket> for BqrLogDumpEventPacket { fn into(self) -> BqrEventPacket {BqrEventPacket::new(self.event) }}
impl BqrLogDumpEventBuilder {pub fn build(self) -> BqrLogDumpEventPacket {let bqr_log_dump_event= Arc::new(BqrLogDumpEventData {connection_handle: self.connection_handle, child: match self.payload { None => BqrLogDumpEventDataChild::None,Some(bytes) => BqrLogDumpEventDataChild::Payload(bytes),},});let bqr_event= Arc::new(BqrEventData {quality_report_id: self.quality_report_id, child: BqrEventDataChild::BqrLogDumpEvent(bqr_log_dump_event),});let vendor_specific_event= Arc::new(VendorSpecificEventData {subevent_code: VseSubeventCode::BqrEvent, child: VendorSpecificEventDataChild::BqrEvent(bqr_event),});let event= Arc::new(EventData {event_code: EventCode::VendorSpecific, child: EventDataChild::VendorSpecificEvent(vendor_specific_event),});BqrLogDumpEventPacket::new(event)}
}
impl Into<EventPacket> for BqrLogDumpEventBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<VendorSpecificEventPacket> for BqrLogDumpEventBuilder { fn into(self) -> VendorSpecificEventPacket { self.build().into() }}
impl Into<BqrEventPacket> for BqrLogDumpEventBuilder { fn into(self) -> BqrEventPacket { self.build().into() }}


#[derive(Debug)] enum BqrLmpLlMessageTraceEventDataChild {Payload(Bytes),None,}
impl BqrLmpLlMessageTraceEventDataChild {fn get_total_size(&self) -> usize {match self {BqrLmpLlMessageTraceEventDataChild::Payload(p) => p.len(),BqrLmpLlMessageTraceEventDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum BqrLmpLlMessageTraceEventChild {Payload(Bytes),None,}
#[derive(Debug)] struct BqrLmpLlMessageTraceEventData {child: BqrLmpLlMessageTraceEventDataChild,}
#[derive(Debug, Clone)] pub struct BqrLmpLlMessageTraceEventPacket {event: Arc<EventData>,vendor_specific_event: Arc<VendorSpecificEventData>,bqr_event: Arc<BqrEventData>,bqr_log_dump_event: Arc<BqrLogDumpEventData>,bqr_lmp_ll_message_trace_event: Arc<BqrLmpLlMessageTraceEventData>,}
#[derive(Debug)] pub struct BqrLmpLlMessageTraceEventBuilder {pub connection_handle: u16, pub payload: Option<Bytes>,}
impl BqrLmpLlMessageTraceEventData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {let payload: Vec::<u8> = bytes[6..].into();let child = if payload.len() > 0 {BqrLmpLlMessageTraceEventDataChild::Payload(Bytes::from(payload))} else {BqrLmpLlMessageTraceEventDataChild::None};Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {BqrLmpLlMessageTraceEventDataChild::Payload(p) => buffer[6..].copy_from_slice(&p[..]),BqrLmpLlMessageTraceEventDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for BqrLmpLlMessageTraceEventPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl BqrLmpLlMessageTraceEventPacket { pub fn specialize(&self) -> BqrLmpLlMessageTraceEventChild { match &self.bqr_lmp_ll_message_trace_event.child {BqrLmpLlMessageTraceEventDataChild::Payload(p) => BqrLmpLlMessageTraceEventChild::Payload(p.clone()),BqrLmpLlMessageTraceEventDataChild::None => BqrLmpLlMessageTraceEventChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let vendor_specific_event = match &event.child {EventDataChild::VendorSpecificEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not VendorSpecificEvent"),};let bqr_event = match &vendor_specific_event.child {VendorSpecificEventDataChild::BqrEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrEvent"),};let bqr_log_dump_event = match &bqr_event.child {BqrEventDataChild::BqrLogDumpEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrLogDumpEvent"),};let bqr_lmp_ll_message_trace_event = match &bqr_log_dump_event.child {BqrLogDumpEventDataChild::BqrLmpLlMessageTraceEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrLmpLlMessageTraceEvent"),};Self {event,vendor_specific_event,bqr_event,bqr_log_dump_event,bqr_lmp_ll_message_trace_event,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> VseSubeventCode{ self.vendor_specific_event.as_ref().subevent_code}
pub fn get_quality_report_id(&self) -> QualityReportId{ self.bqr_event.as_ref().quality_report_id}
pub fn get_connection_handle(&self) -> u16{ self.bqr_log_dump_event.as_ref().connection_handle}
}
impl Into<EventPacket> for BqrLmpLlMessageTraceEventPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<VendorSpecificEventPacket> for BqrLmpLlMessageTraceEventPacket { fn into(self) -> VendorSpecificEventPacket {VendorSpecificEventPacket::new(self.event) }}
impl Into<BqrEventPacket> for BqrLmpLlMessageTraceEventPacket { fn into(self) -> BqrEventPacket {BqrEventPacket::new(self.event) }}
impl Into<BqrLogDumpEventPacket> for BqrLmpLlMessageTraceEventPacket { fn into(self) -> BqrLogDumpEventPacket {BqrLogDumpEventPacket::new(self.event) }}
impl BqrLmpLlMessageTraceEventBuilder {pub fn build(self) -> BqrLmpLlMessageTraceEventPacket {let bqr_lmp_ll_message_trace_event= Arc::new(BqrLmpLlMessageTraceEventData {child: match self.payload { None => BqrLmpLlMessageTraceEventDataChild::None,Some(bytes) => BqrLmpLlMessageTraceEventDataChild::Payload(bytes),},});let bqr_log_dump_event= Arc::new(BqrLogDumpEventData {connection_handle: self.connection_handle, child: BqrLogDumpEventDataChild::BqrLmpLlMessageTraceEvent(bqr_lmp_ll_message_trace_event),});let bqr_event= Arc::new(BqrEventData {quality_report_id: QualityReportId::LmpLlMessageTrace, child: BqrEventDataChild::BqrLogDumpEvent(bqr_log_dump_event),});let vendor_specific_event= Arc::new(VendorSpecificEventData {subevent_code: VseSubeventCode::BqrEvent, child: VendorSpecificEventDataChild::BqrEvent(bqr_event),});let event= Arc::new(EventData {event_code: EventCode::VendorSpecific, child: EventDataChild::VendorSpecificEvent(vendor_specific_event),});BqrLmpLlMessageTraceEventPacket::new(event)}
}
impl Into<EventPacket> for BqrLmpLlMessageTraceEventBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<VendorSpecificEventPacket> for BqrLmpLlMessageTraceEventBuilder { fn into(self) -> VendorSpecificEventPacket { self.build().into() }}
impl Into<BqrEventPacket> for BqrLmpLlMessageTraceEventBuilder { fn into(self) -> BqrEventPacket { self.build().into() }}
impl Into<BqrLogDumpEventPacket> for BqrLmpLlMessageTraceEventBuilder { fn into(self) -> BqrLogDumpEventPacket { self.build().into() }}


#[derive(Debug)] enum BqrBtSchedulingTraceEventDataChild {Payload(Bytes),None,}
impl BqrBtSchedulingTraceEventDataChild {fn get_total_size(&self) -> usize {match self {BqrBtSchedulingTraceEventDataChild::Payload(p) => p.len(),BqrBtSchedulingTraceEventDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum BqrBtSchedulingTraceEventChild {Payload(Bytes),None,}
#[derive(Debug)] struct BqrBtSchedulingTraceEventData {child: BqrBtSchedulingTraceEventDataChild,}
#[derive(Debug, Clone)] pub struct BqrBtSchedulingTraceEventPacket {event: Arc<EventData>,vendor_specific_event: Arc<VendorSpecificEventData>,bqr_event: Arc<BqrEventData>,bqr_log_dump_event: Arc<BqrLogDumpEventData>,bqr_bt_scheduling_trace_event: Arc<BqrBtSchedulingTraceEventData>,}
#[derive(Debug)] pub struct BqrBtSchedulingTraceEventBuilder {pub connection_handle: u16, pub payload: Option<Bytes>,}
impl BqrBtSchedulingTraceEventData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {let payload: Vec::<u8> = bytes[6..].into();let child = if payload.len() > 0 {BqrBtSchedulingTraceEventDataChild::Payload(Bytes::from(payload))} else {BqrBtSchedulingTraceEventDataChild::None};Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {BqrBtSchedulingTraceEventDataChild::Payload(p) => buffer[6..].copy_from_slice(&p[..]),BqrBtSchedulingTraceEventDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for BqrBtSchedulingTraceEventPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl BqrBtSchedulingTraceEventPacket { pub fn specialize(&self) -> BqrBtSchedulingTraceEventChild { match &self.bqr_bt_scheduling_trace_event.child {BqrBtSchedulingTraceEventDataChild::Payload(p) => BqrBtSchedulingTraceEventChild::Payload(p.clone()),BqrBtSchedulingTraceEventDataChild::None => BqrBtSchedulingTraceEventChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let vendor_specific_event = match &event.child {EventDataChild::VendorSpecificEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not VendorSpecificEvent"),};let bqr_event = match &vendor_specific_event.child {VendorSpecificEventDataChild::BqrEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrEvent"),};let bqr_log_dump_event = match &bqr_event.child {BqrEventDataChild::BqrLogDumpEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrLogDumpEvent"),};let bqr_bt_scheduling_trace_event = match &bqr_log_dump_event.child {BqrLogDumpEventDataChild::BqrBtSchedulingTraceEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrBtSchedulingTraceEvent"),};Self {event,vendor_specific_event,bqr_event,bqr_log_dump_event,bqr_bt_scheduling_trace_event,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> VseSubeventCode{ self.vendor_specific_event.as_ref().subevent_code}
pub fn get_quality_report_id(&self) -> QualityReportId{ self.bqr_event.as_ref().quality_report_id}
pub fn get_connection_handle(&self) -> u16{ self.bqr_log_dump_event.as_ref().connection_handle}
}
impl Into<EventPacket> for BqrBtSchedulingTraceEventPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<VendorSpecificEventPacket> for BqrBtSchedulingTraceEventPacket { fn into(self) -> VendorSpecificEventPacket {VendorSpecificEventPacket::new(self.event) }}
impl Into<BqrEventPacket> for BqrBtSchedulingTraceEventPacket { fn into(self) -> BqrEventPacket {BqrEventPacket::new(self.event) }}
impl Into<BqrLogDumpEventPacket> for BqrBtSchedulingTraceEventPacket { fn into(self) -> BqrLogDumpEventPacket {BqrLogDumpEventPacket::new(self.event) }}
impl BqrBtSchedulingTraceEventBuilder {pub fn build(self) -> BqrBtSchedulingTraceEventPacket {let bqr_bt_scheduling_trace_event= Arc::new(BqrBtSchedulingTraceEventData {child: match self.payload { None => BqrBtSchedulingTraceEventDataChild::None,Some(bytes) => BqrBtSchedulingTraceEventDataChild::Payload(bytes),},});let bqr_log_dump_event= Arc::new(BqrLogDumpEventData {connection_handle: self.connection_handle, child: BqrLogDumpEventDataChild::BqrBtSchedulingTraceEvent(bqr_bt_scheduling_trace_event),});let bqr_event= Arc::new(BqrEventData {quality_report_id: QualityReportId::BtSchedulingTrace, child: BqrEventDataChild::BqrLogDumpEvent(bqr_log_dump_event),});let vendor_specific_event= Arc::new(VendorSpecificEventData {subevent_code: VseSubeventCode::BqrEvent, child: VendorSpecificEventDataChild::BqrEvent(bqr_event),});let event= Arc::new(EventData {event_code: EventCode::VendorSpecific, child: EventDataChild::VendorSpecificEvent(vendor_specific_event),});BqrBtSchedulingTraceEventPacket::new(event)}
}
impl Into<EventPacket> for BqrBtSchedulingTraceEventBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<VendorSpecificEventPacket> for BqrBtSchedulingTraceEventBuilder { fn into(self) -> VendorSpecificEventPacket { self.build().into() }}
impl Into<BqrEventPacket> for BqrBtSchedulingTraceEventBuilder { fn into(self) -> BqrEventPacket { self.build().into() }}
impl Into<BqrLogDumpEventPacket> for BqrBtSchedulingTraceEventBuilder { fn into(self) -> BqrLogDumpEventPacket { self.build().into() }}


#[derive(Debug)] enum BqrControllerDbgInfoEventDataChild {Payload(Bytes),None,}
impl BqrControllerDbgInfoEventDataChild {fn get_total_size(&self) -> usize {match self {BqrControllerDbgInfoEventDataChild::Payload(p) => p.len(),BqrControllerDbgInfoEventDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum BqrControllerDbgInfoEventChild {Payload(Bytes),None,}
#[derive(Debug)] struct BqrControllerDbgInfoEventData {child: BqrControllerDbgInfoEventDataChild,}
#[derive(Debug, Clone)] pub struct BqrControllerDbgInfoEventPacket {event: Arc<EventData>,vendor_specific_event: Arc<VendorSpecificEventData>,bqr_event: Arc<BqrEventData>,bqr_log_dump_event: Arc<BqrLogDumpEventData>,bqr_controller_dbg_info_event: Arc<BqrControllerDbgInfoEventData>,}
#[derive(Debug)] pub struct BqrControllerDbgInfoEventBuilder {pub connection_handle: u16, pub payload: Option<Bytes>,}
impl BqrControllerDbgInfoEventData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {let payload: Vec::<u8> = bytes[6..].into();let child = if payload.len() > 0 {BqrControllerDbgInfoEventDataChild::Payload(Bytes::from(payload))} else {BqrControllerDbgInfoEventDataChild::None};Ok(Self {child,})
}
fn write_to(&self, buffer: &mut BytesMut) {match &self.child {BqrControllerDbgInfoEventDataChild::Payload(p) => buffer[6..].copy_from_slice(&p[..]),BqrControllerDbgInfoEventDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;ret}
}
impl Packet for BqrControllerDbgInfoEventPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.event.get_total_size(), 0); self.event.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl BqrControllerDbgInfoEventPacket { pub fn specialize(&self) -> BqrControllerDbgInfoEventChild { match &self.bqr_controller_dbg_info_event.child {BqrControllerDbgInfoEventDataChild::Payload(p) => BqrControllerDbgInfoEventChild::Payload(p.clone()),BqrControllerDbgInfoEventDataChild::None => BqrControllerDbgInfoEventChild::None,}} fn new(root: Arc<EventData>) -> Self {let event = root;let vendor_specific_event = match &event.child {EventDataChild::VendorSpecificEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not VendorSpecificEvent"),};let bqr_event = match &vendor_specific_event.child {VendorSpecificEventDataChild::BqrEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrEvent"),};let bqr_log_dump_event = match &bqr_event.child {BqrEventDataChild::BqrLogDumpEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrLogDumpEvent"),};let bqr_controller_dbg_info_event = match &bqr_log_dump_event.child {BqrLogDumpEventDataChild::BqrControllerDbgInfoEvent(value) => (*value).clone(),_ => panic!("inconsistent state - child was not BqrControllerDbgInfoEvent"),};Self {event,vendor_specific_event,bqr_event,bqr_log_dump_event,bqr_controller_dbg_info_event,}}pub fn get_event_code(&self) -> EventCode{ self.event.as_ref().event_code}
pub fn get_subevent_code(&self) -> VseSubeventCode{ self.vendor_specific_event.as_ref().subevent_code}
pub fn get_quality_report_id(&self) -> QualityReportId{ self.bqr_event.as_ref().quality_report_id}
pub fn get_connection_handle(&self) -> u16{ self.bqr_log_dump_event.as_ref().connection_handle}
}
impl Into<EventPacket> for BqrControllerDbgInfoEventPacket { fn into(self) -> EventPacket {EventPacket::new(self.event) }}
impl Into<VendorSpecificEventPacket> for BqrControllerDbgInfoEventPacket { fn into(self) -> VendorSpecificEventPacket {VendorSpecificEventPacket::new(self.event) }}
impl Into<BqrEventPacket> for BqrControllerDbgInfoEventPacket { fn into(self) -> BqrEventPacket {BqrEventPacket::new(self.event) }}
impl Into<BqrLogDumpEventPacket> for BqrControllerDbgInfoEventPacket { fn into(self) -> BqrLogDumpEventPacket {BqrLogDumpEventPacket::new(self.event) }}
impl BqrControllerDbgInfoEventBuilder {pub fn build(self) -> BqrControllerDbgInfoEventPacket {let bqr_controller_dbg_info_event= Arc::new(BqrControllerDbgInfoEventData {child: match self.payload { None => BqrControllerDbgInfoEventDataChild::None,Some(bytes) => BqrControllerDbgInfoEventDataChild::Payload(bytes),},});let bqr_log_dump_event= Arc::new(BqrLogDumpEventData {connection_handle: self.connection_handle, child: BqrLogDumpEventDataChild::BqrControllerDbgInfoEvent(bqr_controller_dbg_info_event),});let bqr_event= Arc::new(BqrEventData {quality_report_id: QualityReportId::ControllerDbgInfo, child: BqrEventDataChild::BqrLogDumpEvent(bqr_log_dump_event),});let vendor_specific_event= Arc::new(VendorSpecificEventData {subevent_code: VseSubeventCode::BqrEvent, child: VendorSpecificEventDataChild::BqrEvent(bqr_event),});let event= Arc::new(EventData {event_code: EventCode::VendorSpecific, child: EventDataChild::VendorSpecificEvent(vendor_specific_event),});BqrControllerDbgInfoEventPacket::new(event)}
}
impl Into<EventPacket> for BqrControllerDbgInfoEventBuilder { fn into(self) -> EventPacket { self.build().into() }}
impl Into<VendorSpecificEventPacket> for BqrControllerDbgInfoEventBuilder { fn into(self) -> VendorSpecificEventPacket { self.build().into() }}
impl Into<BqrEventPacket> for BqrControllerDbgInfoEventBuilder { fn into(self) -> BqrEventPacket { self.build().into() }}
impl Into<BqrLogDumpEventPacket> for BqrControllerDbgInfoEventBuilder { fn into(self) -> BqrLogDumpEventPacket { self.build().into() }}


#[derive(Debug)] enum IsoDataChild {IsoWithTimestamp(Arc<IsoWithTimestampData>),IsoWithoutTimestamp(Arc<IsoWithoutTimestampData>),Payload(Bytes),None,}
impl IsoDataChild {fn get_total_size(&self) -> usize {match self {IsoDataChild::IsoWithTimestamp(value) => value.get_total_size(),IsoDataChild::IsoWithoutTimestamp(value) => value.get_total_size(),IsoDataChild::Payload(p) => p.len(),IsoDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum IsoChild {IsoWithTimestamp(IsoWithTimestampPacket),IsoWithoutTimestamp(IsoWithoutTimestampPacket),Payload(Bytes),None,}
#[derive(Debug)] struct IsoData {connection_handle: u16, pb_flag: IsoPacketBoundaryFlag, ts_flag: TimeStampFlag, child: IsoDataChild,}
#[derive(Debug, Clone)] pub struct IsoPacket {iso: Arc<IsoData>,}
#[derive(Debug)] pub struct IsoBuilder {pub connection_handle: u16, pub pb_flag: IsoPacketBoundaryFlag, pub ts_flag: TimeStampFlag, pub payload: Option<Bytes>,}
impl IsoData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 2 { return Err(Error::InvalidLengthError{    obj: "Iso".to_string(),    field: "connection_handle".to_string(),    wanted: 2,    got: bytes.len()});}let connection_handle = u16::from_le_bytes([bytes[0],bytes[1]]);let connection_handle = connection_handle & 0xfff;let pb_flag = u8::from_le_bytes([bytes[1]]);let pb_flag = pb_flag >> 4;let pb_flag = pb_flag & 0x3;let pb_flag = IsoPacketBoundaryFlag::from_u8(pb_flag).unwrap();let ts_flag = u8::from_le_bytes([bytes[1]]);let ts_flag = ts_flag >> 6;let ts_flag = ts_flag & 0x1;let ts_flag = TimeStampFlag::from_u8(ts_flag).unwrap();if bytes.len() < 4 { return Err(Error::InvalidLengthError{    obj: "Iso".to_string(),    field: "payload_size".to_string(),    wanted: 4,    got: bytes.len()});}let payload_size = u16::from_le_bytes([bytes[2],bytes[3]]);let payload_size = payload_size & 0x3fff;let payload: Vec::<u8> = bytes[4..(4 + payload_size as usize)].into();let child = match ts_flag {TimeStampFlag::Present if IsoWithTimestampData::conforms(&bytes[..]) => {IsoDataChild::IsoWithTimestamp(Arc::new(IsoWithTimestampData::parse(&bytes[..])?))}
TimeStampFlag::NotPresent if IsoWithoutTimestampData::conforms(&bytes[..]) => {IsoDataChild::IsoWithoutTimestamp(Arc::new(IsoWithoutTimestampData::parse(&bytes[..])?))}
v => return Err(Error::ConstraintOutOfBounds{field: "ts_flag".to_string(), value: v as u64}),};
Ok(Self {connection_handle, pb_flag, ts_flag, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let connection_handle = self.connection_handle;let connection_handle = connection_handle & 0xfff;buffer[0..2].copy_from_slice(&connection_handle.to_le_bytes()[0..2]);let pb_flag = self.pb_flag.to_u8().unwrap();let pb_flag = pb_flag & 0x3;let pb_flag = (pb_flag << 4) | ((buffer[1] as u8) & 0xf);buffer[1..2].copy_from_slice(&pb_flag.to_le_bytes()[0..1]);let ts_flag = self.ts_flag.to_u8().unwrap();let ts_flag = ts_flag & 0x1;let ts_flag = (ts_flag << 6) | ((buffer[1] as u8) & 0x3f);buffer[1..2].copy_from_slice(&ts_flag.to_le_bytes()[0..1]);let payload_size = u16::try_from(self.child.get_total_size()).expect("payload size did not fit");let payload_size = payload_size & 0x3fff;buffer[2..4].copy_from_slice(&payload_size.to_le_bytes()[0..2]);match &self.child {IsoDataChild::IsoWithTimestamp(value) => value.write_to(buffer),IsoDataChild::IsoWithoutTimestamp(value) => value.write_to(buffer),IsoDataChild::Payload(p) => buffer[4..].copy_from_slice(&p[..]),IsoDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl Packet for IsoPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.iso.get_total_size(), 0); self.iso.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl IsoPacket {pub fn parse(bytes: &[u8]) -> Result<Self> { Ok(Self::new(Arc::new(IsoData::parse(bytes)?)))} pub fn specialize(&self) -> IsoChild { match &self.iso.child {IsoDataChild::IsoWithTimestamp(_) => IsoChild::IsoWithTimestamp(IsoWithTimestampPacket::new(self.iso.clone())),IsoDataChild::IsoWithoutTimestamp(_) => IsoChild::IsoWithoutTimestamp(IsoWithoutTimestampPacket::new(self.iso.clone())),IsoDataChild::Payload(p) => IsoChild::Payload(p.clone()),IsoDataChild::None => IsoChild::None,}} fn new(root: Arc<IsoData>) -> Self {let iso = root;Self {iso,}}pub fn get_connection_handle(&self) -> u16{ self.iso.as_ref().connection_handle}
pub fn get_pb_flag(&self) -> IsoPacketBoundaryFlag{ self.iso.as_ref().pb_flag}
pub fn get_ts_flag(&self) -> TimeStampFlag{ self.iso.as_ref().ts_flag}
}
impl IsoBuilder {pub fn build(self) -> IsoPacket {let iso= Arc::new(IsoData {connection_handle: self.connection_handle, pb_flag: self.pb_flag, ts_flag: self.ts_flag, child: match self.payload { None => IsoDataChild::None,Some(bytes) => IsoDataChild::Payload(bytes),},});IsoPacket::new(iso)}
}


#[derive(Debug)] enum IsoWithTimestampDataChild {Payload(Bytes),None,}
impl IsoWithTimestampDataChild {fn get_total_size(&self) -> usize {match self {IsoWithTimestampDataChild::Payload(p) => p.len(),IsoWithTimestampDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum IsoWithTimestampChild {Payload(Bytes),None,}
#[derive(Debug)] struct IsoWithTimestampData {time_stamp: u32, packet_sequence_number: u16, packet_status_flag: IsoPacketStatusFlag, child: IsoWithTimestampDataChild,}
#[derive(Debug, Clone)] pub struct IsoWithTimestampPacket {iso: Arc<IsoData>,iso_with_timestamp: Arc<IsoWithTimestampData>,}
#[derive(Debug)] pub struct IsoWithTimestampBuilder {pub connection_handle: u16, pub pb_flag: IsoPacketBoundaryFlag, pub time_stamp: u32, pub packet_sequence_number: u16, pub packet_status_flag: IsoPacketStatusFlag, pub payload: Option<Bytes>,}
impl IsoWithTimestampData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "IsoWithTimestamp".to_string(),    field: "time_stamp".to_string(),    wanted: 8,    got: bytes.len()});}let time_stamp = u32::from_le_bytes([bytes[4],bytes[5],bytes[6],bytes[7]]);if bytes.len() < 10 { return Err(Error::InvalidLengthError{    obj: "IsoWithTimestamp".to_string(),    field: "packet_sequence_number".to_string(),    wanted: 10,    got: bytes.len()});}let packet_sequence_number = u16::from_le_bytes([bytes[8],bytes[9]]);if bytes.len() < 12 { return Err(Error::InvalidLengthError{    obj: "IsoWithTimestamp".to_string(),    field: "payload_size".to_string(),    wanted: 12,    got: bytes.len()});}let payload_size = u16::from_le_bytes([bytes[10],bytes[11]]);let payload_size = payload_size & 0xfff;let packet_status_flag = u8::from_le_bytes([bytes[11]]);let packet_status_flag = packet_status_flag >> 6;let packet_status_flag = packet_status_flag & 0x3;let packet_status_flag = IsoPacketStatusFlag::from_u8(packet_status_flag).unwrap();let payload: Vec::<u8> = bytes[12..(12 + payload_size as usize)].into();let child = if payload.len() > 0 {IsoWithTimestampDataChild::Payload(Bytes::from(payload))} else {IsoWithTimestampDataChild::None};Ok(Self {time_stamp, packet_sequence_number, packet_status_flag, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let time_stamp = self.time_stamp;buffer[4..8].copy_from_slice(&time_stamp.to_le_bytes()[0..4]);let packet_sequence_number = self.packet_sequence_number;buffer[8..10].copy_from_slice(&packet_sequence_number.to_le_bytes()[0..2]);let payload_size = u16::try_from(self.child.get_total_size()).expect("payload size did not fit");let payload_size = payload_size & 0xfff;buffer[10..12].copy_from_slice(&payload_size.to_le_bytes()[0..2]);let packet_status_flag = self.packet_status_flag.to_u8().unwrap();let packet_status_flag = packet_status_flag & 0x3;let packet_status_flag = (packet_status_flag << 6) | ((buffer[11] as u8) & 0x3f);buffer[11..12].copy_from_slice(&packet_status_flag.to_le_bytes()[0..1]);match &self.child {IsoWithTimestampDataChild::Payload(p) => buffer[12..].copy_from_slice(&p[..]),IsoWithTimestampDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 8;ret}
}
impl Packet for IsoWithTimestampPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.iso.get_total_size(), 0); self.iso.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl IsoWithTimestampPacket { pub fn specialize(&self) -> IsoWithTimestampChild { match &self.iso_with_timestamp.child {IsoWithTimestampDataChild::Payload(p) => IsoWithTimestampChild::Payload(p.clone()),IsoWithTimestampDataChild::None => IsoWithTimestampChild::None,}} fn new(root: Arc<IsoData>) -> Self {let iso = root;let iso_with_timestamp = match &iso.child {IsoDataChild::IsoWithTimestamp(value) => (*value).clone(),_ => panic!("inconsistent state - child was not IsoWithTimestamp"),};Self {iso,iso_with_timestamp,}}pub fn get_connection_handle(&self) -> u16{ self.iso.as_ref().connection_handle}
pub fn get_pb_flag(&self) -> IsoPacketBoundaryFlag{ self.iso.as_ref().pb_flag}
pub fn get_ts_flag(&self) -> TimeStampFlag{ self.iso.as_ref().ts_flag}
pub fn get_time_stamp(&self) -> u32{ self.iso_with_timestamp.as_ref().time_stamp}
pub fn get_packet_sequence_number(&self) -> u16{ self.iso_with_timestamp.as_ref().packet_sequence_number}
pub fn get_packet_status_flag(&self) -> IsoPacketStatusFlag{ self.iso_with_timestamp.as_ref().packet_status_flag}
}
impl Into<IsoPacket> for IsoWithTimestampPacket { fn into(self) -> IsoPacket {IsoPacket::new(self.iso) }}
impl IsoWithTimestampBuilder {pub fn build(self) -> IsoWithTimestampPacket {let iso_with_timestamp= Arc::new(IsoWithTimestampData {time_stamp: self.time_stamp, packet_sequence_number: self.packet_sequence_number, packet_status_flag: self.packet_status_flag, child: match self.payload { None => IsoWithTimestampDataChild::None,Some(bytes) => IsoWithTimestampDataChild::Payload(bytes),},});let iso= Arc::new(IsoData {connection_handle: self.connection_handle, pb_flag: self.pb_flag, ts_flag: TimeStampFlag::Present, child: IsoDataChild::IsoWithTimestamp(iso_with_timestamp),});IsoWithTimestampPacket::new(iso)}
}
impl Into<IsoPacket> for IsoWithTimestampBuilder { fn into(self) -> IsoPacket { self.build().into() }}


#[derive(Debug)] enum IsoWithoutTimestampDataChild {Payload(Bytes),None,}
impl IsoWithoutTimestampDataChild {fn get_total_size(&self) -> usize {match self {IsoWithoutTimestampDataChild::Payload(p) => p.len(),IsoWithoutTimestampDataChild::None => 0,}
}
}
#[derive(Debug)] pub enum IsoWithoutTimestampChild {Payload(Bytes),None,}
#[derive(Debug)] struct IsoWithoutTimestampData {packet_sequence_number: u16, packet_status_flag: IsoPacketStatusFlag, child: IsoWithoutTimestampDataChild,}
#[derive(Debug, Clone)] pub struct IsoWithoutTimestampPacket {iso: Arc<IsoData>,iso_without_timestamp: Arc<IsoWithoutTimestampData>,}
#[derive(Debug)] pub struct IsoWithoutTimestampBuilder {pub connection_handle: u16, pub pb_flag: IsoPacketBoundaryFlag, pub packet_sequence_number: u16, pub packet_status_flag: IsoPacketStatusFlag, pub payload: Option<Bytes>,}
impl IsoWithoutTimestampData {fn conforms(bytes: &[u8]) -> bool { true}fn parse(bytes: &[u8]) -> Result<Self> {if bytes.len() < 6 { return Err(Error::InvalidLengthError{    obj: "IsoWithoutTimestamp".to_string(),    field: "packet_sequence_number".to_string(),    wanted: 6,    got: bytes.len()});}let packet_sequence_number = u16::from_le_bytes([bytes[4],bytes[5]]);if bytes.len() < 8 { return Err(Error::InvalidLengthError{    obj: "IsoWithoutTimestamp".to_string(),    field: "payload_size".to_string(),    wanted: 8,    got: bytes.len()});}let payload_size = u16::from_le_bytes([bytes[6],bytes[7]]);let payload_size = payload_size & 0xfff;let packet_status_flag = u8::from_le_bytes([bytes[7]]);let packet_status_flag = packet_status_flag >> 6;let packet_status_flag = packet_status_flag & 0x3;let packet_status_flag = IsoPacketStatusFlag::from_u8(packet_status_flag).unwrap();let payload: Vec::<u8> = bytes[8..(8 + payload_size as usize)].into();let child = if payload.len() > 0 {IsoWithoutTimestampDataChild::Payload(Bytes::from(payload))} else {IsoWithoutTimestampDataChild::None};Ok(Self {packet_sequence_number, packet_status_flag, child,})
}
fn write_to(&self, buffer: &mut BytesMut) {let packet_sequence_number = self.packet_sequence_number;buffer[4..6].copy_from_slice(&packet_sequence_number.to_le_bytes()[0..2]);let payload_size = u16::try_from(self.child.get_total_size()).expect("payload size did not fit");let payload_size = payload_size & 0xfff;buffer[6..8].copy_from_slice(&payload_size.to_le_bytes()[0..2]);let packet_status_flag = self.packet_status_flag.to_u8().unwrap();let packet_status_flag = packet_status_flag & 0x3;let packet_status_flag = (packet_status_flag << 6) | ((buffer[7] as u8) & 0x3f);buffer[7..8].copy_from_slice(&packet_status_flag.to_le_bytes()[0..1]);match &self.child {IsoWithoutTimestampDataChild::Payload(p) => buffer[8..].copy_from_slice(&p[..]),IsoWithoutTimestampDataChild::None => {}}}
fn get_total_size(&self) -> usize {self.get_size() + self.child.get_total_size()}
fn get_size(&self) -> usize {let ret = 0;let ret = ret + 4;ret}
}
impl Packet for IsoWithoutTimestampPacket {fn to_bytes(self) -> Bytes { let mut buffer = BytesMut::new(); buffer.resize(self.iso.get_total_size(), 0); self.iso.write_to(&mut buffer); buffer.freeze()}
fn to_vec(self) -> Vec<u8> { self.to_bytes().to_vec() }
}impl IsoWithoutTimestampPacket { pub fn specialize(&self) -> IsoWithoutTimestampChild { match &self.iso_without_timestamp.child {IsoWithoutTimestampDataChild::Payload(p) => IsoWithoutTimestampChild::Payload(p.clone()),IsoWithoutTimestampDataChild::None => IsoWithoutTimestampChild::None,}} fn new(root: Arc<IsoData>) -> Self {let iso = root;let iso_without_timestamp = match &iso.child {IsoDataChild::IsoWithoutTimestamp(value) => (*value).clone(),_ => panic!("inconsistent state - child was not IsoWithoutTimestamp"),};Self {iso,iso_without_timestamp,}}pub fn get_connection_handle(&self) -> u16{ self.iso.as_ref().connection_handle}
pub fn get_pb_flag(&self) -> IsoPacketBoundaryFlag{ self.iso.as_ref().pb_flag}
pub fn get_ts_flag(&self) -> TimeStampFlag{ self.iso.as_ref().ts_flag}
pub fn get_packet_sequence_number(&self) -> u16{ self.iso_without_timestamp.as_ref().packet_sequence_number}
pub fn get_packet_status_flag(&self) -> IsoPacketStatusFlag{ self.iso_without_timestamp.as_ref().packet_status_flag}
}
impl Into<IsoPacket> for IsoWithoutTimestampPacket { fn into(self) -> IsoPacket {IsoPacket::new(self.iso) }}
impl IsoWithoutTimestampBuilder {pub fn build(self) -> IsoWithoutTimestampPacket {let iso_without_timestamp= Arc::new(IsoWithoutTimestampData {packet_sequence_number: self.packet_sequence_number, packet_status_flag: self.packet_status_flag, child: match self.payload { None => IsoWithoutTimestampDataChild::None,Some(bytes) => IsoWithoutTimestampDataChild::Payload(bytes),},});let iso= Arc::new(IsoData {connection_handle: self.connection_handle, pb_flag: self.pb_flag, ts_flag: TimeStampFlag::NotPresent, child: IsoDataChild::IsoWithoutTimestamp(iso_without_timestamp),});IsoWithoutTimestampPacket::new(iso)}
}
impl Into<IsoPacket> for IsoWithoutTimestampBuilder { fn into(self) -> IsoPacket { self.build().into() }}


