// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: system/extras/simpleperf/cmd_report_sample.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_system_2fextras_2fsimpleperf_2fcmd_5freport_5fsample_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_system_2fextras_2fsimpleperf_2fcmd_5freport_5fsample_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_system_2fextras_2fsimpleperf_2fcmd_5freport_5fsample_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_system_2fextras_2fsimpleperf_2fcmd_5freport_5fsample_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace simpleperf_report_proto {
class File;
class FileDefaultTypeInternal;
extern FileDefaultTypeInternal _File_default_instance_;
class LostSituation;
class LostSituationDefaultTypeInternal;
extern LostSituationDefaultTypeInternal _LostSituation_default_instance_;
class MetaInfo;
class MetaInfoDefaultTypeInternal;
extern MetaInfoDefaultTypeInternal _MetaInfo_default_instance_;
class Record;
class RecordDefaultTypeInternal;
extern RecordDefaultTypeInternal _Record_default_instance_;
class Sample;
class SampleDefaultTypeInternal;
extern SampleDefaultTypeInternal _Sample_default_instance_;
class Sample_CallChainEntry;
class Sample_CallChainEntryDefaultTypeInternal;
extern Sample_CallChainEntryDefaultTypeInternal _Sample_CallChainEntry_default_instance_;
class Sample_UnwindingResult;
class Sample_UnwindingResultDefaultTypeInternal;
extern Sample_UnwindingResultDefaultTypeInternal _Sample_UnwindingResult_default_instance_;
class Thread;
class ThreadDefaultTypeInternal;
extern ThreadDefaultTypeInternal _Thread_default_instance_;
}  // namespace simpleperf_report_proto
PROTOBUF_NAMESPACE_OPEN
template<> ::simpleperf_report_proto::File* Arena::CreateMaybeMessage<::simpleperf_report_proto::File>(Arena*);
template<> ::simpleperf_report_proto::LostSituation* Arena::CreateMaybeMessage<::simpleperf_report_proto::LostSituation>(Arena*);
template<> ::simpleperf_report_proto::MetaInfo* Arena::CreateMaybeMessage<::simpleperf_report_proto::MetaInfo>(Arena*);
template<> ::simpleperf_report_proto::Record* Arena::CreateMaybeMessage<::simpleperf_report_proto::Record>(Arena*);
template<> ::simpleperf_report_proto::Sample* Arena::CreateMaybeMessage<::simpleperf_report_proto::Sample>(Arena*);
template<> ::simpleperf_report_proto::Sample_CallChainEntry* Arena::CreateMaybeMessage<::simpleperf_report_proto::Sample_CallChainEntry>(Arena*);
template<> ::simpleperf_report_proto::Sample_UnwindingResult* Arena::CreateMaybeMessage<::simpleperf_report_proto::Sample_UnwindingResult>(Arena*);
template<> ::simpleperf_report_proto::Thread* Arena::CreateMaybeMessage<::simpleperf_report_proto::Thread>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace simpleperf_report_proto {

enum Sample_CallChainEntry_ExecutionType : int {
  Sample_CallChainEntry_ExecutionType_NATIVE_METHOD = 0,
  Sample_CallChainEntry_ExecutionType_INTERPRETED_JVM_METHOD = 1,
  Sample_CallChainEntry_ExecutionType_JIT_JVM_METHOD = 2,
  Sample_CallChainEntry_ExecutionType_ART_METHOD = 3
};
bool Sample_CallChainEntry_ExecutionType_IsValid(int value);
constexpr Sample_CallChainEntry_ExecutionType Sample_CallChainEntry_ExecutionType_ExecutionType_MIN = Sample_CallChainEntry_ExecutionType_NATIVE_METHOD;
constexpr Sample_CallChainEntry_ExecutionType Sample_CallChainEntry_ExecutionType_ExecutionType_MAX = Sample_CallChainEntry_ExecutionType_ART_METHOD;
constexpr int Sample_CallChainEntry_ExecutionType_ExecutionType_ARRAYSIZE = Sample_CallChainEntry_ExecutionType_ExecutionType_MAX + 1;

const std::string& Sample_CallChainEntry_ExecutionType_Name(Sample_CallChainEntry_ExecutionType value);
template<typename T>
inline const std::string& Sample_CallChainEntry_ExecutionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Sample_CallChainEntry_ExecutionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Sample_CallChainEntry_ExecutionType_Name.");
  return Sample_CallChainEntry_ExecutionType_Name(static_cast<Sample_CallChainEntry_ExecutionType>(enum_t_value));
}
bool Sample_CallChainEntry_ExecutionType_Parse(
    const std::string& name, Sample_CallChainEntry_ExecutionType* value);
enum Sample_UnwindingResult_ErrorCode : int {
  Sample_UnwindingResult_ErrorCode_ERROR_NONE = 0,
  Sample_UnwindingResult_ErrorCode_ERROR_UNKNOWN = 1,
  Sample_UnwindingResult_ErrorCode_ERROR_NOT_ENOUGH_STACK = 2,
  Sample_UnwindingResult_ErrorCode_ERROR_MEMORY_INVALID = 3,
  Sample_UnwindingResult_ErrorCode_ERROR_UNWIND_INFO = 4,
  Sample_UnwindingResult_ErrorCode_ERROR_INVALID_MAP = 5,
  Sample_UnwindingResult_ErrorCode_ERROR_MAX_FRAME_EXCEEDED = 6,
  Sample_UnwindingResult_ErrorCode_ERROR_REPEATED_FRAME = 7,
  Sample_UnwindingResult_ErrorCode_ERROR_INVALID_ELF = 8
};
bool Sample_UnwindingResult_ErrorCode_IsValid(int value);
constexpr Sample_UnwindingResult_ErrorCode Sample_UnwindingResult_ErrorCode_ErrorCode_MIN = Sample_UnwindingResult_ErrorCode_ERROR_NONE;
constexpr Sample_UnwindingResult_ErrorCode Sample_UnwindingResult_ErrorCode_ErrorCode_MAX = Sample_UnwindingResult_ErrorCode_ERROR_INVALID_ELF;
constexpr int Sample_UnwindingResult_ErrorCode_ErrorCode_ARRAYSIZE = Sample_UnwindingResult_ErrorCode_ErrorCode_MAX + 1;

const std::string& Sample_UnwindingResult_ErrorCode_Name(Sample_UnwindingResult_ErrorCode value);
template<typename T>
inline const std::string& Sample_UnwindingResult_ErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Sample_UnwindingResult_ErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Sample_UnwindingResult_ErrorCode_Name.");
  return Sample_UnwindingResult_ErrorCode_Name(static_cast<Sample_UnwindingResult_ErrorCode>(enum_t_value));
}
bool Sample_UnwindingResult_ErrorCode_Parse(
    const std::string& name, Sample_UnwindingResult_ErrorCode* value);
// ===================================================================

class Sample_CallChainEntry :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:simpleperf_report_proto.Sample.CallChainEntry) */ {
 public:
  Sample_CallChainEntry();
  virtual ~Sample_CallChainEntry();

  Sample_CallChainEntry(const Sample_CallChainEntry& from);
  Sample_CallChainEntry(Sample_CallChainEntry&& from) noexcept
    : Sample_CallChainEntry() {
    *this = ::std::move(from);
  }

  inline Sample_CallChainEntry& operator=(const Sample_CallChainEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sample_CallChainEntry& operator=(Sample_CallChainEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Sample_CallChainEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sample_CallChainEntry* internal_default_instance() {
    return reinterpret_cast<const Sample_CallChainEntry*>(
               &_Sample_CallChainEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Sample_CallChainEntry& a, Sample_CallChainEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(Sample_CallChainEntry* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Sample_CallChainEntry* New() const final {
    return CreateMaybeMessage<Sample_CallChainEntry>(nullptr);
  }

  Sample_CallChainEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Sample_CallChainEntry>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Sample_CallChainEntry& from);
  void MergeFrom(const Sample_CallChainEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Sample_CallChainEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "simpleperf_report_proto.Sample.CallChainEntry";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Sample_CallChainEntry_ExecutionType ExecutionType;
  static constexpr ExecutionType NATIVE_METHOD =
    Sample_CallChainEntry_ExecutionType_NATIVE_METHOD;
  static constexpr ExecutionType INTERPRETED_JVM_METHOD =
    Sample_CallChainEntry_ExecutionType_INTERPRETED_JVM_METHOD;
  static constexpr ExecutionType JIT_JVM_METHOD =
    Sample_CallChainEntry_ExecutionType_JIT_JVM_METHOD;
  static constexpr ExecutionType ART_METHOD =
    Sample_CallChainEntry_ExecutionType_ART_METHOD;
  static inline bool ExecutionType_IsValid(int value) {
    return Sample_CallChainEntry_ExecutionType_IsValid(value);
  }
  static constexpr ExecutionType ExecutionType_MIN =
    Sample_CallChainEntry_ExecutionType_ExecutionType_MIN;
  static constexpr ExecutionType ExecutionType_MAX =
    Sample_CallChainEntry_ExecutionType_ExecutionType_MAX;
  static constexpr int ExecutionType_ARRAYSIZE =
    Sample_CallChainEntry_ExecutionType_ExecutionType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ExecutionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ExecutionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ExecutionType_Name.");
    return Sample_CallChainEntry_ExecutionType_Name(enum_t_value);
  }
  static inline bool ExecutionType_Parse(const std::string& name,
      ExecutionType* value) {
    return Sample_CallChainEntry_ExecutionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVaddrInFileFieldNumber = 1,
    kFileIdFieldNumber = 2,
    kSymbolIdFieldNumber = 3,
    kExecutionTypeFieldNumber = 4,
  };
  // optional uint64 vaddr_in_file = 1;
  bool has_vaddr_in_file() const;
  void clear_vaddr_in_file();
  ::PROTOBUF_NAMESPACE_ID::uint64 vaddr_in_file() const;
  void set_vaddr_in_file(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint32 file_id = 2;
  bool has_file_id() const;
  void clear_file_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 file_id() const;
  void set_file_id(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional int32 symbol_id = 3;
  bool has_symbol_id() const;
  void clear_symbol_id();
  ::PROTOBUF_NAMESPACE_ID::int32 symbol_id() const;
  void set_symbol_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional .simpleperf_report_proto.Sample.CallChainEntry.ExecutionType execution_type = 4 [default = NATIVE_METHOD];
  bool has_execution_type() const;
  void clear_execution_type();
  ::simpleperf_report_proto::Sample_CallChainEntry_ExecutionType execution_type() const;
  void set_execution_type(::simpleperf_report_proto::Sample_CallChainEntry_ExecutionType value);

  // @@protoc_insertion_point(class_scope:simpleperf_report_proto.Sample.CallChainEntry)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 vaddr_in_file_;
  ::PROTOBUF_NAMESPACE_ID::uint32 file_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 symbol_id_;
  int execution_type_;
  friend struct ::TableStruct_system_2fextras_2fsimpleperf_2fcmd_5freport_5fsample_2eproto;
};
// -------------------------------------------------------------------

class Sample_UnwindingResult :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:simpleperf_report_proto.Sample.UnwindingResult) */ {
 public:
  Sample_UnwindingResult();
  virtual ~Sample_UnwindingResult();

  Sample_UnwindingResult(const Sample_UnwindingResult& from);
  Sample_UnwindingResult(Sample_UnwindingResult&& from) noexcept
    : Sample_UnwindingResult() {
    *this = ::std::move(from);
  }

  inline Sample_UnwindingResult& operator=(const Sample_UnwindingResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sample_UnwindingResult& operator=(Sample_UnwindingResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Sample_UnwindingResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sample_UnwindingResult* internal_default_instance() {
    return reinterpret_cast<const Sample_UnwindingResult*>(
               &_Sample_UnwindingResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Sample_UnwindingResult& a, Sample_UnwindingResult& b) {
    a.Swap(&b);
  }
  inline void Swap(Sample_UnwindingResult* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Sample_UnwindingResult* New() const final {
    return CreateMaybeMessage<Sample_UnwindingResult>(nullptr);
  }

  Sample_UnwindingResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Sample_UnwindingResult>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Sample_UnwindingResult& from);
  void MergeFrom(const Sample_UnwindingResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Sample_UnwindingResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "simpleperf_report_proto.Sample.UnwindingResult";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Sample_UnwindingResult_ErrorCode ErrorCode;
  static constexpr ErrorCode ERROR_NONE =
    Sample_UnwindingResult_ErrorCode_ERROR_NONE;
  static constexpr ErrorCode ERROR_UNKNOWN =
    Sample_UnwindingResult_ErrorCode_ERROR_UNKNOWN;
  static constexpr ErrorCode ERROR_NOT_ENOUGH_STACK =
    Sample_UnwindingResult_ErrorCode_ERROR_NOT_ENOUGH_STACK;
  static constexpr ErrorCode ERROR_MEMORY_INVALID =
    Sample_UnwindingResult_ErrorCode_ERROR_MEMORY_INVALID;
  static constexpr ErrorCode ERROR_UNWIND_INFO =
    Sample_UnwindingResult_ErrorCode_ERROR_UNWIND_INFO;
  static constexpr ErrorCode ERROR_INVALID_MAP =
    Sample_UnwindingResult_ErrorCode_ERROR_INVALID_MAP;
  static constexpr ErrorCode ERROR_MAX_FRAME_EXCEEDED =
    Sample_UnwindingResult_ErrorCode_ERROR_MAX_FRAME_EXCEEDED;
  static constexpr ErrorCode ERROR_REPEATED_FRAME =
    Sample_UnwindingResult_ErrorCode_ERROR_REPEATED_FRAME;
  static constexpr ErrorCode ERROR_INVALID_ELF =
    Sample_UnwindingResult_ErrorCode_ERROR_INVALID_ELF;
  static inline bool ErrorCode_IsValid(int value) {
    return Sample_UnwindingResult_ErrorCode_IsValid(value);
  }
  static constexpr ErrorCode ErrorCode_MIN =
    Sample_UnwindingResult_ErrorCode_ErrorCode_MIN;
  static constexpr ErrorCode ErrorCode_MAX =
    Sample_UnwindingResult_ErrorCode_ErrorCode_MAX;
  static constexpr int ErrorCode_ARRAYSIZE =
    Sample_UnwindingResult_ErrorCode_ErrorCode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ErrorCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ErrorCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ErrorCode_Name.");
    return Sample_UnwindingResult_ErrorCode_Name(enum_t_value);
  }
  static inline bool ErrorCode_Parse(const std::string& name,
      ErrorCode* value) {
    return Sample_UnwindingResult_ErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kErrorAddrFieldNumber = 2,
    kRawErrorCodeFieldNumber = 1,
    kErrorCodeFieldNumber = 3,
  };
  // optional uint64 error_addr = 2;
  bool has_error_addr() const;
  void clear_error_addr();
  ::PROTOBUF_NAMESPACE_ID::uint64 error_addr() const;
  void set_error_addr(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint32 raw_error_code = 1;
  bool has_raw_error_code() const;
  void clear_raw_error_code();
  ::PROTOBUF_NAMESPACE_ID::uint32 raw_error_code() const;
  void set_raw_error_code(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional .simpleperf_report_proto.Sample.UnwindingResult.ErrorCode error_code = 3;
  bool has_error_code() const;
  void clear_error_code();
  ::simpleperf_report_proto::Sample_UnwindingResult_ErrorCode error_code() const;
  void set_error_code(::simpleperf_report_proto::Sample_UnwindingResult_ErrorCode value);

  // @@protoc_insertion_point(class_scope:simpleperf_report_proto.Sample.UnwindingResult)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 error_addr_;
  ::PROTOBUF_NAMESPACE_ID::uint32 raw_error_code_;
  int error_code_;
  friend struct ::TableStruct_system_2fextras_2fsimpleperf_2fcmd_5freport_5fsample_2eproto;
};
// -------------------------------------------------------------------

class Sample :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:simpleperf_report_proto.Sample) */ {
 public:
  Sample();
  virtual ~Sample();

  Sample(const Sample& from);
  Sample(Sample&& from) noexcept
    : Sample() {
    *this = ::std::move(from);
  }

  inline Sample& operator=(const Sample& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sample& operator=(Sample&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Sample& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sample* internal_default_instance() {
    return reinterpret_cast<const Sample*>(
               &_Sample_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Sample& a, Sample& b) {
    a.Swap(&b);
  }
  inline void Swap(Sample* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Sample* New() const final {
    return CreateMaybeMessage<Sample>(nullptr);
  }

  Sample* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Sample>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Sample& from);
  void MergeFrom(const Sample& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Sample* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "simpleperf_report_proto.Sample";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Sample_CallChainEntry CallChainEntry;
  typedef Sample_UnwindingResult UnwindingResult;

  // accessors -------------------------------------------------------

  enum : int {
    kCallchainFieldNumber = 3,
    kUnwindingResultFieldNumber = 6,
    kTimeFieldNumber = 1,
    kThreadIdFieldNumber = 2,
    kEventTypeIdFieldNumber = 5,
    kEventCountFieldNumber = 4,
  };
  // repeated .simpleperf_report_proto.Sample.CallChainEntry callchain = 3;
  int callchain_size() const;
  void clear_callchain();
  ::simpleperf_report_proto::Sample_CallChainEntry* mutable_callchain(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::simpleperf_report_proto::Sample_CallChainEntry >*
      mutable_callchain();
  const ::simpleperf_report_proto::Sample_CallChainEntry& callchain(int index) const;
  ::simpleperf_report_proto::Sample_CallChainEntry* add_callchain();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::simpleperf_report_proto::Sample_CallChainEntry >&
      callchain() const;

  // optional .simpleperf_report_proto.Sample.UnwindingResult unwinding_result = 6;
  bool has_unwinding_result() const;
  void clear_unwinding_result();
  const ::simpleperf_report_proto::Sample_UnwindingResult& unwinding_result() const;
  ::simpleperf_report_proto::Sample_UnwindingResult* release_unwinding_result();
  ::simpleperf_report_proto::Sample_UnwindingResult* mutable_unwinding_result();
  void set_allocated_unwinding_result(::simpleperf_report_proto::Sample_UnwindingResult* unwinding_result);

  // optional uint64 time = 1;
  bool has_time() const;
  void clear_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 time() const;
  void set_time(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional int32 thread_id = 2;
  bool has_thread_id() const;
  void clear_thread_id();
  ::PROTOBUF_NAMESPACE_ID::int32 thread_id() const;
  void set_thread_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional uint32 event_type_id = 5;
  bool has_event_type_id() const;
  void clear_event_type_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 event_type_id() const;
  void set_event_type_id(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint64 event_count = 4;
  bool has_event_count() const;
  void clear_event_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 event_count() const;
  void set_event_count(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:simpleperf_report_proto.Sample)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::simpleperf_report_proto::Sample_CallChainEntry > callchain_;
  ::simpleperf_report_proto::Sample_UnwindingResult* unwinding_result_;
  ::PROTOBUF_NAMESPACE_ID::uint64 time_;
  ::PROTOBUF_NAMESPACE_ID::int32 thread_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 event_type_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 event_count_;
  friend struct ::TableStruct_system_2fextras_2fsimpleperf_2fcmd_5freport_5fsample_2eproto;
};
// -------------------------------------------------------------------

class LostSituation :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:simpleperf_report_proto.LostSituation) */ {
 public:
  LostSituation();
  virtual ~LostSituation();

  LostSituation(const LostSituation& from);
  LostSituation(LostSituation&& from) noexcept
    : LostSituation() {
    *this = ::std::move(from);
  }

  inline LostSituation& operator=(const LostSituation& from) {
    CopyFrom(from);
    return *this;
  }
  inline LostSituation& operator=(LostSituation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const LostSituation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LostSituation* internal_default_instance() {
    return reinterpret_cast<const LostSituation*>(
               &_LostSituation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LostSituation& a, LostSituation& b) {
    a.Swap(&b);
  }
  inline void Swap(LostSituation* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LostSituation* New() const final {
    return CreateMaybeMessage<LostSituation>(nullptr);
  }

  LostSituation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LostSituation>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const LostSituation& from);
  void MergeFrom(const LostSituation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LostSituation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "simpleperf_report_proto.LostSituation";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSampleCountFieldNumber = 1,
    kLostCountFieldNumber = 2,
  };
  // optional uint64 sample_count = 1;
  bool has_sample_count() const;
  void clear_sample_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 sample_count() const;
  void set_sample_count(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 lost_count = 2;
  bool has_lost_count() const;
  void clear_lost_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 lost_count() const;
  void set_lost_count(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:simpleperf_report_proto.LostSituation)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 sample_count_;
  ::PROTOBUF_NAMESPACE_ID::uint64 lost_count_;
  friend struct ::TableStruct_system_2fextras_2fsimpleperf_2fcmd_5freport_5fsample_2eproto;
};
// -------------------------------------------------------------------

class File :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:simpleperf_report_proto.File) */ {
 public:
  File();
  virtual ~File();

  File(const File& from);
  File(File&& from) noexcept
    : File() {
    *this = ::std::move(from);
  }

  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }
  inline File& operator=(File&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const File& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const File* internal_default_instance() {
    return reinterpret_cast<const File*>(
               &_File_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(File& a, File& b) {
    a.Swap(&b);
  }
  inline void Swap(File* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline File* New() const final {
    return CreateMaybeMessage<File>(nullptr);
  }

  File* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<File>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const File& from);
  void MergeFrom(const File& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(File* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "simpleperf_report_proto.File";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSymbolFieldNumber = 3,
    kMangledSymbolFieldNumber = 4,
    kPathFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated string symbol = 3;
  int symbol_size() const;
  void clear_symbol();
  const std::string& symbol(int index) const;
  std::string* mutable_symbol(int index);
  void set_symbol(int index, const std::string& value);
  void set_symbol(int index, std::string&& value);
  void set_symbol(int index, const char* value);
  void set_symbol(int index, const char* value, size_t size);
  std::string* add_symbol();
  void add_symbol(const std::string& value);
  void add_symbol(std::string&& value);
  void add_symbol(const char* value);
  void add_symbol(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& symbol() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_symbol();

  // repeated string mangled_symbol = 4;
  int mangled_symbol_size() const;
  void clear_mangled_symbol();
  const std::string& mangled_symbol(int index) const;
  std::string* mutable_mangled_symbol(int index);
  void set_mangled_symbol(int index, const std::string& value);
  void set_mangled_symbol(int index, std::string&& value);
  void set_mangled_symbol(int index, const char* value);
  void set_mangled_symbol(int index, const char* value, size_t size);
  std::string* add_mangled_symbol();
  void add_mangled_symbol(const std::string& value);
  void add_mangled_symbol(std::string&& value);
  void add_mangled_symbol(const char* value);
  void add_mangled_symbol(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& mangled_symbol() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_mangled_symbol();

  // optional string path = 2;
  bool has_path() const;
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);

  // optional uint32 id = 1;
  bool has_id() const;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:simpleperf_report_proto.File)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> symbol_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> mangled_symbol_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  friend struct ::TableStruct_system_2fextras_2fsimpleperf_2fcmd_5freport_5fsample_2eproto;
};
// -------------------------------------------------------------------

class Thread :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:simpleperf_report_proto.Thread) */ {
 public:
  Thread();
  virtual ~Thread();

  Thread(const Thread& from);
  Thread(Thread&& from) noexcept
    : Thread() {
    *this = ::std::move(from);
  }

  inline Thread& operator=(const Thread& from) {
    CopyFrom(from);
    return *this;
  }
  inline Thread& operator=(Thread&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Thread& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Thread* internal_default_instance() {
    return reinterpret_cast<const Thread*>(
               &_Thread_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Thread& a, Thread& b) {
    a.Swap(&b);
  }
  inline void Swap(Thread* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Thread* New() const final {
    return CreateMaybeMessage<Thread>(nullptr);
  }

  Thread* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Thread>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Thread& from);
  void MergeFrom(const Thread& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Thread* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "simpleperf_report_proto.Thread";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThreadNameFieldNumber = 3,
    kThreadIdFieldNumber = 1,
    kProcessIdFieldNumber = 2,
  };
  // optional string thread_name = 3;
  bool has_thread_name() const;
  void clear_thread_name();
  const std::string& thread_name() const;
  void set_thread_name(const std::string& value);
  void set_thread_name(std::string&& value);
  void set_thread_name(const char* value);
  void set_thread_name(const char* value, size_t size);
  std::string* mutable_thread_name();
  std::string* release_thread_name();
  void set_allocated_thread_name(std::string* thread_name);

  // optional uint32 thread_id = 1;
  bool has_thread_id() const;
  void clear_thread_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 thread_id() const;
  void set_thread_id(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 process_id = 2;
  bool has_process_id() const;
  void clear_process_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 process_id() const;
  void set_process_id(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:simpleperf_report_proto.Thread)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thread_name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 thread_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 process_id_;
  friend struct ::TableStruct_system_2fextras_2fsimpleperf_2fcmd_5freport_5fsample_2eproto;
};
// -------------------------------------------------------------------

class MetaInfo :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:simpleperf_report_proto.MetaInfo) */ {
 public:
  MetaInfo();
  virtual ~MetaInfo();

  MetaInfo(const MetaInfo& from);
  MetaInfo(MetaInfo&& from) noexcept
    : MetaInfo() {
    *this = ::std::move(from);
  }

  inline MetaInfo& operator=(const MetaInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetaInfo& operator=(MetaInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MetaInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MetaInfo* internal_default_instance() {
    return reinterpret_cast<const MetaInfo*>(
               &_MetaInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MetaInfo& a, MetaInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MetaInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MetaInfo* New() const final {
    return CreateMaybeMessage<MetaInfo>(nullptr);
  }

  MetaInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MetaInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MetaInfo& from);
  void MergeFrom(const MetaInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MetaInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "simpleperf_report_proto.MetaInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventTypeFieldNumber = 1,
    kAppPackageNameFieldNumber = 2,
  };
  // repeated string event_type = 1;
  int event_type_size() const;
  void clear_event_type();
  const std::string& event_type(int index) const;
  std::string* mutable_event_type(int index);
  void set_event_type(int index, const std::string& value);
  void set_event_type(int index, std::string&& value);
  void set_event_type(int index, const char* value);
  void set_event_type(int index, const char* value, size_t size);
  std::string* add_event_type();
  void add_event_type(const std::string& value);
  void add_event_type(std::string&& value);
  void add_event_type(const char* value);
  void add_event_type(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& event_type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_event_type();

  // optional string app_package_name = 2;
  bool has_app_package_name() const;
  void clear_app_package_name();
  const std::string& app_package_name() const;
  void set_app_package_name(const std::string& value);
  void set_app_package_name(std::string&& value);
  void set_app_package_name(const char* value);
  void set_app_package_name(const char* value, size_t size);
  std::string* mutable_app_package_name();
  std::string* release_app_package_name();
  void set_allocated_app_package_name(std::string* app_package_name);

  // @@protoc_insertion_point(class_scope:simpleperf_report_proto.MetaInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> event_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_package_name_;
  friend struct ::TableStruct_system_2fextras_2fsimpleperf_2fcmd_5freport_5fsample_2eproto;
};
// -------------------------------------------------------------------

class Record :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:simpleperf_report_proto.Record) */ {
 public:
  Record();
  virtual ~Record();

  Record(const Record& from);
  Record(Record&& from) noexcept
    : Record() {
    *this = ::std::move(from);
  }

  inline Record& operator=(const Record& from) {
    CopyFrom(from);
    return *this;
  }
  inline Record& operator=(Record&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Record& default_instance();

  enum RecordDataCase {
    kSample = 1,
    kLost = 2,
    kFile = 3,
    kThread = 4,
    kMetaInfo = 5,
    RECORD_DATA_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Record* internal_default_instance() {
    return reinterpret_cast<const Record*>(
               &_Record_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Record& a, Record& b) {
    a.Swap(&b);
  }
  inline void Swap(Record* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Record* New() const final {
    return CreateMaybeMessage<Record>(nullptr);
  }

  Record* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Record>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Record& from);
  void MergeFrom(const Record& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Record* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "simpleperf_report_proto.Record";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSampleFieldNumber = 1,
    kLostFieldNumber = 2,
    kFileFieldNumber = 3,
    kThreadFieldNumber = 4,
    kMetaInfoFieldNumber = 5,
  };
  // optional .simpleperf_report_proto.Sample sample = 1;
  bool has_sample() const;
  void clear_sample();
  const ::simpleperf_report_proto::Sample& sample() const;
  ::simpleperf_report_proto::Sample* release_sample();
  ::simpleperf_report_proto::Sample* mutable_sample();
  void set_allocated_sample(::simpleperf_report_proto::Sample* sample);

  // optional .simpleperf_report_proto.LostSituation lost = 2;
  bool has_lost() const;
  void clear_lost();
  const ::simpleperf_report_proto::LostSituation& lost() const;
  ::simpleperf_report_proto::LostSituation* release_lost();
  ::simpleperf_report_proto::LostSituation* mutable_lost();
  void set_allocated_lost(::simpleperf_report_proto::LostSituation* lost);

  // optional .simpleperf_report_proto.File file = 3;
  bool has_file() const;
  void clear_file();
  const ::simpleperf_report_proto::File& file() const;
  ::simpleperf_report_proto::File* release_file();
  ::simpleperf_report_proto::File* mutable_file();
  void set_allocated_file(::simpleperf_report_proto::File* file);

  // optional .simpleperf_report_proto.Thread thread = 4;
  bool has_thread() const;
  void clear_thread();
  const ::simpleperf_report_proto::Thread& thread() const;
  ::simpleperf_report_proto::Thread* release_thread();
  ::simpleperf_report_proto::Thread* mutable_thread();
  void set_allocated_thread(::simpleperf_report_proto::Thread* thread);

  // optional .simpleperf_report_proto.MetaInfo meta_info = 5;
  bool has_meta_info() const;
  void clear_meta_info();
  const ::simpleperf_report_proto::MetaInfo& meta_info() const;
  ::simpleperf_report_proto::MetaInfo* release_meta_info();
  ::simpleperf_report_proto::MetaInfo* mutable_meta_info();
  void set_allocated_meta_info(::simpleperf_report_proto::MetaInfo* meta_info);

  void clear_record_data();
  RecordDataCase record_data_case() const;
  // @@protoc_insertion_point(class_scope:simpleperf_report_proto.Record)
 private:
  class _Internal;
  void set_has_sample();
  void set_has_lost();
  void set_has_file();
  void set_has_thread();
  void set_has_meta_info();

  inline bool has_record_data() const;
  inline void clear_has_record_data();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  union RecordDataUnion {
    RecordDataUnion() {}
    ::simpleperf_report_proto::Sample* sample_;
    ::simpleperf_report_proto::LostSituation* lost_;
    ::simpleperf_report_proto::File* file_;
    ::simpleperf_report_proto::Thread* thread_;
    ::simpleperf_report_proto::MetaInfo* meta_info_;
  } record_data_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_system_2fextras_2fsimpleperf_2fcmd_5freport_5fsample_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Sample_CallChainEntry

// optional uint64 vaddr_in_file = 1;
inline bool Sample_CallChainEntry::has_vaddr_in_file() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Sample_CallChainEntry::clear_vaddr_in_file() {
  vaddr_in_file_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Sample_CallChainEntry::vaddr_in_file() const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.Sample.CallChainEntry.vaddr_in_file)
  return vaddr_in_file_;
}
inline void Sample_CallChainEntry::set_vaddr_in_file(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  vaddr_in_file_ = value;
  // @@protoc_insertion_point(field_set:simpleperf_report_proto.Sample.CallChainEntry.vaddr_in_file)
}

// optional uint32 file_id = 2;
inline bool Sample_CallChainEntry::has_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Sample_CallChainEntry::clear_file_id() {
  file_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Sample_CallChainEntry::file_id() const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.Sample.CallChainEntry.file_id)
  return file_id_;
}
inline void Sample_CallChainEntry::set_file_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  file_id_ = value;
  // @@protoc_insertion_point(field_set:simpleperf_report_proto.Sample.CallChainEntry.file_id)
}

// optional int32 symbol_id = 3;
inline bool Sample_CallChainEntry::has_symbol_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Sample_CallChainEntry::clear_symbol_id() {
  symbol_id_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Sample_CallChainEntry::symbol_id() const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.Sample.CallChainEntry.symbol_id)
  return symbol_id_;
}
inline void Sample_CallChainEntry::set_symbol_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  symbol_id_ = value;
  // @@protoc_insertion_point(field_set:simpleperf_report_proto.Sample.CallChainEntry.symbol_id)
}

// optional .simpleperf_report_proto.Sample.CallChainEntry.ExecutionType execution_type = 4 [default = NATIVE_METHOD];
inline bool Sample_CallChainEntry::has_execution_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Sample_CallChainEntry::clear_execution_type() {
  execution_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::simpleperf_report_proto::Sample_CallChainEntry_ExecutionType Sample_CallChainEntry::execution_type() const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.Sample.CallChainEntry.execution_type)
  return static_cast< ::simpleperf_report_proto::Sample_CallChainEntry_ExecutionType >(execution_type_);
}
inline void Sample_CallChainEntry::set_execution_type(::simpleperf_report_proto::Sample_CallChainEntry_ExecutionType value) {
  assert(::simpleperf_report_proto::Sample_CallChainEntry_ExecutionType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  execution_type_ = value;
  // @@protoc_insertion_point(field_set:simpleperf_report_proto.Sample.CallChainEntry.execution_type)
}

// -------------------------------------------------------------------

// Sample_UnwindingResult

// optional uint32 raw_error_code = 1;
inline bool Sample_UnwindingResult::has_raw_error_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Sample_UnwindingResult::clear_raw_error_code() {
  raw_error_code_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Sample_UnwindingResult::raw_error_code() const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.Sample.UnwindingResult.raw_error_code)
  return raw_error_code_;
}
inline void Sample_UnwindingResult::set_raw_error_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  raw_error_code_ = value;
  // @@protoc_insertion_point(field_set:simpleperf_report_proto.Sample.UnwindingResult.raw_error_code)
}

// optional uint64 error_addr = 2;
inline bool Sample_UnwindingResult::has_error_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Sample_UnwindingResult::clear_error_addr() {
  error_addr_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Sample_UnwindingResult::error_addr() const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.Sample.UnwindingResult.error_addr)
  return error_addr_;
}
inline void Sample_UnwindingResult::set_error_addr(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  error_addr_ = value;
  // @@protoc_insertion_point(field_set:simpleperf_report_proto.Sample.UnwindingResult.error_addr)
}

// optional .simpleperf_report_proto.Sample.UnwindingResult.ErrorCode error_code = 3;
inline bool Sample_UnwindingResult::has_error_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Sample_UnwindingResult::clear_error_code() {
  error_code_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::simpleperf_report_proto::Sample_UnwindingResult_ErrorCode Sample_UnwindingResult::error_code() const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.Sample.UnwindingResult.error_code)
  return static_cast< ::simpleperf_report_proto::Sample_UnwindingResult_ErrorCode >(error_code_);
}
inline void Sample_UnwindingResult::set_error_code(::simpleperf_report_proto::Sample_UnwindingResult_ErrorCode value) {
  assert(::simpleperf_report_proto::Sample_UnwindingResult_ErrorCode_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  error_code_ = value;
  // @@protoc_insertion_point(field_set:simpleperf_report_proto.Sample.UnwindingResult.error_code)
}

// -------------------------------------------------------------------

// Sample

// optional uint64 time = 1;
inline bool Sample::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Sample::clear_time() {
  time_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Sample::time() const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.Sample.time)
  return time_;
}
inline void Sample::set_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  time_ = value;
  // @@protoc_insertion_point(field_set:simpleperf_report_proto.Sample.time)
}

// optional int32 thread_id = 2;
inline bool Sample::has_thread_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Sample::clear_thread_id() {
  thread_id_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Sample::thread_id() const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.Sample.thread_id)
  return thread_id_;
}
inline void Sample::set_thread_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  thread_id_ = value;
  // @@protoc_insertion_point(field_set:simpleperf_report_proto.Sample.thread_id)
}

// repeated .simpleperf_report_proto.Sample.CallChainEntry callchain = 3;
inline int Sample::callchain_size() const {
  return callchain_.size();
}
inline void Sample::clear_callchain() {
  callchain_.Clear();
}
inline ::simpleperf_report_proto::Sample_CallChainEntry* Sample::mutable_callchain(int index) {
  // @@protoc_insertion_point(field_mutable:simpleperf_report_proto.Sample.callchain)
  return callchain_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::simpleperf_report_proto::Sample_CallChainEntry >*
Sample::mutable_callchain() {
  // @@protoc_insertion_point(field_mutable_list:simpleperf_report_proto.Sample.callchain)
  return &callchain_;
}
inline const ::simpleperf_report_proto::Sample_CallChainEntry& Sample::callchain(int index) const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.Sample.callchain)
  return callchain_.Get(index);
}
inline ::simpleperf_report_proto::Sample_CallChainEntry* Sample::add_callchain() {
  // @@protoc_insertion_point(field_add:simpleperf_report_proto.Sample.callchain)
  return callchain_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::simpleperf_report_proto::Sample_CallChainEntry >&
Sample::callchain() const {
  // @@protoc_insertion_point(field_list:simpleperf_report_proto.Sample.callchain)
  return callchain_;
}

// optional uint64 event_count = 4;
inline bool Sample::has_event_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Sample::clear_event_count() {
  event_count_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Sample::event_count() const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.Sample.event_count)
  return event_count_;
}
inline void Sample::set_event_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  event_count_ = value;
  // @@protoc_insertion_point(field_set:simpleperf_report_proto.Sample.event_count)
}

// optional uint32 event_type_id = 5;
inline bool Sample::has_event_type_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Sample::clear_event_type_id() {
  event_type_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Sample::event_type_id() const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.Sample.event_type_id)
  return event_type_id_;
}
inline void Sample::set_event_type_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  event_type_id_ = value;
  // @@protoc_insertion_point(field_set:simpleperf_report_proto.Sample.event_type_id)
}

// optional .simpleperf_report_proto.Sample.UnwindingResult unwinding_result = 6;
inline bool Sample::has_unwinding_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Sample::clear_unwinding_result() {
  if (unwinding_result_ != nullptr) unwinding_result_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::simpleperf_report_proto::Sample_UnwindingResult& Sample::unwinding_result() const {
  const ::simpleperf_report_proto::Sample_UnwindingResult* p = unwinding_result_;
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.Sample.unwinding_result)
  return p != nullptr ? *p : *reinterpret_cast<const ::simpleperf_report_proto::Sample_UnwindingResult*>(
      &::simpleperf_report_proto::_Sample_UnwindingResult_default_instance_);
}
inline ::simpleperf_report_proto::Sample_UnwindingResult* Sample::release_unwinding_result() {
  // @@protoc_insertion_point(field_release:simpleperf_report_proto.Sample.unwinding_result)
  _has_bits_[0] &= ~0x00000001u;
  ::simpleperf_report_proto::Sample_UnwindingResult* temp = unwinding_result_;
  unwinding_result_ = nullptr;
  return temp;
}
inline ::simpleperf_report_proto::Sample_UnwindingResult* Sample::mutable_unwinding_result() {
  _has_bits_[0] |= 0x00000001u;
  if (unwinding_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::simpleperf_report_proto::Sample_UnwindingResult>(GetArenaNoVirtual());
    unwinding_result_ = p;
  }
  // @@protoc_insertion_point(field_mutable:simpleperf_report_proto.Sample.unwinding_result)
  return unwinding_result_;
}
inline void Sample::set_allocated_unwinding_result(::simpleperf_report_proto::Sample_UnwindingResult* unwinding_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete unwinding_result_;
  }
  if (unwinding_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      unwinding_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unwinding_result, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  unwinding_result_ = unwinding_result;
  // @@protoc_insertion_point(field_set_allocated:simpleperf_report_proto.Sample.unwinding_result)
}

// -------------------------------------------------------------------

// LostSituation

// optional uint64 sample_count = 1;
inline bool LostSituation::has_sample_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LostSituation::clear_sample_count() {
  sample_count_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 LostSituation::sample_count() const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.LostSituation.sample_count)
  return sample_count_;
}
inline void LostSituation::set_sample_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  sample_count_ = value;
  // @@protoc_insertion_point(field_set:simpleperf_report_proto.LostSituation.sample_count)
}

// optional uint64 lost_count = 2;
inline bool LostSituation::has_lost_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LostSituation::clear_lost_count() {
  lost_count_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 LostSituation::lost_count() const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.LostSituation.lost_count)
  return lost_count_;
}
inline void LostSituation::set_lost_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  lost_count_ = value;
  // @@protoc_insertion_point(field_set:simpleperf_report_proto.LostSituation.lost_count)
}

// -------------------------------------------------------------------

// File

// optional uint32 id = 1;
inline bool File::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void File::clear_id() {
  id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 File::id() const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.File.id)
  return id_;
}
inline void File::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  id_ = value;
  // @@protoc_insertion_point(field_set:simpleperf_report_proto.File.id)
}

// optional string path = 2;
inline bool File::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void File::clear_path() {
  path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& File::path() const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.File.path)
  return path_.GetNoArena();
}
inline void File::set_path(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:simpleperf_report_proto.File.path)
}
inline void File::set_path(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:simpleperf_report_proto.File.path)
}
inline void File::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:simpleperf_report_proto.File.path)
}
inline void File::set_path(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:simpleperf_report_proto.File.path)
}
inline std::string* File::mutable_path() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:simpleperf_report_proto.File.path)
  return path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* File::release_path() {
  // @@protoc_insertion_point(field_release:simpleperf_report_proto.File.path)
  if (!has_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return path_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:simpleperf_report_proto.File.path)
}

// repeated string symbol = 3;
inline int File::symbol_size() const {
  return symbol_.size();
}
inline void File::clear_symbol() {
  symbol_.Clear();
}
inline const std::string& File::symbol(int index) const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.File.symbol)
  return symbol_.Get(index);
}
inline std::string* File::mutable_symbol(int index) {
  // @@protoc_insertion_point(field_mutable:simpleperf_report_proto.File.symbol)
  return symbol_.Mutable(index);
}
inline void File::set_symbol(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:simpleperf_report_proto.File.symbol)
  symbol_.Mutable(index)->assign(value);
}
inline void File::set_symbol(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:simpleperf_report_proto.File.symbol)
  symbol_.Mutable(index)->assign(std::move(value));
}
inline void File::set_symbol(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  symbol_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:simpleperf_report_proto.File.symbol)
}
inline void File::set_symbol(int index, const char* value, size_t size) {
  symbol_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:simpleperf_report_proto.File.symbol)
}
inline std::string* File::add_symbol() {
  // @@protoc_insertion_point(field_add_mutable:simpleperf_report_proto.File.symbol)
  return symbol_.Add();
}
inline void File::add_symbol(const std::string& value) {
  symbol_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:simpleperf_report_proto.File.symbol)
}
inline void File::add_symbol(std::string&& value) {
  symbol_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:simpleperf_report_proto.File.symbol)
}
inline void File::add_symbol(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  symbol_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:simpleperf_report_proto.File.symbol)
}
inline void File::add_symbol(const char* value, size_t size) {
  symbol_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:simpleperf_report_proto.File.symbol)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
File::symbol() const {
  // @@protoc_insertion_point(field_list:simpleperf_report_proto.File.symbol)
  return symbol_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
File::mutable_symbol() {
  // @@protoc_insertion_point(field_mutable_list:simpleperf_report_proto.File.symbol)
  return &symbol_;
}

// repeated string mangled_symbol = 4;
inline int File::mangled_symbol_size() const {
  return mangled_symbol_.size();
}
inline void File::clear_mangled_symbol() {
  mangled_symbol_.Clear();
}
inline const std::string& File::mangled_symbol(int index) const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.File.mangled_symbol)
  return mangled_symbol_.Get(index);
}
inline std::string* File::mutable_mangled_symbol(int index) {
  // @@protoc_insertion_point(field_mutable:simpleperf_report_proto.File.mangled_symbol)
  return mangled_symbol_.Mutable(index);
}
inline void File::set_mangled_symbol(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:simpleperf_report_proto.File.mangled_symbol)
  mangled_symbol_.Mutable(index)->assign(value);
}
inline void File::set_mangled_symbol(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:simpleperf_report_proto.File.mangled_symbol)
  mangled_symbol_.Mutable(index)->assign(std::move(value));
}
inline void File::set_mangled_symbol(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  mangled_symbol_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:simpleperf_report_proto.File.mangled_symbol)
}
inline void File::set_mangled_symbol(int index, const char* value, size_t size) {
  mangled_symbol_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:simpleperf_report_proto.File.mangled_symbol)
}
inline std::string* File::add_mangled_symbol() {
  // @@protoc_insertion_point(field_add_mutable:simpleperf_report_proto.File.mangled_symbol)
  return mangled_symbol_.Add();
}
inline void File::add_mangled_symbol(const std::string& value) {
  mangled_symbol_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:simpleperf_report_proto.File.mangled_symbol)
}
inline void File::add_mangled_symbol(std::string&& value) {
  mangled_symbol_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:simpleperf_report_proto.File.mangled_symbol)
}
inline void File::add_mangled_symbol(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  mangled_symbol_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:simpleperf_report_proto.File.mangled_symbol)
}
inline void File::add_mangled_symbol(const char* value, size_t size) {
  mangled_symbol_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:simpleperf_report_proto.File.mangled_symbol)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
File::mangled_symbol() const {
  // @@protoc_insertion_point(field_list:simpleperf_report_proto.File.mangled_symbol)
  return mangled_symbol_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
File::mutable_mangled_symbol() {
  // @@protoc_insertion_point(field_mutable_list:simpleperf_report_proto.File.mangled_symbol)
  return &mangled_symbol_;
}

// -------------------------------------------------------------------

// Thread

// optional uint32 thread_id = 1;
inline bool Thread::has_thread_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Thread::clear_thread_id() {
  thread_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Thread::thread_id() const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.Thread.thread_id)
  return thread_id_;
}
inline void Thread::set_thread_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  thread_id_ = value;
  // @@protoc_insertion_point(field_set:simpleperf_report_proto.Thread.thread_id)
}

// optional uint32 process_id = 2;
inline bool Thread::has_process_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Thread::clear_process_id() {
  process_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Thread::process_id() const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.Thread.process_id)
  return process_id_;
}
inline void Thread::set_process_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  process_id_ = value;
  // @@protoc_insertion_point(field_set:simpleperf_report_proto.Thread.process_id)
}

// optional string thread_name = 3;
inline bool Thread::has_thread_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Thread::clear_thread_name() {
  thread_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Thread::thread_name() const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.Thread.thread_name)
  return thread_name_.GetNoArena();
}
inline void Thread::set_thread_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  thread_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:simpleperf_report_proto.Thread.thread_name)
}
inline void Thread::set_thread_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  thread_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:simpleperf_report_proto.Thread.thread_name)
}
inline void Thread::set_thread_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  thread_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:simpleperf_report_proto.Thread.thread_name)
}
inline void Thread::set_thread_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  thread_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:simpleperf_report_proto.Thread.thread_name)
}
inline std::string* Thread::mutable_thread_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:simpleperf_report_proto.Thread.thread_name)
  return thread_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Thread::release_thread_name() {
  // @@protoc_insertion_point(field_release:simpleperf_report_proto.Thread.thread_name)
  if (!has_thread_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return thread_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Thread::set_allocated_thread_name(std::string* thread_name) {
  if (thread_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  thread_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), thread_name);
  // @@protoc_insertion_point(field_set_allocated:simpleperf_report_proto.Thread.thread_name)
}

// -------------------------------------------------------------------

// MetaInfo

// repeated string event_type = 1;
inline int MetaInfo::event_type_size() const {
  return event_type_.size();
}
inline void MetaInfo::clear_event_type() {
  event_type_.Clear();
}
inline const std::string& MetaInfo::event_type(int index) const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.MetaInfo.event_type)
  return event_type_.Get(index);
}
inline std::string* MetaInfo::mutable_event_type(int index) {
  // @@protoc_insertion_point(field_mutable:simpleperf_report_proto.MetaInfo.event_type)
  return event_type_.Mutable(index);
}
inline void MetaInfo::set_event_type(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:simpleperf_report_proto.MetaInfo.event_type)
  event_type_.Mutable(index)->assign(value);
}
inline void MetaInfo::set_event_type(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:simpleperf_report_proto.MetaInfo.event_type)
  event_type_.Mutable(index)->assign(std::move(value));
}
inline void MetaInfo::set_event_type(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  event_type_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:simpleperf_report_proto.MetaInfo.event_type)
}
inline void MetaInfo::set_event_type(int index, const char* value, size_t size) {
  event_type_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:simpleperf_report_proto.MetaInfo.event_type)
}
inline std::string* MetaInfo::add_event_type() {
  // @@protoc_insertion_point(field_add_mutable:simpleperf_report_proto.MetaInfo.event_type)
  return event_type_.Add();
}
inline void MetaInfo::add_event_type(const std::string& value) {
  event_type_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:simpleperf_report_proto.MetaInfo.event_type)
}
inline void MetaInfo::add_event_type(std::string&& value) {
  event_type_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:simpleperf_report_proto.MetaInfo.event_type)
}
inline void MetaInfo::add_event_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  event_type_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:simpleperf_report_proto.MetaInfo.event_type)
}
inline void MetaInfo::add_event_type(const char* value, size_t size) {
  event_type_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:simpleperf_report_proto.MetaInfo.event_type)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MetaInfo::event_type() const {
  // @@protoc_insertion_point(field_list:simpleperf_report_proto.MetaInfo.event_type)
  return event_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MetaInfo::mutable_event_type() {
  // @@protoc_insertion_point(field_mutable_list:simpleperf_report_proto.MetaInfo.event_type)
  return &event_type_;
}

// optional string app_package_name = 2;
inline bool MetaInfo::has_app_package_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MetaInfo::clear_app_package_name() {
  app_package_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MetaInfo::app_package_name() const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.MetaInfo.app_package_name)
  return app_package_name_.GetNoArena();
}
inline void MetaInfo::set_app_package_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  app_package_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:simpleperf_report_proto.MetaInfo.app_package_name)
}
inline void MetaInfo::set_app_package_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  app_package_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:simpleperf_report_proto.MetaInfo.app_package_name)
}
inline void MetaInfo::set_app_package_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  app_package_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:simpleperf_report_proto.MetaInfo.app_package_name)
}
inline void MetaInfo::set_app_package_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  app_package_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:simpleperf_report_proto.MetaInfo.app_package_name)
}
inline std::string* MetaInfo::mutable_app_package_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:simpleperf_report_proto.MetaInfo.app_package_name)
  return app_package_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MetaInfo::release_app_package_name() {
  // @@protoc_insertion_point(field_release:simpleperf_report_proto.MetaInfo.app_package_name)
  if (!has_app_package_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return app_package_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MetaInfo::set_allocated_app_package_name(std::string* app_package_name) {
  if (app_package_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  app_package_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_package_name);
  // @@protoc_insertion_point(field_set_allocated:simpleperf_report_proto.MetaInfo.app_package_name)
}

// -------------------------------------------------------------------

// Record

// optional .simpleperf_report_proto.Sample sample = 1;
inline bool Record::has_sample() const {
  return record_data_case() == kSample;
}
inline void Record::set_has_sample() {
  _oneof_case_[0] = kSample;
}
inline void Record::clear_sample() {
  if (has_sample()) {
    delete record_data_.sample_;
    clear_has_record_data();
  }
}
inline ::simpleperf_report_proto::Sample* Record::release_sample() {
  // @@protoc_insertion_point(field_release:simpleperf_report_proto.Record.sample)
  if (has_sample()) {
    clear_has_record_data();
      ::simpleperf_report_proto::Sample* temp = record_data_.sample_;
    record_data_.sample_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::simpleperf_report_proto::Sample& Record::sample() const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.Record.sample)
  return has_sample()
      ? *record_data_.sample_
      : *reinterpret_cast< ::simpleperf_report_proto::Sample*>(&::simpleperf_report_proto::_Sample_default_instance_);
}
inline ::simpleperf_report_proto::Sample* Record::mutable_sample() {
  if (!has_sample()) {
    clear_record_data();
    set_has_sample();
    record_data_.sample_ = CreateMaybeMessage< ::simpleperf_report_proto::Sample >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:simpleperf_report_proto.Record.sample)
  return record_data_.sample_;
}

// optional .simpleperf_report_proto.LostSituation lost = 2;
inline bool Record::has_lost() const {
  return record_data_case() == kLost;
}
inline void Record::set_has_lost() {
  _oneof_case_[0] = kLost;
}
inline void Record::clear_lost() {
  if (has_lost()) {
    delete record_data_.lost_;
    clear_has_record_data();
  }
}
inline ::simpleperf_report_proto::LostSituation* Record::release_lost() {
  // @@protoc_insertion_point(field_release:simpleperf_report_proto.Record.lost)
  if (has_lost()) {
    clear_has_record_data();
      ::simpleperf_report_proto::LostSituation* temp = record_data_.lost_;
    record_data_.lost_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::simpleperf_report_proto::LostSituation& Record::lost() const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.Record.lost)
  return has_lost()
      ? *record_data_.lost_
      : *reinterpret_cast< ::simpleperf_report_proto::LostSituation*>(&::simpleperf_report_proto::_LostSituation_default_instance_);
}
inline ::simpleperf_report_proto::LostSituation* Record::mutable_lost() {
  if (!has_lost()) {
    clear_record_data();
    set_has_lost();
    record_data_.lost_ = CreateMaybeMessage< ::simpleperf_report_proto::LostSituation >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:simpleperf_report_proto.Record.lost)
  return record_data_.lost_;
}

// optional .simpleperf_report_proto.File file = 3;
inline bool Record::has_file() const {
  return record_data_case() == kFile;
}
inline void Record::set_has_file() {
  _oneof_case_[0] = kFile;
}
inline void Record::clear_file() {
  if (has_file()) {
    delete record_data_.file_;
    clear_has_record_data();
  }
}
inline ::simpleperf_report_proto::File* Record::release_file() {
  // @@protoc_insertion_point(field_release:simpleperf_report_proto.Record.file)
  if (has_file()) {
    clear_has_record_data();
      ::simpleperf_report_proto::File* temp = record_data_.file_;
    record_data_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::simpleperf_report_proto::File& Record::file() const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.Record.file)
  return has_file()
      ? *record_data_.file_
      : *reinterpret_cast< ::simpleperf_report_proto::File*>(&::simpleperf_report_proto::_File_default_instance_);
}
inline ::simpleperf_report_proto::File* Record::mutable_file() {
  if (!has_file()) {
    clear_record_data();
    set_has_file();
    record_data_.file_ = CreateMaybeMessage< ::simpleperf_report_proto::File >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:simpleperf_report_proto.Record.file)
  return record_data_.file_;
}

// optional .simpleperf_report_proto.Thread thread = 4;
inline bool Record::has_thread() const {
  return record_data_case() == kThread;
}
inline void Record::set_has_thread() {
  _oneof_case_[0] = kThread;
}
inline void Record::clear_thread() {
  if (has_thread()) {
    delete record_data_.thread_;
    clear_has_record_data();
  }
}
inline ::simpleperf_report_proto::Thread* Record::release_thread() {
  // @@protoc_insertion_point(field_release:simpleperf_report_proto.Record.thread)
  if (has_thread()) {
    clear_has_record_data();
      ::simpleperf_report_proto::Thread* temp = record_data_.thread_;
    record_data_.thread_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::simpleperf_report_proto::Thread& Record::thread() const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.Record.thread)
  return has_thread()
      ? *record_data_.thread_
      : *reinterpret_cast< ::simpleperf_report_proto::Thread*>(&::simpleperf_report_proto::_Thread_default_instance_);
}
inline ::simpleperf_report_proto::Thread* Record::mutable_thread() {
  if (!has_thread()) {
    clear_record_data();
    set_has_thread();
    record_data_.thread_ = CreateMaybeMessage< ::simpleperf_report_proto::Thread >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:simpleperf_report_proto.Record.thread)
  return record_data_.thread_;
}

// optional .simpleperf_report_proto.MetaInfo meta_info = 5;
inline bool Record::has_meta_info() const {
  return record_data_case() == kMetaInfo;
}
inline void Record::set_has_meta_info() {
  _oneof_case_[0] = kMetaInfo;
}
inline void Record::clear_meta_info() {
  if (has_meta_info()) {
    delete record_data_.meta_info_;
    clear_has_record_data();
  }
}
inline ::simpleperf_report_proto::MetaInfo* Record::release_meta_info() {
  // @@protoc_insertion_point(field_release:simpleperf_report_proto.Record.meta_info)
  if (has_meta_info()) {
    clear_has_record_data();
      ::simpleperf_report_proto::MetaInfo* temp = record_data_.meta_info_;
    record_data_.meta_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::simpleperf_report_proto::MetaInfo& Record::meta_info() const {
  // @@protoc_insertion_point(field_get:simpleperf_report_proto.Record.meta_info)
  return has_meta_info()
      ? *record_data_.meta_info_
      : *reinterpret_cast< ::simpleperf_report_proto::MetaInfo*>(&::simpleperf_report_proto::_MetaInfo_default_instance_);
}
inline ::simpleperf_report_proto::MetaInfo* Record::mutable_meta_info() {
  if (!has_meta_info()) {
    clear_record_data();
    set_has_meta_info();
    record_data_.meta_info_ = CreateMaybeMessage< ::simpleperf_report_proto::MetaInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:simpleperf_report_proto.Record.meta_info)
  return record_data_.meta_info_;
}

inline bool Record::has_record_data() const {
  return record_data_case() != RECORD_DATA_NOT_SET;
}
inline void Record::clear_has_record_data() {
  _oneof_case_[0] = RECORD_DATA_NOT_SET;
}
inline Record::RecordDataCase Record::record_data_case() const {
  return Record::RecordDataCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace simpleperf_report_proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::simpleperf_report_proto::Sample_CallChainEntry_ExecutionType> : ::std::true_type {};
template <> struct is_proto_enum< ::simpleperf_report_proto::Sample_UnwindingResult_ErrorCode> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_system_2fextras_2fsimpleperf_2fcmd_5freport_5fsample_2eproto
