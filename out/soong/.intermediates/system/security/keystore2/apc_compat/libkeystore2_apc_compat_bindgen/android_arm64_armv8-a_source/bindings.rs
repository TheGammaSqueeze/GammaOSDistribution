/* automatically generated by rust-bindgen 0.58.1 */

pub const APC_COMPAT_ERROR_OK: u32 = 0;
pub const APC_COMPAT_ERROR_CANCELLED: u32 = 1;
pub const APC_COMPAT_ERROR_ABORTED: u32 = 2;
pub const APC_COMPAT_ERROR_OPERATION_PENDING: u32 = 3;
pub const APC_COMPAT_ERROR_IGNORED: u32 = 4;
pub const APC_COMPAT_ERROR_SYSTEM_ERROR: u32 = 5;
pub type size_t = ::std::os::raw::c_ulong;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type ApcCompatServiceHandle = *mut ::std::os::raw::c_void;
extern "C" {
    pub static INVALID_SERVICE_HANDLE: ApcCompatServiceHandle;
}
#[doc = " This struct holds the ui options for the protected confirmation dialog."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ApcCompatUiOptions {
    #[doc = " If set to true inverted color mode is used."]
    pub inverted: bool,
    #[doc = " If set to true magnified fonts are used."]
    pub magnified: bool,
}
#[test]
fn bindgen_test_layout_ApcCompatUiOptions() {
    assert_eq!(
        ::std::mem::size_of::<ApcCompatUiOptions>(),
        2usize,
        concat!("Size of: ", stringify!(ApcCompatUiOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<ApcCompatUiOptions>(),
        1usize,
        concat!("Alignment of ", stringify!(ApcCompatUiOptions))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ApcCompatUiOptions>())).inverted as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ApcCompatUiOptions),
            "::",
            stringify!(inverted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ApcCompatUiOptions>())).magnified as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ApcCompatUiOptions),
            "::",
            stringify!(magnified)
        )
    );
}
#[doc = " Represents a result callback that is called when a confirmation session was successfully"]
#[doc = " started."]
#[doc = " The field `data` is an opaque callback context handle. It must be passed to the `result`"]
#[doc = " function."]
#[doc = ""]
#[doc = " IMPORTANT: The life cycle of `data` ends when `result` is called. The callback must not"]
#[doc = "            be called a second time."]
#[doc = ""]
#[doc = " The callback function `result` has the prototype:"]
#[doc = " void result("]
#[doc = "     void* data,"]
#[doc = "     uint32_t rc,"]
#[doc = "     const uint8_t* tbs_message,"]
#[doc = "     size_t tbs_message_size,"]
#[doc = "     const uint8_t* confirmation_token,"]
#[doc = "     size_t confirmation_token_size)"]
#[doc = ""]
#[doc = " * data - must be the data field of the structure."]
#[doc = " * rc - response code, one of:"]
#[doc = "      * APC_COMPAT_ERROR_OK - The user confirmed the prompt text."]
#[doc = "      * APC_COMPAT_ERROR_CANCELLED - The user rejected the prompt text."]
#[doc = "      * APC_COMPAT_ERROR_ABORTED - `abortUserConfirmation` was called."]
#[doc = "      * APC_COMPAT_ERROR_SYSTEM_ERROR - An unspecified system error occurred."]
#[doc = " * tbs_message(_size) - Pointer to and size of the to-be-signed message. Must"]
#[doc = "      be NULL and 0 respectively if `rc != APC_COMPAT_ERROR_OK`."]
#[doc = " * confirmation_token(_size) - Pointer to and size of the confirmation token. Must"]
#[doc = "      be NULL and 0 respectively if `rc != APC_COMPAT_ERROR_OK`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ApcCompatCallback {
    pub data: *mut ::std::os::raw::c_void,
    pub result: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: u32,
            arg3: *const u8,
            arg4: size_t,
            arg5: *const u8,
            arg6: size_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_ApcCompatCallback() {
    assert_eq!(
        ::std::mem::size_of::<ApcCompatCallback>(),
        16usize,
        concat!("Size of: ", stringify!(ApcCompatCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<ApcCompatCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(ApcCompatCallback))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ApcCompatCallback>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ApcCompatCallback),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ApcCompatCallback>())).result as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ApcCompatCallback),
            "::",
            stringify!(result)
        )
    );
}
extern "C" {
    #[doc = " Attempts to make a connection to the confirmationui HIDL backend."]
    #[doc = " If a valid service handle is returned it stays valid until"]
    #[doc = " `closeUserConfirmationService` is called."]
    #[doc = ""]
    #[doc = " @return A valid service handle on success or INVALID_SERVICE_HANDLE"]
    #[doc = "         on failure."]
    pub fn tryGetUserConfirmationService() -> ApcCompatServiceHandle;
}
extern "C" {
    #[doc = " Attempts to start a protected confirmation session on the given service handle."]
    #[doc = " The function takes ownership of the callback object (`cb`) IFF APC_COMPAT_ERROR_OK"]
    #[doc = " is returned. The resources referenced by the callback object must stay valid"]
    #[doc = " until the callback is called."]
    #[doc = ""]
    #[doc = " @param handle A valid service handle as returned by `tryGetUserConfirmationService()`."]
    #[doc = " @cb A ApcCompatCallback structure that represents a callback function with session data."]
    #[doc = " @param prompt_text A UTF-8 encoded prompt string."]
    #[doc = " @param extra_data Free form extra data."]
    #[doc = " @param extra_data_size size of the extra data buffer in bytes."]
    #[doc = " @param locale A locale string."]
    #[doc = " @param ui_options A UI options. See ApcCompatUiOptions above."]
    #[doc = " @retval APC_COMPAT_ERROR_OK on success."]
    #[doc = " @retval APC_COMPAT_ERROR_OPERATION_PENDING if another operation was already in progress."]
    #[doc = " @retval APC_COMPAT_ERROR_SYSTEM_ERROR if an unspecified system error occurred."]
    pub fn promptUserConfirmation(
        handle: ApcCompatServiceHandle,
        cb: ApcCompatCallback,
        prompt_text: *const ::std::os::raw::c_char,
        extra_data: *const u8,
        extra_data_size: size_t,
        locale: *const ::std::os::raw::c_char,
        ui_options: ApcCompatUiOptions,
    ) -> u32;
}
extern "C" {
    #[doc = " Aborts a running confirmation session or no-op if no session is running."]
    #[doc = " If a session is running this results in a `result` callback with"]
    #[doc = " `rc == APC_COMPAT_ERROR_ABORTED`. Mind though that the callback can still yield other"]
    #[doc = " results even after this function was called, because it may race with an actual user"]
    #[doc = " response. In any case, there will be only one callback response for each session"]
    #[doc = " successfully started with promptUserConfirmation."]
    #[doc = ""]
    #[doc = " @param handle A valid session handle as returned by `tryGetUserConfirmationService()`"]
    pub fn abortUserConfirmation(handle: ApcCompatServiceHandle);
}
extern "C" {
    #[doc = " Closes a valid service session as returned by `tryGetUserConfirmationService()`."]
    #[doc = " If a session is still running it is implicitly aborted. In this case, freeing up of the resources"]
    #[doc = " referenced by the service handle is deferred until the callback has completed."]
    #[doc = ""]
    #[doc = " @param handle A valid session handle as returned by `tryGetUserConfirmationService()`"]
    pub fn closeUserConfirmationService(arg1: ApcCompatServiceHandle);
}
