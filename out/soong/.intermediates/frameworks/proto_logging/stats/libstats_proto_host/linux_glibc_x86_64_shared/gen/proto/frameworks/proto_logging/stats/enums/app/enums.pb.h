// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/app/enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fapp_2fenums_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fapp_2fenums_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_frameworks_2fproto_5flogging_2fstats_2fenums_2fapp_2fenums_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_frameworks_2fproto_5flogging_2fstats_2fenums_2fapp_2fenums_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_frameworks_2fproto_5flogging_2fstats_2fenums_2fapp_2fenums_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace android {
namespace app {

enum AppTransitionReasonEnum : int {
  APP_TRANSITION_REASON_UNKNOWN = 0,
  APP_TRANSITION_SPLASH_SCREEN = 1,
  APP_TRANSITION_WINDOWS_DRAWN = 2,
  APP_TRANSITION_TIMEOUT = 3,
  APP_TRANSITION_SNAPSHOT = 4,
  APP_TRANSITION_RECENTS_ANIM = 5
};
bool AppTransitionReasonEnum_IsValid(int value);
constexpr AppTransitionReasonEnum AppTransitionReasonEnum_MIN = APP_TRANSITION_REASON_UNKNOWN;
constexpr AppTransitionReasonEnum AppTransitionReasonEnum_MAX = APP_TRANSITION_RECENTS_ANIM;
constexpr int AppTransitionReasonEnum_ARRAYSIZE = AppTransitionReasonEnum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AppTransitionReasonEnum_descriptor();
template<typename T>
inline const std::string& AppTransitionReasonEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AppTransitionReasonEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AppTransitionReasonEnum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AppTransitionReasonEnum_descriptor(), enum_t_value);
}
inline bool AppTransitionReasonEnum_Parse(
    const std::string& name, AppTransitionReasonEnum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AppTransitionReasonEnum>(
    AppTransitionReasonEnum_descriptor(), name, value);
}
enum ProcessStateEnum : int {
  PROCESS_STATE_UNKNOWN_TO_PROTO = 998,
  PROCESS_STATE_UNKNOWN = 999,
  PROCESS_STATE_PERSISTENT = 1000,
  PROCESS_STATE_PERSISTENT_UI = 1001,
  PROCESS_STATE_TOP = 1002,
  PROCESS_STATE_BOUND_TOP = 1020,
  PROCESS_STATE_FOREGROUND_SERVICE = 1003,
  PROCESS_STATE_BOUND_FOREGROUND_SERVICE = 1004,
  PROCESS_STATE_IMPORTANT_FOREGROUND = 1005,
  PROCESS_STATE_IMPORTANT_BACKGROUND = 1006,
  PROCESS_STATE_TRANSIENT_BACKGROUND = 1007,
  PROCESS_STATE_BACKUP = 1008,
  PROCESS_STATE_SERVICE = 1009,
  PROCESS_STATE_RECEIVER = 1010,
  PROCESS_STATE_TOP_SLEEPING = 1011,
  PROCESS_STATE_HEAVY_WEIGHT = 1012,
  PROCESS_STATE_HOME = 1013,
  PROCESS_STATE_LAST_ACTIVITY = 1014,
  PROCESS_STATE_CACHED_ACTIVITY = 1015,
  PROCESS_STATE_CACHED_ACTIVITY_CLIENT = 1016,
  PROCESS_STATE_CACHED_RECENT = 1017,
  PROCESS_STATE_CACHED_EMPTY = 1018,
  PROCESS_STATE_NONEXISTENT = 1019
};
bool ProcessStateEnum_IsValid(int value);
constexpr ProcessStateEnum ProcessStateEnum_MIN = PROCESS_STATE_UNKNOWN_TO_PROTO;
constexpr ProcessStateEnum ProcessStateEnum_MAX = PROCESS_STATE_BOUND_TOP;
constexpr int ProcessStateEnum_ARRAYSIZE = ProcessStateEnum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProcessStateEnum_descriptor();
template<typename T>
inline const std::string& ProcessStateEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProcessStateEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProcessStateEnum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProcessStateEnum_descriptor(), enum_t_value);
}
inline bool ProcessStateEnum_Parse(
    const std::string& name, ProcessStateEnum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProcessStateEnum>(
    ProcessStateEnum_descriptor(), name, value);
}
enum AppOpEnum : int {
  APP_OP_NONE = -1,
  APP_OP_COARSE_LOCATION = 0,
  APP_OP_FINE_LOCATION = 1,
  APP_OP_GPS = 2,
  APP_OP_VIBRATE = 3,
  APP_OP_READ_CONTACTS = 4,
  APP_OP_WRITE_CONTACTS = 5,
  APP_OP_READ_CALL_LOG = 6,
  APP_OP_WRITE_CALL_LOG = 7,
  APP_OP_READ_CALENDAR = 8,
  APP_OP_WRITE_CALENDAR = 9,
  APP_OP_WIFI_SCAN = 10,
  APP_OP_POST_NOTIFICATION = 11,
  APP_OP_NEIGHBORING_CELLS = 12,
  APP_OP_CALL_PHONE = 13,
  APP_OP_READ_SMS = 14,
  APP_OP_WRITE_SMS = 15,
  APP_OP_RECEIVE_SMS = 16,
  APP_OP_RECEIVE_EMERGENCY_SMS = 17,
  APP_OP_RECEIVE_MMS = 18,
  APP_OP_RECEIVE_WAP_PUSH = 19,
  APP_OP_SEND_SMS = 20,
  APP_OP_READ_ICC_SMS = 21,
  APP_OP_WRITE_ICC_SMS = 22,
  APP_OP_WRITE_SETTINGS = 23,
  APP_OP_SYSTEM_ALERT_WINDOW = 24,
  APP_OP_ACCESS_NOTIFICATIONS = 25,
  APP_OP_CAMERA = 26,
  APP_OP_RECORD_AUDIO = 27,
  APP_OP_PLAY_AUDIO = 28,
  APP_OP_READ_CLIPBOARD = 29,
  APP_OP_WRITE_CLIPBOARD = 30,
  APP_OP_TAKE_MEDIA_BUTTONS = 31,
  APP_OP_TAKE_AUDIO_FOCUS = 32,
  APP_OP_AUDIO_MASTER_VOLUME = 33,
  APP_OP_AUDIO_VOICE_VOLUME = 34,
  APP_OP_AUDIO_RING_VOLUME = 35,
  APP_OP_AUDIO_MEDIA_VOLUME = 36,
  APP_OP_AUDIO_ALARM_VOLUME = 37,
  APP_OP_AUDIO_NOTIFICATION_VOLUME = 38,
  APP_OP_AUDIO_BLUETOOTH_VOLUME = 39,
  APP_OP_WAKE_LOCK = 40,
  APP_OP_MONITOR_LOCATION = 41,
  APP_OP_MONITOR_HIGH_POWER_LOCATION = 42,
  APP_OP_GET_USAGE_STATS = 43,
  APP_OP_MUTE_MICROPHONE = 44,
  APP_OP_TOAST_WINDOW = 45,
  APP_OP_PROJECT_MEDIA = 46,
  APP_OP_ACTIVATE_VPN = 47,
  APP_OP_WRITE_WALLPAPER = 48,
  APP_OP_ASSIST_STRUCTURE = 49,
  APP_OP_ASSIST_SCREENSHOT = 50,
  APP_OP_READ_PHONE_STATE = 51,
  APP_OP_ADD_VOICEMAIL = 52,
  APP_OP_USE_SIP = 53,
  APP_OP_PROCESS_OUTGOING_CALLS = 54,
  APP_OP_USE_FINGERPRINT = 55,
  APP_OP_BODY_SENSORS = 56,
  APP_OP_READ_CELL_BROADCASTS = 57,
  APP_OP_MOCK_LOCATION = 58,
  APP_OP_READ_EXTERNAL_STORAGE = 59,
  APP_OP_WRITE_EXTERNAL_STORAGE = 60,
  APP_OP_TURN_SCREEN_ON = 61,
  APP_OP_GET_ACCOUNTS = 62,
  APP_OP_RUN_IN_BACKGROUND = 63,
  APP_OP_AUDIO_ACCESSIBILITY_VOLUME = 64,
  APP_OP_READ_PHONE_NUMBERS = 65,
  APP_OP_REQUEST_INSTALL_PACKAGES = 66,
  APP_OP_PICTURE_IN_PICTURE = 67,
  APP_OP_INSTANT_APP_START_FOREGROUND = 68,
  APP_OP_ANSWER_PHONE_CALLS = 69,
  APP_OP_RUN_ANY_IN_BACKGROUND = 70,
  APP_OP_CHANGE_WIFI_STATE = 71,
  APP_OP_REQUEST_DELETE_PACKAGES = 72,
  APP_OP_BIND_ACCESSIBILITY_SERVICE = 73,
  APP_OP_ACCEPT_HANDOVER = 74,
  APP_OP_MANAGE_IPSEC_TUNNELS = 75,
  APP_OP_START_FOREGROUND = 76,
  APP_OP_BLUETOOTH_SCAN = 77,
  APP_OP_USE_BIOMETRIC = 78,
  APP_OP_ACTIVITY_RECOGNITION = 79,
  APP_OP_SMS_FINANCIAL_TRANSACTIONS = 80,
  APP_OP_READ_MEDIA_AUDIO = 81,
  APP_OP_WRITE_MEDIA_AUDIO = 82,
  APP_OP_READ_MEDIA_VIDEO = 83,
  APP_OP_WRITE_MEDIA_VIDEO = 84,
  APP_OP_READ_MEDIA_IMAGES = 85,
  APP_OP_WRITE_MEDIA_IMAGES = 86,
  APP_OP_LEGACY_STORAGE = 87,
  APP_OP_ACCESS_ACCESSIBILITY = 88,
  APP_OP_READ_DEVICE_IDENTIFIERS = 89,
  APP_OP_ACCESS_MEDIA_LOCATION = 90,
  APP_OP_QUERY_ALL_PACKAGES = 91,
  APP_OP_MANAGE_EXTERNAL_STORAGE = 92,
  APP_OP_INTERACT_ACROSS_PROFILES = 93,
  APP_OP_ACTIVATE_PLATFORM_VPN = 94,
  APP_OP_LOADER_USAGE_STATS = 95,
  APP_OP_DEPRECATED_1 PROTOBUF_DEPRECATED = 96,
  APP_OP_AUTO_REVOKE_PERMISSIONS_IF_UNUSED = 97,
  APP_OP_AUTO_REVOKE_MANAGED_BY_INSTALLER = 98,
  APP_OP_NO_ISOLATED_STORAGE = 99,
  APP_OP_PHONE_CALL_MICROPHONE = 100,
  APP_OP_PHONE_CALL_CAMERA = 101,
  APP_OP_RECORD_AUDIO_HOTWORD = 102,
  APP_OP_MANAGE_ONGOING_CALLS = 103,
  APP_OP_MANAGE_CREDENTIALS = 104,
  APP_OP_USE_ICC_AUTH_WITH_DEVICE_IDENTIFIER = 105,
  APP_OP_RECORD_AUDIO_OUTPUT = 106,
  APP_OP_SCHEDULE_EXACT_ALARM = 107,
  APP_OP_FINE_LOCATION_SOURCE = 108,
  APP_OP_COARSE_LOCATION_SOURCE = 109,
  APP_OP_MANAGE_MEDIA = 110,
  APP_OP_BLUETOOTH_CONNECT = 111,
  APP_OP_UWB_RANGING = 112,
  APP_OP_ACTIVITY_RECOGNITION_SOURCE = 113,
  APP_OP_BLUETOOTH_ADVERTISE = 114,
  APP_OP_RECORD_INCOMING_PHONE_AUDIO = 115
};
bool AppOpEnum_IsValid(int value);
constexpr AppOpEnum AppOpEnum_MIN = APP_OP_NONE;
constexpr AppOpEnum AppOpEnum_MAX = APP_OP_RECORD_INCOMING_PHONE_AUDIO;
constexpr int AppOpEnum_ARRAYSIZE = AppOpEnum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AppOpEnum_descriptor();
template<typename T>
inline const std::string& AppOpEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AppOpEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AppOpEnum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AppOpEnum_descriptor(), enum_t_value);
}
inline bool AppOpEnum_Parse(
    const std::string& name, AppOpEnum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AppOpEnum>(
    AppOpEnum_descriptor(), name, value);
}
enum AppExitReasonCode : int {
  REASON_UNKNOWN = 0,
  REASON_EXIT_SELF = 1,
  REASON_SIGNALED = 2,
  REASON_LOW_MEMORY = 3,
  REASON_CRASH = 4,
  REASON_CRASH_NATIVE = 5,
  REASON_ANR = 6,
  REASON_INITIALIZATION_FAILURE = 7,
  REASON_PERMISSION_CHANGE = 8,
  REASON_EXCESSIVE_RESOURCE_USAGE = 9,
  REASON_USER_REQUESTED = 10,
  REASON_USER_STOPPED = 11,
  REASON_DEPENDENCY_DIED = 12,
  REASON_OTHER = 13
};
bool AppExitReasonCode_IsValid(int value);
constexpr AppExitReasonCode AppExitReasonCode_MIN = REASON_UNKNOWN;
constexpr AppExitReasonCode AppExitReasonCode_MAX = REASON_OTHER;
constexpr int AppExitReasonCode_ARRAYSIZE = AppExitReasonCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AppExitReasonCode_descriptor();
template<typename T>
inline const std::string& AppExitReasonCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AppExitReasonCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AppExitReasonCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AppExitReasonCode_descriptor(), enum_t_value);
}
inline bool AppExitReasonCode_Parse(
    const std::string& name, AppExitReasonCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AppExitReasonCode>(
    AppExitReasonCode_descriptor(), name, value);
}
enum AppExitSubReasonCode : int {
  SUBREASON_UNKNOWN = 0,
  SUBREASON_WAIT_FOR_DEBUGGER = 1,
  SUBREASON_TOO_MANY_CACHED = 2,
  SUBREASON_TOO_MANY_EMPTY = 3,
  SUBREASON_TRIM_EMPTY = 4,
  SUBREASON_LARGE_CACHED = 5,
  SUBREASON_MEMORY_PRESSURE = 6,
  SUBREASON_EXCESSIVE_CPU = 7,
  SUBREASON_SYSTEM_UPDATE_DONE = 8,
  SUBREASON_KILL_ALL_FG = 9,
  SUBREASON_KILL_ALL_BG_EXCEPT = 10,
  SUBREASON_KILL_UID = 11,
  SUBREASON_KILL_PID = 12,
  SUBREASON_INVALID_START = 13,
  SUBREASON_INVALID_STATE = 14,
  SUBREASON_IMPERCEPTIBLE = 15,
  SUBREASON_REMOVE_LRU = 16,
  SUBREASON_ISOLATED_NOT_NEEDED = 17,
  SUBREASON_CACHED_IDLE_FORCED_APP_STANDBY = 18,
  SUBREASON_FREEZER_BINDER_IOCTL = 19,
  SUBREASON_FREEZER_BINDER_TRANSACTION = 20
};
bool AppExitSubReasonCode_IsValid(int value);
constexpr AppExitSubReasonCode AppExitSubReasonCode_MIN = SUBREASON_UNKNOWN;
constexpr AppExitSubReasonCode AppExitSubReasonCode_MAX = SUBREASON_FREEZER_BINDER_TRANSACTION;
constexpr int AppExitSubReasonCode_ARRAYSIZE = AppExitSubReasonCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AppExitSubReasonCode_descriptor();
template<typename T>
inline const std::string& AppExitSubReasonCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AppExitSubReasonCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AppExitSubReasonCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AppExitSubReasonCode_descriptor(), enum_t_value);
}
inline bool AppExitSubReasonCode_Parse(
    const std::string& name, AppExitSubReasonCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AppExitSubReasonCode>(
    AppExitSubReasonCode_descriptor(), name, value);
}
enum Importance : int {
  IMPORTANCE_FOREGROUND = 100,
  IMPORTANCE_FOREGROUND_SERVICE = 125,
  IMPORTANCE_TOP_SLEEPING_PRE_28 = 150,
  IMPORTANCE_VISIBLE = 200,
  IMPORTANCE_PERCEPTIBLE_PRE_26 = 130,
  IMPORTANCE_PERCEPTIBLE = 230,
  IMPORTANCE_CANT_SAVE_STATE_PRE_26 = 170,
  IMPORTANCE_SERVICE = 300,
  IMPORTANCE_TOP_SLEEPING = 325,
  IMPORTANCE_CANT_SAVE_STATE = 350,
  IMPORTANCE_CACHED = 400,
  IMPORTANCE_BACKGROUND = 400,
  IMPORTANCE_EMPTY = 500,
  IMPORTANCE_GONE = 1000
};
bool Importance_IsValid(int value);
constexpr Importance Importance_MIN = IMPORTANCE_FOREGROUND;
constexpr Importance Importance_MAX = IMPORTANCE_GONE;
constexpr int Importance_ARRAYSIZE = Importance_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Importance_descriptor();
template<typename T>
inline const std::string& Importance_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Importance>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Importance_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Importance_descriptor(), enum_t_value);
}
inline bool Importance_Parse(
    const std::string& name, Importance* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Importance>(
    Importance_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace app
}  // namespace android

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::android::app::AppTransitionReasonEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::app::AppTransitionReasonEnum>() {
  return ::android::app::AppTransitionReasonEnum_descriptor();
}
template <> struct is_proto_enum< ::android::app::ProcessStateEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::app::ProcessStateEnum>() {
  return ::android::app::ProcessStateEnum_descriptor();
}
template <> struct is_proto_enum< ::android::app::AppOpEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::app::AppOpEnum>() {
  return ::android::app::AppOpEnum_descriptor();
}
template <> struct is_proto_enum< ::android::app::AppExitReasonCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::app::AppExitReasonCode>() {
  return ::android::app::AppExitReasonCode_descriptor();
}
template <> struct is_proto_enum< ::android::app::AppExitSubReasonCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::app::AppExitSubReasonCode>() {
  return ::android::app::AppExitSubReasonCode_descriptor();
}
template <> struct is_proto_enum< ::android::app::Importance> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::app::Importance>() {
  return ::android::app::Importance_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fapp_2fenums_2eproto
