// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/server/location/enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fserver_2flocation_2fenums_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fserver_2flocation_2fenums_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_frameworks_2fproto_5flogging_2fstats_2fenums_2fserver_2flocation_2fenums_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_frameworks_2fproto_5flogging_2fstats_2fenums_2fserver_2flocation_2fenums_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_frameworks_2fproto_5flogging_2fstats_2fenums_2fserver_2flocation_2fenums_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace android {
namespace server {
namespace location {

enum GpsSignalQualityEnum : int {
  GPS_SIGNAL_QUALITY_UNKNOWN = -1,
  GPS_SIGNAL_QUALITY_POOR = 0,
  GPS_SIGNAL_QUALITY_GOOD = 1
};
bool GpsSignalQualityEnum_IsValid(int value);
constexpr GpsSignalQualityEnum GpsSignalQualityEnum_MIN = GPS_SIGNAL_QUALITY_UNKNOWN;
constexpr GpsSignalQualityEnum GpsSignalQualityEnum_MAX = GPS_SIGNAL_QUALITY_GOOD;
constexpr int GpsSignalQualityEnum_ARRAYSIZE = GpsSignalQualityEnum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GpsSignalQualityEnum_descriptor();
template<typename T>
inline const std::string& GpsSignalQualityEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GpsSignalQualityEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GpsSignalQualityEnum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GpsSignalQualityEnum_descriptor(), enum_t_value);
}
inline bool GpsSignalQualityEnum_Parse(
    const std::string& name, GpsSignalQualityEnum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GpsSignalQualityEnum>(
    GpsSignalQualityEnum_descriptor(), name, value);
}
enum GnssNiType : int {
  VOICE = 1,
  UMTS_SUPL = 2,
  UMTS_CTRL_PLANE = 3,
  EMERGENCY_SUPL = 4
};
bool GnssNiType_IsValid(int value);
constexpr GnssNiType GnssNiType_MIN = VOICE;
constexpr GnssNiType GnssNiType_MAX = EMERGENCY_SUPL;
constexpr int GnssNiType_ARRAYSIZE = GnssNiType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GnssNiType_descriptor();
template<typename T>
inline const std::string& GnssNiType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GnssNiType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GnssNiType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GnssNiType_descriptor(), enum_t_value);
}
inline bool GnssNiType_Parse(
    const std::string& name, GnssNiType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GnssNiType>(
    GnssNiType_descriptor(), name, value);
}
enum GnssUserResponseType : int {
  RESPONSE_ACCEPT = 1,
  RESPONSE_DENY = 2,
  RESPONSE_NORESP = 3
};
bool GnssUserResponseType_IsValid(int value);
constexpr GnssUserResponseType GnssUserResponseType_MIN = RESPONSE_ACCEPT;
constexpr GnssUserResponseType GnssUserResponseType_MAX = RESPONSE_NORESP;
constexpr int GnssUserResponseType_ARRAYSIZE = GnssUserResponseType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GnssUserResponseType_descriptor();
template<typename T>
inline const std::string& GnssUserResponseType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GnssUserResponseType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GnssUserResponseType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GnssUserResponseType_descriptor(), enum_t_value);
}
inline bool GnssUserResponseType_Parse(
    const std::string& name, GnssUserResponseType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GnssUserResponseType>(
    GnssUserResponseType_descriptor(), name, value);
}
enum GnssNiEncodingType : int {
  ENC_NONE = 0,
  ENC_SUPL_GSM_DEFAULT = 1,
  ENC_SUPL_UTF8 = 2,
  ENC_SUPL_UCS2 = 3,
  ENC_UNKNOWN = -1
};
bool GnssNiEncodingType_IsValid(int value);
constexpr GnssNiEncodingType GnssNiEncodingType_MIN = ENC_UNKNOWN;
constexpr GnssNiEncodingType GnssNiEncodingType_MAX = ENC_SUPL_UCS2;
constexpr int GnssNiEncodingType_ARRAYSIZE = GnssNiEncodingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GnssNiEncodingType_descriptor();
template<typename T>
inline const std::string& GnssNiEncodingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GnssNiEncodingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GnssNiEncodingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GnssNiEncodingType_descriptor(), enum_t_value);
}
inline bool GnssNiEncodingType_Parse(
    const std::string& name, GnssNiEncodingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GnssNiEncodingType>(
    GnssNiEncodingType_descriptor(), name, value);
}
enum NfwProtocolStack : int {
  CTRL_PLANE = 0,
  SUPL = 1,
  IMS = 10,
  SIM = 11,
  OTHER_PROTOCOL_STACK = 100
};
bool NfwProtocolStack_IsValid(int value);
constexpr NfwProtocolStack NfwProtocolStack_MIN = CTRL_PLANE;
constexpr NfwProtocolStack NfwProtocolStack_MAX = OTHER_PROTOCOL_STACK;
constexpr int NfwProtocolStack_ARRAYSIZE = NfwProtocolStack_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NfwProtocolStack_descriptor();
template<typename T>
inline const std::string& NfwProtocolStack_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NfwProtocolStack>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NfwProtocolStack_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NfwProtocolStack_descriptor(), enum_t_value);
}
inline bool NfwProtocolStack_Parse(
    const std::string& name, NfwProtocolStack* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NfwProtocolStack>(
    NfwProtocolStack_descriptor(), name, value);
}
enum NfwRequestor : int {
  CARRIER = 0,
  OEM = 10,
  MODEM_CHIPSET_VENDOR = 11,
  GNSS_CHIPSET_VENDOR = 12,
  OTHER_CHIPSET_VENDOR = 13,
  AUTOMOBILE_CLIENT = 20,
  OTHER_REQUESTOR = 100
};
bool NfwRequestor_IsValid(int value);
constexpr NfwRequestor NfwRequestor_MIN = CARRIER;
constexpr NfwRequestor NfwRequestor_MAX = OTHER_REQUESTOR;
constexpr int NfwRequestor_ARRAYSIZE = NfwRequestor_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NfwRequestor_descriptor();
template<typename T>
inline const std::string& NfwRequestor_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NfwRequestor>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NfwRequestor_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NfwRequestor_descriptor(), enum_t_value);
}
inline bool NfwRequestor_Parse(
    const std::string& name, NfwRequestor* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NfwRequestor>(
    NfwRequestor_descriptor(), name, value);
}
enum NfwResponseType : int {
  REJECTED = 0,
  ACCEPTED_NO_LOCATION_PROVIDED = 1,
  ACCEPTED_LOCATION_PROVIDED = 2
};
bool NfwResponseType_IsValid(int value);
constexpr NfwResponseType NfwResponseType_MIN = REJECTED;
constexpr NfwResponseType NfwResponseType_MAX = ACCEPTED_LOCATION_PROVIDED;
constexpr int NfwResponseType_ARRAYSIZE = NfwResponseType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NfwResponseType_descriptor();
template<typename T>
inline const std::string& NfwResponseType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NfwResponseType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NfwResponseType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NfwResponseType_descriptor(), enum_t_value);
}
inline bool NfwResponseType_Parse(
    const std::string& name, NfwResponseType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NfwResponseType>(
    NfwResponseType_descriptor(), name, value);
}
enum SuplMode : int {
  MSB = 1,
  MSA = 2
};
bool SuplMode_IsValid(int value);
constexpr SuplMode SuplMode_MIN = MSB;
constexpr SuplMode SuplMode_MAX = MSA;
constexpr int SuplMode_ARRAYSIZE = SuplMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SuplMode_descriptor();
template<typename T>
inline const std::string& SuplMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SuplMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SuplMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SuplMode_descriptor(), enum_t_value);
}
inline bool SuplMode_Parse(
    const std::string& name, SuplMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SuplMode>(
    SuplMode_descriptor(), name, value);
}
enum LppProfile : int {
  USER_PLANE = 1,
  CONTROL_PLANE = 2
};
bool LppProfile_IsValid(int value);
constexpr LppProfile LppProfile_MIN = USER_PLANE;
constexpr LppProfile LppProfile_MAX = CONTROL_PLANE;
constexpr int LppProfile_ARRAYSIZE = LppProfile_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LppProfile_descriptor();
template<typename T>
inline const std::string& LppProfile_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LppProfile>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LppProfile_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LppProfile_descriptor(), enum_t_value);
}
inline bool LppProfile_Parse(
    const std::string& name, LppProfile* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LppProfile>(
    LppProfile_descriptor(), name, value);
}
enum GlonassPosProtocol : int {
  RRC_CPLANE = 1,
  RRLP_CPLANE = 2,
  LPP_UPLANE = 4
};
bool GlonassPosProtocol_IsValid(int value);
constexpr GlonassPosProtocol GlonassPosProtocol_MIN = RRC_CPLANE;
constexpr GlonassPosProtocol GlonassPosProtocol_MAX = LPP_UPLANE;
constexpr int GlonassPosProtocol_ARRAYSIZE = GlonassPosProtocol_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GlonassPosProtocol_descriptor();
template<typename T>
inline const std::string& GlonassPosProtocol_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GlonassPosProtocol>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GlonassPosProtocol_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GlonassPosProtocol_descriptor(), enum_t_value);
}
inline bool GlonassPosProtocol_Parse(
    const std::string& name, GlonassPosProtocol* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GlonassPosProtocol>(
    GlonassPosProtocol_descriptor(), name, value);
}
enum GpsLock : int {
  MO = 1,
  NI = 2
};
bool GpsLock_IsValid(int value);
constexpr GpsLock GpsLock_MIN = MO;
constexpr GpsLock GpsLock_MAX = NI;
constexpr int GpsLock_ARRAYSIZE = GpsLock_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GpsLock_descriptor();
template<typename T>
inline const std::string& GpsLock_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GpsLock>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GpsLock_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GpsLock_descriptor(), enum_t_value);
}
inline bool GpsLock_Parse(
    const std::string& name, GpsLock* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GpsLock>(
    GpsLock_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace location
}  // namespace server
}  // namespace android

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::android::server::location::GpsSignalQualityEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::server::location::GpsSignalQualityEnum>() {
  return ::android::server::location::GpsSignalQualityEnum_descriptor();
}
template <> struct is_proto_enum< ::android::server::location::GnssNiType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::server::location::GnssNiType>() {
  return ::android::server::location::GnssNiType_descriptor();
}
template <> struct is_proto_enum< ::android::server::location::GnssUserResponseType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::server::location::GnssUserResponseType>() {
  return ::android::server::location::GnssUserResponseType_descriptor();
}
template <> struct is_proto_enum< ::android::server::location::GnssNiEncodingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::server::location::GnssNiEncodingType>() {
  return ::android::server::location::GnssNiEncodingType_descriptor();
}
template <> struct is_proto_enum< ::android::server::location::NfwProtocolStack> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::server::location::NfwProtocolStack>() {
  return ::android::server::location::NfwProtocolStack_descriptor();
}
template <> struct is_proto_enum< ::android::server::location::NfwRequestor> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::server::location::NfwRequestor>() {
  return ::android::server::location::NfwRequestor_descriptor();
}
template <> struct is_proto_enum< ::android::server::location::NfwResponseType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::server::location::NfwResponseType>() {
  return ::android::server::location::NfwResponseType_descriptor();
}
template <> struct is_proto_enum< ::android::server::location::SuplMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::server::location::SuplMode>() {
  return ::android::server::location::SuplMode_descriptor();
}
template <> struct is_proto_enum< ::android::server::location::LppProfile> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::server::location::LppProfile>() {
  return ::android::server::location::LppProfile_descriptor();
}
template <> struct is_proto_enum< ::android::server::location::GlonassPosProtocol> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::server::location::GlonassPosProtocol>() {
  return ::android::server::location::GlonassPosProtocol_descriptor();
}
template <> struct is_proto_enum< ::android::server::location::GpsLock> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::server::location::GpsLock>() {
  return ::android::server::location::GpsLock_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fserver_2flocation_2fenums_2eproto
