// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/stats/location/location_enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2flocation_2flocation_5fenums_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2flocation_2flocation_5fenums_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2flocation_2flocation_5fenums_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2flocation_2flocation_5fenums_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2flocation_2flocation_5fenums_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace android {
namespace stats {
namespace location {

enum LocationManagerServiceApi : int {
  API_UNKNOWN = 0,
  API_REQUEST_LOCATION_UPDATES = 1,
  API_ADD_GNSS_MEASUREMENTS_LISTENER = 2,
  API_REGISTER_GNSS_STATUS_CALLBACK = 3,
  API_REQUEST_GEOFENCE = 4,
  API_SEND_EXTRA_COMMAND = 5
};
bool LocationManagerServiceApi_IsValid(int value);
constexpr LocationManagerServiceApi LocationManagerServiceApi_MIN = API_UNKNOWN;
constexpr LocationManagerServiceApi LocationManagerServiceApi_MAX = API_SEND_EXTRA_COMMAND;
constexpr int LocationManagerServiceApi_ARRAYSIZE = LocationManagerServiceApi_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LocationManagerServiceApi_descriptor();
template<typename T>
inline const std::string& LocationManagerServiceApi_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LocationManagerServiceApi>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LocationManagerServiceApi_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LocationManagerServiceApi_descriptor(), enum_t_value);
}
inline bool LocationManagerServiceApi_Parse(
    const std::string& name, LocationManagerServiceApi* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LocationManagerServiceApi>(
    LocationManagerServiceApi_descriptor(), name, value);
}
enum UsageState : int {
  USAGE_STARTED = 0,
  USAGE_ENDED = 1
};
bool UsageState_IsValid(int value);
constexpr UsageState UsageState_MIN = USAGE_STARTED;
constexpr UsageState UsageState_MAX = USAGE_ENDED;
constexpr int UsageState_ARRAYSIZE = UsageState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UsageState_descriptor();
template<typename T>
inline const std::string& UsageState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UsageState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UsageState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UsageState_descriptor(), enum_t_value);
}
inline bool UsageState_Parse(
    const std::string& name, UsageState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UsageState>(
    UsageState_descriptor(), name, value);
}
enum ProviderType : int {
  PROVIDER_UNKNOWN = 0,
  PROVIDER_NETWORK = 1,
  PROVIDER_GPS = 2,
  PROVIDER_PASSIVE = 3,
  PROVIDER_FUSED = 4
};
bool ProviderType_IsValid(int value);
constexpr ProviderType ProviderType_MIN = PROVIDER_UNKNOWN;
constexpr ProviderType ProviderType_MAX = PROVIDER_FUSED;
constexpr int ProviderType_ARRAYSIZE = ProviderType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProviderType_descriptor();
template<typename T>
inline const std::string& ProviderType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProviderType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProviderType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProviderType_descriptor(), enum_t_value);
}
inline bool ProviderType_Parse(
    const std::string& name, ProviderType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProviderType>(
    ProviderType_descriptor(), name, value);
}
enum CallbackType : int {
  CALLBACK_UNKNOWN = 0,
  CALLBACK_NOT_APPLICABLE = 1,
  CALLBACK_LISTENER = 2,
  CALLBACK_PENDING_INTENT = 3
};
bool CallbackType_IsValid(int value);
constexpr CallbackType CallbackType_MIN = CALLBACK_UNKNOWN;
constexpr CallbackType CallbackType_MAX = CALLBACK_PENDING_INTENT;
constexpr int CallbackType_ARRAYSIZE = CallbackType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CallbackType_descriptor();
template<typename T>
inline const std::string& CallbackType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CallbackType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CallbackType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CallbackType_descriptor(), enum_t_value);
}
inline bool CallbackType_Parse(
    const std::string& name, CallbackType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CallbackType>(
    CallbackType_descriptor(), name, value);
}
enum LocationRequestQuality : int {
  QUALITY_UNKNOWN = 0,
  ACCURACY_FINE = 100,
  ACCURACY_BLOCK = 102,
  ACCURACY_CITY = 104,
  POWER_NONE = 200,
  POWER_LOW = 201,
  POWER_HIGH = 203
};
bool LocationRequestQuality_IsValid(int value);
constexpr LocationRequestQuality LocationRequestQuality_MIN = QUALITY_UNKNOWN;
constexpr LocationRequestQuality LocationRequestQuality_MAX = POWER_HIGH;
constexpr int LocationRequestQuality_ARRAYSIZE = LocationRequestQuality_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LocationRequestQuality_descriptor();
template<typename T>
inline const std::string& LocationRequestQuality_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LocationRequestQuality>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LocationRequestQuality_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LocationRequestQuality_descriptor(), enum_t_value);
}
inline bool LocationRequestQuality_Parse(
    const std::string& name, LocationRequestQuality* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LocationRequestQuality>(
    LocationRequestQuality_descriptor(), name, value);
}
enum LocationRequestIntervalBucket : int {
  INTERVAL_UNKNOWN = 0,
  INTERVAL_BETWEEN_0_SEC_AND_1_SEC = 1,
  INTERVAL_BETWEEN_1_SEC_AND_5_SEC = 2,
  INTERVAL_BETWEEN_5_SEC_AND_1_MIN = 3,
  INTERVAL_BETWEEN_1_MIN_AND_10_MIN = 4,
  INTERVAL_BETWEEN_10_MIN_AND_1_HOUR = 5,
  INTERVAL_LARGER_THAN_1_HOUR = 6
};
bool LocationRequestIntervalBucket_IsValid(int value);
constexpr LocationRequestIntervalBucket LocationRequestIntervalBucket_MIN = INTERVAL_UNKNOWN;
constexpr LocationRequestIntervalBucket LocationRequestIntervalBucket_MAX = INTERVAL_LARGER_THAN_1_HOUR;
constexpr int LocationRequestIntervalBucket_ARRAYSIZE = LocationRequestIntervalBucket_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LocationRequestIntervalBucket_descriptor();
template<typename T>
inline const std::string& LocationRequestIntervalBucket_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LocationRequestIntervalBucket>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LocationRequestIntervalBucket_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LocationRequestIntervalBucket_descriptor(), enum_t_value);
}
inline bool LocationRequestIntervalBucket_Parse(
    const std::string& name, LocationRequestIntervalBucket* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LocationRequestIntervalBucket>(
    LocationRequestIntervalBucket_descriptor(), name, value);
}
enum SmallestDisplacementBucket : int {
  DISTANCE_UNKNOWN = 0,
  DISTANCE_ZERO = 1,
  DISTANCE_BETWEEN_0_AND_100 = 2,
  DISTANCE_LARGER_THAN_100 = 3
};
bool SmallestDisplacementBucket_IsValid(int value);
constexpr SmallestDisplacementBucket SmallestDisplacementBucket_MIN = DISTANCE_UNKNOWN;
constexpr SmallestDisplacementBucket SmallestDisplacementBucket_MAX = DISTANCE_LARGER_THAN_100;
constexpr int SmallestDisplacementBucket_ARRAYSIZE = SmallestDisplacementBucket_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SmallestDisplacementBucket_descriptor();
template<typename T>
inline const std::string& SmallestDisplacementBucket_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SmallestDisplacementBucket>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SmallestDisplacementBucket_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SmallestDisplacementBucket_descriptor(), enum_t_value);
}
inline bool SmallestDisplacementBucket_Parse(
    const std::string& name, SmallestDisplacementBucket* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SmallestDisplacementBucket>(
    SmallestDisplacementBucket_descriptor(), name, value);
}
enum ExpirationBucket : int {
  EXPIRATION_UNKNOWN = 0,
  EXPIRATION_BETWEEN_0_AND_20_SEC = 1,
  EXPIRATION_BETWEEN_20_SEC_AND_1_MIN = 2,
  EXPIRATION_BETWEEN_1_MIN_AND_10_MIN = 3,
  EXPIRATION_BETWEEN_10_MIN_AND_1_HOUR = 4,
  EXPIRATION_LARGER_THAN_1_HOUR = 5,
  EXPIRATION_NO_EXPIRY = 6
};
bool ExpirationBucket_IsValid(int value);
constexpr ExpirationBucket ExpirationBucket_MIN = EXPIRATION_UNKNOWN;
constexpr ExpirationBucket ExpirationBucket_MAX = EXPIRATION_NO_EXPIRY;
constexpr int ExpirationBucket_ARRAYSIZE = ExpirationBucket_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExpirationBucket_descriptor();
template<typename T>
inline const std::string& ExpirationBucket_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExpirationBucket>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExpirationBucket_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ExpirationBucket_descriptor(), enum_t_value);
}
inline bool ExpirationBucket_Parse(
    const std::string& name, ExpirationBucket* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ExpirationBucket>(
    ExpirationBucket_descriptor(), name, value);
}
enum GeofenceRadiusBucket : int {
  RADIUS_UNKNOWN = 0,
  RADIUS_BETWEEN_0_AND_100 = 1,
  RADIUS_BETWEEN_100_AND_200 = 2,
  RADIUS_BETWEEN_200_AND_300 = 3,
  RADIUS_BETWEEN_300_AND_1000 = 4,
  RADIUS_BETWEEN_1000_AND_10000 = 5,
  RADIUS_LARGER_THAN_100000 = 6,
  RADIUS_NEGATIVE = 7
};
bool GeofenceRadiusBucket_IsValid(int value);
constexpr GeofenceRadiusBucket GeofenceRadiusBucket_MIN = RADIUS_UNKNOWN;
constexpr GeofenceRadiusBucket GeofenceRadiusBucket_MAX = RADIUS_NEGATIVE;
constexpr int GeofenceRadiusBucket_ARRAYSIZE = GeofenceRadiusBucket_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GeofenceRadiusBucket_descriptor();
template<typename T>
inline const std::string& GeofenceRadiusBucket_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GeofenceRadiusBucket>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GeofenceRadiusBucket_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GeofenceRadiusBucket_descriptor(), enum_t_value);
}
inline bool GeofenceRadiusBucket_Parse(
    const std::string& name, GeofenceRadiusBucket* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GeofenceRadiusBucket>(
    GeofenceRadiusBucket_descriptor(), name, value);
}
enum ActivityImportance : int {
  IMPORTANCE_UNKNOWN = 0,
  IMPORTANCE_TOP = 1,
  IMPORTANCE_FORGROUND_SERVICE = 2,
  IMPORTANCE_BACKGROUND = 3
};
bool ActivityImportance_IsValid(int value);
constexpr ActivityImportance ActivityImportance_MIN = IMPORTANCE_UNKNOWN;
constexpr ActivityImportance ActivityImportance_MAX = IMPORTANCE_BACKGROUND;
constexpr int ActivityImportance_ARRAYSIZE = ActivityImportance_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActivityImportance_descriptor();
template<typename T>
inline const std::string& ActivityImportance_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActivityImportance>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActivityImportance_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActivityImportance_descriptor(), enum_t_value);
}
inline bool ActivityImportance_Parse(
    const std::string& name, ActivityImportance* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActivityImportance>(
    ActivityImportance_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace location
}  // namespace stats
}  // namespace android

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::android::stats::location::LocationManagerServiceApi> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::location::LocationManagerServiceApi>() {
  return ::android::stats::location::LocationManagerServiceApi_descriptor();
}
template <> struct is_proto_enum< ::android::stats::location::UsageState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::location::UsageState>() {
  return ::android::stats::location::UsageState_descriptor();
}
template <> struct is_proto_enum< ::android::stats::location::ProviderType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::location::ProviderType>() {
  return ::android::stats::location::ProviderType_descriptor();
}
template <> struct is_proto_enum< ::android::stats::location::CallbackType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::location::CallbackType>() {
  return ::android::stats::location::CallbackType_descriptor();
}
template <> struct is_proto_enum< ::android::stats::location::LocationRequestQuality> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::location::LocationRequestQuality>() {
  return ::android::stats::location::LocationRequestQuality_descriptor();
}
template <> struct is_proto_enum< ::android::stats::location::LocationRequestIntervalBucket> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::location::LocationRequestIntervalBucket>() {
  return ::android::stats::location::LocationRequestIntervalBucket_descriptor();
}
template <> struct is_proto_enum< ::android::stats::location::SmallestDisplacementBucket> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::location::SmallestDisplacementBucket>() {
  return ::android::stats::location::SmallestDisplacementBucket_descriptor();
}
template <> struct is_proto_enum< ::android::stats::location::ExpirationBucket> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::location::ExpirationBucket>() {
  return ::android::stats::location::ExpirationBucket_descriptor();
}
template <> struct is_proto_enum< ::android::stats::location::GeofenceRadiusBucket> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::location::GeofenceRadiusBucket>() {
  return ::android::stats::location::GeofenceRadiusBucket_descriptor();
}
template <> struct is_proto_enum< ::android::stats::location::ActivityImportance> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::location::ActivityImportance>() {
  return ::android::stats::location::ActivityImportance_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2flocation_2flocation_5fenums_2eproto
