// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/bluetooth/enums.proto

#include "frameworks/proto_logging/stats/enums/bluetooth/enums.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
namespace android {
namespace bluetooth {
}  // namespace bluetooth
}  // namespace android
namespace android {
namespace bluetooth {
bool ConnectionStateEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ConnectionStateEnum_strings[4] = {};

static const char ConnectionStateEnum_names[] =
  "CONNECTION_STATE_CONNECTED"
  "CONNECTION_STATE_CONNECTING"
  "CONNECTION_STATE_DISCONNECTED"
  "CONNECTION_STATE_DISCONNECTING";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ConnectionStateEnum_entries[] = {
  { {ConnectionStateEnum_names + 0, 26}, 2 },
  { {ConnectionStateEnum_names + 26, 27}, 1 },
  { {ConnectionStateEnum_names + 53, 29}, 0 },
  { {ConnectionStateEnum_names + 82, 30}, 3 },
};

static const int ConnectionStateEnum_entries_by_number[] = {
  2, // 0 -> CONNECTION_STATE_DISCONNECTED
  1, // 1 -> CONNECTION_STATE_CONNECTING
  0, // 2 -> CONNECTION_STATE_CONNECTED
  3, // 3 -> CONNECTION_STATE_DISCONNECTING
};

const std::string& ConnectionStateEnum_Name(
    ConnectionStateEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ConnectionStateEnum_entries,
          ConnectionStateEnum_entries_by_number,
          4, ConnectionStateEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ConnectionStateEnum_entries,
      ConnectionStateEnum_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ConnectionStateEnum_strings[idx].get();
}
bool ConnectionStateEnum_Parse(
    const std::string& name, ConnectionStateEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ConnectionStateEnum_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ConnectionStateEnum>(int_value);
  }
  return success;
}
bool EnableDisableReasonEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EnableDisableReasonEnum_strings[12] = {};

static const char EnableDisableReasonEnum_names[] =
  "ENABLE_DISABLE_REASON_AIRPLANE_MODE"
  "ENABLE_DISABLE_REASON_APPLICATION_REQUEST"
  "ENABLE_DISABLE_REASON_CRASH"
  "ENABLE_DISABLE_REASON_DISALLOWED"
  "ENABLE_DISABLE_REASON_FACTORY_RESET"
  "ENABLE_DISABLE_REASON_INIT_FLAGS_CHANGED"
  "ENABLE_DISABLE_REASON_RESTARTED"
  "ENABLE_DISABLE_REASON_RESTORE_USER_SETTING"
  "ENABLE_DISABLE_REASON_START_ERROR"
  "ENABLE_DISABLE_REASON_SYSTEM_BOOT"
  "ENABLE_DISABLE_REASON_UNSPECIFIED"
  "ENABLE_DISABLE_REASON_USER_SWITCH";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EnableDisableReasonEnum_entries[] = {
  { {EnableDisableReasonEnum_names + 0, 35}, 2 },
  { {EnableDisableReasonEnum_names + 35, 41}, 1 },
  { {EnableDisableReasonEnum_names + 76, 27}, 7 },
  { {EnableDisableReasonEnum_names + 103, 32}, 3 },
  { {EnableDisableReasonEnum_names + 135, 35}, 10 },
  { {EnableDisableReasonEnum_names + 170, 40}, 11 },
  { {EnableDisableReasonEnum_names + 210, 31}, 4 },
  { {EnableDisableReasonEnum_names + 241, 42}, 9 },
  { {EnableDisableReasonEnum_names + 283, 33}, 5 },
  { {EnableDisableReasonEnum_names + 316, 33}, 6 },
  { {EnableDisableReasonEnum_names + 349, 33}, 0 },
  { {EnableDisableReasonEnum_names + 382, 33}, 8 },
};

static const int EnableDisableReasonEnum_entries_by_number[] = {
  10, // 0 -> ENABLE_DISABLE_REASON_UNSPECIFIED
  1, // 1 -> ENABLE_DISABLE_REASON_APPLICATION_REQUEST
  0, // 2 -> ENABLE_DISABLE_REASON_AIRPLANE_MODE
  3, // 3 -> ENABLE_DISABLE_REASON_DISALLOWED
  6, // 4 -> ENABLE_DISABLE_REASON_RESTARTED
  8, // 5 -> ENABLE_DISABLE_REASON_START_ERROR
  9, // 6 -> ENABLE_DISABLE_REASON_SYSTEM_BOOT
  2, // 7 -> ENABLE_DISABLE_REASON_CRASH
  11, // 8 -> ENABLE_DISABLE_REASON_USER_SWITCH
  7, // 9 -> ENABLE_DISABLE_REASON_RESTORE_USER_SETTING
  4, // 10 -> ENABLE_DISABLE_REASON_FACTORY_RESET
  5, // 11 -> ENABLE_DISABLE_REASON_INIT_FLAGS_CHANGED
};

const std::string& EnableDisableReasonEnum_Name(
    EnableDisableReasonEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EnableDisableReasonEnum_entries,
          EnableDisableReasonEnum_entries_by_number,
          12, EnableDisableReasonEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EnableDisableReasonEnum_entries,
      EnableDisableReasonEnum_entries_by_number,
      12, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EnableDisableReasonEnum_strings[idx].get();
}
bool EnableDisableReasonEnum_Parse(
    const std::string& name, EnableDisableReasonEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EnableDisableReasonEnum_entries, 12, name, &int_value);
  if (success) {
    *value = static_cast<EnableDisableReasonEnum>(int_value);
  }
  return success;
}
bool DirectionEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DirectionEnum_strings[3] = {};

static const char DirectionEnum_names[] =
  "DIRECTION_INCOMING"
  "DIRECTION_OUTGOING"
  "DIRECTION_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DirectionEnum_entries[] = {
  { {DirectionEnum_names + 0, 18}, 2 },
  { {DirectionEnum_names + 18, 18}, 1 },
  { {DirectionEnum_names + 36, 17}, 0 },
};

static const int DirectionEnum_entries_by_number[] = {
  2, // 0 -> DIRECTION_UNKNOWN
  1, // 1 -> DIRECTION_OUTGOING
  0, // 2 -> DIRECTION_INCOMING
};

const std::string& DirectionEnum_Name(
    DirectionEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DirectionEnum_entries,
          DirectionEnum_entries_by_number,
          3, DirectionEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DirectionEnum_entries,
      DirectionEnum_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DirectionEnum_strings[idx].get();
}
bool DirectionEnum_Parse(
    const std::string& name, DirectionEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DirectionEnum_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<DirectionEnum>(int_value);
  }
  return success;
}
bool LinkTypeEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4095:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LinkTypeEnum_strings[4] = {};

static const char LinkTypeEnum_names[] =
  "LINK_TYPE_ACL"
  "LINK_TYPE_ESCO"
  "LINK_TYPE_SCO"
  "LINK_TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LinkTypeEnum_entries[] = {
  { {LinkTypeEnum_names + 0, 13}, 1 },
  { {LinkTypeEnum_names + 13, 14}, 2 },
  { {LinkTypeEnum_names + 27, 13}, 0 },
  { {LinkTypeEnum_names + 40, 17}, 4095 },
};

static const int LinkTypeEnum_entries_by_number[] = {
  2, // 0 -> LINK_TYPE_SCO
  0, // 1 -> LINK_TYPE_ACL
  1, // 2 -> LINK_TYPE_ESCO
  3, // 4095 -> LINK_TYPE_UNKNOWN
};

const std::string& LinkTypeEnum_Name(
    LinkTypeEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LinkTypeEnum_entries,
          LinkTypeEnum_entries_by_number,
          4, LinkTypeEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LinkTypeEnum_entries,
      LinkTypeEnum_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LinkTypeEnum_strings[idx].get();
}
bool LinkTypeEnum_Parse(
    const std::string& name, LinkTypeEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LinkTypeEnum_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<LinkTypeEnum>(int_value);
  }
  return success;
}
bool DeviceInfoSrcEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceInfoSrcEnum_strings[3] = {};

static const char DeviceInfoSrcEnum_names[] =
  "DEVICE_INFO_EXTERNAL"
  "DEVICE_INFO_INTERNAL"
  "DEVICE_INFO_SRC_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceInfoSrcEnum_entries[] = {
  { {DeviceInfoSrcEnum_names + 0, 20}, 2 },
  { {DeviceInfoSrcEnum_names + 20, 20}, 1 },
  { {DeviceInfoSrcEnum_names + 40, 23}, 0 },
};

static const int DeviceInfoSrcEnum_entries_by_number[] = {
  2, // 0 -> DEVICE_INFO_SRC_UNKNOWN
  1, // 1 -> DEVICE_INFO_INTERNAL
  0, // 2 -> DEVICE_INFO_EXTERNAL
};

const std::string& DeviceInfoSrcEnum_Name(
    DeviceInfoSrcEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceInfoSrcEnum_entries,
          DeviceInfoSrcEnum_entries_by_number,
          3, DeviceInfoSrcEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceInfoSrcEnum_entries,
      DeviceInfoSrcEnum_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceInfoSrcEnum_strings[idx].get();
}
bool DeviceInfoSrcEnum_Parse(
    const std::string& name, DeviceInfoSrcEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceInfoSrcEnum_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<DeviceInfoSrcEnum>(int_value);
  }
  return success;
}
bool DeviceTypeEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceTypeEnum_strings[4] = {};

static const char DeviceTypeEnum_names[] =
  "DEVICE_TYPE_CLASSIC"
  "DEVICE_TYPE_DUAL"
  "DEVICE_TYPE_LE"
  "DEVICE_TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceTypeEnum_entries[] = {
  { {DeviceTypeEnum_names + 0, 19}, 1 },
  { {DeviceTypeEnum_names + 19, 16}, 3 },
  { {DeviceTypeEnum_names + 35, 14}, 2 },
  { {DeviceTypeEnum_names + 49, 19}, 0 },
};

static const int DeviceTypeEnum_entries_by_number[] = {
  3, // 0 -> DEVICE_TYPE_UNKNOWN
  0, // 1 -> DEVICE_TYPE_CLASSIC
  2, // 2 -> DEVICE_TYPE_LE
  1, // 3 -> DEVICE_TYPE_DUAL
};

const std::string& DeviceTypeEnum_Name(
    DeviceTypeEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceTypeEnum_entries,
          DeviceTypeEnum_entries_by_number,
          4, DeviceTypeEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceTypeEnum_entries,
      DeviceTypeEnum_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceTypeEnum_strings[idx].get();
}
bool DeviceTypeEnum_Parse(
    const std::string& name, DeviceTypeEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceTypeEnum_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DeviceTypeEnum>(int_value);
  }
  return success;
}
bool TransportTypeEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TransportTypeEnum_strings[3] = {};

static const char TransportTypeEnum_names[] =
  "TRANSPORT_TYPE_AUTO"
  "TRANSPORT_TYPE_BREDR"
  "TRANSPORT_TYPE_LE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TransportTypeEnum_entries[] = {
  { {TransportTypeEnum_names + 0, 19}, 0 },
  { {TransportTypeEnum_names + 19, 20}, 1 },
  { {TransportTypeEnum_names + 39, 17}, 2 },
};

static const int TransportTypeEnum_entries_by_number[] = {
  0, // 0 -> TRANSPORT_TYPE_AUTO
  1, // 1 -> TRANSPORT_TYPE_BREDR
  2, // 2 -> TRANSPORT_TYPE_LE
};

const std::string& TransportTypeEnum_Name(
    TransportTypeEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TransportTypeEnum_entries,
          TransportTypeEnum_entries_by_number,
          3, TransportTypeEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TransportTypeEnum_entries,
      TransportTypeEnum_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TransportTypeEnum_strings[idx].get();
}
bool TransportTypeEnum_Parse(
    const std::string& name, TransportTypeEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TransportTypeEnum_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<TransportTypeEnum>(int_value);
  }
  return success;
}
bool BondStateEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BondStateEnum_strings[4] = {};

static const char BondStateEnum_names[] =
  "BOND_STATE_BONDED"
  "BOND_STATE_BONDING"
  "BOND_STATE_NONE"
  "BOND_STATE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BondStateEnum_entries[] = {
  { {BondStateEnum_names + 0, 17}, 12 },
  { {BondStateEnum_names + 17, 18}, 11 },
  { {BondStateEnum_names + 35, 15}, 10 },
  { {BondStateEnum_names + 50, 18}, 0 },
};

static const int BondStateEnum_entries_by_number[] = {
  3, // 0 -> BOND_STATE_UNKNOWN
  2, // 10 -> BOND_STATE_NONE
  1, // 11 -> BOND_STATE_BONDING
  0, // 12 -> BOND_STATE_BONDED
};

const std::string& BondStateEnum_Name(
    BondStateEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BondStateEnum_entries,
          BondStateEnum_entries_by_number,
          4, BondStateEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BondStateEnum_entries,
      BondStateEnum_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BondStateEnum_strings[idx].get();
}
bool BondStateEnum_Parse(
    const std::string& name, BondStateEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BondStateEnum_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<BondStateEnum>(int_value);
  }
  return success;
}
bool BondSubStateEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BondSubStateEnum_strings[6] = {};

static const char BondSubStateEnum_names[] =
  "BOND_SUB_STATE_LOCAL_OOB_DATA_PROVIDED"
  "BOND_SUB_STATE_LOCAL_PIN_REPLIED"
  "BOND_SUB_STATE_LOCAL_PIN_REQUESTED"
  "BOND_SUB_STATE_LOCAL_SSP_REPLIED"
  "BOND_SUB_STATE_LOCAL_SSP_REQUESTED"
  "BOND_SUB_STATE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BondSubStateEnum_entries[] = {
  { {BondSubStateEnum_names + 0, 38}, 1 },
  { {BondSubStateEnum_names + 38, 32}, 3 },
  { {BondSubStateEnum_names + 70, 34}, 2 },
  { {BondSubStateEnum_names + 104, 32}, 5 },
  { {BondSubStateEnum_names + 136, 34}, 4 },
  { {BondSubStateEnum_names + 170, 22}, 0 },
};

static const int BondSubStateEnum_entries_by_number[] = {
  5, // 0 -> BOND_SUB_STATE_UNKNOWN
  0, // 1 -> BOND_SUB_STATE_LOCAL_OOB_DATA_PROVIDED
  2, // 2 -> BOND_SUB_STATE_LOCAL_PIN_REQUESTED
  1, // 3 -> BOND_SUB_STATE_LOCAL_PIN_REPLIED
  4, // 4 -> BOND_SUB_STATE_LOCAL_SSP_REQUESTED
  3, // 5 -> BOND_SUB_STATE_LOCAL_SSP_REPLIED
};

const std::string& BondSubStateEnum_Name(
    BondSubStateEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BondSubStateEnum_entries,
          BondSubStateEnum_entries_by_number,
          6, BondSubStateEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BondSubStateEnum_entries,
      BondSubStateEnum_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BondSubStateEnum_strings[idx].get();
}
bool BondSubStateEnum_Parse(
    const std::string& name, BondSubStateEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BondSubStateEnum_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<BondSubStateEnum>(int_value);
  }
  return success;
}
bool UnbondReasonEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UnbondReasonEnum_strings[10] = {};

static const char UnbondReasonEnum_names[] =
  "UNBOND_REASON_AUTH_CANCELED"
  "UNBOND_REASON_AUTH_FAILED"
  "UNBOND_REASON_AUTH_REJECTED"
  "UNBOND_REASON_AUTH_TIMEOUT"
  "UNBOND_REASON_DISCOVERY_IN_PROGRESS"
  "UNBOND_REASON_REMOTE_AUTH_CANCELED"
  "UNBOND_REASON_REMOTE_DEVICE_DOWN"
  "UNBOND_REASON_REMOVED"
  "UNBOND_REASON_REPEATED_ATTEMPTS"
  "UNBOND_REASON_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UnbondReasonEnum_entries[] = {
  { {UnbondReasonEnum_names + 0, 27}, 3 },
  { {UnbondReasonEnum_names + 27, 25}, 1 },
  { {UnbondReasonEnum_names + 52, 27}, 2 },
  { {UnbondReasonEnum_names + 79, 26}, 6 },
  { {UnbondReasonEnum_names + 105, 35}, 5 },
  { {UnbondReasonEnum_names + 140, 34}, 8 },
  { {UnbondReasonEnum_names + 174, 32}, 4 },
  { {UnbondReasonEnum_names + 206, 21}, 9 },
  { {UnbondReasonEnum_names + 227, 31}, 7 },
  { {UnbondReasonEnum_names + 258, 21}, 0 },
};

static const int UnbondReasonEnum_entries_by_number[] = {
  9, // 0 -> UNBOND_REASON_UNKNOWN
  1, // 1 -> UNBOND_REASON_AUTH_FAILED
  2, // 2 -> UNBOND_REASON_AUTH_REJECTED
  0, // 3 -> UNBOND_REASON_AUTH_CANCELED
  6, // 4 -> UNBOND_REASON_REMOTE_DEVICE_DOWN
  4, // 5 -> UNBOND_REASON_DISCOVERY_IN_PROGRESS
  3, // 6 -> UNBOND_REASON_AUTH_TIMEOUT
  8, // 7 -> UNBOND_REASON_REPEATED_ATTEMPTS
  5, // 8 -> UNBOND_REASON_REMOTE_AUTH_CANCELED
  7, // 9 -> UNBOND_REASON_REMOVED
};

const std::string& UnbondReasonEnum_Name(
    UnbondReasonEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UnbondReasonEnum_entries,
          UnbondReasonEnum_entries_by_number,
          10, UnbondReasonEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UnbondReasonEnum_entries,
      UnbondReasonEnum_entries_by_number,
      10, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UnbondReasonEnum_strings[idx].get();
}
bool UnbondReasonEnum_Parse(
    const std::string& name, UnbondReasonEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UnbondReasonEnum_entries, 10, name, &int_value);
  if (success) {
    *value = static_cast<UnbondReasonEnum>(int_value);
  }
  return success;
}
bool SocketTypeEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SocketTypeEnum_strings[5] = {};

static const char SocketTypeEnum_names[] =
  "SOCKET_TYPE_L2CAP_BREDR"
  "SOCKET_TYPE_L2CAP_LE"
  "SOCKET_TYPE_RFCOMM"
  "SOCKET_TYPE_SCO"
  "SOCKET_TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SocketTypeEnum_entries[] = {
  { {SocketTypeEnum_names + 0, 23}, 3 },
  { {SocketTypeEnum_names + 23, 20}, 4 },
  { {SocketTypeEnum_names + 43, 18}, 1 },
  { {SocketTypeEnum_names + 61, 15}, 2 },
  { {SocketTypeEnum_names + 76, 19}, 0 },
};

static const int SocketTypeEnum_entries_by_number[] = {
  4, // 0 -> SOCKET_TYPE_UNKNOWN
  2, // 1 -> SOCKET_TYPE_RFCOMM
  3, // 2 -> SOCKET_TYPE_SCO
  0, // 3 -> SOCKET_TYPE_L2CAP_BREDR
  1, // 4 -> SOCKET_TYPE_L2CAP_LE
};

const std::string& SocketTypeEnum_Name(
    SocketTypeEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SocketTypeEnum_entries,
          SocketTypeEnum_entries_by_number,
          5, SocketTypeEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SocketTypeEnum_entries,
      SocketTypeEnum_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SocketTypeEnum_strings[idx].get();
}
bool SocketTypeEnum_Parse(
    const std::string& name, SocketTypeEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SocketTypeEnum_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<SocketTypeEnum>(int_value);
  }
  return success;
}
bool SocketConnectionstateEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SocketConnectionstateEnum_strings[6] = {};

static const char SocketConnectionstateEnum_names[] =
  "SOCKET_CONNECTION_STATE_CONNECTED"
  "SOCKET_CONNECTION_STATE_CONNECTING"
  "SOCKET_CONNECTION_STATE_DISCONNECTED"
  "SOCKET_CONNECTION_STATE_DISCONNECTING"
  "SOCKET_CONNECTION_STATE_LISTENING"
  "SOCKET_CONNECTION_STATE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SocketConnectionstateEnum_entries[] = {
  { {SocketConnectionstateEnum_names + 0, 33}, 3 },
  { {SocketConnectionstateEnum_names + 33, 34}, 2 },
  { {SocketConnectionstateEnum_names + 67, 36}, 5 },
  { {SocketConnectionstateEnum_names + 103, 37}, 4 },
  { {SocketConnectionstateEnum_names + 140, 33}, 1 },
  { {SocketConnectionstateEnum_names + 173, 31}, 0 },
};

static const int SocketConnectionstateEnum_entries_by_number[] = {
  5, // 0 -> SOCKET_CONNECTION_STATE_UNKNOWN
  4, // 1 -> SOCKET_CONNECTION_STATE_LISTENING
  1, // 2 -> SOCKET_CONNECTION_STATE_CONNECTING
  0, // 3 -> SOCKET_CONNECTION_STATE_CONNECTED
  3, // 4 -> SOCKET_CONNECTION_STATE_DISCONNECTING
  2, // 5 -> SOCKET_CONNECTION_STATE_DISCONNECTED
};

const std::string& SocketConnectionstateEnum_Name(
    SocketConnectionstateEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SocketConnectionstateEnum_entries,
          SocketConnectionstateEnum_entries_by_number,
          6, SocketConnectionstateEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SocketConnectionstateEnum_entries,
      SocketConnectionstateEnum_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SocketConnectionstateEnum_strings[idx].get();
}
bool SocketConnectionstateEnum_Parse(
    const std::string& name, SocketConnectionstateEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SocketConnectionstateEnum_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<SocketConnectionstateEnum>(int_value);
  }
  return success;
}
bool SocketRoleEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SocketRoleEnum_strings[3] = {};

static const char SocketRoleEnum_names[] =
  "SOCKET_ROLE_CONNECTION"
  "SOCKET_ROLE_LISTEN"
  "SOCKET_ROLE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SocketRoleEnum_entries[] = {
  { {SocketRoleEnum_names + 0, 22}, 2 },
  { {SocketRoleEnum_names + 22, 18}, 1 },
  { {SocketRoleEnum_names + 40, 19}, 0 },
};

static const int SocketRoleEnum_entries_by_number[] = {
  2, // 0 -> SOCKET_ROLE_UNKNOWN
  1, // 1 -> SOCKET_ROLE_LISTEN
  0, // 2 -> SOCKET_ROLE_CONNECTION
};

const std::string& SocketRoleEnum_Name(
    SocketRoleEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SocketRoleEnum_entries,
          SocketRoleEnum_entries_by_number,
          3, SocketRoleEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SocketRoleEnum_entries,
      SocketRoleEnum_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SocketRoleEnum_strings[idx].get();
}
bool SocketRoleEnum_Parse(
    const std::string& name, SocketRoleEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SocketRoleEnum_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<SocketRoleEnum>(int_value);
  }
  return success;
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace bluetooth
}  // namespace android
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
