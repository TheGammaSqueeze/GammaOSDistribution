// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/base/tools/aapt2/Configuration.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_frameworks_2fbase_2ftools_2faapt2_2fConfiguration_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_frameworks_2fbase_2ftools_2faapt2_2fConfiguration_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2ftools_2faapt2_2fConfiguration_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_frameworks_2fbase_2ftools_2faapt2_2fConfiguration_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_frameworks_2fbase_2ftools_2faapt2_2fConfiguration_2eproto;
namespace aapt {
namespace pb {
class Configuration;
class ConfigurationDefaultTypeInternal;
extern ConfigurationDefaultTypeInternal _Configuration_default_instance_;
}  // namespace pb
}  // namespace aapt
PROTOBUF_NAMESPACE_OPEN
template<> ::aapt::pb::Configuration* Arena::CreateMaybeMessage<::aapt::pb::Configuration>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace aapt {
namespace pb {

enum Configuration_LayoutDirection : int {
  Configuration_LayoutDirection_LAYOUT_DIRECTION_UNSET = 0,
  Configuration_LayoutDirection_LAYOUT_DIRECTION_LTR = 1,
  Configuration_LayoutDirection_LAYOUT_DIRECTION_RTL = 2,
  Configuration_LayoutDirection_Configuration_LayoutDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Configuration_LayoutDirection_Configuration_LayoutDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Configuration_LayoutDirection_IsValid(int value);
constexpr Configuration_LayoutDirection Configuration_LayoutDirection_LayoutDirection_MIN = Configuration_LayoutDirection_LAYOUT_DIRECTION_UNSET;
constexpr Configuration_LayoutDirection Configuration_LayoutDirection_LayoutDirection_MAX = Configuration_LayoutDirection_LAYOUT_DIRECTION_RTL;
constexpr int Configuration_LayoutDirection_LayoutDirection_ARRAYSIZE = Configuration_LayoutDirection_LayoutDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_LayoutDirection_descriptor();
template<typename T>
inline const std::string& Configuration_LayoutDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_LayoutDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_LayoutDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_LayoutDirection_descriptor(), enum_t_value);
}
inline bool Configuration_LayoutDirection_Parse(
    const std::string& name, Configuration_LayoutDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_LayoutDirection>(
    Configuration_LayoutDirection_descriptor(), name, value);
}
enum Configuration_ScreenLayoutSize : int {
  Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_UNSET = 0,
  Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_SMALL = 1,
  Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_NORMAL = 2,
  Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_LARGE = 3,
  Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_XLARGE = 4,
  Configuration_ScreenLayoutSize_Configuration_ScreenLayoutSize_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Configuration_ScreenLayoutSize_Configuration_ScreenLayoutSize_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Configuration_ScreenLayoutSize_IsValid(int value);
constexpr Configuration_ScreenLayoutSize Configuration_ScreenLayoutSize_ScreenLayoutSize_MIN = Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_UNSET;
constexpr Configuration_ScreenLayoutSize Configuration_ScreenLayoutSize_ScreenLayoutSize_MAX = Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_XLARGE;
constexpr int Configuration_ScreenLayoutSize_ScreenLayoutSize_ARRAYSIZE = Configuration_ScreenLayoutSize_ScreenLayoutSize_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_ScreenLayoutSize_descriptor();
template<typename T>
inline const std::string& Configuration_ScreenLayoutSize_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_ScreenLayoutSize>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_ScreenLayoutSize_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_ScreenLayoutSize_descriptor(), enum_t_value);
}
inline bool Configuration_ScreenLayoutSize_Parse(
    const std::string& name, Configuration_ScreenLayoutSize* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_ScreenLayoutSize>(
    Configuration_ScreenLayoutSize_descriptor(), name, value);
}
enum Configuration_ScreenLayoutLong : int {
  Configuration_ScreenLayoutLong_SCREEN_LAYOUT_LONG_UNSET = 0,
  Configuration_ScreenLayoutLong_SCREEN_LAYOUT_LONG_LONG = 1,
  Configuration_ScreenLayoutLong_SCREEN_LAYOUT_LONG_NOTLONG = 2,
  Configuration_ScreenLayoutLong_Configuration_ScreenLayoutLong_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Configuration_ScreenLayoutLong_Configuration_ScreenLayoutLong_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Configuration_ScreenLayoutLong_IsValid(int value);
constexpr Configuration_ScreenLayoutLong Configuration_ScreenLayoutLong_ScreenLayoutLong_MIN = Configuration_ScreenLayoutLong_SCREEN_LAYOUT_LONG_UNSET;
constexpr Configuration_ScreenLayoutLong Configuration_ScreenLayoutLong_ScreenLayoutLong_MAX = Configuration_ScreenLayoutLong_SCREEN_LAYOUT_LONG_NOTLONG;
constexpr int Configuration_ScreenLayoutLong_ScreenLayoutLong_ARRAYSIZE = Configuration_ScreenLayoutLong_ScreenLayoutLong_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_ScreenLayoutLong_descriptor();
template<typename T>
inline const std::string& Configuration_ScreenLayoutLong_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_ScreenLayoutLong>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_ScreenLayoutLong_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_ScreenLayoutLong_descriptor(), enum_t_value);
}
inline bool Configuration_ScreenLayoutLong_Parse(
    const std::string& name, Configuration_ScreenLayoutLong* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_ScreenLayoutLong>(
    Configuration_ScreenLayoutLong_descriptor(), name, value);
}
enum Configuration_ScreenRound : int {
  Configuration_ScreenRound_SCREEN_ROUND_UNSET = 0,
  Configuration_ScreenRound_SCREEN_ROUND_ROUND = 1,
  Configuration_ScreenRound_SCREEN_ROUND_NOTROUND = 2,
  Configuration_ScreenRound_Configuration_ScreenRound_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Configuration_ScreenRound_Configuration_ScreenRound_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Configuration_ScreenRound_IsValid(int value);
constexpr Configuration_ScreenRound Configuration_ScreenRound_ScreenRound_MIN = Configuration_ScreenRound_SCREEN_ROUND_UNSET;
constexpr Configuration_ScreenRound Configuration_ScreenRound_ScreenRound_MAX = Configuration_ScreenRound_SCREEN_ROUND_NOTROUND;
constexpr int Configuration_ScreenRound_ScreenRound_ARRAYSIZE = Configuration_ScreenRound_ScreenRound_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_ScreenRound_descriptor();
template<typename T>
inline const std::string& Configuration_ScreenRound_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_ScreenRound>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_ScreenRound_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_ScreenRound_descriptor(), enum_t_value);
}
inline bool Configuration_ScreenRound_Parse(
    const std::string& name, Configuration_ScreenRound* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_ScreenRound>(
    Configuration_ScreenRound_descriptor(), name, value);
}
enum Configuration_WideColorGamut : int {
  Configuration_WideColorGamut_WIDE_COLOR_GAMUT_UNSET = 0,
  Configuration_WideColorGamut_WIDE_COLOR_GAMUT_WIDECG = 1,
  Configuration_WideColorGamut_WIDE_COLOR_GAMUT_NOWIDECG = 2,
  Configuration_WideColorGamut_Configuration_WideColorGamut_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Configuration_WideColorGamut_Configuration_WideColorGamut_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Configuration_WideColorGamut_IsValid(int value);
constexpr Configuration_WideColorGamut Configuration_WideColorGamut_WideColorGamut_MIN = Configuration_WideColorGamut_WIDE_COLOR_GAMUT_UNSET;
constexpr Configuration_WideColorGamut Configuration_WideColorGamut_WideColorGamut_MAX = Configuration_WideColorGamut_WIDE_COLOR_GAMUT_NOWIDECG;
constexpr int Configuration_WideColorGamut_WideColorGamut_ARRAYSIZE = Configuration_WideColorGamut_WideColorGamut_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_WideColorGamut_descriptor();
template<typename T>
inline const std::string& Configuration_WideColorGamut_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_WideColorGamut>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_WideColorGamut_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_WideColorGamut_descriptor(), enum_t_value);
}
inline bool Configuration_WideColorGamut_Parse(
    const std::string& name, Configuration_WideColorGamut* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_WideColorGamut>(
    Configuration_WideColorGamut_descriptor(), name, value);
}
enum Configuration_Hdr : int {
  Configuration_Hdr_HDR_UNSET = 0,
  Configuration_Hdr_HDR_HIGHDR = 1,
  Configuration_Hdr_HDR_LOWDR = 2,
  Configuration_Hdr_Configuration_Hdr_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Configuration_Hdr_Configuration_Hdr_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Configuration_Hdr_IsValid(int value);
constexpr Configuration_Hdr Configuration_Hdr_Hdr_MIN = Configuration_Hdr_HDR_UNSET;
constexpr Configuration_Hdr Configuration_Hdr_Hdr_MAX = Configuration_Hdr_HDR_LOWDR;
constexpr int Configuration_Hdr_Hdr_ARRAYSIZE = Configuration_Hdr_Hdr_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_Hdr_descriptor();
template<typename T>
inline const std::string& Configuration_Hdr_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_Hdr>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_Hdr_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_Hdr_descriptor(), enum_t_value);
}
inline bool Configuration_Hdr_Parse(
    const std::string& name, Configuration_Hdr* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_Hdr>(
    Configuration_Hdr_descriptor(), name, value);
}
enum Configuration_Orientation : int {
  Configuration_Orientation_ORIENTATION_UNSET = 0,
  Configuration_Orientation_ORIENTATION_PORT = 1,
  Configuration_Orientation_ORIENTATION_LAND = 2,
  Configuration_Orientation_ORIENTATION_SQUARE = 3,
  Configuration_Orientation_Configuration_Orientation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Configuration_Orientation_Configuration_Orientation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Configuration_Orientation_IsValid(int value);
constexpr Configuration_Orientation Configuration_Orientation_Orientation_MIN = Configuration_Orientation_ORIENTATION_UNSET;
constexpr Configuration_Orientation Configuration_Orientation_Orientation_MAX = Configuration_Orientation_ORIENTATION_SQUARE;
constexpr int Configuration_Orientation_Orientation_ARRAYSIZE = Configuration_Orientation_Orientation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_Orientation_descriptor();
template<typename T>
inline const std::string& Configuration_Orientation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_Orientation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_Orientation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_Orientation_descriptor(), enum_t_value);
}
inline bool Configuration_Orientation_Parse(
    const std::string& name, Configuration_Orientation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_Orientation>(
    Configuration_Orientation_descriptor(), name, value);
}
enum Configuration_UiModeType : int {
  Configuration_UiModeType_UI_MODE_TYPE_UNSET = 0,
  Configuration_UiModeType_UI_MODE_TYPE_NORMAL = 1,
  Configuration_UiModeType_UI_MODE_TYPE_DESK = 2,
  Configuration_UiModeType_UI_MODE_TYPE_CAR = 3,
  Configuration_UiModeType_UI_MODE_TYPE_TELEVISION = 4,
  Configuration_UiModeType_UI_MODE_TYPE_APPLIANCE = 5,
  Configuration_UiModeType_UI_MODE_TYPE_WATCH = 6,
  Configuration_UiModeType_UI_MODE_TYPE_VRHEADSET = 7,
  Configuration_UiModeType_Configuration_UiModeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Configuration_UiModeType_Configuration_UiModeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Configuration_UiModeType_IsValid(int value);
constexpr Configuration_UiModeType Configuration_UiModeType_UiModeType_MIN = Configuration_UiModeType_UI_MODE_TYPE_UNSET;
constexpr Configuration_UiModeType Configuration_UiModeType_UiModeType_MAX = Configuration_UiModeType_UI_MODE_TYPE_VRHEADSET;
constexpr int Configuration_UiModeType_UiModeType_ARRAYSIZE = Configuration_UiModeType_UiModeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_UiModeType_descriptor();
template<typename T>
inline const std::string& Configuration_UiModeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_UiModeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_UiModeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_UiModeType_descriptor(), enum_t_value);
}
inline bool Configuration_UiModeType_Parse(
    const std::string& name, Configuration_UiModeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_UiModeType>(
    Configuration_UiModeType_descriptor(), name, value);
}
enum Configuration_UiModeNight : int {
  Configuration_UiModeNight_UI_MODE_NIGHT_UNSET = 0,
  Configuration_UiModeNight_UI_MODE_NIGHT_NIGHT = 1,
  Configuration_UiModeNight_UI_MODE_NIGHT_NOTNIGHT = 2,
  Configuration_UiModeNight_Configuration_UiModeNight_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Configuration_UiModeNight_Configuration_UiModeNight_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Configuration_UiModeNight_IsValid(int value);
constexpr Configuration_UiModeNight Configuration_UiModeNight_UiModeNight_MIN = Configuration_UiModeNight_UI_MODE_NIGHT_UNSET;
constexpr Configuration_UiModeNight Configuration_UiModeNight_UiModeNight_MAX = Configuration_UiModeNight_UI_MODE_NIGHT_NOTNIGHT;
constexpr int Configuration_UiModeNight_UiModeNight_ARRAYSIZE = Configuration_UiModeNight_UiModeNight_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_UiModeNight_descriptor();
template<typename T>
inline const std::string& Configuration_UiModeNight_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_UiModeNight>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_UiModeNight_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_UiModeNight_descriptor(), enum_t_value);
}
inline bool Configuration_UiModeNight_Parse(
    const std::string& name, Configuration_UiModeNight* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_UiModeNight>(
    Configuration_UiModeNight_descriptor(), name, value);
}
enum Configuration_Touchscreen : int {
  Configuration_Touchscreen_TOUCHSCREEN_UNSET = 0,
  Configuration_Touchscreen_TOUCHSCREEN_NOTOUCH = 1,
  Configuration_Touchscreen_TOUCHSCREEN_STYLUS = 2,
  Configuration_Touchscreen_TOUCHSCREEN_FINGER = 3,
  Configuration_Touchscreen_Configuration_Touchscreen_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Configuration_Touchscreen_Configuration_Touchscreen_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Configuration_Touchscreen_IsValid(int value);
constexpr Configuration_Touchscreen Configuration_Touchscreen_Touchscreen_MIN = Configuration_Touchscreen_TOUCHSCREEN_UNSET;
constexpr Configuration_Touchscreen Configuration_Touchscreen_Touchscreen_MAX = Configuration_Touchscreen_TOUCHSCREEN_FINGER;
constexpr int Configuration_Touchscreen_Touchscreen_ARRAYSIZE = Configuration_Touchscreen_Touchscreen_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_Touchscreen_descriptor();
template<typename T>
inline const std::string& Configuration_Touchscreen_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_Touchscreen>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_Touchscreen_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_Touchscreen_descriptor(), enum_t_value);
}
inline bool Configuration_Touchscreen_Parse(
    const std::string& name, Configuration_Touchscreen* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_Touchscreen>(
    Configuration_Touchscreen_descriptor(), name, value);
}
enum Configuration_KeysHidden : int {
  Configuration_KeysHidden_KEYS_HIDDEN_UNSET = 0,
  Configuration_KeysHidden_KEYS_HIDDEN_KEYSEXPOSED = 1,
  Configuration_KeysHidden_KEYS_HIDDEN_KEYSHIDDEN = 2,
  Configuration_KeysHidden_KEYS_HIDDEN_KEYSSOFT = 3,
  Configuration_KeysHidden_Configuration_KeysHidden_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Configuration_KeysHidden_Configuration_KeysHidden_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Configuration_KeysHidden_IsValid(int value);
constexpr Configuration_KeysHidden Configuration_KeysHidden_KeysHidden_MIN = Configuration_KeysHidden_KEYS_HIDDEN_UNSET;
constexpr Configuration_KeysHidden Configuration_KeysHidden_KeysHidden_MAX = Configuration_KeysHidden_KEYS_HIDDEN_KEYSSOFT;
constexpr int Configuration_KeysHidden_KeysHidden_ARRAYSIZE = Configuration_KeysHidden_KeysHidden_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_KeysHidden_descriptor();
template<typename T>
inline const std::string& Configuration_KeysHidden_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_KeysHidden>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_KeysHidden_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_KeysHidden_descriptor(), enum_t_value);
}
inline bool Configuration_KeysHidden_Parse(
    const std::string& name, Configuration_KeysHidden* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_KeysHidden>(
    Configuration_KeysHidden_descriptor(), name, value);
}
enum Configuration_Keyboard : int {
  Configuration_Keyboard_KEYBOARD_UNSET = 0,
  Configuration_Keyboard_KEYBOARD_NOKEYS = 1,
  Configuration_Keyboard_KEYBOARD_QWERTY = 2,
  Configuration_Keyboard_KEYBOARD_TWELVEKEY = 3,
  Configuration_Keyboard_Configuration_Keyboard_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Configuration_Keyboard_Configuration_Keyboard_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Configuration_Keyboard_IsValid(int value);
constexpr Configuration_Keyboard Configuration_Keyboard_Keyboard_MIN = Configuration_Keyboard_KEYBOARD_UNSET;
constexpr Configuration_Keyboard Configuration_Keyboard_Keyboard_MAX = Configuration_Keyboard_KEYBOARD_TWELVEKEY;
constexpr int Configuration_Keyboard_Keyboard_ARRAYSIZE = Configuration_Keyboard_Keyboard_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_Keyboard_descriptor();
template<typename T>
inline const std::string& Configuration_Keyboard_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_Keyboard>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_Keyboard_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_Keyboard_descriptor(), enum_t_value);
}
inline bool Configuration_Keyboard_Parse(
    const std::string& name, Configuration_Keyboard* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_Keyboard>(
    Configuration_Keyboard_descriptor(), name, value);
}
enum Configuration_NavHidden : int {
  Configuration_NavHidden_NAV_HIDDEN_UNSET = 0,
  Configuration_NavHidden_NAV_HIDDEN_NAVEXPOSED = 1,
  Configuration_NavHidden_NAV_HIDDEN_NAVHIDDEN = 2,
  Configuration_NavHidden_Configuration_NavHidden_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Configuration_NavHidden_Configuration_NavHidden_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Configuration_NavHidden_IsValid(int value);
constexpr Configuration_NavHidden Configuration_NavHidden_NavHidden_MIN = Configuration_NavHidden_NAV_HIDDEN_UNSET;
constexpr Configuration_NavHidden Configuration_NavHidden_NavHidden_MAX = Configuration_NavHidden_NAV_HIDDEN_NAVHIDDEN;
constexpr int Configuration_NavHidden_NavHidden_ARRAYSIZE = Configuration_NavHidden_NavHidden_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_NavHidden_descriptor();
template<typename T>
inline const std::string& Configuration_NavHidden_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_NavHidden>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_NavHidden_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_NavHidden_descriptor(), enum_t_value);
}
inline bool Configuration_NavHidden_Parse(
    const std::string& name, Configuration_NavHidden* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_NavHidden>(
    Configuration_NavHidden_descriptor(), name, value);
}
enum Configuration_Navigation : int {
  Configuration_Navigation_NAVIGATION_UNSET = 0,
  Configuration_Navigation_NAVIGATION_NONAV = 1,
  Configuration_Navigation_NAVIGATION_DPAD = 2,
  Configuration_Navigation_NAVIGATION_TRACKBALL = 3,
  Configuration_Navigation_NAVIGATION_WHEEL = 4,
  Configuration_Navigation_Configuration_Navigation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Configuration_Navigation_Configuration_Navigation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Configuration_Navigation_IsValid(int value);
constexpr Configuration_Navigation Configuration_Navigation_Navigation_MIN = Configuration_Navigation_NAVIGATION_UNSET;
constexpr Configuration_Navigation Configuration_Navigation_Navigation_MAX = Configuration_Navigation_NAVIGATION_WHEEL;
constexpr int Configuration_Navigation_Navigation_ARRAYSIZE = Configuration_Navigation_Navigation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_Navigation_descriptor();
template<typename T>
inline const std::string& Configuration_Navigation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_Navigation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_Navigation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_Navigation_descriptor(), enum_t_value);
}
inline bool Configuration_Navigation_Parse(
    const std::string& name, Configuration_Navigation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_Navigation>(
    Configuration_Navigation_descriptor(), name, value);
}
// ===================================================================

class Configuration :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Configuration) */ {
 public:
  Configuration();
  virtual ~Configuration();

  Configuration(const Configuration& from);
  Configuration(Configuration&& from) noexcept
    : Configuration() {
    *this = ::std::move(from);
  }

  inline Configuration& operator=(const Configuration& from) {
    CopyFrom(from);
    return *this;
  }
  inline Configuration& operator=(Configuration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Configuration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Configuration* internal_default_instance() {
    return reinterpret_cast<const Configuration*>(
               &_Configuration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Configuration& a, Configuration& b) {
    a.Swap(&b);
  }
  inline void Swap(Configuration* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Configuration* New() const final {
    return CreateMaybeMessage<Configuration>(nullptr);
  }

  Configuration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Configuration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Configuration& from);
  void MergeFrom(const Configuration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Configuration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Configuration";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2ftools_2faapt2_2fConfiguration_2eproto);
    return ::descriptor_table_frameworks_2fbase_2ftools_2faapt2_2fConfiguration_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Configuration_LayoutDirection LayoutDirection;
  static constexpr LayoutDirection LAYOUT_DIRECTION_UNSET =
    Configuration_LayoutDirection_LAYOUT_DIRECTION_UNSET;
  static constexpr LayoutDirection LAYOUT_DIRECTION_LTR =
    Configuration_LayoutDirection_LAYOUT_DIRECTION_LTR;
  static constexpr LayoutDirection LAYOUT_DIRECTION_RTL =
    Configuration_LayoutDirection_LAYOUT_DIRECTION_RTL;
  static inline bool LayoutDirection_IsValid(int value) {
    return Configuration_LayoutDirection_IsValid(value);
  }
  static constexpr LayoutDirection LayoutDirection_MIN =
    Configuration_LayoutDirection_LayoutDirection_MIN;
  static constexpr LayoutDirection LayoutDirection_MAX =
    Configuration_LayoutDirection_LayoutDirection_MAX;
  static constexpr int LayoutDirection_ARRAYSIZE =
    Configuration_LayoutDirection_LayoutDirection_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LayoutDirection_descriptor() {
    return Configuration_LayoutDirection_descriptor();
  }
  template<typename T>
  static inline const std::string& LayoutDirection_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LayoutDirection>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LayoutDirection_Name.");
    return Configuration_LayoutDirection_Name(enum_t_value);
  }
  static inline bool LayoutDirection_Parse(const std::string& name,
      LayoutDirection* value) {
    return Configuration_LayoutDirection_Parse(name, value);
  }

  typedef Configuration_ScreenLayoutSize ScreenLayoutSize;
  static constexpr ScreenLayoutSize SCREEN_LAYOUT_SIZE_UNSET =
    Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_UNSET;
  static constexpr ScreenLayoutSize SCREEN_LAYOUT_SIZE_SMALL =
    Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_SMALL;
  static constexpr ScreenLayoutSize SCREEN_LAYOUT_SIZE_NORMAL =
    Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_NORMAL;
  static constexpr ScreenLayoutSize SCREEN_LAYOUT_SIZE_LARGE =
    Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_LARGE;
  static constexpr ScreenLayoutSize SCREEN_LAYOUT_SIZE_XLARGE =
    Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_XLARGE;
  static inline bool ScreenLayoutSize_IsValid(int value) {
    return Configuration_ScreenLayoutSize_IsValid(value);
  }
  static constexpr ScreenLayoutSize ScreenLayoutSize_MIN =
    Configuration_ScreenLayoutSize_ScreenLayoutSize_MIN;
  static constexpr ScreenLayoutSize ScreenLayoutSize_MAX =
    Configuration_ScreenLayoutSize_ScreenLayoutSize_MAX;
  static constexpr int ScreenLayoutSize_ARRAYSIZE =
    Configuration_ScreenLayoutSize_ScreenLayoutSize_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ScreenLayoutSize_descriptor() {
    return Configuration_ScreenLayoutSize_descriptor();
  }
  template<typename T>
  static inline const std::string& ScreenLayoutSize_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ScreenLayoutSize>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ScreenLayoutSize_Name.");
    return Configuration_ScreenLayoutSize_Name(enum_t_value);
  }
  static inline bool ScreenLayoutSize_Parse(const std::string& name,
      ScreenLayoutSize* value) {
    return Configuration_ScreenLayoutSize_Parse(name, value);
  }

  typedef Configuration_ScreenLayoutLong ScreenLayoutLong;
  static constexpr ScreenLayoutLong SCREEN_LAYOUT_LONG_UNSET =
    Configuration_ScreenLayoutLong_SCREEN_LAYOUT_LONG_UNSET;
  static constexpr ScreenLayoutLong SCREEN_LAYOUT_LONG_LONG =
    Configuration_ScreenLayoutLong_SCREEN_LAYOUT_LONG_LONG;
  static constexpr ScreenLayoutLong SCREEN_LAYOUT_LONG_NOTLONG =
    Configuration_ScreenLayoutLong_SCREEN_LAYOUT_LONG_NOTLONG;
  static inline bool ScreenLayoutLong_IsValid(int value) {
    return Configuration_ScreenLayoutLong_IsValid(value);
  }
  static constexpr ScreenLayoutLong ScreenLayoutLong_MIN =
    Configuration_ScreenLayoutLong_ScreenLayoutLong_MIN;
  static constexpr ScreenLayoutLong ScreenLayoutLong_MAX =
    Configuration_ScreenLayoutLong_ScreenLayoutLong_MAX;
  static constexpr int ScreenLayoutLong_ARRAYSIZE =
    Configuration_ScreenLayoutLong_ScreenLayoutLong_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ScreenLayoutLong_descriptor() {
    return Configuration_ScreenLayoutLong_descriptor();
  }
  template<typename T>
  static inline const std::string& ScreenLayoutLong_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ScreenLayoutLong>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ScreenLayoutLong_Name.");
    return Configuration_ScreenLayoutLong_Name(enum_t_value);
  }
  static inline bool ScreenLayoutLong_Parse(const std::string& name,
      ScreenLayoutLong* value) {
    return Configuration_ScreenLayoutLong_Parse(name, value);
  }

  typedef Configuration_ScreenRound ScreenRound;
  static constexpr ScreenRound SCREEN_ROUND_UNSET =
    Configuration_ScreenRound_SCREEN_ROUND_UNSET;
  static constexpr ScreenRound SCREEN_ROUND_ROUND =
    Configuration_ScreenRound_SCREEN_ROUND_ROUND;
  static constexpr ScreenRound SCREEN_ROUND_NOTROUND =
    Configuration_ScreenRound_SCREEN_ROUND_NOTROUND;
  static inline bool ScreenRound_IsValid(int value) {
    return Configuration_ScreenRound_IsValid(value);
  }
  static constexpr ScreenRound ScreenRound_MIN =
    Configuration_ScreenRound_ScreenRound_MIN;
  static constexpr ScreenRound ScreenRound_MAX =
    Configuration_ScreenRound_ScreenRound_MAX;
  static constexpr int ScreenRound_ARRAYSIZE =
    Configuration_ScreenRound_ScreenRound_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ScreenRound_descriptor() {
    return Configuration_ScreenRound_descriptor();
  }
  template<typename T>
  static inline const std::string& ScreenRound_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ScreenRound>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ScreenRound_Name.");
    return Configuration_ScreenRound_Name(enum_t_value);
  }
  static inline bool ScreenRound_Parse(const std::string& name,
      ScreenRound* value) {
    return Configuration_ScreenRound_Parse(name, value);
  }

  typedef Configuration_WideColorGamut WideColorGamut;
  static constexpr WideColorGamut WIDE_COLOR_GAMUT_UNSET =
    Configuration_WideColorGamut_WIDE_COLOR_GAMUT_UNSET;
  static constexpr WideColorGamut WIDE_COLOR_GAMUT_WIDECG =
    Configuration_WideColorGamut_WIDE_COLOR_GAMUT_WIDECG;
  static constexpr WideColorGamut WIDE_COLOR_GAMUT_NOWIDECG =
    Configuration_WideColorGamut_WIDE_COLOR_GAMUT_NOWIDECG;
  static inline bool WideColorGamut_IsValid(int value) {
    return Configuration_WideColorGamut_IsValid(value);
  }
  static constexpr WideColorGamut WideColorGamut_MIN =
    Configuration_WideColorGamut_WideColorGamut_MIN;
  static constexpr WideColorGamut WideColorGamut_MAX =
    Configuration_WideColorGamut_WideColorGamut_MAX;
  static constexpr int WideColorGamut_ARRAYSIZE =
    Configuration_WideColorGamut_WideColorGamut_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  WideColorGamut_descriptor() {
    return Configuration_WideColorGamut_descriptor();
  }
  template<typename T>
  static inline const std::string& WideColorGamut_Name(T enum_t_value) {
    static_assert(::std::is_same<T, WideColorGamut>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function WideColorGamut_Name.");
    return Configuration_WideColorGamut_Name(enum_t_value);
  }
  static inline bool WideColorGamut_Parse(const std::string& name,
      WideColorGamut* value) {
    return Configuration_WideColorGamut_Parse(name, value);
  }

  typedef Configuration_Hdr Hdr;
  static constexpr Hdr HDR_UNSET =
    Configuration_Hdr_HDR_UNSET;
  static constexpr Hdr HDR_HIGHDR =
    Configuration_Hdr_HDR_HIGHDR;
  static constexpr Hdr HDR_LOWDR =
    Configuration_Hdr_HDR_LOWDR;
  static inline bool Hdr_IsValid(int value) {
    return Configuration_Hdr_IsValid(value);
  }
  static constexpr Hdr Hdr_MIN =
    Configuration_Hdr_Hdr_MIN;
  static constexpr Hdr Hdr_MAX =
    Configuration_Hdr_Hdr_MAX;
  static constexpr int Hdr_ARRAYSIZE =
    Configuration_Hdr_Hdr_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Hdr_descriptor() {
    return Configuration_Hdr_descriptor();
  }
  template<typename T>
  static inline const std::string& Hdr_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Hdr>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Hdr_Name.");
    return Configuration_Hdr_Name(enum_t_value);
  }
  static inline bool Hdr_Parse(const std::string& name,
      Hdr* value) {
    return Configuration_Hdr_Parse(name, value);
  }

  typedef Configuration_Orientation Orientation;
  static constexpr Orientation ORIENTATION_UNSET =
    Configuration_Orientation_ORIENTATION_UNSET;
  static constexpr Orientation ORIENTATION_PORT =
    Configuration_Orientation_ORIENTATION_PORT;
  static constexpr Orientation ORIENTATION_LAND =
    Configuration_Orientation_ORIENTATION_LAND;
  static constexpr Orientation ORIENTATION_SQUARE =
    Configuration_Orientation_ORIENTATION_SQUARE;
  static inline bool Orientation_IsValid(int value) {
    return Configuration_Orientation_IsValid(value);
  }
  static constexpr Orientation Orientation_MIN =
    Configuration_Orientation_Orientation_MIN;
  static constexpr Orientation Orientation_MAX =
    Configuration_Orientation_Orientation_MAX;
  static constexpr int Orientation_ARRAYSIZE =
    Configuration_Orientation_Orientation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Orientation_descriptor() {
    return Configuration_Orientation_descriptor();
  }
  template<typename T>
  static inline const std::string& Orientation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Orientation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Orientation_Name.");
    return Configuration_Orientation_Name(enum_t_value);
  }
  static inline bool Orientation_Parse(const std::string& name,
      Orientation* value) {
    return Configuration_Orientation_Parse(name, value);
  }

  typedef Configuration_UiModeType UiModeType;
  static constexpr UiModeType UI_MODE_TYPE_UNSET =
    Configuration_UiModeType_UI_MODE_TYPE_UNSET;
  static constexpr UiModeType UI_MODE_TYPE_NORMAL =
    Configuration_UiModeType_UI_MODE_TYPE_NORMAL;
  static constexpr UiModeType UI_MODE_TYPE_DESK =
    Configuration_UiModeType_UI_MODE_TYPE_DESK;
  static constexpr UiModeType UI_MODE_TYPE_CAR =
    Configuration_UiModeType_UI_MODE_TYPE_CAR;
  static constexpr UiModeType UI_MODE_TYPE_TELEVISION =
    Configuration_UiModeType_UI_MODE_TYPE_TELEVISION;
  static constexpr UiModeType UI_MODE_TYPE_APPLIANCE =
    Configuration_UiModeType_UI_MODE_TYPE_APPLIANCE;
  static constexpr UiModeType UI_MODE_TYPE_WATCH =
    Configuration_UiModeType_UI_MODE_TYPE_WATCH;
  static constexpr UiModeType UI_MODE_TYPE_VRHEADSET =
    Configuration_UiModeType_UI_MODE_TYPE_VRHEADSET;
  static inline bool UiModeType_IsValid(int value) {
    return Configuration_UiModeType_IsValid(value);
  }
  static constexpr UiModeType UiModeType_MIN =
    Configuration_UiModeType_UiModeType_MIN;
  static constexpr UiModeType UiModeType_MAX =
    Configuration_UiModeType_UiModeType_MAX;
  static constexpr int UiModeType_ARRAYSIZE =
    Configuration_UiModeType_UiModeType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  UiModeType_descriptor() {
    return Configuration_UiModeType_descriptor();
  }
  template<typename T>
  static inline const std::string& UiModeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UiModeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UiModeType_Name.");
    return Configuration_UiModeType_Name(enum_t_value);
  }
  static inline bool UiModeType_Parse(const std::string& name,
      UiModeType* value) {
    return Configuration_UiModeType_Parse(name, value);
  }

  typedef Configuration_UiModeNight UiModeNight;
  static constexpr UiModeNight UI_MODE_NIGHT_UNSET =
    Configuration_UiModeNight_UI_MODE_NIGHT_UNSET;
  static constexpr UiModeNight UI_MODE_NIGHT_NIGHT =
    Configuration_UiModeNight_UI_MODE_NIGHT_NIGHT;
  static constexpr UiModeNight UI_MODE_NIGHT_NOTNIGHT =
    Configuration_UiModeNight_UI_MODE_NIGHT_NOTNIGHT;
  static inline bool UiModeNight_IsValid(int value) {
    return Configuration_UiModeNight_IsValid(value);
  }
  static constexpr UiModeNight UiModeNight_MIN =
    Configuration_UiModeNight_UiModeNight_MIN;
  static constexpr UiModeNight UiModeNight_MAX =
    Configuration_UiModeNight_UiModeNight_MAX;
  static constexpr int UiModeNight_ARRAYSIZE =
    Configuration_UiModeNight_UiModeNight_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  UiModeNight_descriptor() {
    return Configuration_UiModeNight_descriptor();
  }
  template<typename T>
  static inline const std::string& UiModeNight_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UiModeNight>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UiModeNight_Name.");
    return Configuration_UiModeNight_Name(enum_t_value);
  }
  static inline bool UiModeNight_Parse(const std::string& name,
      UiModeNight* value) {
    return Configuration_UiModeNight_Parse(name, value);
  }

  typedef Configuration_Touchscreen Touchscreen;
  static constexpr Touchscreen TOUCHSCREEN_UNSET =
    Configuration_Touchscreen_TOUCHSCREEN_UNSET;
  static constexpr Touchscreen TOUCHSCREEN_NOTOUCH =
    Configuration_Touchscreen_TOUCHSCREEN_NOTOUCH;
  static constexpr Touchscreen TOUCHSCREEN_STYLUS =
    Configuration_Touchscreen_TOUCHSCREEN_STYLUS;
  static constexpr Touchscreen TOUCHSCREEN_FINGER =
    Configuration_Touchscreen_TOUCHSCREEN_FINGER;
  static inline bool Touchscreen_IsValid(int value) {
    return Configuration_Touchscreen_IsValid(value);
  }
  static constexpr Touchscreen Touchscreen_MIN =
    Configuration_Touchscreen_Touchscreen_MIN;
  static constexpr Touchscreen Touchscreen_MAX =
    Configuration_Touchscreen_Touchscreen_MAX;
  static constexpr int Touchscreen_ARRAYSIZE =
    Configuration_Touchscreen_Touchscreen_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Touchscreen_descriptor() {
    return Configuration_Touchscreen_descriptor();
  }
  template<typename T>
  static inline const std::string& Touchscreen_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Touchscreen>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Touchscreen_Name.");
    return Configuration_Touchscreen_Name(enum_t_value);
  }
  static inline bool Touchscreen_Parse(const std::string& name,
      Touchscreen* value) {
    return Configuration_Touchscreen_Parse(name, value);
  }

  typedef Configuration_KeysHidden KeysHidden;
  static constexpr KeysHidden KEYS_HIDDEN_UNSET =
    Configuration_KeysHidden_KEYS_HIDDEN_UNSET;
  static constexpr KeysHidden KEYS_HIDDEN_KEYSEXPOSED =
    Configuration_KeysHidden_KEYS_HIDDEN_KEYSEXPOSED;
  static constexpr KeysHidden KEYS_HIDDEN_KEYSHIDDEN =
    Configuration_KeysHidden_KEYS_HIDDEN_KEYSHIDDEN;
  static constexpr KeysHidden KEYS_HIDDEN_KEYSSOFT =
    Configuration_KeysHidden_KEYS_HIDDEN_KEYSSOFT;
  static inline bool KeysHidden_IsValid(int value) {
    return Configuration_KeysHidden_IsValid(value);
  }
  static constexpr KeysHidden KeysHidden_MIN =
    Configuration_KeysHidden_KeysHidden_MIN;
  static constexpr KeysHidden KeysHidden_MAX =
    Configuration_KeysHidden_KeysHidden_MAX;
  static constexpr int KeysHidden_ARRAYSIZE =
    Configuration_KeysHidden_KeysHidden_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  KeysHidden_descriptor() {
    return Configuration_KeysHidden_descriptor();
  }
  template<typename T>
  static inline const std::string& KeysHidden_Name(T enum_t_value) {
    static_assert(::std::is_same<T, KeysHidden>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function KeysHidden_Name.");
    return Configuration_KeysHidden_Name(enum_t_value);
  }
  static inline bool KeysHidden_Parse(const std::string& name,
      KeysHidden* value) {
    return Configuration_KeysHidden_Parse(name, value);
  }

  typedef Configuration_Keyboard Keyboard;
  static constexpr Keyboard KEYBOARD_UNSET =
    Configuration_Keyboard_KEYBOARD_UNSET;
  static constexpr Keyboard KEYBOARD_NOKEYS =
    Configuration_Keyboard_KEYBOARD_NOKEYS;
  static constexpr Keyboard KEYBOARD_QWERTY =
    Configuration_Keyboard_KEYBOARD_QWERTY;
  static constexpr Keyboard KEYBOARD_TWELVEKEY =
    Configuration_Keyboard_KEYBOARD_TWELVEKEY;
  static inline bool Keyboard_IsValid(int value) {
    return Configuration_Keyboard_IsValid(value);
  }
  static constexpr Keyboard Keyboard_MIN =
    Configuration_Keyboard_Keyboard_MIN;
  static constexpr Keyboard Keyboard_MAX =
    Configuration_Keyboard_Keyboard_MAX;
  static constexpr int Keyboard_ARRAYSIZE =
    Configuration_Keyboard_Keyboard_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Keyboard_descriptor() {
    return Configuration_Keyboard_descriptor();
  }
  template<typename T>
  static inline const std::string& Keyboard_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Keyboard>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Keyboard_Name.");
    return Configuration_Keyboard_Name(enum_t_value);
  }
  static inline bool Keyboard_Parse(const std::string& name,
      Keyboard* value) {
    return Configuration_Keyboard_Parse(name, value);
  }

  typedef Configuration_NavHidden NavHidden;
  static constexpr NavHidden NAV_HIDDEN_UNSET =
    Configuration_NavHidden_NAV_HIDDEN_UNSET;
  static constexpr NavHidden NAV_HIDDEN_NAVEXPOSED =
    Configuration_NavHidden_NAV_HIDDEN_NAVEXPOSED;
  static constexpr NavHidden NAV_HIDDEN_NAVHIDDEN =
    Configuration_NavHidden_NAV_HIDDEN_NAVHIDDEN;
  static inline bool NavHidden_IsValid(int value) {
    return Configuration_NavHidden_IsValid(value);
  }
  static constexpr NavHidden NavHidden_MIN =
    Configuration_NavHidden_NavHidden_MIN;
  static constexpr NavHidden NavHidden_MAX =
    Configuration_NavHidden_NavHidden_MAX;
  static constexpr int NavHidden_ARRAYSIZE =
    Configuration_NavHidden_NavHidden_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  NavHidden_descriptor() {
    return Configuration_NavHidden_descriptor();
  }
  template<typename T>
  static inline const std::string& NavHidden_Name(T enum_t_value) {
    static_assert(::std::is_same<T, NavHidden>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function NavHidden_Name.");
    return Configuration_NavHidden_Name(enum_t_value);
  }
  static inline bool NavHidden_Parse(const std::string& name,
      NavHidden* value) {
    return Configuration_NavHidden_Parse(name, value);
  }

  typedef Configuration_Navigation Navigation;
  static constexpr Navigation NAVIGATION_UNSET =
    Configuration_Navigation_NAVIGATION_UNSET;
  static constexpr Navigation NAVIGATION_NONAV =
    Configuration_Navigation_NAVIGATION_NONAV;
  static constexpr Navigation NAVIGATION_DPAD =
    Configuration_Navigation_NAVIGATION_DPAD;
  static constexpr Navigation NAVIGATION_TRACKBALL =
    Configuration_Navigation_NAVIGATION_TRACKBALL;
  static constexpr Navigation NAVIGATION_WHEEL =
    Configuration_Navigation_NAVIGATION_WHEEL;
  static inline bool Navigation_IsValid(int value) {
    return Configuration_Navigation_IsValid(value);
  }
  static constexpr Navigation Navigation_MIN =
    Configuration_Navigation_Navigation_MIN;
  static constexpr Navigation Navigation_MAX =
    Configuration_Navigation_Navigation_MAX;
  static constexpr int Navigation_ARRAYSIZE =
    Configuration_Navigation_Navigation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Navigation_descriptor() {
    return Configuration_Navigation_descriptor();
  }
  template<typename T>
  static inline const std::string& Navigation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Navigation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Navigation_Name.");
    return Configuration_Navigation_Name(enum_t_value);
  }
  static inline bool Navigation_Parse(const std::string& name,
      Navigation* value) {
    return Configuration_Navigation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLocaleFieldNumber = 3,
    kProductFieldNumber = 25,
    kMccFieldNumber = 1,
    kMncFieldNumber = 2,
    kLayoutDirectionFieldNumber = 4,
    kScreenWidthFieldNumber = 5,
    kScreenHeightFieldNumber = 6,
    kScreenWidthDpFieldNumber = 7,
    kScreenHeightDpFieldNumber = 8,
    kSmallestScreenWidthDpFieldNumber = 9,
    kScreenLayoutSizeFieldNumber = 10,
    kScreenLayoutLongFieldNumber = 11,
    kScreenRoundFieldNumber = 12,
    kWideColorGamutFieldNumber = 13,
    kHdrFieldNumber = 14,
    kOrientationFieldNumber = 15,
    kUiModeTypeFieldNumber = 16,
    kUiModeNightFieldNumber = 17,
    kDensityFieldNumber = 18,
    kTouchscreenFieldNumber = 19,
    kKeysHiddenFieldNumber = 20,
    kKeyboardFieldNumber = 21,
    kNavHiddenFieldNumber = 22,
    kNavigationFieldNumber = 23,
    kSdkVersionFieldNumber = 24,
  };
  // string locale = 3;
  void clear_locale();
  const std::string& locale() const;
  void set_locale(const std::string& value);
  void set_locale(std::string&& value);
  void set_locale(const char* value);
  void set_locale(const char* value, size_t size);
  std::string* mutable_locale();
  std::string* release_locale();
  void set_allocated_locale(std::string* locale);

  // string product = 25;
  void clear_product();
  const std::string& product() const;
  void set_product(const std::string& value);
  void set_product(std::string&& value);
  void set_product(const char* value);
  void set_product(const char* value, size_t size);
  std::string* mutable_product();
  std::string* release_product();
  void set_allocated_product(std::string* product);

  // uint32 mcc = 1;
  void clear_mcc();
  ::PROTOBUF_NAMESPACE_ID::uint32 mcc() const;
  void set_mcc(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 mnc = 2;
  void clear_mnc();
  ::PROTOBUF_NAMESPACE_ID::uint32 mnc() const;
  void set_mnc(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // .aapt.pb.Configuration.LayoutDirection layout_direction = 4;
  void clear_layout_direction();
  ::aapt::pb::Configuration_LayoutDirection layout_direction() const;
  void set_layout_direction(::aapt::pb::Configuration_LayoutDirection value);

  // uint32 screen_width = 5;
  void clear_screen_width();
  ::PROTOBUF_NAMESPACE_ID::uint32 screen_width() const;
  void set_screen_width(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 screen_height = 6;
  void clear_screen_height();
  ::PROTOBUF_NAMESPACE_ID::uint32 screen_height() const;
  void set_screen_height(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 screen_width_dp = 7;
  void clear_screen_width_dp();
  ::PROTOBUF_NAMESPACE_ID::uint32 screen_width_dp() const;
  void set_screen_width_dp(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 screen_height_dp = 8;
  void clear_screen_height_dp();
  ::PROTOBUF_NAMESPACE_ID::uint32 screen_height_dp() const;
  void set_screen_height_dp(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 smallest_screen_width_dp = 9;
  void clear_smallest_screen_width_dp();
  ::PROTOBUF_NAMESPACE_ID::uint32 smallest_screen_width_dp() const;
  void set_smallest_screen_width_dp(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // .aapt.pb.Configuration.ScreenLayoutSize screen_layout_size = 10;
  void clear_screen_layout_size();
  ::aapt::pb::Configuration_ScreenLayoutSize screen_layout_size() const;
  void set_screen_layout_size(::aapt::pb::Configuration_ScreenLayoutSize value);

  // .aapt.pb.Configuration.ScreenLayoutLong screen_layout_long = 11;
  void clear_screen_layout_long();
  ::aapt::pb::Configuration_ScreenLayoutLong screen_layout_long() const;
  void set_screen_layout_long(::aapt::pb::Configuration_ScreenLayoutLong value);

  // .aapt.pb.Configuration.ScreenRound screen_round = 12;
  void clear_screen_round();
  ::aapt::pb::Configuration_ScreenRound screen_round() const;
  void set_screen_round(::aapt::pb::Configuration_ScreenRound value);

  // .aapt.pb.Configuration.WideColorGamut wide_color_gamut = 13;
  void clear_wide_color_gamut();
  ::aapt::pb::Configuration_WideColorGamut wide_color_gamut() const;
  void set_wide_color_gamut(::aapt::pb::Configuration_WideColorGamut value);

  // .aapt.pb.Configuration.Hdr hdr = 14;
  void clear_hdr();
  ::aapt::pb::Configuration_Hdr hdr() const;
  void set_hdr(::aapt::pb::Configuration_Hdr value);

  // .aapt.pb.Configuration.Orientation orientation = 15;
  void clear_orientation();
  ::aapt::pb::Configuration_Orientation orientation() const;
  void set_orientation(::aapt::pb::Configuration_Orientation value);

  // .aapt.pb.Configuration.UiModeType ui_mode_type = 16;
  void clear_ui_mode_type();
  ::aapt::pb::Configuration_UiModeType ui_mode_type() const;
  void set_ui_mode_type(::aapt::pb::Configuration_UiModeType value);

  // .aapt.pb.Configuration.UiModeNight ui_mode_night = 17;
  void clear_ui_mode_night();
  ::aapt::pb::Configuration_UiModeNight ui_mode_night() const;
  void set_ui_mode_night(::aapt::pb::Configuration_UiModeNight value);

  // uint32 density = 18;
  void clear_density();
  ::PROTOBUF_NAMESPACE_ID::uint32 density() const;
  void set_density(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // .aapt.pb.Configuration.Touchscreen touchscreen = 19;
  void clear_touchscreen();
  ::aapt::pb::Configuration_Touchscreen touchscreen() const;
  void set_touchscreen(::aapt::pb::Configuration_Touchscreen value);

  // .aapt.pb.Configuration.KeysHidden keys_hidden = 20;
  void clear_keys_hidden();
  ::aapt::pb::Configuration_KeysHidden keys_hidden() const;
  void set_keys_hidden(::aapt::pb::Configuration_KeysHidden value);

  // .aapt.pb.Configuration.Keyboard keyboard = 21;
  void clear_keyboard();
  ::aapt::pb::Configuration_Keyboard keyboard() const;
  void set_keyboard(::aapt::pb::Configuration_Keyboard value);

  // .aapt.pb.Configuration.NavHidden nav_hidden = 22;
  void clear_nav_hidden();
  ::aapt::pb::Configuration_NavHidden nav_hidden() const;
  void set_nav_hidden(::aapt::pb::Configuration_NavHidden value);

  // .aapt.pb.Configuration.Navigation navigation = 23;
  void clear_navigation();
  ::aapt::pb::Configuration_Navigation navigation() const;
  void set_navigation(::aapt::pb::Configuration_Navigation value);

  // uint32 sdk_version = 24;
  void clear_sdk_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 sdk_version() const;
  void set_sdk_version(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:aapt.pb.Configuration)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr locale_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_;
  ::PROTOBUF_NAMESPACE_ID::uint32 mcc_;
  ::PROTOBUF_NAMESPACE_ID::uint32 mnc_;
  int layout_direction_;
  ::PROTOBUF_NAMESPACE_ID::uint32 screen_width_;
  ::PROTOBUF_NAMESPACE_ID::uint32 screen_height_;
  ::PROTOBUF_NAMESPACE_ID::uint32 screen_width_dp_;
  ::PROTOBUF_NAMESPACE_ID::uint32 screen_height_dp_;
  ::PROTOBUF_NAMESPACE_ID::uint32 smallest_screen_width_dp_;
  int screen_layout_size_;
  int screen_layout_long_;
  int screen_round_;
  int wide_color_gamut_;
  int hdr_;
  int orientation_;
  int ui_mode_type_;
  int ui_mode_night_;
  ::PROTOBUF_NAMESPACE_ID::uint32 density_;
  int touchscreen_;
  int keys_hidden_;
  int keyboard_;
  int nav_hidden_;
  int navigation_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sdk_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frameworks_2fbase_2ftools_2faapt2_2fConfiguration_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Configuration

// uint32 mcc = 1;
inline void Configuration::clear_mcc() {
  mcc_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Configuration::mcc() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.mcc)
  return mcc_;
}
inline void Configuration::set_mcc(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  mcc_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.mcc)
}

// uint32 mnc = 2;
inline void Configuration::clear_mnc() {
  mnc_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Configuration::mnc() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.mnc)
  return mnc_;
}
inline void Configuration::set_mnc(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  mnc_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.mnc)
}

// string locale = 3;
inline void Configuration::clear_locale() {
  locale_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Configuration::locale() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.locale)
  return locale_.GetNoArena();
}
inline void Configuration::set_locale(const std::string& value) {
  
  locale_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.locale)
}
inline void Configuration::set_locale(std::string&& value) {
  
  locale_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aapt.pb.Configuration.locale)
}
inline void Configuration::set_locale(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  locale_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.Configuration.locale)
}
inline void Configuration::set_locale(const char* value, size_t size) {
  
  locale_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Configuration.locale)
}
inline std::string* Configuration::mutable_locale() {
  
  // @@protoc_insertion_point(field_mutable:aapt.pb.Configuration.locale)
  return locale_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Configuration::release_locale() {
  // @@protoc_insertion_point(field_release:aapt.pb.Configuration.locale)
  
  return locale_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Configuration::set_allocated_locale(std::string* locale) {
  if (locale != nullptr) {
    
  } else {
    
  }
  locale_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), locale);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Configuration.locale)
}

// .aapt.pb.Configuration.LayoutDirection layout_direction = 4;
inline void Configuration::clear_layout_direction() {
  layout_direction_ = 0;
}
inline ::aapt::pb::Configuration_LayoutDirection Configuration::layout_direction() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.layout_direction)
  return static_cast< ::aapt::pb::Configuration_LayoutDirection >(layout_direction_);
}
inline void Configuration::set_layout_direction(::aapt::pb::Configuration_LayoutDirection value) {
  
  layout_direction_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.layout_direction)
}

// uint32 screen_width = 5;
inline void Configuration::clear_screen_width() {
  screen_width_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Configuration::screen_width() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.screen_width)
  return screen_width_;
}
inline void Configuration::set_screen_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  screen_width_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.screen_width)
}

// uint32 screen_height = 6;
inline void Configuration::clear_screen_height() {
  screen_height_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Configuration::screen_height() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.screen_height)
  return screen_height_;
}
inline void Configuration::set_screen_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  screen_height_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.screen_height)
}

// uint32 screen_width_dp = 7;
inline void Configuration::clear_screen_width_dp() {
  screen_width_dp_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Configuration::screen_width_dp() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.screen_width_dp)
  return screen_width_dp_;
}
inline void Configuration::set_screen_width_dp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  screen_width_dp_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.screen_width_dp)
}

// uint32 screen_height_dp = 8;
inline void Configuration::clear_screen_height_dp() {
  screen_height_dp_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Configuration::screen_height_dp() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.screen_height_dp)
  return screen_height_dp_;
}
inline void Configuration::set_screen_height_dp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  screen_height_dp_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.screen_height_dp)
}

// uint32 smallest_screen_width_dp = 9;
inline void Configuration::clear_smallest_screen_width_dp() {
  smallest_screen_width_dp_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Configuration::smallest_screen_width_dp() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.smallest_screen_width_dp)
  return smallest_screen_width_dp_;
}
inline void Configuration::set_smallest_screen_width_dp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  smallest_screen_width_dp_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.smallest_screen_width_dp)
}

// .aapt.pb.Configuration.ScreenLayoutSize screen_layout_size = 10;
inline void Configuration::clear_screen_layout_size() {
  screen_layout_size_ = 0;
}
inline ::aapt::pb::Configuration_ScreenLayoutSize Configuration::screen_layout_size() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.screen_layout_size)
  return static_cast< ::aapt::pb::Configuration_ScreenLayoutSize >(screen_layout_size_);
}
inline void Configuration::set_screen_layout_size(::aapt::pb::Configuration_ScreenLayoutSize value) {
  
  screen_layout_size_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.screen_layout_size)
}

// .aapt.pb.Configuration.ScreenLayoutLong screen_layout_long = 11;
inline void Configuration::clear_screen_layout_long() {
  screen_layout_long_ = 0;
}
inline ::aapt::pb::Configuration_ScreenLayoutLong Configuration::screen_layout_long() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.screen_layout_long)
  return static_cast< ::aapt::pb::Configuration_ScreenLayoutLong >(screen_layout_long_);
}
inline void Configuration::set_screen_layout_long(::aapt::pb::Configuration_ScreenLayoutLong value) {
  
  screen_layout_long_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.screen_layout_long)
}

// .aapt.pb.Configuration.ScreenRound screen_round = 12;
inline void Configuration::clear_screen_round() {
  screen_round_ = 0;
}
inline ::aapt::pb::Configuration_ScreenRound Configuration::screen_round() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.screen_round)
  return static_cast< ::aapt::pb::Configuration_ScreenRound >(screen_round_);
}
inline void Configuration::set_screen_round(::aapt::pb::Configuration_ScreenRound value) {
  
  screen_round_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.screen_round)
}

// .aapt.pb.Configuration.WideColorGamut wide_color_gamut = 13;
inline void Configuration::clear_wide_color_gamut() {
  wide_color_gamut_ = 0;
}
inline ::aapt::pb::Configuration_WideColorGamut Configuration::wide_color_gamut() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.wide_color_gamut)
  return static_cast< ::aapt::pb::Configuration_WideColorGamut >(wide_color_gamut_);
}
inline void Configuration::set_wide_color_gamut(::aapt::pb::Configuration_WideColorGamut value) {
  
  wide_color_gamut_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.wide_color_gamut)
}

// .aapt.pb.Configuration.Hdr hdr = 14;
inline void Configuration::clear_hdr() {
  hdr_ = 0;
}
inline ::aapt::pb::Configuration_Hdr Configuration::hdr() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.hdr)
  return static_cast< ::aapt::pb::Configuration_Hdr >(hdr_);
}
inline void Configuration::set_hdr(::aapt::pb::Configuration_Hdr value) {
  
  hdr_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.hdr)
}

// .aapt.pb.Configuration.Orientation orientation = 15;
inline void Configuration::clear_orientation() {
  orientation_ = 0;
}
inline ::aapt::pb::Configuration_Orientation Configuration::orientation() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.orientation)
  return static_cast< ::aapt::pb::Configuration_Orientation >(orientation_);
}
inline void Configuration::set_orientation(::aapt::pb::Configuration_Orientation value) {
  
  orientation_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.orientation)
}

// .aapt.pb.Configuration.UiModeType ui_mode_type = 16;
inline void Configuration::clear_ui_mode_type() {
  ui_mode_type_ = 0;
}
inline ::aapt::pb::Configuration_UiModeType Configuration::ui_mode_type() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.ui_mode_type)
  return static_cast< ::aapt::pb::Configuration_UiModeType >(ui_mode_type_);
}
inline void Configuration::set_ui_mode_type(::aapt::pb::Configuration_UiModeType value) {
  
  ui_mode_type_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.ui_mode_type)
}

// .aapt.pb.Configuration.UiModeNight ui_mode_night = 17;
inline void Configuration::clear_ui_mode_night() {
  ui_mode_night_ = 0;
}
inline ::aapt::pb::Configuration_UiModeNight Configuration::ui_mode_night() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.ui_mode_night)
  return static_cast< ::aapt::pb::Configuration_UiModeNight >(ui_mode_night_);
}
inline void Configuration::set_ui_mode_night(::aapt::pb::Configuration_UiModeNight value) {
  
  ui_mode_night_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.ui_mode_night)
}

// uint32 density = 18;
inline void Configuration::clear_density() {
  density_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Configuration::density() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.density)
  return density_;
}
inline void Configuration::set_density(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  density_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.density)
}

// .aapt.pb.Configuration.Touchscreen touchscreen = 19;
inline void Configuration::clear_touchscreen() {
  touchscreen_ = 0;
}
inline ::aapt::pb::Configuration_Touchscreen Configuration::touchscreen() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.touchscreen)
  return static_cast< ::aapt::pb::Configuration_Touchscreen >(touchscreen_);
}
inline void Configuration::set_touchscreen(::aapt::pb::Configuration_Touchscreen value) {
  
  touchscreen_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.touchscreen)
}

// .aapt.pb.Configuration.KeysHidden keys_hidden = 20;
inline void Configuration::clear_keys_hidden() {
  keys_hidden_ = 0;
}
inline ::aapt::pb::Configuration_KeysHidden Configuration::keys_hidden() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.keys_hidden)
  return static_cast< ::aapt::pb::Configuration_KeysHidden >(keys_hidden_);
}
inline void Configuration::set_keys_hidden(::aapt::pb::Configuration_KeysHidden value) {
  
  keys_hidden_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.keys_hidden)
}

// .aapt.pb.Configuration.Keyboard keyboard = 21;
inline void Configuration::clear_keyboard() {
  keyboard_ = 0;
}
inline ::aapt::pb::Configuration_Keyboard Configuration::keyboard() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.keyboard)
  return static_cast< ::aapt::pb::Configuration_Keyboard >(keyboard_);
}
inline void Configuration::set_keyboard(::aapt::pb::Configuration_Keyboard value) {
  
  keyboard_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.keyboard)
}

// .aapt.pb.Configuration.NavHidden nav_hidden = 22;
inline void Configuration::clear_nav_hidden() {
  nav_hidden_ = 0;
}
inline ::aapt::pb::Configuration_NavHidden Configuration::nav_hidden() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.nav_hidden)
  return static_cast< ::aapt::pb::Configuration_NavHidden >(nav_hidden_);
}
inline void Configuration::set_nav_hidden(::aapt::pb::Configuration_NavHidden value) {
  
  nav_hidden_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.nav_hidden)
}

// .aapt.pb.Configuration.Navigation navigation = 23;
inline void Configuration::clear_navigation() {
  navigation_ = 0;
}
inline ::aapt::pb::Configuration_Navigation Configuration::navigation() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.navigation)
  return static_cast< ::aapt::pb::Configuration_Navigation >(navigation_);
}
inline void Configuration::set_navigation(::aapt::pb::Configuration_Navigation value) {
  
  navigation_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.navigation)
}

// uint32 sdk_version = 24;
inline void Configuration::clear_sdk_version() {
  sdk_version_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Configuration::sdk_version() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.sdk_version)
  return sdk_version_;
}
inline void Configuration::set_sdk_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  sdk_version_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.sdk_version)
}

// string product = 25;
inline void Configuration::clear_product() {
  product_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Configuration::product() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.product)
  return product_.GetNoArena();
}
inline void Configuration::set_product(const std::string& value) {
  
  product_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.product)
}
inline void Configuration::set_product(std::string&& value) {
  
  product_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aapt.pb.Configuration.product)
}
inline void Configuration::set_product(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  product_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.Configuration.product)
}
inline void Configuration::set_product(const char* value, size_t size) {
  
  product_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Configuration.product)
}
inline std::string* Configuration::mutable_product() {
  
  // @@protoc_insertion_point(field_mutable:aapt.pb.Configuration.product)
  return product_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Configuration::release_product() {
  // @@protoc_insertion_point(field_release:aapt.pb.Configuration.product)
  
  return product_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Configuration::set_allocated_product(std::string* product) {
  if (product != nullptr) {
    
  } else {
    
  }
  product_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), product);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Configuration.product)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace aapt

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::aapt::pb::Configuration_LayoutDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_LayoutDirection>() {
  return ::aapt::pb::Configuration_LayoutDirection_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_ScreenLayoutSize> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_ScreenLayoutSize>() {
  return ::aapt::pb::Configuration_ScreenLayoutSize_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_ScreenLayoutLong> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_ScreenLayoutLong>() {
  return ::aapt::pb::Configuration_ScreenLayoutLong_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_ScreenRound> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_ScreenRound>() {
  return ::aapt::pb::Configuration_ScreenRound_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_WideColorGamut> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_WideColorGamut>() {
  return ::aapt::pb::Configuration_WideColorGamut_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_Hdr> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_Hdr>() {
  return ::aapt::pb::Configuration_Hdr_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_Orientation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_Orientation>() {
  return ::aapt::pb::Configuration_Orientation_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_UiModeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_UiModeType>() {
  return ::aapt::pb::Configuration_UiModeType_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_UiModeNight> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_UiModeNight>() {
  return ::aapt::pb::Configuration_UiModeNight_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_Touchscreen> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_Touchscreen>() {
  return ::aapt::pb::Configuration_Touchscreen_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_KeysHidden> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_KeysHidden>() {
  return ::aapt::pb::Configuration_KeysHidden_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_Keyboard> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_Keyboard>() {
  return ::aapt::pb::Configuration_Keyboard_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_NavHidden> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_NavHidden>() {
  return ::aapt::pb::Configuration_NavHidden_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_Navigation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_Navigation>() {
  return ::aapt::pb::Configuration_Navigation_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_frameworks_2fbase_2ftools_2faapt2_2fConfiguration_2eproto
