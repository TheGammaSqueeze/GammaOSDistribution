// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/stats/docsui/docsui_enums.proto

#include "frameworks/proto_logging/stats/enums/stats/docsui/docsui_enums.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
namespace android {
namespace stats {
namespace docsui {
}  // namespace docsui
}  // namespace stats
}  // namespace android
namespace android {
namespace stats {
namespace docsui {
bool LaunchAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LaunchAction_strings[8] = {};

static const char LaunchAction_names[] =
  "BROWSE"
  "CREATE"
  "GET_CONTENT"
  "OPEN"
  "OPEN_TREE"
  "OTHER"
  "PICK_COPY_DEST"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LaunchAction_entries[] = {
  { {LaunchAction_names + 0, 6}, 6 },
  { {LaunchAction_names + 6, 6}, 2 },
  { {LaunchAction_names + 12, 11}, 3 },
  { {LaunchAction_names + 23, 4}, 1 },
  { {LaunchAction_names + 27, 9}, 4 },
  { {LaunchAction_names + 36, 5}, 7 },
  { {LaunchAction_names + 41, 14}, 5 },
  { {LaunchAction_names + 55, 7}, 0 },
};

static const int LaunchAction_entries_by_number[] = {
  7, // 0 -> UNKNOWN
  3, // 1 -> OPEN
  1, // 2 -> CREATE
  2, // 3 -> GET_CONTENT
  4, // 4 -> OPEN_TREE
  6, // 5 -> PICK_COPY_DEST
  0, // 6 -> BROWSE
  5, // 7 -> OTHER
};

const std::string& LaunchAction_Name(
    LaunchAction value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LaunchAction_entries,
          LaunchAction_entries_by_number,
          8, LaunchAction_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LaunchAction_entries,
      LaunchAction_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LaunchAction_strings[idx].get();
}
bool LaunchAction_Parse(
    const std::string& name, LaunchAction* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LaunchAction_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<LaunchAction>(int_value);
  }
  return success;
}
bool MimeType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MimeType_strings[11] = {};

static const char MimeType_names[] =
  "MIME_ANY"
  "MIME_APPLICATION"
  "MIME_AUDIO"
  "MIME_IMAGE"
  "MIME_MESSAGE"
  "MIME_MULTIPART"
  "MIME_NONE"
  "MIME_OTHER"
  "MIME_TEXT"
  "MIME_UNKNOWN"
  "MIME_VIDEO";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MimeType_entries[] = {
  { {MimeType_names + 0, 8}, 2 },
  { {MimeType_names + 8, 16}, 3 },
  { {MimeType_names + 24, 10}, 4 },
  { {MimeType_names + 34, 10}, 5 },
  { {MimeType_names + 44, 12}, 6 },
  { {MimeType_names + 56, 14}, 7 },
  { {MimeType_names + 70, 9}, 1 },
  { {MimeType_names + 79, 10}, 10 },
  { {MimeType_names + 89, 9}, 8 },
  { {MimeType_names + 98, 12}, 0 },
  { {MimeType_names + 110, 10}, 9 },
};

static const int MimeType_entries_by_number[] = {
  9, // 0 -> MIME_UNKNOWN
  6, // 1 -> MIME_NONE
  0, // 2 -> MIME_ANY
  1, // 3 -> MIME_APPLICATION
  2, // 4 -> MIME_AUDIO
  3, // 5 -> MIME_IMAGE
  4, // 6 -> MIME_MESSAGE
  5, // 7 -> MIME_MULTIPART
  8, // 8 -> MIME_TEXT
  10, // 9 -> MIME_VIDEO
  7, // 10 -> MIME_OTHER
};

const std::string& MimeType_Name(
    MimeType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MimeType_entries,
          MimeType_entries_by_number,
          11, MimeType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MimeType_entries,
      MimeType_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MimeType_strings[idx].get();
}
bool MimeType_Parse(
    const std::string& name, MimeType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MimeType_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<MimeType>(int_value);
  }
  return success;
}
bool Root_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Root_strings[13] = {};

static const char Root_names[] =
  "ROOT_AUDIO"
  "ROOT_DEVICE_STORAGE"
  "ROOT_DOCUMENTS"
  "ROOT_DOWNLOADS"
  "ROOT_HOME"
  "ROOT_IMAGES"
  "ROOT_MTP"
  "ROOT_NONE"
  "ROOT_OTHER_DOCS_PROVIDER"
  "ROOT_RECENTS"
  "ROOT_THIRD_PARTY_APP"
  "ROOT_UNKNOWN"
  "ROOT_VIDEOS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Root_entries[] = {
  { {Root_names + 0, 10}, 3 },
  { {Root_names + 10, 19}, 4 },
  { {Root_names + 29, 14}, 12 },
  { {Root_names + 43, 14}, 5 },
  { {Root_names + 57, 9}, 6 },
  { {Root_names + 66, 11}, 7 },
  { {Root_names + 77, 8}, 10 },
  { {Root_names + 85, 9}, 1 },
  { {Root_names + 94, 24}, 2 },
  { {Root_names + 118, 12}, 8 },
  { {Root_names + 130, 20}, 11 },
  { {Root_names + 150, 12}, 0 },
  { {Root_names + 162, 11}, 9 },
};

static const int Root_entries_by_number[] = {
  11, // 0 -> ROOT_UNKNOWN
  7, // 1 -> ROOT_NONE
  8, // 2 -> ROOT_OTHER_DOCS_PROVIDER
  0, // 3 -> ROOT_AUDIO
  1, // 4 -> ROOT_DEVICE_STORAGE
  3, // 5 -> ROOT_DOWNLOADS
  4, // 6 -> ROOT_HOME
  5, // 7 -> ROOT_IMAGES
  9, // 8 -> ROOT_RECENTS
  12, // 9 -> ROOT_VIDEOS
  6, // 10 -> ROOT_MTP
  10, // 11 -> ROOT_THIRD_PARTY_APP
  2, // 12 -> ROOT_DOCUMENTS
};

const std::string& Root_Name(
    Root value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Root_entries,
          Root_entries_by_number,
          13, Root_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Root_entries,
      Root_entries_by_number,
      13, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Root_strings[idx].get();
}
bool Root_Parse(
    const std::string& name, Root* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Root_entries, 13, name, &int_value);
  if (success) {
    *value = static_cast<Root>(int_value);
  }
  return success;
}
bool ContextScope_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ContextScope_strings[3] = {};

static const char ContextScope_names[] =
  "SCOPE_FILES"
  "SCOPE_PICKER"
  "SCOPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ContextScope_entries[] = {
  { {ContextScope_names + 0, 11}, 1 },
  { {ContextScope_names + 11, 12}, 2 },
  { {ContextScope_names + 23, 13}, 0 },
};

static const int ContextScope_entries_by_number[] = {
  2, // 0 -> SCOPE_UNKNOWN
  0, // 1 -> SCOPE_FILES
  1, // 2 -> SCOPE_PICKER
};

const std::string& ContextScope_Name(
    ContextScope value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ContextScope_entries,
          ContextScope_entries_by_number,
          3, ContextScope_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ContextScope_entries,
      ContextScope_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ContextScope_strings[idx].get();
}
bool ContextScope_Parse(
    const std::string& name, ContextScope* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ContextScope_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ContextScope>(int_value);
  }
  return success;
}
bool Provider_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Provider_strings[3] = {};

static const char Provider_names[] =
  "PROVIDER_EXTERNAL"
  "PROVIDER_SYSTEM"
  "PROVIDER_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Provider_entries[] = {
  { {Provider_names + 0, 17}, 2 },
  { {Provider_names + 17, 15}, 1 },
  { {Provider_names + 32, 16}, 0 },
};

static const int Provider_entries_by_number[] = {
  2, // 0 -> PROVIDER_UNKNOWN
  1, // 1 -> PROVIDER_SYSTEM
  0, // 2 -> PROVIDER_EXTERNAL
};

const std::string& Provider_Name(
    Provider value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Provider_entries,
          Provider_entries_by_number,
          3, Provider_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Provider_entries,
      Provider_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Provider_strings[idx].get();
}
bool Provider_Parse(
    const std::string& name, Provider* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Provider_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<Provider>(int_value);
  }
  return success;
}
bool FileOperation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FileOperation_strings[27] = {};

static const char FileOperation_names[] =
  "OP_COMPRESS_ERROR"
  "OP_COMPRESS_EXTERNAL_PROVIDER"
  "OP_COMPRESS_INTRA_PROVIDER"
  "OP_COMPRESS_SYSTEM_PROVIDER"
  "OP_COPY"
  "OP_COPY_ERROR"
  "OP_COPY_EXTERNAL_PROVIDER"
  "OP_COPY_INTRA_PROVIDER"
  "OP_COPY_SYSTEM_PROVIDER"
  "OP_CREATE_DIR"
  "OP_CREATE_DIR_ERROR"
  "OP_DELETE"
  "OP_DELETE_ERROR"
  "OP_EXTRACT_ERROR"
  "OP_EXTRACT_EXTERNAL_PROVIDER"
  "OP_EXTRACT_INTRA_PROVIDER"
  "OP_EXTRACT_SYSTEM_PROVIDER"
  "OP_MOVE"
  "OP_MOVE_ERROR"
  "OP_MOVE_EXTERNAL_PROVIDER"
  "OP_MOVE_INTRA_PROVIDER"
  "OP_MOVE_SYSTEM_PROVIDER"
  "OP_OTHER"
  "OP_OTHER_ERROR"
  "OP_RENAME"
  "OP_RENAME_ERROR"
  "OP_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FileOperation_entries[] = {
  { {FileOperation_names + 0, 17}, 25 },
  { {FileOperation_names + 17, 29}, 21 },
  { {FileOperation_names + 46, 26}, 19 },
  { {FileOperation_names + 72, 27}, 20 },
  { {FileOperation_names + 99, 7}, 2 },
  { {FileOperation_names + 106, 13}, 16 },
  { {FileOperation_names + 119, 25}, 5 },
  { {FileOperation_names + 144, 22}, 3 },
  { {FileOperation_names + 166, 23}, 4 },
  { {FileOperation_names + 189, 13}, 12 },
  { {FileOperation_names + 202, 19}, 18 },
  { {FileOperation_names + 221, 9}, 10 },
  { {FileOperation_names + 230, 15}, 14 },
  { {FileOperation_names + 245, 16}, 26 },
  { {FileOperation_names + 261, 28}, 24 },
  { {FileOperation_names + 289, 25}, 22 },
  { {FileOperation_names + 314, 26}, 23 },
  { {FileOperation_names + 340, 7}, 6 },
  { {FileOperation_names + 347, 13}, 15 },
  { {FileOperation_names + 360, 25}, 9 },
  { {FileOperation_names + 385, 22}, 7 },
  { {FileOperation_names + 407, 23}, 8 },
  { {FileOperation_names + 430, 8}, 1 },
  { {FileOperation_names + 438, 14}, 13 },
  { {FileOperation_names + 452, 9}, 11 },
  { {FileOperation_names + 461, 15}, 17 },
  { {FileOperation_names + 476, 10}, 0 },
};

static const int FileOperation_entries_by_number[] = {
  26, // 0 -> OP_UNKNOWN
  22, // 1 -> OP_OTHER
  4, // 2 -> OP_COPY
  7, // 3 -> OP_COPY_INTRA_PROVIDER
  8, // 4 -> OP_COPY_SYSTEM_PROVIDER
  6, // 5 -> OP_COPY_EXTERNAL_PROVIDER
  17, // 6 -> OP_MOVE
  20, // 7 -> OP_MOVE_INTRA_PROVIDER
  21, // 8 -> OP_MOVE_SYSTEM_PROVIDER
  19, // 9 -> OP_MOVE_EXTERNAL_PROVIDER
  11, // 10 -> OP_DELETE
  24, // 11 -> OP_RENAME
  9, // 12 -> OP_CREATE_DIR
  23, // 13 -> OP_OTHER_ERROR
  12, // 14 -> OP_DELETE_ERROR
  18, // 15 -> OP_MOVE_ERROR
  5, // 16 -> OP_COPY_ERROR
  25, // 17 -> OP_RENAME_ERROR
  10, // 18 -> OP_CREATE_DIR_ERROR
  2, // 19 -> OP_COMPRESS_INTRA_PROVIDER
  3, // 20 -> OP_COMPRESS_SYSTEM_PROVIDER
  1, // 21 -> OP_COMPRESS_EXTERNAL_PROVIDER
  15, // 22 -> OP_EXTRACT_INTRA_PROVIDER
  16, // 23 -> OP_EXTRACT_SYSTEM_PROVIDER
  14, // 24 -> OP_EXTRACT_EXTERNAL_PROVIDER
  0, // 25 -> OP_COMPRESS_ERROR
  13, // 26 -> OP_EXTRACT_ERROR
};

const std::string& FileOperation_Name(
    FileOperation value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FileOperation_entries,
          FileOperation_entries_by_number,
          27, FileOperation_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FileOperation_entries,
      FileOperation_entries_by_number,
      27, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FileOperation_strings[idx].get();
}
bool FileOperation_Parse(
    const std::string& name, FileOperation* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FileOperation_entries, 27, name, &int_value);
  if (success) {
    *value = static_cast<FileOperation>(int_value);
  }
  return success;
}
bool SubFileOperation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SubFileOperation_strings[11] = {};

static const char SubFileOperation_names[] =
  "SUB_OP_CREATE_DOC"
  "SUB_OP_DELETE_DOC"
  "SUB_OP_OBTAIN_STREAM_TYPE"
  "SUB_OP_OPEN_FILE"
  "SUB_OP_QUERY_CHILD"
  "SUB_OP_QUERY_DOC"
  "SUB_OP_QUICK_COPY"
  "SUB_OP_QUICK_MOVE"
  "SUB_OP_READ_FILE"
  "SUB_OP_UNKNOWN"
  "SUB_OP_WRITE_FILE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SubFileOperation_entries[] = {
  { {SubFileOperation_names + 0, 17}, 5 },
  { {SubFileOperation_names + 17, 17}, 7 },
  { {SubFileOperation_names + 34, 25}, 8 },
  { {SubFileOperation_names + 59, 16}, 3 },
  { {SubFileOperation_names + 75, 18}, 2 },
  { {SubFileOperation_names + 93, 16}, 1 },
  { {SubFileOperation_names + 109, 17}, 10 },
  { {SubFileOperation_names + 126, 17}, 9 },
  { {SubFileOperation_names + 143, 16}, 4 },
  { {SubFileOperation_names + 159, 14}, 0 },
  { {SubFileOperation_names + 173, 17}, 6 },
};

static const int SubFileOperation_entries_by_number[] = {
  9, // 0 -> SUB_OP_UNKNOWN
  5, // 1 -> SUB_OP_QUERY_DOC
  4, // 2 -> SUB_OP_QUERY_CHILD
  3, // 3 -> SUB_OP_OPEN_FILE
  8, // 4 -> SUB_OP_READ_FILE
  0, // 5 -> SUB_OP_CREATE_DOC
  10, // 6 -> SUB_OP_WRITE_FILE
  1, // 7 -> SUB_OP_DELETE_DOC
  2, // 8 -> SUB_OP_OBTAIN_STREAM_TYPE
  7, // 9 -> SUB_OP_QUICK_MOVE
  6, // 10 -> SUB_OP_QUICK_COPY
};

const std::string& SubFileOperation_Name(
    SubFileOperation value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SubFileOperation_entries,
          SubFileOperation_entries_by_number,
          11, SubFileOperation_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SubFileOperation_entries,
      SubFileOperation_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SubFileOperation_strings[idx].get();
}
bool SubFileOperation_Parse(
    const std::string& name, SubFileOperation* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SubFileOperation_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<SubFileOperation>(int_value);
  }
  return success;
}
bool CopyMoveOpMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CopyMoveOpMode_strings[4] = {};

static const char CopyMoveOpMode_names[] =
  "MODE_CONVENTIONAL"
  "MODE_CONVERTED"
  "MODE_PROVIDER"
  "MODE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CopyMoveOpMode_entries[] = {
  { {CopyMoveOpMode_names + 0, 17}, 3 },
  { {CopyMoveOpMode_names + 17, 14}, 2 },
  { {CopyMoveOpMode_names + 31, 13}, 1 },
  { {CopyMoveOpMode_names + 44, 12}, 0 },
};

static const int CopyMoveOpMode_entries_by_number[] = {
  3, // 0 -> MODE_UNKNOWN
  2, // 1 -> MODE_PROVIDER
  1, // 2 -> MODE_CONVERTED
  0, // 3 -> MODE_CONVENTIONAL
};

const std::string& CopyMoveOpMode_Name(
    CopyMoveOpMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CopyMoveOpMode_entries,
          CopyMoveOpMode_entries_by_number,
          4, CopyMoveOpMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CopyMoveOpMode_entries,
      CopyMoveOpMode_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CopyMoveOpMode_strings[idx].get();
}
bool CopyMoveOpMode_Parse(
    const std::string& name, CopyMoveOpMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CopyMoveOpMode_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<CopyMoveOpMode>(int_value);
  }
  return success;
}
bool Authority_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Authority_strings[7] = {};

static const char Authority_names[] =
  "AUTH_DOWNLOADS"
  "AUTH_MEDIA"
  "AUTH_MTP"
  "AUTH_OTHER"
  "AUTH_STORAGE_EXTERNAL"
  "AUTH_STORAGE_INTERNAL"
  "AUTH_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Authority_entries[] = {
  { {Authority_names + 0, 14}, 5 },
  { {Authority_names + 14, 10}, 2 },
  { {Authority_names + 24, 8}, 6 },
  { {Authority_names + 32, 10}, 1 },
  { {Authority_names + 42, 21}, 4 },
  { {Authority_names + 63, 21}, 3 },
  { {Authority_names + 84, 12}, 0 },
};

static const int Authority_entries_by_number[] = {
  6, // 0 -> AUTH_UNKNOWN
  3, // 1 -> AUTH_OTHER
  1, // 2 -> AUTH_MEDIA
  5, // 3 -> AUTH_STORAGE_INTERNAL
  4, // 4 -> AUTH_STORAGE_EXTERNAL
  0, // 5 -> AUTH_DOWNLOADS
  2, // 6 -> AUTH_MTP
};

const std::string& Authority_Name(
    Authority value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Authority_entries,
          Authority_entries_by_number,
          7, Authority_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Authority_entries,
      Authority_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Authority_strings[idx].get();
}
bool Authority_Parse(
    const std::string& name, Authority* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Authority_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<Authority>(int_value);
  }
  return success;
}
bool UserAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UserAction_strings[34] = {};

static const char UserAction_names[] =
  "ACTION_COMPRESS"
  "ACTION_COPY_CLIPBOARD"
  "ACTION_COPY_TO"
  "ACTION_CREATE_DIR"
  "ACTION_CUT_CLIPBOARD"
  "ACTION_DELETE"
  "ACTION_DRAG_N_DROP"
  "ACTION_DRAG_N_DROP_MULTI_WINDOW"
  "ACTION_EXTRACT_TO"
  "ACTION_GRID"
  "ACTION_HIDE_ADVANCED"
  "ACTION_HIDE_SIZE"
  "ACTION_INSPECTOR"
  "ACTION_LIST"
  "ACTION_MOVE_TO"
  "ACTION_NEW_WINDOW"
  "ACTION_OPEN"
  "ACTION_OTHER"
  "ACTION_PASTE_CLIPBOARD"
  "ACTION_RENAME"
  "ACTION_SEARCH"
  "ACTION_SEARCH_CHIP"
  "ACTION_SEARCH_HISTORY"
  "ACTION_SELECT_ALL"
  "ACTION_SETTINGS"
  "ACTION_SHARE"
  "ACTION_SHOW_ADVANCED"
  "ACTION_SHOW_SIZE"
  "ACTION_SORT_DATE"
  "ACTION_SORT_NAME"
  "ACTION_SORT_SIZE"
  "ACTION_SORT_TYPE"
  "ACTION_UNKNOWN"
  "ACTION_VIEW_IN_APPLICATION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UserAction_entries[] = {
  { {UserAction_names + 0, 15}, 28 },
  { {UserAction_names + 15, 21}, 24 },
  { {UserAction_names + 36, 14}, 12 },
  { {UserAction_names + 50, 17}, 16 },
  { {UserAction_names + 67, 20}, 27 },
  { {UserAction_names + 87, 13}, 14 },
  { {UserAction_names + 100, 18}, 25 },
  { {UserAction_names + 118, 31}, 26 },
  { {UserAction_names + 149, 17}, 29 },
  { {UserAction_names + 166, 11}, 2 },
  { {UserAction_names + 177, 20}, 21 },
  { {UserAction_names + 197, 16}, 10 },
  { {UserAction_names + 213, 16}, 31 },
  { {UserAction_names + 229, 11}, 3 },
  { {UserAction_names + 240, 14}, 13 },
  { {UserAction_names + 254, 17}, 22 },
  { {UserAction_names + 271, 11}, 19 },
  { {UserAction_names + 282, 12}, 1 },
  { {UserAction_names + 294, 22}, 23 },
  { {UserAction_names + 316, 13}, 15 },
  { {UserAction_names + 329, 13}, 8 },
  { {UserAction_names + 342, 18}, 32 },
  { {UserAction_names + 360, 21}, 33 },
  { {UserAction_names + 381, 17}, 17 },
  { {UserAction_names + 398, 15}, 11 },
  { {UserAction_names + 413, 12}, 18 },
  { {UserAction_names + 425, 20}, 20 },
  { {UserAction_names + 445, 16}, 9 },
  { {UserAction_names + 461, 16}, 5 },
  { {UserAction_names + 477, 16}, 4 },
  { {UserAction_names + 493, 16}, 6 },
  { {UserAction_names + 509, 16}, 7 },
  { {UserAction_names + 525, 14}, 0 },
  { {UserAction_names + 539, 26}, 30 },
};

static const int UserAction_entries_by_number[] = {
  32, // 0 -> ACTION_UNKNOWN
  17, // 1 -> ACTION_OTHER
  9, // 2 -> ACTION_GRID
  13, // 3 -> ACTION_LIST
  29, // 4 -> ACTION_SORT_NAME
  28, // 5 -> ACTION_SORT_DATE
  30, // 6 -> ACTION_SORT_SIZE
  31, // 7 -> ACTION_SORT_TYPE
  20, // 8 -> ACTION_SEARCH
  27, // 9 -> ACTION_SHOW_SIZE
  11, // 10 -> ACTION_HIDE_SIZE
  24, // 11 -> ACTION_SETTINGS
  2, // 12 -> ACTION_COPY_TO
  14, // 13 -> ACTION_MOVE_TO
  5, // 14 -> ACTION_DELETE
  19, // 15 -> ACTION_RENAME
  3, // 16 -> ACTION_CREATE_DIR
  23, // 17 -> ACTION_SELECT_ALL
  25, // 18 -> ACTION_SHARE
  16, // 19 -> ACTION_OPEN
  26, // 20 -> ACTION_SHOW_ADVANCED
  10, // 21 -> ACTION_HIDE_ADVANCED
  15, // 22 -> ACTION_NEW_WINDOW
  18, // 23 -> ACTION_PASTE_CLIPBOARD
  1, // 24 -> ACTION_COPY_CLIPBOARD
  6, // 25 -> ACTION_DRAG_N_DROP
  7, // 26 -> ACTION_DRAG_N_DROP_MULTI_WINDOW
  4, // 27 -> ACTION_CUT_CLIPBOARD
  0, // 28 -> ACTION_COMPRESS
  8, // 29 -> ACTION_EXTRACT_TO
  33, // 30 -> ACTION_VIEW_IN_APPLICATION
  12, // 31 -> ACTION_INSPECTOR
  21, // 32 -> ACTION_SEARCH_CHIP
  22, // 33 -> ACTION_SEARCH_HISTORY
};

const std::string& UserAction_Name(
    UserAction value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UserAction_entries,
          UserAction_entries_by_number,
          34, UserAction_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UserAction_entries,
      UserAction_entries_by_number,
      34, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UserAction_strings[idx].get();
}
bool UserAction_Parse(
    const std::string& name, UserAction* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UserAction_entries, 34, name, &int_value);
  if (success) {
    *value = static_cast<UserAction>(int_value);
  }
  return success;
}
bool InvalidScopedAccess_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> InvalidScopedAccess_strings[5] = {};

static const char InvalidScopedAccess_names[] =
  "SCOPED_DIR_ACCESS_DEPRECATED"
  "SCOPED_DIR_ACCESS_ERROR"
  "SCOPED_DIR_ACCESS_INVALID_ARGUMENTS"
  "SCOPED_DIR_ACCESS_INVALID_DIRECTORY"
  "SCOPED_DIR_ACCESS_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry InvalidScopedAccess_entries[] = {
  { {InvalidScopedAccess_names + 0, 28}, 4 },
  { {InvalidScopedAccess_names + 28, 23}, 3 },
  { {InvalidScopedAccess_names + 51, 35}, 1 },
  { {InvalidScopedAccess_names + 86, 35}, 2 },
  { {InvalidScopedAccess_names + 121, 25}, 0 },
};

static const int InvalidScopedAccess_entries_by_number[] = {
  4, // 0 -> SCOPED_DIR_ACCESS_UNKNOWN
  2, // 1 -> SCOPED_DIR_ACCESS_INVALID_ARGUMENTS
  3, // 2 -> SCOPED_DIR_ACCESS_INVALID_DIRECTORY
  1, // 3 -> SCOPED_DIR_ACCESS_ERROR
  0, // 4 -> SCOPED_DIR_ACCESS_DEPRECATED
};

const std::string& InvalidScopedAccess_Name(
    InvalidScopedAccess value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          InvalidScopedAccess_entries,
          InvalidScopedAccess_entries_by_number,
          5, InvalidScopedAccess_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      InvalidScopedAccess_entries,
      InvalidScopedAccess_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     InvalidScopedAccess_strings[idx].get();
}
bool InvalidScopedAccess_Parse(
    const std::string& name, InvalidScopedAccess* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      InvalidScopedAccess_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<InvalidScopedAccess>(int_value);
  }
  return success;
}
bool SearchType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SearchType_strings[9] = {};

static const char SearchType_names[] =
  "TYPE_CHIP_AUDIOS"
  "TYPE_CHIP_DOCS"
  "TYPE_CHIP_FROM_THIS_WEEK"
  "TYPE_CHIP_IMAGES"
  "TYPE_CHIP_LARGE_FILES"
  "TYPE_CHIP_VIDEOS"
  "TYPE_SEARCH_HISTORY"
  "TYPE_SEARCH_STRING"
  "TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SearchType_entries[] = {
  { {SearchType_names + 0, 16}, 2 },
  { {SearchType_names + 16, 14}, 4 },
  { {SearchType_names + 30, 24}, 8 },
  { {SearchType_names + 54, 16}, 1 },
  { {SearchType_names + 70, 21}, 7 },
  { {SearchType_names + 91, 16}, 3 },
  { {SearchType_names + 107, 19}, 5 },
  { {SearchType_names + 126, 18}, 6 },
  { {SearchType_names + 144, 12}, 0 },
};

static const int SearchType_entries_by_number[] = {
  8, // 0 -> TYPE_UNKNOWN
  3, // 1 -> TYPE_CHIP_IMAGES
  0, // 2 -> TYPE_CHIP_AUDIOS
  5, // 3 -> TYPE_CHIP_VIDEOS
  1, // 4 -> TYPE_CHIP_DOCS
  6, // 5 -> TYPE_SEARCH_HISTORY
  7, // 6 -> TYPE_SEARCH_STRING
  4, // 7 -> TYPE_CHIP_LARGE_FILES
  2, // 8 -> TYPE_CHIP_FROM_THIS_WEEK
};

const std::string& SearchType_Name(
    SearchType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SearchType_entries,
          SearchType_entries_by_number,
          9, SearchType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SearchType_entries,
      SearchType_entries_by_number,
      9, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SearchType_strings[idx].get();
}
bool SearchType_Parse(
    const std::string& name, SearchType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SearchType_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<SearchType>(int_value);
  }
  return success;
}
bool SearchMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SearchMode_strings[4] = {};

static const char SearchMode_names[] =
  "SEARCH_CHIPS"
  "SEARCH_KEYWORD"
  "SEARCH_KEYWORD_N_CHIPS"
  "SEARCH_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SearchMode_entries[] = {
  { {SearchMode_names + 0, 12}, 2 },
  { {SearchMode_names + 12, 14}, 1 },
  { {SearchMode_names + 26, 22}, 3 },
  { {SearchMode_names + 48, 14}, 0 },
};

static const int SearchMode_entries_by_number[] = {
  3, // 0 -> SEARCH_UNKNOWN
  1, // 1 -> SEARCH_KEYWORD
  0, // 2 -> SEARCH_CHIPS
  2, // 3 -> SEARCH_KEYWORD_N_CHIPS
};

const std::string& SearchMode_Name(
    SearchMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SearchMode_entries,
          SearchMode_entries_by_number,
          4, SearchMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SearchMode_entries,
      SearchMode_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SearchMode_strings[idx].get();
}
bool SearchMode_Parse(
    const std::string& name, SearchMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SearchMode_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<SearchMode>(int_value);
  }
  return success;
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace docsui
}  // namespace stats
}  // namespace android
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
