// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/service/enums.proto

#include "frameworks/proto_logging/stats/enums/service/enums.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
namespace android {
namespace service {
}  // namespace service
}  // namespace android
namespace android {
namespace service {
bool UsbEndPointType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UsbEndPointType_strings[4] = {};

static const char UsbEndPointType_names[] =
  "USB_ENDPOINT_TYPE_XFER_BULK"
  "USB_ENDPOINT_TYPE_XFER_CONTROL"
  "USB_ENDPOINT_TYPE_XFER_INT"
  "USB_ENDPOINT_TYPE_XFER_ISOC";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UsbEndPointType_entries[] = {
  { {UsbEndPointType_names + 0, 27}, 2 },
  { {UsbEndPointType_names + 27, 30}, 0 },
  { {UsbEndPointType_names + 57, 26}, 3 },
  { {UsbEndPointType_names + 83, 27}, 1 },
};

static const int UsbEndPointType_entries_by_number[] = {
  1, // 0 -> USB_ENDPOINT_TYPE_XFER_CONTROL
  3, // 1 -> USB_ENDPOINT_TYPE_XFER_ISOC
  0, // 2 -> USB_ENDPOINT_TYPE_XFER_BULK
  2, // 3 -> USB_ENDPOINT_TYPE_XFER_INT
};

const std::string& UsbEndPointType_Name(
    UsbEndPointType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UsbEndPointType_entries,
          UsbEndPointType_entries_by_number,
          4, UsbEndPointType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UsbEndPointType_entries,
      UsbEndPointType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UsbEndPointType_strings[idx].get();
}
bool UsbEndPointType_Parse(
    const std::string& name, UsbEndPointType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UsbEndPointType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<UsbEndPointType>(int_value);
  }
  return success;
}
bool UsbEndPointDirection_IsValid(int value) {
  switch (value) {
    case 0:
    case 128:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UsbEndPointDirection_strings[2] = {};

static const char UsbEndPointDirection_names[] =
  "USB_ENDPOINT_DIR_IN"
  "USB_ENDPOINT_DIR_OUT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UsbEndPointDirection_entries[] = {
  { {UsbEndPointDirection_names + 0, 19}, 128 },
  { {UsbEndPointDirection_names + 19, 20}, 0 },
};

static const int UsbEndPointDirection_entries_by_number[] = {
  1, // 0 -> USB_ENDPOINT_DIR_OUT
  0, // 128 -> USB_ENDPOINT_DIR_IN
};

const std::string& UsbEndPointDirection_Name(
    UsbEndPointDirection value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UsbEndPointDirection_entries,
          UsbEndPointDirection_entries_by_number,
          2, UsbEndPointDirection_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UsbEndPointDirection_entries,
      UsbEndPointDirection_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UsbEndPointDirection_strings[idx].get();
}
bool UsbEndPointDirection_Parse(
    const std::string& name, UsbEndPointDirection* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UsbEndPointDirection_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<UsbEndPointDirection>(int_value);
  }
  return success;
}
bool UsbConnectionRecordMode_IsValid(int value) {
  switch (value) {
    case -1:
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UsbConnectionRecordMode_strings[4] = {};

static const char UsbConnectionRecordMode_names[] =
  "USB_CONNECTION_RECORD_MODE_CONNECT"
  "USB_CONNECTION_RECORD_MODE_CONNECT_BADDEVICE"
  "USB_CONNECTION_RECORD_MODE_CONNECT_BADPARSE"
  "USB_CONNECTION_RECORD_MODE_DISCONNECT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UsbConnectionRecordMode_entries[] = {
  { {UsbConnectionRecordMode_names + 0, 34}, 0 },
  { {UsbConnectionRecordMode_names + 34, 44}, 2 },
  { {UsbConnectionRecordMode_names + 78, 43}, 1 },
  { {UsbConnectionRecordMode_names + 121, 37}, -1 },
};

static const int UsbConnectionRecordMode_entries_by_number[] = {
  3, // -1 -> USB_CONNECTION_RECORD_MODE_DISCONNECT
  0, // 0 -> USB_CONNECTION_RECORD_MODE_CONNECT
  2, // 1 -> USB_CONNECTION_RECORD_MODE_CONNECT_BADPARSE
  1, // 2 -> USB_CONNECTION_RECORD_MODE_CONNECT_BADDEVICE
};

const std::string& UsbConnectionRecordMode_Name(
    UsbConnectionRecordMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UsbConnectionRecordMode_entries,
          UsbConnectionRecordMode_entries_by_number,
          4, UsbConnectionRecordMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UsbConnectionRecordMode_entries,
      UsbConnectionRecordMode_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UsbConnectionRecordMode_strings[idx].get();
}
bool UsbConnectionRecordMode_Parse(
    const std::string& name, UsbConnectionRecordMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UsbConnectionRecordMode_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<UsbConnectionRecordMode>(int_value);
  }
  return success;
}
bool ContaminantPresenceStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ContaminantPresenceStatus_strings[5] = {};

static const char ContaminantPresenceStatus_names[] =
  "CONTAMINANT_STATUS_DETECTED"
  "CONTAMINANT_STATUS_DISABLED"
  "CONTAMINANT_STATUS_NOT_DETECTED"
  "CONTAMINANT_STATUS_NOT_SUPPORTED"
  "CONTAMINANT_STATUS_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ContaminantPresenceStatus_entries[] = {
  { {ContaminantPresenceStatus_names + 0, 27}, 4 },
  { {ContaminantPresenceStatus_names + 27, 27}, 2 },
  { {ContaminantPresenceStatus_names + 54, 31}, 3 },
  { {ContaminantPresenceStatus_names + 85, 32}, 1 },
  { {ContaminantPresenceStatus_names + 117, 26}, 0 },
};

static const int ContaminantPresenceStatus_entries_by_number[] = {
  4, // 0 -> CONTAMINANT_STATUS_UNKNOWN
  3, // 1 -> CONTAMINANT_STATUS_NOT_SUPPORTED
  1, // 2 -> CONTAMINANT_STATUS_DISABLED
  2, // 3 -> CONTAMINANT_STATUS_NOT_DETECTED
  0, // 4 -> CONTAMINANT_STATUS_DETECTED
};

const std::string& ContaminantPresenceStatus_Name(
    ContaminantPresenceStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ContaminantPresenceStatus_entries,
          ContaminantPresenceStatus_entries_by_number,
          5, ContaminantPresenceStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ContaminantPresenceStatus_entries,
      ContaminantPresenceStatus_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ContaminantPresenceStatus_strings[idx].get();
}
bool ContaminantPresenceStatus_Parse(
    const std::string& name, ContaminantPresenceStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ContaminantPresenceStatus_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<ContaminantPresenceStatus>(int_value);
  }
  return success;
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace service
}  // namespace android
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
