// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/os/enums.proto

#include "frameworks/proto_logging/stats/enums/os/enums.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
namespace android {
namespace os {
}  // namespace os
}  // namespace android
namespace android {
namespace os {
bool BatteryHealthEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BatteryHealthEnum_strings[8] = {};

static const char BatteryHealthEnum_names[] =
  "BATTERY_HEALTH_COLD"
  "BATTERY_HEALTH_DEAD"
  "BATTERY_HEALTH_GOOD"
  "BATTERY_HEALTH_INVALID"
  "BATTERY_HEALTH_OVERHEAT"
  "BATTERY_HEALTH_OVER_VOLTAGE"
  "BATTERY_HEALTH_UNKNOWN"
  "BATTERY_HEALTH_UNSPECIFIED_FAILURE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BatteryHealthEnum_entries[] = {
  { {BatteryHealthEnum_names + 0, 19}, 7 },
  { {BatteryHealthEnum_names + 19, 19}, 4 },
  { {BatteryHealthEnum_names + 38, 19}, 2 },
  { {BatteryHealthEnum_names + 57, 22}, 0 },
  { {BatteryHealthEnum_names + 79, 23}, 3 },
  { {BatteryHealthEnum_names + 102, 27}, 5 },
  { {BatteryHealthEnum_names + 129, 22}, 1 },
  { {BatteryHealthEnum_names + 151, 34}, 6 },
};

static const int BatteryHealthEnum_entries_by_number[] = {
  3, // 0 -> BATTERY_HEALTH_INVALID
  6, // 1 -> BATTERY_HEALTH_UNKNOWN
  2, // 2 -> BATTERY_HEALTH_GOOD
  4, // 3 -> BATTERY_HEALTH_OVERHEAT
  1, // 4 -> BATTERY_HEALTH_DEAD
  5, // 5 -> BATTERY_HEALTH_OVER_VOLTAGE
  7, // 6 -> BATTERY_HEALTH_UNSPECIFIED_FAILURE
  0, // 7 -> BATTERY_HEALTH_COLD
};

const std::string& BatteryHealthEnum_Name(
    BatteryHealthEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BatteryHealthEnum_entries,
          BatteryHealthEnum_entries_by_number,
          8, BatteryHealthEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BatteryHealthEnum_entries,
      BatteryHealthEnum_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BatteryHealthEnum_strings[idx].get();
}
bool BatteryHealthEnum_Parse(
    const std::string& name, BatteryHealthEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BatteryHealthEnum_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<BatteryHealthEnum>(int_value);
  }
  return success;
}
bool BatteryPluggedStateEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BatteryPluggedStateEnum_strings[4] = {};

static const char BatteryPluggedStateEnum_names[] =
  "BATTERY_PLUGGED_AC"
  "BATTERY_PLUGGED_NONE"
  "BATTERY_PLUGGED_USB"
  "BATTERY_PLUGGED_WIRELESS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BatteryPluggedStateEnum_entries[] = {
  { {BatteryPluggedStateEnum_names + 0, 18}, 1 },
  { {BatteryPluggedStateEnum_names + 18, 20}, 0 },
  { {BatteryPluggedStateEnum_names + 38, 19}, 2 },
  { {BatteryPluggedStateEnum_names + 57, 24}, 4 },
};

static const int BatteryPluggedStateEnum_entries_by_number[] = {
  1, // 0 -> BATTERY_PLUGGED_NONE
  0, // 1 -> BATTERY_PLUGGED_AC
  2, // 2 -> BATTERY_PLUGGED_USB
  3, // 4 -> BATTERY_PLUGGED_WIRELESS
};

const std::string& BatteryPluggedStateEnum_Name(
    BatteryPluggedStateEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BatteryPluggedStateEnum_entries,
          BatteryPluggedStateEnum_entries_by_number,
          4, BatteryPluggedStateEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BatteryPluggedStateEnum_entries,
      BatteryPluggedStateEnum_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BatteryPluggedStateEnum_strings[idx].get();
}
bool BatteryPluggedStateEnum_Parse(
    const std::string& name, BatteryPluggedStateEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BatteryPluggedStateEnum_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<BatteryPluggedStateEnum>(int_value);
  }
  return success;
}
bool BatteryStatusEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BatteryStatusEnum_strings[6] = {};

static const char BatteryStatusEnum_names[] =
  "BATTERY_STATUS_CHARGING"
  "BATTERY_STATUS_DISCHARGING"
  "BATTERY_STATUS_FULL"
  "BATTERY_STATUS_INVALID"
  "BATTERY_STATUS_NOT_CHARGING"
  "BATTERY_STATUS_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BatteryStatusEnum_entries[] = {
  { {BatteryStatusEnum_names + 0, 23}, 2 },
  { {BatteryStatusEnum_names + 23, 26}, 3 },
  { {BatteryStatusEnum_names + 49, 19}, 5 },
  { {BatteryStatusEnum_names + 68, 22}, 0 },
  { {BatteryStatusEnum_names + 90, 27}, 4 },
  { {BatteryStatusEnum_names + 117, 22}, 1 },
};

static const int BatteryStatusEnum_entries_by_number[] = {
  3, // 0 -> BATTERY_STATUS_INVALID
  5, // 1 -> BATTERY_STATUS_UNKNOWN
  0, // 2 -> BATTERY_STATUS_CHARGING
  1, // 3 -> BATTERY_STATUS_DISCHARGING
  4, // 4 -> BATTERY_STATUS_NOT_CHARGING
  2, // 5 -> BATTERY_STATUS_FULL
};

const std::string& BatteryStatusEnum_Name(
    BatteryStatusEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BatteryStatusEnum_entries,
          BatteryStatusEnum_entries_by_number,
          6, BatteryStatusEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BatteryStatusEnum_entries,
      BatteryStatusEnum_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BatteryStatusEnum_strings[idx].get();
}
bool BatteryStatusEnum_Parse(
    const std::string& name, BatteryStatusEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BatteryStatusEnum_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<BatteryStatusEnum>(int_value);
  }
  return success;
}
bool PowerComponentEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PowerComponentEnum_strings[18] = {};

static const char PowerComponentEnum_names[] =
  "POWER_COMPONENT_AMBIENT_DISPLAY"
  "POWER_COMPONENT_AUDIO"
  "POWER_COMPONENT_BLUETOOTH"
  "POWER_COMPONENT_CAMERA"
  "POWER_COMPONENT_CPU"
  "POWER_COMPONENT_FLASHLIGHT"
  "POWER_COMPONENT_GNSS"
  "POWER_COMPONENT_IDLE"
  "POWER_COMPONENT_MEMORY"
  "POWER_COMPONENT_MOBILE_RADIO"
  "POWER_COMPONENT_PHONE"
  "POWER_COMPONENT_REATTRIBUTED_TO_OTHER_CONSUMERS"
  "POWER_COMPONENT_SCREEN"
  "POWER_COMPONENT_SENSORS"
  "POWER_COMPONENT_SYSTEM_SERVICES"
  "POWER_COMPONENT_VIDEO"
  "POWER_COMPONENT_WAKELOCK"
  "POWER_COMPONENT_WIFI";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PowerComponentEnum_entries[] = {
  { {PowerComponentEnum_names + 0, 31}, 15 },
  { {PowerComponentEnum_names + 31, 21}, 4 },
  { {PowerComponentEnum_names + 52, 25}, 2 },
  { {PowerComponentEnum_names + 77, 22}, 3 },
  { {PowerComponentEnum_names + 99, 19}, 1 },
  { {PowerComponentEnum_names + 118, 26}, 6 },
  { {PowerComponentEnum_names + 144, 20}, 10 },
  { {PowerComponentEnum_names + 164, 20}, 16 },
  { {PowerComponentEnum_names + 184, 22}, 13 },
  { {PowerComponentEnum_names + 206, 28}, 8 },
  { {PowerComponentEnum_names + 234, 21}, 14 },
  { {PowerComponentEnum_names + 255, 47}, 17 },
  { {PowerComponentEnum_names + 302, 22}, 0 },
  { {PowerComponentEnum_names + 324, 23}, 9 },
  { {PowerComponentEnum_names + 347, 31}, 7 },
  { {PowerComponentEnum_names + 378, 21}, 5 },
  { {PowerComponentEnum_names + 399, 24}, 12 },
  { {PowerComponentEnum_names + 423, 20}, 11 },
};

static const int PowerComponentEnum_entries_by_number[] = {
  12, // 0 -> POWER_COMPONENT_SCREEN
  4, // 1 -> POWER_COMPONENT_CPU
  2, // 2 -> POWER_COMPONENT_BLUETOOTH
  3, // 3 -> POWER_COMPONENT_CAMERA
  1, // 4 -> POWER_COMPONENT_AUDIO
  15, // 5 -> POWER_COMPONENT_VIDEO
  5, // 6 -> POWER_COMPONENT_FLASHLIGHT
  14, // 7 -> POWER_COMPONENT_SYSTEM_SERVICES
  9, // 8 -> POWER_COMPONENT_MOBILE_RADIO
  13, // 9 -> POWER_COMPONENT_SENSORS
  6, // 10 -> POWER_COMPONENT_GNSS
  17, // 11 -> POWER_COMPONENT_WIFI
  16, // 12 -> POWER_COMPONENT_WAKELOCK
  8, // 13 -> POWER_COMPONENT_MEMORY
  10, // 14 -> POWER_COMPONENT_PHONE
  0, // 15 -> POWER_COMPONENT_AMBIENT_DISPLAY
  7, // 16 -> POWER_COMPONENT_IDLE
  11, // 17 -> POWER_COMPONENT_REATTRIBUTED_TO_OTHER_CONSUMERS
};

const std::string& PowerComponentEnum_Name(
    PowerComponentEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PowerComponentEnum_entries,
          PowerComponentEnum_entries_by_number,
          18, PowerComponentEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PowerComponentEnum_entries,
      PowerComponentEnum_entries_by_number,
      18, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PowerComponentEnum_strings[idx].get();
}
bool PowerComponentEnum_Parse(
    const std::string& name, PowerComponentEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PowerComponentEnum_entries, 18, name, &int_value);
  if (success) {
    *value = static_cast<PowerComponentEnum>(int_value);
  }
  return success;
}
bool TemperatureTypeEnum_IsValid(int value) {
  switch (value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TemperatureTypeEnum_strings[11] = {};

static const char TemperatureTypeEnum_names[] =
  "TEMPERATURE_TYPE_BATTERY"
  "TEMPERATURE_TYPE_BCL_CURRENT"
  "TEMPERATURE_TYPE_BCL_PERCENTAGE"
  "TEMPERATURE_TYPE_BCL_VOLTAGE"
  "TEMPERATURE_TYPE_CPU"
  "TEMPERATURE_TYPE_GPU"
  "TEMPERATURE_TYPE_NPU"
  "TEMPERATURE_TYPE_POWER_AMPLIFIER"
  "TEMPERATURE_TYPE_SKIN"
  "TEMPERATURE_TYPE_UNKNOWN"
  "TEMPERATURE_TYPE_USB_PORT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TemperatureTypeEnum_entries[] = {
  { {TemperatureTypeEnum_names + 0, 24}, 2 },
  { {TemperatureTypeEnum_names + 24, 28}, 7 },
  { {TemperatureTypeEnum_names + 52, 31}, 8 },
  { {TemperatureTypeEnum_names + 83, 28}, 6 },
  { {TemperatureTypeEnum_names + 111, 20}, 0 },
  { {TemperatureTypeEnum_names + 131, 20}, 1 },
  { {TemperatureTypeEnum_names + 151, 20}, 9 },
  { {TemperatureTypeEnum_names + 171, 32}, 5 },
  { {TemperatureTypeEnum_names + 203, 21}, 3 },
  { {TemperatureTypeEnum_names + 224, 24}, -1 },
  { {TemperatureTypeEnum_names + 248, 25}, 4 },
};

static const int TemperatureTypeEnum_entries_by_number[] = {
  9, // -1 -> TEMPERATURE_TYPE_UNKNOWN
  4, // 0 -> TEMPERATURE_TYPE_CPU
  5, // 1 -> TEMPERATURE_TYPE_GPU
  0, // 2 -> TEMPERATURE_TYPE_BATTERY
  8, // 3 -> TEMPERATURE_TYPE_SKIN
  10, // 4 -> TEMPERATURE_TYPE_USB_PORT
  7, // 5 -> TEMPERATURE_TYPE_POWER_AMPLIFIER
  3, // 6 -> TEMPERATURE_TYPE_BCL_VOLTAGE
  1, // 7 -> TEMPERATURE_TYPE_BCL_CURRENT
  2, // 8 -> TEMPERATURE_TYPE_BCL_PERCENTAGE
  6, // 9 -> TEMPERATURE_TYPE_NPU
};

const std::string& TemperatureTypeEnum_Name(
    TemperatureTypeEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TemperatureTypeEnum_entries,
          TemperatureTypeEnum_entries_by_number,
          11, TemperatureTypeEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TemperatureTypeEnum_entries,
      TemperatureTypeEnum_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TemperatureTypeEnum_strings[idx].get();
}
bool TemperatureTypeEnum_Parse(
    const std::string& name, TemperatureTypeEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TemperatureTypeEnum_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<TemperatureTypeEnum>(int_value);
  }
  return success;
}
bool ThrottlingSeverityEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ThrottlingSeverityEnum_strings[7] = {};

static const char ThrottlingSeverityEnum_names[] =
  "CRITICAL"
  "EMERGENCY"
  "LIGHT"
  "MODERATE"
  "NONE"
  "SEVERE"
  "SHUTDOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ThrottlingSeverityEnum_entries[] = {
  { {ThrottlingSeverityEnum_names + 0, 8}, 4 },
  { {ThrottlingSeverityEnum_names + 8, 9}, 5 },
  { {ThrottlingSeverityEnum_names + 17, 5}, 1 },
  { {ThrottlingSeverityEnum_names + 22, 8}, 2 },
  { {ThrottlingSeverityEnum_names + 30, 4}, 0 },
  { {ThrottlingSeverityEnum_names + 34, 6}, 3 },
  { {ThrottlingSeverityEnum_names + 40, 8}, 6 },
};

static const int ThrottlingSeverityEnum_entries_by_number[] = {
  4, // 0 -> NONE
  2, // 1 -> LIGHT
  3, // 2 -> MODERATE
  5, // 3 -> SEVERE
  0, // 4 -> CRITICAL
  1, // 5 -> EMERGENCY
  6, // 6 -> SHUTDOWN
};

const std::string& ThrottlingSeverityEnum_Name(
    ThrottlingSeverityEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ThrottlingSeverityEnum_entries,
          ThrottlingSeverityEnum_entries_by_number,
          7, ThrottlingSeverityEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ThrottlingSeverityEnum_entries,
      ThrottlingSeverityEnum_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ThrottlingSeverityEnum_strings[idx].get();
}
bool ThrottlingSeverityEnum_Parse(
    const std::string& name, ThrottlingSeverityEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ThrottlingSeverityEnum_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<ThrottlingSeverityEnum>(int_value);
  }
  return success;
}
bool CoolingTypeEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CoolingTypeEnum_strings[7] = {};

static const char CoolingTypeEnum_names[] =
  "BATTERY"
  "COMPONENT"
  "CPU"
  "FAN"
  "GPU"
  "MODEM"
  "NPU";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CoolingTypeEnum_entries[] = {
  { {CoolingTypeEnum_names + 0, 7}, 1 },
  { {CoolingTypeEnum_names + 7, 9}, 6 },
  { {CoolingTypeEnum_names + 16, 3}, 2 },
  { {CoolingTypeEnum_names + 19, 3}, 0 },
  { {CoolingTypeEnum_names + 22, 3}, 3 },
  { {CoolingTypeEnum_names + 25, 5}, 4 },
  { {CoolingTypeEnum_names + 30, 3}, 5 },
};

static const int CoolingTypeEnum_entries_by_number[] = {
  3, // 0 -> FAN
  0, // 1 -> BATTERY
  2, // 2 -> CPU
  4, // 3 -> GPU
  5, // 4 -> MODEM
  6, // 5 -> NPU
  1, // 6 -> COMPONENT
};

const std::string& CoolingTypeEnum_Name(
    CoolingTypeEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CoolingTypeEnum_entries,
          CoolingTypeEnum_entries_by_number,
          7, CoolingTypeEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CoolingTypeEnum_entries,
      CoolingTypeEnum_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CoolingTypeEnum_strings[idx].get();
}
bool CoolingTypeEnum_Parse(
    const std::string& name, CoolingTypeEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CoolingTypeEnum_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<CoolingTypeEnum>(int_value);
  }
  return success;
}
bool WakeLockLevelEnum_IsValid(int value) {
  switch (value) {
    case 1:
    case 6:
    case 10:
    case 26:
    case 32:
    case 64:
    case 128:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> WakeLockLevelEnum_strings[7] = {};

static const char WakeLockLevelEnum_names[] =
  "DOZE_WAKE_LOCK"
  "DRAW_WAKE_LOCK"
  "FULL_WAKE_LOCK"
  "PARTIAL_WAKE_LOCK"
  "PROXIMITY_SCREEN_OFF_WAKE_LOCK"
  "SCREEN_BRIGHT_WAKE_LOCK"
  "SCREEN_DIM_WAKE_LOCK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry WakeLockLevelEnum_entries[] = {
  { {WakeLockLevelEnum_names + 0, 14}, 64 },
  { {WakeLockLevelEnum_names + 14, 14}, 128 },
  { {WakeLockLevelEnum_names + 28, 14}, 26 },
  { {WakeLockLevelEnum_names + 42, 17}, 1 },
  { {WakeLockLevelEnum_names + 59, 30}, 32 },
  { {WakeLockLevelEnum_names + 89, 23}, 10 },
  { {WakeLockLevelEnum_names + 112, 20}, 6 },
};

static const int WakeLockLevelEnum_entries_by_number[] = {
  3, // 1 -> PARTIAL_WAKE_LOCK
  6, // 6 -> SCREEN_DIM_WAKE_LOCK
  5, // 10 -> SCREEN_BRIGHT_WAKE_LOCK
  2, // 26 -> FULL_WAKE_LOCK
  4, // 32 -> PROXIMITY_SCREEN_OFF_WAKE_LOCK
  0, // 64 -> DOZE_WAKE_LOCK
  1, // 128 -> DRAW_WAKE_LOCK
};

const std::string& WakeLockLevelEnum_Name(
    WakeLockLevelEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          WakeLockLevelEnum_entries,
          WakeLockLevelEnum_entries_by_number,
          7, WakeLockLevelEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      WakeLockLevelEnum_entries,
      WakeLockLevelEnum_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     WakeLockLevelEnum_strings[idx].get();
}
bool WakeLockLevelEnum_Parse(
    const std::string& name, WakeLockLevelEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      WakeLockLevelEnum_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<WakeLockLevelEnum>(int_value);
  }
  return success;
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace os
}  // namespace android
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
