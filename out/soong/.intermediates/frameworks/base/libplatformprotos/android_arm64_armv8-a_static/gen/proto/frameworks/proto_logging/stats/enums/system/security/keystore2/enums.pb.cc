// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/system/security/keystore2/enums.proto

#include "frameworks/proto_logging/stats/enums/system/security/keystore2/enums.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
namespace android {
namespace system {
namespace security {
namespace keystore2 {
}  // namespace keystore2
}  // namespace security
}  // namespace system
}  // namespace android
namespace android {
namespace system {
namespace security {
namespace keystore2 {
bool SecurityLevelEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SecurityLevelEnum_strings[5] = {};

static const char SecurityLevelEnum_names[] =
  "SECURITY_LEVEL_KEYSTORE"
  "SECURITY_LEVEL_SOFTWARE"
  "SECURITY_LEVEL_STRONGBOX"
  "SECURITY_LEVEL_TRUSTED_ENVIRONMENT"
  "SECURITY_LEVEL_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SecurityLevelEnum_entries[] = {
  { {SecurityLevelEnum_names + 0, 23}, 4 },
  { {SecurityLevelEnum_names + 23, 23}, 1 },
  { {SecurityLevelEnum_names + 46, 24}, 3 },
  { {SecurityLevelEnum_names + 70, 34}, 2 },
  { {SecurityLevelEnum_names + 104, 26}, 0 },
};

static const int SecurityLevelEnum_entries_by_number[] = {
  4, // 0 -> SECURITY_LEVEL_UNSPECIFIED
  1, // 1 -> SECURITY_LEVEL_SOFTWARE
  3, // 2 -> SECURITY_LEVEL_TRUSTED_ENVIRONMENT
  2, // 3 -> SECURITY_LEVEL_STRONGBOX
  0, // 4 -> SECURITY_LEVEL_KEYSTORE
};

const std::string& SecurityLevelEnum_Name(
    SecurityLevelEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SecurityLevelEnum_entries,
          SecurityLevelEnum_entries_by_number,
          5, SecurityLevelEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SecurityLevelEnum_entries,
      SecurityLevelEnum_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SecurityLevelEnum_strings[idx].get();
}
bool SecurityLevelEnum_Parse(
    const std::string& name, SecurityLevelEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SecurityLevelEnum_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<SecurityLevelEnum>(int_value);
  }
  return success;
}
bool Algorithm_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 3:
    case 32:
    case 33:
    case 128:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Algorithm_strings[6] = {};

static const char Algorithm_names[] =
  "AES"
  "ALGORITHM_UNSPECIFIED"
  "EC"
  "HMAC"
  "RSA"
  "TRIPLE_DES";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Algorithm_entries[] = {
  { {Algorithm_names + 0, 3}, 32 },
  { {Algorithm_names + 3, 21}, 0 },
  { {Algorithm_names + 24, 2}, 3 },
  { {Algorithm_names + 26, 4}, 128 },
  { {Algorithm_names + 30, 3}, 1 },
  { {Algorithm_names + 33, 10}, 33 },
};

static const int Algorithm_entries_by_number[] = {
  1, // 0 -> ALGORITHM_UNSPECIFIED
  4, // 1 -> RSA
  2, // 3 -> EC
  0, // 32 -> AES
  5, // 33 -> TRIPLE_DES
  3, // 128 -> HMAC
};

const std::string& Algorithm_Name(
    Algorithm value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Algorithm_entries,
          Algorithm_entries_by_number,
          6, Algorithm_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Algorithm_entries,
      Algorithm_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Algorithm_strings[idx].get();
}
bool Algorithm_Parse(
    const std::string& name, Algorithm* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Algorithm_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<Algorithm>(int_value);
  }
  return success;
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace keystore2
}  // namespace security
}  // namespace system
}  // namespace android
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
