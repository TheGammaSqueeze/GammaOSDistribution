// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/stats/connectivity/tethering.proto

#include "frameworks/proto_logging/stats/enums/stats/connectivity/tethering.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
namespace android {
namespace stats {
namespace connectivity {
}  // namespace connectivity
}  // namespace stats
}  // namespace android
namespace android {
namespace stats {
namespace connectivity {
bool ErrorCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ErrorCode_strings[17] = {};

static const char ErrorCode_names[] =
  "EC_DHCPSERVER_ERROR"
  "EC_DISABLE_FORWARDING_ERROR"
  "EC_ENABLE_FORWARDING_ERROR"
  "EC_ENTITLEMENT_UNKNOWN"
  "EC_IFACE_CFG_ERROR"
  "EC_INTERNAL_ERROR"
  "EC_NO_ACCESS_TETHERING_PERMISSION"
  "EC_NO_CHANGE_TETHERING_PERMISSION"
  "EC_NO_ERROR"
  "EC_PROVISIONING_FAILED"
  "EC_SERVICE_UNAVAIL"
  "EC_TETHER_IFACE_ERROR"
  "EC_UNAVAIL_IFACE"
  "EC_UNKNOWN_IFACE"
  "EC_UNKNOWN_TYPE"
  "EC_UNSUPPORTED"
  "EC_UNTETHER_IFACE_ERROR";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ErrorCode_entries[] = {
  { {ErrorCode_names + 0, 19}, 12 },
  { {ErrorCode_names + 19, 27}, 9 },
  { {ErrorCode_names + 46, 26}, 8 },
  { {ErrorCode_names + 72, 22}, 13 },
  { {ErrorCode_names + 94, 18}, 10 },
  { {ErrorCode_names + 112, 17}, 5 },
  { {ErrorCode_names + 129, 33}, 15 },
  { {ErrorCode_names + 162, 33}, 14 },
  { {ErrorCode_names + 195, 11}, 0 },
  { {ErrorCode_names + 206, 22}, 11 },
  { {ErrorCode_names + 228, 18}, 2 },
  { {ErrorCode_names + 246, 21}, 6 },
  { {ErrorCode_names + 267, 16}, 4 },
  { {ErrorCode_names + 283, 16}, 1 },
  { {ErrorCode_names + 299, 15}, 16 },
  { {ErrorCode_names + 314, 14}, 3 },
  { {ErrorCode_names + 328, 23}, 7 },
};

static const int ErrorCode_entries_by_number[] = {
  8, // 0 -> EC_NO_ERROR
  13, // 1 -> EC_UNKNOWN_IFACE
  10, // 2 -> EC_SERVICE_UNAVAIL
  15, // 3 -> EC_UNSUPPORTED
  12, // 4 -> EC_UNAVAIL_IFACE
  5, // 5 -> EC_INTERNAL_ERROR
  11, // 6 -> EC_TETHER_IFACE_ERROR
  16, // 7 -> EC_UNTETHER_IFACE_ERROR
  2, // 8 -> EC_ENABLE_FORWARDING_ERROR
  1, // 9 -> EC_DISABLE_FORWARDING_ERROR
  4, // 10 -> EC_IFACE_CFG_ERROR
  9, // 11 -> EC_PROVISIONING_FAILED
  0, // 12 -> EC_DHCPSERVER_ERROR
  3, // 13 -> EC_ENTITLEMENT_UNKNOWN
  7, // 14 -> EC_NO_CHANGE_TETHERING_PERMISSION
  6, // 15 -> EC_NO_ACCESS_TETHERING_PERMISSION
  14, // 16 -> EC_UNKNOWN_TYPE
};

const std::string& ErrorCode_Name(
    ErrorCode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ErrorCode_entries,
          ErrorCode_entries_by_number,
          17, ErrorCode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ErrorCode_entries,
      ErrorCode_entries_by_number,
      17, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ErrorCode_strings[idx].get();
}
bool ErrorCode_Parse(
    const std::string& name, ErrorCode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ErrorCode_entries, 17, name, &int_value);
  if (success) {
    *value = static_cast<ErrorCode>(int_value);
  }
  return success;
}
bool DownstreamType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DownstreamType_strings[7] = {};

static const char DownstreamType_names[] =
  "DS_TETHERING_BLUETOOTH"
  "DS_TETHERING_ETHERNET"
  "DS_TETHERING_NCM"
  "DS_TETHERING_USB"
  "DS_TETHERING_WIFI"
  "DS_TETHERING_WIFI_P2P"
  "DS_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DownstreamType_entries[] = {
  { {DownstreamType_names + 0, 22}, 3 },
  { {DownstreamType_names + 22, 21}, 6 },
  { {DownstreamType_names + 43, 16}, 5 },
  { {DownstreamType_names + 59, 16}, 2 },
  { {DownstreamType_names + 75, 17}, 1 },
  { {DownstreamType_names + 92, 21}, 4 },
  { {DownstreamType_names + 113, 14}, 0 },
};

static const int DownstreamType_entries_by_number[] = {
  6, // 0 -> DS_UNSPECIFIED
  4, // 1 -> DS_TETHERING_WIFI
  3, // 2 -> DS_TETHERING_USB
  0, // 3 -> DS_TETHERING_BLUETOOTH
  5, // 4 -> DS_TETHERING_WIFI_P2P
  2, // 5 -> DS_TETHERING_NCM
  1, // 6 -> DS_TETHERING_ETHERNET
};

const std::string& DownstreamType_Name(
    DownstreamType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DownstreamType_entries,
          DownstreamType_entries_by_number,
          7, DownstreamType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DownstreamType_entries,
      DownstreamType_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DownstreamType_strings[idx].get();
}
bool DownstreamType_Parse(
    const std::string& name, DownstreamType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DownstreamType_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<DownstreamType>(int_value);
  }
  return success;
}
bool UpstreamType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UpstreamType_strings[14] = {};

static const char UpstreamType_names[] =
  "UT_BLUETOOTH"
  "UT_BLUETOOTH_VPN"
  "UT_CELLULAR"
  "UT_CELLULAR_VPN"
  "UT_DUN_CELLULAR"
  "UT_ETHERNET"
  "UT_ETHERNET_VPN"
  "UT_LOWPAN"
  "UT_TEST"
  "UT_UNKNOWN"
  "UT_WIFI"
  "UT_WIFI_AWARE"
  "UT_WIFI_CELLULAR_VPN"
  "UT_WIFI_VPN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UpstreamType_entries[] = {
  { {UpstreamType_names + 0, 12}, 3 },
  { {UpstreamType_names + 12, 16}, 9 },
  { {UpstreamType_names + 28, 11}, 1 },
  { {UpstreamType_names + 39, 15}, 7 },
  { {UpstreamType_names + 54, 15}, 13 },
  { {UpstreamType_names + 69, 11}, 4 },
  { {UpstreamType_names + 80, 15}, 10 },
  { {UpstreamType_names + 95, 9}, 6 },
  { {UpstreamType_names + 104, 7}, 12 },
  { {UpstreamType_names + 111, 10}, 0 },
  { {UpstreamType_names + 121, 7}, 2 },
  { {UpstreamType_names + 128, 13}, 5 },
  { {UpstreamType_names + 141, 20}, 11 },
  { {UpstreamType_names + 161, 11}, 8 },
};

static const int UpstreamType_entries_by_number[] = {
  9, // 0 -> UT_UNKNOWN
  2, // 1 -> UT_CELLULAR
  10, // 2 -> UT_WIFI
  0, // 3 -> UT_BLUETOOTH
  5, // 4 -> UT_ETHERNET
  11, // 5 -> UT_WIFI_AWARE
  7, // 6 -> UT_LOWPAN
  3, // 7 -> UT_CELLULAR_VPN
  13, // 8 -> UT_WIFI_VPN
  1, // 9 -> UT_BLUETOOTH_VPN
  6, // 10 -> UT_ETHERNET_VPN
  12, // 11 -> UT_WIFI_CELLULAR_VPN
  8, // 12 -> UT_TEST
  4, // 13 -> UT_DUN_CELLULAR
};

const std::string& UpstreamType_Name(
    UpstreamType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UpstreamType_entries,
          UpstreamType_entries_by_number,
          14, UpstreamType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UpstreamType_entries,
      UpstreamType_entries_by_number,
      14, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UpstreamType_strings[idx].get();
}
bool UpstreamType_Parse(
    const std::string& name, UpstreamType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UpstreamType_entries, 14, name, &int_value);
  if (success) {
    *value = static_cast<UpstreamType>(int_value);
  }
  return success;
}
bool UserType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UserType_strings[4] = {};

static const char UserType_names[] =
  "USER_GMS"
  "USER_SETTINGS"
  "USER_SYSTEMUI"
  "USER_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UserType_entries[] = {
  { {UserType_names + 0, 8}, 3 },
  { {UserType_names + 8, 13}, 1 },
  { {UserType_names + 21, 13}, 2 },
  { {UserType_names + 34, 12}, 0 },
};

static const int UserType_entries_by_number[] = {
  3, // 0 -> USER_UNKNOWN
  1, // 1 -> USER_SETTINGS
  2, // 2 -> USER_SYSTEMUI
  0, // 3 -> USER_GMS
};

const std::string& UserType_Name(
    UserType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UserType_entries,
          UserType_entries_by_number,
          4, UserType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UserType_entries,
      UserType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UserType_strings[idx].get();
}
bool UserType_Parse(
    const std::string& name, UserType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UserType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<UserType>(int_value);
  }
  return success;
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace connectivity
}  // namespace stats
}  // namespace android
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
