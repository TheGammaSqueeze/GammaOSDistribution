// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/telephony/enums.proto

#include "frameworks/proto_logging/stats/enums/telephony/enums.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
namespace android {
namespace telephony {
}  // namespace telephony
}  // namespace android
namespace android {
namespace telephony {
bool CallBearerEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CallBearerEnum_strings[3] = {};

static const char CallBearerEnum_names[] =
  "CALL_BEARER_CS"
  "CALL_BEARER_IMS"
  "CALL_BEARER_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CallBearerEnum_entries[] = {
  { {CallBearerEnum_names + 0, 14}, 1 },
  { {CallBearerEnum_names + 14, 15}, 2 },
  { {CallBearerEnum_names + 29, 19}, 0 },
};

static const int CallBearerEnum_entries_by_number[] = {
  2, // 0 -> CALL_BEARER_UNKNOWN
  0, // 1 -> CALL_BEARER_CS
  1, // 2 -> CALL_BEARER_IMS
};

const std::string& CallBearerEnum_Name(
    CallBearerEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CallBearerEnum_entries,
          CallBearerEnum_entries_by_number,
          3, CallBearerEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CallBearerEnum_entries,
      CallBearerEnum_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CallBearerEnum_strings[idx].get();
}
bool CallBearerEnum_Parse(
    const std::string& name, CallBearerEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CallBearerEnum_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<CallBearerEnum>(int_value);
  }
  return success;
}
bool CallDirectionEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CallDirectionEnum_strings[3] = {};

static const char CallDirectionEnum_names[] =
  "CALL_DIRECTION_MO"
  "CALL_DIRECTION_MT"
  "CALL_DIRECTION_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CallDirectionEnum_entries[] = {
  { {CallDirectionEnum_names + 0, 17}, 1 },
  { {CallDirectionEnum_names + 17, 17}, 2 },
  { {CallDirectionEnum_names + 34, 22}, 0 },
};

static const int CallDirectionEnum_entries_by_number[] = {
  2, // 0 -> CALL_DIRECTION_UNKNOWN
  0, // 1 -> CALL_DIRECTION_MO
  1, // 2 -> CALL_DIRECTION_MT
};

const std::string& CallDirectionEnum_Name(
    CallDirectionEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CallDirectionEnum_entries,
          CallDirectionEnum_entries_by_number,
          3, CallDirectionEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CallDirectionEnum_entries,
      CallDirectionEnum_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CallDirectionEnum_strings[idx].get();
}
bool CallDirectionEnum_Parse(
    const std::string& name, CallDirectionEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CallDirectionEnum_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<CallDirectionEnum>(int_value);
  }
  return success;
}
bool CallSetupDurationEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CallSetupDurationEnum_strings[10] = {};

static const char CallSetupDurationEnum_names[] =
  "CALL_SETUP_DURATION_EXTREMELY_FAST"
  "CALL_SETUP_DURATION_EXTREMELY_SLOW"
  "CALL_SETUP_DURATION_FAST"
  "CALL_SETUP_DURATION_NORMAL"
  "CALL_SETUP_DURATION_SLOW"
  "CALL_SETUP_DURATION_ULTRA_FAST"
  "CALL_SETUP_DURATION_ULTRA_SLOW"
  "CALL_SETUP_DURATION_UNKNOWN"
  "CALL_SETUP_DURATION_VERY_FAST"
  "CALL_SETUP_DURATION_VERY_SLOW";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CallSetupDurationEnum_entries[] = {
  { {CallSetupDurationEnum_names + 0, 34}, 1 },
  { {CallSetupDurationEnum_names + 34, 34}, 9 },
  { {CallSetupDurationEnum_names + 68, 24}, 4 },
  { {CallSetupDurationEnum_names + 92, 26}, 5 },
  { {CallSetupDurationEnum_names + 118, 24}, 6 },
  { {CallSetupDurationEnum_names + 142, 30}, 2 },
  { {CallSetupDurationEnum_names + 172, 30}, 8 },
  { {CallSetupDurationEnum_names + 202, 27}, 0 },
  { {CallSetupDurationEnum_names + 229, 29}, 3 },
  { {CallSetupDurationEnum_names + 258, 29}, 7 },
};

static const int CallSetupDurationEnum_entries_by_number[] = {
  7, // 0 -> CALL_SETUP_DURATION_UNKNOWN
  0, // 1 -> CALL_SETUP_DURATION_EXTREMELY_FAST
  5, // 2 -> CALL_SETUP_DURATION_ULTRA_FAST
  8, // 3 -> CALL_SETUP_DURATION_VERY_FAST
  2, // 4 -> CALL_SETUP_DURATION_FAST
  3, // 5 -> CALL_SETUP_DURATION_NORMAL
  4, // 6 -> CALL_SETUP_DURATION_SLOW
  9, // 7 -> CALL_SETUP_DURATION_VERY_SLOW
  6, // 8 -> CALL_SETUP_DURATION_ULTRA_SLOW
  1, // 9 -> CALL_SETUP_DURATION_EXTREMELY_SLOW
};

const std::string& CallSetupDurationEnum_Name(
    CallSetupDurationEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CallSetupDurationEnum_entries,
          CallSetupDurationEnum_entries_by_number,
          10, CallSetupDurationEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CallSetupDurationEnum_entries,
      CallSetupDurationEnum_entries_by_number,
      10, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CallSetupDurationEnum_strings[idx].get();
}
bool CallSetupDurationEnum_Parse(
    const std::string& name, CallSetupDurationEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CallSetupDurationEnum_entries, 10, name, &int_value);
  if (success) {
    *value = static_cast<CallSetupDurationEnum>(int_value);
  }
  return success;
}
bool DataConnectionPowerStateEnum_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 2147483647:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DataConnectionPowerStateEnum_strings[4] = {};

static const char DataConnectionPowerStateEnum_names[] =
  "DATA_CONNECTION_POWER_STATE_HIGH"
  "DATA_CONNECTION_POWER_STATE_LOW"
  "DATA_CONNECTION_POWER_STATE_MEDIUM"
  "DATA_CONNECTION_POWER_STATE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DataConnectionPowerStateEnum_entries[] = {
  { {DataConnectionPowerStateEnum_names + 0, 32}, 3 },
  { {DataConnectionPowerStateEnum_names + 32, 31}, 1 },
  { {DataConnectionPowerStateEnum_names + 63, 34}, 2 },
  { {DataConnectionPowerStateEnum_names + 97, 35}, 2147483647 },
};

static const int DataConnectionPowerStateEnum_entries_by_number[] = {
  1, // 1 -> DATA_CONNECTION_POWER_STATE_LOW
  2, // 2 -> DATA_CONNECTION_POWER_STATE_MEDIUM
  0, // 3 -> DATA_CONNECTION_POWER_STATE_HIGH
  3, // 2147483647 -> DATA_CONNECTION_POWER_STATE_UNKNOWN
};

const std::string& DataConnectionPowerStateEnum_Name(
    DataConnectionPowerStateEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DataConnectionPowerStateEnum_entries,
          DataConnectionPowerStateEnum_entries_by_number,
          4, DataConnectionPowerStateEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DataConnectionPowerStateEnum_entries,
      DataConnectionPowerStateEnum_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DataConnectionPowerStateEnum_strings[idx].get();
}
bool DataConnectionPowerStateEnum_Parse(
    const std::string& name, DataConnectionPowerStateEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DataConnectionPowerStateEnum_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DataConnectionPowerStateEnum>(int_value);
  }
  return success;
}
bool NetworkTypeEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NetworkTypeEnum_strings[21] = {};

static const char NetworkTypeEnum_names[] =
  "NETWORK_TYPE_1XRTT"
  "NETWORK_TYPE_CDMA"
  "NETWORK_TYPE_EDGE"
  "NETWORK_TYPE_EHRPD"
  "NETWORK_TYPE_EVDO_0"
  "NETWORK_TYPE_EVDO_A"
  "NETWORK_TYPE_EVDO_B"
  "NETWORK_TYPE_GPRS"
  "NETWORK_TYPE_GSM"
  "NETWORK_TYPE_HSDPA"
  "NETWORK_TYPE_HSPA"
  "NETWORK_TYPE_HSPAP"
  "NETWORK_TYPE_HSUPA"
  "NETWORK_TYPE_IDEN"
  "NETWORK_TYPE_IWLAN"
  "NETWORK_TYPE_LTE"
  "NETWORK_TYPE_LTE_CA"
  "NETWORK_TYPE_NR"
  "NETWORK_TYPE_TD_SCDMA"
  "NETWORK_TYPE_UMTS"
  "NETWORK_TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NetworkTypeEnum_entries[] = {
  { {NetworkTypeEnum_names + 0, 18}, 7 },
  { {NetworkTypeEnum_names + 18, 17}, 4 },
  { {NetworkTypeEnum_names + 35, 17}, 2 },
  { {NetworkTypeEnum_names + 52, 18}, 14 },
  { {NetworkTypeEnum_names + 70, 19}, 5 },
  { {NetworkTypeEnum_names + 89, 19}, 6 },
  { {NetworkTypeEnum_names + 108, 19}, 12 },
  { {NetworkTypeEnum_names + 127, 17}, 1 },
  { {NetworkTypeEnum_names + 144, 16}, 16 },
  { {NetworkTypeEnum_names + 160, 18}, 8 },
  { {NetworkTypeEnum_names + 178, 17}, 10 },
  { {NetworkTypeEnum_names + 195, 18}, 15 },
  { {NetworkTypeEnum_names + 213, 18}, 9 },
  { {NetworkTypeEnum_names + 231, 17}, 11 },
  { {NetworkTypeEnum_names + 248, 18}, 18 },
  { {NetworkTypeEnum_names + 266, 16}, 13 },
  { {NetworkTypeEnum_names + 282, 19}, 19 },
  { {NetworkTypeEnum_names + 301, 15}, 20 },
  { {NetworkTypeEnum_names + 316, 21}, 17 },
  { {NetworkTypeEnum_names + 337, 17}, 3 },
  { {NetworkTypeEnum_names + 354, 20}, 0 },
};

static const int NetworkTypeEnum_entries_by_number[] = {
  20, // 0 -> NETWORK_TYPE_UNKNOWN
  7, // 1 -> NETWORK_TYPE_GPRS
  2, // 2 -> NETWORK_TYPE_EDGE
  19, // 3 -> NETWORK_TYPE_UMTS
  1, // 4 -> NETWORK_TYPE_CDMA
  4, // 5 -> NETWORK_TYPE_EVDO_0
  5, // 6 -> NETWORK_TYPE_EVDO_A
  0, // 7 -> NETWORK_TYPE_1XRTT
  9, // 8 -> NETWORK_TYPE_HSDPA
  12, // 9 -> NETWORK_TYPE_HSUPA
  10, // 10 -> NETWORK_TYPE_HSPA
  13, // 11 -> NETWORK_TYPE_IDEN
  6, // 12 -> NETWORK_TYPE_EVDO_B
  15, // 13 -> NETWORK_TYPE_LTE
  3, // 14 -> NETWORK_TYPE_EHRPD
  11, // 15 -> NETWORK_TYPE_HSPAP
  8, // 16 -> NETWORK_TYPE_GSM
  18, // 17 -> NETWORK_TYPE_TD_SCDMA
  14, // 18 -> NETWORK_TYPE_IWLAN
  16, // 19 -> NETWORK_TYPE_LTE_CA
  17, // 20 -> NETWORK_TYPE_NR
};

const std::string& NetworkTypeEnum_Name(
    NetworkTypeEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NetworkTypeEnum_entries,
          NetworkTypeEnum_entries_by_number,
          21, NetworkTypeEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NetworkTypeEnum_entries,
      NetworkTypeEnum_entries_by_number,
      21, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NetworkTypeEnum_strings[idx].get();
}
bool NetworkTypeEnum_Parse(
    const std::string& name, NetworkTypeEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NetworkTypeEnum_entries, 21, name, &int_value);
  if (success) {
    *value = static_cast<NetworkTypeEnum>(int_value);
  }
  return success;
}
bool RoamingTypeEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RoamingTypeEnum_strings[4] = {};

static const char RoamingTypeEnum_names[] =
  "ROAMING_TYPE_NOT_ROAMING"
  "ROAMING_TYPE_ROAMING"
  "ROAMING_TYPE_ROAMING_DOMESTIC"
  "ROAMING_TYPE_ROAMING_INTERNATIONAL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RoamingTypeEnum_entries[] = {
  { {RoamingTypeEnum_names + 0, 24}, 0 },
  { {RoamingTypeEnum_names + 24, 20}, 1 },
  { {RoamingTypeEnum_names + 44, 29}, 2 },
  { {RoamingTypeEnum_names + 73, 34}, 3 },
};

static const int RoamingTypeEnum_entries_by_number[] = {
  0, // 0 -> ROAMING_TYPE_NOT_ROAMING
  1, // 1 -> ROAMING_TYPE_ROAMING
  2, // 2 -> ROAMING_TYPE_ROAMING_DOMESTIC
  3, // 3 -> ROAMING_TYPE_ROAMING_INTERNATIONAL
};

const std::string& RoamingTypeEnum_Name(
    RoamingTypeEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RoamingTypeEnum_entries,
          RoamingTypeEnum_entries_by_number,
          4, RoamingTypeEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RoamingTypeEnum_entries,
      RoamingTypeEnum_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RoamingTypeEnum_strings[idx].get();
}
bool RoamingTypeEnum_Parse(
    const std::string& name, RoamingTypeEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RoamingTypeEnum_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<RoamingTypeEnum>(int_value);
  }
  return success;
}
bool SignalStrengthEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SignalStrengthEnum_strings[5] = {};

static const char SignalStrengthEnum_names[] =
  "SIGNAL_STRENGTH_GOOD"
  "SIGNAL_STRENGTH_GREAT"
  "SIGNAL_STRENGTH_MODERATE"
  "SIGNAL_STRENGTH_NONE_OR_UNKNOWN"
  "SIGNAL_STRENGTH_POOR";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SignalStrengthEnum_entries[] = {
  { {SignalStrengthEnum_names + 0, 20}, 3 },
  { {SignalStrengthEnum_names + 20, 21}, 4 },
  { {SignalStrengthEnum_names + 41, 24}, 2 },
  { {SignalStrengthEnum_names + 65, 31}, 0 },
  { {SignalStrengthEnum_names + 96, 20}, 1 },
};

static const int SignalStrengthEnum_entries_by_number[] = {
  3, // 0 -> SIGNAL_STRENGTH_NONE_OR_UNKNOWN
  4, // 1 -> SIGNAL_STRENGTH_POOR
  2, // 2 -> SIGNAL_STRENGTH_MODERATE
  0, // 3 -> SIGNAL_STRENGTH_GOOD
  1, // 4 -> SIGNAL_STRENGTH_GREAT
};

const std::string& SignalStrengthEnum_Name(
    SignalStrengthEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SignalStrengthEnum_entries,
          SignalStrengthEnum_entries_by_number,
          5, SignalStrengthEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SignalStrengthEnum_entries,
      SignalStrengthEnum_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SignalStrengthEnum_strings[idx].get();
}
bool SignalStrengthEnum_Parse(
    const std::string& name, SignalStrengthEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SignalStrengthEnum_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<SignalStrengthEnum>(int_value);
  }
  return success;
}
bool ServiceStateEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServiceStateEnum_strings[4] = {};

static const char ServiceStateEnum_names[] =
  "SERVICE_STATE_EMERGENCY_ONLY"
  "SERVICE_STATE_IN_SERVICE"
  "SERVICE_STATE_OUT_OF_SERVICE"
  "SERVICE_STATE_POWER_OFF";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServiceStateEnum_entries[] = {
  { {ServiceStateEnum_names + 0, 28}, 2 },
  { {ServiceStateEnum_names + 28, 24}, 0 },
  { {ServiceStateEnum_names + 52, 28}, 1 },
  { {ServiceStateEnum_names + 80, 23}, 3 },
};

static const int ServiceStateEnum_entries_by_number[] = {
  1, // 0 -> SERVICE_STATE_IN_SERVICE
  2, // 1 -> SERVICE_STATE_OUT_OF_SERVICE
  0, // 2 -> SERVICE_STATE_EMERGENCY_ONLY
  3, // 3 -> SERVICE_STATE_POWER_OFF
};

const std::string& ServiceStateEnum_Name(
    ServiceStateEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ServiceStateEnum_entries,
          ServiceStateEnum_entries_by_number,
          4, ServiceStateEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ServiceStateEnum_entries,
      ServiceStateEnum_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ServiceStateEnum_strings[idx].get();
}
bool ServiceStateEnum_Parse(
    const std::string& name, ServiceStateEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ServiceStateEnum_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ServiceStateEnum>(int_value);
  }
  return success;
}
bool SimStateEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SimStateEnum_strings[12] = {};

static const char SimStateEnum_names[] =
  "SIM_STATE_ABSENT"
  "SIM_STATE_CARD_IO_ERROR"
  "SIM_STATE_CARD_RESTRICTED"
  "SIM_STATE_LOADED"
  "SIM_STATE_NETWORK_LOCKED"
  "SIM_STATE_NOT_READY"
  "SIM_STATE_PERM_DISABLED"
  "SIM_STATE_PIN_REQUIRED"
  "SIM_STATE_PRESENT"
  "SIM_STATE_PUK_REQUIRED"
  "SIM_STATE_READY"
  "SIM_STATE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SimStateEnum_entries[] = {
  { {SimStateEnum_names + 0, 16}, 1 },
  { {SimStateEnum_names + 16, 23}, 8 },
  { {SimStateEnum_names + 39, 25}, 9 },
  { {SimStateEnum_names + 64, 16}, 10 },
  { {SimStateEnum_names + 80, 24}, 4 },
  { {SimStateEnum_names + 104, 19}, 6 },
  { {SimStateEnum_names + 123, 23}, 7 },
  { {SimStateEnum_names + 146, 22}, 2 },
  { {SimStateEnum_names + 168, 17}, 11 },
  { {SimStateEnum_names + 185, 22}, 3 },
  { {SimStateEnum_names + 207, 15}, 5 },
  { {SimStateEnum_names + 222, 17}, 0 },
};

static const int SimStateEnum_entries_by_number[] = {
  11, // 0 -> SIM_STATE_UNKNOWN
  0, // 1 -> SIM_STATE_ABSENT
  7, // 2 -> SIM_STATE_PIN_REQUIRED
  9, // 3 -> SIM_STATE_PUK_REQUIRED
  4, // 4 -> SIM_STATE_NETWORK_LOCKED
  10, // 5 -> SIM_STATE_READY
  5, // 6 -> SIM_STATE_NOT_READY
  6, // 7 -> SIM_STATE_PERM_DISABLED
  1, // 8 -> SIM_STATE_CARD_IO_ERROR
  2, // 9 -> SIM_STATE_CARD_RESTRICTED
  3, // 10 -> SIM_STATE_LOADED
  8, // 11 -> SIM_STATE_PRESENT
};

const std::string& SimStateEnum_Name(
    SimStateEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SimStateEnum_entries,
          SimStateEnum_entries_by_number,
          12, SimStateEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SimStateEnum_entries,
      SimStateEnum_entries_by_number,
      12, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SimStateEnum_strings[idx].get();
}
bool SimStateEnum_Parse(
    const std::string& name, SimStateEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SimStateEnum_entries, 12, name, &int_value);
  if (success) {
    *value = static_cast<SimStateEnum>(int_value);
  }
  return success;
}
bool SmsFormatEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SmsFormatEnum_strings[3] = {};

static const char SmsFormatEnum_names[] =
  "SMS_FORMAT_3GPP"
  "SMS_FORMAT_3GPP2"
  "SMS_FORMAT_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SmsFormatEnum_entries[] = {
  { {SmsFormatEnum_names + 0, 15}, 1 },
  { {SmsFormatEnum_names + 15, 16}, 2 },
  { {SmsFormatEnum_names + 31, 18}, 0 },
};

static const int SmsFormatEnum_entries_by_number[] = {
  2, // 0 -> SMS_FORMAT_UNKNOWN
  0, // 1 -> SMS_FORMAT_3GPP
  1, // 2 -> SMS_FORMAT_3GPP2
};

const std::string& SmsFormatEnum_Name(
    SmsFormatEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SmsFormatEnum_entries,
          SmsFormatEnum_entries_by_number,
          3, SmsFormatEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SmsFormatEnum_entries,
      SmsFormatEnum_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SmsFormatEnum_strings[idx].get();
}
bool SmsFormatEnum_Parse(
    const std::string& name, SmsFormatEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SmsFormatEnum_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<SmsFormatEnum>(int_value);
  }
  return success;
}
bool SmsTechEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SmsTechEnum_strings[4] = {};

static const char SmsTechEnum_names[] =
  "SMS_TECH_CS_3GPP"
  "SMS_TECH_CS_3GPP2"
  "SMS_TECH_IMS"
  "SMS_TECH_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SmsTechEnum_entries[] = {
  { {SmsTechEnum_names + 0, 16}, 1 },
  { {SmsTechEnum_names + 16, 17}, 2 },
  { {SmsTechEnum_names + 33, 12}, 3 },
  { {SmsTechEnum_names + 45, 16}, 0 },
};

static const int SmsTechEnum_entries_by_number[] = {
  3, // 0 -> SMS_TECH_UNKNOWN
  0, // 1 -> SMS_TECH_CS_3GPP
  1, // 2 -> SMS_TECH_CS_3GPP2
  2, // 3 -> SMS_TECH_IMS
};

const std::string& SmsTechEnum_Name(
    SmsTechEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SmsTechEnum_entries,
          SmsTechEnum_entries_by_number,
          4, SmsTechEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SmsTechEnum_entries,
      SmsTechEnum_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SmsTechEnum_strings[idx].get();
}
bool SmsTechEnum_Parse(
    const std::string& name, SmsTechEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SmsTechEnum_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<SmsTechEnum>(int_value);
  }
  return success;
}
bool SmsTypeEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SmsTypeEnum_strings[5] = {};

static const char SmsTypeEnum_names[] =
  "SMS_TYPE_NORMAL"
  "SMS_TYPE_SMS_PP"
  "SMS_TYPE_VOICEMAIL_INDICATION"
  "SMS_TYPE_WAP_PUSH"
  "SMS_TYPE_ZERO";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SmsTypeEnum_entries[] = {
  { {SmsTypeEnum_names + 0, 15}, 0 },
  { {SmsTypeEnum_names + 15, 15}, 1 },
  { {SmsTypeEnum_names + 30, 29}, 2 },
  { {SmsTypeEnum_names + 59, 17}, 4 },
  { {SmsTypeEnum_names + 76, 13}, 3 },
};

static const int SmsTypeEnum_entries_by_number[] = {
  0, // 0 -> SMS_TYPE_NORMAL
  1, // 1 -> SMS_TYPE_SMS_PP
  2, // 2 -> SMS_TYPE_VOICEMAIL_INDICATION
  4, // 3 -> SMS_TYPE_ZERO
  3, // 4 -> SMS_TYPE_WAP_PUSH
};

const std::string& SmsTypeEnum_Name(
    SmsTypeEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SmsTypeEnum_entries,
          SmsTypeEnum_entries_by_number,
          5, SmsTypeEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SmsTypeEnum_entries,
      SmsTypeEnum_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SmsTypeEnum_strings[idx].get();
}
bool SmsTypeEnum_Parse(
    const std::string& name, SmsTypeEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SmsTypeEnum_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<SmsTypeEnum>(int_value);
  }
  return success;
}
bool SmsIncomingErrorEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SmsIncomingErrorEnum_strings[4] = {};

static const char SmsIncomingErrorEnum_names[] =
  "SMS_ERROR_GENERIC"
  "SMS_ERROR_NOT_SUPPORTED"
  "SMS_ERROR_NO_MEMORY"
  "SMS_SUCCESS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SmsIncomingErrorEnum_entries[] = {
  { {SmsIncomingErrorEnum_names + 0, 17}, 1 },
  { {SmsIncomingErrorEnum_names + 17, 23}, 3 },
  { {SmsIncomingErrorEnum_names + 40, 19}, 2 },
  { {SmsIncomingErrorEnum_names + 59, 11}, 0 },
};

static const int SmsIncomingErrorEnum_entries_by_number[] = {
  3, // 0 -> SMS_SUCCESS
  0, // 1 -> SMS_ERROR_GENERIC
  2, // 2 -> SMS_ERROR_NO_MEMORY
  1, // 3 -> SMS_ERROR_NOT_SUPPORTED
};

const std::string& SmsIncomingErrorEnum_Name(
    SmsIncomingErrorEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SmsIncomingErrorEnum_entries,
          SmsIncomingErrorEnum_entries_by_number,
          4, SmsIncomingErrorEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SmsIncomingErrorEnum_entries,
      SmsIncomingErrorEnum_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SmsIncomingErrorEnum_strings[idx].get();
}
bool SmsIncomingErrorEnum_Parse(
    const std::string& name, SmsIncomingErrorEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SmsIncomingErrorEnum_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<SmsIncomingErrorEnum>(int_value);
  }
  return success;
}
bool SmsSendResultEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SmsSendResultEnum_strings[5] = {};

static const char SmsSendResultEnum_names[] =
  "SMS_SEND_RESULT_ERROR"
  "SMS_SEND_RESULT_ERROR_FALLBACK"
  "SMS_SEND_RESULT_ERROR_RETRY"
  "SMS_SEND_RESULT_SUCCESS"
  "SMS_SEND_RESULT_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SmsSendResultEnum_entries[] = {
  { {SmsSendResultEnum_names + 0, 21}, 2 },
  { {SmsSendResultEnum_names + 21, 30}, 4 },
  { {SmsSendResultEnum_names + 51, 27}, 3 },
  { {SmsSendResultEnum_names + 78, 23}, 1 },
  { {SmsSendResultEnum_names + 101, 23}, 0 },
};

static const int SmsSendResultEnum_entries_by_number[] = {
  4, // 0 -> SMS_SEND_RESULT_UNKNOWN
  3, // 1 -> SMS_SEND_RESULT_SUCCESS
  0, // 2 -> SMS_SEND_RESULT_ERROR
  2, // 3 -> SMS_SEND_RESULT_ERROR_RETRY
  1, // 4 -> SMS_SEND_RESULT_ERROR_FALLBACK
};

const std::string& SmsSendResultEnum_Name(
    SmsSendResultEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SmsSendResultEnum_entries,
          SmsSendResultEnum_entries_by_number,
          5, SmsSendResultEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SmsSendResultEnum_entries,
      SmsSendResultEnum_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SmsSendResultEnum_strings[idx].get();
}
bool SmsSendResultEnum_Parse(
    const std::string& name, SmsSendResultEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SmsSendResultEnum_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<SmsSendResultEnum>(int_value);
  }
  return success;
}
bool DataProfileEnum_IsValid(int value) {
  switch (value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 1000:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DataProfileEnum_strings[7] = {};

static const char DataProfileEnum_names[] =
  "DATA_PROFILE_CBS"
  "DATA_PROFILE_DEFAULT"
  "DATA_PROFILE_FOTA"
  "DATA_PROFILE_IMS"
  "DATA_PROFILE_INVALID"
  "DATA_PROFILE_OEM_BASE"
  "DATA_PROFILE_TETHERED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DataProfileEnum_entries[] = {
  { {DataProfileEnum_names + 0, 16}, 4 },
  { {DataProfileEnum_names + 16, 20}, 0 },
  { {DataProfileEnum_names + 36, 17}, 3 },
  { {DataProfileEnum_names + 53, 16}, 2 },
  { {DataProfileEnum_names + 69, 20}, -1 },
  { {DataProfileEnum_names + 89, 21}, 1000 },
  { {DataProfileEnum_names + 110, 21}, 1 },
};

static const int DataProfileEnum_entries_by_number[] = {
  4, // -1 -> DATA_PROFILE_INVALID
  1, // 0 -> DATA_PROFILE_DEFAULT
  6, // 1 -> DATA_PROFILE_TETHERED
  3, // 2 -> DATA_PROFILE_IMS
  2, // 3 -> DATA_PROFILE_FOTA
  0, // 4 -> DATA_PROFILE_CBS
  5, // 1000 -> DATA_PROFILE_OEM_BASE
};

const std::string& DataProfileEnum_Name(
    DataProfileEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DataProfileEnum_entries,
          DataProfileEnum_entries_by_number,
          7, DataProfileEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DataProfileEnum_entries,
      DataProfileEnum_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DataProfileEnum_strings[idx].get();
}
bool DataProfileEnum_Parse(
    const std::string& name, DataProfileEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DataProfileEnum_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<DataProfileEnum>(int_value);
  }
  return success;
}
bool DataDeactivateReasonEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DataDeactivateReasonEnum_strings[4] = {};

static const char DataDeactivateReasonEnum_names[] =
  "DEACTIVATE_REASON_HANDOVER"
  "DEACTIVATE_REASON_NORMAL"
  "DEACTIVATE_REASON_RADIO_OFF"
  "DEACTIVATE_REASON_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DataDeactivateReasonEnum_entries[] = {
  { {DataDeactivateReasonEnum_names + 0, 26}, 3 },
  { {DataDeactivateReasonEnum_names + 26, 24}, 1 },
  { {DataDeactivateReasonEnum_names + 50, 27}, 2 },
  { {DataDeactivateReasonEnum_names + 77, 25}, 0 },
};

static const int DataDeactivateReasonEnum_entries_by_number[] = {
  3, // 0 -> DEACTIVATE_REASON_UNKNOWN
  1, // 1 -> DEACTIVATE_REASON_NORMAL
  2, // 2 -> DEACTIVATE_REASON_RADIO_OFF
  0, // 3 -> DEACTIVATE_REASON_HANDOVER
};

const std::string& DataDeactivateReasonEnum_Name(
    DataDeactivateReasonEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DataDeactivateReasonEnum_entries,
          DataDeactivateReasonEnum_entries_by_number,
          4, DataDeactivateReasonEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DataDeactivateReasonEnum_entries,
      DataDeactivateReasonEnum_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DataDeactivateReasonEnum_strings[idx].get();
}
bool DataDeactivateReasonEnum_Parse(
    const std::string& name, DataDeactivateReasonEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DataDeactivateReasonEnum_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DataDeactivateReasonEnum>(int_value);
  }
  return success;
}
bool ApnProtocolEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ApnProtocolEnum_strings[4] = {};

static const char ApnProtocolEnum_names[] =
  "APN_PROTOCOL_IPV4"
  "APN_PROTOCOL_IPV4V6"
  "APN_PROTOCOL_IPV6"
  "APN_PROTOCOL_PPP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ApnProtocolEnum_entries[] = {
  { {ApnProtocolEnum_names + 0, 17}, 0 },
  { {ApnProtocolEnum_names + 17, 19}, 2 },
  { {ApnProtocolEnum_names + 36, 17}, 1 },
  { {ApnProtocolEnum_names + 53, 16}, 3 },
};

static const int ApnProtocolEnum_entries_by_number[] = {
  0, // 0 -> APN_PROTOCOL_IPV4
  2, // 1 -> APN_PROTOCOL_IPV6
  1, // 2 -> APN_PROTOCOL_IPV4V6
  3, // 3 -> APN_PROTOCOL_PPP
};

const std::string& ApnProtocolEnum_Name(
    ApnProtocolEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ApnProtocolEnum_entries,
          ApnProtocolEnum_entries_by_number,
          4, ApnProtocolEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ApnProtocolEnum_entries,
      ApnProtocolEnum_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ApnProtocolEnum_strings[idx].get();
}
bool ApnProtocolEnum_Parse(
    const std::string& name, ApnProtocolEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ApnProtocolEnum_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ApnProtocolEnum>(int_value);
  }
  return success;
}
bool DataStallRecoveryActionEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DataStallRecoveryActionEnum_strings[4] = {};

static const char DataStallRecoveryActionEnum_names[] =
  "RECOVERY_ACTION_CLEANUP"
  "RECOVERY_ACTION_GET_DATA_CALL_LIST"
  "RECOVERY_ACTION_RADIO_RESTART"
  "RECOVERY_ACTION_REREGISTER";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DataStallRecoveryActionEnum_entries[] = {
  { {DataStallRecoveryActionEnum_names + 0, 23}, 1 },
  { {DataStallRecoveryActionEnum_names + 23, 34}, 0 },
  { {DataStallRecoveryActionEnum_names + 57, 29}, 3 },
  { {DataStallRecoveryActionEnum_names + 86, 26}, 2 },
};

static const int DataStallRecoveryActionEnum_entries_by_number[] = {
  1, // 0 -> RECOVERY_ACTION_GET_DATA_CALL_LIST
  0, // 1 -> RECOVERY_ACTION_CLEANUP
  3, // 2 -> RECOVERY_ACTION_REREGISTER
  2, // 3 -> RECOVERY_ACTION_RADIO_RESTART
};

const std::string& DataStallRecoveryActionEnum_Name(
    DataStallRecoveryActionEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DataStallRecoveryActionEnum_entries,
          DataStallRecoveryActionEnum_entries_by_number,
          4, DataStallRecoveryActionEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DataStallRecoveryActionEnum_entries,
      DataStallRecoveryActionEnum_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DataStallRecoveryActionEnum_strings[idx].get();
}
bool DataStallRecoveryActionEnum_Parse(
    const std::string& name, DataStallRecoveryActionEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DataStallRecoveryActionEnum_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DataStallRecoveryActionEnum>(int_value);
  }
  return success;
}
bool CodecQuality_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CodecQuality_strings[5] = {};

static const char CodecQuality_names[] =
  "CODEC_QUALITY_FULLBAND"
  "CODEC_QUALITY_NARROWBAND"
  "CODEC_QUALITY_SUPER_WIDEBAND"
  "CODEC_QUALITY_UNKNOWN"
  "CODEC_QUALITY_WIDEBAND";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CodecQuality_entries[] = {
  { {CodecQuality_names + 0, 22}, 4 },
  { {CodecQuality_names + 22, 24}, 1 },
  { {CodecQuality_names + 46, 28}, 3 },
  { {CodecQuality_names + 74, 21}, 0 },
  { {CodecQuality_names + 95, 22}, 2 },
};

static const int CodecQuality_entries_by_number[] = {
  3, // 0 -> CODEC_QUALITY_UNKNOWN
  1, // 1 -> CODEC_QUALITY_NARROWBAND
  4, // 2 -> CODEC_QUALITY_WIDEBAND
  2, // 3 -> CODEC_QUALITY_SUPER_WIDEBAND
  0, // 4 -> CODEC_QUALITY_FULLBAND
};

const std::string& CodecQuality_Name(
    CodecQuality value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CodecQuality_entries,
          CodecQuality_entries_by_number,
          5, CodecQuality_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CodecQuality_entries,
      CodecQuality_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CodecQuality_strings[idx].get();
}
bool CodecQuality_Parse(
    const std::string& name, CodecQuality* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CodecQuality_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<CodecQuality>(int_value);
  }
  return success;
}
bool SimSpecfifcSettingsRestoreResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SimSpecfifcSettingsRestoreResult_strings[4] = {};

static const char SimSpecfifcSettingsRestoreResult_names[] =
  "SIM_RESTORE_RESULT_NONE_MATCH"
  "SIM_RESTORE_RESULT_SUCCESS"
  "SIM_RESTORE_RESULT_UNKNOWN"
  "SIM_RESTORE_RESULT_ZERO_SIM_IN_BACKUP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SimSpecfifcSettingsRestoreResult_entries[] = {
  { {SimSpecfifcSettingsRestoreResult_names + 0, 29}, 2 },
  { {SimSpecfifcSettingsRestoreResult_names + 29, 26}, 1 },
  { {SimSpecfifcSettingsRestoreResult_names + 55, 26}, 0 },
  { {SimSpecfifcSettingsRestoreResult_names + 81, 37}, 3 },
};

static const int SimSpecfifcSettingsRestoreResult_entries_by_number[] = {
  2, // 0 -> SIM_RESTORE_RESULT_UNKNOWN
  1, // 1 -> SIM_RESTORE_RESULT_SUCCESS
  0, // 2 -> SIM_RESTORE_RESULT_NONE_MATCH
  3, // 3 -> SIM_RESTORE_RESULT_ZERO_SIM_IN_BACKUP
};

const std::string& SimSpecfifcSettingsRestoreResult_Name(
    SimSpecfifcSettingsRestoreResult value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SimSpecfifcSettingsRestoreResult_entries,
          SimSpecfifcSettingsRestoreResult_entries_by_number,
          4, SimSpecfifcSettingsRestoreResult_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SimSpecfifcSettingsRestoreResult_entries,
      SimSpecfifcSettingsRestoreResult_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SimSpecfifcSettingsRestoreResult_strings[idx].get();
}
bool SimSpecfifcSettingsRestoreResult_Parse(
    const std::string& name, SimSpecfifcSettingsRestoreResult* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SimSpecfifcSettingsRestoreResult_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<SimSpecfifcSettingsRestoreResult>(int_value);
  }
  return success;
}
bool SimSpecificSettingsRestoreCase_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SimSpecificSettingsRestoreCase_strings[3] = {};

static const char SimSpecificSettingsRestoreCase_names[] =
  "SIM_RESTORE_CASE_SIM_INSERTED"
  "SIM_RESTORE_CASE_SUW"
  "SIM_RESTORE_CASE_UNDEFINED_USE_CASE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SimSpecificSettingsRestoreCase_entries[] = {
  { {SimSpecificSettingsRestoreCase_names + 0, 29}, 2 },
  { {SimSpecificSettingsRestoreCase_names + 29, 20}, 1 },
  { {SimSpecificSettingsRestoreCase_names + 49, 35}, 0 },
};

static const int SimSpecificSettingsRestoreCase_entries_by_number[] = {
  2, // 0 -> SIM_RESTORE_CASE_UNDEFINED_USE_CASE
  1, // 1 -> SIM_RESTORE_CASE_SUW
  0, // 2 -> SIM_RESTORE_CASE_SIM_INSERTED
};

const std::string& SimSpecificSettingsRestoreCase_Name(
    SimSpecificSettingsRestoreCase value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SimSpecificSettingsRestoreCase_entries,
          SimSpecificSettingsRestoreCase_entries_by_number,
          3, SimSpecificSettingsRestoreCase_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SimSpecificSettingsRestoreCase_entries,
      SimSpecificSettingsRestoreCase_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SimSpecificSettingsRestoreCase_strings[idx].get();
}
bool SimSpecificSettingsRestoreCase_Parse(
    const std::string& name, SimSpecificSettingsRestoreCase* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SimSpecificSettingsRestoreCase_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<SimSpecificSettingsRestoreCase>(int_value);
  }
  return success;
}
bool SimSpecificSettingsRestoreMatchingCriteria_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SimSpecificSettingsRestoreMatchingCriteria_strings[5] = {};

static const char SimSpecificSettingsRestoreMatchingCriteria_names[] =
  "SIM_RESTORE_MATCHING_CRITERIA_CARRIER_ID_AND_PHONE_NUMBER"
  "SIM_RESTORE_MATCHING_CRITERIA_CARRIER_ID_ONLY"
  "SIM_RESTORE_MATCHING_CRITERIA_ICCID"
  "SIM_RESTORE_MATCHING_CRITERIA_NONE"
  "SIM_RESTORE_MATCHING_CRITERIA_UNSET";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SimSpecificSettingsRestoreMatchingCriteria_entries[] = {
  { {SimSpecificSettingsRestoreMatchingCriteria_names + 0, 57}, 3 },
  { {SimSpecificSettingsRestoreMatchingCriteria_names + 57, 45}, 4 },
  { {SimSpecificSettingsRestoreMatchingCriteria_names + 102, 35}, 2 },
  { {SimSpecificSettingsRestoreMatchingCriteria_names + 137, 34}, 1 },
  { {SimSpecificSettingsRestoreMatchingCriteria_names + 171, 35}, 0 },
};

static const int SimSpecificSettingsRestoreMatchingCriteria_entries_by_number[] = {
  4, // 0 -> SIM_RESTORE_MATCHING_CRITERIA_UNSET
  3, // 1 -> SIM_RESTORE_MATCHING_CRITERIA_NONE
  2, // 2 -> SIM_RESTORE_MATCHING_CRITERIA_ICCID
  0, // 3 -> SIM_RESTORE_MATCHING_CRITERIA_CARRIER_ID_AND_PHONE_NUMBER
  1, // 4 -> SIM_RESTORE_MATCHING_CRITERIA_CARRIER_ID_ONLY
};

const std::string& SimSpecificSettingsRestoreMatchingCriteria_Name(
    SimSpecificSettingsRestoreMatchingCriteria value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SimSpecificSettingsRestoreMatchingCriteria_entries,
          SimSpecificSettingsRestoreMatchingCriteria_entries_by_number,
          5, SimSpecificSettingsRestoreMatchingCriteria_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SimSpecificSettingsRestoreMatchingCriteria_entries,
      SimSpecificSettingsRestoreMatchingCriteria_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SimSpecificSettingsRestoreMatchingCriteria_strings[idx].get();
}
bool SimSpecificSettingsRestoreMatchingCriteria_Parse(
    const std::string& name, SimSpecificSettingsRestoreMatchingCriteria* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SimSpecificSettingsRestoreMatchingCriteria_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<SimSpecificSettingsRestoreMatchingCriteria>(int_value);
  }
  return success;
}
bool ImsFeatureTag_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ImsFeatureTag_strings[21] = {};

static const char ImsFeatureTag_names[] =
  "IMS_FEATURE_TAG_CALL_COMPOSER_ENRICHED_CALLING"
  "IMS_FEATURE_TAG_CALL_COMPOSER_VIA_TELEPHONY"
  "IMS_FEATURE_TAG_CHATBOT_COMMUNICATION_USING_SESSION"
  "IMS_FEATURE_TAG_CHATBOT_COMMUNICATION_USING_STANDALONE_MSG"
  "IMS_FEATURE_TAG_CHATBOT_ROLE"
  "IMS_FEATURE_TAG_CHATBOT_VERSION_SUPPORTED"
  "IMS_FEATURE_TAG_CHAT_IM"
  "IMS_FEATURE_TAG_CHAT_SESSION"
  "IMS_FEATURE_TAG_CUSTOM"
  "IMS_FEATURE_TAG_FILE_TRANSFER"
  "IMS_FEATURE_TAG_FILE_TRANSFER_VIA_SMS"
  "IMS_FEATURE_TAG_GEO_PUSH"
  "IMS_FEATURE_TAG_GEO_PUSH_VIA_SMS"
  "IMS_FEATURE_TAG_MMTEL"
  "IMS_FEATURE_TAG_POST_CALL"
  "IMS_FEATURE_TAG_PRESENCE"
  "IMS_FEATURE_TAG_SHARED_MAP"
  "IMS_FEATURE_TAG_SHARED_SKETCH"
  "IMS_FEATURE_TAG_STANDALONE_MSG"
  "IMS_FEATURE_TAG_UNSPECIFIED"
  "IMS_FEATURE_TAG_VIDEO";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ImsFeatureTag_entries[] = {
  { {ImsFeatureTag_names + 0, 46}, 7 },
  { {ImsFeatureTag_names + 46, 43}, 8 },
  { {ImsFeatureTag_names + 89, 51}, 14 },
  { {ImsFeatureTag_names + 140, 58}, 15 },
  { {ImsFeatureTag_names + 198, 28}, 17 },
  { {ImsFeatureTag_names + 226, 41}, 16 },
  { {ImsFeatureTag_names + 267, 23}, 3 },
  { {ImsFeatureTag_names + 290, 28}, 4 },
  { {ImsFeatureTag_names + 318, 22}, 1 },
  { {ImsFeatureTag_names + 340, 29}, 5 },
  { {ImsFeatureTag_names + 369, 37}, 6 },
  { {ImsFeatureTag_names + 406, 24}, 12 },
  { {ImsFeatureTag_names + 430, 32}, 13 },
  { {ImsFeatureTag_names + 462, 21}, 18 },
  { {ImsFeatureTag_names + 483, 25}, 9 },
  { {ImsFeatureTag_names + 508, 24}, 20 },
  { {ImsFeatureTag_names + 532, 26}, 10 },
  { {ImsFeatureTag_names + 558, 29}, 11 },
  { {ImsFeatureTag_names + 587, 30}, 2 },
  { {ImsFeatureTag_names + 617, 27}, 0 },
  { {ImsFeatureTag_names + 644, 21}, 19 },
};

static const int ImsFeatureTag_entries_by_number[] = {
  19, // 0 -> IMS_FEATURE_TAG_UNSPECIFIED
  8, // 1 -> IMS_FEATURE_TAG_CUSTOM
  18, // 2 -> IMS_FEATURE_TAG_STANDALONE_MSG
  6, // 3 -> IMS_FEATURE_TAG_CHAT_IM
  7, // 4 -> IMS_FEATURE_TAG_CHAT_SESSION
  9, // 5 -> IMS_FEATURE_TAG_FILE_TRANSFER
  10, // 6 -> IMS_FEATURE_TAG_FILE_TRANSFER_VIA_SMS
  0, // 7 -> IMS_FEATURE_TAG_CALL_COMPOSER_ENRICHED_CALLING
  1, // 8 -> IMS_FEATURE_TAG_CALL_COMPOSER_VIA_TELEPHONY
  14, // 9 -> IMS_FEATURE_TAG_POST_CALL
  16, // 10 -> IMS_FEATURE_TAG_SHARED_MAP
  17, // 11 -> IMS_FEATURE_TAG_SHARED_SKETCH
  11, // 12 -> IMS_FEATURE_TAG_GEO_PUSH
  12, // 13 -> IMS_FEATURE_TAG_GEO_PUSH_VIA_SMS
  2, // 14 -> IMS_FEATURE_TAG_CHATBOT_COMMUNICATION_USING_SESSION
  3, // 15 -> IMS_FEATURE_TAG_CHATBOT_COMMUNICATION_USING_STANDALONE_MSG
  5, // 16 -> IMS_FEATURE_TAG_CHATBOT_VERSION_SUPPORTED
  4, // 17 -> IMS_FEATURE_TAG_CHATBOT_ROLE
  13, // 18 -> IMS_FEATURE_TAG_MMTEL
  20, // 19 -> IMS_FEATURE_TAG_VIDEO
  15, // 20 -> IMS_FEATURE_TAG_PRESENCE
};

const std::string& ImsFeatureTag_Name(
    ImsFeatureTag value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ImsFeatureTag_entries,
          ImsFeatureTag_entries_by_number,
          21, ImsFeatureTag_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ImsFeatureTag_entries,
      ImsFeatureTag_entries_by_number,
      21, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ImsFeatureTag_strings[idx].get();
}
bool ImsFeatureTag_Parse(
    const std::string& name, ImsFeatureTag* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ImsFeatureTag_entries, 21, name, &int_value);
  if (success) {
    *value = static_cast<ImsFeatureTag>(int_value);
  }
  return success;
}
bool SipRequestMethodType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SipRequestMethodType_strings[16] = {};

static const char SipRequestMethodType_names[] =
  "SIP_REQUEST_ACK"
  "SIP_REQUEST_BYE"
  "SIP_REQUEST_CANCEL"
  "SIP_REQUEST_CUSTOM"
  "SIP_REQUEST_INFO"
  "SIP_REQUEST_INVITE"
  "SIP_REQUEST_MESSAGE"
  "SIP_REQUEST_NOTIFY"
  "SIP_REQUEST_OPTIONS"
  "SIP_REQUEST_PRACK"
  "SIP_REQUEST_PUBLISH"
  "SIP_REQUEST_REFER"
  "SIP_REQUEST_REGISTER"
  "SIP_REQUEST_SUBSCRIBE"
  "SIP_REQUEST_UNSPECIFIED"
  "SIP_REQUEST_UPDATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SipRequestMethodType_entries[] = {
  { {SipRequestMethodType_names + 0, 15}, 3 },
  { {SipRequestMethodType_names + 15, 15}, 5 },
  { {SipRequestMethodType_names + 30, 18}, 6 },
  { {SipRequestMethodType_names + 48, 18}, 1 },
  { {SipRequestMethodType_names + 66, 16}, 12 },
  { {SipRequestMethodType_names + 82, 18}, 2 },
  { {SipRequestMethodType_names + 100, 19}, 14 },
  { {SipRequestMethodType_names + 119, 18}, 10 },
  { {SipRequestMethodType_names + 137, 19}, 4 },
  { {SipRequestMethodType_names + 156, 17}, 8 },
  { {SipRequestMethodType_names + 173, 19}, 11 },
  { {SipRequestMethodType_names + 192, 17}, 13 },
  { {SipRequestMethodType_names + 209, 20}, 7 },
  { {SipRequestMethodType_names + 229, 21}, 9 },
  { {SipRequestMethodType_names + 250, 23}, 0 },
  { {SipRequestMethodType_names + 273, 18}, 15 },
};

static const int SipRequestMethodType_entries_by_number[] = {
  14, // 0 -> SIP_REQUEST_UNSPECIFIED
  3, // 1 -> SIP_REQUEST_CUSTOM
  5, // 2 -> SIP_REQUEST_INVITE
  0, // 3 -> SIP_REQUEST_ACK
  8, // 4 -> SIP_REQUEST_OPTIONS
  1, // 5 -> SIP_REQUEST_BYE
  2, // 6 -> SIP_REQUEST_CANCEL
  12, // 7 -> SIP_REQUEST_REGISTER
  9, // 8 -> SIP_REQUEST_PRACK
  13, // 9 -> SIP_REQUEST_SUBSCRIBE
  7, // 10 -> SIP_REQUEST_NOTIFY
  10, // 11 -> SIP_REQUEST_PUBLISH
  4, // 12 -> SIP_REQUEST_INFO
  11, // 13 -> SIP_REQUEST_REFER
  6, // 14 -> SIP_REQUEST_MESSAGE
  15, // 15 -> SIP_REQUEST_UPDATE
};

const std::string& SipRequestMethodType_Name(
    SipRequestMethodType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SipRequestMethodType_entries,
          SipRequestMethodType_entries_by_number,
          16, SipRequestMethodType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SipRequestMethodType_entries,
      SipRequestMethodType_entries_by_number,
      16, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SipRequestMethodType_strings[idx].get();
}
bool SipRequestMethodType_Parse(
    const std::string& name, SipRequestMethodType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SipRequestMethodType_entries, 16, name, &int_value);
  if (success) {
    *value = static_cast<SipRequestMethodType>(int_value);
  }
  return success;
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace telephony
}  // namespace android
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
