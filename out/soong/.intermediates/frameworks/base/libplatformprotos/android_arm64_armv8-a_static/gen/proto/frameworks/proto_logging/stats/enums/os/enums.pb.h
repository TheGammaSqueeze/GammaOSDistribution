// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/os/enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fos_2fenums_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fos_2fenums_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_frameworks_2fproto_5flogging_2fstats_2fenums_2fos_2fenums_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_frameworks_2fproto_5flogging_2fstats_2fenums_2fos_2fenums_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace android {
namespace os {

enum BatteryHealthEnum : int {
  BATTERY_HEALTH_INVALID = 0,
  BATTERY_HEALTH_UNKNOWN = 1,
  BATTERY_HEALTH_GOOD = 2,
  BATTERY_HEALTH_OVERHEAT = 3,
  BATTERY_HEALTH_DEAD = 4,
  BATTERY_HEALTH_OVER_VOLTAGE = 5,
  BATTERY_HEALTH_UNSPECIFIED_FAILURE = 6,
  BATTERY_HEALTH_COLD = 7
};
bool BatteryHealthEnum_IsValid(int value);
constexpr BatteryHealthEnum BatteryHealthEnum_MIN = BATTERY_HEALTH_INVALID;
constexpr BatteryHealthEnum BatteryHealthEnum_MAX = BATTERY_HEALTH_COLD;
constexpr int BatteryHealthEnum_ARRAYSIZE = BatteryHealthEnum_MAX + 1;

const std::string& BatteryHealthEnum_Name(BatteryHealthEnum value);
template<typename T>
inline const std::string& BatteryHealthEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BatteryHealthEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BatteryHealthEnum_Name.");
  return BatteryHealthEnum_Name(static_cast<BatteryHealthEnum>(enum_t_value));
}
bool BatteryHealthEnum_Parse(
    const std::string& name, BatteryHealthEnum* value);
enum BatteryPluggedStateEnum : int {
  BATTERY_PLUGGED_NONE = 0,
  BATTERY_PLUGGED_AC = 1,
  BATTERY_PLUGGED_USB = 2,
  BATTERY_PLUGGED_WIRELESS = 4
};
bool BatteryPluggedStateEnum_IsValid(int value);
constexpr BatteryPluggedStateEnum BatteryPluggedStateEnum_MIN = BATTERY_PLUGGED_NONE;
constexpr BatteryPluggedStateEnum BatteryPluggedStateEnum_MAX = BATTERY_PLUGGED_WIRELESS;
constexpr int BatteryPluggedStateEnum_ARRAYSIZE = BatteryPluggedStateEnum_MAX + 1;

const std::string& BatteryPluggedStateEnum_Name(BatteryPluggedStateEnum value);
template<typename T>
inline const std::string& BatteryPluggedStateEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BatteryPluggedStateEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BatteryPluggedStateEnum_Name.");
  return BatteryPluggedStateEnum_Name(static_cast<BatteryPluggedStateEnum>(enum_t_value));
}
bool BatteryPluggedStateEnum_Parse(
    const std::string& name, BatteryPluggedStateEnum* value);
enum BatteryStatusEnum : int {
  BATTERY_STATUS_INVALID = 0,
  BATTERY_STATUS_UNKNOWN = 1,
  BATTERY_STATUS_CHARGING = 2,
  BATTERY_STATUS_DISCHARGING = 3,
  BATTERY_STATUS_NOT_CHARGING = 4,
  BATTERY_STATUS_FULL = 5
};
bool BatteryStatusEnum_IsValid(int value);
constexpr BatteryStatusEnum BatteryStatusEnum_MIN = BATTERY_STATUS_INVALID;
constexpr BatteryStatusEnum BatteryStatusEnum_MAX = BATTERY_STATUS_FULL;
constexpr int BatteryStatusEnum_ARRAYSIZE = BatteryStatusEnum_MAX + 1;

const std::string& BatteryStatusEnum_Name(BatteryStatusEnum value);
template<typename T>
inline const std::string& BatteryStatusEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BatteryStatusEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BatteryStatusEnum_Name.");
  return BatteryStatusEnum_Name(static_cast<BatteryStatusEnum>(enum_t_value));
}
bool BatteryStatusEnum_Parse(
    const std::string& name, BatteryStatusEnum* value);
enum PowerComponentEnum : int {
  POWER_COMPONENT_SCREEN = 0,
  POWER_COMPONENT_CPU = 1,
  POWER_COMPONENT_BLUETOOTH = 2,
  POWER_COMPONENT_CAMERA = 3,
  POWER_COMPONENT_AUDIO = 4,
  POWER_COMPONENT_VIDEO = 5,
  POWER_COMPONENT_FLASHLIGHT = 6,
  POWER_COMPONENT_SYSTEM_SERVICES = 7,
  POWER_COMPONENT_MOBILE_RADIO = 8,
  POWER_COMPONENT_SENSORS = 9,
  POWER_COMPONENT_GNSS = 10,
  POWER_COMPONENT_WIFI = 11,
  POWER_COMPONENT_WAKELOCK = 12,
  POWER_COMPONENT_MEMORY = 13,
  POWER_COMPONENT_PHONE = 14,
  POWER_COMPONENT_AMBIENT_DISPLAY = 15,
  POWER_COMPONENT_IDLE = 16,
  POWER_COMPONENT_REATTRIBUTED_TO_OTHER_CONSUMERS = 17
};
bool PowerComponentEnum_IsValid(int value);
constexpr PowerComponentEnum PowerComponentEnum_MIN = POWER_COMPONENT_SCREEN;
constexpr PowerComponentEnum PowerComponentEnum_MAX = POWER_COMPONENT_REATTRIBUTED_TO_OTHER_CONSUMERS;
constexpr int PowerComponentEnum_ARRAYSIZE = PowerComponentEnum_MAX + 1;

const std::string& PowerComponentEnum_Name(PowerComponentEnum value);
template<typename T>
inline const std::string& PowerComponentEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PowerComponentEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PowerComponentEnum_Name.");
  return PowerComponentEnum_Name(static_cast<PowerComponentEnum>(enum_t_value));
}
bool PowerComponentEnum_Parse(
    const std::string& name, PowerComponentEnum* value);
enum TemperatureTypeEnum : int {
  TEMPERATURE_TYPE_UNKNOWN = -1,
  TEMPERATURE_TYPE_CPU = 0,
  TEMPERATURE_TYPE_GPU = 1,
  TEMPERATURE_TYPE_BATTERY = 2,
  TEMPERATURE_TYPE_SKIN = 3,
  TEMPERATURE_TYPE_USB_PORT = 4,
  TEMPERATURE_TYPE_POWER_AMPLIFIER = 5,
  TEMPERATURE_TYPE_BCL_VOLTAGE = 6,
  TEMPERATURE_TYPE_BCL_CURRENT = 7,
  TEMPERATURE_TYPE_BCL_PERCENTAGE = 8,
  TEMPERATURE_TYPE_NPU = 9
};
bool TemperatureTypeEnum_IsValid(int value);
constexpr TemperatureTypeEnum TemperatureTypeEnum_MIN = TEMPERATURE_TYPE_UNKNOWN;
constexpr TemperatureTypeEnum TemperatureTypeEnum_MAX = TEMPERATURE_TYPE_NPU;
constexpr int TemperatureTypeEnum_ARRAYSIZE = TemperatureTypeEnum_MAX + 1;

const std::string& TemperatureTypeEnum_Name(TemperatureTypeEnum value);
template<typename T>
inline const std::string& TemperatureTypeEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TemperatureTypeEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TemperatureTypeEnum_Name.");
  return TemperatureTypeEnum_Name(static_cast<TemperatureTypeEnum>(enum_t_value));
}
bool TemperatureTypeEnum_Parse(
    const std::string& name, TemperatureTypeEnum* value);
enum ThrottlingSeverityEnum : int {
  NONE = 0,
  LIGHT = 1,
  MODERATE = 2,
  SEVERE = 3,
  CRITICAL = 4,
  EMERGENCY = 5,
  SHUTDOWN = 6
};
bool ThrottlingSeverityEnum_IsValid(int value);
constexpr ThrottlingSeverityEnum ThrottlingSeverityEnum_MIN = NONE;
constexpr ThrottlingSeverityEnum ThrottlingSeverityEnum_MAX = SHUTDOWN;
constexpr int ThrottlingSeverityEnum_ARRAYSIZE = ThrottlingSeverityEnum_MAX + 1;

const std::string& ThrottlingSeverityEnum_Name(ThrottlingSeverityEnum value);
template<typename T>
inline const std::string& ThrottlingSeverityEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ThrottlingSeverityEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ThrottlingSeverityEnum_Name.");
  return ThrottlingSeverityEnum_Name(static_cast<ThrottlingSeverityEnum>(enum_t_value));
}
bool ThrottlingSeverityEnum_Parse(
    const std::string& name, ThrottlingSeverityEnum* value);
enum CoolingTypeEnum : int {
  FAN = 0,
  BATTERY = 1,
  CPU = 2,
  GPU = 3,
  MODEM = 4,
  NPU = 5,
  COMPONENT = 6
};
bool CoolingTypeEnum_IsValid(int value);
constexpr CoolingTypeEnum CoolingTypeEnum_MIN = FAN;
constexpr CoolingTypeEnum CoolingTypeEnum_MAX = COMPONENT;
constexpr int CoolingTypeEnum_ARRAYSIZE = CoolingTypeEnum_MAX + 1;

const std::string& CoolingTypeEnum_Name(CoolingTypeEnum value);
template<typename T>
inline const std::string& CoolingTypeEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CoolingTypeEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CoolingTypeEnum_Name.");
  return CoolingTypeEnum_Name(static_cast<CoolingTypeEnum>(enum_t_value));
}
bool CoolingTypeEnum_Parse(
    const std::string& name, CoolingTypeEnum* value);
enum WakeLockLevelEnum : int {
  PARTIAL_WAKE_LOCK = 1,
  SCREEN_DIM_WAKE_LOCK PROTOBUF_DEPRECATED = 6,
  SCREEN_BRIGHT_WAKE_LOCK PROTOBUF_DEPRECATED = 10,
  FULL_WAKE_LOCK PROTOBUF_DEPRECATED = 26,
  PROXIMITY_SCREEN_OFF_WAKE_LOCK = 32,
  DOZE_WAKE_LOCK = 64,
  DRAW_WAKE_LOCK = 128
};
bool WakeLockLevelEnum_IsValid(int value);
constexpr WakeLockLevelEnum WakeLockLevelEnum_MIN = PARTIAL_WAKE_LOCK;
constexpr WakeLockLevelEnum WakeLockLevelEnum_MAX = DRAW_WAKE_LOCK;
constexpr int WakeLockLevelEnum_ARRAYSIZE = WakeLockLevelEnum_MAX + 1;

const std::string& WakeLockLevelEnum_Name(WakeLockLevelEnum value);
template<typename T>
inline const std::string& WakeLockLevelEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WakeLockLevelEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WakeLockLevelEnum_Name.");
  return WakeLockLevelEnum_Name(static_cast<WakeLockLevelEnum>(enum_t_value));
}
bool WakeLockLevelEnum_Parse(
    const std::string& name, WakeLockLevelEnum* value);
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace os
}  // namespace android

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::android::os::BatteryHealthEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::os::BatteryPluggedStateEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::os::BatteryStatusEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::os::PowerComponentEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::os::TemperatureTypeEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::os::ThrottlingSeverityEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::os::CoolingTypeEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::os::WakeLockLevelEnum> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fos_2fenums_2eproto
