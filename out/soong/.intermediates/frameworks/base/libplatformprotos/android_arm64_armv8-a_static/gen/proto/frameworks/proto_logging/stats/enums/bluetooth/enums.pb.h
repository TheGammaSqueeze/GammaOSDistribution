// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/bluetooth/enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fbluetooth_2fenums_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fbluetooth_2fenums_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_frameworks_2fproto_5flogging_2fstats_2fenums_2fbluetooth_2fenums_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_frameworks_2fproto_5flogging_2fstats_2fenums_2fbluetooth_2fenums_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace android {
namespace bluetooth {

enum ConnectionStateEnum : int {
  CONNECTION_STATE_DISCONNECTED = 0,
  CONNECTION_STATE_CONNECTING = 1,
  CONNECTION_STATE_CONNECTED = 2,
  CONNECTION_STATE_DISCONNECTING = 3
};
bool ConnectionStateEnum_IsValid(int value);
constexpr ConnectionStateEnum ConnectionStateEnum_MIN = CONNECTION_STATE_DISCONNECTED;
constexpr ConnectionStateEnum ConnectionStateEnum_MAX = CONNECTION_STATE_DISCONNECTING;
constexpr int ConnectionStateEnum_ARRAYSIZE = ConnectionStateEnum_MAX + 1;

const std::string& ConnectionStateEnum_Name(ConnectionStateEnum value);
template<typename T>
inline const std::string& ConnectionStateEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectionStateEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectionStateEnum_Name.");
  return ConnectionStateEnum_Name(static_cast<ConnectionStateEnum>(enum_t_value));
}
bool ConnectionStateEnum_Parse(
    const std::string& name, ConnectionStateEnum* value);
enum EnableDisableReasonEnum : int {
  ENABLE_DISABLE_REASON_UNSPECIFIED = 0,
  ENABLE_DISABLE_REASON_APPLICATION_REQUEST = 1,
  ENABLE_DISABLE_REASON_AIRPLANE_MODE = 2,
  ENABLE_DISABLE_REASON_DISALLOWED = 3,
  ENABLE_DISABLE_REASON_RESTARTED = 4,
  ENABLE_DISABLE_REASON_START_ERROR = 5,
  ENABLE_DISABLE_REASON_SYSTEM_BOOT = 6,
  ENABLE_DISABLE_REASON_CRASH = 7,
  ENABLE_DISABLE_REASON_USER_SWITCH = 8,
  ENABLE_DISABLE_REASON_RESTORE_USER_SETTING = 9,
  ENABLE_DISABLE_REASON_FACTORY_RESET = 10,
  ENABLE_DISABLE_REASON_INIT_FLAGS_CHANGED = 11
};
bool EnableDisableReasonEnum_IsValid(int value);
constexpr EnableDisableReasonEnum EnableDisableReasonEnum_MIN = ENABLE_DISABLE_REASON_UNSPECIFIED;
constexpr EnableDisableReasonEnum EnableDisableReasonEnum_MAX = ENABLE_DISABLE_REASON_INIT_FLAGS_CHANGED;
constexpr int EnableDisableReasonEnum_ARRAYSIZE = EnableDisableReasonEnum_MAX + 1;

const std::string& EnableDisableReasonEnum_Name(EnableDisableReasonEnum value);
template<typename T>
inline const std::string& EnableDisableReasonEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EnableDisableReasonEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EnableDisableReasonEnum_Name.");
  return EnableDisableReasonEnum_Name(static_cast<EnableDisableReasonEnum>(enum_t_value));
}
bool EnableDisableReasonEnum_Parse(
    const std::string& name, EnableDisableReasonEnum* value);
enum DirectionEnum : int {
  DIRECTION_UNKNOWN = 0,
  DIRECTION_OUTGOING = 1,
  DIRECTION_INCOMING = 2
};
bool DirectionEnum_IsValid(int value);
constexpr DirectionEnum DirectionEnum_MIN = DIRECTION_UNKNOWN;
constexpr DirectionEnum DirectionEnum_MAX = DIRECTION_INCOMING;
constexpr int DirectionEnum_ARRAYSIZE = DirectionEnum_MAX + 1;

const std::string& DirectionEnum_Name(DirectionEnum value);
template<typename T>
inline const std::string& DirectionEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DirectionEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DirectionEnum_Name.");
  return DirectionEnum_Name(static_cast<DirectionEnum>(enum_t_value));
}
bool DirectionEnum_Parse(
    const std::string& name, DirectionEnum* value);
enum LinkTypeEnum : int {
  LINK_TYPE_UNKNOWN = 4095,
  LINK_TYPE_SCO = 0,
  LINK_TYPE_ACL = 1,
  LINK_TYPE_ESCO = 2
};
bool LinkTypeEnum_IsValid(int value);
constexpr LinkTypeEnum LinkTypeEnum_MIN = LINK_TYPE_SCO;
constexpr LinkTypeEnum LinkTypeEnum_MAX = LINK_TYPE_UNKNOWN;
constexpr int LinkTypeEnum_ARRAYSIZE = LinkTypeEnum_MAX + 1;

const std::string& LinkTypeEnum_Name(LinkTypeEnum value);
template<typename T>
inline const std::string& LinkTypeEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LinkTypeEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LinkTypeEnum_Name.");
  return LinkTypeEnum_Name(static_cast<LinkTypeEnum>(enum_t_value));
}
bool LinkTypeEnum_Parse(
    const std::string& name, LinkTypeEnum* value);
enum DeviceInfoSrcEnum : int {
  DEVICE_INFO_SRC_UNKNOWN = 0,
  DEVICE_INFO_INTERNAL = 1,
  DEVICE_INFO_EXTERNAL = 2
};
bool DeviceInfoSrcEnum_IsValid(int value);
constexpr DeviceInfoSrcEnum DeviceInfoSrcEnum_MIN = DEVICE_INFO_SRC_UNKNOWN;
constexpr DeviceInfoSrcEnum DeviceInfoSrcEnum_MAX = DEVICE_INFO_EXTERNAL;
constexpr int DeviceInfoSrcEnum_ARRAYSIZE = DeviceInfoSrcEnum_MAX + 1;

const std::string& DeviceInfoSrcEnum_Name(DeviceInfoSrcEnum value);
template<typename T>
inline const std::string& DeviceInfoSrcEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceInfoSrcEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceInfoSrcEnum_Name.");
  return DeviceInfoSrcEnum_Name(static_cast<DeviceInfoSrcEnum>(enum_t_value));
}
bool DeviceInfoSrcEnum_Parse(
    const std::string& name, DeviceInfoSrcEnum* value);
enum DeviceTypeEnum : int {
  DEVICE_TYPE_UNKNOWN = 0,
  DEVICE_TYPE_CLASSIC = 1,
  DEVICE_TYPE_LE = 2,
  DEVICE_TYPE_DUAL = 3
};
bool DeviceTypeEnum_IsValid(int value);
constexpr DeviceTypeEnum DeviceTypeEnum_MIN = DEVICE_TYPE_UNKNOWN;
constexpr DeviceTypeEnum DeviceTypeEnum_MAX = DEVICE_TYPE_DUAL;
constexpr int DeviceTypeEnum_ARRAYSIZE = DeviceTypeEnum_MAX + 1;

const std::string& DeviceTypeEnum_Name(DeviceTypeEnum value);
template<typename T>
inline const std::string& DeviceTypeEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceTypeEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceTypeEnum_Name.");
  return DeviceTypeEnum_Name(static_cast<DeviceTypeEnum>(enum_t_value));
}
bool DeviceTypeEnum_Parse(
    const std::string& name, DeviceTypeEnum* value);
enum TransportTypeEnum : int {
  TRANSPORT_TYPE_AUTO = 0,
  TRANSPORT_TYPE_BREDR = 1,
  TRANSPORT_TYPE_LE = 2
};
bool TransportTypeEnum_IsValid(int value);
constexpr TransportTypeEnum TransportTypeEnum_MIN = TRANSPORT_TYPE_AUTO;
constexpr TransportTypeEnum TransportTypeEnum_MAX = TRANSPORT_TYPE_LE;
constexpr int TransportTypeEnum_ARRAYSIZE = TransportTypeEnum_MAX + 1;

const std::string& TransportTypeEnum_Name(TransportTypeEnum value);
template<typename T>
inline const std::string& TransportTypeEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransportTypeEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransportTypeEnum_Name.");
  return TransportTypeEnum_Name(static_cast<TransportTypeEnum>(enum_t_value));
}
bool TransportTypeEnum_Parse(
    const std::string& name, TransportTypeEnum* value);
enum BondStateEnum : int {
  BOND_STATE_UNKNOWN = 0,
  BOND_STATE_NONE = 10,
  BOND_STATE_BONDING = 11,
  BOND_STATE_BONDED = 12
};
bool BondStateEnum_IsValid(int value);
constexpr BondStateEnum BondStateEnum_MIN = BOND_STATE_UNKNOWN;
constexpr BondStateEnum BondStateEnum_MAX = BOND_STATE_BONDED;
constexpr int BondStateEnum_ARRAYSIZE = BondStateEnum_MAX + 1;

const std::string& BondStateEnum_Name(BondStateEnum value);
template<typename T>
inline const std::string& BondStateEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BondStateEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BondStateEnum_Name.");
  return BondStateEnum_Name(static_cast<BondStateEnum>(enum_t_value));
}
bool BondStateEnum_Parse(
    const std::string& name, BondStateEnum* value);
enum BondSubStateEnum : int {
  BOND_SUB_STATE_UNKNOWN = 0,
  BOND_SUB_STATE_LOCAL_OOB_DATA_PROVIDED = 1,
  BOND_SUB_STATE_LOCAL_PIN_REQUESTED = 2,
  BOND_SUB_STATE_LOCAL_PIN_REPLIED = 3,
  BOND_SUB_STATE_LOCAL_SSP_REQUESTED = 4,
  BOND_SUB_STATE_LOCAL_SSP_REPLIED = 5
};
bool BondSubStateEnum_IsValid(int value);
constexpr BondSubStateEnum BondSubStateEnum_MIN = BOND_SUB_STATE_UNKNOWN;
constexpr BondSubStateEnum BondSubStateEnum_MAX = BOND_SUB_STATE_LOCAL_SSP_REPLIED;
constexpr int BondSubStateEnum_ARRAYSIZE = BondSubStateEnum_MAX + 1;

const std::string& BondSubStateEnum_Name(BondSubStateEnum value);
template<typename T>
inline const std::string& BondSubStateEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BondSubStateEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BondSubStateEnum_Name.");
  return BondSubStateEnum_Name(static_cast<BondSubStateEnum>(enum_t_value));
}
bool BondSubStateEnum_Parse(
    const std::string& name, BondSubStateEnum* value);
enum UnbondReasonEnum : int {
  UNBOND_REASON_UNKNOWN = 0,
  UNBOND_REASON_AUTH_FAILED = 1,
  UNBOND_REASON_AUTH_REJECTED = 2,
  UNBOND_REASON_AUTH_CANCELED = 3,
  UNBOND_REASON_REMOTE_DEVICE_DOWN = 4,
  UNBOND_REASON_DISCOVERY_IN_PROGRESS = 5,
  UNBOND_REASON_AUTH_TIMEOUT = 6,
  UNBOND_REASON_REPEATED_ATTEMPTS = 7,
  UNBOND_REASON_REMOTE_AUTH_CANCELED = 8,
  UNBOND_REASON_REMOVED = 9
};
bool UnbondReasonEnum_IsValid(int value);
constexpr UnbondReasonEnum UnbondReasonEnum_MIN = UNBOND_REASON_UNKNOWN;
constexpr UnbondReasonEnum UnbondReasonEnum_MAX = UNBOND_REASON_REMOVED;
constexpr int UnbondReasonEnum_ARRAYSIZE = UnbondReasonEnum_MAX + 1;

const std::string& UnbondReasonEnum_Name(UnbondReasonEnum value);
template<typename T>
inline const std::string& UnbondReasonEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UnbondReasonEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UnbondReasonEnum_Name.");
  return UnbondReasonEnum_Name(static_cast<UnbondReasonEnum>(enum_t_value));
}
bool UnbondReasonEnum_Parse(
    const std::string& name, UnbondReasonEnum* value);
enum SocketTypeEnum : int {
  SOCKET_TYPE_UNKNOWN = 0,
  SOCKET_TYPE_RFCOMM = 1,
  SOCKET_TYPE_SCO = 2,
  SOCKET_TYPE_L2CAP_BREDR = 3,
  SOCKET_TYPE_L2CAP_LE = 4
};
bool SocketTypeEnum_IsValid(int value);
constexpr SocketTypeEnum SocketTypeEnum_MIN = SOCKET_TYPE_UNKNOWN;
constexpr SocketTypeEnum SocketTypeEnum_MAX = SOCKET_TYPE_L2CAP_LE;
constexpr int SocketTypeEnum_ARRAYSIZE = SocketTypeEnum_MAX + 1;

const std::string& SocketTypeEnum_Name(SocketTypeEnum value);
template<typename T>
inline const std::string& SocketTypeEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SocketTypeEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SocketTypeEnum_Name.");
  return SocketTypeEnum_Name(static_cast<SocketTypeEnum>(enum_t_value));
}
bool SocketTypeEnum_Parse(
    const std::string& name, SocketTypeEnum* value);
enum SocketConnectionstateEnum : int {
  SOCKET_CONNECTION_STATE_UNKNOWN = 0,
  SOCKET_CONNECTION_STATE_LISTENING = 1,
  SOCKET_CONNECTION_STATE_CONNECTING = 2,
  SOCKET_CONNECTION_STATE_CONNECTED = 3,
  SOCKET_CONNECTION_STATE_DISCONNECTING = 4,
  SOCKET_CONNECTION_STATE_DISCONNECTED = 5
};
bool SocketConnectionstateEnum_IsValid(int value);
constexpr SocketConnectionstateEnum SocketConnectionstateEnum_MIN = SOCKET_CONNECTION_STATE_UNKNOWN;
constexpr SocketConnectionstateEnum SocketConnectionstateEnum_MAX = SOCKET_CONNECTION_STATE_DISCONNECTED;
constexpr int SocketConnectionstateEnum_ARRAYSIZE = SocketConnectionstateEnum_MAX + 1;

const std::string& SocketConnectionstateEnum_Name(SocketConnectionstateEnum value);
template<typename T>
inline const std::string& SocketConnectionstateEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SocketConnectionstateEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SocketConnectionstateEnum_Name.");
  return SocketConnectionstateEnum_Name(static_cast<SocketConnectionstateEnum>(enum_t_value));
}
bool SocketConnectionstateEnum_Parse(
    const std::string& name, SocketConnectionstateEnum* value);
enum SocketRoleEnum : int {
  SOCKET_ROLE_UNKNOWN = 0,
  SOCKET_ROLE_LISTEN = 1,
  SOCKET_ROLE_CONNECTION = 2
};
bool SocketRoleEnum_IsValid(int value);
constexpr SocketRoleEnum SocketRoleEnum_MIN = SOCKET_ROLE_UNKNOWN;
constexpr SocketRoleEnum SocketRoleEnum_MAX = SOCKET_ROLE_CONNECTION;
constexpr int SocketRoleEnum_ARRAYSIZE = SocketRoleEnum_MAX + 1;

const std::string& SocketRoleEnum_Name(SocketRoleEnum value);
template<typename T>
inline const std::string& SocketRoleEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SocketRoleEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SocketRoleEnum_Name.");
  return SocketRoleEnum_Name(static_cast<SocketRoleEnum>(enum_t_value));
}
bool SocketRoleEnum_Parse(
    const std::string& name, SocketRoleEnum* value);
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace bluetooth
}  // namespace android

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::android::bluetooth::ConnectionStateEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::EnableDisableReasonEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::DirectionEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::LinkTypeEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::DeviceInfoSrcEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::DeviceTypeEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::TransportTypeEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::BondStateEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::BondSubStateEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::UnbondReasonEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::SocketTypeEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::SocketConnectionstateEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::SocketRoleEnum> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fbluetooth_2fenums_2eproto
