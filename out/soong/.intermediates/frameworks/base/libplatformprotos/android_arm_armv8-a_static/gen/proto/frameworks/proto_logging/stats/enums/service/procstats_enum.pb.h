// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/service/procstats_enum.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fservice_2fprocstats_5fenum_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fservice_2fprocstats_5fenum_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_frameworks_2fproto_5flogging_2fstats_2fenums_2fservice_2fprocstats_5fenum_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_frameworks_2fproto_5flogging_2fstats_2fenums_2fservice_2fprocstats_5fenum_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace android {
namespace service {
namespace procstats {

enum ScreenState : int {
  SCREEN_STATE_UNKNOWN = 0,
  SCREEN_STATE_OFF = 1,
  SCREEN_STATE_ON = 2
};
bool ScreenState_IsValid(int value);
constexpr ScreenState ScreenState_MIN = SCREEN_STATE_UNKNOWN;
constexpr ScreenState ScreenState_MAX = SCREEN_STATE_ON;
constexpr int ScreenState_ARRAYSIZE = ScreenState_MAX + 1;

const std::string& ScreenState_Name(ScreenState value);
template<typename T>
inline const std::string& ScreenState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ScreenState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ScreenState_Name.");
  return ScreenState_Name(static_cast<ScreenState>(enum_t_value));
}
bool ScreenState_Parse(
    const std::string& name, ScreenState* value);
enum MemoryState : int {
  MEMORY_STATE_UNKNOWN = 0,
  MEMORY_STATE_NORMAL = 1,
  MEMORY_STATE_MODERATE = 2,
  MEMORY_STATE_LOW = 3,
  MEMORY_STATE_CRITICAL = 4
};
bool MemoryState_IsValid(int value);
constexpr MemoryState MemoryState_MIN = MEMORY_STATE_UNKNOWN;
constexpr MemoryState MemoryState_MAX = MEMORY_STATE_CRITICAL;
constexpr int MemoryState_ARRAYSIZE = MemoryState_MAX + 1;

const std::string& MemoryState_Name(MemoryState value);
template<typename T>
inline const std::string& MemoryState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MemoryState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MemoryState_Name.");
  return MemoryState_Name(static_cast<MemoryState>(enum_t_value));
}
bool MemoryState_Parse(
    const std::string& name, MemoryState* value);
enum ProcessState : int {
  PROCESS_STATE_UNKNOWN = 0,
  PROCESS_STATE_PERSISTENT = 1,
  PROCESS_STATE_TOP = 2,
  PROCESS_STATE_BOUND_TOP_OR_FGS = 15,
  PROCESS_STATE_FGS = 16,
  PROCESS_STATE_IMPORTANT_FOREGROUND = 3,
  PROCESS_STATE_IMPORTANT_BACKGROUND = 4,
  PROCESS_STATE_BACKUP = 5,
  PROCESS_STATE_SERVICE = 6,
  PROCESS_STATE_SERVICE_RESTARTING = 7,
  PROCESS_STATE_RECEIVER = 8,
  PROCESS_STATE_HEAVY_WEIGHT = 9,
  PROCESS_STATE_HOME = 10,
  PROCESS_STATE_LAST_ACTIVITY = 11,
  PROCESS_STATE_CACHED_ACTIVITY = 12,
  PROCESS_STATE_CACHED_ACTIVITY_CLIENT = 13,
  PROCESS_STATE_CACHED_EMPTY = 14
};
bool ProcessState_IsValid(int value);
constexpr ProcessState ProcessState_MIN = PROCESS_STATE_UNKNOWN;
constexpr ProcessState ProcessState_MAX = PROCESS_STATE_FGS;
constexpr int ProcessState_ARRAYSIZE = ProcessState_MAX + 1;

const std::string& ProcessState_Name(ProcessState value);
template<typename T>
inline const std::string& ProcessState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProcessState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProcessState_Name.");
  return ProcessState_Name(static_cast<ProcessState>(enum_t_value));
}
bool ProcessState_Parse(
    const std::string& name, ProcessState* value);
enum ServiceOperationState : int {
  SERVICE_OPERATION_STATE_UNKNOWN = 0,
  SERVICE_OPERATION_STATE_RUNNING = 1,
  SERVICE_OPERATION_STATE_STARTED = 2,
  SERVICE_OPERATION_STATE_FOREGROUND = 3,
  SERVICE_OPERATION_STATE_BOUND = 4,
  SERVICE_OPERATION_STATE_EXECUTING = 5
};
bool ServiceOperationState_IsValid(int value);
constexpr ServiceOperationState ServiceOperationState_MIN = SERVICE_OPERATION_STATE_UNKNOWN;
constexpr ServiceOperationState ServiceOperationState_MAX = SERVICE_OPERATION_STATE_EXECUTING;
constexpr int ServiceOperationState_ARRAYSIZE = ServiceOperationState_MAX + 1;

const std::string& ServiceOperationState_Name(ServiceOperationState value);
template<typename T>
inline const std::string& ServiceOperationState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServiceOperationState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServiceOperationState_Name.");
  return ServiceOperationState_Name(static_cast<ServiceOperationState>(enum_t_value));
}
bool ServiceOperationState_Parse(
    const std::string& name, ServiceOperationState* value);
enum AggregatedProcessState : int {
  AGGREGATED_PROCESS_STATE_UNKNOWN = 0,
  AGGREGATED_PROCESS_STATE_PERSISTENT = 1,
  AGGREGATED_PROCESS_STATE_TOP = 2,
  AGGREGATED_PROCESS_STATE_BOUND_TOP_OR_FGS = 3,
  AGGREGATED_PROCESS_STATE_FGS = 4,
  AGGREGATED_PROCESS_STATE_IMPORTANT_FOREGROUND = 5,
  AGGREGATED_PROCESS_STATE_BACKGROUND = 6,
  AGGREGATED_PROCESS_STATE_RECEIVER = 7,
  AGGREGATED_PROCESS_STATE_CACHED = 8
};
bool AggregatedProcessState_IsValid(int value);
constexpr AggregatedProcessState AggregatedProcessState_MIN = AGGREGATED_PROCESS_STATE_UNKNOWN;
constexpr AggregatedProcessState AggregatedProcessState_MAX = AGGREGATED_PROCESS_STATE_CACHED;
constexpr int AggregatedProcessState_ARRAYSIZE = AggregatedProcessState_MAX + 1;

const std::string& AggregatedProcessState_Name(AggregatedProcessState value);
template<typename T>
inline const std::string& AggregatedProcessState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AggregatedProcessState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AggregatedProcessState_Name.");
  return AggregatedProcessState_Name(static_cast<AggregatedProcessState>(enum_t_value));
}
bool AggregatedProcessState_Parse(
    const std::string& name, AggregatedProcessState* value);
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace procstats
}  // namespace service
}  // namespace android

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::android::service::procstats::ScreenState> : ::std::true_type {};
template <> struct is_proto_enum< ::android::service::procstats::MemoryState> : ::std::true_type {};
template <> struct is_proto_enum< ::android::service::procstats::ProcessState> : ::std::true_type {};
template <> struct is_proto_enum< ::android::service::procstats::ServiceOperationState> : ::std::true_type {};
template <> struct is_proto_enum< ::android::service::procstats::AggregatedProcessState> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fservice_2fprocstats_5fenum_2eproto
