// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/server/location/enums.proto

#include "frameworks/proto_logging/stats/enums/server/location/enums.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
namespace android {
namespace server {
namespace location {
}  // namespace location
}  // namespace server
}  // namespace android
namespace android {
namespace server {
namespace location {
bool GpsSignalQualityEnum_IsValid(int value) {
  switch (value) {
    case -1:
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GpsSignalQualityEnum_strings[3] = {};

static const char GpsSignalQualityEnum_names[] =
  "GPS_SIGNAL_QUALITY_GOOD"
  "GPS_SIGNAL_QUALITY_POOR"
  "GPS_SIGNAL_QUALITY_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GpsSignalQualityEnum_entries[] = {
  { {GpsSignalQualityEnum_names + 0, 23}, 1 },
  { {GpsSignalQualityEnum_names + 23, 23}, 0 },
  { {GpsSignalQualityEnum_names + 46, 26}, -1 },
};

static const int GpsSignalQualityEnum_entries_by_number[] = {
  2, // -1 -> GPS_SIGNAL_QUALITY_UNKNOWN
  1, // 0 -> GPS_SIGNAL_QUALITY_POOR
  0, // 1 -> GPS_SIGNAL_QUALITY_GOOD
};

const std::string& GpsSignalQualityEnum_Name(
    GpsSignalQualityEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GpsSignalQualityEnum_entries,
          GpsSignalQualityEnum_entries_by_number,
          3, GpsSignalQualityEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GpsSignalQualityEnum_entries,
      GpsSignalQualityEnum_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GpsSignalQualityEnum_strings[idx].get();
}
bool GpsSignalQualityEnum_Parse(
    const std::string& name, GpsSignalQualityEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GpsSignalQualityEnum_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<GpsSignalQualityEnum>(int_value);
  }
  return success;
}
bool GnssNiType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GnssNiType_strings[4] = {};

static const char GnssNiType_names[] =
  "EMERGENCY_SUPL"
  "UMTS_CTRL_PLANE"
  "UMTS_SUPL"
  "VOICE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GnssNiType_entries[] = {
  { {GnssNiType_names + 0, 14}, 4 },
  { {GnssNiType_names + 14, 15}, 3 },
  { {GnssNiType_names + 29, 9}, 2 },
  { {GnssNiType_names + 38, 5}, 1 },
};

static const int GnssNiType_entries_by_number[] = {
  3, // 1 -> VOICE
  2, // 2 -> UMTS_SUPL
  1, // 3 -> UMTS_CTRL_PLANE
  0, // 4 -> EMERGENCY_SUPL
};

const std::string& GnssNiType_Name(
    GnssNiType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GnssNiType_entries,
          GnssNiType_entries_by_number,
          4, GnssNiType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GnssNiType_entries,
      GnssNiType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GnssNiType_strings[idx].get();
}
bool GnssNiType_Parse(
    const std::string& name, GnssNiType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GnssNiType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<GnssNiType>(int_value);
  }
  return success;
}
bool GnssUserResponseType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GnssUserResponseType_strings[3] = {};

static const char GnssUserResponseType_names[] =
  "RESPONSE_ACCEPT"
  "RESPONSE_DENY"
  "RESPONSE_NORESP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GnssUserResponseType_entries[] = {
  { {GnssUserResponseType_names + 0, 15}, 1 },
  { {GnssUserResponseType_names + 15, 13}, 2 },
  { {GnssUserResponseType_names + 28, 15}, 3 },
};

static const int GnssUserResponseType_entries_by_number[] = {
  0, // 1 -> RESPONSE_ACCEPT
  1, // 2 -> RESPONSE_DENY
  2, // 3 -> RESPONSE_NORESP
};

const std::string& GnssUserResponseType_Name(
    GnssUserResponseType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GnssUserResponseType_entries,
          GnssUserResponseType_entries_by_number,
          3, GnssUserResponseType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GnssUserResponseType_entries,
      GnssUserResponseType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GnssUserResponseType_strings[idx].get();
}
bool GnssUserResponseType_Parse(
    const std::string& name, GnssUserResponseType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GnssUserResponseType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<GnssUserResponseType>(int_value);
  }
  return success;
}
bool GnssNiEncodingType_IsValid(int value) {
  switch (value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GnssNiEncodingType_strings[5] = {};

static const char GnssNiEncodingType_names[] =
  "ENC_NONE"
  "ENC_SUPL_GSM_DEFAULT"
  "ENC_SUPL_UCS2"
  "ENC_SUPL_UTF8"
  "ENC_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GnssNiEncodingType_entries[] = {
  { {GnssNiEncodingType_names + 0, 8}, 0 },
  { {GnssNiEncodingType_names + 8, 20}, 1 },
  { {GnssNiEncodingType_names + 28, 13}, 3 },
  { {GnssNiEncodingType_names + 41, 13}, 2 },
  { {GnssNiEncodingType_names + 54, 11}, -1 },
};

static const int GnssNiEncodingType_entries_by_number[] = {
  4, // -1 -> ENC_UNKNOWN
  0, // 0 -> ENC_NONE
  1, // 1 -> ENC_SUPL_GSM_DEFAULT
  3, // 2 -> ENC_SUPL_UTF8
  2, // 3 -> ENC_SUPL_UCS2
};

const std::string& GnssNiEncodingType_Name(
    GnssNiEncodingType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GnssNiEncodingType_entries,
          GnssNiEncodingType_entries_by_number,
          5, GnssNiEncodingType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GnssNiEncodingType_entries,
      GnssNiEncodingType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GnssNiEncodingType_strings[idx].get();
}
bool GnssNiEncodingType_Parse(
    const std::string& name, GnssNiEncodingType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GnssNiEncodingType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<GnssNiEncodingType>(int_value);
  }
  return success;
}
bool NfwProtocolStack_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 10:
    case 11:
    case 100:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NfwProtocolStack_strings[5] = {};

static const char NfwProtocolStack_names[] =
  "CTRL_PLANE"
  "IMS"
  "OTHER_PROTOCOL_STACK"
  "SIM"
  "SUPL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NfwProtocolStack_entries[] = {
  { {NfwProtocolStack_names + 0, 10}, 0 },
  { {NfwProtocolStack_names + 10, 3}, 10 },
  { {NfwProtocolStack_names + 13, 20}, 100 },
  { {NfwProtocolStack_names + 33, 3}, 11 },
  { {NfwProtocolStack_names + 36, 4}, 1 },
};

static const int NfwProtocolStack_entries_by_number[] = {
  0, // 0 -> CTRL_PLANE
  4, // 1 -> SUPL
  1, // 10 -> IMS
  3, // 11 -> SIM
  2, // 100 -> OTHER_PROTOCOL_STACK
};

const std::string& NfwProtocolStack_Name(
    NfwProtocolStack value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NfwProtocolStack_entries,
          NfwProtocolStack_entries_by_number,
          5, NfwProtocolStack_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NfwProtocolStack_entries,
      NfwProtocolStack_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NfwProtocolStack_strings[idx].get();
}
bool NfwProtocolStack_Parse(
    const std::string& name, NfwProtocolStack* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NfwProtocolStack_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<NfwProtocolStack>(int_value);
  }
  return success;
}
bool NfwRequestor_IsValid(int value) {
  switch (value) {
    case 0:
    case 10:
    case 11:
    case 12:
    case 13:
    case 20:
    case 100:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NfwRequestor_strings[7] = {};

static const char NfwRequestor_names[] =
  "AUTOMOBILE_CLIENT"
  "CARRIER"
  "GNSS_CHIPSET_VENDOR"
  "MODEM_CHIPSET_VENDOR"
  "OEM"
  "OTHER_CHIPSET_VENDOR"
  "OTHER_REQUESTOR";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NfwRequestor_entries[] = {
  { {NfwRequestor_names + 0, 17}, 20 },
  { {NfwRequestor_names + 17, 7}, 0 },
  { {NfwRequestor_names + 24, 19}, 12 },
  { {NfwRequestor_names + 43, 20}, 11 },
  { {NfwRequestor_names + 63, 3}, 10 },
  { {NfwRequestor_names + 66, 20}, 13 },
  { {NfwRequestor_names + 86, 15}, 100 },
};

static const int NfwRequestor_entries_by_number[] = {
  1, // 0 -> CARRIER
  4, // 10 -> OEM
  3, // 11 -> MODEM_CHIPSET_VENDOR
  2, // 12 -> GNSS_CHIPSET_VENDOR
  5, // 13 -> OTHER_CHIPSET_VENDOR
  0, // 20 -> AUTOMOBILE_CLIENT
  6, // 100 -> OTHER_REQUESTOR
};

const std::string& NfwRequestor_Name(
    NfwRequestor value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NfwRequestor_entries,
          NfwRequestor_entries_by_number,
          7, NfwRequestor_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NfwRequestor_entries,
      NfwRequestor_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NfwRequestor_strings[idx].get();
}
bool NfwRequestor_Parse(
    const std::string& name, NfwRequestor* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NfwRequestor_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<NfwRequestor>(int_value);
  }
  return success;
}
bool NfwResponseType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NfwResponseType_strings[3] = {};

static const char NfwResponseType_names[] =
  "ACCEPTED_LOCATION_PROVIDED"
  "ACCEPTED_NO_LOCATION_PROVIDED"
  "REJECTED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NfwResponseType_entries[] = {
  { {NfwResponseType_names + 0, 26}, 2 },
  { {NfwResponseType_names + 26, 29}, 1 },
  { {NfwResponseType_names + 55, 8}, 0 },
};

static const int NfwResponseType_entries_by_number[] = {
  2, // 0 -> REJECTED
  1, // 1 -> ACCEPTED_NO_LOCATION_PROVIDED
  0, // 2 -> ACCEPTED_LOCATION_PROVIDED
};

const std::string& NfwResponseType_Name(
    NfwResponseType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NfwResponseType_entries,
          NfwResponseType_entries_by_number,
          3, NfwResponseType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NfwResponseType_entries,
      NfwResponseType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NfwResponseType_strings[idx].get();
}
bool NfwResponseType_Parse(
    const std::string& name, NfwResponseType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NfwResponseType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<NfwResponseType>(int_value);
  }
  return success;
}
bool SuplMode_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SuplMode_strings[2] = {};

static const char SuplMode_names[] =
  "MSA"
  "MSB";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SuplMode_entries[] = {
  { {SuplMode_names + 0, 3}, 2 },
  { {SuplMode_names + 3, 3}, 1 },
};

static const int SuplMode_entries_by_number[] = {
  1, // 1 -> MSB
  0, // 2 -> MSA
};

const std::string& SuplMode_Name(
    SuplMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SuplMode_entries,
          SuplMode_entries_by_number,
          2, SuplMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SuplMode_entries,
      SuplMode_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SuplMode_strings[idx].get();
}
bool SuplMode_Parse(
    const std::string& name, SuplMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SuplMode_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<SuplMode>(int_value);
  }
  return success;
}
bool LppProfile_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LppProfile_strings[2] = {};

static const char LppProfile_names[] =
  "CONTROL_PLANE"
  "USER_PLANE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LppProfile_entries[] = {
  { {LppProfile_names + 0, 13}, 2 },
  { {LppProfile_names + 13, 10}, 1 },
};

static const int LppProfile_entries_by_number[] = {
  1, // 1 -> USER_PLANE
  0, // 2 -> CONTROL_PLANE
};

const std::string& LppProfile_Name(
    LppProfile value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LppProfile_entries,
          LppProfile_entries_by_number,
          2, LppProfile_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LppProfile_entries,
      LppProfile_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LppProfile_strings[idx].get();
}
bool LppProfile_Parse(
    const std::string& name, LppProfile* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LppProfile_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<LppProfile>(int_value);
  }
  return success;
}
bool GlonassPosProtocol_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GlonassPosProtocol_strings[3] = {};

static const char GlonassPosProtocol_names[] =
  "LPP_UPLANE"
  "RRC_CPLANE"
  "RRLP_CPLANE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GlonassPosProtocol_entries[] = {
  { {GlonassPosProtocol_names + 0, 10}, 4 },
  { {GlonassPosProtocol_names + 10, 10}, 1 },
  { {GlonassPosProtocol_names + 20, 11}, 2 },
};

static const int GlonassPosProtocol_entries_by_number[] = {
  1, // 1 -> RRC_CPLANE
  2, // 2 -> RRLP_CPLANE
  0, // 4 -> LPP_UPLANE
};

const std::string& GlonassPosProtocol_Name(
    GlonassPosProtocol value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GlonassPosProtocol_entries,
          GlonassPosProtocol_entries_by_number,
          3, GlonassPosProtocol_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GlonassPosProtocol_entries,
      GlonassPosProtocol_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GlonassPosProtocol_strings[idx].get();
}
bool GlonassPosProtocol_Parse(
    const std::string& name, GlonassPosProtocol* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GlonassPosProtocol_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<GlonassPosProtocol>(int_value);
  }
  return success;
}
bool GpsLock_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GpsLock_strings[2] = {};

static const char GpsLock_names[] =
  "MO"
  "NI";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GpsLock_entries[] = {
  { {GpsLock_names + 0, 2}, 1 },
  { {GpsLock_names + 2, 2}, 2 },
};

static const int GpsLock_entries_by_number[] = {
  0, // 1 -> MO
  1, // 2 -> NI
};

const std::string& GpsLock_Name(
    GpsLock value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GpsLock_entries,
          GpsLock_entries_by_number,
          2, GpsLock_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GpsLock_entries,
      GpsLock_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GpsLock_strings[idx].get();
}
bool GpsLock_Parse(
    const std::string& name, GpsLock* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GpsLock_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<GpsLock>(int_value);
  }
  return success;
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace location
}  // namespace server
}  // namespace android
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
