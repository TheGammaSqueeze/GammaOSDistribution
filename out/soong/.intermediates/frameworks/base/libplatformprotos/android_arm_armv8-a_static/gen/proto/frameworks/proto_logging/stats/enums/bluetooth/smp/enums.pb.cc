// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/bluetooth/smp/enums.proto

#include "frameworks/proto_logging/stats/enums/bluetooth/smp/enums.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
namespace android {
namespace bluetooth {
namespace smp {
}  // namespace smp
}  // namespace bluetooth
}  // namespace android
namespace android {
namespace bluetooth {
namespace smp {
bool CommandEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CommandEnum_strings[15] = {};

static const char CommandEnum_names[] =
  "CMD_ENCRYPTION_INFON"
  "CMD_IDENTITY_ADDR_INFO"
  "CMD_IDENTITY_INFO"
  "CMD_MASTER_IDENTIFICATION"
  "CMD_PAIRING_CONFIRM"
  "CMD_PAIRING_DHKEY_CHECK"
  "CMD_PAIRING_FAILED"
  "CMD_PAIRING_KEYPRESS_INFO"
  "CMD_PAIRING_PUBLIC_KEY"
  "CMD_PAIRING_RANDOM"
  "CMD_PAIRING_REQUEST"
  "CMD_PAIRING_RESPONSE"
  "CMD_SECURITY_REQUEST"
  "CMD_SIGNING_INFO"
  "CMD_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CommandEnum_entries[] = {
  { {CommandEnum_names + 0, 20}, 6 },
  { {CommandEnum_names + 20, 22}, 9 },
  { {CommandEnum_names + 42, 17}, 8 },
  { {CommandEnum_names + 59, 25}, 7 },
  { {CommandEnum_names + 84, 19}, 3 },
  { {CommandEnum_names + 103, 23}, 13 },
  { {CommandEnum_names + 126, 18}, 5 },
  { {CommandEnum_names + 144, 25}, 14 },
  { {CommandEnum_names + 169, 22}, 12 },
  { {CommandEnum_names + 191, 18}, 4 },
  { {CommandEnum_names + 209, 19}, 1 },
  { {CommandEnum_names + 228, 20}, 2 },
  { {CommandEnum_names + 248, 20}, 11 },
  { {CommandEnum_names + 268, 16}, 10 },
  { {CommandEnum_names + 284, 11}, 0 },
};

static const int CommandEnum_entries_by_number[] = {
  14, // 0 -> CMD_UNKNOWN
  10, // 1 -> CMD_PAIRING_REQUEST
  11, // 2 -> CMD_PAIRING_RESPONSE
  4, // 3 -> CMD_PAIRING_CONFIRM
  9, // 4 -> CMD_PAIRING_RANDOM
  6, // 5 -> CMD_PAIRING_FAILED
  0, // 6 -> CMD_ENCRYPTION_INFON
  3, // 7 -> CMD_MASTER_IDENTIFICATION
  2, // 8 -> CMD_IDENTITY_INFO
  1, // 9 -> CMD_IDENTITY_ADDR_INFO
  13, // 10 -> CMD_SIGNING_INFO
  12, // 11 -> CMD_SECURITY_REQUEST
  8, // 12 -> CMD_PAIRING_PUBLIC_KEY
  5, // 13 -> CMD_PAIRING_DHKEY_CHECK
  7, // 14 -> CMD_PAIRING_KEYPRESS_INFO
};

const std::string& CommandEnum_Name(
    CommandEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CommandEnum_entries,
          CommandEnum_entries_by_number,
          15, CommandEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CommandEnum_entries,
      CommandEnum_entries_by_number,
      15, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CommandEnum_strings[idx].get();
}
bool CommandEnum_Parse(
    const std::string& name, CommandEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CommandEnum_entries, 15, name, &int_value);
  if (success) {
    *value = static_cast<CommandEnum>(int_value);
  }
  return success;
}
bool PairingFailReasonEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PairingFailReasonEnum_strings[15] = {};

static const char PairingFailReasonEnum_names[] =
  "PAIRING_FAIL_REASON_AUTH_REQ"
  "PAIRING_FAIL_REASON_CLASSIC_PAIRING_IN_PROGR"
  "PAIRING_FAIL_REASON_CONFIRM_VALUE"
  "PAIRING_FAIL_REASON_DHKEY_CHK"
  "PAIRING_FAIL_REASON_ENC_KEY_SIZE"
  "PAIRING_FAIL_REASON_INVALID_CMD"
  "PAIRING_FAIL_REASON_INVALID_PARAMETERS"
  "PAIRING_FAIL_REASON_NUMERIC_COMPARISON"
  "PAIRING_FAIL_REASON_OOB"
  "PAIRING_FAIL_REASON_PAIR_NOT_SUPPORT"
  "PAIRING_FAIL_REASON_PASSKEY_ENTRY"
  "PAIRING_FAIL_REASON_REPEATED_ATTEMPTS"
  "PAIRING_FAIL_REASON_RESERVED"
  "PAIRING_FAIL_REASON_UNSPECIFIED"
  "PAIRING_FAIL_REASON_XTRANS_DERIVE_NOT_ALLOW";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PairingFailReasonEnum_entries[] = {
  { {PairingFailReasonEnum_names + 0, 28}, 3 },
  { {PairingFailReasonEnum_names + 28, 44}, 13 },
  { {PairingFailReasonEnum_names + 72, 33}, 4 },
  { {PairingFailReasonEnum_names + 105, 29}, 11 },
  { {PairingFailReasonEnum_names + 134, 32}, 6 },
  { {PairingFailReasonEnum_names + 166, 31}, 7 },
  { {PairingFailReasonEnum_names + 197, 38}, 10 },
  { {PairingFailReasonEnum_names + 235, 38}, 12 },
  { {PairingFailReasonEnum_names + 273, 23}, 2 },
  { {PairingFailReasonEnum_names + 296, 36}, 5 },
  { {PairingFailReasonEnum_names + 332, 33}, 1 },
  { {PairingFailReasonEnum_names + 365, 37}, 9 },
  { {PairingFailReasonEnum_names + 402, 28}, 0 },
  { {PairingFailReasonEnum_names + 430, 31}, 8 },
  { {PairingFailReasonEnum_names + 461, 43}, 14 },
};

static const int PairingFailReasonEnum_entries_by_number[] = {
  12, // 0 -> PAIRING_FAIL_REASON_RESERVED
  10, // 1 -> PAIRING_FAIL_REASON_PASSKEY_ENTRY
  8, // 2 -> PAIRING_FAIL_REASON_OOB
  0, // 3 -> PAIRING_FAIL_REASON_AUTH_REQ
  2, // 4 -> PAIRING_FAIL_REASON_CONFIRM_VALUE
  9, // 5 -> PAIRING_FAIL_REASON_PAIR_NOT_SUPPORT
  4, // 6 -> PAIRING_FAIL_REASON_ENC_KEY_SIZE
  5, // 7 -> PAIRING_FAIL_REASON_INVALID_CMD
  13, // 8 -> PAIRING_FAIL_REASON_UNSPECIFIED
  11, // 9 -> PAIRING_FAIL_REASON_REPEATED_ATTEMPTS
  6, // 10 -> PAIRING_FAIL_REASON_INVALID_PARAMETERS
  3, // 11 -> PAIRING_FAIL_REASON_DHKEY_CHK
  7, // 12 -> PAIRING_FAIL_REASON_NUMERIC_COMPARISON
  1, // 13 -> PAIRING_FAIL_REASON_CLASSIC_PAIRING_IN_PROGR
  14, // 14 -> PAIRING_FAIL_REASON_XTRANS_DERIVE_NOT_ALLOW
};

const std::string& PairingFailReasonEnum_Name(
    PairingFailReasonEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PairingFailReasonEnum_entries,
          PairingFailReasonEnum_entries_by_number,
          15, PairingFailReasonEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PairingFailReasonEnum_entries,
      PairingFailReasonEnum_entries_by_number,
      15, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PairingFailReasonEnum_strings[idx].get();
}
bool PairingFailReasonEnum_Parse(
    const std::string& name, PairingFailReasonEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PairingFailReasonEnum_entries, 15, name, &int_value);
  if (success) {
    *value = static_cast<PairingFailReasonEnum>(int_value);
  }
  return success;
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace smp
}  // namespace bluetooth
}  // namespace android
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
