// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/base/core/proto/android/nfc/nfc_service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "frameworks/base/core/proto/android/app/pendingintent.pb.h"
#include "frameworks/base/core/proto/android/content/intent.pb.h"
#include "frameworks/base/core/proto/android/nfc/card_emulation.pb.h"
#include "frameworks/base/core/proto/android/nfc/ndef.pb.h"
#include "frameworks/base/core/proto/android/privacy.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace com {
namespace android {
namespace nfc {
class DiscoveryParamsProto;
class DiscoveryParamsProtoDefaultTypeInternal;
extern DiscoveryParamsProtoDefaultTypeInternal _DiscoveryParamsProto_default_instance_;
class NfcDispatcherProto;
class NfcDispatcherProtoDefaultTypeInternal;
extern NfcDispatcherProtoDefaultTypeInternal _NfcDispatcherProto_default_instance_;
class NfcServiceDumpProto;
class NfcServiceDumpProtoDefaultTypeInternal;
extern NfcServiceDumpProtoDefaultTypeInternal _NfcServiceDumpProto_default_instance_;
class P2pLinkManagerProto;
class P2pLinkManagerProtoDefaultTypeInternal;
extern P2pLinkManagerProtoDefaultTypeInternal _P2pLinkManagerProto_default_instance_;
}  // namespace nfc
}  // namespace android
}  // namespace com
PROTOBUF_NAMESPACE_OPEN
template<> ::com::android::nfc::DiscoveryParamsProto* Arena::CreateMaybeMessage<::com::android::nfc::DiscoveryParamsProto>(Arena*);
template<> ::com::android::nfc::NfcDispatcherProto* Arena::CreateMaybeMessage<::com::android::nfc::NfcDispatcherProto>(Arena*);
template<> ::com::android::nfc::NfcServiceDumpProto* Arena::CreateMaybeMessage<::com::android::nfc::NfcServiceDumpProto>(Arena*);
template<> ::com::android::nfc::P2pLinkManagerProto* Arena::CreateMaybeMessage<::com::android::nfc::P2pLinkManagerProto>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace com {
namespace android {
namespace nfc {

enum NfcServiceDumpProto_State : int {
  NfcServiceDumpProto_State_STATE_UNKNOWN = 0,
  NfcServiceDumpProto_State_STATE_OFF = 1,
  NfcServiceDumpProto_State_STATE_TURNING_ON = 2,
  NfcServiceDumpProto_State_STATE_ON = 3,
  NfcServiceDumpProto_State_STATE_TURNING_OFF = 4
};
bool NfcServiceDumpProto_State_IsValid(int value);
constexpr NfcServiceDumpProto_State NfcServiceDumpProto_State_State_MIN = NfcServiceDumpProto_State_STATE_UNKNOWN;
constexpr NfcServiceDumpProto_State NfcServiceDumpProto_State_State_MAX = NfcServiceDumpProto_State_STATE_TURNING_OFF;
constexpr int NfcServiceDumpProto_State_State_ARRAYSIZE = NfcServiceDumpProto_State_State_MAX + 1;

const std::string& NfcServiceDumpProto_State_Name(NfcServiceDumpProto_State value);
template<typename T>
inline const std::string& NfcServiceDumpProto_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NfcServiceDumpProto_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NfcServiceDumpProto_State_Name.");
  return NfcServiceDumpProto_State_Name(static_cast<NfcServiceDumpProto_State>(enum_t_value));
}
bool NfcServiceDumpProto_State_Parse(
    const std::string& name, NfcServiceDumpProto_State* value);
enum NfcServiceDumpProto_ScreenState : int {
  NfcServiceDumpProto_ScreenState_SCREEN_STATE_UNKNOWN = 0,
  NfcServiceDumpProto_ScreenState_SCREEN_STATE_OFF_UNLOCKED = 1,
  NfcServiceDumpProto_ScreenState_SCREEN_STATE_OFF_LOCKED = 2,
  NfcServiceDumpProto_ScreenState_SCREEN_STATE_ON_LOCKED = 3,
  NfcServiceDumpProto_ScreenState_SCREEN_STATE_ON_UNLOCKED = 4
};
bool NfcServiceDumpProto_ScreenState_IsValid(int value);
constexpr NfcServiceDumpProto_ScreenState NfcServiceDumpProto_ScreenState_ScreenState_MIN = NfcServiceDumpProto_ScreenState_SCREEN_STATE_UNKNOWN;
constexpr NfcServiceDumpProto_ScreenState NfcServiceDumpProto_ScreenState_ScreenState_MAX = NfcServiceDumpProto_ScreenState_SCREEN_STATE_ON_UNLOCKED;
constexpr int NfcServiceDumpProto_ScreenState_ScreenState_ARRAYSIZE = NfcServiceDumpProto_ScreenState_ScreenState_MAX + 1;

const std::string& NfcServiceDumpProto_ScreenState_Name(NfcServiceDumpProto_ScreenState value);
template<typename T>
inline const std::string& NfcServiceDumpProto_ScreenState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NfcServiceDumpProto_ScreenState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NfcServiceDumpProto_ScreenState_Name.");
  return NfcServiceDumpProto_ScreenState_Name(static_cast<NfcServiceDumpProto_ScreenState>(enum_t_value));
}
bool NfcServiceDumpProto_ScreenState_Parse(
    const std::string& name, NfcServiceDumpProto_ScreenState* value);
enum P2pLinkManagerProto_LinkState : int {
  P2pLinkManagerProto_LinkState_LINK_STATE_UNKNOWN = 0,
  P2pLinkManagerProto_LinkState_LINK_STATE_DOWN = 1,
  P2pLinkManagerProto_LinkState_LINK_STATE_DEBOUNCE = 2,
  P2pLinkManagerProto_LinkState_LINK_STATE_UP = 3
};
bool P2pLinkManagerProto_LinkState_IsValid(int value);
constexpr P2pLinkManagerProto_LinkState P2pLinkManagerProto_LinkState_LinkState_MIN = P2pLinkManagerProto_LinkState_LINK_STATE_UNKNOWN;
constexpr P2pLinkManagerProto_LinkState P2pLinkManagerProto_LinkState_LinkState_MAX = P2pLinkManagerProto_LinkState_LINK_STATE_UP;
constexpr int P2pLinkManagerProto_LinkState_LinkState_ARRAYSIZE = P2pLinkManagerProto_LinkState_LinkState_MAX + 1;

const std::string& P2pLinkManagerProto_LinkState_Name(P2pLinkManagerProto_LinkState value);
template<typename T>
inline const std::string& P2pLinkManagerProto_LinkState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, P2pLinkManagerProto_LinkState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function P2pLinkManagerProto_LinkState_Name.");
  return P2pLinkManagerProto_LinkState_Name(static_cast<P2pLinkManagerProto_LinkState>(enum_t_value));
}
bool P2pLinkManagerProto_LinkState_Parse(
    const std::string& name, P2pLinkManagerProto_LinkState* value);
enum P2pLinkManagerProto_SendState : int {
  P2pLinkManagerProto_SendState_SEND_STATE_UNKNOWN = 0,
  P2pLinkManagerProto_SendState_SEND_STATE_NOTHING_TO_SEND = 1,
  P2pLinkManagerProto_SendState_SEND_STATE_NEED_CONFIRMATION = 2,
  P2pLinkManagerProto_SendState_SEND_STATE_SENDING = 3,
  P2pLinkManagerProto_SendState_SEND_STATE_COMPLETE = 4,
  P2pLinkManagerProto_SendState_SEND_STATE_CANCELED = 5
};
bool P2pLinkManagerProto_SendState_IsValid(int value);
constexpr P2pLinkManagerProto_SendState P2pLinkManagerProto_SendState_SendState_MIN = P2pLinkManagerProto_SendState_SEND_STATE_UNKNOWN;
constexpr P2pLinkManagerProto_SendState P2pLinkManagerProto_SendState_SendState_MAX = P2pLinkManagerProto_SendState_SEND_STATE_CANCELED;
constexpr int P2pLinkManagerProto_SendState_SendState_ARRAYSIZE = P2pLinkManagerProto_SendState_SendState_MAX + 1;

const std::string& P2pLinkManagerProto_SendState_Name(P2pLinkManagerProto_SendState value);
template<typename T>
inline const std::string& P2pLinkManagerProto_SendState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, P2pLinkManagerProto_SendState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function P2pLinkManagerProto_SendState_Name.");
  return P2pLinkManagerProto_SendState_Name(static_cast<P2pLinkManagerProto_SendState>(enum_t_value));
}
bool P2pLinkManagerProto_SendState_Parse(
    const std::string& name, P2pLinkManagerProto_SendState* value);
// ===================================================================

class NfcServiceDumpProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:com.android.nfc.NfcServiceDumpProto) */ {
 public:
  NfcServiceDumpProto();
  virtual ~NfcServiceDumpProto();

  NfcServiceDumpProto(const NfcServiceDumpProto& from);
  NfcServiceDumpProto(NfcServiceDumpProto&& from) noexcept
    : NfcServiceDumpProto() {
    *this = ::std::move(from);
  }

  inline NfcServiceDumpProto& operator=(const NfcServiceDumpProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline NfcServiceDumpProto& operator=(NfcServiceDumpProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const NfcServiceDumpProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NfcServiceDumpProto* internal_default_instance() {
    return reinterpret_cast<const NfcServiceDumpProto*>(
               &_NfcServiceDumpProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NfcServiceDumpProto& a, NfcServiceDumpProto& b) {
    a.Swap(&b);
  }
  inline void Swap(NfcServiceDumpProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NfcServiceDumpProto* New() const final {
    return CreateMaybeMessage<NfcServiceDumpProto>(nullptr);
  }

  NfcServiceDumpProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NfcServiceDumpProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const NfcServiceDumpProto& from);
  void MergeFrom(const NfcServiceDumpProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NfcServiceDumpProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.android.nfc.NfcServiceDumpProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef NfcServiceDumpProto_State State;
  static constexpr State STATE_UNKNOWN =
    NfcServiceDumpProto_State_STATE_UNKNOWN;
  static constexpr State STATE_OFF =
    NfcServiceDumpProto_State_STATE_OFF;
  static constexpr State STATE_TURNING_ON =
    NfcServiceDumpProto_State_STATE_TURNING_ON;
  static constexpr State STATE_ON =
    NfcServiceDumpProto_State_STATE_ON;
  static constexpr State STATE_TURNING_OFF =
    NfcServiceDumpProto_State_STATE_TURNING_OFF;
  static inline bool State_IsValid(int value) {
    return NfcServiceDumpProto_State_IsValid(value);
  }
  static constexpr State State_MIN =
    NfcServiceDumpProto_State_State_MIN;
  static constexpr State State_MAX =
    NfcServiceDumpProto_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    NfcServiceDumpProto_State_State_ARRAYSIZE;
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return NfcServiceDumpProto_State_Name(enum_t_value);
  }
  static inline bool State_Parse(const std::string& name,
      State* value) {
    return NfcServiceDumpProto_State_Parse(name, value);
  }

  typedef NfcServiceDumpProto_ScreenState ScreenState;
  static constexpr ScreenState SCREEN_STATE_UNKNOWN =
    NfcServiceDumpProto_ScreenState_SCREEN_STATE_UNKNOWN;
  static constexpr ScreenState SCREEN_STATE_OFF_UNLOCKED =
    NfcServiceDumpProto_ScreenState_SCREEN_STATE_OFF_UNLOCKED;
  static constexpr ScreenState SCREEN_STATE_OFF_LOCKED =
    NfcServiceDumpProto_ScreenState_SCREEN_STATE_OFF_LOCKED;
  static constexpr ScreenState SCREEN_STATE_ON_LOCKED =
    NfcServiceDumpProto_ScreenState_SCREEN_STATE_ON_LOCKED;
  static constexpr ScreenState SCREEN_STATE_ON_UNLOCKED =
    NfcServiceDumpProto_ScreenState_SCREEN_STATE_ON_UNLOCKED;
  static inline bool ScreenState_IsValid(int value) {
    return NfcServiceDumpProto_ScreenState_IsValid(value);
  }
  static constexpr ScreenState ScreenState_MIN =
    NfcServiceDumpProto_ScreenState_ScreenState_MIN;
  static constexpr ScreenState ScreenState_MAX =
    NfcServiceDumpProto_ScreenState_ScreenState_MAX;
  static constexpr int ScreenState_ARRAYSIZE =
    NfcServiceDumpProto_ScreenState_ScreenState_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ScreenState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ScreenState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ScreenState_Name.");
    return NfcServiceDumpProto_ScreenState_Name(enum_t_value);
  }
  static inline bool ScreenState_Parse(const std::string& name,
      ScreenState* value) {
    return NfcServiceDumpProto_ScreenState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNativeCrashLogsFieldNumber = 19,
    kDiscoveryParamsFieldNumber = 15,
    kP2PLinkManagerFieldNumber = 16,
    kCardEmulationManagerFieldNumber = 17,
    kNfcDispatcherFieldNumber = 18,
    kStateFieldNumber = 1,
    kScreenStateFieldNumber = 4,
    kInProvisionModeFieldNumber = 2,
    kNdefPushEnabledFieldNumber = 3,
    kSecureNfcEnabledFieldNumber = 5,
    kPollingPausedFieldNumber = 6,
    kNumTagsDetectedFieldNumber = 7,
    kNumP2PDetectedFieldNumber = 8,
    kNumHceDetectedFieldNumber = 9,
    kHceCapableFieldNumber = 10,
    kHceFCapableFieldNumber = 11,
    kBeamCapableFieldNumber = 12,
    kSecureNfcCapableFieldNumber = 13,
    kVrModeEnabledFieldNumber = 14,
  };
  // optional string native_crash_logs = 19 [(.android.privacy) = {
  bool has_native_crash_logs() const;
  void clear_native_crash_logs();
  const std::string& native_crash_logs() const;
  void set_native_crash_logs(const std::string& value);
  void set_native_crash_logs(std::string&& value);
  void set_native_crash_logs(const char* value);
  void set_native_crash_logs(const char* value, size_t size);
  std::string* mutable_native_crash_logs();
  std::string* release_native_crash_logs();
  void set_allocated_native_crash_logs(std::string* native_crash_logs);

  // optional .com.android.nfc.DiscoveryParamsProto discovery_params = 15;
  bool has_discovery_params() const;
  void clear_discovery_params();
  const ::com::android::nfc::DiscoveryParamsProto& discovery_params() const;
  ::com::android::nfc::DiscoveryParamsProto* release_discovery_params();
  ::com::android::nfc::DiscoveryParamsProto* mutable_discovery_params();
  void set_allocated_discovery_params(::com::android::nfc::DiscoveryParamsProto* discovery_params);

  // optional .com.android.nfc.P2pLinkManagerProto p2p_link_manager = 16;
  bool has_p2p_link_manager() const;
  void clear_p2p_link_manager();
  const ::com::android::nfc::P2pLinkManagerProto& p2p_link_manager() const;
  ::com::android::nfc::P2pLinkManagerProto* release_p2p_link_manager();
  ::com::android::nfc::P2pLinkManagerProto* mutable_p2p_link_manager();
  void set_allocated_p2p_link_manager(::com::android::nfc::P2pLinkManagerProto* p2p_link_manager);

  // optional .com.android.nfc.cardemulation.CardEmulationManagerProto card_emulation_manager = 17;
  bool has_card_emulation_manager() const;
  void clear_card_emulation_manager();
  const ::com::android::nfc::cardemulation::CardEmulationManagerProto& card_emulation_manager() const;
  ::com::android::nfc::cardemulation::CardEmulationManagerProto* release_card_emulation_manager();
  ::com::android::nfc::cardemulation::CardEmulationManagerProto* mutable_card_emulation_manager();
  void set_allocated_card_emulation_manager(::com::android::nfc::cardemulation::CardEmulationManagerProto* card_emulation_manager);

  // optional .com.android.nfc.NfcDispatcherProto nfc_dispatcher = 18;
  bool has_nfc_dispatcher() const;
  void clear_nfc_dispatcher();
  const ::com::android::nfc::NfcDispatcherProto& nfc_dispatcher() const;
  ::com::android::nfc::NfcDispatcherProto* release_nfc_dispatcher();
  ::com::android::nfc::NfcDispatcherProto* mutable_nfc_dispatcher();
  void set_allocated_nfc_dispatcher(::com::android::nfc::NfcDispatcherProto* nfc_dispatcher);

  // optional .com.android.nfc.NfcServiceDumpProto.State state = 1;
  bool has_state() const;
  void clear_state();
  ::com::android::nfc::NfcServiceDumpProto_State state() const;
  void set_state(::com::android::nfc::NfcServiceDumpProto_State value);

  // optional .com.android.nfc.NfcServiceDumpProto.ScreenState screen_state = 4;
  bool has_screen_state() const;
  void clear_screen_state();
  ::com::android::nfc::NfcServiceDumpProto_ScreenState screen_state() const;
  void set_screen_state(::com::android::nfc::NfcServiceDumpProto_ScreenState value);

  // optional bool in_provision_mode = 2;
  bool has_in_provision_mode() const;
  void clear_in_provision_mode();
  bool in_provision_mode() const;
  void set_in_provision_mode(bool value);

  // optional bool ndef_push_enabled = 3;
  bool has_ndef_push_enabled() const;
  void clear_ndef_push_enabled();
  bool ndef_push_enabled() const;
  void set_ndef_push_enabled(bool value);

  // optional bool secure_nfc_enabled = 5;
  bool has_secure_nfc_enabled() const;
  void clear_secure_nfc_enabled();
  bool secure_nfc_enabled() const;
  void set_secure_nfc_enabled(bool value);

  // optional bool polling_paused = 6;
  bool has_polling_paused() const;
  void clear_polling_paused();
  bool polling_paused() const;
  void set_polling_paused(bool value);

  // optional int32 num_tags_detected = 7;
  bool has_num_tags_detected() const;
  void clear_num_tags_detected();
  ::PROTOBUF_NAMESPACE_ID::int32 num_tags_detected() const;
  void set_num_tags_detected(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_p2p_detected = 8;
  bool has_num_p2p_detected() const;
  void clear_num_p2p_detected();
  ::PROTOBUF_NAMESPACE_ID::int32 num_p2p_detected() const;
  void set_num_p2p_detected(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_hce_detected = 9;
  bool has_num_hce_detected() const;
  void clear_num_hce_detected();
  ::PROTOBUF_NAMESPACE_ID::int32 num_hce_detected() const;
  void set_num_hce_detected(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional bool hce_capable = 10;
  bool has_hce_capable() const;
  void clear_hce_capable();
  bool hce_capable() const;
  void set_hce_capable(bool value);

  // optional bool hce_f_capable = 11;
  bool has_hce_f_capable() const;
  void clear_hce_f_capable();
  bool hce_f_capable() const;
  void set_hce_f_capable(bool value);

  // optional bool beam_capable = 12;
  bool has_beam_capable() const;
  void clear_beam_capable();
  bool beam_capable() const;
  void set_beam_capable(bool value);

  // optional bool secure_nfc_capable = 13;
  bool has_secure_nfc_capable() const;
  void clear_secure_nfc_capable();
  bool secure_nfc_capable() const;
  void set_secure_nfc_capable(bool value);

  // optional bool vr_mode_enabled = 14;
  bool has_vr_mode_enabled() const;
  void clear_vr_mode_enabled();
  bool vr_mode_enabled() const;
  void set_vr_mode_enabled(bool value);

  // @@protoc_insertion_point(class_scope:com.android.nfc.NfcServiceDumpProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr native_crash_logs_;
  ::com::android::nfc::DiscoveryParamsProto* discovery_params_;
  ::com::android::nfc::P2pLinkManagerProto* p2p_link_manager_;
  ::com::android::nfc::cardemulation::CardEmulationManagerProto* card_emulation_manager_;
  ::com::android::nfc::NfcDispatcherProto* nfc_dispatcher_;
  int state_;
  int screen_state_;
  bool in_provision_mode_;
  bool ndef_push_enabled_;
  bool secure_nfc_enabled_;
  bool polling_paused_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_tags_detected_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_p2p_detected_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_hce_detected_;
  bool hce_capable_;
  bool hce_f_capable_;
  bool beam_capable_;
  bool secure_nfc_capable_;
  bool vr_mode_enabled_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class DiscoveryParamsProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:com.android.nfc.DiscoveryParamsProto) */ {
 public:
  DiscoveryParamsProto();
  virtual ~DiscoveryParamsProto();

  DiscoveryParamsProto(const DiscoveryParamsProto& from);
  DiscoveryParamsProto(DiscoveryParamsProto&& from) noexcept
    : DiscoveryParamsProto() {
    *this = ::std::move(from);
  }

  inline DiscoveryParamsProto& operator=(const DiscoveryParamsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiscoveryParamsProto& operator=(DiscoveryParamsProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DiscoveryParamsProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DiscoveryParamsProto* internal_default_instance() {
    return reinterpret_cast<const DiscoveryParamsProto*>(
               &_DiscoveryParamsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DiscoveryParamsProto& a, DiscoveryParamsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DiscoveryParamsProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DiscoveryParamsProto* New() const final {
    return CreateMaybeMessage<DiscoveryParamsProto>(nullptr);
  }

  DiscoveryParamsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DiscoveryParamsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DiscoveryParamsProto& from);
  void MergeFrom(const DiscoveryParamsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DiscoveryParamsProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.android.nfc.DiscoveryParamsProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTechMaskFieldNumber = 1,
    kEnableLpdFieldNumber = 2,
    kEnableReaderFieldNumber = 3,
    kEnableHostRoutingFieldNumber = 4,
    kEnableP2PFieldNumber = 5,
  };
  // optional int32 tech_mask = 1;
  bool has_tech_mask() const;
  void clear_tech_mask();
  ::PROTOBUF_NAMESPACE_ID::int32 tech_mask() const;
  void set_tech_mask(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional bool enable_lpd = 2;
  bool has_enable_lpd() const;
  void clear_enable_lpd();
  bool enable_lpd() const;
  void set_enable_lpd(bool value);

  // optional bool enable_reader = 3;
  bool has_enable_reader() const;
  void clear_enable_reader();
  bool enable_reader() const;
  void set_enable_reader(bool value);

  // optional bool enable_host_routing = 4;
  bool has_enable_host_routing() const;
  void clear_enable_host_routing();
  bool enable_host_routing() const;
  void set_enable_host_routing(bool value);

  // optional bool enable_p2p = 5;
  bool has_enable_p2p() const;
  void clear_enable_p2p();
  bool enable_p2p() const;
  void set_enable_p2p(bool value);

  // @@protoc_insertion_point(class_scope:com.android.nfc.DiscoveryParamsProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 tech_mask_;
  bool enable_lpd_;
  bool enable_reader_;
  bool enable_host_routing_;
  bool enable_p2p_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class P2pLinkManagerProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:com.android.nfc.P2pLinkManagerProto) */ {
 public:
  P2pLinkManagerProto();
  virtual ~P2pLinkManagerProto();

  P2pLinkManagerProto(const P2pLinkManagerProto& from);
  P2pLinkManagerProto(P2pLinkManagerProto&& from) noexcept
    : P2pLinkManagerProto() {
    *this = ::std::move(from);
  }

  inline P2pLinkManagerProto& operator=(const P2pLinkManagerProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline P2pLinkManagerProto& operator=(P2pLinkManagerProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const P2pLinkManagerProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const P2pLinkManagerProto* internal_default_instance() {
    return reinterpret_cast<const P2pLinkManagerProto*>(
               &_P2pLinkManagerProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(P2pLinkManagerProto& a, P2pLinkManagerProto& b) {
    a.Swap(&b);
  }
  inline void Swap(P2pLinkManagerProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline P2pLinkManagerProto* New() const final {
    return CreateMaybeMessage<P2pLinkManagerProto>(nullptr);
  }

  P2pLinkManagerProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<P2pLinkManagerProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const P2pLinkManagerProto& from);
  void MergeFrom(const P2pLinkManagerProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(P2pLinkManagerProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.android.nfc.P2pLinkManagerProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef P2pLinkManagerProto_LinkState LinkState;
  static constexpr LinkState LINK_STATE_UNKNOWN =
    P2pLinkManagerProto_LinkState_LINK_STATE_UNKNOWN;
  static constexpr LinkState LINK_STATE_DOWN =
    P2pLinkManagerProto_LinkState_LINK_STATE_DOWN;
  static constexpr LinkState LINK_STATE_DEBOUNCE =
    P2pLinkManagerProto_LinkState_LINK_STATE_DEBOUNCE;
  static constexpr LinkState LINK_STATE_UP =
    P2pLinkManagerProto_LinkState_LINK_STATE_UP;
  static inline bool LinkState_IsValid(int value) {
    return P2pLinkManagerProto_LinkState_IsValid(value);
  }
  static constexpr LinkState LinkState_MIN =
    P2pLinkManagerProto_LinkState_LinkState_MIN;
  static constexpr LinkState LinkState_MAX =
    P2pLinkManagerProto_LinkState_LinkState_MAX;
  static constexpr int LinkState_ARRAYSIZE =
    P2pLinkManagerProto_LinkState_LinkState_ARRAYSIZE;
  template<typename T>
  static inline const std::string& LinkState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LinkState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LinkState_Name.");
    return P2pLinkManagerProto_LinkState_Name(enum_t_value);
  }
  static inline bool LinkState_Parse(const std::string& name,
      LinkState* value) {
    return P2pLinkManagerProto_LinkState_Parse(name, value);
  }

  typedef P2pLinkManagerProto_SendState SendState;
  static constexpr SendState SEND_STATE_UNKNOWN =
    P2pLinkManagerProto_SendState_SEND_STATE_UNKNOWN;
  static constexpr SendState SEND_STATE_NOTHING_TO_SEND =
    P2pLinkManagerProto_SendState_SEND_STATE_NOTHING_TO_SEND;
  static constexpr SendState SEND_STATE_NEED_CONFIRMATION =
    P2pLinkManagerProto_SendState_SEND_STATE_NEED_CONFIRMATION;
  static constexpr SendState SEND_STATE_SENDING =
    P2pLinkManagerProto_SendState_SEND_STATE_SENDING;
  static constexpr SendState SEND_STATE_COMPLETE =
    P2pLinkManagerProto_SendState_SEND_STATE_COMPLETE;
  static constexpr SendState SEND_STATE_CANCELED =
    P2pLinkManagerProto_SendState_SEND_STATE_CANCELED;
  static inline bool SendState_IsValid(int value) {
    return P2pLinkManagerProto_SendState_IsValid(value);
  }
  static constexpr SendState SendState_MIN =
    P2pLinkManagerProto_SendState_SendState_MIN;
  static constexpr SendState SendState_MAX =
    P2pLinkManagerProto_SendState_SendState_MAX;
  static constexpr int SendState_ARRAYSIZE =
    P2pLinkManagerProto_SendState_SendState_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SendState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SendState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SendState_Name.");
    return P2pLinkManagerProto_SendState_Name(enum_t_value);
  }
  static inline bool SendState_Parse(const std::string& name,
      SendState* value) {
    return P2pLinkManagerProto_SendState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUrisToSendFieldNumber = 10,
    kCallbackNdefFieldNumber = 8,
    kMessageToSendFieldNumber = 9,
    kDefaultMiuFieldNumber = 1,
    kDefaultRwSizeFieldNumber = 2,
    kLinkStateFieldNumber = 3,
    kSendStateFieldNumber = 4,
    kSendFlagsFieldNumber = 5,
    kSendEnabledFieldNumber = 6,
    kReceiveEnabledFieldNumber = 7,
  };
  // repeated string uris_to_send = 10 [(.android.privacy) = {
  int uris_to_send_size() const;
  void clear_uris_to_send();
  const std::string& uris_to_send(int index) const;
  std::string* mutable_uris_to_send(int index);
  void set_uris_to_send(int index, const std::string& value);
  void set_uris_to_send(int index, std::string&& value);
  void set_uris_to_send(int index, const char* value);
  void set_uris_to_send(int index, const char* value, size_t size);
  std::string* add_uris_to_send();
  void add_uris_to_send(const std::string& value);
  void add_uris_to_send(std::string&& value);
  void add_uris_to_send(const char* value);
  void add_uris_to_send(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& uris_to_send() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_uris_to_send();

  // optional string callback_ndef = 8 [(.android.privacy) = {
  bool has_callback_ndef() const;
  void clear_callback_ndef();
  const std::string& callback_ndef() const;
  void set_callback_ndef(const std::string& value);
  void set_callback_ndef(std::string&& value);
  void set_callback_ndef(const char* value);
  void set_callback_ndef(const char* value, size_t size);
  std::string* mutable_callback_ndef();
  std::string* release_callback_ndef();
  void set_allocated_callback_ndef(std::string* callback_ndef);

  // optional .android.nfc.NdefMessageProto message_to_send = 9;
  bool has_message_to_send() const;
  void clear_message_to_send();
  const ::android::nfc::NdefMessageProto& message_to_send() const;
  ::android::nfc::NdefMessageProto* release_message_to_send();
  ::android::nfc::NdefMessageProto* mutable_message_to_send();
  void set_allocated_message_to_send(::android::nfc::NdefMessageProto* message_to_send);

  // optional int32 default_miu = 1;
  bool has_default_miu() const;
  void clear_default_miu();
  ::PROTOBUF_NAMESPACE_ID::int32 default_miu() const;
  void set_default_miu(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 default_rw_size = 2;
  bool has_default_rw_size() const;
  void clear_default_rw_size();
  ::PROTOBUF_NAMESPACE_ID::int32 default_rw_size() const;
  void set_default_rw_size(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional .com.android.nfc.P2pLinkManagerProto.LinkState link_state = 3;
  bool has_link_state() const;
  void clear_link_state();
  ::com::android::nfc::P2pLinkManagerProto_LinkState link_state() const;
  void set_link_state(::com::android::nfc::P2pLinkManagerProto_LinkState value);

  // optional .com.android.nfc.P2pLinkManagerProto.SendState send_state = 4;
  bool has_send_state() const;
  void clear_send_state();
  ::com::android::nfc::P2pLinkManagerProto_SendState send_state() const;
  void set_send_state(::com::android::nfc::P2pLinkManagerProto_SendState value);

  // optional int32 send_flags = 5;
  bool has_send_flags() const;
  void clear_send_flags();
  ::PROTOBUF_NAMESPACE_ID::int32 send_flags() const;
  void set_send_flags(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional bool send_enabled = 6;
  bool has_send_enabled() const;
  void clear_send_enabled();
  bool send_enabled() const;
  void set_send_enabled(bool value);

  // optional bool receive_enabled = 7;
  bool has_receive_enabled() const;
  void clear_receive_enabled();
  bool receive_enabled() const;
  void set_receive_enabled(bool value);

  // @@protoc_insertion_point(class_scope:com.android.nfc.P2pLinkManagerProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> uris_to_send_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr callback_ndef_;
  ::android::nfc::NdefMessageProto* message_to_send_;
  ::PROTOBUF_NAMESPACE_ID::int32 default_miu_;
  ::PROTOBUF_NAMESPACE_ID::int32 default_rw_size_;
  int link_state_;
  int send_state_;
  ::PROTOBUF_NAMESPACE_ID::int32 send_flags_;
  bool send_enabled_;
  bool receive_enabled_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class NfcDispatcherProto :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:com.android.nfc.NfcDispatcherProto) */ {
 public:
  NfcDispatcherProto();
  virtual ~NfcDispatcherProto();

  NfcDispatcherProto(const NfcDispatcherProto& from);
  NfcDispatcherProto(NfcDispatcherProto&& from) noexcept
    : NfcDispatcherProto() {
    *this = ::std::move(from);
  }

  inline NfcDispatcherProto& operator=(const NfcDispatcherProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline NfcDispatcherProto& operator=(NfcDispatcherProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const NfcDispatcherProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NfcDispatcherProto* internal_default_instance() {
    return reinterpret_cast<const NfcDispatcherProto*>(
               &_NfcDispatcherProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(NfcDispatcherProto& a, NfcDispatcherProto& b) {
    a.Swap(&b);
  }
  inline void Swap(NfcDispatcherProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NfcDispatcherProto* New() const final {
    return CreateMaybeMessage<NfcDispatcherProto>(nullptr);
  }

  NfcDispatcherProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NfcDispatcherProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const NfcDispatcherProto& from);
  void MergeFrom(const NfcDispatcherProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NfcDispatcherProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.android.nfc.NfcDispatcherProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOverrideFiltersFieldNumber = 5,
    kOverrideTechListsFieldNumber = 6,
    kOverrideIntentFieldNumber = 4,
    kDeviceSupportsBluetoothFieldNumber = 1,
    kBluetoothEnabledByNfcFieldNumber = 2,
    kProvisioningOnlyFieldNumber = 3,
  };
  // repeated .android.content.IntentFilterProto override_filters = 5;
  int override_filters_size() const;
  void clear_override_filters();
  ::android::content::IntentFilterProto* mutable_override_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::content::IntentFilterProto >*
      mutable_override_filters();
  const ::android::content::IntentFilterProto& override_filters(int index) const;
  ::android::content::IntentFilterProto* add_override_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::content::IntentFilterProto >&
      override_filters() const;

  // optional string override_tech_lists = 6;
  bool has_override_tech_lists() const;
  void clear_override_tech_lists();
  const std::string& override_tech_lists() const;
  void set_override_tech_lists(const std::string& value);
  void set_override_tech_lists(std::string&& value);
  void set_override_tech_lists(const char* value);
  void set_override_tech_lists(const char* value, size_t size);
  std::string* mutable_override_tech_lists();
  std::string* release_override_tech_lists();
  void set_allocated_override_tech_lists(std::string* override_tech_lists);

  // optional .android.app.PendingIntentProto override_intent = 4;
  bool has_override_intent() const;
  void clear_override_intent();
  const ::android::app::PendingIntentProto& override_intent() const;
  ::android::app::PendingIntentProto* release_override_intent();
  ::android::app::PendingIntentProto* mutable_override_intent();
  void set_allocated_override_intent(::android::app::PendingIntentProto* override_intent);

  // optional bool device_supports_bluetooth = 1;
  bool has_device_supports_bluetooth() const;
  void clear_device_supports_bluetooth();
  bool device_supports_bluetooth() const;
  void set_device_supports_bluetooth(bool value);

  // optional bool bluetooth_enabled_by_nfc = 2;
  bool has_bluetooth_enabled_by_nfc() const;
  void clear_bluetooth_enabled_by_nfc();
  bool bluetooth_enabled_by_nfc() const;
  void set_bluetooth_enabled_by_nfc(bool value);

  // optional bool provisioning_only = 3;
  bool has_provisioning_only() const;
  void clear_provisioning_only();
  bool provisioning_only() const;
  void set_provisioning_only(bool value);

  // @@protoc_insertion_point(class_scope:com.android.nfc.NfcDispatcherProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::content::IntentFilterProto > override_filters_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr override_tech_lists_;
  ::android::app::PendingIntentProto* override_intent_;
  bool device_supports_bluetooth_;
  bool bluetooth_enabled_by_nfc_;
  bool provisioning_only_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NfcServiceDumpProto

// optional .com.android.nfc.NfcServiceDumpProto.State state = 1;
inline bool NfcServiceDumpProto::has_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NfcServiceDumpProto::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::com::android::nfc::NfcServiceDumpProto_State NfcServiceDumpProto::state() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.NfcServiceDumpProto.state)
  return static_cast< ::com::android::nfc::NfcServiceDumpProto_State >(state_);
}
inline void NfcServiceDumpProto::set_state(::com::android::nfc::NfcServiceDumpProto_State value) {
  assert(::com::android::nfc::NfcServiceDumpProto_State_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  state_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.NfcServiceDumpProto.state)
}

// optional bool in_provision_mode = 2;
inline bool NfcServiceDumpProto::has_in_provision_mode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NfcServiceDumpProto::clear_in_provision_mode() {
  in_provision_mode_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool NfcServiceDumpProto::in_provision_mode() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.NfcServiceDumpProto.in_provision_mode)
  return in_provision_mode_;
}
inline void NfcServiceDumpProto::set_in_provision_mode(bool value) {
  _has_bits_[0] |= 0x00000080u;
  in_provision_mode_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.NfcServiceDumpProto.in_provision_mode)
}

// optional bool ndef_push_enabled = 3;
inline bool NfcServiceDumpProto::has_ndef_push_enabled() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NfcServiceDumpProto::clear_ndef_push_enabled() {
  ndef_push_enabled_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool NfcServiceDumpProto::ndef_push_enabled() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.NfcServiceDumpProto.ndef_push_enabled)
  return ndef_push_enabled_;
}
inline void NfcServiceDumpProto::set_ndef_push_enabled(bool value) {
  _has_bits_[0] |= 0x00000100u;
  ndef_push_enabled_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.NfcServiceDumpProto.ndef_push_enabled)
}

// optional .com.android.nfc.NfcServiceDumpProto.ScreenState screen_state = 4;
inline bool NfcServiceDumpProto::has_screen_state() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NfcServiceDumpProto::clear_screen_state() {
  screen_state_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::com::android::nfc::NfcServiceDumpProto_ScreenState NfcServiceDumpProto::screen_state() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.NfcServiceDumpProto.screen_state)
  return static_cast< ::com::android::nfc::NfcServiceDumpProto_ScreenState >(screen_state_);
}
inline void NfcServiceDumpProto::set_screen_state(::com::android::nfc::NfcServiceDumpProto_ScreenState value) {
  assert(::com::android::nfc::NfcServiceDumpProto_ScreenState_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  screen_state_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.NfcServiceDumpProto.screen_state)
}

// optional bool secure_nfc_enabled = 5;
inline bool NfcServiceDumpProto::has_secure_nfc_enabled() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NfcServiceDumpProto::clear_secure_nfc_enabled() {
  secure_nfc_enabled_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool NfcServiceDumpProto::secure_nfc_enabled() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.NfcServiceDumpProto.secure_nfc_enabled)
  return secure_nfc_enabled_;
}
inline void NfcServiceDumpProto::set_secure_nfc_enabled(bool value) {
  _has_bits_[0] |= 0x00000200u;
  secure_nfc_enabled_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.NfcServiceDumpProto.secure_nfc_enabled)
}

// optional bool polling_paused = 6;
inline bool NfcServiceDumpProto::has_polling_paused() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NfcServiceDumpProto::clear_polling_paused() {
  polling_paused_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool NfcServiceDumpProto::polling_paused() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.NfcServiceDumpProto.polling_paused)
  return polling_paused_;
}
inline void NfcServiceDumpProto::set_polling_paused(bool value) {
  _has_bits_[0] |= 0x00000400u;
  polling_paused_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.NfcServiceDumpProto.polling_paused)
}

// optional int32 num_tags_detected = 7;
inline bool NfcServiceDumpProto::has_num_tags_detected() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void NfcServiceDumpProto::clear_num_tags_detected() {
  num_tags_detected_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NfcServiceDumpProto::num_tags_detected() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.NfcServiceDumpProto.num_tags_detected)
  return num_tags_detected_;
}
inline void NfcServiceDumpProto::set_num_tags_detected(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000800u;
  num_tags_detected_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.NfcServiceDumpProto.num_tags_detected)
}

// optional int32 num_p2p_detected = 8;
inline bool NfcServiceDumpProto::has_num_p2p_detected() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void NfcServiceDumpProto::clear_num_p2p_detected() {
  num_p2p_detected_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NfcServiceDumpProto::num_p2p_detected() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.NfcServiceDumpProto.num_p2p_detected)
  return num_p2p_detected_;
}
inline void NfcServiceDumpProto::set_num_p2p_detected(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00001000u;
  num_p2p_detected_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.NfcServiceDumpProto.num_p2p_detected)
}

// optional int32 num_hce_detected = 9;
inline bool NfcServiceDumpProto::has_num_hce_detected() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void NfcServiceDumpProto::clear_num_hce_detected() {
  num_hce_detected_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NfcServiceDumpProto::num_hce_detected() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.NfcServiceDumpProto.num_hce_detected)
  return num_hce_detected_;
}
inline void NfcServiceDumpProto::set_num_hce_detected(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00002000u;
  num_hce_detected_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.NfcServiceDumpProto.num_hce_detected)
}

// optional bool hce_capable = 10;
inline bool NfcServiceDumpProto::has_hce_capable() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void NfcServiceDumpProto::clear_hce_capable() {
  hce_capable_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool NfcServiceDumpProto::hce_capable() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.NfcServiceDumpProto.hce_capable)
  return hce_capable_;
}
inline void NfcServiceDumpProto::set_hce_capable(bool value) {
  _has_bits_[0] |= 0x00004000u;
  hce_capable_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.NfcServiceDumpProto.hce_capable)
}

// optional bool hce_f_capable = 11;
inline bool NfcServiceDumpProto::has_hce_f_capable() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void NfcServiceDumpProto::clear_hce_f_capable() {
  hce_f_capable_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool NfcServiceDumpProto::hce_f_capable() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.NfcServiceDumpProto.hce_f_capable)
  return hce_f_capable_;
}
inline void NfcServiceDumpProto::set_hce_f_capable(bool value) {
  _has_bits_[0] |= 0x00008000u;
  hce_f_capable_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.NfcServiceDumpProto.hce_f_capable)
}

// optional bool beam_capable = 12;
inline bool NfcServiceDumpProto::has_beam_capable() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void NfcServiceDumpProto::clear_beam_capable() {
  beam_capable_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool NfcServiceDumpProto::beam_capable() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.NfcServiceDumpProto.beam_capable)
  return beam_capable_;
}
inline void NfcServiceDumpProto::set_beam_capable(bool value) {
  _has_bits_[0] |= 0x00010000u;
  beam_capable_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.NfcServiceDumpProto.beam_capable)
}

// optional bool secure_nfc_capable = 13;
inline bool NfcServiceDumpProto::has_secure_nfc_capable() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void NfcServiceDumpProto::clear_secure_nfc_capable() {
  secure_nfc_capable_ = false;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool NfcServiceDumpProto::secure_nfc_capable() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.NfcServiceDumpProto.secure_nfc_capable)
  return secure_nfc_capable_;
}
inline void NfcServiceDumpProto::set_secure_nfc_capable(bool value) {
  _has_bits_[0] |= 0x00020000u;
  secure_nfc_capable_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.NfcServiceDumpProto.secure_nfc_capable)
}

// optional bool vr_mode_enabled = 14;
inline bool NfcServiceDumpProto::has_vr_mode_enabled() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void NfcServiceDumpProto::clear_vr_mode_enabled() {
  vr_mode_enabled_ = false;
  _has_bits_[0] &= ~0x00040000u;
}
inline bool NfcServiceDumpProto::vr_mode_enabled() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.NfcServiceDumpProto.vr_mode_enabled)
  return vr_mode_enabled_;
}
inline void NfcServiceDumpProto::set_vr_mode_enabled(bool value) {
  _has_bits_[0] |= 0x00040000u;
  vr_mode_enabled_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.NfcServiceDumpProto.vr_mode_enabled)
}

// optional .com.android.nfc.DiscoveryParamsProto discovery_params = 15;
inline bool NfcServiceDumpProto::has_discovery_params() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NfcServiceDumpProto::clear_discovery_params() {
  if (discovery_params_ != nullptr) discovery_params_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::com::android::nfc::DiscoveryParamsProto& NfcServiceDumpProto::discovery_params() const {
  const ::com::android::nfc::DiscoveryParamsProto* p = discovery_params_;
  // @@protoc_insertion_point(field_get:com.android.nfc.NfcServiceDumpProto.discovery_params)
  return p != nullptr ? *p : *reinterpret_cast<const ::com::android::nfc::DiscoveryParamsProto*>(
      &::com::android::nfc::_DiscoveryParamsProto_default_instance_);
}
inline ::com::android::nfc::DiscoveryParamsProto* NfcServiceDumpProto::release_discovery_params() {
  // @@protoc_insertion_point(field_release:com.android.nfc.NfcServiceDumpProto.discovery_params)
  _has_bits_[0] &= ~0x00000002u;
  ::com::android::nfc::DiscoveryParamsProto* temp = discovery_params_;
  discovery_params_ = nullptr;
  return temp;
}
inline ::com::android::nfc::DiscoveryParamsProto* NfcServiceDumpProto::mutable_discovery_params() {
  _has_bits_[0] |= 0x00000002u;
  if (discovery_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::android::nfc::DiscoveryParamsProto>(GetArenaNoVirtual());
    discovery_params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:com.android.nfc.NfcServiceDumpProto.discovery_params)
  return discovery_params_;
}
inline void NfcServiceDumpProto::set_allocated_discovery_params(::com::android::nfc::DiscoveryParamsProto* discovery_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete discovery_params_;
  }
  if (discovery_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      discovery_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, discovery_params, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  discovery_params_ = discovery_params;
  // @@protoc_insertion_point(field_set_allocated:com.android.nfc.NfcServiceDumpProto.discovery_params)
}

// optional .com.android.nfc.P2pLinkManagerProto p2p_link_manager = 16;
inline bool NfcServiceDumpProto::has_p2p_link_manager() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NfcServiceDumpProto::clear_p2p_link_manager() {
  if (p2p_link_manager_ != nullptr) p2p_link_manager_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::com::android::nfc::P2pLinkManagerProto& NfcServiceDumpProto::p2p_link_manager() const {
  const ::com::android::nfc::P2pLinkManagerProto* p = p2p_link_manager_;
  // @@protoc_insertion_point(field_get:com.android.nfc.NfcServiceDumpProto.p2p_link_manager)
  return p != nullptr ? *p : *reinterpret_cast<const ::com::android::nfc::P2pLinkManagerProto*>(
      &::com::android::nfc::_P2pLinkManagerProto_default_instance_);
}
inline ::com::android::nfc::P2pLinkManagerProto* NfcServiceDumpProto::release_p2p_link_manager() {
  // @@protoc_insertion_point(field_release:com.android.nfc.NfcServiceDumpProto.p2p_link_manager)
  _has_bits_[0] &= ~0x00000004u;
  ::com::android::nfc::P2pLinkManagerProto* temp = p2p_link_manager_;
  p2p_link_manager_ = nullptr;
  return temp;
}
inline ::com::android::nfc::P2pLinkManagerProto* NfcServiceDumpProto::mutable_p2p_link_manager() {
  _has_bits_[0] |= 0x00000004u;
  if (p2p_link_manager_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::android::nfc::P2pLinkManagerProto>(GetArenaNoVirtual());
    p2p_link_manager_ = p;
  }
  // @@protoc_insertion_point(field_mutable:com.android.nfc.NfcServiceDumpProto.p2p_link_manager)
  return p2p_link_manager_;
}
inline void NfcServiceDumpProto::set_allocated_p2p_link_manager(::com::android::nfc::P2pLinkManagerProto* p2p_link_manager) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete p2p_link_manager_;
  }
  if (p2p_link_manager) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      p2p_link_manager = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, p2p_link_manager, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  p2p_link_manager_ = p2p_link_manager;
  // @@protoc_insertion_point(field_set_allocated:com.android.nfc.NfcServiceDumpProto.p2p_link_manager)
}

// optional .com.android.nfc.cardemulation.CardEmulationManagerProto card_emulation_manager = 17;
inline bool NfcServiceDumpProto::has_card_emulation_manager() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline const ::com::android::nfc::cardemulation::CardEmulationManagerProto& NfcServiceDumpProto::card_emulation_manager() const {
  const ::com::android::nfc::cardemulation::CardEmulationManagerProto* p = card_emulation_manager_;
  // @@protoc_insertion_point(field_get:com.android.nfc.NfcServiceDumpProto.card_emulation_manager)
  return p != nullptr ? *p : *reinterpret_cast<const ::com::android::nfc::cardemulation::CardEmulationManagerProto*>(
      &::com::android::nfc::cardemulation::_CardEmulationManagerProto_default_instance_);
}
inline ::com::android::nfc::cardemulation::CardEmulationManagerProto* NfcServiceDumpProto::release_card_emulation_manager() {
  // @@protoc_insertion_point(field_release:com.android.nfc.NfcServiceDumpProto.card_emulation_manager)
  _has_bits_[0] &= ~0x00000008u;
  ::com::android::nfc::cardemulation::CardEmulationManagerProto* temp = card_emulation_manager_;
  card_emulation_manager_ = nullptr;
  return temp;
}
inline ::com::android::nfc::cardemulation::CardEmulationManagerProto* NfcServiceDumpProto::mutable_card_emulation_manager() {
  _has_bits_[0] |= 0x00000008u;
  if (card_emulation_manager_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::android::nfc::cardemulation::CardEmulationManagerProto>(GetArenaNoVirtual());
    card_emulation_manager_ = p;
  }
  // @@protoc_insertion_point(field_mutable:com.android.nfc.NfcServiceDumpProto.card_emulation_manager)
  return card_emulation_manager_;
}
inline void NfcServiceDumpProto::set_allocated_card_emulation_manager(::com::android::nfc::cardemulation::CardEmulationManagerProto* card_emulation_manager) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(card_emulation_manager_);
  }
  if (card_emulation_manager) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      card_emulation_manager = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, card_emulation_manager, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  card_emulation_manager_ = card_emulation_manager;
  // @@protoc_insertion_point(field_set_allocated:com.android.nfc.NfcServiceDumpProto.card_emulation_manager)
}

// optional .com.android.nfc.NfcDispatcherProto nfc_dispatcher = 18;
inline bool NfcServiceDumpProto::has_nfc_dispatcher() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NfcServiceDumpProto::clear_nfc_dispatcher() {
  if (nfc_dispatcher_ != nullptr) nfc_dispatcher_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::com::android::nfc::NfcDispatcherProto& NfcServiceDumpProto::nfc_dispatcher() const {
  const ::com::android::nfc::NfcDispatcherProto* p = nfc_dispatcher_;
  // @@protoc_insertion_point(field_get:com.android.nfc.NfcServiceDumpProto.nfc_dispatcher)
  return p != nullptr ? *p : *reinterpret_cast<const ::com::android::nfc::NfcDispatcherProto*>(
      &::com::android::nfc::_NfcDispatcherProto_default_instance_);
}
inline ::com::android::nfc::NfcDispatcherProto* NfcServiceDumpProto::release_nfc_dispatcher() {
  // @@protoc_insertion_point(field_release:com.android.nfc.NfcServiceDumpProto.nfc_dispatcher)
  _has_bits_[0] &= ~0x00000010u;
  ::com::android::nfc::NfcDispatcherProto* temp = nfc_dispatcher_;
  nfc_dispatcher_ = nullptr;
  return temp;
}
inline ::com::android::nfc::NfcDispatcherProto* NfcServiceDumpProto::mutable_nfc_dispatcher() {
  _has_bits_[0] |= 0x00000010u;
  if (nfc_dispatcher_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::android::nfc::NfcDispatcherProto>(GetArenaNoVirtual());
    nfc_dispatcher_ = p;
  }
  // @@protoc_insertion_point(field_mutable:com.android.nfc.NfcServiceDumpProto.nfc_dispatcher)
  return nfc_dispatcher_;
}
inline void NfcServiceDumpProto::set_allocated_nfc_dispatcher(::com::android::nfc::NfcDispatcherProto* nfc_dispatcher) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete nfc_dispatcher_;
  }
  if (nfc_dispatcher) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      nfc_dispatcher = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nfc_dispatcher, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  nfc_dispatcher_ = nfc_dispatcher;
  // @@protoc_insertion_point(field_set_allocated:com.android.nfc.NfcServiceDumpProto.nfc_dispatcher)
}

// optional string native_crash_logs = 19 [(.android.privacy) = {
inline bool NfcServiceDumpProto::has_native_crash_logs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NfcServiceDumpProto::clear_native_crash_logs() {
  native_crash_logs_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NfcServiceDumpProto::native_crash_logs() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.NfcServiceDumpProto.native_crash_logs)
  return native_crash_logs_.GetNoArena();
}
inline void NfcServiceDumpProto::set_native_crash_logs(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  native_crash_logs_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.android.nfc.NfcServiceDumpProto.native_crash_logs)
}
inline void NfcServiceDumpProto::set_native_crash_logs(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  native_crash_logs_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.android.nfc.NfcServiceDumpProto.native_crash_logs)
}
inline void NfcServiceDumpProto::set_native_crash_logs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  native_crash_logs_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.android.nfc.NfcServiceDumpProto.native_crash_logs)
}
inline void NfcServiceDumpProto::set_native_crash_logs(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  native_crash_logs_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.android.nfc.NfcServiceDumpProto.native_crash_logs)
}
inline std::string* NfcServiceDumpProto::mutable_native_crash_logs() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:com.android.nfc.NfcServiceDumpProto.native_crash_logs)
  return native_crash_logs_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NfcServiceDumpProto::release_native_crash_logs() {
  // @@protoc_insertion_point(field_release:com.android.nfc.NfcServiceDumpProto.native_crash_logs)
  if (!has_native_crash_logs()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return native_crash_logs_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NfcServiceDumpProto::set_allocated_native_crash_logs(std::string* native_crash_logs) {
  if (native_crash_logs != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  native_crash_logs_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), native_crash_logs);
  // @@protoc_insertion_point(field_set_allocated:com.android.nfc.NfcServiceDumpProto.native_crash_logs)
}

// -------------------------------------------------------------------

// DiscoveryParamsProto

// optional int32 tech_mask = 1;
inline bool DiscoveryParamsProto::has_tech_mask() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiscoveryParamsProto::clear_tech_mask() {
  tech_mask_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DiscoveryParamsProto::tech_mask() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.DiscoveryParamsProto.tech_mask)
  return tech_mask_;
}
inline void DiscoveryParamsProto::set_tech_mask(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  tech_mask_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.DiscoveryParamsProto.tech_mask)
}

// optional bool enable_lpd = 2;
inline bool DiscoveryParamsProto::has_enable_lpd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiscoveryParamsProto::clear_enable_lpd() {
  enable_lpd_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool DiscoveryParamsProto::enable_lpd() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.DiscoveryParamsProto.enable_lpd)
  return enable_lpd_;
}
inline void DiscoveryParamsProto::set_enable_lpd(bool value) {
  _has_bits_[0] |= 0x00000002u;
  enable_lpd_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.DiscoveryParamsProto.enable_lpd)
}

// optional bool enable_reader = 3;
inline bool DiscoveryParamsProto::has_enable_reader() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DiscoveryParamsProto::clear_enable_reader() {
  enable_reader_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool DiscoveryParamsProto::enable_reader() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.DiscoveryParamsProto.enable_reader)
  return enable_reader_;
}
inline void DiscoveryParamsProto::set_enable_reader(bool value) {
  _has_bits_[0] |= 0x00000004u;
  enable_reader_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.DiscoveryParamsProto.enable_reader)
}

// optional bool enable_host_routing = 4;
inline bool DiscoveryParamsProto::has_enable_host_routing() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DiscoveryParamsProto::clear_enable_host_routing() {
  enable_host_routing_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool DiscoveryParamsProto::enable_host_routing() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.DiscoveryParamsProto.enable_host_routing)
  return enable_host_routing_;
}
inline void DiscoveryParamsProto::set_enable_host_routing(bool value) {
  _has_bits_[0] |= 0x00000008u;
  enable_host_routing_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.DiscoveryParamsProto.enable_host_routing)
}

// optional bool enable_p2p = 5;
inline bool DiscoveryParamsProto::has_enable_p2p() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DiscoveryParamsProto::clear_enable_p2p() {
  enable_p2p_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool DiscoveryParamsProto::enable_p2p() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.DiscoveryParamsProto.enable_p2p)
  return enable_p2p_;
}
inline void DiscoveryParamsProto::set_enable_p2p(bool value) {
  _has_bits_[0] |= 0x00000010u;
  enable_p2p_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.DiscoveryParamsProto.enable_p2p)
}

// -------------------------------------------------------------------

// P2pLinkManagerProto

// optional int32 default_miu = 1;
inline bool P2pLinkManagerProto::has_default_miu() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void P2pLinkManagerProto::clear_default_miu() {
  default_miu_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 P2pLinkManagerProto::default_miu() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.P2pLinkManagerProto.default_miu)
  return default_miu_;
}
inline void P2pLinkManagerProto::set_default_miu(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  default_miu_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.P2pLinkManagerProto.default_miu)
}

// optional int32 default_rw_size = 2;
inline bool P2pLinkManagerProto::has_default_rw_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void P2pLinkManagerProto::clear_default_rw_size() {
  default_rw_size_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 P2pLinkManagerProto::default_rw_size() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.P2pLinkManagerProto.default_rw_size)
  return default_rw_size_;
}
inline void P2pLinkManagerProto::set_default_rw_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  default_rw_size_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.P2pLinkManagerProto.default_rw_size)
}

// optional .com.android.nfc.P2pLinkManagerProto.LinkState link_state = 3;
inline bool P2pLinkManagerProto::has_link_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void P2pLinkManagerProto::clear_link_state() {
  link_state_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::com::android::nfc::P2pLinkManagerProto_LinkState P2pLinkManagerProto::link_state() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.P2pLinkManagerProto.link_state)
  return static_cast< ::com::android::nfc::P2pLinkManagerProto_LinkState >(link_state_);
}
inline void P2pLinkManagerProto::set_link_state(::com::android::nfc::P2pLinkManagerProto_LinkState value) {
  assert(::com::android::nfc::P2pLinkManagerProto_LinkState_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  link_state_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.P2pLinkManagerProto.link_state)
}

// optional .com.android.nfc.P2pLinkManagerProto.SendState send_state = 4;
inline bool P2pLinkManagerProto::has_send_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void P2pLinkManagerProto::clear_send_state() {
  send_state_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::com::android::nfc::P2pLinkManagerProto_SendState P2pLinkManagerProto::send_state() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.P2pLinkManagerProto.send_state)
  return static_cast< ::com::android::nfc::P2pLinkManagerProto_SendState >(send_state_);
}
inline void P2pLinkManagerProto::set_send_state(::com::android::nfc::P2pLinkManagerProto_SendState value) {
  assert(::com::android::nfc::P2pLinkManagerProto_SendState_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  send_state_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.P2pLinkManagerProto.send_state)
}

// optional int32 send_flags = 5;
inline bool P2pLinkManagerProto::has_send_flags() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void P2pLinkManagerProto::clear_send_flags() {
  send_flags_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 P2pLinkManagerProto::send_flags() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.P2pLinkManagerProto.send_flags)
  return send_flags_;
}
inline void P2pLinkManagerProto::set_send_flags(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  send_flags_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.P2pLinkManagerProto.send_flags)
}

// optional bool send_enabled = 6;
inline bool P2pLinkManagerProto::has_send_enabled() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void P2pLinkManagerProto::clear_send_enabled() {
  send_enabled_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool P2pLinkManagerProto::send_enabled() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.P2pLinkManagerProto.send_enabled)
  return send_enabled_;
}
inline void P2pLinkManagerProto::set_send_enabled(bool value) {
  _has_bits_[0] |= 0x00000080u;
  send_enabled_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.P2pLinkManagerProto.send_enabled)
}

// optional bool receive_enabled = 7;
inline bool P2pLinkManagerProto::has_receive_enabled() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void P2pLinkManagerProto::clear_receive_enabled() {
  receive_enabled_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool P2pLinkManagerProto::receive_enabled() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.P2pLinkManagerProto.receive_enabled)
  return receive_enabled_;
}
inline void P2pLinkManagerProto::set_receive_enabled(bool value) {
  _has_bits_[0] |= 0x00000100u;
  receive_enabled_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.P2pLinkManagerProto.receive_enabled)
}

// optional string callback_ndef = 8 [(.android.privacy) = {
inline bool P2pLinkManagerProto::has_callback_ndef() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void P2pLinkManagerProto::clear_callback_ndef() {
  callback_ndef_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& P2pLinkManagerProto::callback_ndef() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.P2pLinkManagerProto.callback_ndef)
  return callback_ndef_.GetNoArena();
}
inline void P2pLinkManagerProto::set_callback_ndef(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  callback_ndef_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.android.nfc.P2pLinkManagerProto.callback_ndef)
}
inline void P2pLinkManagerProto::set_callback_ndef(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  callback_ndef_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.android.nfc.P2pLinkManagerProto.callback_ndef)
}
inline void P2pLinkManagerProto::set_callback_ndef(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  callback_ndef_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.android.nfc.P2pLinkManagerProto.callback_ndef)
}
inline void P2pLinkManagerProto::set_callback_ndef(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  callback_ndef_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.android.nfc.P2pLinkManagerProto.callback_ndef)
}
inline std::string* P2pLinkManagerProto::mutable_callback_ndef() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:com.android.nfc.P2pLinkManagerProto.callback_ndef)
  return callback_ndef_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* P2pLinkManagerProto::release_callback_ndef() {
  // @@protoc_insertion_point(field_release:com.android.nfc.P2pLinkManagerProto.callback_ndef)
  if (!has_callback_ndef()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return callback_ndef_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void P2pLinkManagerProto::set_allocated_callback_ndef(std::string* callback_ndef) {
  if (callback_ndef != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  callback_ndef_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), callback_ndef);
  // @@protoc_insertion_point(field_set_allocated:com.android.nfc.P2pLinkManagerProto.callback_ndef)
}

// optional .android.nfc.NdefMessageProto message_to_send = 9;
inline bool P2pLinkManagerProto::has_message_to_send() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::android::nfc::NdefMessageProto& P2pLinkManagerProto::message_to_send() const {
  const ::android::nfc::NdefMessageProto* p = message_to_send_;
  // @@protoc_insertion_point(field_get:com.android.nfc.P2pLinkManagerProto.message_to_send)
  return p != nullptr ? *p : *reinterpret_cast<const ::android::nfc::NdefMessageProto*>(
      &::android::nfc::_NdefMessageProto_default_instance_);
}
inline ::android::nfc::NdefMessageProto* P2pLinkManagerProto::release_message_to_send() {
  // @@protoc_insertion_point(field_release:com.android.nfc.P2pLinkManagerProto.message_to_send)
  _has_bits_[0] &= ~0x00000002u;
  ::android::nfc::NdefMessageProto* temp = message_to_send_;
  message_to_send_ = nullptr;
  return temp;
}
inline ::android::nfc::NdefMessageProto* P2pLinkManagerProto::mutable_message_to_send() {
  _has_bits_[0] |= 0x00000002u;
  if (message_to_send_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::nfc::NdefMessageProto>(GetArenaNoVirtual());
    message_to_send_ = p;
  }
  // @@protoc_insertion_point(field_mutable:com.android.nfc.P2pLinkManagerProto.message_to_send)
  return message_to_send_;
}
inline void P2pLinkManagerProto::set_allocated_message_to_send(::android::nfc::NdefMessageProto* message_to_send) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(message_to_send_);
  }
  if (message_to_send) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      message_to_send = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message_to_send, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  message_to_send_ = message_to_send;
  // @@protoc_insertion_point(field_set_allocated:com.android.nfc.P2pLinkManagerProto.message_to_send)
}

// repeated string uris_to_send = 10 [(.android.privacy) = {
inline int P2pLinkManagerProto::uris_to_send_size() const {
  return uris_to_send_.size();
}
inline void P2pLinkManagerProto::clear_uris_to_send() {
  uris_to_send_.Clear();
}
inline const std::string& P2pLinkManagerProto::uris_to_send(int index) const {
  // @@protoc_insertion_point(field_get:com.android.nfc.P2pLinkManagerProto.uris_to_send)
  return uris_to_send_.Get(index);
}
inline std::string* P2pLinkManagerProto::mutable_uris_to_send(int index) {
  // @@protoc_insertion_point(field_mutable:com.android.nfc.P2pLinkManagerProto.uris_to_send)
  return uris_to_send_.Mutable(index);
}
inline void P2pLinkManagerProto::set_uris_to_send(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:com.android.nfc.P2pLinkManagerProto.uris_to_send)
  uris_to_send_.Mutable(index)->assign(value);
}
inline void P2pLinkManagerProto::set_uris_to_send(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:com.android.nfc.P2pLinkManagerProto.uris_to_send)
  uris_to_send_.Mutable(index)->assign(std::move(value));
}
inline void P2pLinkManagerProto::set_uris_to_send(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  uris_to_send_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.android.nfc.P2pLinkManagerProto.uris_to_send)
}
inline void P2pLinkManagerProto::set_uris_to_send(int index, const char* value, size_t size) {
  uris_to_send_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.android.nfc.P2pLinkManagerProto.uris_to_send)
}
inline std::string* P2pLinkManagerProto::add_uris_to_send() {
  // @@protoc_insertion_point(field_add_mutable:com.android.nfc.P2pLinkManagerProto.uris_to_send)
  return uris_to_send_.Add();
}
inline void P2pLinkManagerProto::add_uris_to_send(const std::string& value) {
  uris_to_send_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.android.nfc.P2pLinkManagerProto.uris_to_send)
}
inline void P2pLinkManagerProto::add_uris_to_send(std::string&& value) {
  uris_to_send_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:com.android.nfc.P2pLinkManagerProto.uris_to_send)
}
inline void P2pLinkManagerProto::add_uris_to_send(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  uris_to_send_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.android.nfc.P2pLinkManagerProto.uris_to_send)
}
inline void P2pLinkManagerProto::add_uris_to_send(const char* value, size_t size) {
  uris_to_send_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.android.nfc.P2pLinkManagerProto.uris_to_send)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
P2pLinkManagerProto::uris_to_send() const {
  // @@protoc_insertion_point(field_list:com.android.nfc.P2pLinkManagerProto.uris_to_send)
  return uris_to_send_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
P2pLinkManagerProto::mutable_uris_to_send() {
  // @@protoc_insertion_point(field_mutable_list:com.android.nfc.P2pLinkManagerProto.uris_to_send)
  return &uris_to_send_;
}

// -------------------------------------------------------------------

// NfcDispatcherProto

// optional bool device_supports_bluetooth = 1;
inline bool NfcDispatcherProto::has_device_supports_bluetooth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NfcDispatcherProto::clear_device_supports_bluetooth() {
  device_supports_bluetooth_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool NfcDispatcherProto::device_supports_bluetooth() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.NfcDispatcherProto.device_supports_bluetooth)
  return device_supports_bluetooth_;
}
inline void NfcDispatcherProto::set_device_supports_bluetooth(bool value) {
  _has_bits_[0] |= 0x00000004u;
  device_supports_bluetooth_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.NfcDispatcherProto.device_supports_bluetooth)
}

// optional bool bluetooth_enabled_by_nfc = 2;
inline bool NfcDispatcherProto::has_bluetooth_enabled_by_nfc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NfcDispatcherProto::clear_bluetooth_enabled_by_nfc() {
  bluetooth_enabled_by_nfc_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool NfcDispatcherProto::bluetooth_enabled_by_nfc() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.NfcDispatcherProto.bluetooth_enabled_by_nfc)
  return bluetooth_enabled_by_nfc_;
}
inline void NfcDispatcherProto::set_bluetooth_enabled_by_nfc(bool value) {
  _has_bits_[0] |= 0x00000008u;
  bluetooth_enabled_by_nfc_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.NfcDispatcherProto.bluetooth_enabled_by_nfc)
}

// optional bool provisioning_only = 3;
inline bool NfcDispatcherProto::has_provisioning_only() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NfcDispatcherProto::clear_provisioning_only() {
  provisioning_only_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool NfcDispatcherProto::provisioning_only() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.NfcDispatcherProto.provisioning_only)
  return provisioning_only_;
}
inline void NfcDispatcherProto::set_provisioning_only(bool value) {
  _has_bits_[0] |= 0x00000010u;
  provisioning_only_ = value;
  // @@protoc_insertion_point(field_set:com.android.nfc.NfcDispatcherProto.provisioning_only)
}

// optional .android.app.PendingIntentProto override_intent = 4;
inline bool NfcDispatcherProto::has_override_intent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::android::app::PendingIntentProto& NfcDispatcherProto::override_intent() const {
  const ::android::app::PendingIntentProto* p = override_intent_;
  // @@protoc_insertion_point(field_get:com.android.nfc.NfcDispatcherProto.override_intent)
  return p != nullptr ? *p : *reinterpret_cast<const ::android::app::PendingIntentProto*>(
      &::android::app::_PendingIntentProto_default_instance_);
}
inline ::android::app::PendingIntentProto* NfcDispatcherProto::release_override_intent() {
  // @@protoc_insertion_point(field_release:com.android.nfc.NfcDispatcherProto.override_intent)
  _has_bits_[0] &= ~0x00000002u;
  ::android::app::PendingIntentProto* temp = override_intent_;
  override_intent_ = nullptr;
  return temp;
}
inline ::android::app::PendingIntentProto* NfcDispatcherProto::mutable_override_intent() {
  _has_bits_[0] |= 0x00000002u;
  if (override_intent_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::app::PendingIntentProto>(GetArenaNoVirtual());
    override_intent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:com.android.nfc.NfcDispatcherProto.override_intent)
  return override_intent_;
}
inline void NfcDispatcherProto::set_allocated_override_intent(::android::app::PendingIntentProto* override_intent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(override_intent_);
  }
  if (override_intent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      override_intent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, override_intent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  override_intent_ = override_intent;
  // @@protoc_insertion_point(field_set_allocated:com.android.nfc.NfcDispatcherProto.override_intent)
}

// repeated .android.content.IntentFilterProto override_filters = 5;
inline int NfcDispatcherProto::override_filters_size() const {
  return override_filters_.size();
}
inline ::android::content::IntentFilterProto* NfcDispatcherProto::mutable_override_filters(int index) {
  // @@protoc_insertion_point(field_mutable:com.android.nfc.NfcDispatcherProto.override_filters)
  return override_filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::content::IntentFilterProto >*
NfcDispatcherProto::mutable_override_filters() {
  // @@protoc_insertion_point(field_mutable_list:com.android.nfc.NfcDispatcherProto.override_filters)
  return &override_filters_;
}
inline const ::android::content::IntentFilterProto& NfcDispatcherProto::override_filters(int index) const {
  // @@protoc_insertion_point(field_get:com.android.nfc.NfcDispatcherProto.override_filters)
  return override_filters_.Get(index);
}
inline ::android::content::IntentFilterProto* NfcDispatcherProto::add_override_filters() {
  // @@protoc_insertion_point(field_add:com.android.nfc.NfcDispatcherProto.override_filters)
  return override_filters_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::content::IntentFilterProto >&
NfcDispatcherProto::override_filters() const {
  // @@protoc_insertion_point(field_list:com.android.nfc.NfcDispatcherProto.override_filters)
  return override_filters_;
}

// optional string override_tech_lists = 6;
inline bool NfcDispatcherProto::has_override_tech_lists() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NfcDispatcherProto::clear_override_tech_lists() {
  override_tech_lists_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NfcDispatcherProto::override_tech_lists() const {
  // @@protoc_insertion_point(field_get:com.android.nfc.NfcDispatcherProto.override_tech_lists)
  return override_tech_lists_.GetNoArena();
}
inline void NfcDispatcherProto::set_override_tech_lists(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  override_tech_lists_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.android.nfc.NfcDispatcherProto.override_tech_lists)
}
inline void NfcDispatcherProto::set_override_tech_lists(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  override_tech_lists_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.android.nfc.NfcDispatcherProto.override_tech_lists)
}
inline void NfcDispatcherProto::set_override_tech_lists(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  override_tech_lists_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.android.nfc.NfcDispatcherProto.override_tech_lists)
}
inline void NfcDispatcherProto::set_override_tech_lists(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  override_tech_lists_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.android.nfc.NfcDispatcherProto.override_tech_lists)
}
inline std::string* NfcDispatcherProto::mutable_override_tech_lists() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:com.android.nfc.NfcDispatcherProto.override_tech_lists)
  return override_tech_lists_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NfcDispatcherProto::release_override_tech_lists() {
  // @@protoc_insertion_point(field_release:com.android.nfc.NfcDispatcherProto.override_tech_lists)
  if (!has_override_tech_lists()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return override_tech_lists_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NfcDispatcherProto::set_allocated_override_tech_lists(std::string* override_tech_lists) {
  if (override_tech_lists != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  override_tech_lists_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), override_tech_lists);
  // @@protoc_insertion_point(field_set_allocated:com.android.nfc.NfcDispatcherProto.override_tech_lists)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace nfc
}  // namespace android
}  // namespace com

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::com::android::nfc::NfcServiceDumpProto_State> : ::std::true_type {};
template <> struct is_proto_enum< ::com::android::nfc::NfcServiceDumpProto_ScreenState> : ::std::true_type {};
template <> struct is_proto_enum< ::com::android::nfc::P2pLinkManagerProto_LinkState> : ::std::true_type {};
template <> struct is_proto_enum< ::com::android::nfc::P2pLinkManagerProto_SendState> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto
