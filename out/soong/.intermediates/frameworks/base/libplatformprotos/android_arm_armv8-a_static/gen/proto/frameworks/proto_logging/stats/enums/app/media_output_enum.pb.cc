// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/app/media_output_enum.proto

#include "frameworks/proto_logging/stats/enums/app/media_output_enum.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
namespace android {
namespace app {
namespace settings {
namespace mediaoutput {
}  // namespace mediaoutput
}  // namespace settings
}  // namespace app
}  // namespace android
namespace android {
namespace app {
namespace settings {
namespace mediaoutput {
bool MediumType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 100:
    case 101:
    case 102:
    case 200:
    case 201:
    case 202:
    case 203:
    case 204:
    case 205:
    case 300:
    case 301:
    case 302:
    case 400:
    case 401:
    case 402:
    case 500:
    case 501:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MediumType_strings[19] = {};

static const char MediumType_names[] =
  "BLUETOOTH"
  "BLUETOOTH_A2DP"
  "BLUETOOTH_HEARING_AID"
  "BUILTIN_SPEAKER"
  "REMOTE_DYNAMIC_GROUP"
  "REMOTE_GROUP"
  "REMOTE_SINGLE"
  "REMOTE_SPEAKER"
  "REMOTE_TV"
  "UNKNOWN_TYPE"
  "USB_C_ACCESSORY"
  "USB_C_AUDIO"
  "USB_C_DEVICE"
  "USB_C_DOCK"
  "USB_C_HDMI"
  "USB_C_HEADSET"
  "WIRED_3POINT5_MM_AUDIO"
  "WIRED_3POINT5_MM_HEADPHONES"
  "WIRED_3POINT5_MM_HEADSET";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MediumType_entries[] = {
  { {MediumType_names + 0, 9}, 300 },
  { {MediumType_names + 9, 14}, 302 },
  { {MediumType_names + 23, 21}, 301 },
  { {MediumType_names + 44, 15}, 1 },
  { {MediumType_names + 59, 20}, 501 },
  { {MediumType_names + 79, 12}, 500 },
  { {MediumType_names + 91, 13}, 400 },
  { {MediumType_names + 104, 14}, 402 },
  { {MediumType_names + 118, 9}, 401 },
  { {MediumType_names + 127, 12}, 0 },
  { {MediumType_names + 139, 15}, 203 },
  { {MediumType_names + 154, 11}, 200 },
  { {MediumType_names + 165, 12}, 201 },
  { {MediumType_names + 177, 10}, 204 },
  { {MediumType_names + 187, 10}, 205 },
  { {MediumType_names + 197, 13}, 202 },
  { {MediumType_names + 210, 22}, 100 },
  { {MediumType_names + 232, 27}, 102 },
  { {MediumType_names + 259, 24}, 101 },
};

static const int MediumType_entries_by_number[] = {
  9, // 0 -> UNKNOWN_TYPE
  3, // 1 -> BUILTIN_SPEAKER
  16, // 100 -> WIRED_3POINT5_MM_AUDIO
  18, // 101 -> WIRED_3POINT5_MM_HEADSET
  17, // 102 -> WIRED_3POINT5_MM_HEADPHONES
  11, // 200 -> USB_C_AUDIO
  12, // 201 -> USB_C_DEVICE
  15, // 202 -> USB_C_HEADSET
  10, // 203 -> USB_C_ACCESSORY
  13, // 204 -> USB_C_DOCK
  14, // 205 -> USB_C_HDMI
  0, // 300 -> BLUETOOTH
  2, // 301 -> BLUETOOTH_HEARING_AID
  1, // 302 -> BLUETOOTH_A2DP
  6, // 400 -> REMOTE_SINGLE
  8, // 401 -> REMOTE_TV
  7, // 402 -> REMOTE_SPEAKER
  5, // 500 -> REMOTE_GROUP
  4, // 501 -> REMOTE_DYNAMIC_GROUP
};

const std::string& MediumType_Name(
    MediumType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MediumType_entries,
          MediumType_entries_by_number,
          19, MediumType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MediumType_entries,
      MediumType_entries_by_number,
      19, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MediumType_strings[idx].get();
}
bool MediumType_Parse(
    const std::string& name, MediumType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MediumType_entries, 19, name, &int_value);
  if (success) {
    *value = static_cast<MediumType>(int_value);
  }
  return success;
}
bool SwitchResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SwitchResult_strings[2] = {};

static const char SwitchResult_names[] =
  "ERROR"
  "OK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SwitchResult_entries[] = {
  { {SwitchResult_names + 0, 5}, 0 },
  { {SwitchResult_names + 5, 2}, 1 },
};

static const int SwitchResult_entries_by_number[] = {
  0, // 0 -> ERROR
  1, // 1 -> OK
};

const std::string& SwitchResult_Name(
    SwitchResult value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SwitchResult_entries,
          SwitchResult_entries_by_number,
          2, SwitchResult_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SwitchResult_entries,
      SwitchResult_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SwitchResult_strings[idx].get();
}
bool SwitchResult_Parse(
    const std::string& name, SwitchResult* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SwitchResult_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<SwitchResult>(int_value);
  }
  return success;
}
bool SubResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SubResult_strings[6] = {};

static const char SubResult_names[] =
  "INVALID_COMMAND"
  "NETWORK_ERROR"
  "NO_ERROR"
  "REJECTED"
  "ROUTE_NOT_AVAILABLE"
  "UNKNOWN_ERROR";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SubResult_entries[] = {
  { {SubResult_names + 0, 15}, 5 },
  { {SubResult_names + 15, 13}, 3 },
  { {SubResult_names + 28, 8}, 1 },
  { {SubResult_names + 36, 8}, 2 },
  { {SubResult_names + 44, 19}, 4 },
  { {SubResult_names + 63, 13}, 0 },
};

static const int SubResult_entries_by_number[] = {
  5, // 0 -> UNKNOWN_ERROR
  2, // 1 -> NO_ERROR
  3, // 2 -> REJECTED
  1, // 3 -> NETWORK_ERROR
  4, // 4 -> ROUTE_NOT_AVAILABLE
  0, // 5 -> INVALID_COMMAND
};

const std::string& SubResult_Name(
    SubResult value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SubResult_entries,
          SubResult_entries_by_number,
          6, SubResult_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SubResult_entries,
      SubResult_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SubResult_strings[idx].get();
}
bool SubResult_Parse(
    const std::string& name, SubResult* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SubResult_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<SubResult>(int_value);
  }
  return success;
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace mediaoutput
}  // namespace settings
}  // namespace app
}  // namespace android
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
