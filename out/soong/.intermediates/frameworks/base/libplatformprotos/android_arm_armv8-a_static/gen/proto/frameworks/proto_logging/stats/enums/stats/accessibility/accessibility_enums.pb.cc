// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/stats/accessibility/accessibility_enums.proto

#include "frameworks/proto_logging/stats/enums/stats/accessibility/accessibility_enums.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
namespace android {
namespace stats {
namespace accessibility {
}  // namespace accessibility
}  // namespace stats
}  // namespace android
namespace android {
namespace stats {
namespace accessibility {
bool ShortcutType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ShortcutType_strings[7] = {};

static const char ShortcutType_names[] =
  "A11Y_BUTTON"
  "A11Y_BUTTON_LONG_PRESS"
  "A11Y_FLOATING_MENU"
  "A11Y_GESTURE"
  "TRIPLE_TAP"
  "UNKNOWN_TYPE"
  "VOLUME_KEY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ShortcutType_entries[] = {
  { {ShortcutType_names + 0, 11}, 1 },
  { {ShortcutType_names + 11, 22}, 4 },
  { {ShortcutType_names + 33, 18}, 5 },
  { {ShortcutType_names + 51, 12}, 6 },
  { {ShortcutType_names + 63, 10}, 3 },
  { {ShortcutType_names + 73, 12}, 0 },
  { {ShortcutType_names + 85, 10}, 2 },
};

static const int ShortcutType_entries_by_number[] = {
  5, // 0 -> UNKNOWN_TYPE
  0, // 1 -> A11Y_BUTTON
  6, // 2 -> VOLUME_KEY
  4, // 3 -> TRIPLE_TAP
  1, // 4 -> A11Y_BUTTON_LONG_PRESS
  2, // 5 -> A11Y_FLOATING_MENU
  3, // 6 -> A11Y_GESTURE
};

const std::string& ShortcutType_Name(
    ShortcutType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ShortcutType_entries,
          ShortcutType_entries_by_number,
          7, ShortcutType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ShortcutType_entries,
      ShortcutType_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ShortcutType_strings[idx].get();
}
bool ShortcutType_Parse(
    const std::string& name, ShortcutType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ShortcutType_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<ShortcutType>(int_value);
  }
  return success;
}
bool ServiceStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServiceStatus_strings[3] = {};

static const char ServiceStatus_names[] =
  "DISABLED"
  "ENABLED"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServiceStatus_entries[] = {
  { {ServiceStatus_names + 0, 8}, 2 },
  { {ServiceStatus_names + 8, 7}, 1 },
  { {ServiceStatus_names + 15, 7}, 0 },
};

static const int ServiceStatus_entries_by_number[] = {
  2, // 0 -> UNKNOWN
  1, // 1 -> ENABLED
  0, // 2 -> DISABLED
};

const std::string& ServiceStatus_Name(
    ServiceStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ServiceStatus_entries,
          ServiceStatus_entries_by_number,
          3, ServiceStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ServiceStatus_entries,
      ServiceStatus_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ServiceStatus_strings[idx].get();
}
bool ServiceStatus_Parse(
    const std::string& name, ServiceStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ServiceStatus_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ServiceStatus>(int_value);
  }
  return success;
}
bool MagnificationMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MagnificationMode_strings[4] = {};

static const char MagnificationMode_names[] =
  "MAGNIFICATION_ALL"
  "MAGNIFICATION_FULL_SCREEN"
  "MAGNIFICATION_UNKNOWN_MODE"
  "MAGNIFICATION_WINDOW";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MagnificationMode_entries[] = {
  { {MagnificationMode_names + 0, 17}, 3 },
  { {MagnificationMode_names + 17, 25}, 1 },
  { {MagnificationMode_names + 42, 26}, 0 },
  { {MagnificationMode_names + 68, 20}, 2 },
};

static const int MagnificationMode_entries_by_number[] = {
  2, // 0 -> MAGNIFICATION_UNKNOWN_MODE
  1, // 1 -> MAGNIFICATION_FULL_SCREEN
  3, // 2 -> MAGNIFICATION_WINDOW
  0, // 3 -> MAGNIFICATION_ALL
};

const std::string& MagnificationMode_Name(
    MagnificationMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MagnificationMode_entries,
          MagnificationMode_entries_by_number,
          4, MagnificationMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MagnificationMode_entries,
      MagnificationMode_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MagnificationMode_strings[idx].get();
}
bool MagnificationMode_Parse(
    const std::string& name, MagnificationMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MagnificationMode_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<MagnificationMode>(int_value);
  }
  return success;
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace accessibility
}  // namespace stats
}  // namespace android
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
