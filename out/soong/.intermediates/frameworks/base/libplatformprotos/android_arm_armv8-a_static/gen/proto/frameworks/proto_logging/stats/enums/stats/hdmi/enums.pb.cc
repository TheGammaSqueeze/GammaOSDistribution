// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/stats/hdmi/enums.proto

#include "frameworks/proto_logging/stats/enums/stats/hdmi/enums.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
namespace android {
namespace stats {
namespace hdmi {
}  // namespace hdmi
}  // namespace stats
}  // namespace android
namespace android {
namespace stats {
namespace hdmi {
bool LogicalAddress_IsValid(int value) {
  switch (value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LogicalAddress_strings[17] = {};

static const char LogicalAddress_names[] =
  "AUDIO_SYSTEM"
  "LOGICAL_ADDRESS_UNKNOWN"
  "PLAYBACK_DEVICE_1"
  "PLAYBACK_DEVICE_2"
  "PLAYBACK_DEVICE_3"
  "RECORDING_DEVICE_1"
  "RECORDING_DEVICE_2"
  "RECORDING_DEVICE_3"
  "RESERVED_1"
  "RESERVED_2"
  "SPECIFIC_USE"
  "TUNER_1"
  "TUNER_2"
  "TUNER_3"
  "TUNER_4"
  "TV"
  "UNREGISTERED_OR_BROADCAST";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LogicalAddress_entries[] = {
  { {LogicalAddress_names + 0, 12}, 5 },
  { {LogicalAddress_names + 12, 23}, -1 },
  { {LogicalAddress_names + 35, 17}, 4 },
  { {LogicalAddress_names + 52, 17}, 8 },
  { {LogicalAddress_names + 69, 17}, 11 },
  { {LogicalAddress_names + 86, 18}, 1 },
  { {LogicalAddress_names + 104, 18}, 2 },
  { {LogicalAddress_names + 122, 18}, 9 },
  { {LogicalAddress_names + 140, 10}, 12 },
  { {LogicalAddress_names + 150, 10}, 13 },
  { {LogicalAddress_names + 160, 12}, 14 },
  { {LogicalAddress_names + 172, 7}, 3 },
  { {LogicalAddress_names + 179, 7}, 6 },
  { {LogicalAddress_names + 186, 7}, 7 },
  { {LogicalAddress_names + 193, 7}, 10 },
  { {LogicalAddress_names + 200, 2}, 0 },
  { {LogicalAddress_names + 202, 25}, 15 },
};

static const int LogicalAddress_entries_by_number[] = {
  1, // -1 -> LOGICAL_ADDRESS_UNKNOWN
  15, // 0 -> TV
  5, // 1 -> RECORDING_DEVICE_1
  6, // 2 -> RECORDING_DEVICE_2
  11, // 3 -> TUNER_1
  2, // 4 -> PLAYBACK_DEVICE_1
  0, // 5 -> AUDIO_SYSTEM
  12, // 6 -> TUNER_2
  13, // 7 -> TUNER_3
  3, // 8 -> PLAYBACK_DEVICE_2
  7, // 9 -> RECORDING_DEVICE_3
  14, // 10 -> TUNER_4
  4, // 11 -> PLAYBACK_DEVICE_3
  8, // 12 -> RESERVED_1
  9, // 13 -> RESERVED_2
  10, // 14 -> SPECIFIC_USE
  16, // 15 -> UNREGISTERED_OR_BROADCAST
};

const std::string& LogicalAddress_Name(
    LogicalAddress value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LogicalAddress_entries,
          LogicalAddress_entries_by_number,
          17, LogicalAddress_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LogicalAddress_entries,
      LogicalAddress_entries_by_number,
      17, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LogicalAddress_strings[idx].get();
}
bool LogicalAddress_Parse(
    const std::string& name, LogicalAddress* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LogicalAddress_entries, 17, name, &int_value);
  if (success) {
    *value = static_cast<LogicalAddress>(int_value);
  }
  return success;
}
bool PathRelationship_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PathRelationship_strings[6] = {};

static const char PathRelationship_names[] =
  "ANCESTOR"
  "DESCENDANT"
  "DIFFERENT_BRANCH"
  "RELATIONSHIP_TO_ACTIVE_SOURCE_UNKNOWN"
  "SAME"
  "SIBLING";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PathRelationship_entries[] = {
  { {PathRelationship_names + 0, 8}, 2 },
  { {PathRelationship_names + 8, 10}, 3 },
  { {PathRelationship_names + 18, 16}, 1 },
  { {PathRelationship_names + 34, 37}, 0 },
  { {PathRelationship_names + 71, 4}, 5 },
  { {PathRelationship_names + 75, 7}, 4 },
};

static const int PathRelationship_entries_by_number[] = {
  3, // 0 -> RELATIONSHIP_TO_ACTIVE_SOURCE_UNKNOWN
  2, // 1 -> DIFFERENT_BRANCH
  0, // 2 -> ANCESTOR
  1, // 3 -> DESCENDANT
  5, // 4 -> SIBLING
  4, // 5 -> SAME
};

const std::string& PathRelationship_Name(
    PathRelationship value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PathRelationship_entries,
          PathRelationship_entries_by_number,
          6, PathRelationship_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PathRelationship_entries,
      PathRelationship_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PathRelationship_strings[idx].get();
}
bool PathRelationship_Parse(
    const std::string& name, PathRelationship* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PathRelationship_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<PathRelationship>(int_value);
  }
  return success;
}
bool SendMessageResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 10:
    case 11:
    case 12:
    case 13:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SendMessageResult_strings[5] = {};

static const char SendMessageResult_names[] =
  "BUSY"
  "FAIL"
  "NACK"
  "SEND_MESSAGE_RESULT_UNKNOWN"
  "SUCCESS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SendMessageResult_entries[] = {
  { {SendMessageResult_names + 0, 4}, 12 },
  { {SendMessageResult_names + 4, 4}, 13 },
  { {SendMessageResult_names + 8, 4}, 11 },
  { {SendMessageResult_names + 12, 27}, 0 },
  { {SendMessageResult_names + 39, 7}, 10 },
};

static const int SendMessageResult_entries_by_number[] = {
  3, // 0 -> SEND_MESSAGE_RESULT_UNKNOWN
  4, // 10 -> SUCCESS
  2, // 11 -> NACK
  0, // 12 -> BUSY
  1, // 13 -> FAIL
};

const std::string& SendMessageResult_Name(
    SendMessageResult value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SendMessageResult_entries,
          SendMessageResult_entries_by_number,
          5, SendMessageResult_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SendMessageResult_entries,
      SendMessageResult_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SendMessageResult_strings[idx].get();
}
bool SendMessageResult_Parse(
    const std::string& name, SendMessageResult* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SendMessageResult_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<SendMessageResult>(int_value);
  }
  return success;
}
bool MessageDirection_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MessageDirection_strings[5] = {};

static const char MessageDirection_names[] =
  "INCOMING"
  "MESSAGE_DIRECTION_OTHER"
  "MESSAGE_DIRECTION_UNKNOWN"
  "OUTGOING"
  "TO_SELF";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MessageDirection_entries[] = {
  { {MessageDirection_names + 0, 8}, 3 },
  { {MessageDirection_names + 8, 23}, 1 },
  { {MessageDirection_names + 31, 25}, 0 },
  { {MessageDirection_names + 56, 8}, 2 },
  { {MessageDirection_names + 64, 7}, 4 },
};

static const int MessageDirection_entries_by_number[] = {
  2, // 0 -> MESSAGE_DIRECTION_UNKNOWN
  1, // 1 -> MESSAGE_DIRECTION_OTHER
  3, // 2 -> OUTGOING
  0, // 3 -> INCOMING
  4, // 4 -> TO_SELF
};

const std::string& MessageDirection_Name(
    MessageDirection value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MessageDirection_entries,
          MessageDirection_entries_by_number,
          5, MessageDirection_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MessageDirection_entries,
      MessageDirection_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MessageDirection_strings[idx].get();
}
bool MessageDirection_Parse(
    const std::string& name, MessageDirection* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MessageDirection_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<MessageDirection>(int_value);
  }
  return success;
}
bool UserControlPressedCommand_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 256:
    case 257:
    case 258:
    case 259:
    case 260:
    case 261:
    case 262:
    case 263:
    case 264:
    case 269:
    case 320:
    case 321:
    case 322:
    case 323:
    case 363:
    case 364:
    case 365:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UserControlPressedCommand_strings[20] = {};

static const char UserControlPressedCommand_names[] =
  "DOWN"
  "EXIT"
  "LEFT"
  "LEFT_DOWN"
  "LEFT_UP"
  "NUMBER"
  "POWER"
  "POWER_OFF"
  "POWER_ON"
  "POWER_TOGGLE"
  "RIGHT"
  "RIGHT_DOWN"
  "RIGHT_UP"
  "SELECT"
  "UP"
  "USER_CONTROL_PRESSED_COMMAND_OTHER"
  "USER_CONTROL_PRESSED_COMMAND_UNKNOWN"
  "VOLUME_DOWN"
  "VOLUME_MUTE"
  "VOLUME_UP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UserControlPressedCommand_entries[] = {
  { {UserControlPressedCommand_names + 0, 4}, 258 },
  { {UserControlPressedCommand_names + 4, 4}, 269 },
  { {UserControlPressedCommand_names + 8, 4}, 259 },
  { {UserControlPressedCommand_names + 12, 9}, 264 },
  { {UserControlPressedCommand_names + 21, 7}, 263 },
  { {UserControlPressedCommand_names + 28, 6}, 2 },
  { {UserControlPressedCommand_names + 34, 5}, 320 },
  { {UserControlPressedCommand_names + 39, 9}, 364 },
  { {UserControlPressedCommand_names + 48, 8}, 365 },
  { {UserControlPressedCommand_names + 56, 12}, 363 },
  { {UserControlPressedCommand_names + 68, 5}, 260 },
  { {UserControlPressedCommand_names + 73, 10}, 262 },
  { {UserControlPressedCommand_names + 83, 8}, 261 },
  { {UserControlPressedCommand_names + 91, 6}, 256 },
  { {UserControlPressedCommand_names + 97, 2}, 257 },
  { {UserControlPressedCommand_names + 99, 34}, 1 },
  { {UserControlPressedCommand_names + 133, 36}, 0 },
  { {UserControlPressedCommand_names + 169, 11}, 322 },
  { {UserControlPressedCommand_names + 180, 11}, 323 },
  { {UserControlPressedCommand_names + 191, 9}, 321 },
};

static const int UserControlPressedCommand_entries_by_number[] = {
  16, // 0 -> USER_CONTROL_PRESSED_COMMAND_UNKNOWN
  15, // 1 -> USER_CONTROL_PRESSED_COMMAND_OTHER
  5, // 2 -> NUMBER
  13, // 256 -> SELECT
  14, // 257 -> UP
  0, // 258 -> DOWN
  2, // 259 -> LEFT
  10, // 260 -> RIGHT
  12, // 261 -> RIGHT_UP
  11, // 262 -> RIGHT_DOWN
  4, // 263 -> LEFT_UP
  3, // 264 -> LEFT_DOWN
  1, // 269 -> EXIT
  6, // 320 -> POWER
  19, // 321 -> VOLUME_UP
  17, // 322 -> VOLUME_DOWN
  18, // 323 -> VOLUME_MUTE
  9, // 363 -> POWER_TOGGLE
  7, // 364 -> POWER_OFF
  8, // 365 -> POWER_ON
};

const std::string& UserControlPressedCommand_Name(
    UserControlPressedCommand value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UserControlPressedCommand_entries,
          UserControlPressedCommand_entries_by_number,
          20, UserControlPressedCommand_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UserControlPressedCommand_entries,
      UserControlPressedCommand_entries_by_number,
      20, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UserControlPressedCommand_strings[idx].get();
}
bool UserControlPressedCommand_Parse(
    const std::string& name, UserControlPressedCommand* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UserControlPressedCommand_entries, 20, name, &int_value);
  if (success) {
    *value = static_cast<UserControlPressedCommand>(int_value);
  }
  return success;
}
bool FeatureAbortReason_IsValid(int value) {
  switch (value) {
    case 0:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FeatureAbortReason_strings[7] = {};

static const char FeatureAbortReason_names[] =
  "CANNOT_PROVIDE_SOURCE"
  "FEATURE_ABORT_REASON_UNKNOWN"
  "INVALID_OPERAND"
  "NOT_IN_CORRECT_MODE_TO_RESPOND"
  "REFUSED"
  "UNABLE_TO_DETERMINE"
  "UNRECOGNIZED_OPCODE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FeatureAbortReason_entries[] = {
  { {FeatureAbortReason_names + 0, 21}, 12 },
  { {FeatureAbortReason_names + 21, 28}, 0 },
  { {FeatureAbortReason_names + 49, 15}, 13 },
  { {FeatureAbortReason_names + 64, 30}, 11 },
  { {FeatureAbortReason_names + 94, 7}, 14 },
  { {FeatureAbortReason_names + 101, 19}, 15 },
  { {FeatureAbortReason_names + 120, 19}, 10 },
};

static const int FeatureAbortReason_entries_by_number[] = {
  1, // 0 -> FEATURE_ABORT_REASON_UNKNOWN
  6, // 10 -> UNRECOGNIZED_OPCODE
  3, // 11 -> NOT_IN_CORRECT_MODE_TO_RESPOND
  0, // 12 -> CANNOT_PROVIDE_SOURCE
  2, // 13 -> INVALID_OPERAND
  4, // 14 -> REFUSED
  5, // 15 -> UNABLE_TO_DETERMINE
};

const std::string& FeatureAbortReason_Name(
    FeatureAbortReason value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FeatureAbortReason_entries,
          FeatureAbortReason_entries_by_number,
          7, FeatureAbortReason_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FeatureAbortReason_entries,
      FeatureAbortReason_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FeatureAbortReason_strings[idx].get();
}
bool FeatureAbortReason_Parse(
    const std::string& name, FeatureAbortReason* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FeatureAbortReason_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<FeatureAbortReason>(int_value);
  }
  return success;
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace hdmi
}  // namespace stats
}  // namespace android
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
