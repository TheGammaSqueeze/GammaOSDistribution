// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/stats/location/location_enums.proto

#include "frameworks/proto_logging/stats/enums/stats/location/location_enums.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
namespace android {
namespace stats {
namespace location {
}  // namespace location
}  // namespace stats
}  // namespace android
namespace android {
namespace stats {
namespace location {
bool LocationManagerServiceApi_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LocationManagerServiceApi_strings[6] = {};

static const char LocationManagerServiceApi_names[] =
  "API_ADD_GNSS_MEASUREMENTS_LISTENER"
  "API_REGISTER_GNSS_STATUS_CALLBACK"
  "API_REQUEST_GEOFENCE"
  "API_REQUEST_LOCATION_UPDATES"
  "API_SEND_EXTRA_COMMAND"
  "API_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LocationManagerServiceApi_entries[] = {
  { {LocationManagerServiceApi_names + 0, 34}, 2 },
  { {LocationManagerServiceApi_names + 34, 33}, 3 },
  { {LocationManagerServiceApi_names + 67, 20}, 4 },
  { {LocationManagerServiceApi_names + 87, 28}, 1 },
  { {LocationManagerServiceApi_names + 115, 22}, 5 },
  { {LocationManagerServiceApi_names + 137, 11}, 0 },
};

static const int LocationManagerServiceApi_entries_by_number[] = {
  5, // 0 -> API_UNKNOWN
  3, // 1 -> API_REQUEST_LOCATION_UPDATES
  0, // 2 -> API_ADD_GNSS_MEASUREMENTS_LISTENER
  1, // 3 -> API_REGISTER_GNSS_STATUS_CALLBACK
  2, // 4 -> API_REQUEST_GEOFENCE
  4, // 5 -> API_SEND_EXTRA_COMMAND
};

const std::string& LocationManagerServiceApi_Name(
    LocationManagerServiceApi value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LocationManagerServiceApi_entries,
          LocationManagerServiceApi_entries_by_number,
          6, LocationManagerServiceApi_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LocationManagerServiceApi_entries,
      LocationManagerServiceApi_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LocationManagerServiceApi_strings[idx].get();
}
bool LocationManagerServiceApi_Parse(
    const std::string& name, LocationManagerServiceApi* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LocationManagerServiceApi_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<LocationManagerServiceApi>(int_value);
  }
  return success;
}
bool UsageState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UsageState_strings[2] = {};

static const char UsageState_names[] =
  "USAGE_ENDED"
  "USAGE_STARTED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UsageState_entries[] = {
  { {UsageState_names + 0, 11}, 1 },
  { {UsageState_names + 11, 13}, 0 },
};

static const int UsageState_entries_by_number[] = {
  1, // 0 -> USAGE_STARTED
  0, // 1 -> USAGE_ENDED
};

const std::string& UsageState_Name(
    UsageState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UsageState_entries,
          UsageState_entries_by_number,
          2, UsageState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UsageState_entries,
      UsageState_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UsageState_strings[idx].get();
}
bool UsageState_Parse(
    const std::string& name, UsageState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UsageState_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<UsageState>(int_value);
  }
  return success;
}
bool ProviderType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ProviderType_strings[5] = {};

static const char ProviderType_names[] =
  "PROVIDER_FUSED"
  "PROVIDER_GPS"
  "PROVIDER_NETWORK"
  "PROVIDER_PASSIVE"
  "PROVIDER_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ProviderType_entries[] = {
  { {ProviderType_names + 0, 14}, 4 },
  { {ProviderType_names + 14, 12}, 2 },
  { {ProviderType_names + 26, 16}, 1 },
  { {ProviderType_names + 42, 16}, 3 },
  { {ProviderType_names + 58, 16}, 0 },
};

static const int ProviderType_entries_by_number[] = {
  4, // 0 -> PROVIDER_UNKNOWN
  2, // 1 -> PROVIDER_NETWORK
  1, // 2 -> PROVIDER_GPS
  3, // 3 -> PROVIDER_PASSIVE
  0, // 4 -> PROVIDER_FUSED
};

const std::string& ProviderType_Name(
    ProviderType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ProviderType_entries,
          ProviderType_entries_by_number,
          5, ProviderType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ProviderType_entries,
      ProviderType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ProviderType_strings[idx].get();
}
bool ProviderType_Parse(
    const std::string& name, ProviderType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ProviderType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<ProviderType>(int_value);
  }
  return success;
}
bool CallbackType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CallbackType_strings[4] = {};

static const char CallbackType_names[] =
  "CALLBACK_LISTENER"
  "CALLBACK_NOT_APPLICABLE"
  "CALLBACK_PENDING_INTENT"
  "CALLBACK_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CallbackType_entries[] = {
  { {CallbackType_names + 0, 17}, 2 },
  { {CallbackType_names + 17, 23}, 1 },
  { {CallbackType_names + 40, 23}, 3 },
  { {CallbackType_names + 63, 16}, 0 },
};

static const int CallbackType_entries_by_number[] = {
  3, // 0 -> CALLBACK_UNKNOWN
  1, // 1 -> CALLBACK_NOT_APPLICABLE
  0, // 2 -> CALLBACK_LISTENER
  2, // 3 -> CALLBACK_PENDING_INTENT
};

const std::string& CallbackType_Name(
    CallbackType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CallbackType_entries,
          CallbackType_entries_by_number,
          4, CallbackType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CallbackType_entries,
      CallbackType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CallbackType_strings[idx].get();
}
bool CallbackType_Parse(
    const std::string& name, CallbackType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CallbackType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<CallbackType>(int_value);
  }
  return success;
}
bool LocationRequestQuality_IsValid(int value) {
  switch (value) {
    case 0:
    case 100:
    case 102:
    case 104:
    case 200:
    case 201:
    case 203:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LocationRequestQuality_strings[7] = {};

static const char LocationRequestQuality_names[] =
  "ACCURACY_BLOCK"
  "ACCURACY_CITY"
  "ACCURACY_FINE"
  "POWER_HIGH"
  "POWER_LOW"
  "POWER_NONE"
  "QUALITY_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LocationRequestQuality_entries[] = {
  { {LocationRequestQuality_names + 0, 14}, 102 },
  { {LocationRequestQuality_names + 14, 13}, 104 },
  { {LocationRequestQuality_names + 27, 13}, 100 },
  { {LocationRequestQuality_names + 40, 10}, 203 },
  { {LocationRequestQuality_names + 50, 9}, 201 },
  { {LocationRequestQuality_names + 59, 10}, 200 },
  { {LocationRequestQuality_names + 69, 15}, 0 },
};

static const int LocationRequestQuality_entries_by_number[] = {
  6, // 0 -> QUALITY_UNKNOWN
  2, // 100 -> ACCURACY_FINE
  0, // 102 -> ACCURACY_BLOCK
  1, // 104 -> ACCURACY_CITY
  5, // 200 -> POWER_NONE
  4, // 201 -> POWER_LOW
  3, // 203 -> POWER_HIGH
};

const std::string& LocationRequestQuality_Name(
    LocationRequestQuality value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LocationRequestQuality_entries,
          LocationRequestQuality_entries_by_number,
          7, LocationRequestQuality_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LocationRequestQuality_entries,
      LocationRequestQuality_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LocationRequestQuality_strings[idx].get();
}
bool LocationRequestQuality_Parse(
    const std::string& name, LocationRequestQuality* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LocationRequestQuality_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<LocationRequestQuality>(int_value);
  }
  return success;
}
bool LocationRequestIntervalBucket_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LocationRequestIntervalBucket_strings[7] = {};

static const char LocationRequestIntervalBucket_names[] =
  "INTERVAL_BETWEEN_0_SEC_AND_1_SEC"
  "INTERVAL_BETWEEN_10_MIN_AND_1_HOUR"
  "INTERVAL_BETWEEN_1_MIN_AND_10_MIN"
  "INTERVAL_BETWEEN_1_SEC_AND_5_SEC"
  "INTERVAL_BETWEEN_5_SEC_AND_1_MIN"
  "INTERVAL_LARGER_THAN_1_HOUR"
  "INTERVAL_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LocationRequestIntervalBucket_entries[] = {
  { {LocationRequestIntervalBucket_names + 0, 32}, 1 },
  { {LocationRequestIntervalBucket_names + 32, 34}, 5 },
  { {LocationRequestIntervalBucket_names + 66, 33}, 4 },
  { {LocationRequestIntervalBucket_names + 99, 32}, 2 },
  { {LocationRequestIntervalBucket_names + 131, 32}, 3 },
  { {LocationRequestIntervalBucket_names + 163, 27}, 6 },
  { {LocationRequestIntervalBucket_names + 190, 16}, 0 },
};

static const int LocationRequestIntervalBucket_entries_by_number[] = {
  6, // 0 -> INTERVAL_UNKNOWN
  0, // 1 -> INTERVAL_BETWEEN_0_SEC_AND_1_SEC
  3, // 2 -> INTERVAL_BETWEEN_1_SEC_AND_5_SEC
  4, // 3 -> INTERVAL_BETWEEN_5_SEC_AND_1_MIN
  2, // 4 -> INTERVAL_BETWEEN_1_MIN_AND_10_MIN
  1, // 5 -> INTERVAL_BETWEEN_10_MIN_AND_1_HOUR
  5, // 6 -> INTERVAL_LARGER_THAN_1_HOUR
};

const std::string& LocationRequestIntervalBucket_Name(
    LocationRequestIntervalBucket value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LocationRequestIntervalBucket_entries,
          LocationRequestIntervalBucket_entries_by_number,
          7, LocationRequestIntervalBucket_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LocationRequestIntervalBucket_entries,
      LocationRequestIntervalBucket_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LocationRequestIntervalBucket_strings[idx].get();
}
bool LocationRequestIntervalBucket_Parse(
    const std::string& name, LocationRequestIntervalBucket* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LocationRequestIntervalBucket_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<LocationRequestIntervalBucket>(int_value);
  }
  return success;
}
bool SmallestDisplacementBucket_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SmallestDisplacementBucket_strings[4] = {};

static const char SmallestDisplacementBucket_names[] =
  "DISTANCE_BETWEEN_0_AND_100"
  "DISTANCE_LARGER_THAN_100"
  "DISTANCE_UNKNOWN"
  "DISTANCE_ZERO";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SmallestDisplacementBucket_entries[] = {
  { {SmallestDisplacementBucket_names + 0, 26}, 2 },
  { {SmallestDisplacementBucket_names + 26, 24}, 3 },
  { {SmallestDisplacementBucket_names + 50, 16}, 0 },
  { {SmallestDisplacementBucket_names + 66, 13}, 1 },
};

static const int SmallestDisplacementBucket_entries_by_number[] = {
  2, // 0 -> DISTANCE_UNKNOWN
  3, // 1 -> DISTANCE_ZERO
  0, // 2 -> DISTANCE_BETWEEN_0_AND_100
  1, // 3 -> DISTANCE_LARGER_THAN_100
};

const std::string& SmallestDisplacementBucket_Name(
    SmallestDisplacementBucket value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SmallestDisplacementBucket_entries,
          SmallestDisplacementBucket_entries_by_number,
          4, SmallestDisplacementBucket_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SmallestDisplacementBucket_entries,
      SmallestDisplacementBucket_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SmallestDisplacementBucket_strings[idx].get();
}
bool SmallestDisplacementBucket_Parse(
    const std::string& name, SmallestDisplacementBucket* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SmallestDisplacementBucket_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<SmallestDisplacementBucket>(int_value);
  }
  return success;
}
bool ExpirationBucket_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ExpirationBucket_strings[7] = {};

static const char ExpirationBucket_names[] =
  "EXPIRATION_BETWEEN_0_AND_20_SEC"
  "EXPIRATION_BETWEEN_10_MIN_AND_1_HOUR"
  "EXPIRATION_BETWEEN_1_MIN_AND_10_MIN"
  "EXPIRATION_BETWEEN_20_SEC_AND_1_MIN"
  "EXPIRATION_LARGER_THAN_1_HOUR"
  "EXPIRATION_NO_EXPIRY"
  "EXPIRATION_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExpirationBucket_entries[] = {
  { {ExpirationBucket_names + 0, 31}, 1 },
  { {ExpirationBucket_names + 31, 36}, 4 },
  { {ExpirationBucket_names + 67, 35}, 3 },
  { {ExpirationBucket_names + 102, 35}, 2 },
  { {ExpirationBucket_names + 137, 29}, 5 },
  { {ExpirationBucket_names + 166, 20}, 6 },
  { {ExpirationBucket_names + 186, 18}, 0 },
};

static const int ExpirationBucket_entries_by_number[] = {
  6, // 0 -> EXPIRATION_UNKNOWN
  0, // 1 -> EXPIRATION_BETWEEN_0_AND_20_SEC
  3, // 2 -> EXPIRATION_BETWEEN_20_SEC_AND_1_MIN
  2, // 3 -> EXPIRATION_BETWEEN_1_MIN_AND_10_MIN
  1, // 4 -> EXPIRATION_BETWEEN_10_MIN_AND_1_HOUR
  4, // 5 -> EXPIRATION_LARGER_THAN_1_HOUR
  5, // 6 -> EXPIRATION_NO_EXPIRY
};

const std::string& ExpirationBucket_Name(
    ExpirationBucket value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ExpirationBucket_entries,
          ExpirationBucket_entries_by_number,
          7, ExpirationBucket_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ExpirationBucket_entries,
      ExpirationBucket_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ExpirationBucket_strings[idx].get();
}
bool ExpirationBucket_Parse(
    const std::string& name, ExpirationBucket* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ExpirationBucket_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<ExpirationBucket>(int_value);
  }
  return success;
}
bool GeofenceRadiusBucket_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GeofenceRadiusBucket_strings[8] = {};

static const char GeofenceRadiusBucket_names[] =
  "RADIUS_BETWEEN_0_AND_100"
  "RADIUS_BETWEEN_1000_AND_10000"
  "RADIUS_BETWEEN_100_AND_200"
  "RADIUS_BETWEEN_200_AND_300"
  "RADIUS_BETWEEN_300_AND_1000"
  "RADIUS_LARGER_THAN_100000"
  "RADIUS_NEGATIVE"
  "RADIUS_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GeofenceRadiusBucket_entries[] = {
  { {GeofenceRadiusBucket_names + 0, 24}, 1 },
  { {GeofenceRadiusBucket_names + 24, 29}, 5 },
  { {GeofenceRadiusBucket_names + 53, 26}, 2 },
  { {GeofenceRadiusBucket_names + 79, 26}, 3 },
  { {GeofenceRadiusBucket_names + 105, 27}, 4 },
  { {GeofenceRadiusBucket_names + 132, 25}, 6 },
  { {GeofenceRadiusBucket_names + 157, 15}, 7 },
  { {GeofenceRadiusBucket_names + 172, 14}, 0 },
};

static const int GeofenceRadiusBucket_entries_by_number[] = {
  7, // 0 -> RADIUS_UNKNOWN
  0, // 1 -> RADIUS_BETWEEN_0_AND_100
  2, // 2 -> RADIUS_BETWEEN_100_AND_200
  3, // 3 -> RADIUS_BETWEEN_200_AND_300
  4, // 4 -> RADIUS_BETWEEN_300_AND_1000
  1, // 5 -> RADIUS_BETWEEN_1000_AND_10000
  5, // 6 -> RADIUS_LARGER_THAN_100000
  6, // 7 -> RADIUS_NEGATIVE
};

const std::string& GeofenceRadiusBucket_Name(
    GeofenceRadiusBucket value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GeofenceRadiusBucket_entries,
          GeofenceRadiusBucket_entries_by_number,
          8, GeofenceRadiusBucket_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GeofenceRadiusBucket_entries,
      GeofenceRadiusBucket_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GeofenceRadiusBucket_strings[idx].get();
}
bool GeofenceRadiusBucket_Parse(
    const std::string& name, GeofenceRadiusBucket* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GeofenceRadiusBucket_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<GeofenceRadiusBucket>(int_value);
  }
  return success;
}
bool ActivityImportance_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ActivityImportance_strings[4] = {};

static const char ActivityImportance_names[] =
  "IMPORTANCE_BACKGROUND"
  "IMPORTANCE_FORGROUND_SERVICE"
  "IMPORTANCE_TOP"
  "IMPORTANCE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ActivityImportance_entries[] = {
  { {ActivityImportance_names + 0, 21}, 3 },
  { {ActivityImportance_names + 21, 28}, 2 },
  { {ActivityImportance_names + 49, 14}, 1 },
  { {ActivityImportance_names + 63, 18}, 0 },
};

static const int ActivityImportance_entries_by_number[] = {
  3, // 0 -> IMPORTANCE_UNKNOWN
  2, // 1 -> IMPORTANCE_TOP
  1, // 2 -> IMPORTANCE_FORGROUND_SERVICE
  0, // 3 -> IMPORTANCE_BACKGROUND
};

const std::string& ActivityImportance_Name(
    ActivityImportance value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ActivityImportance_entries,
          ActivityImportance_entries_by_number,
          4, ActivityImportance_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ActivityImportance_entries,
      ActivityImportance_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ActivityImportance_strings[idx].get();
}
bool ActivityImportance_Parse(
    const std::string& name, ActivityImportance* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ActivityImportance_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ActivityImportance>(int_value);
  }
  return success;
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace location
}  // namespace stats
}  // namespace android
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
