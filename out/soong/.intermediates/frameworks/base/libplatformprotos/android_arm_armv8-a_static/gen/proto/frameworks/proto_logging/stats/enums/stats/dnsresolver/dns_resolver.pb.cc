// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/stats/dnsresolver/dns_resolver.proto

#include "frameworks/proto_logging/stats/enums/stats/dnsresolver/dns_resolver.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fdnsresolver_2fdns_5fresolver_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DnsQueryEvent_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fdnsresolver_2fdns_5fresolver_2eproto;
namespace android {
namespace stats {
namespace dnsresolver {
class DnsQueryEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DnsQueryEvent> _instance;
} _DnsQueryEvent_default_instance_;
class DnsQueryEventsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DnsQueryEvents> _instance;
} _DnsQueryEvents_default_instance_;
}  // namespace dnsresolver
}  // namespace stats
}  // namespace android
static void InitDefaultsscc_info_DnsQueryEvent_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fdnsresolver_2fdns_5fresolver_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::stats::dnsresolver::_DnsQueryEvent_default_instance_;
    new (ptr) ::android::stats::dnsresolver::DnsQueryEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::stats::dnsresolver::DnsQueryEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DnsQueryEvent_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fdnsresolver_2fdns_5fresolver_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_DnsQueryEvent_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fdnsresolver_2fdns_5fresolver_2eproto}, {}};

static void InitDefaultsscc_info_DnsQueryEvents_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fdnsresolver_2fdns_5fresolver_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::stats::dnsresolver::_DnsQueryEvents_default_instance_;
    new (ptr) ::android::stats::dnsresolver::DnsQueryEvents();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::stats::dnsresolver::DnsQueryEvents::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_DnsQueryEvents_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fdnsresolver_2fdns_5fresolver_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_DnsQueryEvents_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fdnsresolver_2fdns_5fresolver_2eproto}, {
      &scc_info_DnsQueryEvent_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fdnsresolver_2fdns_5fresolver_2eproto.base,}};

namespace android {
namespace stats {
namespace dnsresolver {
bool EventType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EventType_strings[5] = {};

static const char EventType_names[] =
  "EVENT_GETADDRINFO"
  "EVENT_GETHOSTBYADDR"
  "EVENT_GETHOSTBYNAME"
  "EVENT_RES_NSEND"
  "EVENT_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EventType_entries[] = {
  { {EventType_names + 0, 17}, 1 },
  { {EventType_names + 17, 19}, 3 },
  { {EventType_names + 36, 19}, 2 },
  { {EventType_names + 55, 15}, 4 },
  { {EventType_names + 70, 13}, 0 },
};

static const int EventType_entries_by_number[] = {
  4, // 0 -> EVENT_UNKNOWN
  0, // 1 -> EVENT_GETADDRINFO
  2, // 2 -> EVENT_GETHOSTBYNAME
  1, // 3 -> EVENT_GETHOSTBYADDR
  3, // 4 -> EVENT_RES_NSEND
};

const std::string& EventType_Name(
    EventType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EventType_entries,
          EventType_entries_by_number,
          5, EventType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EventType_entries,
      EventType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EventType_strings[idx].get();
}
bool EventType_Parse(
    const std::string& name, EventType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EventType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<EventType>(int_value);
  }
  return success;
}
bool ReturnCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 254:
    case 255:
    case 256:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ReturnCode_strings[18] = {};

static const char ReturnCode_names[] =
  "RC_EAI_ADDRFAMILY"
  "RC_EAI_AGAIN"
  "RC_EAI_BADFLAGS"
  "RC_EAI_BADHINTS"
  "RC_EAI_FAIL"
  "RC_EAI_FAMILY"
  "RC_EAI_MAX"
  "RC_EAI_MEMORY"
  "RC_EAI_NODATA"
  "RC_EAI_NONAME"
  "RC_EAI_NO_ERROR"
  "RC_EAI_OVERFLOW"
  "RC_EAI_PROTOCOL"
  "RC_EAI_SERVICE"
  "RC_EAI_SOCKTYPE"
  "RC_EAI_SYSTEM"
  "RC_RESOLV_INTERNAL_ERROR"
  "RC_RESOLV_TIMEOUT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ReturnCode_entries[] = {
  { {ReturnCode_names + 0, 17}, 1 },
  { {ReturnCode_names + 17, 12}, 2 },
  { {ReturnCode_names + 29, 15}, 3 },
  { {ReturnCode_names + 44, 15}, 12 },
  { {ReturnCode_names + 59, 11}, 4 },
  { {ReturnCode_names + 70, 13}, 5 },
  { {ReturnCode_names + 83, 10}, 256 },
  { {ReturnCode_names + 93, 13}, 6 },
  { {ReturnCode_names + 106, 13}, 7 },
  { {ReturnCode_names + 119, 13}, 8 },
  { {ReturnCode_names + 132, 15}, 0 },
  { {ReturnCode_names + 147, 15}, 14 },
  { {ReturnCode_names + 162, 15}, 13 },
  { {ReturnCode_names + 177, 14}, 9 },
  { {ReturnCode_names + 191, 15}, 10 },
  { {ReturnCode_names + 206, 13}, 11 },
  { {ReturnCode_names + 219, 24}, 254 },
  { {ReturnCode_names + 243, 17}, 255 },
};

static const int ReturnCode_entries_by_number[] = {
  10, // 0 -> RC_EAI_NO_ERROR
  0, // 1 -> RC_EAI_ADDRFAMILY
  1, // 2 -> RC_EAI_AGAIN
  2, // 3 -> RC_EAI_BADFLAGS
  4, // 4 -> RC_EAI_FAIL
  5, // 5 -> RC_EAI_FAMILY
  7, // 6 -> RC_EAI_MEMORY
  8, // 7 -> RC_EAI_NODATA
  9, // 8 -> RC_EAI_NONAME
  13, // 9 -> RC_EAI_SERVICE
  14, // 10 -> RC_EAI_SOCKTYPE
  15, // 11 -> RC_EAI_SYSTEM
  3, // 12 -> RC_EAI_BADHINTS
  12, // 13 -> RC_EAI_PROTOCOL
  11, // 14 -> RC_EAI_OVERFLOW
  16, // 254 -> RC_RESOLV_INTERNAL_ERROR
  17, // 255 -> RC_RESOLV_TIMEOUT
  6, // 256 -> RC_EAI_MAX
};

const std::string& ReturnCode_Name(
    ReturnCode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ReturnCode_entries,
          ReturnCode_entries_by_number,
          18, ReturnCode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ReturnCode_entries,
      ReturnCode_entries_by_number,
      18, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ReturnCode_strings[idx].get();
}
bool ReturnCode_Parse(
    const std::string& name, ReturnCode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ReturnCode_entries, 18, name, &int_value);
  if (success) {
    *value = static_cast<ReturnCode>(int_value);
  }
  return success;
}
bool NsRcode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 254:
    case 255:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NsRcode_strings[21] = {};

static const char NsRcode_names[] =
  "NS_R_BADKEY"
  "NS_R_BADTIME"
  "NS_R_BADVERS"
  "NS_R_FORMERR"
  "NS_R_INTERNAL_ERROR"
  "NS_R_MAX"
  "NS_R_NOTAUTH"
  "NS_R_NOTIMPL"
  "NS_R_NOTZONE"
  "NS_R_NO_ERROR"
  "NS_R_NXDOMAIN"
  "NS_R_NXRRSET"
  "NS_R_REFUSED"
  "NS_R_SERVFAIL"
  "NS_R_TIMEOUT"
  "NS_R_UNASSIGNED12"
  "NS_R_UNASSIGNED13"
  "NS_R_UNASSIGNED14"
  "NS_R_UNASSIGNED15"
  "NS_R_YXDOMAIN"
  "NS_R_YXRRSET";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NsRcode_entries[] = {
  { {NsRcode_names + 0, 11}, 17 },
  { {NsRcode_names + 11, 12}, 18 },
  { {NsRcode_names + 23, 12}, 16 },
  { {NsRcode_names + 35, 12}, 1 },
  { {NsRcode_names + 47, 19}, 254 },
  { {NsRcode_names + 66, 8}, 11 },
  { {NsRcode_names + 74, 12}, 9 },
  { {NsRcode_names + 86, 12}, 4 },
  { {NsRcode_names + 98, 12}, 10 },
  { {NsRcode_names + 110, 13}, 0 },
  { {NsRcode_names + 123, 13}, 3 },
  { {NsRcode_names + 136, 12}, 8 },
  { {NsRcode_names + 148, 12}, 5 },
  { {NsRcode_names + 160, 13}, 2 },
  { {NsRcode_names + 173, 12}, 255 },
  { {NsRcode_names + 185, 17}, 12 },
  { {NsRcode_names + 202, 17}, 13 },
  { {NsRcode_names + 219, 17}, 14 },
  { {NsRcode_names + 236, 17}, 15 },
  { {NsRcode_names + 253, 13}, 6 },
  { {NsRcode_names + 266, 12}, 7 },
};

static const int NsRcode_entries_by_number[] = {
  9, // 0 -> NS_R_NO_ERROR
  3, // 1 -> NS_R_FORMERR
  13, // 2 -> NS_R_SERVFAIL
  10, // 3 -> NS_R_NXDOMAIN
  7, // 4 -> NS_R_NOTIMPL
  12, // 5 -> NS_R_REFUSED
  19, // 6 -> NS_R_YXDOMAIN
  20, // 7 -> NS_R_YXRRSET
  11, // 8 -> NS_R_NXRRSET
  6, // 9 -> NS_R_NOTAUTH
  8, // 10 -> NS_R_NOTZONE
  5, // 11 -> NS_R_MAX
  15, // 12 -> NS_R_UNASSIGNED12
  16, // 13 -> NS_R_UNASSIGNED13
  17, // 14 -> NS_R_UNASSIGNED14
  18, // 15 -> NS_R_UNASSIGNED15
  2, // 16 -> NS_R_BADVERS
  0, // 17 -> NS_R_BADKEY
  1, // 18 -> NS_R_BADTIME
  4, // 254 -> NS_R_INTERNAL_ERROR
  14, // 255 -> NS_R_TIMEOUT
};

const std::string& NsRcode_Name(
    NsRcode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NsRcode_entries,
          NsRcode_entries_by_number,
          21, NsRcode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NsRcode_entries,
      NsRcode_entries_by_number,
      21, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NsRcode_strings[idx].get();
}
bool NsRcode_Parse(
    const std::string& name, NsRcode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NsRcode_entries, 21, name, &int_value);
  if (success) {
    *value = static_cast<NsRcode>(int_value);
  }
  return success;
}
bool NsType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 55:
    case 99:
    case 249:
    case 250:
    case 251:
    case 252:
    case 253:
    case 254:
    case 255:
    case 256:
    case 32769:
    case 65536:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NsType_strings[64] = {};

static const char NsType_names[] =
  "NS_T_A"
  "NS_T_A6"
  "NS_T_AAAA"
  "NS_T_AFSDB"
  "NS_T_ANY"
  "NS_T_APL"
  "NS_T_ATMA"
  "NS_T_AXFR"
  "NS_T_CERT"
  "NS_T_CNAME"
  "NS_T_DHCID"
  "NS_T_DLV"
  "NS_T_DNAME"
  "NS_T_DNSKEY"
  "NS_T_DS"
  "NS_T_EID"
  "NS_T_GPOS"
  "NS_T_HINFO"
  "NS_T_HIP"
  "NS_T_INVALID"
  "NS_T_IPSECKEY"
  "NS_T_ISDN"
  "NS_T_IXFR"
  "NS_T_KEY"
  "NS_T_KX"
  "NS_T_LOC"
  "NS_T_MAILA"
  "NS_T_MAILB"
  "NS_T_MAX"
  "NS_T_MB"
  "NS_T_MD"
  "NS_T_MF"
  "NS_T_MG"
  "NS_T_MINFO"
  "NS_T_MR"
  "NS_T_MX"
  "NS_T_NAPTR"
  "NS_T_NIMLOC"
  "NS_T_NS"
  "NS_T_NSAP"
  "NS_T_NSAP_PTR"
  "NS_T_NSEC"
  "NS_T_NSEC3"
  "NS_T_NSEC3PARAM"
  "NS_T_NULL"
  "NS_T_NXT"
  "NS_T_OPT"
  "NS_T_PTR"
  "NS_T_PX"
  "NS_T_RP"
  "NS_T_RRSIG"
  "NS_T_RT"
  "NS_T_SIG"
  "NS_T_SINK"
  "NS_T_SOA"
  "NS_T_SPF"
  "NS_T_SRV"
  "NS_T_SSHFP"
  "NS_T_TKEY"
  "NS_T_TSIG"
  "NS_T_TXT"
  "NS_T_WKS"
  "NS_T_X25"
  "NS_T_ZXFR";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NsType_entries[] = {
  { {NsType_names + 0, 6}, 1 },
  { {NsType_names + 6, 7}, 38 },
  { {NsType_names + 13, 9}, 28 },
  { {NsType_names + 22, 10}, 18 },
  { {NsType_names + 32, 8}, 255 },
  { {NsType_names + 40, 8}, 42 },
  { {NsType_names + 48, 9}, 34 },
  { {NsType_names + 57, 9}, 252 },
  { {NsType_names + 66, 9}, 37 },
  { {NsType_names + 75, 10}, 5 },
  { {NsType_names + 85, 10}, 49 },
  { {NsType_names + 95, 8}, 32769 },
  { {NsType_names + 103, 10}, 39 },
  { {NsType_names + 113, 11}, 48 },
  { {NsType_names + 124, 7}, 43 },
  { {NsType_names + 131, 8}, 31 },
  { {NsType_names + 139, 9}, 27 },
  { {NsType_names + 148, 10}, 13 },
  { {NsType_names + 158, 8}, 55 },
  { {NsType_names + 166, 12}, 0 },
  { {NsType_names + 178, 13}, 45 },
  { {NsType_names + 191, 9}, 20 },
  { {NsType_names + 200, 9}, 251 },
  { {NsType_names + 209, 8}, 25 },
  { {NsType_names + 217, 7}, 36 },
  { {NsType_names + 224, 8}, 29 },
  { {NsType_names + 232, 10}, 254 },
  { {NsType_names + 242, 10}, 253 },
  { {NsType_names + 252, 8}, 65536 },
  { {NsType_names + 260, 7}, 7 },
  { {NsType_names + 267, 7}, 3 },
  { {NsType_names + 274, 7}, 4 },
  { {NsType_names + 281, 7}, 8 },
  { {NsType_names + 288, 10}, 14 },
  { {NsType_names + 298, 7}, 9 },
  { {NsType_names + 305, 7}, 15 },
  { {NsType_names + 312, 10}, 35 },
  { {NsType_names + 322, 11}, 32 },
  { {NsType_names + 333, 7}, 2 },
  { {NsType_names + 340, 9}, 22 },
  { {NsType_names + 349, 13}, 23 },
  { {NsType_names + 362, 9}, 47 },
  { {NsType_names + 371, 10}, 50 },
  { {NsType_names + 381, 15}, 51 },
  { {NsType_names + 396, 9}, 10 },
  { {NsType_names + 405, 8}, 30 },
  { {NsType_names + 413, 8}, 41 },
  { {NsType_names + 421, 8}, 12 },
  { {NsType_names + 429, 7}, 26 },
  { {NsType_names + 436, 7}, 17 },
  { {NsType_names + 443, 10}, 46 },
  { {NsType_names + 453, 7}, 21 },
  { {NsType_names + 460, 8}, 24 },
  { {NsType_names + 468, 9}, 40 },
  { {NsType_names + 477, 8}, 6 },
  { {NsType_names + 485, 8}, 99 },
  { {NsType_names + 493, 8}, 33 },
  { {NsType_names + 501, 10}, 44 },
  { {NsType_names + 511, 9}, 249 },
  { {NsType_names + 520, 9}, 250 },
  { {NsType_names + 529, 8}, 16 },
  { {NsType_names + 537, 8}, 11 },
  { {NsType_names + 545, 8}, 19 },
  { {NsType_names + 553, 9}, 256 },
};

static const int NsType_entries_by_number[] = {
  19, // 0 -> NS_T_INVALID
  0, // 1 -> NS_T_A
  38, // 2 -> NS_T_NS
  30, // 3 -> NS_T_MD
  31, // 4 -> NS_T_MF
  9, // 5 -> NS_T_CNAME
  54, // 6 -> NS_T_SOA
  29, // 7 -> NS_T_MB
  32, // 8 -> NS_T_MG
  34, // 9 -> NS_T_MR
  44, // 10 -> NS_T_NULL
  61, // 11 -> NS_T_WKS
  47, // 12 -> NS_T_PTR
  17, // 13 -> NS_T_HINFO
  33, // 14 -> NS_T_MINFO
  35, // 15 -> NS_T_MX
  60, // 16 -> NS_T_TXT
  49, // 17 -> NS_T_RP
  3, // 18 -> NS_T_AFSDB
  62, // 19 -> NS_T_X25
  21, // 20 -> NS_T_ISDN
  51, // 21 -> NS_T_RT
  39, // 22 -> NS_T_NSAP
  40, // 23 -> NS_T_NSAP_PTR
  52, // 24 -> NS_T_SIG
  23, // 25 -> NS_T_KEY
  48, // 26 -> NS_T_PX
  16, // 27 -> NS_T_GPOS
  2, // 28 -> NS_T_AAAA
  25, // 29 -> NS_T_LOC
  45, // 30 -> NS_T_NXT
  15, // 31 -> NS_T_EID
  37, // 32 -> NS_T_NIMLOC
  56, // 33 -> NS_T_SRV
  6, // 34 -> NS_T_ATMA
  36, // 35 -> NS_T_NAPTR
  24, // 36 -> NS_T_KX
  8, // 37 -> NS_T_CERT
  1, // 38 -> NS_T_A6
  12, // 39 -> NS_T_DNAME
  53, // 40 -> NS_T_SINK
  46, // 41 -> NS_T_OPT
  5, // 42 -> NS_T_APL
  14, // 43 -> NS_T_DS
  57, // 44 -> NS_T_SSHFP
  20, // 45 -> NS_T_IPSECKEY
  50, // 46 -> NS_T_RRSIG
  41, // 47 -> NS_T_NSEC
  13, // 48 -> NS_T_DNSKEY
  10, // 49 -> NS_T_DHCID
  42, // 50 -> NS_T_NSEC3
  43, // 51 -> NS_T_NSEC3PARAM
  18, // 55 -> NS_T_HIP
  55, // 99 -> NS_T_SPF
  58, // 249 -> NS_T_TKEY
  59, // 250 -> NS_T_TSIG
  22, // 251 -> NS_T_IXFR
  7, // 252 -> NS_T_AXFR
  27, // 253 -> NS_T_MAILB
  26, // 254 -> NS_T_MAILA
  4, // 255 -> NS_T_ANY
  63, // 256 -> NS_T_ZXFR
  11, // 32769 -> NS_T_DLV
  28, // 65536 -> NS_T_MAX
};

const std::string& NsType_Name(
    NsType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NsType_entries,
          NsType_entries_by_number,
          64, NsType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NsType_entries,
      NsType_entries_by_number,
      64, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NsType_strings[idx].get();
}
bool NsType_Parse(
    const std::string& name, NsType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NsType_entries, 64, name, &int_value);
  if (success) {
    *value = static_cast<NsType>(int_value);
  }
  return success;
}
bool IpVersion_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> IpVersion_strings[3] = {};

static const char IpVersion_names[] =
  "IV_IPV4"
  "IV_IPV6"
  "IV_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry IpVersion_entries[] = {
  { {IpVersion_names + 0, 7}, 1 },
  { {IpVersion_names + 7, 7}, 2 },
  { {IpVersion_names + 14, 10}, 0 },
};

static const int IpVersion_entries_by_number[] = {
  2, // 0 -> IV_UNKNOWN
  0, // 1 -> IV_IPV4
  1, // 2 -> IV_IPV6
};

const std::string& IpVersion_Name(
    IpVersion value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          IpVersion_entries,
          IpVersion_entries_by_number,
          3, IpVersion_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      IpVersion_entries,
      IpVersion_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     IpVersion_strings[idx].get();
}
bool IpVersion_Parse(
    const std::string& name, IpVersion* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      IpVersion_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<IpVersion>(int_value);
  }
  return success;
}
bool Protocol_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Protocol_strings[5] = {};

static const char Protocol_names[] =
  "PROTO_DOH"
  "PROTO_DOT"
  "PROTO_TCP"
  "PROTO_UDP"
  "PROTO_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Protocol_entries[] = {
  { {Protocol_names + 0, 9}, 4 },
  { {Protocol_names + 9, 9}, 3 },
  { {Protocol_names + 18, 9}, 2 },
  { {Protocol_names + 27, 9}, 1 },
  { {Protocol_names + 36, 13}, 0 },
};

static const int Protocol_entries_by_number[] = {
  4, // 0 -> PROTO_UNKNOWN
  3, // 1 -> PROTO_UDP
  2, // 2 -> PROTO_TCP
  1, // 3 -> PROTO_DOT
  0, // 4 -> PROTO_DOH
};

const std::string& Protocol_Name(
    Protocol value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Protocol_entries,
          Protocol_entries_by_number,
          5, Protocol_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Protocol_entries,
      Protocol_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Protocol_strings[idx].get();
}
bool Protocol_Parse(
    const std::string& name, Protocol* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Protocol_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<Protocol>(int_value);
  }
  return success;
}
bool PrivateDnsModes_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PrivateDnsModes_strings[4] = {};

static const char PrivateDnsModes_names[] =
  "PDM_OFF"
  "PDM_OPPORTUNISTIC"
  "PDM_STRICT"
  "PDM_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PrivateDnsModes_entries[] = {
  { {PrivateDnsModes_names + 0, 7}, 1 },
  { {PrivateDnsModes_names + 7, 17}, 2 },
  { {PrivateDnsModes_names + 24, 10}, 3 },
  { {PrivateDnsModes_names + 34, 11}, 0 },
};

static const int PrivateDnsModes_entries_by_number[] = {
  3, // 0 -> PDM_UNKNOWN
  0, // 1 -> PDM_OFF
  1, // 2 -> PDM_OPPORTUNISTIC
  2, // 3 -> PDM_STRICT
};

const std::string& PrivateDnsModes_Name(
    PrivateDnsModes value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PrivateDnsModes_entries,
          PrivateDnsModes_entries_by_number,
          4, PrivateDnsModes_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PrivateDnsModes_entries,
      PrivateDnsModes_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PrivateDnsModes_strings[idx].get();
}
bool PrivateDnsModes_Parse(
    const std::string& name, PrivateDnsModes* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PrivateDnsModes_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<PrivateDnsModes>(int_value);
  }
  return success;
}
bool NetworkType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NetworkType_strings[13] = {};

static const char NetworkType_names[] =
  "NT_BLUETOOTH"
  "NT_BLUETOOTH_VPN"
  "NT_CELLULAR"
  "NT_CELLULAR_VPN"
  "NT_ETHERNET"
  "NT_ETHERNET_VPN"
  "NT_LOWPAN"
  "NT_UNKNOWN"
  "NT_VPN"
  "NT_WIFI"
  "NT_WIFI_AWARE"
  "NT_WIFI_CELLULAR_VPN"
  "NT_WIFI_VPN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NetworkType_entries[] = {
  { {NetworkType_names + 0, 12}, 3 },
  { {NetworkType_names + 12, 16}, 10 },
  { {NetworkType_names + 28, 11}, 1 },
  { {NetworkType_names + 39, 15}, 8 },
  { {NetworkType_names + 54, 11}, 4 },
  { {NetworkType_names + 65, 15}, 11 },
  { {NetworkType_names + 80, 9}, 7 },
  { {NetworkType_names + 89, 10}, 0 },
  { {NetworkType_names + 99, 6}, 5 },
  { {NetworkType_names + 105, 7}, 2 },
  { {NetworkType_names + 112, 13}, 6 },
  { {NetworkType_names + 125, 20}, 12 },
  { {NetworkType_names + 145, 11}, 9 },
};

static const int NetworkType_entries_by_number[] = {
  7, // 0 -> NT_UNKNOWN
  2, // 1 -> NT_CELLULAR
  9, // 2 -> NT_WIFI
  0, // 3 -> NT_BLUETOOTH
  4, // 4 -> NT_ETHERNET
  8, // 5 -> NT_VPN
  10, // 6 -> NT_WIFI_AWARE
  6, // 7 -> NT_LOWPAN
  3, // 8 -> NT_CELLULAR_VPN
  12, // 9 -> NT_WIFI_VPN
  1, // 10 -> NT_BLUETOOTH_VPN
  5, // 11 -> NT_ETHERNET_VPN
  11, // 12 -> NT_WIFI_CELLULAR_VPN
};

const std::string& NetworkType_Name(
    NetworkType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NetworkType_entries,
          NetworkType_entries_by_number,
          13, NetworkType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NetworkType_entries,
      NetworkType_entries_by_number,
      13, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NetworkType_strings[idx].get();
}
bool NetworkType_Parse(
    const std::string& name, NetworkType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NetworkType_entries, 13, name, &int_value);
  if (success) {
    *value = static_cast<NetworkType>(int_value);
  }
  return success;
}
bool CacheStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CacheStatus_strings[4] = {};

static const char CacheStatus_names[] =
  "CS_FOUND"
  "CS_NOTFOUND"
  "CS_SKIP"
  "CS_UNSUPPORTED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CacheStatus_entries[] = {
  { {CacheStatus_names + 0, 8}, 2 },
  { {CacheStatus_names + 8, 11}, 1 },
  { {CacheStatus_names + 19, 7}, 3 },
  { {CacheStatus_names + 26, 14}, 0 },
};

static const int CacheStatus_entries_by_number[] = {
  3, // 0 -> CS_UNSUPPORTED
  1, // 1 -> CS_NOTFOUND
  0, // 2 -> CS_FOUND
  2, // 3 -> CS_SKIP
};

const std::string& CacheStatus_Name(
    CacheStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CacheStatus_entries,
          CacheStatus_entries_by_number,
          4, CacheStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CacheStatus_entries,
      CacheStatus_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CacheStatus_strings[idx].get();
}
bool CacheStatus_Parse(
    const std::string& name, CacheStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CacheStatus_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<CacheStatus>(int_value);
  }
  return success;
}
bool LinuxErrno_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 126:
    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 132:
    case 133:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LinuxErrno_strings[132] = {};

static const char LinuxErrno_names[] =
  "SYS_E2BIG"
  "SYS_EACCES"
  "SYS_EADDRINUSE"
  "SYS_EADDRNOTAVAIL"
  "SYS_EADV"
  "SYS_EAFNOSUPPORT"
  "SYS_EAGAIN"
  "SYS_EALREADY"
  "SYS_EBADE"
  "SYS_EBADF"
  "SYS_EBADFD"
  "SYS_EBADMSG"
  "SYS_EBADR"
  "SYS_EBADRQC"
  "SYS_EBADSLT"
  "SYS_EBFONT"
  "SYS_EBUSY"
  "SYS_ECANCELED"
  "SYS_ECHILD"
  "SYS_ECHRNG"
  "SYS_ECOMM"
  "SYS_ECONNABORTED"
  "SYS_ECONNREFUSED"
  "SYS_ECONNRESET"
  "SYS_EDEADLOCK"
  "SYS_EDESTADDRREQ"
  "SYS_EDOM"
  "SYS_EDOTDOT"
  "SYS_EDQUOT"
  "SYS_EEXIST"
  "SYS_EFAULT"
  "SYS_EFBIG"
  "SYS_EHOSTDOWN"
  "SYS_EHOSTUNREACH"
  "SYS_EHWPOISON"
  "SYS_EIDRM"
  "SYS_EILSEQ"
  "SYS_EINPROGRESS"
  "SYS_EINTR"
  "SYS_EINVAL"
  "SYS_EIO"
  "SYS_EISCONN"
  "SYS_EISDIR"
  "SYS_EISNAM"
  "SYS_EKEYEXPIRED"
  "SYS_EKEYREJECTED"
  "SYS_EKEYREVOKED"
  "SYS_EL2HLT"
  "SYS_EL2NSYNC"
  "SYS_EL3HLT"
  "SYS_EL3RST"
  "SYS_ELIBACC"
  "SYS_ELIBBAD"
  "SYS_ELIBEXEC"
  "SYS_ELIBMAX"
  "SYS_ELIBSCN"
  "SYS_ELNRNG"
  "SYS_ELOOP"
  "SYS_EMEDIUMTYPE"
  "SYS_EMFILE"
  "SYS_EMLINK"
  "SYS_EMSGSIZE"
  "SYS_EMULTIHOP"
  "SYS_ENAMETOOLONG"
  "SYS_ENAVAIL"
  "SYS_ENETDOWN"
  "SYS_ENETRESET"
  "SYS_ENETUNREACH"
  "SYS_ENFILE"
  "SYS_ENOANO"
  "SYS_ENOBUFS"
  "SYS_ENOCSI"
  "SYS_ENODATA"
  "SYS_ENODEV"
  "SYS_ENOENT"
  "SYS_ENOEXEC"
  "SYS_ENOKEY"
  "SYS_ENOLCK"
  "SYS_ENOLINK"
  "SYS_ENOMEDIUM"
  "SYS_ENOMEM"
  "SYS_ENOMSG"
  "SYS_ENONET"
  "SYS_ENOPKG"
  "SYS_ENOPROTOOPT"
  "SYS_ENOSPC"
  "SYS_ENOSR"
  "SYS_ENOSTR"
  "SYS_ENOSYS"
  "SYS_ENOTBLK"
  "SYS_ENOTCONN"
  "SYS_ENOTDIR"
  "SYS_ENOTEMPTY"
  "SYS_ENOTNAM"
  "SYS_ENOTRECOVERABLE"
  "SYS_ENOTSOCK"
  "SYS_ENOTTY"
  "SYS_ENOTUNIQ"
  "SYS_ENXIO"
  "SYS_EOPNOTSUPP"
  "SYS_EOVERFLOW"
  "SYS_EOWNERDEAD"
  "SYS_EPERM"
  "SYS_EPFNOSUPPORT"
  "SYS_EPIPE"
  "SYS_EPROTO"
  "SYS_EPROTONOSUPPORT"
  "SYS_EPROTOTYPE"
  "SYS_ERANGE"
  "SYS_EREMCHG"
  "SYS_EREMOTE"
  "SYS_EREMOTEIO"
  "SYS_ERESTART"
  "SYS_ERFKILL"
  "SYS_EROFS"
  "SYS_ESHUTDOWN"
  "SYS_ESOCKTNOSUPPORT"
  "SYS_ESPIPE"
  "SYS_ESRCH"
  "SYS_ESRMNT"
  "SYS_ESTALE"
  "SYS_ESTRPIPE"
  "SYS_ETIME"
  "SYS_ETIMEDOUT"
  "SYS_ETOOMANYREFS"
  "SYS_ETXTBSY"
  "SYS_EUCLEAN"
  "SYS_EUNATCH"
  "SYS_EUSERS"
  "SYS_EXDEV"
  "SYS_EXFULL"
  "SYS_NO_ERROR";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LinuxErrno_entries[] = {
  { {LinuxErrno_names + 0, 9}, 7 },
  { {LinuxErrno_names + 9, 10}, 13 },
  { {LinuxErrno_names + 19, 14}, 98 },
  { {LinuxErrno_names + 33, 17}, 99 },
  { {LinuxErrno_names + 50, 8}, 68 },
  { {LinuxErrno_names + 58, 16}, 97 },
  { {LinuxErrno_names + 74, 10}, 11 },
  { {LinuxErrno_names + 84, 12}, 114 },
  { {LinuxErrno_names + 96, 9}, 52 },
  { {LinuxErrno_names + 105, 9}, 9 },
  { {LinuxErrno_names + 114, 10}, 77 },
  { {LinuxErrno_names + 124, 11}, 74 },
  { {LinuxErrno_names + 135, 9}, 53 },
  { {LinuxErrno_names + 144, 11}, 56 },
  { {LinuxErrno_names + 155, 11}, 57 },
  { {LinuxErrno_names + 166, 10}, 59 },
  { {LinuxErrno_names + 176, 9}, 16 },
  { {LinuxErrno_names + 185, 13}, 125 },
  { {LinuxErrno_names + 198, 10}, 10 },
  { {LinuxErrno_names + 208, 10}, 44 },
  { {LinuxErrno_names + 218, 9}, 70 },
  { {LinuxErrno_names + 227, 16}, 103 },
  { {LinuxErrno_names + 243, 16}, 111 },
  { {LinuxErrno_names + 259, 14}, 104 },
  { {LinuxErrno_names + 273, 13}, 35 },
  { {LinuxErrno_names + 286, 16}, 89 },
  { {LinuxErrno_names + 302, 8}, 33 },
  { {LinuxErrno_names + 310, 11}, 73 },
  { {LinuxErrno_names + 321, 10}, 122 },
  { {LinuxErrno_names + 331, 10}, 17 },
  { {LinuxErrno_names + 341, 10}, 14 },
  { {LinuxErrno_names + 351, 9}, 27 },
  { {LinuxErrno_names + 360, 13}, 112 },
  { {LinuxErrno_names + 373, 16}, 113 },
  { {LinuxErrno_names + 389, 13}, 133 },
  { {LinuxErrno_names + 402, 9}, 43 },
  { {LinuxErrno_names + 411, 10}, 84 },
  { {LinuxErrno_names + 421, 15}, 115 },
  { {LinuxErrno_names + 436, 9}, 4 },
  { {LinuxErrno_names + 445, 10}, 22 },
  { {LinuxErrno_names + 455, 7}, 5 },
  { {LinuxErrno_names + 462, 11}, 106 },
  { {LinuxErrno_names + 473, 10}, 21 },
  { {LinuxErrno_names + 483, 10}, 120 },
  { {LinuxErrno_names + 493, 15}, 127 },
  { {LinuxErrno_names + 508, 16}, 129 },
  { {LinuxErrno_names + 524, 15}, 128 },
  { {LinuxErrno_names + 539, 10}, 51 },
  { {LinuxErrno_names + 549, 12}, 45 },
  { {LinuxErrno_names + 561, 10}, 46 },
  { {LinuxErrno_names + 571, 10}, 47 },
  { {LinuxErrno_names + 581, 11}, 79 },
  { {LinuxErrno_names + 592, 11}, 80 },
  { {LinuxErrno_names + 603, 12}, 83 },
  { {LinuxErrno_names + 615, 11}, 82 },
  { {LinuxErrno_names + 626, 11}, 81 },
  { {LinuxErrno_names + 637, 10}, 48 },
  { {LinuxErrno_names + 647, 9}, 40 },
  { {LinuxErrno_names + 656, 15}, 124 },
  { {LinuxErrno_names + 671, 10}, 24 },
  { {LinuxErrno_names + 681, 10}, 31 },
  { {LinuxErrno_names + 691, 12}, 90 },
  { {LinuxErrno_names + 703, 13}, 72 },
  { {LinuxErrno_names + 716, 16}, 36 },
  { {LinuxErrno_names + 732, 11}, 119 },
  { {LinuxErrno_names + 743, 12}, 100 },
  { {LinuxErrno_names + 755, 13}, 102 },
  { {LinuxErrno_names + 768, 15}, 101 },
  { {LinuxErrno_names + 783, 10}, 23 },
  { {LinuxErrno_names + 793, 10}, 55 },
  { {LinuxErrno_names + 803, 11}, 105 },
  { {LinuxErrno_names + 814, 10}, 50 },
  { {LinuxErrno_names + 824, 11}, 61 },
  { {LinuxErrno_names + 835, 10}, 19 },
  { {LinuxErrno_names + 845, 10}, 2 },
  { {LinuxErrno_names + 855, 11}, 8 },
  { {LinuxErrno_names + 866, 10}, 126 },
  { {LinuxErrno_names + 876, 10}, 37 },
  { {LinuxErrno_names + 886, 11}, 67 },
  { {LinuxErrno_names + 897, 13}, 123 },
  { {LinuxErrno_names + 910, 10}, 12 },
  { {LinuxErrno_names + 920, 10}, 42 },
  { {LinuxErrno_names + 930, 10}, 64 },
  { {LinuxErrno_names + 940, 10}, 65 },
  { {LinuxErrno_names + 950, 15}, 92 },
  { {LinuxErrno_names + 965, 10}, 28 },
  { {LinuxErrno_names + 975, 9}, 63 },
  { {LinuxErrno_names + 984, 10}, 60 },
  { {LinuxErrno_names + 994, 10}, 38 },
  { {LinuxErrno_names + 1004, 11}, 15 },
  { {LinuxErrno_names + 1015, 12}, 107 },
  { {LinuxErrno_names + 1027, 11}, 20 },
  { {LinuxErrno_names + 1038, 13}, 39 },
  { {LinuxErrno_names + 1051, 11}, 118 },
  { {LinuxErrno_names + 1062, 19}, 131 },
  { {LinuxErrno_names + 1081, 12}, 88 },
  { {LinuxErrno_names + 1093, 10}, 25 },
  { {LinuxErrno_names + 1103, 12}, 76 },
  { {LinuxErrno_names + 1115, 9}, 6 },
  { {LinuxErrno_names + 1124, 14}, 95 },
  { {LinuxErrno_names + 1138, 13}, 75 },
  { {LinuxErrno_names + 1151, 14}, 130 },
  { {LinuxErrno_names + 1165, 9}, 1 },
  { {LinuxErrno_names + 1174, 16}, 96 },
  { {LinuxErrno_names + 1190, 9}, 32 },
  { {LinuxErrno_names + 1199, 10}, 71 },
  { {LinuxErrno_names + 1209, 19}, 93 },
  { {LinuxErrno_names + 1228, 14}, 91 },
  { {LinuxErrno_names + 1242, 10}, 34 },
  { {LinuxErrno_names + 1252, 11}, 78 },
  { {LinuxErrno_names + 1263, 11}, 66 },
  { {LinuxErrno_names + 1274, 13}, 121 },
  { {LinuxErrno_names + 1287, 12}, 85 },
  { {LinuxErrno_names + 1299, 11}, 132 },
  { {LinuxErrno_names + 1310, 9}, 30 },
  { {LinuxErrno_names + 1319, 13}, 108 },
  { {LinuxErrno_names + 1332, 19}, 94 },
  { {LinuxErrno_names + 1351, 10}, 29 },
  { {LinuxErrno_names + 1361, 9}, 3 },
  { {LinuxErrno_names + 1370, 10}, 69 },
  { {LinuxErrno_names + 1380, 10}, 116 },
  { {LinuxErrno_names + 1390, 12}, 86 },
  { {LinuxErrno_names + 1402, 9}, 62 },
  { {LinuxErrno_names + 1411, 13}, 110 },
  { {LinuxErrno_names + 1424, 16}, 109 },
  { {LinuxErrno_names + 1440, 11}, 26 },
  { {LinuxErrno_names + 1451, 11}, 117 },
  { {LinuxErrno_names + 1462, 11}, 49 },
  { {LinuxErrno_names + 1473, 10}, 87 },
  { {LinuxErrno_names + 1483, 9}, 18 },
  { {LinuxErrno_names + 1492, 10}, 54 },
  { {LinuxErrno_names + 1502, 12}, 0 },
};

static const int LinuxErrno_entries_by_number[] = {
  131, // 0 -> SYS_NO_ERROR
  102, // 1 -> SYS_EPERM
  74, // 2 -> SYS_ENOENT
  118, // 3 -> SYS_ESRCH
  38, // 4 -> SYS_EINTR
  40, // 5 -> SYS_EIO
  98, // 6 -> SYS_ENXIO
  0, // 7 -> SYS_E2BIG
  75, // 8 -> SYS_ENOEXEC
  9, // 9 -> SYS_EBADF
  18, // 10 -> SYS_ECHILD
  6, // 11 -> SYS_EAGAIN
  80, // 12 -> SYS_ENOMEM
  1, // 13 -> SYS_EACCES
  30, // 14 -> SYS_EFAULT
  89, // 15 -> SYS_ENOTBLK
  16, // 16 -> SYS_EBUSY
  29, // 17 -> SYS_EEXIST
  129, // 18 -> SYS_EXDEV
  73, // 19 -> SYS_ENODEV
  91, // 20 -> SYS_ENOTDIR
  42, // 21 -> SYS_EISDIR
  39, // 22 -> SYS_EINVAL
  68, // 23 -> SYS_ENFILE
  59, // 24 -> SYS_EMFILE
  96, // 25 -> SYS_ENOTTY
  125, // 26 -> SYS_ETXTBSY
  31, // 27 -> SYS_EFBIG
  85, // 28 -> SYS_ENOSPC
  117, // 29 -> SYS_ESPIPE
  114, // 30 -> SYS_EROFS
  60, // 31 -> SYS_EMLINK
  104, // 32 -> SYS_EPIPE
  26, // 33 -> SYS_EDOM
  108, // 34 -> SYS_ERANGE
  24, // 35 -> SYS_EDEADLOCK
  63, // 36 -> SYS_ENAMETOOLONG
  77, // 37 -> SYS_ENOLCK
  88, // 38 -> SYS_ENOSYS
  92, // 39 -> SYS_ENOTEMPTY
  57, // 40 -> SYS_ELOOP
  81, // 42 -> SYS_ENOMSG
  35, // 43 -> SYS_EIDRM
  19, // 44 -> SYS_ECHRNG
  48, // 45 -> SYS_EL2NSYNC
  49, // 46 -> SYS_EL3HLT
  50, // 47 -> SYS_EL3RST
  56, // 48 -> SYS_ELNRNG
  127, // 49 -> SYS_EUNATCH
  71, // 50 -> SYS_ENOCSI
  47, // 51 -> SYS_EL2HLT
  8, // 52 -> SYS_EBADE
  12, // 53 -> SYS_EBADR
  130, // 54 -> SYS_EXFULL
  69, // 55 -> SYS_ENOANO
  13, // 56 -> SYS_EBADRQC
  14, // 57 -> SYS_EBADSLT
  15, // 59 -> SYS_EBFONT
  87, // 60 -> SYS_ENOSTR
  72, // 61 -> SYS_ENODATA
  122, // 62 -> SYS_ETIME
  86, // 63 -> SYS_ENOSR
  82, // 64 -> SYS_ENONET
  83, // 65 -> SYS_ENOPKG
  110, // 66 -> SYS_EREMOTE
  78, // 67 -> SYS_ENOLINK
  4, // 68 -> SYS_EADV
  119, // 69 -> SYS_ESRMNT
  20, // 70 -> SYS_ECOMM
  105, // 71 -> SYS_EPROTO
  62, // 72 -> SYS_EMULTIHOP
  27, // 73 -> SYS_EDOTDOT
  11, // 74 -> SYS_EBADMSG
  100, // 75 -> SYS_EOVERFLOW
  97, // 76 -> SYS_ENOTUNIQ
  10, // 77 -> SYS_EBADFD
  109, // 78 -> SYS_EREMCHG
  51, // 79 -> SYS_ELIBACC
  52, // 80 -> SYS_ELIBBAD
  55, // 81 -> SYS_ELIBSCN
  54, // 82 -> SYS_ELIBMAX
  53, // 83 -> SYS_ELIBEXEC
  36, // 84 -> SYS_EILSEQ
  112, // 85 -> SYS_ERESTART
  121, // 86 -> SYS_ESTRPIPE
  128, // 87 -> SYS_EUSERS
  95, // 88 -> SYS_ENOTSOCK
  25, // 89 -> SYS_EDESTADDRREQ
  61, // 90 -> SYS_EMSGSIZE
  107, // 91 -> SYS_EPROTOTYPE
  84, // 92 -> SYS_ENOPROTOOPT
  106, // 93 -> SYS_EPROTONOSUPPORT
  116, // 94 -> SYS_ESOCKTNOSUPPORT
  99, // 95 -> SYS_EOPNOTSUPP
  103, // 96 -> SYS_EPFNOSUPPORT
  5, // 97 -> SYS_EAFNOSUPPORT
  2, // 98 -> SYS_EADDRINUSE
  3, // 99 -> SYS_EADDRNOTAVAIL
  65, // 100 -> SYS_ENETDOWN
  67, // 101 -> SYS_ENETUNREACH
  66, // 102 -> SYS_ENETRESET
  21, // 103 -> SYS_ECONNABORTED
  23, // 104 -> SYS_ECONNRESET
  70, // 105 -> SYS_ENOBUFS
  41, // 106 -> SYS_EISCONN
  90, // 107 -> SYS_ENOTCONN
  115, // 108 -> SYS_ESHUTDOWN
  124, // 109 -> SYS_ETOOMANYREFS
  123, // 110 -> SYS_ETIMEDOUT
  22, // 111 -> SYS_ECONNREFUSED
  32, // 112 -> SYS_EHOSTDOWN
  33, // 113 -> SYS_EHOSTUNREACH
  7, // 114 -> SYS_EALREADY
  37, // 115 -> SYS_EINPROGRESS
  120, // 116 -> SYS_ESTALE
  126, // 117 -> SYS_EUCLEAN
  93, // 118 -> SYS_ENOTNAM
  64, // 119 -> SYS_ENAVAIL
  43, // 120 -> SYS_EISNAM
  111, // 121 -> SYS_EREMOTEIO
  28, // 122 -> SYS_EDQUOT
  79, // 123 -> SYS_ENOMEDIUM
  58, // 124 -> SYS_EMEDIUMTYPE
  17, // 125 -> SYS_ECANCELED
  76, // 126 -> SYS_ENOKEY
  44, // 127 -> SYS_EKEYEXPIRED
  46, // 128 -> SYS_EKEYREVOKED
  45, // 129 -> SYS_EKEYREJECTED
  101, // 130 -> SYS_EOWNERDEAD
  94, // 131 -> SYS_ENOTRECOVERABLE
  113, // 132 -> SYS_ERFKILL
  34, // 133 -> SYS_EHWPOISON
};

const std::string& LinuxErrno_Name(
    LinuxErrno value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LinuxErrno_entries,
          LinuxErrno_entries_by_number,
          132, LinuxErrno_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LinuxErrno_entries,
      LinuxErrno_entries_by_number,
      132, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LinuxErrno_strings[idx].get();
}
bool LinuxErrno_Parse(
    const std::string& name, LinuxErrno* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LinuxErrno_entries, 132, name, &int_value);
  if (success) {
    *value = static_cast<LinuxErrno>(int_value);
  }
  return success;
}

// ===================================================================

void DnsQueryEvent::InitAsDefaultInstance() {
}
class DnsQueryEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<DnsQueryEvent>()._has_bits_);
  static void set_has_rcode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cache_hit(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ip_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_protocol(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_retry_times(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_dns_server_index(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_connected(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_latency_micros(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_linux_errno(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

DnsQueryEvent::DnsQueryEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.stats.dnsresolver.DnsQueryEvent)
}
DnsQueryEvent::DnsQueryEvent(const DnsQueryEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&rcode_, &from.rcode_,
    static_cast<size_t>(reinterpret_cast<char*>(&linux_errno_) -
    reinterpret_cast<char*>(&rcode_)) + sizeof(linux_errno_));
  // @@protoc_insertion_point(copy_constructor:android.stats.dnsresolver.DnsQueryEvent)
}

void DnsQueryEvent::SharedCtor() {
  ::memset(&rcode_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&linux_errno_) -
      reinterpret_cast<char*>(&rcode_)) + sizeof(linux_errno_));
}

DnsQueryEvent::~DnsQueryEvent() {
  // @@protoc_insertion_point(destructor:android.stats.dnsresolver.DnsQueryEvent)
  SharedDtor();
}

void DnsQueryEvent::SharedDtor() {
}

void DnsQueryEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DnsQueryEvent& DnsQueryEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_DnsQueryEvent_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fdnsresolver_2fdns_5fresolver_2eproto.base);
  return *internal_default_instance();
}


void DnsQueryEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:android.stats.dnsresolver.DnsQueryEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&rcode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&connected_) -
        reinterpret_cast<char*>(&rcode_)) + sizeof(connected_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&latency_micros_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&linux_errno_) -
        reinterpret_cast<char*>(&latency_micros_)) + sizeof(linux_errno_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* DnsQueryEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .android.stats.dnsresolver.NsRcode rcode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::android::stats::dnsresolver::NsRcode_IsValid(val))) {
            set_rcode(static_cast<::android::stats::dnsresolver::NsRcode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .android.stats.dnsresolver.NsType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::android::stats::dnsresolver::NsType_IsValid(val))) {
            set_type(static_cast<::android::stats::dnsresolver::NsType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .android.stats.dnsresolver.CacheStatus cache_hit = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::android::stats::dnsresolver::CacheStatus_IsValid(val))) {
            set_cache_hit(static_cast<::android::stats::dnsresolver::CacheStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .android.stats.dnsresolver.IpVersion ip_version = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::android::stats::dnsresolver::IpVersion_IsValid(val))) {
            set_ip_version(static_cast<::android::stats::dnsresolver::IpVersion>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .android.stats.dnsresolver.Protocol protocol = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::android::stats::dnsresolver::Protocol_IsValid(val))) {
            set_protocol(static_cast<::android::stats::dnsresolver::Protocol>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional int32 retry_times = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_retry_times(&has_bits);
          retry_times_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 dns_server_index = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_dns_server_index(&has_bits);
          dns_server_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool connected = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_connected(&has_bits);
          connected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 latency_micros = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_latency_micros(&has_bits);
          latency_micros_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.stats.dnsresolver.LinuxErrno linux_errno = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::android::stats::dnsresolver::LinuxErrno_IsValid(val))) {
            set_linux_errno(static_cast<::android::stats::dnsresolver::LinuxErrno>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool DnsQueryEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.stats.dnsresolver.DnsQueryEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .android.stats.dnsresolver.NsRcode rcode = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::stats::dnsresolver::NsRcode_IsValid(value)) {
            set_rcode(static_cast< ::android::stats::dnsresolver::NsRcode >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.stats.dnsresolver.NsType type = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::stats::dnsresolver::NsType_IsValid(value)) {
            set_type(static_cast< ::android::stats::dnsresolver::NsType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.stats.dnsresolver.CacheStatus cache_hit = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::stats::dnsresolver::CacheStatus_IsValid(value)) {
            set_cache_hit(static_cast< ::android::stats::dnsresolver::CacheStatus >(value));
          } else {
            unknown_fields_stream.WriteVarint32(24u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.stats.dnsresolver.IpVersion ip_version = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::stats::dnsresolver::IpVersion_IsValid(value)) {
            set_ip_version(static_cast< ::android::stats::dnsresolver::IpVersion >(value));
          } else {
            unknown_fields_stream.WriteVarint32(32u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.stats.dnsresolver.Protocol protocol = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::stats::dnsresolver::Protocol_IsValid(value)) {
            set_protocol(static_cast< ::android::stats::dnsresolver::Protocol >(value));
          } else {
            unknown_fields_stream.WriteVarint32(40u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 retry_times = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_retry_times(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &retry_times_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 dns_server_index = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_dns_server_index(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &dns_server_index_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool connected = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          _Internal::set_has_connected(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &connected_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 latency_micros = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          _Internal::set_has_latency_micros(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &latency_micros_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.stats.dnsresolver.LinuxErrno linux_errno = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (80 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::stats::dnsresolver::LinuxErrno_IsValid(value)) {
            set_linux_errno(static_cast< ::android::stats::dnsresolver::LinuxErrno >(value));
          } else {
            unknown_fields_stream.WriteVarint32(80u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.stats.dnsresolver.DnsQueryEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.stats.dnsresolver.DnsQueryEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void DnsQueryEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.stats.dnsresolver.DnsQueryEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.stats.dnsresolver.NsRcode rcode = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->rcode(), output);
  }

  // optional .android.stats.dnsresolver.NsType type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // optional .android.stats.dnsresolver.CacheStatus cache_hit = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      3, this->cache_hit(), output);
  }

  // optional .android.stats.dnsresolver.IpVersion ip_version = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      4, this->ip_version(), output);
  }

  // optional .android.stats.dnsresolver.Protocol protocol = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      5, this->protocol(), output);
  }

  // optional int32 retry_times = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(6, this->retry_times(), output);
  }

  // optional int32 dns_server_index = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(7, this->dns_server_index(), output);
  }

  // optional bool connected = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(8, this->connected(), output);
  }

  // optional int32 latency_micros = 9;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(9, this->latency_micros(), output);
  }

  // optional .android.stats.dnsresolver.LinuxErrno linux_errno = 10;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      10, this->linux_errno(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.stats.dnsresolver.DnsQueryEvent)
}

size_t DnsQueryEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.stats.dnsresolver.DnsQueryEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .android.stats.dnsresolver.NsRcode rcode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->rcode());
    }

    // optional .android.stats.dnsresolver.NsType type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .android.stats.dnsresolver.CacheStatus cache_hit = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->cache_hit());
    }

    // optional .android.stats.dnsresolver.IpVersion ip_version = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->ip_version());
    }

    // optional .android.stats.dnsresolver.Protocol protocol = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->protocol());
    }

    // optional int32 retry_times = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->retry_times());
    }

    // optional int32 dns_server_index = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->dns_server_index());
    }

    // optional bool connected = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional int32 latency_micros = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->latency_micros());
    }

    // optional .android.stats.dnsresolver.LinuxErrno linux_errno = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->linux_errno());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DnsQueryEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DnsQueryEvent*>(
      &from));
}

void DnsQueryEvent::MergeFrom(const DnsQueryEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.stats.dnsresolver.DnsQueryEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      rcode_ = from.rcode_;
    }
    if (cached_has_bits & 0x00000002u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000004u) {
      cache_hit_ = from.cache_hit_;
    }
    if (cached_has_bits & 0x00000008u) {
      ip_version_ = from.ip_version_;
    }
    if (cached_has_bits & 0x00000010u) {
      protocol_ = from.protocol_;
    }
    if (cached_has_bits & 0x00000020u) {
      retry_times_ = from.retry_times_;
    }
    if (cached_has_bits & 0x00000040u) {
      dns_server_index_ = from.dns_server_index_;
    }
    if (cached_has_bits & 0x00000080u) {
      connected_ = from.connected_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      latency_micros_ = from.latency_micros_;
    }
    if (cached_has_bits & 0x00000200u) {
      linux_errno_ = from.linux_errno_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DnsQueryEvent::CopyFrom(const DnsQueryEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.stats.dnsresolver.DnsQueryEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DnsQueryEvent::IsInitialized() const {
  return true;
}

void DnsQueryEvent::InternalSwap(DnsQueryEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(rcode_, other->rcode_);
  swap(type_, other->type_);
  swap(cache_hit_, other->cache_hit_);
  swap(ip_version_, other->ip_version_);
  swap(protocol_, other->protocol_);
  swap(retry_times_, other->retry_times_);
  swap(dns_server_index_, other->dns_server_index_);
  swap(connected_, other->connected_);
  swap(latency_micros_, other->latency_micros_);
  swap(linux_errno_, other->linux_errno_);
}

std::string DnsQueryEvent::GetTypeName() const {
  return "android.stats.dnsresolver.DnsQueryEvent";
}


// ===================================================================

void DnsQueryEvents::InitAsDefaultInstance() {
}
class DnsQueryEvents::_Internal {
 public:
  using HasBits = decltype(std::declval<DnsQueryEvents>()._has_bits_);
};

DnsQueryEvents::DnsQueryEvents()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.stats.dnsresolver.DnsQueryEvents)
}
DnsQueryEvents::DnsQueryEvents(const DnsQueryEvents& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      dns_query_event_(from.dns_query_event_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:android.stats.dnsresolver.DnsQueryEvents)
}

void DnsQueryEvents::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_DnsQueryEvents_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fdnsresolver_2fdns_5fresolver_2eproto.base);
}

DnsQueryEvents::~DnsQueryEvents() {
  // @@protoc_insertion_point(destructor:android.stats.dnsresolver.DnsQueryEvents)
  SharedDtor();
}

void DnsQueryEvents::SharedDtor() {
}

void DnsQueryEvents::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DnsQueryEvents& DnsQueryEvents::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_DnsQueryEvents_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fdnsresolver_2fdns_5fresolver_2eproto.base);
  return *internal_default_instance();
}


void DnsQueryEvents::Clear() {
// @@protoc_insertion_point(message_clear_start:android.stats.dnsresolver.DnsQueryEvents)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  dns_query_event_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* DnsQueryEvents::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .android.stats.dnsresolver.DnsQueryEvent dns_query_event = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_dns_query_event(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool DnsQueryEvents::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.stats.dnsresolver.DnsQueryEvents)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .android.stats.dnsresolver.DnsQueryEvent dns_query_event = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_dns_query_event()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.stats.dnsresolver.DnsQueryEvents)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.stats.dnsresolver.DnsQueryEvents)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void DnsQueryEvents::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.stats.dnsresolver.DnsQueryEvents)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .android.stats.dnsresolver.DnsQueryEvent dns_query_event = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->dns_query_event_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1,
      this->dns_query_event(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.stats.dnsresolver.DnsQueryEvents)
}

size_t DnsQueryEvents::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.stats.dnsresolver.DnsQueryEvents)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.stats.dnsresolver.DnsQueryEvent dns_query_event = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->dns_query_event_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->dns_query_event(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DnsQueryEvents::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DnsQueryEvents*>(
      &from));
}

void DnsQueryEvents::MergeFrom(const DnsQueryEvents& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.stats.dnsresolver.DnsQueryEvents)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  dns_query_event_.MergeFrom(from.dns_query_event_);
}

void DnsQueryEvents::CopyFrom(const DnsQueryEvents& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.stats.dnsresolver.DnsQueryEvents)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DnsQueryEvents::IsInitialized() const {
  return true;
}

void DnsQueryEvents::InternalSwap(DnsQueryEvents* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&dns_query_event_)->InternalSwap(CastToBase(&other->dns_query_event_));
}

std::string DnsQueryEvents::GetTypeName() const {
  return "android.stats.dnsresolver.DnsQueryEvents";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace dnsresolver
}  // namespace stats
}  // namespace android
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::android::stats::dnsresolver::DnsQueryEvent* Arena::CreateMaybeMessage< ::android::stats::dnsresolver::DnsQueryEvent >(Arena* arena) {
  return Arena::CreateInternal< ::android::stats::dnsresolver::DnsQueryEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::android::stats::dnsresolver::DnsQueryEvents* Arena::CreateMaybeMessage< ::android::stats::dnsresolver::DnsQueryEvents >(Arena* arena) {
  return Arena::CreateInternal< ::android::stats::dnsresolver::DnsQueryEvents >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
