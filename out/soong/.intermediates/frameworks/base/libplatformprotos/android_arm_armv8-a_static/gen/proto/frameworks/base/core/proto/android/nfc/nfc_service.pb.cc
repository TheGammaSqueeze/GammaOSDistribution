// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/base/core/proto/android/nfc/nfc_service.proto

#include "frameworks/base/core/proto/android/nfc/nfc_service.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fapp_2fpendingintent_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PendingIntentProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fapp_2fpendingintent_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fcontent_2fintent_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_IntentFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fcontent_2fintent_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fndef_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_NdefMessageProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fndef_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DiscoveryParamsProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_NfcDispatcherProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_P2pLinkManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fcard_5femulation_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<8> scc_info_CardEmulationManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fcard_5femulation_2eproto;
namespace com {
namespace android {
namespace nfc {
class NfcServiceDumpProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<NfcServiceDumpProto> _instance;
} _NfcServiceDumpProto_default_instance_;
class DiscoveryParamsProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DiscoveryParamsProto> _instance;
} _DiscoveryParamsProto_default_instance_;
class P2pLinkManagerProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<P2pLinkManagerProto> _instance;
} _P2pLinkManagerProto_default_instance_;
class NfcDispatcherProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<NfcDispatcherProto> _instance;
} _NfcDispatcherProto_default_instance_;
}  // namespace nfc
}  // namespace android
}  // namespace com
static void InitDefaultsscc_info_DiscoveryParamsProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::com::android::nfc::_DiscoveryParamsProto_default_instance_;
    new (ptr) ::com::android::nfc::DiscoveryParamsProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::com::android::nfc::DiscoveryParamsProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DiscoveryParamsProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_DiscoveryParamsProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto}, {}};

static void InitDefaultsscc_info_NfcDispatcherProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::com::android::nfc::_NfcDispatcherProto_default_instance_;
    new (ptr) ::com::android::nfc::NfcDispatcherProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::com::android::nfc::NfcDispatcherProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_NfcDispatcherProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_NfcDispatcherProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto}, {
      &scc_info_PendingIntentProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fapp_2fpendingintent_2eproto.base,
      &scc_info_IntentFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fcontent_2fintent_2eproto.base,}};

static void InitDefaultsscc_info_NfcServiceDumpProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::com::android::nfc::_NfcServiceDumpProto_default_instance_;
    new (ptr) ::com::android::nfc::NfcServiceDumpProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::com::android::nfc::NfcServiceDumpProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_NfcServiceDumpProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 4, InitDefaultsscc_info_NfcServiceDumpProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto}, {
      &scc_info_DiscoveryParamsProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto.base,
      &scc_info_P2pLinkManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto.base,
      &scc_info_CardEmulationManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fcard_5femulation_2eproto.base,
      &scc_info_NfcDispatcherProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto.base,}};

static void InitDefaultsscc_info_P2pLinkManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::com::android::nfc::_P2pLinkManagerProto_default_instance_;
    new (ptr) ::com::android::nfc::P2pLinkManagerProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::com::android::nfc::P2pLinkManagerProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_P2pLinkManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_P2pLinkManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto}, {
      &scc_info_NdefMessageProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fndef_2eproto.base,}};

namespace com {
namespace android {
namespace nfc {
bool NfcServiceDumpProto_State_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NfcServiceDumpProto_State_strings[5] = {};

static const char NfcServiceDumpProto_State_names[] =
  "STATE_OFF"
  "STATE_ON"
  "STATE_TURNING_OFF"
  "STATE_TURNING_ON"
  "STATE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NfcServiceDumpProto_State_entries[] = {
  { {NfcServiceDumpProto_State_names + 0, 9}, 1 },
  { {NfcServiceDumpProto_State_names + 9, 8}, 3 },
  { {NfcServiceDumpProto_State_names + 17, 17}, 4 },
  { {NfcServiceDumpProto_State_names + 34, 16}, 2 },
  { {NfcServiceDumpProto_State_names + 50, 13}, 0 },
};

static const int NfcServiceDumpProto_State_entries_by_number[] = {
  4, // 0 -> STATE_UNKNOWN
  0, // 1 -> STATE_OFF
  3, // 2 -> STATE_TURNING_ON
  1, // 3 -> STATE_ON
  2, // 4 -> STATE_TURNING_OFF
};

const std::string& NfcServiceDumpProto_State_Name(
    NfcServiceDumpProto_State value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NfcServiceDumpProto_State_entries,
          NfcServiceDumpProto_State_entries_by_number,
          5, NfcServiceDumpProto_State_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NfcServiceDumpProto_State_entries,
      NfcServiceDumpProto_State_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NfcServiceDumpProto_State_strings[idx].get();
}
bool NfcServiceDumpProto_State_Parse(
    const std::string& name, NfcServiceDumpProto_State* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NfcServiceDumpProto_State_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<NfcServiceDumpProto_State>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr NfcServiceDumpProto_State NfcServiceDumpProto::STATE_UNKNOWN;
constexpr NfcServiceDumpProto_State NfcServiceDumpProto::STATE_OFF;
constexpr NfcServiceDumpProto_State NfcServiceDumpProto::STATE_TURNING_ON;
constexpr NfcServiceDumpProto_State NfcServiceDumpProto::STATE_ON;
constexpr NfcServiceDumpProto_State NfcServiceDumpProto::STATE_TURNING_OFF;
constexpr NfcServiceDumpProto_State NfcServiceDumpProto::State_MIN;
constexpr NfcServiceDumpProto_State NfcServiceDumpProto::State_MAX;
constexpr int NfcServiceDumpProto::State_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool NfcServiceDumpProto_ScreenState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NfcServiceDumpProto_ScreenState_strings[5] = {};

static const char NfcServiceDumpProto_ScreenState_names[] =
  "SCREEN_STATE_OFF_LOCKED"
  "SCREEN_STATE_OFF_UNLOCKED"
  "SCREEN_STATE_ON_LOCKED"
  "SCREEN_STATE_ON_UNLOCKED"
  "SCREEN_STATE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NfcServiceDumpProto_ScreenState_entries[] = {
  { {NfcServiceDumpProto_ScreenState_names + 0, 23}, 2 },
  { {NfcServiceDumpProto_ScreenState_names + 23, 25}, 1 },
  { {NfcServiceDumpProto_ScreenState_names + 48, 22}, 3 },
  { {NfcServiceDumpProto_ScreenState_names + 70, 24}, 4 },
  { {NfcServiceDumpProto_ScreenState_names + 94, 20}, 0 },
};

static const int NfcServiceDumpProto_ScreenState_entries_by_number[] = {
  4, // 0 -> SCREEN_STATE_UNKNOWN
  1, // 1 -> SCREEN_STATE_OFF_UNLOCKED
  0, // 2 -> SCREEN_STATE_OFF_LOCKED
  2, // 3 -> SCREEN_STATE_ON_LOCKED
  3, // 4 -> SCREEN_STATE_ON_UNLOCKED
};

const std::string& NfcServiceDumpProto_ScreenState_Name(
    NfcServiceDumpProto_ScreenState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NfcServiceDumpProto_ScreenState_entries,
          NfcServiceDumpProto_ScreenState_entries_by_number,
          5, NfcServiceDumpProto_ScreenState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NfcServiceDumpProto_ScreenState_entries,
      NfcServiceDumpProto_ScreenState_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NfcServiceDumpProto_ScreenState_strings[idx].get();
}
bool NfcServiceDumpProto_ScreenState_Parse(
    const std::string& name, NfcServiceDumpProto_ScreenState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NfcServiceDumpProto_ScreenState_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<NfcServiceDumpProto_ScreenState>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr NfcServiceDumpProto_ScreenState NfcServiceDumpProto::SCREEN_STATE_UNKNOWN;
constexpr NfcServiceDumpProto_ScreenState NfcServiceDumpProto::SCREEN_STATE_OFF_UNLOCKED;
constexpr NfcServiceDumpProto_ScreenState NfcServiceDumpProto::SCREEN_STATE_OFF_LOCKED;
constexpr NfcServiceDumpProto_ScreenState NfcServiceDumpProto::SCREEN_STATE_ON_LOCKED;
constexpr NfcServiceDumpProto_ScreenState NfcServiceDumpProto::SCREEN_STATE_ON_UNLOCKED;
constexpr NfcServiceDumpProto_ScreenState NfcServiceDumpProto::ScreenState_MIN;
constexpr NfcServiceDumpProto_ScreenState NfcServiceDumpProto::ScreenState_MAX;
constexpr int NfcServiceDumpProto::ScreenState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool P2pLinkManagerProto_LinkState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> P2pLinkManagerProto_LinkState_strings[4] = {};

static const char P2pLinkManagerProto_LinkState_names[] =
  "LINK_STATE_DEBOUNCE"
  "LINK_STATE_DOWN"
  "LINK_STATE_UNKNOWN"
  "LINK_STATE_UP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry P2pLinkManagerProto_LinkState_entries[] = {
  { {P2pLinkManagerProto_LinkState_names + 0, 19}, 2 },
  { {P2pLinkManagerProto_LinkState_names + 19, 15}, 1 },
  { {P2pLinkManagerProto_LinkState_names + 34, 18}, 0 },
  { {P2pLinkManagerProto_LinkState_names + 52, 13}, 3 },
};

static const int P2pLinkManagerProto_LinkState_entries_by_number[] = {
  2, // 0 -> LINK_STATE_UNKNOWN
  1, // 1 -> LINK_STATE_DOWN
  0, // 2 -> LINK_STATE_DEBOUNCE
  3, // 3 -> LINK_STATE_UP
};

const std::string& P2pLinkManagerProto_LinkState_Name(
    P2pLinkManagerProto_LinkState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          P2pLinkManagerProto_LinkState_entries,
          P2pLinkManagerProto_LinkState_entries_by_number,
          4, P2pLinkManagerProto_LinkState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      P2pLinkManagerProto_LinkState_entries,
      P2pLinkManagerProto_LinkState_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     P2pLinkManagerProto_LinkState_strings[idx].get();
}
bool P2pLinkManagerProto_LinkState_Parse(
    const std::string& name, P2pLinkManagerProto_LinkState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      P2pLinkManagerProto_LinkState_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<P2pLinkManagerProto_LinkState>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr P2pLinkManagerProto_LinkState P2pLinkManagerProto::LINK_STATE_UNKNOWN;
constexpr P2pLinkManagerProto_LinkState P2pLinkManagerProto::LINK_STATE_DOWN;
constexpr P2pLinkManagerProto_LinkState P2pLinkManagerProto::LINK_STATE_DEBOUNCE;
constexpr P2pLinkManagerProto_LinkState P2pLinkManagerProto::LINK_STATE_UP;
constexpr P2pLinkManagerProto_LinkState P2pLinkManagerProto::LinkState_MIN;
constexpr P2pLinkManagerProto_LinkState P2pLinkManagerProto::LinkState_MAX;
constexpr int P2pLinkManagerProto::LinkState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool P2pLinkManagerProto_SendState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> P2pLinkManagerProto_SendState_strings[6] = {};

static const char P2pLinkManagerProto_SendState_names[] =
  "SEND_STATE_CANCELED"
  "SEND_STATE_COMPLETE"
  "SEND_STATE_NEED_CONFIRMATION"
  "SEND_STATE_NOTHING_TO_SEND"
  "SEND_STATE_SENDING"
  "SEND_STATE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry P2pLinkManagerProto_SendState_entries[] = {
  { {P2pLinkManagerProto_SendState_names + 0, 19}, 5 },
  { {P2pLinkManagerProto_SendState_names + 19, 19}, 4 },
  { {P2pLinkManagerProto_SendState_names + 38, 28}, 2 },
  { {P2pLinkManagerProto_SendState_names + 66, 26}, 1 },
  { {P2pLinkManagerProto_SendState_names + 92, 18}, 3 },
  { {P2pLinkManagerProto_SendState_names + 110, 18}, 0 },
};

static const int P2pLinkManagerProto_SendState_entries_by_number[] = {
  5, // 0 -> SEND_STATE_UNKNOWN
  3, // 1 -> SEND_STATE_NOTHING_TO_SEND
  2, // 2 -> SEND_STATE_NEED_CONFIRMATION
  4, // 3 -> SEND_STATE_SENDING
  1, // 4 -> SEND_STATE_COMPLETE
  0, // 5 -> SEND_STATE_CANCELED
};

const std::string& P2pLinkManagerProto_SendState_Name(
    P2pLinkManagerProto_SendState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          P2pLinkManagerProto_SendState_entries,
          P2pLinkManagerProto_SendState_entries_by_number,
          6, P2pLinkManagerProto_SendState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      P2pLinkManagerProto_SendState_entries,
      P2pLinkManagerProto_SendState_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     P2pLinkManagerProto_SendState_strings[idx].get();
}
bool P2pLinkManagerProto_SendState_Parse(
    const std::string& name, P2pLinkManagerProto_SendState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      P2pLinkManagerProto_SendState_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<P2pLinkManagerProto_SendState>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr P2pLinkManagerProto_SendState P2pLinkManagerProto::SEND_STATE_UNKNOWN;
constexpr P2pLinkManagerProto_SendState P2pLinkManagerProto::SEND_STATE_NOTHING_TO_SEND;
constexpr P2pLinkManagerProto_SendState P2pLinkManagerProto::SEND_STATE_NEED_CONFIRMATION;
constexpr P2pLinkManagerProto_SendState P2pLinkManagerProto::SEND_STATE_SENDING;
constexpr P2pLinkManagerProto_SendState P2pLinkManagerProto::SEND_STATE_COMPLETE;
constexpr P2pLinkManagerProto_SendState P2pLinkManagerProto::SEND_STATE_CANCELED;
constexpr P2pLinkManagerProto_SendState P2pLinkManagerProto::SendState_MIN;
constexpr P2pLinkManagerProto_SendState P2pLinkManagerProto::SendState_MAX;
constexpr int P2pLinkManagerProto::SendState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void NfcServiceDumpProto::InitAsDefaultInstance() {
  ::com::android::nfc::_NfcServiceDumpProto_default_instance_._instance.get_mutable()->discovery_params_ = const_cast< ::com::android::nfc::DiscoveryParamsProto*>(
      ::com::android::nfc::DiscoveryParamsProto::internal_default_instance());
  ::com::android::nfc::_NfcServiceDumpProto_default_instance_._instance.get_mutable()->p2p_link_manager_ = const_cast< ::com::android::nfc::P2pLinkManagerProto*>(
      ::com::android::nfc::P2pLinkManagerProto::internal_default_instance());
  ::com::android::nfc::_NfcServiceDumpProto_default_instance_._instance.get_mutable()->card_emulation_manager_ = const_cast< ::com::android::nfc::cardemulation::CardEmulationManagerProto*>(
      ::com::android::nfc::cardemulation::CardEmulationManagerProto::internal_default_instance());
  ::com::android::nfc::_NfcServiceDumpProto_default_instance_._instance.get_mutable()->nfc_dispatcher_ = const_cast< ::com::android::nfc::NfcDispatcherProto*>(
      ::com::android::nfc::NfcDispatcherProto::internal_default_instance());
}
class NfcServiceDumpProto::_Internal {
 public:
  using HasBits = decltype(std::declval<NfcServiceDumpProto>()._has_bits_);
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_in_provision_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_ndef_push_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_screen_state(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_secure_nfc_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_polling_paused(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_num_tags_detected(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_num_p2p_detected(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_num_hce_detected(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_hce_capable(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_hce_f_capable(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_beam_capable(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_secure_nfc_capable(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_vr_mode_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static const ::com::android::nfc::DiscoveryParamsProto& discovery_params(const NfcServiceDumpProto* msg);
  static void set_has_discovery_params(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::com::android::nfc::P2pLinkManagerProto& p2p_link_manager(const NfcServiceDumpProto* msg);
  static void set_has_p2p_link_manager(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::com::android::nfc::cardemulation::CardEmulationManagerProto& card_emulation_manager(const NfcServiceDumpProto* msg);
  static void set_has_card_emulation_manager(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::com::android::nfc::NfcDispatcherProto& nfc_dispatcher(const NfcServiceDumpProto* msg);
  static void set_has_nfc_dispatcher(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_native_crash_logs(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::com::android::nfc::DiscoveryParamsProto&
NfcServiceDumpProto::_Internal::discovery_params(const NfcServiceDumpProto* msg) {
  return *msg->discovery_params_;
}
const ::com::android::nfc::P2pLinkManagerProto&
NfcServiceDumpProto::_Internal::p2p_link_manager(const NfcServiceDumpProto* msg) {
  return *msg->p2p_link_manager_;
}
const ::com::android::nfc::cardemulation::CardEmulationManagerProto&
NfcServiceDumpProto::_Internal::card_emulation_manager(const NfcServiceDumpProto* msg) {
  return *msg->card_emulation_manager_;
}
const ::com::android::nfc::NfcDispatcherProto&
NfcServiceDumpProto::_Internal::nfc_dispatcher(const NfcServiceDumpProto* msg) {
  return *msg->nfc_dispatcher_;
}
void NfcServiceDumpProto::clear_card_emulation_manager() {
  if (card_emulation_manager_ != nullptr) card_emulation_manager_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
NfcServiceDumpProto::NfcServiceDumpProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.android.nfc.NfcServiceDumpProto)
}
NfcServiceDumpProto::NfcServiceDumpProto(const NfcServiceDumpProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  native_crash_logs_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_native_crash_logs()) {
    native_crash_logs_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.native_crash_logs_);
  }
  if (from.has_discovery_params()) {
    discovery_params_ = new ::com::android::nfc::DiscoveryParamsProto(*from.discovery_params_);
  } else {
    discovery_params_ = nullptr;
  }
  if (from.has_p2p_link_manager()) {
    p2p_link_manager_ = new ::com::android::nfc::P2pLinkManagerProto(*from.p2p_link_manager_);
  } else {
    p2p_link_manager_ = nullptr;
  }
  if (from.has_card_emulation_manager()) {
    card_emulation_manager_ = new ::com::android::nfc::cardemulation::CardEmulationManagerProto(*from.card_emulation_manager_);
  } else {
    card_emulation_manager_ = nullptr;
  }
  if (from.has_nfc_dispatcher()) {
    nfc_dispatcher_ = new ::com::android::nfc::NfcDispatcherProto(*from.nfc_dispatcher_);
  } else {
    nfc_dispatcher_ = nullptr;
  }
  ::memcpy(&state_, &from.state_,
    static_cast<size_t>(reinterpret_cast<char*>(&vr_mode_enabled_) -
    reinterpret_cast<char*>(&state_)) + sizeof(vr_mode_enabled_));
  // @@protoc_insertion_point(copy_constructor:com.android.nfc.NfcServiceDumpProto)
}

void NfcServiceDumpProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_NfcServiceDumpProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto.base);
  native_crash_logs_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&discovery_params_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&vr_mode_enabled_) -
      reinterpret_cast<char*>(&discovery_params_)) + sizeof(vr_mode_enabled_));
}

NfcServiceDumpProto::~NfcServiceDumpProto() {
  // @@protoc_insertion_point(destructor:com.android.nfc.NfcServiceDumpProto)
  SharedDtor();
}

void NfcServiceDumpProto::SharedDtor() {
  native_crash_logs_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete discovery_params_;
  if (this != internal_default_instance()) delete p2p_link_manager_;
  if (this != internal_default_instance()) delete card_emulation_manager_;
  if (this != internal_default_instance()) delete nfc_dispatcher_;
}

void NfcServiceDumpProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NfcServiceDumpProto& NfcServiceDumpProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_NfcServiceDumpProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto.base);
  return *internal_default_instance();
}


void NfcServiceDumpProto::Clear() {
// @@protoc_insertion_point(message_clear_start:com.android.nfc.NfcServiceDumpProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      native_crash_logs_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(discovery_params_ != nullptr);
      discovery_params_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(p2p_link_manager_ != nullptr);
      p2p_link_manager_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(card_emulation_manager_ != nullptr);
      card_emulation_manager_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(nfc_dispatcher_ != nullptr);
      nfc_dispatcher_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&state_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&in_provision_mode_) -
        reinterpret_cast<char*>(&state_)) + sizeof(in_provision_mode_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&ndef_push_enabled_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&hce_f_capable_) -
        reinterpret_cast<char*>(&ndef_push_enabled_)) + sizeof(hce_f_capable_));
  }
  if (cached_has_bits & 0x00070000u) {
    ::memset(&beam_capable_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&vr_mode_enabled_) -
        reinterpret_cast<char*>(&beam_capable_)) + sizeof(vr_mode_enabled_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* NfcServiceDumpProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .com.android.nfc.NfcServiceDumpProto.State state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::com::android::nfc::NfcServiceDumpProto_State_IsValid(val))) {
            set_state(static_cast<::com::android::nfc::NfcServiceDumpProto_State>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool in_provision_mode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_in_provision_mode(&has_bits);
          in_provision_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool ndef_push_enabled = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_ndef_push_enabled(&has_bits);
          ndef_push_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .com.android.nfc.NfcServiceDumpProto.ScreenState screen_state = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::com::android::nfc::NfcServiceDumpProto_ScreenState_IsValid(val))) {
            set_screen_state(static_cast<::com::android::nfc::NfcServiceDumpProto_ScreenState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool secure_nfc_enabled = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_secure_nfc_enabled(&has_bits);
          secure_nfc_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool polling_paused = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_polling_paused(&has_bits);
          polling_paused_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_tags_detected = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_num_tags_detected(&has_bits);
          num_tags_detected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_p2p_detected = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_num_p2p_detected(&has_bits);
          num_p2p_detected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_hce_detected = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_num_hce_detected(&has_bits);
          num_hce_detected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool hce_capable = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_hce_capable(&has_bits);
          hce_capable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool hce_f_capable = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_hce_f_capable(&has_bits);
          hce_f_capable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool beam_capable = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_beam_capable(&has_bits);
          beam_capable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool secure_nfc_capable = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_secure_nfc_capable(&has_bits);
          secure_nfc_capable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool vr_mode_enabled = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_vr_mode_enabled(&has_bits);
          vr_mode_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .com.android.nfc.DiscoveryParamsProto discovery_params = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 122)) {
          ptr = ctx->ParseMessage(mutable_discovery_params(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .com.android.nfc.P2pLinkManagerProto p2p_link_manager = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 130)) {
          ptr = ctx->ParseMessage(mutable_p2p_link_manager(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .com.android.nfc.cardemulation.CardEmulationManagerProto card_emulation_manager = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 138)) {
          ptr = ctx->ParseMessage(mutable_card_emulation_manager(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .com.android.nfc.NfcDispatcherProto nfc_dispatcher = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 146)) {
          ptr = ctx->ParseMessage(mutable_nfc_dispatcher(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string native_crash_logs = 19 [(.android.privacy) = {
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 154)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_native_crash_logs(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool NfcServiceDumpProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:com.android.nfc.NfcServiceDumpProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .com.android.nfc.NfcServiceDumpProto.State state = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::android::nfc::NfcServiceDumpProto_State_IsValid(value)) {
            set_state(static_cast< ::com::android::nfc::NfcServiceDumpProto_State >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool in_provision_mode = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_in_provision_mode(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &in_provision_mode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool ndef_push_enabled = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_ndef_push_enabled(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &ndef_push_enabled_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .com.android.nfc.NfcServiceDumpProto.ScreenState screen_state = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::android::nfc::NfcServiceDumpProto_ScreenState_IsValid(value)) {
            set_screen_state(static_cast< ::com::android::nfc::NfcServiceDumpProto_ScreenState >(value));
          } else {
            unknown_fields_stream.WriteVarint32(32u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool secure_nfc_enabled = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_secure_nfc_enabled(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &secure_nfc_enabled_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool polling_paused = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_polling_paused(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &polling_paused_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_tags_detected = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_num_tags_detected(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_tags_detected_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_p2p_detected = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          _Internal::set_has_num_p2p_detected(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_p2p_detected_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_hce_detected = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          _Internal::set_has_num_hce_detected(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_hce_detected_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool hce_capable = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (80 & 0xFF)) {
          _Internal::set_has_hce_capable(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &hce_capable_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool hce_f_capable = 11;
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (88 & 0xFF)) {
          _Internal::set_has_hce_f_capable(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &hce_f_capable_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool beam_capable = 12;
      case 12: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (96 & 0xFF)) {
          _Internal::set_has_beam_capable(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &beam_capable_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool secure_nfc_capable = 13;
      case 13: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (104 & 0xFF)) {
          _Internal::set_has_secure_nfc_capable(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &secure_nfc_capable_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool vr_mode_enabled = 14;
      case 14: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (112 & 0xFF)) {
          _Internal::set_has_vr_mode_enabled(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &vr_mode_enabled_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .com.android.nfc.DiscoveryParamsProto discovery_params = 15;
      case 15: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (122 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_discovery_params()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .com.android.nfc.P2pLinkManagerProto p2p_link_manager = 16;
      case 16: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (130 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_p2p_link_manager()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .com.android.nfc.cardemulation.CardEmulationManagerProto card_emulation_manager = 17;
      case 17: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (138 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_card_emulation_manager()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .com.android.nfc.NfcDispatcherProto nfc_dispatcher = 18;
      case 18: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (146 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_nfc_dispatcher()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string native_crash_logs = 19 [(.android.privacy) = {
      case 19: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (154 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_native_crash_logs()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.android.nfc.NfcServiceDumpProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.android.nfc.NfcServiceDumpProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void NfcServiceDumpProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.android.nfc.NfcServiceDumpProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .com.android.nfc.NfcServiceDumpProto.State state = 1;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->state(), output);
  }

  // optional bool in_provision_mode = 2;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(2, this->in_provision_mode(), output);
  }

  // optional bool ndef_push_enabled = 3;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(3, this->ndef_push_enabled(), output);
  }

  // optional .com.android.nfc.NfcServiceDumpProto.ScreenState screen_state = 4;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      4, this->screen_state(), output);
  }

  // optional bool secure_nfc_enabled = 5;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(5, this->secure_nfc_enabled(), output);
  }

  // optional bool polling_paused = 6;
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(6, this->polling_paused(), output);
  }

  // optional int32 num_tags_detected = 7;
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(7, this->num_tags_detected(), output);
  }

  // optional int32 num_p2p_detected = 8;
  if (cached_has_bits & 0x00001000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(8, this->num_p2p_detected(), output);
  }

  // optional int32 num_hce_detected = 9;
  if (cached_has_bits & 0x00002000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(9, this->num_hce_detected(), output);
  }

  // optional bool hce_capable = 10;
  if (cached_has_bits & 0x00004000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(10, this->hce_capable(), output);
  }

  // optional bool hce_f_capable = 11;
  if (cached_has_bits & 0x00008000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(11, this->hce_f_capable(), output);
  }

  // optional bool beam_capable = 12;
  if (cached_has_bits & 0x00010000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(12, this->beam_capable(), output);
  }

  // optional bool secure_nfc_capable = 13;
  if (cached_has_bits & 0x00020000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(13, this->secure_nfc_capable(), output);
  }

  // optional bool vr_mode_enabled = 14;
  if (cached_has_bits & 0x00040000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(14, this->vr_mode_enabled(), output);
  }

  // optional .com.android.nfc.DiscoveryParamsProto discovery_params = 15;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      15, _Internal::discovery_params(this), output);
  }

  // optional .com.android.nfc.P2pLinkManagerProto p2p_link_manager = 16;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      16, _Internal::p2p_link_manager(this), output);
  }

  // optional .com.android.nfc.cardemulation.CardEmulationManagerProto card_emulation_manager = 17;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      17, _Internal::card_emulation_manager(this), output);
  }

  // optional .com.android.nfc.NfcDispatcherProto nfc_dispatcher = 18;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      18, _Internal::nfc_dispatcher(this), output);
  }

  // optional string native_crash_logs = 19 [(.android.privacy) = {
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      19, this->native_crash_logs(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:com.android.nfc.NfcServiceDumpProto)
}

size_t NfcServiceDumpProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.android.nfc.NfcServiceDumpProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string native_crash_logs = 19 [(.android.privacy) = {
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->native_crash_logs());
    }

    // optional .com.android.nfc.DiscoveryParamsProto discovery_params = 15;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *discovery_params_);
    }

    // optional .com.android.nfc.P2pLinkManagerProto p2p_link_manager = 16;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *p2p_link_manager_);
    }

    // optional .com.android.nfc.cardemulation.CardEmulationManagerProto card_emulation_manager = 17;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *card_emulation_manager_);
    }

    // optional .com.android.nfc.NfcDispatcherProto nfc_dispatcher = 18;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *nfc_dispatcher_);
    }

    // optional .com.android.nfc.NfcServiceDumpProto.State state = 1;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->state());
    }

    // optional .com.android.nfc.NfcServiceDumpProto.ScreenState screen_state = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->screen_state());
    }

    // optional bool in_provision_mode = 2;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool ndef_push_enabled = 3;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool secure_nfc_enabled = 5;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool polling_paused = 6;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional int32 num_tags_detected = 7;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_tags_detected());
    }

    // optional int32 num_p2p_detected = 8;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_p2p_detected());
    }

    // optional int32 num_hce_detected = 9;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_hce_detected());
    }

    // optional bool hce_capable = 10;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional bool hce_f_capable = 11;
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00070000u) {
    // optional bool beam_capable = 12;
    if (cached_has_bits & 0x00010000u) {
      total_size += 1 + 1;
    }

    // optional bool secure_nfc_capable = 13;
    if (cached_has_bits & 0x00020000u) {
      total_size += 1 + 1;
    }

    // optional bool vr_mode_enabled = 14;
    if (cached_has_bits & 0x00040000u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NfcServiceDumpProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const NfcServiceDumpProto*>(
      &from));
}

void NfcServiceDumpProto::MergeFrom(const NfcServiceDumpProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:com.android.nfc.NfcServiceDumpProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      native_crash_logs_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.native_crash_logs_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_discovery_params()->::com::android::nfc::DiscoveryParamsProto::MergeFrom(from.discovery_params());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_p2p_link_manager()->::com::android::nfc::P2pLinkManagerProto::MergeFrom(from.p2p_link_manager());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_card_emulation_manager()->::com::android::nfc::cardemulation::CardEmulationManagerProto::MergeFrom(from.card_emulation_manager());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_nfc_dispatcher()->::com::android::nfc::NfcDispatcherProto::MergeFrom(from.nfc_dispatcher());
    }
    if (cached_has_bits & 0x00000020u) {
      state_ = from.state_;
    }
    if (cached_has_bits & 0x00000040u) {
      screen_state_ = from.screen_state_;
    }
    if (cached_has_bits & 0x00000080u) {
      in_provision_mode_ = from.in_provision_mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      ndef_push_enabled_ = from.ndef_push_enabled_;
    }
    if (cached_has_bits & 0x00000200u) {
      secure_nfc_enabled_ = from.secure_nfc_enabled_;
    }
    if (cached_has_bits & 0x00000400u) {
      polling_paused_ = from.polling_paused_;
    }
    if (cached_has_bits & 0x00000800u) {
      num_tags_detected_ = from.num_tags_detected_;
    }
    if (cached_has_bits & 0x00001000u) {
      num_p2p_detected_ = from.num_p2p_detected_;
    }
    if (cached_has_bits & 0x00002000u) {
      num_hce_detected_ = from.num_hce_detected_;
    }
    if (cached_has_bits & 0x00004000u) {
      hce_capable_ = from.hce_capable_;
    }
    if (cached_has_bits & 0x00008000u) {
      hce_f_capable_ = from.hce_f_capable_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00070000u) {
    if (cached_has_bits & 0x00010000u) {
      beam_capable_ = from.beam_capable_;
    }
    if (cached_has_bits & 0x00020000u) {
      secure_nfc_capable_ = from.secure_nfc_capable_;
    }
    if (cached_has_bits & 0x00040000u) {
      vr_mode_enabled_ = from.vr_mode_enabled_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void NfcServiceDumpProto::CopyFrom(const NfcServiceDumpProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.android.nfc.NfcServiceDumpProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NfcServiceDumpProto::IsInitialized() const {
  return true;
}

void NfcServiceDumpProto::InternalSwap(NfcServiceDumpProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  native_crash_logs_.Swap(&other->native_crash_logs_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(discovery_params_, other->discovery_params_);
  swap(p2p_link_manager_, other->p2p_link_manager_);
  swap(card_emulation_manager_, other->card_emulation_manager_);
  swap(nfc_dispatcher_, other->nfc_dispatcher_);
  swap(state_, other->state_);
  swap(screen_state_, other->screen_state_);
  swap(in_provision_mode_, other->in_provision_mode_);
  swap(ndef_push_enabled_, other->ndef_push_enabled_);
  swap(secure_nfc_enabled_, other->secure_nfc_enabled_);
  swap(polling_paused_, other->polling_paused_);
  swap(num_tags_detected_, other->num_tags_detected_);
  swap(num_p2p_detected_, other->num_p2p_detected_);
  swap(num_hce_detected_, other->num_hce_detected_);
  swap(hce_capable_, other->hce_capable_);
  swap(hce_f_capable_, other->hce_f_capable_);
  swap(beam_capable_, other->beam_capable_);
  swap(secure_nfc_capable_, other->secure_nfc_capable_);
  swap(vr_mode_enabled_, other->vr_mode_enabled_);
}

std::string NfcServiceDumpProto::GetTypeName() const {
  return "com.android.nfc.NfcServiceDumpProto";
}


// ===================================================================

void DiscoveryParamsProto::InitAsDefaultInstance() {
}
class DiscoveryParamsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DiscoveryParamsProto>()._has_bits_);
  static void set_has_tech_mask(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_enable_lpd(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_enable_reader(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_enable_host_routing(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_enable_p2p(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

DiscoveryParamsProto::DiscoveryParamsProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.android.nfc.DiscoveryParamsProto)
}
DiscoveryParamsProto::DiscoveryParamsProto(const DiscoveryParamsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&tech_mask_, &from.tech_mask_,
    static_cast<size_t>(reinterpret_cast<char*>(&enable_p2p_) -
    reinterpret_cast<char*>(&tech_mask_)) + sizeof(enable_p2p_));
  // @@protoc_insertion_point(copy_constructor:com.android.nfc.DiscoveryParamsProto)
}

void DiscoveryParamsProto::SharedCtor() {
  ::memset(&tech_mask_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&enable_p2p_) -
      reinterpret_cast<char*>(&tech_mask_)) + sizeof(enable_p2p_));
}

DiscoveryParamsProto::~DiscoveryParamsProto() {
  // @@protoc_insertion_point(destructor:com.android.nfc.DiscoveryParamsProto)
  SharedDtor();
}

void DiscoveryParamsProto::SharedDtor() {
}

void DiscoveryParamsProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DiscoveryParamsProto& DiscoveryParamsProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_DiscoveryParamsProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto.base);
  return *internal_default_instance();
}


void DiscoveryParamsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:com.android.nfc.DiscoveryParamsProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&tech_mask_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&enable_p2p_) -
        reinterpret_cast<char*>(&tech_mask_)) + sizeof(enable_p2p_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* DiscoveryParamsProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 tech_mask = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_tech_mask(&has_bits);
          tech_mask_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool enable_lpd = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_enable_lpd(&has_bits);
          enable_lpd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool enable_reader = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_enable_reader(&has_bits);
          enable_reader_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool enable_host_routing = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_enable_host_routing(&has_bits);
          enable_host_routing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool enable_p2p = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_enable_p2p(&has_bits);
          enable_p2p_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool DiscoveryParamsProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:com.android.nfc.DiscoveryParamsProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 tech_mask = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_tech_mask(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &tech_mask_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool enable_lpd = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_enable_lpd(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enable_lpd_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool enable_reader = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_enable_reader(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enable_reader_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool enable_host_routing = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_enable_host_routing(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enable_host_routing_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool enable_p2p = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_enable_p2p(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enable_p2p_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.android.nfc.DiscoveryParamsProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.android.nfc.DiscoveryParamsProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void DiscoveryParamsProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.android.nfc.DiscoveryParamsProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 tech_mask = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->tech_mask(), output);
  }

  // optional bool enable_lpd = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(2, this->enable_lpd(), output);
  }

  // optional bool enable_reader = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(3, this->enable_reader(), output);
  }

  // optional bool enable_host_routing = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(4, this->enable_host_routing(), output);
  }

  // optional bool enable_p2p = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(5, this->enable_p2p(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:com.android.nfc.DiscoveryParamsProto)
}

size_t DiscoveryParamsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.android.nfc.DiscoveryParamsProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int32 tech_mask = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->tech_mask());
    }

    // optional bool enable_lpd = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool enable_reader = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool enable_host_routing = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool enable_p2p = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DiscoveryParamsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DiscoveryParamsProto*>(
      &from));
}

void DiscoveryParamsProto::MergeFrom(const DiscoveryParamsProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:com.android.nfc.DiscoveryParamsProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      tech_mask_ = from.tech_mask_;
    }
    if (cached_has_bits & 0x00000002u) {
      enable_lpd_ = from.enable_lpd_;
    }
    if (cached_has_bits & 0x00000004u) {
      enable_reader_ = from.enable_reader_;
    }
    if (cached_has_bits & 0x00000008u) {
      enable_host_routing_ = from.enable_host_routing_;
    }
    if (cached_has_bits & 0x00000010u) {
      enable_p2p_ = from.enable_p2p_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DiscoveryParamsProto::CopyFrom(const DiscoveryParamsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.android.nfc.DiscoveryParamsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DiscoveryParamsProto::IsInitialized() const {
  return true;
}

void DiscoveryParamsProto::InternalSwap(DiscoveryParamsProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(tech_mask_, other->tech_mask_);
  swap(enable_lpd_, other->enable_lpd_);
  swap(enable_reader_, other->enable_reader_);
  swap(enable_host_routing_, other->enable_host_routing_);
  swap(enable_p2p_, other->enable_p2p_);
}

std::string DiscoveryParamsProto::GetTypeName() const {
  return "com.android.nfc.DiscoveryParamsProto";
}


// ===================================================================

void P2pLinkManagerProto::InitAsDefaultInstance() {
  ::com::android::nfc::_P2pLinkManagerProto_default_instance_._instance.get_mutable()->message_to_send_ = const_cast< ::android::nfc::NdefMessageProto*>(
      ::android::nfc::NdefMessageProto::internal_default_instance());
}
class P2pLinkManagerProto::_Internal {
 public:
  using HasBits = decltype(std::declval<P2pLinkManagerProto>()._has_bits_);
  static void set_has_default_miu(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_default_rw_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_link_state(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_send_state(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_send_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_send_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_receive_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_callback_ndef(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::android::nfc::NdefMessageProto& message_to_send(const P2pLinkManagerProto* msg);
  static void set_has_message_to_send(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::android::nfc::NdefMessageProto&
P2pLinkManagerProto::_Internal::message_to_send(const P2pLinkManagerProto* msg) {
  return *msg->message_to_send_;
}
void P2pLinkManagerProto::clear_message_to_send() {
  if (message_to_send_ != nullptr) message_to_send_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
P2pLinkManagerProto::P2pLinkManagerProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.android.nfc.P2pLinkManagerProto)
}
P2pLinkManagerProto::P2pLinkManagerProto(const P2pLinkManagerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      uris_to_send_(from.uris_to_send_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  callback_ndef_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_callback_ndef()) {
    callback_ndef_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.callback_ndef_);
  }
  if (from.has_message_to_send()) {
    message_to_send_ = new ::android::nfc::NdefMessageProto(*from.message_to_send_);
  } else {
    message_to_send_ = nullptr;
  }
  ::memcpy(&default_miu_, &from.default_miu_,
    static_cast<size_t>(reinterpret_cast<char*>(&receive_enabled_) -
    reinterpret_cast<char*>(&default_miu_)) + sizeof(receive_enabled_));
  // @@protoc_insertion_point(copy_constructor:com.android.nfc.P2pLinkManagerProto)
}

void P2pLinkManagerProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_P2pLinkManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto.base);
  callback_ndef_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&message_to_send_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&receive_enabled_) -
      reinterpret_cast<char*>(&message_to_send_)) + sizeof(receive_enabled_));
}

P2pLinkManagerProto::~P2pLinkManagerProto() {
  // @@protoc_insertion_point(destructor:com.android.nfc.P2pLinkManagerProto)
  SharedDtor();
}

void P2pLinkManagerProto::SharedDtor() {
  callback_ndef_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete message_to_send_;
}

void P2pLinkManagerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const P2pLinkManagerProto& P2pLinkManagerProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_P2pLinkManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto.base);
  return *internal_default_instance();
}


void P2pLinkManagerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:com.android.nfc.P2pLinkManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  uris_to_send_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      callback_ndef_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(message_to_send_ != nullptr);
      message_to_send_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&default_miu_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&send_enabled_) -
        reinterpret_cast<char*>(&default_miu_)) + sizeof(send_enabled_));
  }
  receive_enabled_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* P2pLinkManagerProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 default_miu = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_default_miu(&has_bits);
          default_miu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 default_rw_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_default_rw_size(&has_bits);
          default_rw_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .com.android.nfc.P2pLinkManagerProto.LinkState link_state = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::com::android::nfc::P2pLinkManagerProto_LinkState_IsValid(val))) {
            set_link_state(static_cast<::com::android::nfc::P2pLinkManagerProto_LinkState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .com.android.nfc.P2pLinkManagerProto.SendState send_state = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::com::android::nfc::P2pLinkManagerProto_SendState_IsValid(val))) {
            set_send_state(static_cast<::com::android::nfc::P2pLinkManagerProto_SendState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional int32 send_flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_send_flags(&has_bits);
          send_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool send_enabled = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_send_enabled(&has_bits);
          send_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool receive_enabled = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_receive_enabled(&has_bits);
          receive_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string callback_ndef = 8 [(.android.privacy) = {
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_callback_ndef(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.nfc.NdefMessageProto message_to_send = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(mutable_message_to_send(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string uris_to_send = 10 [(.android.privacy) = {
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(add_uris_to_send(), ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 82);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool P2pLinkManagerProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:com.android.nfc.P2pLinkManagerProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 default_miu = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_default_miu(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &default_miu_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 default_rw_size = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_default_rw_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &default_rw_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .com.android.nfc.P2pLinkManagerProto.LinkState link_state = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::android::nfc::P2pLinkManagerProto_LinkState_IsValid(value)) {
            set_link_state(static_cast< ::com::android::nfc::P2pLinkManagerProto_LinkState >(value));
          } else {
            unknown_fields_stream.WriteVarint32(24u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .com.android.nfc.P2pLinkManagerProto.SendState send_state = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::android::nfc::P2pLinkManagerProto_SendState_IsValid(value)) {
            set_send_state(static_cast< ::com::android::nfc::P2pLinkManagerProto_SendState >(value));
          } else {
            unknown_fields_stream.WriteVarint32(32u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 send_flags = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_send_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &send_flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool send_enabled = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_send_enabled(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &send_enabled_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool receive_enabled = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_receive_enabled(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &receive_enabled_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string callback_ndef = 8 [(.android.privacy) = {
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (66 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_callback_ndef()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.nfc.NdefMessageProto message_to_send = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (74 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_message_to_send()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string uris_to_send = 10 [(.android.privacy) = {
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (82 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->add_uris_to_send()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.android.nfc.P2pLinkManagerProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.android.nfc.P2pLinkManagerProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void P2pLinkManagerProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.android.nfc.P2pLinkManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 default_miu = 1;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->default_miu(), output);
  }

  // optional int32 default_rw_size = 2;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->default_rw_size(), output);
  }

  // optional .com.android.nfc.P2pLinkManagerProto.LinkState link_state = 3;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      3, this->link_state(), output);
  }

  // optional .com.android.nfc.P2pLinkManagerProto.SendState send_state = 4;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      4, this->send_state(), output);
  }

  // optional int32 send_flags = 5;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->send_flags(), output);
  }

  // optional bool send_enabled = 6;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(6, this->send_enabled(), output);
  }

  // optional bool receive_enabled = 7;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(7, this->receive_enabled(), output);
  }

  // optional string callback_ndef = 8 [(.android.privacy) = {
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->callback_ndef(), output);
  }

  // optional .android.nfc.NdefMessageProto message_to_send = 9;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      9, _Internal::message_to_send(this), output);
  }

  // repeated string uris_to_send = 10 [(.android.privacy) = {
  for (int i = 0, n = this->uris_to_send_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteString(
      10, this->uris_to_send(i), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:com.android.nfc.P2pLinkManagerProto)
}

size_t P2pLinkManagerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.android.nfc.P2pLinkManagerProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string uris_to_send = 10 [(.android.privacy) = {
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->uris_to_send_size());
  for (int i = 0, n = this->uris_to_send_size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      this->uris_to_send(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string callback_ndef = 8 [(.android.privacy) = {
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->callback_ndef());
    }

    // optional .android.nfc.NdefMessageProto message_to_send = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *message_to_send_);
    }

    // optional int32 default_miu = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->default_miu());
    }

    // optional int32 default_rw_size = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->default_rw_size());
    }

    // optional .com.android.nfc.P2pLinkManagerProto.LinkState link_state = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->link_state());
    }

    // optional .com.android.nfc.P2pLinkManagerProto.SendState send_state = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->send_state());
    }

    // optional int32 send_flags = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->send_flags());
    }

    // optional bool send_enabled = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  // optional bool receive_enabled = 7;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 1;
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void P2pLinkManagerProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const P2pLinkManagerProto*>(
      &from));
}

void P2pLinkManagerProto::MergeFrom(const P2pLinkManagerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:com.android.nfc.P2pLinkManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  uris_to_send_.MergeFrom(from.uris_to_send_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      callback_ndef_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.callback_ndef_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_message_to_send()->::android::nfc::NdefMessageProto::MergeFrom(from.message_to_send());
    }
    if (cached_has_bits & 0x00000004u) {
      default_miu_ = from.default_miu_;
    }
    if (cached_has_bits & 0x00000008u) {
      default_rw_size_ = from.default_rw_size_;
    }
    if (cached_has_bits & 0x00000010u) {
      link_state_ = from.link_state_;
    }
    if (cached_has_bits & 0x00000020u) {
      send_state_ = from.send_state_;
    }
    if (cached_has_bits & 0x00000040u) {
      send_flags_ = from.send_flags_;
    }
    if (cached_has_bits & 0x00000080u) {
      send_enabled_ = from.send_enabled_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    set_receive_enabled(from.receive_enabled());
  }
}

void P2pLinkManagerProto::CopyFrom(const P2pLinkManagerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.android.nfc.P2pLinkManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool P2pLinkManagerProto::IsInitialized() const {
  return true;
}

void P2pLinkManagerProto::InternalSwap(P2pLinkManagerProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  uris_to_send_.InternalSwap(CastToBase(&other->uris_to_send_));
  callback_ndef_.Swap(&other->callback_ndef_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(message_to_send_, other->message_to_send_);
  swap(default_miu_, other->default_miu_);
  swap(default_rw_size_, other->default_rw_size_);
  swap(link_state_, other->link_state_);
  swap(send_state_, other->send_state_);
  swap(send_flags_, other->send_flags_);
  swap(send_enabled_, other->send_enabled_);
  swap(receive_enabled_, other->receive_enabled_);
}

std::string P2pLinkManagerProto::GetTypeName() const {
  return "com.android.nfc.P2pLinkManagerProto";
}


// ===================================================================

void NfcDispatcherProto::InitAsDefaultInstance() {
  ::com::android::nfc::_NfcDispatcherProto_default_instance_._instance.get_mutable()->override_intent_ = const_cast< ::android::app::PendingIntentProto*>(
      ::android::app::PendingIntentProto::internal_default_instance());
}
class NfcDispatcherProto::_Internal {
 public:
  using HasBits = decltype(std::declval<NfcDispatcherProto>()._has_bits_);
  static void set_has_device_supports_bluetooth(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_bluetooth_enabled_by_nfc(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_provisioning_only(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::android::app::PendingIntentProto& override_intent(const NfcDispatcherProto* msg);
  static void set_has_override_intent(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_override_tech_lists(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::android::app::PendingIntentProto&
NfcDispatcherProto::_Internal::override_intent(const NfcDispatcherProto* msg) {
  return *msg->override_intent_;
}
void NfcDispatcherProto::clear_override_intent() {
  if (override_intent_ != nullptr) override_intent_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void NfcDispatcherProto::clear_override_filters() {
  override_filters_.Clear();
}
NfcDispatcherProto::NfcDispatcherProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.android.nfc.NfcDispatcherProto)
}
NfcDispatcherProto::NfcDispatcherProto(const NfcDispatcherProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      override_filters_(from.override_filters_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  override_tech_lists_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_override_tech_lists()) {
    override_tech_lists_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.override_tech_lists_);
  }
  if (from.has_override_intent()) {
    override_intent_ = new ::android::app::PendingIntentProto(*from.override_intent_);
  } else {
    override_intent_ = nullptr;
  }
  ::memcpy(&device_supports_bluetooth_, &from.device_supports_bluetooth_,
    static_cast<size_t>(reinterpret_cast<char*>(&provisioning_only_) -
    reinterpret_cast<char*>(&device_supports_bluetooth_)) + sizeof(provisioning_only_));
  // @@protoc_insertion_point(copy_constructor:com.android.nfc.NfcDispatcherProto)
}

void NfcDispatcherProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_NfcDispatcherProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto.base);
  override_tech_lists_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&override_intent_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&provisioning_only_) -
      reinterpret_cast<char*>(&override_intent_)) + sizeof(provisioning_only_));
}

NfcDispatcherProto::~NfcDispatcherProto() {
  // @@protoc_insertion_point(destructor:com.android.nfc.NfcDispatcherProto)
  SharedDtor();
}

void NfcDispatcherProto::SharedDtor() {
  override_tech_lists_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete override_intent_;
}

void NfcDispatcherProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NfcDispatcherProto& NfcDispatcherProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_NfcDispatcherProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fnfc_2fnfc_5fservice_2eproto.base);
  return *internal_default_instance();
}


void NfcDispatcherProto::Clear() {
// @@protoc_insertion_point(message_clear_start:com.android.nfc.NfcDispatcherProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  override_filters_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      override_tech_lists_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(override_intent_ != nullptr);
      override_intent_->Clear();
    }
  }
  ::memset(&device_supports_bluetooth_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&provisioning_only_) -
      reinterpret_cast<char*>(&device_supports_bluetooth_)) + sizeof(provisioning_only_));
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* NfcDispatcherProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bool device_supports_bluetooth = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_device_supports_bluetooth(&has_bits);
          device_supports_bluetooth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool bluetooth_enabled_by_nfc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_bluetooth_enabled_by_nfc(&has_bits);
          bluetooth_enabled_by_nfc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool provisioning_only = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_provisioning_only(&has_bits);
          provisioning_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.app.PendingIntentProto override_intent = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(mutable_override_intent(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.content.IntentFilterProto override_filters = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_override_filters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 42);
        } else goto handle_unusual;
        continue;
      // optional string override_tech_lists = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_override_tech_lists(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool NfcDispatcherProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:com.android.nfc.NfcDispatcherProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool device_supports_bluetooth = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_device_supports_bluetooth(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &device_supports_bluetooth_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool bluetooth_enabled_by_nfc = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_bluetooth_enabled_by_nfc(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &bluetooth_enabled_by_nfc_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool provisioning_only = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_provisioning_only(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &provisioning_only_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.app.PendingIntentProto override_intent = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_override_intent()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.content.IntentFilterProto override_filters = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_override_filters()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string override_tech_lists = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_override_tech_lists()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.android.nfc.NfcDispatcherProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.android.nfc.NfcDispatcherProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void NfcDispatcherProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.android.nfc.NfcDispatcherProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool device_supports_bluetooth = 1;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(1, this->device_supports_bluetooth(), output);
  }

  // optional bool bluetooth_enabled_by_nfc = 2;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(2, this->bluetooth_enabled_by_nfc(), output);
  }

  // optional bool provisioning_only = 3;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(3, this->provisioning_only(), output);
  }

  // optional .android.app.PendingIntentProto override_intent = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      4, _Internal::override_intent(this), output);
  }

  // repeated .android.content.IntentFilterProto override_filters = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->override_filters_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      5,
      this->override_filters(static_cast<int>(i)),
      output);
  }

  // optional string override_tech_lists = 6;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->override_tech_lists(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:com.android.nfc.NfcDispatcherProto)
}

size_t NfcDispatcherProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.android.nfc.NfcDispatcherProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.content.IntentFilterProto override_filters = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->override_filters_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->override_filters(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string override_tech_lists = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->override_tech_lists());
    }

    // optional .android.app.PendingIntentProto override_intent = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *override_intent_);
    }

    // optional bool device_supports_bluetooth = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool bluetooth_enabled_by_nfc = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool provisioning_only = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NfcDispatcherProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const NfcDispatcherProto*>(
      &from));
}

void NfcDispatcherProto::MergeFrom(const NfcDispatcherProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:com.android.nfc.NfcDispatcherProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  override_filters_.MergeFrom(from.override_filters_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      override_tech_lists_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.override_tech_lists_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_override_intent()->::android::app::PendingIntentProto::MergeFrom(from.override_intent());
    }
    if (cached_has_bits & 0x00000004u) {
      device_supports_bluetooth_ = from.device_supports_bluetooth_;
    }
    if (cached_has_bits & 0x00000008u) {
      bluetooth_enabled_by_nfc_ = from.bluetooth_enabled_by_nfc_;
    }
    if (cached_has_bits & 0x00000010u) {
      provisioning_only_ = from.provisioning_only_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void NfcDispatcherProto::CopyFrom(const NfcDispatcherProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.android.nfc.NfcDispatcherProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NfcDispatcherProto::IsInitialized() const {
  return true;
}

void NfcDispatcherProto::InternalSwap(NfcDispatcherProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&override_filters_)->InternalSwap(CastToBase(&other->override_filters_));
  override_tech_lists_.Swap(&other->override_tech_lists_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(override_intent_, other->override_intent_);
  swap(device_supports_bluetooth_, other->device_supports_bluetooth_);
  swap(bluetooth_enabled_by_nfc_, other->bluetooth_enabled_by_nfc_);
  swap(provisioning_only_, other->provisioning_only_);
}

std::string NfcDispatcherProto::GetTypeName() const {
  return "com.android.nfc.NfcDispatcherProto";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace nfc
}  // namespace android
}  // namespace com
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::com::android::nfc::NfcServiceDumpProto* Arena::CreateMaybeMessage< ::com::android::nfc::NfcServiceDumpProto >(Arena* arena) {
  return Arena::CreateInternal< ::com::android::nfc::NfcServiceDumpProto >(arena);
}
template<> PROTOBUF_NOINLINE ::com::android::nfc::DiscoveryParamsProto* Arena::CreateMaybeMessage< ::com::android::nfc::DiscoveryParamsProto >(Arena* arena) {
  return Arena::CreateInternal< ::com::android::nfc::DiscoveryParamsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::com::android::nfc::P2pLinkManagerProto* Arena::CreateMaybeMessage< ::com::android::nfc::P2pLinkManagerProto >(Arena* arena) {
  return Arena::CreateInternal< ::com::android::nfc::P2pLinkManagerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::com::android::nfc::NfcDispatcherProto* Arena::CreateMaybeMessage< ::com::android::nfc::NfcDispatcherProto >(Arena* arena) {
  return Arena::CreateInternal< ::com::android::nfc::NfcDispatcherProto >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
