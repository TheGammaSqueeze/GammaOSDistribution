// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/base/proto/src/ipconnectivity.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_frameworks_2fbase_2fproto_2fsrc_2fipconnectivity_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_frameworks_2fbase_2fproto_2fsrc_2fipconnectivity_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fproto_2fsrc_2fipconnectivity_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_frameworks_2fbase_2fproto_2fsrc_2fipconnectivity_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[18]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace clearcut {
namespace connectivity {
class ApfProgramEvent;
class ApfProgramEventDefaultTypeInternal;
extern ApfProgramEventDefaultTypeInternal _ApfProgramEvent_default_instance_;
class ApfStatistics;
class ApfStatisticsDefaultTypeInternal;
extern ApfStatisticsDefaultTypeInternal _ApfStatistics_default_instance_;
class ConnectStatistics;
class ConnectStatisticsDefaultTypeInternal;
extern ConnectStatisticsDefaultTypeInternal _ConnectStatistics_default_instance_;
class DHCPEvent;
class DHCPEventDefaultTypeInternal;
extern DHCPEventDefaultTypeInternal _DHCPEvent_default_instance_;
class DNSLatencies;
class DNSLatenciesDefaultTypeInternal;
extern DNSLatenciesDefaultTypeInternal _DNSLatencies_default_instance_;
class DNSLookupBatch;
class DNSLookupBatchDefaultTypeInternal;
extern DNSLookupBatchDefaultTypeInternal _DNSLookupBatch_default_instance_;
class DefaultNetworkEvent;
class DefaultNetworkEventDefaultTypeInternal;
extern DefaultNetworkEventDefaultTypeInternal _DefaultNetworkEvent_default_instance_;
class IpConnectivityEvent;
class IpConnectivityEventDefaultTypeInternal;
extern IpConnectivityEventDefaultTypeInternal _IpConnectivityEvent_default_instance_;
class IpConnectivityLog;
class IpConnectivityLogDefaultTypeInternal;
extern IpConnectivityLogDefaultTypeInternal _IpConnectivityLog_default_instance_;
class IpProvisioningEvent;
class IpProvisioningEventDefaultTypeInternal;
extern IpProvisioningEventDefaultTypeInternal _IpProvisioningEvent_default_instance_;
class IpReachabilityEvent;
class IpReachabilityEventDefaultTypeInternal;
extern IpReachabilityEventDefaultTypeInternal _IpReachabilityEvent_default_instance_;
class NetworkEvent;
class NetworkEventDefaultTypeInternal;
extern NetworkEventDefaultTypeInternal _NetworkEvent_default_instance_;
class NetworkId;
class NetworkIdDefaultTypeInternal;
extern NetworkIdDefaultTypeInternal _NetworkId_default_instance_;
class NetworkStats;
class NetworkStatsDefaultTypeInternal;
extern NetworkStatsDefaultTypeInternal _NetworkStats_default_instance_;
class Pair;
class PairDefaultTypeInternal;
extern PairDefaultTypeInternal _Pair_default_instance_;
class RaEvent;
class RaEventDefaultTypeInternal;
extern RaEventDefaultTypeInternal _RaEvent_default_instance_;
class ValidationProbeEvent;
class ValidationProbeEventDefaultTypeInternal;
extern ValidationProbeEventDefaultTypeInternal _ValidationProbeEvent_default_instance_;
class WakeupStats;
class WakeupStatsDefaultTypeInternal;
extern WakeupStatsDefaultTypeInternal _WakeupStats_default_instance_;
}  // namespace connectivity
}  // namespace clearcut
PROTOBUF_NAMESPACE_OPEN
template<> ::clearcut::connectivity::ApfProgramEvent* Arena::CreateMaybeMessage<::clearcut::connectivity::ApfProgramEvent>(Arena*);
template<> ::clearcut::connectivity::ApfStatistics* Arena::CreateMaybeMessage<::clearcut::connectivity::ApfStatistics>(Arena*);
template<> ::clearcut::connectivity::ConnectStatistics* Arena::CreateMaybeMessage<::clearcut::connectivity::ConnectStatistics>(Arena*);
template<> ::clearcut::connectivity::DHCPEvent* Arena::CreateMaybeMessage<::clearcut::connectivity::DHCPEvent>(Arena*);
template<> ::clearcut::connectivity::DNSLatencies* Arena::CreateMaybeMessage<::clearcut::connectivity::DNSLatencies>(Arena*);
template<> ::clearcut::connectivity::DNSLookupBatch* Arena::CreateMaybeMessage<::clearcut::connectivity::DNSLookupBatch>(Arena*);
template<> ::clearcut::connectivity::DefaultNetworkEvent* Arena::CreateMaybeMessage<::clearcut::connectivity::DefaultNetworkEvent>(Arena*);
template<> ::clearcut::connectivity::IpConnectivityEvent* Arena::CreateMaybeMessage<::clearcut::connectivity::IpConnectivityEvent>(Arena*);
template<> ::clearcut::connectivity::IpConnectivityLog* Arena::CreateMaybeMessage<::clearcut::connectivity::IpConnectivityLog>(Arena*);
template<> ::clearcut::connectivity::IpProvisioningEvent* Arena::CreateMaybeMessage<::clearcut::connectivity::IpProvisioningEvent>(Arena*);
template<> ::clearcut::connectivity::IpReachabilityEvent* Arena::CreateMaybeMessage<::clearcut::connectivity::IpReachabilityEvent>(Arena*);
template<> ::clearcut::connectivity::NetworkEvent* Arena::CreateMaybeMessage<::clearcut::connectivity::NetworkEvent>(Arena*);
template<> ::clearcut::connectivity::NetworkId* Arena::CreateMaybeMessage<::clearcut::connectivity::NetworkId>(Arena*);
template<> ::clearcut::connectivity::NetworkStats* Arena::CreateMaybeMessage<::clearcut::connectivity::NetworkStats>(Arena*);
template<> ::clearcut::connectivity::Pair* Arena::CreateMaybeMessage<::clearcut::connectivity::Pair>(Arena*);
template<> ::clearcut::connectivity::RaEvent* Arena::CreateMaybeMessage<::clearcut::connectivity::RaEvent>(Arena*);
template<> ::clearcut::connectivity::ValidationProbeEvent* Arena::CreateMaybeMessage<::clearcut::connectivity::ValidationProbeEvent>(Arena*);
template<> ::clearcut::connectivity::WakeupStats* Arena::CreateMaybeMessage<::clearcut::connectivity::WakeupStats>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace clearcut {
namespace connectivity {

enum DefaultNetworkEvent_LostReason : int {
  DefaultNetworkEvent_LostReason_UNKNOWN = 0,
  DefaultNetworkEvent_LostReason_OUTSCORED = 1,
  DefaultNetworkEvent_LostReason_INVALIDATION = 2,
  DefaultNetworkEvent_LostReason_DISCONNECT = 3
};
bool DefaultNetworkEvent_LostReason_IsValid(int value);
constexpr DefaultNetworkEvent_LostReason DefaultNetworkEvent_LostReason_LostReason_MIN = DefaultNetworkEvent_LostReason_UNKNOWN;
constexpr DefaultNetworkEvent_LostReason DefaultNetworkEvent_LostReason_LostReason_MAX = DefaultNetworkEvent_LostReason_DISCONNECT;
constexpr int DefaultNetworkEvent_LostReason_LostReason_ARRAYSIZE = DefaultNetworkEvent_LostReason_LostReason_MAX + 1;

const std::string& DefaultNetworkEvent_LostReason_Name(DefaultNetworkEvent_LostReason value);
template<typename T>
inline const std::string& DefaultNetworkEvent_LostReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DefaultNetworkEvent_LostReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DefaultNetworkEvent_LostReason_Name.");
  return DefaultNetworkEvent_LostReason_Name(static_cast<DefaultNetworkEvent_LostReason>(enum_t_value));
}
bool DefaultNetworkEvent_LostReason_Parse(
    const std::string& name, DefaultNetworkEvent_LostReason* value);
enum DefaultNetworkEvent_IPSupport : int {
  DefaultNetworkEvent_IPSupport_NONE = 0,
  DefaultNetworkEvent_IPSupport_IPV4 = 1,
  DefaultNetworkEvent_IPSupport_IPV6 = 2,
  DefaultNetworkEvent_IPSupport_DUAL = 3
};
bool DefaultNetworkEvent_IPSupport_IsValid(int value);
constexpr DefaultNetworkEvent_IPSupport DefaultNetworkEvent_IPSupport_IPSupport_MIN = DefaultNetworkEvent_IPSupport_NONE;
constexpr DefaultNetworkEvent_IPSupport DefaultNetworkEvent_IPSupport_IPSupport_MAX = DefaultNetworkEvent_IPSupport_DUAL;
constexpr int DefaultNetworkEvent_IPSupport_IPSupport_ARRAYSIZE = DefaultNetworkEvent_IPSupport_IPSupport_MAX + 1;

const std::string& DefaultNetworkEvent_IPSupport_Name(DefaultNetworkEvent_IPSupport value);
template<typename T>
inline const std::string& DefaultNetworkEvent_IPSupport_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DefaultNetworkEvent_IPSupport>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DefaultNetworkEvent_IPSupport_Name.");
  return DefaultNetworkEvent_IPSupport_Name(static_cast<DefaultNetworkEvent_IPSupport>(enum_t_value));
}
bool DefaultNetworkEvent_IPSupport_Parse(
    const std::string& name, DefaultNetworkEvent_IPSupport* value);
enum LinkLayer : int {
  UNKNOWN = 0,
  BLUETOOTH = 1,
  CELLULAR = 2,
  ETHERNET = 3,
  WIFI = 4,
  WIFI_P2P = 7,
  WIFI_NAN = 8,
  LOWPAN = 9,
  NONE = 5,
  MULTIPLE = 6
};
bool LinkLayer_IsValid(int value);
constexpr LinkLayer LinkLayer_MIN = UNKNOWN;
constexpr LinkLayer LinkLayer_MAX = LOWPAN;
constexpr int LinkLayer_ARRAYSIZE = LinkLayer_MAX + 1;

const std::string& LinkLayer_Name(LinkLayer value);
template<typename T>
inline const std::string& LinkLayer_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LinkLayer>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LinkLayer_Name.");
  return LinkLayer_Name(static_cast<LinkLayer>(enum_t_value));
}
bool LinkLayer_Parse(
    const std::string& name, LinkLayer* value);
// ===================================================================

class NetworkId :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:clearcut.connectivity.NetworkId) */ {
 public:
  NetworkId();
  virtual ~NetworkId();

  NetworkId(const NetworkId& from);
  NetworkId(NetworkId&& from) noexcept
    : NetworkId() {
    *this = ::std::move(from);
  }

  inline NetworkId& operator=(const NetworkId& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkId& operator=(NetworkId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const NetworkId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkId* internal_default_instance() {
    return reinterpret_cast<const NetworkId*>(
               &_NetworkId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NetworkId& a, NetworkId& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkId* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NetworkId* New() const final {
    return CreateMaybeMessage<NetworkId>(nullptr);
  }

  NetworkId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NetworkId>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const NetworkId& from);
  void MergeFrom(const NetworkId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clearcut.connectivity.NetworkId";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetworkIdFieldNumber = 1,
  };
  // optional int32 network_id = 1;
  bool has_network_id() const;
  void clear_network_id();
  ::PROTOBUF_NAMESPACE_ID::int32 network_id() const;
  void set_network_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:clearcut.connectivity.NetworkId)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 network_id_;
  friend struct ::TableStruct_frameworks_2fbase_2fproto_2fsrc_2fipconnectivity_2eproto;
};
// -------------------------------------------------------------------

class Pair :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:clearcut.connectivity.Pair) */ {
 public:
  Pair();
  virtual ~Pair();

  Pair(const Pair& from);
  Pair(Pair&& from) noexcept
    : Pair() {
    *this = ::std::move(from);
  }

  inline Pair& operator=(const Pair& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pair& operator=(Pair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Pair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pair* internal_default_instance() {
    return reinterpret_cast<const Pair*>(
               &_Pair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Pair& a, Pair& b) {
    a.Swap(&b);
  }
  inline void Swap(Pair* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Pair* New() const final {
    return CreateMaybeMessage<Pair>(nullptr);
  }

  Pair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Pair>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Pair& from);
  void MergeFrom(const Pair& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Pair* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clearcut.connectivity.Pair";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // optional int32 key = 1;
  bool has_key() const;
  void clear_key();
  ::PROTOBUF_NAMESPACE_ID::int32 key() const;
  void set_key(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 value = 2;
  bool has_value() const;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::int32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:clearcut.connectivity.Pair)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 key_;
  ::PROTOBUF_NAMESPACE_ID::int32 value_;
  friend struct ::TableStruct_frameworks_2fbase_2fproto_2fsrc_2fipconnectivity_2eproto;
};
// -------------------------------------------------------------------

class DefaultNetworkEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:clearcut.connectivity.DefaultNetworkEvent) */ {
 public:
  DefaultNetworkEvent();
  virtual ~DefaultNetworkEvent();

  DefaultNetworkEvent(const DefaultNetworkEvent& from);
  DefaultNetworkEvent(DefaultNetworkEvent&& from) noexcept
    : DefaultNetworkEvent() {
    *this = ::std::move(from);
  }

  inline DefaultNetworkEvent& operator=(const DefaultNetworkEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefaultNetworkEvent& operator=(DefaultNetworkEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DefaultNetworkEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DefaultNetworkEvent* internal_default_instance() {
    return reinterpret_cast<const DefaultNetworkEvent*>(
               &_DefaultNetworkEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DefaultNetworkEvent& a, DefaultNetworkEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(DefaultNetworkEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DefaultNetworkEvent* New() const final {
    return CreateMaybeMessage<DefaultNetworkEvent>(nullptr);
  }

  DefaultNetworkEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DefaultNetworkEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DefaultNetworkEvent& from);
  void MergeFrom(const DefaultNetworkEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DefaultNetworkEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clearcut.connectivity.DefaultNetworkEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DefaultNetworkEvent_LostReason LostReason;
  static constexpr LostReason UNKNOWN =
    DefaultNetworkEvent_LostReason_UNKNOWN;
  static constexpr LostReason OUTSCORED =
    DefaultNetworkEvent_LostReason_OUTSCORED;
  static constexpr LostReason INVALIDATION =
    DefaultNetworkEvent_LostReason_INVALIDATION;
  static constexpr LostReason DISCONNECT =
    DefaultNetworkEvent_LostReason_DISCONNECT;
  static inline bool LostReason_IsValid(int value) {
    return DefaultNetworkEvent_LostReason_IsValid(value);
  }
  static constexpr LostReason LostReason_MIN =
    DefaultNetworkEvent_LostReason_LostReason_MIN;
  static constexpr LostReason LostReason_MAX =
    DefaultNetworkEvent_LostReason_LostReason_MAX;
  static constexpr int LostReason_ARRAYSIZE =
    DefaultNetworkEvent_LostReason_LostReason_ARRAYSIZE;
  template<typename T>
  static inline const std::string& LostReason_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LostReason>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LostReason_Name.");
    return DefaultNetworkEvent_LostReason_Name(enum_t_value);
  }
  static inline bool LostReason_Parse(const std::string& name,
      LostReason* value) {
    return DefaultNetworkEvent_LostReason_Parse(name, value);
  }

  typedef DefaultNetworkEvent_IPSupport IPSupport;
  static constexpr IPSupport NONE =
    DefaultNetworkEvent_IPSupport_NONE;
  static constexpr IPSupport IPV4 =
    DefaultNetworkEvent_IPSupport_IPV4;
  static constexpr IPSupport IPV6 =
    DefaultNetworkEvent_IPSupport_IPV6;
  static constexpr IPSupport DUAL =
    DefaultNetworkEvent_IPSupport_DUAL;
  static inline bool IPSupport_IsValid(int value) {
    return DefaultNetworkEvent_IPSupport_IsValid(value);
  }
  static constexpr IPSupport IPSupport_MIN =
    DefaultNetworkEvent_IPSupport_IPSupport_MIN;
  static constexpr IPSupport IPSupport_MAX =
    DefaultNetworkEvent_IPSupport_IPSupport_MAX;
  static constexpr int IPSupport_ARRAYSIZE =
    DefaultNetworkEvent_IPSupport_IPSupport_ARRAYSIZE;
  template<typename T>
  static inline const std::string& IPSupport_Name(T enum_t_value) {
    static_assert(::std::is_same<T, IPSupport>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function IPSupport_Name.");
    return DefaultNetworkEvent_IPSupport_Name(enum_t_value);
  }
  static inline bool IPSupport_Parse(const std::string& name,
      IPSupport* value) {
    return DefaultNetworkEvent_IPSupport_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTransportTypesFieldNumber = 4,
    kNetworkIdFieldNumber = 1,
    kPreviousNetworkIdFieldNumber = 2,
    kDefaultNetworkDurationMsFieldNumber = 5,
    kNoDefaultNetworkDurationMsFieldNumber = 6,
    kPreviousNetworkIpSupportFieldNumber = 3,
    kIpSupportFieldNumber = 9,
    kInitialScoreFieldNumber = 7,
    kFinalScoreFieldNumber = 8,
    kValidationDurationMsFieldNumber = 11,
    kPreviousDefaultNetworkLinkLayerFieldNumber = 10,
  };
  // repeated int32 transport_types = 4 [deprecated = true];
  PROTOBUF_DEPRECATED int transport_types_size() const;
  PROTOBUF_DEPRECATED void clear_transport_types();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::int32 transport_types(int index) const;
  PROTOBUF_DEPRECATED void set_transport_types(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  PROTOBUF_DEPRECATED void add_transport_types(::PROTOBUF_NAMESPACE_ID::int32 value);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      transport_types() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_transport_types();

  // optional .clearcut.connectivity.NetworkId network_id = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_network_id() const;
  PROTOBUF_DEPRECATED void clear_network_id();
  PROTOBUF_DEPRECATED const ::clearcut::connectivity::NetworkId& network_id() const;
  PROTOBUF_DEPRECATED ::clearcut::connectivity::NetworkId* release_network_id();
  PROTOBUF_DEPRECATED ::clearcut::connectivity::NetworkId* mutable_network_id();
  PROTOBUF_DEPRECATED void set_allocated_network_id(::clearcut::connectivity::NetworkId* network_id);

  // optional .clearcut.connectivity.NetworkId previous_network_id = 2 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_previous_network_id() const;
  PROTOBUF_DEPRECATED void clear_previous_network_id();
  PROTOBUF_DEPRECATED const ::clearcut::connectivity::NetworkId& previous_network_id() const;
  PROTOBUF_DEPRECATED ::clearcut::connectivity::NetworkId* release_previous_network_id();
  PROTOBUF_DEPRECATED ::clearcut::connectivity::NetworkId* mutable_previous_network_id();
  PROTOBUF_DEPRECATED void set_allocated_previous_network_id(::clearcut::connectivity::NetworkId* previous_network_id);

  // optional int64 default_network_duration_ms = 5;
  bool has_default_network_duration_ms() const;
  void clear_default_network_duration_ms();
  ::PROTOBUF_NAMESPACE_ID::int64 default_network_duration_ms() const;
  void set_default_network_duration_ms(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 no_default_network_duration_ms = 6 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_no_default_network_duration_ms() const;
  PROTOBUF_DEPRECATED void clear_no_default_network_duration_ms();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::int64 no_default_network_duration_ms() const;
  PROTOBUF_DEPRECATED void set_no_default_network_duration_ms(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional .clearcut.connectivity.DefaultNetworkEvent.IPSupport previous_network_ip_support = 3 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_previous_network_ip_support() const;
  PROTOBUF_DEPRECATED void clear_previous_network_ip_support();
  PROTOBUF_DEPRECATED ::clearcut::connectivity::DefaultNetworkEvent_IPSupport previous_network_ip_support() const;
  PROTOBUF_DEPRECATED void set_previous_network_ip_support(::clearcut::connectivity::DefaultNetworkEvent_IPSupport value);

  // optional .clearcut.connectivity.DefaultNetworkEvent.IPSupport ip_support = 9;
  bool has_ip_support() const;
  void clear_ip_support();
  ::clearcut::connectivity::DefaultNetworkEvent_IPSupport ip_support() const;
  void set_ip_support(::clearcut::connectivity::DefaultNetworkEvent_IPSupport value);

  // optional int64 initial_score = 7;
  bool has_initial_score() const;
  void clear_initial_score();
  ::PROTOBUF_NAMESPACE_ID::int64 initial_score() const;
  void set_initial_score(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 final_score = 8;
  bool has_final_score() const;
  void clear_final_score();
  ::PROTOBUF_NAMESPACE_ID::int64 final_score() const;
  void set_final_score(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 validation_duration_ms = 11;
  bool has_validation_duration_ms() const;
  void clear_validation_duration_ms();
  ::PROTOBUF_NAMESPACE_ID::int64 validation_duration_ms() const;
  void set_validation_duration_ms(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional .clearcut.connectivity.LinkLayer previous_default_network_link_layer = 10;
  bool has_previous_default_network_link_layer() const;
  void clear_previous_default_network_link_layer();
  ::clearcut::connectivity::LinkLayer previous_default_network_link_layer() const;
  void set_previous_default_network_link_layer(::clearcut::connectivity::LinkLayer value);

  // @@protoc_insertion_point(class_scope:clearcut.connectivity.DefaultNetworkEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > transport_types_;
  ::clearcut::connectivity::NetworkId* network_id_;
  ::clearcut::connectivity::NetworkId* previous_network_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 default_network_duration_ms_;
  ::PROTOBUF_NAMESPACE_ID::int64 no_default_network_duration_ms_;
  int previous_network_ip_support_;
  int ip_support_;
  ::PROTOBUF_NAMESPACE_ID::int64 initial_score_;
  ::PROTOBUF_NAMESPACE_ID::int64 final_score_;
  ::PROTOBUF_NAMESPACE_ID::int64 validation_duration_ms_;
  int previous_default_network_link_layer_;
  friend struct ::TableStruct_frameworks_2fbase_2fproto_2fsrc_2fipconnectivity_2eproto;
};
// -------------------------------------------------------------------

class IpReachabilityEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:clearcut.connectivity.IpReachabilityEvent) */ {
 public:
  IpReachabilityEvent();
  virtual ~IpReachabilityEvent();

  IpReachabilityEvent(const IpReachabilityEvent& from);
  IpReachabilityEvent(IpReachabilityEvent&& from) noexcept
    : IpReachabilityEvent() {
    *this = ::std::move(from);
  }

  inline IpReachabilityEvent& operator=(const IpReachabilityEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IpReachabilityEvent& operator=(IpReachabilityEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IpReachabilityEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IpReachabilityEvent* internal_default_instance() {
    return reinterpret_cast<const IpReachabilityEvent*>(
               &_IpReachabilityEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(IpReachabilityEvent& a, IpReachabilityEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IpReachabilityEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IpReachabilityEvent* New() const final {
    return CreateMaybeMessage<IpReachabilityEvent>(nullptr);
  }

  IpReachabilityEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IpReachabilityEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IpReachabilityEvent& from);
  void MergeFrom(const IpReachabilityEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IpReachabilityEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clearcut.connectivity.IpReachabilityEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIfNameFieldNumber = 1,
    kEventTypeFieldNumber = 2,
  };
  // optional string if_name = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_if_name() const;
  PROTOBUF_DEPRECATED void clear_if_name();
  PROTOBUF_DEPRECATED const std::string& if_name() const;
  PROTOBUF_DEPRECATED void set_if_name(const std::string& value);
  PROTOBUF_DEPRECATED void set_if_name(std::string&& value);
  PROTOBUF_DEPRECATED void set_if_name(const char* value);
  PROTOBUF_DEPRECATED void set_if_name(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_if_name();
  PROTOBUF_DEPRECATED std::string* release_if_name();
  PROTOBUF_DEPRECATED void set_allocated_if_name(std::string* if_name);

  // optional int32 event_type = 2;
  bool has_event_type() const;
  void clear_event_type();
  ::PROTOBUF_NAMESPACE_ID::int32 event_type() const;
  void set_event_type(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:clearcut.connectivity.IpReachabilityEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr if_name_;
  ::PROTOBUF_NAMESPACE_ID::int32 event_type_;
  friend struct ::TableStruct_frameworks_2fbase_2fproto_2fsrc_2fipconnectivity_2eproto;
};
// -------------------------------------------------------------------

class NetworkEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:clearcut.connectivity.NetworkEvent) */ {
 public:
  NetworkEvent();
  virtual ~NetworkEvent();

  NetworkEvent(const NetworkEvent& from);
  NetworkEvent(NetworkEvent&& from) noexcept
    : NetworkEvent() {
    *this = ::std::move(from);
  }

  inline NetworkEvent& operator=(const NetworkEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkEvent& operator=(NetworkEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const NetworkEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkEvent* internal_default_instance() {
    return reinterpret_cast<const NetworkEvent*>(
               &_NetworkEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NetworkEvent& a, NetworkEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NetworkEvent* New() const final {
    return CreateMaybeMessage<NetworkEvent>(nullptr);
  }

  NetworkEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NetworkEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const NetworkEvent& from);
  void MergeFrom(const NetworkEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clearcut.connectivity.NetworkEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetworkIdFieldNumber = 1,
    kEventTypeFieldNumber = 2,
    kLatencyMsFieldNumber = 3,
  };
  // optional .clearcut.connectivity.NetworkId network_id = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_network_id() const;
  PROTOBUF_DEPRECATED void clear_network_id();
  PROTOBUF_DEPRECATED const ::clearcut::connectivity::NetworkId& network_id() const;
  PROTOBUF_DEPRECATED ::clearcut::connectivity::NetworkId* release_network_id();
  PROTOBUF_DEPRECATED ::clearcut::connectivity::NetworkId* mutable_network_id();
  PROTOBUF_DEPRECATED void set_allocated_network_id(::clearcut::connectivity::NetworkId* network_id);

  // optional int32 event_type = 2;
  bool has_event_type() const;
  void clear_event_type();
  ::PROTOBUF_NAMESPACE_ID::int32 event_type() const;
  void set_event_type(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 latency_ms = 3;
  bool has_latency_ms() const;
  void clear_latency_ms();
  ::PROTOBUF_NAMESPACE_ID::int32 latency_ms() const;
  void set_latency_ms(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:clearcut.connectivity.NetworkEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::clearcut::connectivity::NetworkId* network_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 event_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 latency_ms_;
  friend struct ::TableStruct_frameworks_2fbase_2fproto_2fsrc_2fipconnectivity_2eproto;
};
// -------------------------------------------------------------------

class ValidationProbeEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:clearcut.connectivity.ValidationProbeEvent) */ {
 public:
  ValidationProbeEvent();
  virtual ~ValidationProbeEvent();

  ValidationProbeEvent(const ValidationProbeEvent& from);
  ValidationProbeEvent(ValidationProbeEvent&& from) noexcept
    : ValidationProbeEvent() {
    *this = ::std::move(from);
  }

  inline ValidationProbeEvent& operator=(const ValidationProbeEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidationProbeEvent& operator=(ValidationProbeEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ValidationProbeEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValidationProbeEvent* internal_default_instance() {
    return reinterpret_cast<const ValidationProbeEvent*>(
               &_ValidationProbeEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ValidationProbeEvent& a, ValidationProbeEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidationProbeEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValidationProbeEvent* New() const final {
    return CreateMaybeMessage<ValidationProbeEvent>(nullptr);
  }

  ValidationProbeEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValidationProbeEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ValidationProbeEvent& from);
  void MergeFrom(const ValidationProbeEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ValidationProbeEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clearcut.connectivity.ValidationProbeEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetworkIdFieldNumber = 1,
    kLatencyMsFieldNumber = 2,
    kProbeTypeFieldNumber = 3,
    kProbeResultFieldNumber = 4,
  };
  // optional .clearcut.connectivity.NetworkId network_id = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_network_id() const;
  PROTOBUF_DEPRECATED void clear_network_id();
  PROTOBUF_DEPRECATED const ::clearcut::connectivity::NetworkId& network_id() const;
  PROTOBUF_DEPRECATED ::clearcut::connectivity::NetworkId* release_network_id();
  PROTOBUF_DEPRECATED ::clearcut::connectivity::NetworkId* mutable_network_id();
  PROTOBUF_DEPRECATED void set_allocated_network_id(::clearcut::connectivity::NetworkId* network_id);

  // optional int32 latency_ms = 2;
  bool has_latency_ms() const;
  void clear_latency_ms();
  ::PROTOBUF_NAMESPACE_ID::int32 latency_ms() const;
  void set_latency_ms(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 probe_type = 3;
  bool has_probe_type() const;
  void clear_probe_type();
  ::PROTOBUF_NAMESPACE_ID::int32 probe_type() const;
  void set_probe_type(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 probe_result = 4;
  bool has_probe_result() const;
  void clear_probe_result();
  ::PROTOBUF_NAMESPACE_ID::int32 probe_result() const;
  void set_probe_result(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:clearcut.connectivity.ValidationProbeEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::clearcut::connectivity::NetworkId* network_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 latency_ms_;
  ::PROTOBUF_NAMESPACE_ID::int32 probe_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 probe_result_;
  friend struct ::TableStruct_frameworks_2fbase_2fproto_2fsrc_2fipconnectivity_2eproto;
};
// -------------------------------------------------------------------

class DNSLookupBatch :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:clearcut.connectivity.DNSLookupBatch) */ {
 public:
  DNSLookupBatch();
  virtual ~DNSLookupBatch();

  DNSLookupBatch(const DNSLookupBatch& from);
  DNSLookupBatch(DNSLookupBatch&& from) noexcept
    : DNSLookupBatch() {
    *this = ::std::move(from);
  }

  inline DNSLookupBatch& operator=(const DNSLookupBatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline DNSLookupBatch& operator=(DNSLookupBatch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DNSLookupBatch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DNSLookupBatch* internal_default_instance() {
    return reinterpret_cast<const DNSLookupBatch*>(
               &_DNSLookupBatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DNSLookupBatch& a, DNSLookupBatch& b) {
    a.Swap(&b);
  }
  inline void Swap(DNSLookupBatch* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DNSLookupBatch* New() const final {
    return CreateMaybeMessage<DNSLookupBatch>(nullptr);
  }

  DNSLookupBatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DNSLookupBatch>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DNSLookupBatch& from);
  void MergeFrom(const DNSLookupBatch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DNSLookupBatch* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clearcut.connectivity.DNSLookupBatch";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventTypesFieldNumber = 2,
    kReturnCodesFieldNumber = 3,
    kLatenciesMsFieldNumber = 4,
    kGetaddrinfoErrorsFieldNumber = 9,
    kGethostbynameErrorsFieldNumber = 10,
    kNetworkIdFieldNumber = 1,
    kGetaddrinfoQueryCountFieldNumber = 5,
    kGethostbynameQueryCountFieldNumber = 6,
    kGetaddrinfoErrorCountFieldNumber = 7,
    kGethostbynameErrorCountFieldNumber = 8,
  };
  // repeated int32 event_types = 2 [deprecated = true];
  PROTOBUF_DEPRECATED int event_types_size() const;
  PROTOBUF_DEPRECATED void clear_event_types();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::int32 event_types(int index) const;
  PROTOBUF_DEPRECATED void set_event_types(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  PROTOBUF_DEPRECATED void add_event_types(::PROTOBUF_NAMESPACE_ID::int32 value);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      event_types() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_event_types();

  // repeated int32 return_codes = 3 [deprecated = true];
  PROTOBUF_DEPRECATED int return_codes_size() const;
  PROTOBUF_DEPRECATED void clear_return_codes();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::int32 return_codes(int index) const;
  PROTOBUF_DEPRECATED void set_return_codes(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  PROTOBUF_DEPRECATED void add_return_codes(::PROTOBUF_NAMESPACE_ID::int32 value);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      return_codes() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_return_codes();

  // repeated int32 latencies_ms = 4;
  int latencies_ms_size() const;
  void clear_latencies_ms();
  ::PROTOBUF_NAMESPACE_ID::int32 latencies_ms(int index) const;
  void set_latencies_ms(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_latencies_ms(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      latencies_ms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_latencies_ms();

  // repeated .clearcut.connectivity.Pair getaddrinfo_errors = 9;
  int getaddrinfo_errors_size() const;
  void clear_getaddrinfo_errors();
  ::clearcut::connectivity::Pair* mutable_getaddrinfo_errors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >*
      mutable_getaddrinfo_errors();
  const ::clearcut::connectivity::Pair& getaddrinfo_errors(int index) const;
  ::clearcut::connectivity::Pair* add_getaddrinfo_errors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >&
      getaddrinfo_errors() const;

  // repeated .clearcut.connectivity.Pair gethostbyname_errors = 10;
  int gethostbyname_errors_size() const;
  void clear_gethostbyname_errors();
  ::clearcut::connectivity::Pair* mutable_gethostbyname_errors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >*
      mutable_gethostbyname_errors();
  const ::clearcut::connectivity::Pair& gethostbyname_errors(int index) const;
  ::clearcut::connectivity::Pair* add_gethostbyname_errors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >&
      gethostbyname_errors() const;

  // optional .clearcut.connectivity.NetworkId network_id = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_network_id() const;
  PROTOBUF_DEPRECATED void clear_network_id();
  PROTOBUF_DEPRECATED const ::clearcut::connectivity::NetworkId& network_id() const;
  PROTOBUF_DEPRECATED ::clearcut::connectivity::NetworkId* release_network_id();
  PROTOBUF_DEPRECATED ::clearcut::connectivity::NetworkId* mutable_network_id();
  PROTOBUF_DEPRECATED void set_allocated_network_id(::clearcut::connectivity::NetworkId* network_id);

  // optional int64 getaddrinfo_query_count = 5;
  bool has_getaddrinfo_query_count() const;
  void clear_getaddrinfo_query_count();
  ::PROTOBUF_NAMESPACE_ID::int64 getaddrinfo_query_count() const;
  void set_getaddrinfo_query_count(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 gethostbyname_query_count = 6;
  bool has_gethostbyname_query_count() const;
  void clear_gethostbyname_query_count();
  ::PROTOBUF_NAMESPACE_ID::int64 gethostbyname_query_count() const;
  void set_gethostbyname_query_count(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 getaddrinfo_error_count = 7;
  bool has_getaddrinfo_error_count() const;
  void clear_getaddrinfo_error_count();
  ::PROTOBUF_NAMESPACE_ID::int64 getaddrinfo_error_count() const;
  void set_getaddrinfo_error_count(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 gethostbyname_error_count = 8;
  bool has_gethostbyname_error_count() const;
  void clear_gethostbyname_error_count();
  ::PROTOBUF_NAMESPACE_ID::int64 gethostbyname_error_count() const;
  void set_gethostbyname_error_count(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:clearcut.connectivity.DNSLookupBatch)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > event_types_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > return_codes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > latencies_ms_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair > getaddrinfo_errors_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair > gethostbyname_errors_;
  ::clearcut::connectivity::NetworkId* network_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 getaddrinfo_query_count_;
  ::PROTOBUF_NAMESPACE_ID::int64 gethostbyname_query_count_;
  ::PROTOBUF_NAMESPACE_ID::int64 getaddrinfo_error_count_;
  ::PROTOBUF_NAMESPACE_ID::int64 gethostbyname_error_count_;
  friend struct ::TableStruct_frameworks_2fbase_2fproto_2fsrc_2fipconnectivity_2eproto;
};
// -------------------------------------------------------------------

class DNSLatencies :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:clearcut.connectivity.DNSLatencies) */ {
 public:
  DNSLatencies();
  virtual ~DNSLatencies();

  DNSLatencies(const DNSLatencies& from);
  DNSLatencies(DNSLatencies&& from) noexcept
    : DNSLatencies() {
    *this = ::std::move(from);
  }

  inline DNSLatencies& operator=(const DNSLatencies& from) {
    CopyFrom(from);
    return *this;
  }
  inline DNSLatencies& operator=(DNSLatencies&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DNSLatencies& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DNSLatencies* internal_default_instance() {
    return reinterpret_cast<const DNSLatencies*>(
               &_DNSLatencies_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DNSLatencies& a, DNSLatencies& b) {
    a.Swap(&b);
  }
  inline void Swap(DNSLatencies* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DNSLatencies* New() const final {
    return CreateMaybeMessage<DNSLatencies>(nullptr);
  }

  DNSLatencies* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DNSLatencies>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DNSLatencies& from);
  void MergeFrom(const DNSLatencies& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DNSLatencies* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clearcut.connectivity.DNSLatencies";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatenciesMsFieldNumber = 6,
    kTypeFieldNumber = 1,
    kReturnCodeFieldNumber = 2,
    kQueryCountFieldNumber = 3,
    kACountFieldNumber = 4,
    kAaaaCountFieldNumber = 5,
  };
  // repeated int32 latencies_ms = 6;
  int latencies_ms_size() const;
  void clear_latencies_ms();
  ::PROTOBUF_NAMESPACE_ID::int32 latencies_ms(int index) const;
  void set_latencies_ms(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_latencies_ms(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      latencies_ms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_latencies_ms();

  // optional int32 type = 1;
  bool has_type() const;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 return_code = 2;
  bool has_return_code() const;
  void clear_return_code();
  ::PROTOBUF_NAMESPACE_ID::int32 return_code() const;
  void set_return_code(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 query_count = 3;
  bool has_query_count() const;
  void clear_query_count();
  ::PROTOBUF_NAMESPACE_ID::int32 query_count() const;
  void set_query_count(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 a_count = 4;
  bool has_a_count() const;
  void clear_a_count();
  ::PROTOBUF_NAMESPACE_ID::int32 a_count() const;
  void set_a_count(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 aaaa_count = 5;
  bool has_aaaa_count() const;
  void clear_aaaa_count();
  ::PROTOBUF_NAMESPACE_ID::int32 aaaa_count() const;
  void set_aaaa_count(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:clearcut.connectivity.DNSLatencies)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > latencies_ms_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  ::PROTOBUF_NAMESPACE_ID::int32 return_code_;
  ::PROTOBUF_NAMESPACE_ID::int32 query_count_;
  ::PROTOBUF_NAMESPACE_ID::int32 a_count_;
  ::PROTOBUF_NAMESPACE_ID::int32 aaaa_count_;
  friend struct ::TableStruct_frameworks_2fbase_2fproto_2fsrc_2fipconnectivity_2eproto;
};
// -------------------------------------------------------------------

class ConnectStatistics :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:clearcut.connectivity.ConnectStatistics) */ {
 public:
  ConnectStatistics();
  virtual ~ConnectStatistics();

  ConnectStatistics(const ConnectStatistics& from);
  ConnectStatistics(ConnectStatistics&& from) noexcept
    : ConnectStatistics() {
    *this = ::std::move(from);
  }

  inline ConnectStatistics& operator=(const ConnectStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectStatistics& operator=(ConnectStatistics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ConnectStatistics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectStatistics* internal_default_instance() {
    return reinterpret_cast<const ConnectStatistics*>(
               &_ConnectStatistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ConnectStatistics& a, ConnectStatistics& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectStatistics* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConnectStatistics* New() const final {
    return CreateMaybeMessage<ConnectStatistics>(nullptr);
  }

  ConnectStatistics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConnectStatistics>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ConnectStatistics& from);
  void MergeFrom(const ConnectStatistics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConnectStatistics* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clearcut.connectivity.ConnectStatistics";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatenciesMsFieldNumber = 3,
    kErrnosCountersFieldNumber = 4,
    kNonBlockingLatenciesMsFieldNumber = 6,
    kConnectCountFieldNumber = 1,
    kIpv6AddrCountFieldNumber = 2,
    kConnectBlockingCountFieldNumber = 5,
  };
  // repeated int32 latencies_ms = 3;
  int latencies_ms_size() const;
  void clear_latencies_ms();
  ::PROTOBUF_NAMESPACE_ID::int32 latencies_ms(int index) const;
  void set_latencies_ms(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_latencies_ms(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      latencies_ms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_latencies_ms();

  // repeated .clearcut.connectivity.Pair errnos_counters = 4;
  int errnos_counters_size() const;
  void clear_errnos_counters();
  ::clearcut::connectivity::Pair* mutable_errnos_counters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >*
      mutable_errnos_counters();
  const ::clearcut::connectivity::Pair& errnos_counters(int index) const;
  ::clearcut::connectivity::Pair* add_errnos_counters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >&
      errnos_counters() const;

  // repeated int32 non_blocking_latencies_ms = 6;
  int non_blocking_latencies_ms_size() const;
  void clear_non_blocking_latencies_ms();
  ::PROTOBUF_NAMESPACE_ID::int32 non_blocking_latencies_ms(int index) const;
  void set_non_blocking_latencies_ms(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_non_blocking_latencies_ms(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      non_blocking_latencies_ms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_non_blocking_latencies_ms();

  // optional int32 connect_count = 1;
  bool has_connect_count() const;
  void clear_connect_count();
  ::PROTOBUF_NAMESPACE_ID::int32 connect_count() const;
  void set_connect_count(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 ipv6_addr_count = 2;
  bool has_ipv6_addr_count() const;
  void clear_ipv6_addr_count();
  ::PROTOBUF_NAMESPACE_ID::int32 ipv6_addr_count() const;
  void set_ipv6_addr_count(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 connect_blocking_count = 5;
  bool has_connect_blocking_count() const;
  void clear_connect_blocking_count();
  ::PROTOBUF_NAMESPACE_ID::int32 connect_blocking_count() const;
  void set_connect_blocking_count(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:clearcut.connectivity.ConnectStatistics)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > latencies_ms_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair > errnos_counters_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > non_blocking_latencies_ms_;
  ::PROTOBUF_NAMESPACE_ID::int32 connect_count_;
  ::PROTOBUF_NAMESPACE_ID::int32 ipv6_addr_count_;
  ::PROTOBUF_NAMESPACE_ID::int32 connect_blocking_count_;
  friend struct ::TableStruct_frameworks_2fbase_2fproto_2fsrc_2fipconnectivity_2eproto;
};
// -------------------------------------------------------------------

class DHCPEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:clearcut.connectivity.DHCPEvent) */ {
 public:
  DHCPEvent();
  virtual ~DHCPEvent();

  DHCPEvent(const DHCPEvent& from);
  DHCPEvent(DHCPEvent&& from) noexcept
    : DHCPEvent() {
    *this = ::std::move(from);
  }

  inline DHCPEvent& operator=(const DHCPEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DHCPEvent& operator=(DHCPEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DHCPEvent& default_instance();

  enum ValueCase {
    kStateTransition = 2,
    kErrorCode = 3,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DHCPEvent* internal_default_instance() {
    return reinterpret_cast<const DHCPEvent*>(
               &_DHCPEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DHCPEvent& a, DHCPEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(DHCPEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DHCPEvent* New() const final {
    return CreateMaybeMessage<DHCPEvent>(nullptr);
  }

  DHCPEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DHCPEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DHCPEvent& from);
  void MergeFrom(const DHCPEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DHCPEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clearcut.connectivity.DHCPEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIfNameFieldNumber = 1,
    kDurationMsFieldNumber = 4,
    kStateTransitionFieldNumber = 2,
    kErrorCodeFieldNumber = 3,
  };
  // optional string if_name = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_if_name() const;
  PROTOBUF_DEPRECATED void clear_if_name();
  PROTOBUF_DEPRECATED const std::string& if_name() const;
  PROTOBUF_DEPRECATED void set_if_name(const std::string& value);
  PROTOBUF_DEPRECATED void set_if_name(std::string&& value);
  PROTOBUF_DEPRECATED void set_if_name(const char* value);
  PROTOBUF_DEPRECATED void set_if_name(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_if_name();
  PROTOBUF_DEPRECATED std::string* release_if_name();
  PROTOBUF_DEPRECATED void set_allocated_if_name(std::string* if_name);

  // optional int32 duration_ms = 4;
  bool has_duration_ms() const;
  void clear_duration_ms();
  ::PROTOBUF_NAMESPACE_ID::int32 duration_ms() const;
  void set_duration_ms(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional string state_transition = 2;
  bool has_state_transition() const;
  void clear_state_transition();
  const std::string& state_transition() const;
  void set_state_transition(const std::string& value);
  void set_state_transition(std::string&& value);
  void set_state_transition(const char* value);
  void set_state_transition(const char* value, size_t size);
  std::string* mutable_state_transition();
  std::string* release_state_transition();
  void set_allocated_state_transition(std::string* state_transition);

  // optional int32 error_code = 3;
  bool has_error_code() const;
  void clear_error_code();
  ::PROTOBUF_NAMESPACE_ID::int32 error_code() const;
  void set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:clearcut.connectivity.DHCPEvent)
 private:
  class _Internal;
  void set_has_state_transition();
  void set_has_error_code();

  inline bool has_value() const;
  inline void clear_has_value();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr if_name_;
  ::PROTOBUF_NAMESPACE_ID::int32 duration_ms_;
  union ValueUnion {
    ValueUnion() {}
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_transition_;
    ::PROTOBUF_NAMESPACE_ID::int32 error_code_;
  } value_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_frameworks_2fbase_2fproto_2fsrc_2fipconnectivity_2eproto;
};
// -------------------------------------------------------------------

class ApfProgramEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:clearcut.connectivity.ApfProgramEvent) */ {
 public:
  ApfProgramEvent();
  virtual ~ApfProgramEvent();

  ApfProgramEvent(const ApfProgramEvent& from);
  ApfProgramEvent(ApfProgramEvent&& from) noexcept
    : ApfProgramEvent() {
    *this = ::std::move(from);
  }

  inline ApfProgramEvent& operator=(const ApfProgramEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApfProgramEvent& operator=(ApfProgramEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ApfProgramEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ApfProgramEvent* internal_default_instance() {
    return reinterpret_cast<const ApfProgramEvent*>(
               &_ApfProgramEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ApfProgramEvent& a, ApfProgramEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ApfProgramEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ApfProgramEvent* New() const final {
    return CreateMaybeMessage<ApfProgramEvent>(nullptr);
  }

  ApfProgramEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ApfProgramEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ApfProgramEvent& from);
  void MergeFrom(const ApfProgramEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ApfProgramEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clearcut.connectivity.ApfProgramEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLifetimeFieldNumber = 1,
    kFilteredRasFieldNumber = 2,
    kCurrentRasFieldNumber = 3,
    kProgramLengthFieldNumber = 4,
    kDropMulticastFieldNumber = 5,
    kHasIpv4AddrFieldNumber = 6,
    kEffectiveLifetimeFieldNumber = 7,
  };
  // optional int64 lifetime = 1;
  bool has_lifetime() const;
  void clear_lifetime();
  ::PROTOBUF_NAMESPACE_ID::int64 lifetime() const;
  void set_lifetime(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int32 filtered_ras = 2;
  bool has_filtered_ras() const;
  void clear_filtered_ras();
  ::PROTOBUF_NAMESPACE_ID::int32 filtered_ras() const;
  void set_filtered_ras(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 current_ras = 3;
  bool has_current_ras() const;
  void clear_current_ras();
  ::PROTOBUF_NAMESPACE_ID::int32 current_ras() const;
  void set_current_ras(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 program_length = 4;
  bool has_program_length() const;
  void clear_program_length();
  ::PROTOBUF_NAMESPACE_ID::int32 program_length() const;
  void set_program_length(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional bool drop_multicast = 5;
  bool has_drop_multicast() const;
  void clear_drop_multicast();
  bool drop_multicast() const;
  void set_drop_multicast(bool value);

  // optional bool has_ipv4_addr = 6;
  bool has_has_ipv4_addr() const;
  void clear_has_ipv4_addr();
  bool has_ipv4_addr() const;
  void set_has_ipv4_addr(bool value);

  // optional int64 effective_lifetime = 7;
  bool has_effective_lifetime() const;
  void clear_effective_lifetime();
  ::PROTOBUF_NAMESPACE_ID::int64 effective_lifetime() const;
  void set_effective_lifetime(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:clearcut.connectivity.ApfProgramEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 lifetime_;
  ::PROTOBUF_NAMESPACE_ID::int32 filtered_ras_;
  ::PROTOBUF_NAMESPACE_ID::int32 current_ras_;
  ::PROTOBUF_NAMESPACE_ID::int32 program_length_;
  bool drop_multicast_;
  bool has_ipv4_addr_;
  ::PROTOBUF_NAMESPACE_ID::int64 effective_lifetime_;
  friend struct ::TableStruct_frameworks_2fbase_2fproto_2fsrc_2fipconnectivity_2eproto;
};
// -------------------------------------------------------------------

class ApfStatistics :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:clearcut.connectivity.ApfStatistics) */ {
 public:
  ApfStatistics();
  virtual ~ApfStatistics();

  ApfStatistics(const ApfStatistics& from);
  ApfStatistics(ApfStatistics&& from) noexcept
    : ApfStatistics() {
    *this = ::std::move(from);
  }

  inline ApfStatistics& operator=(const ApfStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApfStatistics& operator=(ApfStatistics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ApfStatistics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ApfStatistics* internal_default_instance() {
    return reinterpret_cast<const ApfStatistics*>(
               &_ApfStatistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ApfStatistics& a, ApfStatistics& b) {
    a.Swap(&b);
  }
  inline void Swap(ApfStatistics* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ApfStatistics* New() const final {
    return CreateMaybeMessage<ApfStatistics>(nullptr);
  }

  ApfStatistics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ApfStatistics>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ApfStatistics& from);
  void MergeFrom(const ApfStatistics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ApfStatistics* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clearcut.connectivity.ApfStatistics";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHardwareCountersFieldNumber = 14,
    kDurationMsFieldNumber = 1,
    kReceivedRasFieldNumber = 2,
    kMatchingRasFieldNumber = 3,
    kDroppedRasFieldNumber = 5,
    kZeroLifetimeRasFieldNumber = 6,
    kParseErrorsFieldNumber = 7,
    kProgramUpdatesFieldNumber = 8,
    kMaxProgramSizeFieldNumber = 9,
    kProgramUpdatesAllFieldNumber = 10,
    kProgramUpdatesAllowingMulticastFieldNumber = 11,
    kTotalPacketProcessedFieldNumber = 12,
    kTotalPacketDroppedFieldNumber = 13,
  };
  // repeated .clearcut.connectivity.Pair hardware_counters = 14;
  int hardware_counters_size() const;
  void clear_hardware_counters();
  ::clearcut::connectivity::Pair* mutable_hardware_counters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >*
      mutable_hardware_counters();
  const ::clearcut::connectivity::Pair& hardware_counters(int index) const;
  ::clearcut::connectivity::Pair* add_hardware_counters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >&
      hardware_counters() const;

  // optional int64 duration_ms = 1;
  bool has_duration_ms() const;
  void clear_duration_ms();
  ::PROTOBUF_NAMESPACE_ID::int64 duration_ms() const;
  void set_duration_ms(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int32 received_ras = 2;
  bool has_received_ras() const;
  void clear_received_ras();
  ::PROTOBUF_NAMESPACE_ID::int32 received_ras() const;
  void set_received_ras(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 matching_ras = 3;
  bool has_matching_ras() const;
  void clear_matching_ras();
  ::PROTOBUF_NAMESPACE_ID::int32 matching_ras() const;
  void set_matching_ras(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 dropped_ras = 5;
  bool has_dropped_ras() const;
  void clear_dropped_ras();
  ::PROTOBUF_NAMESPACE_ID::int32 dropped_ras() const;
  void set_dropped_ras(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 zero_lifetime_ras = 6;
  bool has_zero_lifetime_ras() const;
  void clear_zero_lifetime_ras();
  ::PROTOBUF_NAMESPACE_ID::int32 zero_lifetime_ras() const;
  void set_zero_lifetime_ras(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 parse_errors = 7;
  bool has_parse_errors() const;
  void clear_parse_errors();
  ::PROTOBUF_NAMESPACE_ID::int32 parse_errors() const;
  void set_parse_errors(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 program_updates = 8;
  bool has_program_updates() const;
  void clear_program_updates();
  ::PROTOBUF_NAMESPACE_ID::int32 program_updates() const;
  void set_program_updates(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 max_program_size = 9;
  bool has_max_program_size() const;
  void clear_max_program_size();
  ::PROTOBUF_NAMESPACE_ID::int32 max_program_size() const;
  void set_max_program_size(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 program_updates_all = 10;
  bool has_program_updates_all() const;
  void clear_program_updates_all();
  ::PROTOBUF_NAMESPACE_ID::int32 program_updates_all() const;
  void set_program_updates_all(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 program_updates_allowing_multicast = 11;
  bool has_program_updates_allowing_multicast() const;
  void clear_program_updates_allowing_multicast();
  ::PROTOBUF_NAMESPACE_ID::int32 program_updates_allowing_multicast() const;
  void set_program_updates_allowing_multicast(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 total_packet_processed = 12;
  bool has_total_packet_processed() const;
  void clear_total_packet_processed();
  ::PROTOBUF_NAMESPACE_ID::int32 total_packet_processed() const;
  void set_total_packet_processed(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 total_packet_dropped = 13;
  bool has_total_packet_dropped() const;
  void clear_total_packet_dropped();
  ::PROTOBUF_NAMESPACE_ID::int32 total_packet_dropped() const;
  void set_total_packet_dropped(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:clearcut.connectivity.ApfStatistics)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair > hardware_counters_;
  ::PROTOBUF_NAMESPACE_ID::int64 duration_ms_;
  ::PROTOBUF_NAMESPACE_ID::int32 received_ras_;
  ::PROTOBUF_NAMESPACE_ID::int32 matching_ras_;
  ::PROTOBUF_NAMESPACE_ID::int32 dropped_ras_;
  ::PROTOBUF_NAMESPACE_ID::int32 zero_lifetime_ras_;
  ::PROTOBUF_NAMESPACE_ID::int32 parse_errors_;
  ::PROTOBUF_NAMESPACE_ID::int32 program_updates_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_program_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 program_updates_all_;
  ::PROTOBUF_NAMESPACE_ID::int32 program_updates_allowing_multicast_;
  ::PROTOBUF_NAMESPACE_ID::int32 total_packet_processed_;
  ::PROTOBUF_NAMESPACE_ID::int32 total_packet_dropped_;
  friend struct ::TableStruct_frameworks_2fbase_2fproto_2fsrc_2fipconnectivity_2eproto;
};
// -------------------------------------------------------------------

class RaEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:clearcut.connectivity.RaEvent) */ {
 public:
  RaEvent();
  virtual ~RaEvent();

  RaEvent(const RaEvent& from);
  RaEvent(RaEvent&& from) noexcept
    : RaEvent() {
    *this = ::std::move(from);
  }

  inline RaEvent& operator=(const RaEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline RaEvent& operator=(RaEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RaEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RaEvent* internal_default_instance() {
    return reinterpret_cast<const RaEvent*>(
               &_RaEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RaEvent& a, RaEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(RaEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RaEvent* New() const final {
    return CreateMaybeMessage<RaEvent>(nullptr);
  }

  RaEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RaEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RaEvent& from);
  void MergeFrom(const RaEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RaEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clearcut.connectivity.RaEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRouterLifetimeFieldNumber = 1,
    kPrefixValidLifetimeFieldNumber = 2,
    kPrefixPreferredLifetimeFieldNumber = 3,
    kRouteInfoLifetimeFieldNumber = 4,
    kRdnssLifetimeFieldNumber = 5,
    kDnsslLifetimeFieldNumber = 6,
  };
  // optional int64 router_lifetime = 1;
  bool has_router_lifetime() const;
  void clear_router_lifetime();
  ::PROTOBUF_NAMESPACE_ID::int64 router_lifetime() const;
  void set_router_lifetime(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 prefix_valid_lifetime = 2;
  bool has_prefix_valid_lifetime() const;
  void clear_prefix_valid_lifetime();
  ::PROTOBUF_NAMESPACE_ID::int64 prefix_valid_lifetime() const;
  void set_prefix_valid_lifetime(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 prefix_preferred_lifetime = 3;
  bool has_prefix_preferred_lifetime() const;
  void clear_prefix_preferred_lifetime();
  ::PROTOBUF_NAMESPACE_ID::int64 prefix_preferred_lifetime() const;
  void set_prefix_preferred_lifetime(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 route_info_lifetime = 4;
  bool has_route_info_lifetime() const;
  void clear_route_info_lifetime();
  ::PROTOBUF_NAMESPACE_ID::int64 route_info_lifetime() const;
  void set_route_info_lifetime(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 rdnss_lifetime = 5;
  bool has_rdnss_lifetime() const;
  void clear_rdnss_lifetime();
  ::PROTOBUF_NAMESPACE_ID::int64 rdnss_lifetime() const;
  void set_rdnss_lifetime(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 dnssl_lifetime = 6;
  bool has_dnssl_lifetime() const;
  void clear_dnssl_lifetime();
  ::PROTOBUF_NAMESPACE_ID::int64 dnssl_lifetime() const;
  void set_dnssl_lifetime(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:clearcut.connectivity.RaEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 router_lifetime_;
  ::PROTOBUF_NAMESPACE_ID::int64 prefix_valid_lifetime_;
  ::PROTOBUF_NAMESPACE_ID::int64 prefix_preferred_lifetime_;
  ::PROTOBUF_NAMESPACE_ID::int64 route_info_lifetime_;
  ::PROTOBUF_NAMESPACE_ID::int64 rdnss_lifetime_;
  ::PROTOBUF_NAMESPACE_ID::int64 dnssl_lifetime_;
  friend struct ::TableStruct_frameworks_2fbase_2fproto_2fsrc_2fipconnectivity_2eproto;
};
// -------------------------------------------------------------------

class IpProvisioningEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:clearcut.connectivity.IpProvisioningEvent) */ {
 public:
  IpProvisioningEvent();
  virtual ~IpProvisioningEvent();

  IpProvisioningEvent(const IpProvisioningEvent& from);
  IpProvisioningEvent(IpProvisioningEvent&& from) noexcept
    : IpProvisioningEvent() {
    *this = ::std::move(from);
  }

  inline IpProvisioningEvent& operator=(const IpProvisioningEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IpProvisioningEvent& operator=(IpProvisioningEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IpProvisioningEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IpProvisioningEvent* internal_default_instance() {
    return reinterpret_cast<const IpProvisioningEvent*>(
               &_IpProvisioningEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(IpProvisioningEvent& a, IpProvisioningEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IpProvisioningEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IpProvisioningEvent* New() const final {
    return CreateMaybeMessage<IpProvisioningEvent>(nullptr);
  }

  IpProvisioningEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IpProvisioningEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IpProvisioningEvent& from);
  void MergeFrom(const IpProvisioningEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IpProvisioningEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clearcut.connectivity.IpProvisioningEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIfNameFieldNumber = 1,
    kEventTypeFieldNumber = 2,
    kLatencyMsFieldNumber = 3,
  };
  // optional string if_name = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_if_name() const;
  PROTOBUF_DEPRECATED void clear_if_name();
  PROTOBUF_DEPRECATED const std::string& if_name() const;
  PROTOBUF_DEPRECATED void set_if_name(const std::string& value);
  PROTOBUF_DEPRECATED void set_if_name(std::string&& value);
  PROTOBUF_DEPRECATED void set_if_name(const char* value);
  PROTOBUF_DEPRECATED void set_if_name(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_if_name();
  PROTOBUF_DEPRECATED std::string* release_if_name();
  PROTOBUF_DEPRECATED void set_allocated_if_name(std::string* if_name);

  // optional int32 event_type = 2;
  bool has_event_type() const;
  void clear_event_type();
  ::PROTOBUF_NAMESPACE_ID::int32 event_type() const;
  void set_event_type(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 latency_ms = 3;
  bool has_latency_ms() const;
  void clear_latency_ms();
  ::PROTOBUF_NAMESPACE_ID::int32 latency_ms() const;
  void set_latency_ms(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:clearcut.connectivity.IpProvisioningEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr if_name_;
  ::PROTOBUF_NAMESPACE_ID::int32 event_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 latency_ms_;
  friend struct ::TableStruct_frameworks_2fbase_2fproto_2fsrc_2fipconnectivity_2eproto;
};
// -------------------------------------------------------------------

class NetworkStats :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:clearcut.connectivity.NetworkStats) */ {
 public:
  NetworkStats();
  virtual ~NetworkStats();

  NetworkStats(const NetworkStats& from);
  NetworkStats(NetworkStats&& from) noexcept
    : NetworkStats() {
    *this = ::std::move(from);
  }

  inline NetworkStats& operator=(const NetworkStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkStats& operator=(NetworkStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const NetworkStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkStats* internal_default_instance() {
    return reinterpret_cast<const NetworkStats*>(
               &_NetworkStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(NetworkStats& a, NetworkStats& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkStats* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NetworkStats* New() const final {
    return CreateMaybeMessage<NetworkStats>(nullptr);
  }

  NetworkStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NetworkStats>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const NetworkStats& from);
  void MergeFrom(const NetworkStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkStats* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clearcut.connectivity.NetworkStats";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidationEventsFieldNumber = 7,
    kValidationStatesFieldNumber = 8,
    kDurationMsFieldNumber = 1,
    kIpSupportFieldNumber = 2,
    kEverValidatedFieldNumber = 3,
    kPortalFoundFieldNumber = 4,
    kNoConnectivityReportsFieldNumber = 5,
    kValidationAttemptsFieldNumber = 6,
  };
  // repeated .clearcut.connectivity.Pair validation_events = 7;
  int validation_events_size() const;
  void clear_validation_events();
  ::clearcut::connectivity::Pair* mutable_validation_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >*
      mutable_validation_events();
  const ::clearcut::connectivity::Pair& validation_events(int index) const;
  ::clearcut::connectivity::Pair* add_validation_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >&
      validation_events() const;

  // repeated .clearcut.connectivity.Pair validation_states = 8;
  int validation_states_size() const;
  void clear_validation_states();
  ::clearcut::connectivity::Pair* mutable_validation_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >*
      mutable_validation_states();
  const ::clearcut::connectivity::Pair& validation_states(int index) const;
  ::clearcut::connectivity::Pair* add_validation_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >&
      validation_states() const;

  // optional int64 duration_ms = 1;
  bool has_duration_ms() const;
  void clear_duration_ms();
  ::PROTOBUF_NAMESPACE_ID::int64 duration_ms() const;
  void set_duration_ms(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional .clearcut.connectivity.DefaultNetworkEvent.IPSupport ip_support = 2;
  bool has_ip_support() const;
  void clear_ip_support();
  ::clearcut::connectivity::DefaultNetworkEvent_IPSupport ip_support() const;
  void set_ip_support(::clearcut::connectivity::DefaultNetworkEvent_IPSupport value);

  // optional bool ever_validated = 3;
  bool has_ever_validated() const;
  void clear_ever_validated();
  bool ever_validated() const;
  void set_ever_validated(bool value);

  // optional bool portal_found = 4;
  bool has_portal_found() const;
  void clear_portal_found();
  bool portal_found() const;
  void set_portal_found(bool value);

  // optional int32 no_connectivity_reports = 5;
  bool has_no_connectivity_reports() const;
  void clear_no_connectivity_reports();
  ::PROTOBUF_NAMESPACE_ID::int32 no_connectivity_reports() const;
  void set_no_connectivity_reports(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 validation_attempts = 6;
  bool has_validation_attempts() const;
  void clear_validation_attempts();
  ::PROTOBUF_NAMESPACE_ID::int32 validation_attempts() const;
  void set_validation_attempts(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:clearcut.connectivity.NetworkStats)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair > validation_events_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair > validation_states_;
  ::PROTOBUF_NAMESPACE_ID::int64 duration_ms_;
  int ip_support_;
  bool ever_validated_;
  bool portal_found_;
  ::PROTOBUF_NAMESPACE_ID::int32 no_connectivity_reports_;
  ::PROTOBUF_NAMESPACE_ID::int32 validation_attempts_;
  friend struct ::TableStruct_frameworks_2fbase_2fproto_2fsrc_2fipconnectivity_2eproto;
};
// -------------------------------------------------------------------

class WakeupStats :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:clearcut.connectivity.WakeupStats) */ {
 public:
  WakeupStats();
  virtual ~WakeupStats();

  WakeupStats(const WakeupStats& from);
  WakeupStats(WakeupStats&& from) noexcept
    : WakeupStats() {
    *this = ::std::move(from);
  }

  inline WakeupStats& operator=(const WakeupStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline WakeupStats& operator=(WakeupStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const WakeupStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WakeupStats* internal_default_instance() {
    return reinterpret_cast<const WakeupStats*>(
               &_WakeupStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(WakeupStats& a, WakeupStats& b) {
    a.Swap(&b);
  }
  inline void Swap(WakeupStats* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WakeupStats* New() const final {
    return CreateMaybeMessage<WakeupStats>(nullptr);
  }

  WakeupStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WakeupStats>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const WakeupStats& from);
  void MergeFrom(const WakeupStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WakeupStats* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clearcut.connectivity.WakeupStats";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEthertypeCountsFieldNumber = 8,
    kIpNextHeaderCountsFieldNumber = 9,
    kDurationSecFieldNumber = 1,
    kTotalWakeupsFieldNumber = 2,
    kRootWakeupsFieldNumber = 3,
    kSystemWakeupsFieldNumber = 4,
    kApplicationWakeupsFieldNumber = 5,
    kNonApplicationWakeupsFieldNumber = 6,
    kNoUidWakeupsFieldNumber = 7,
    kL2UnicastCountFieldNumber = 10,
    kL2MulticastCountFieldNumber = 11,
    kL2BroadcastCountFieldNumber = 12,
  };
  // repeated .clearcut.connectivity.Pair ethertype_counts = 8;
  int ethertype_counts_size() const;
  void clear_ethertype_counts();
  ::clearcut::connectivity::Pair* mutable_ethertype_counts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >*
      mutable_ethertype_counts();
  const ::clearcut::connectivity::Pair& ethertype_counts(int index) const;
  ::clearcut::connectivity::Pair* add_ethertype_counts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >&
      ethertype_counts() const;

  // repeated .clearcut.connectivity.Pair ip_next_header_counts = 9;
  int ip_next_header_counts_size() const;
  void clear_ip_next_header_counts();
  ::clearcut::connectivity::Pair* mutable_ip_next_header_counts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >*
      mutable_ip_next_header_counts();
  const ::clearcut::connectivity::Pair& ip_next_header_counts(int index) const;
  ::clearcut::connectivity::Pair* add_ip_next_header_counts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >&
      ip_next_header_counts() const;

  // optional int64 duration_sec = 1;
  bool has_duration_sec() const;
  void clear_duration_sec();
  ::PROTOBUF_NAMESPACE_ID::int64 duration_sec() const;
  void set_duration_sec(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 total_wakeups = 2;
  bool has_total_wakeups() const;
  void clear_total_wakeups();
  ::PROTOBUF_NAMESPACE_ID::int64 total_wakeups() const;
  void set_total_wakeups(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 root_wakeups = 3;
  bool has_root_wakeups() const;
  void clear_root_wakeups();
  ::PROTOBUF_NAMESPACE_ID::int64 root_wakeups() const;
  void set_root_wakeups(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 system_wakeups = 4;
  bool has_system_wakeups() const;
  void clear_system_wakeups();
  ::PROTOBUF_NAMESPACE_ID::int64 system_wakeups() const;
  void set_system_wakeups(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 application_wakeups = 5;
  bool has_application_wakeups() const;
  void clear_application_wakeups();
  ::PROTOBUF_NAMESPACE_ID::int64 application_wakeups() const;
  void set_application_wakeups(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 non_application_wakeups = 6;
  bool has_non_application_wakeups() const;
  void clear_non_application_wakeups();
  ::PROTOBUF_NAMESPACE_ID::int64 non_application_wakeups() const;
  void set_non_application_wakeups(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 no_uid_wakeups = 7;
  bool has_no_uid_wakeups() const;
  void clear_no_uid_wakeups();
  ::PROTOBUF_NAMESPACE_ID::int64 no_uid_wakeups() const;
  void set_no_uid_wakeups(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 l2_unicast_count = 10;
  bool has_l2_unicast_count() const;
  void clear_l2_unicast_count();
  ::PROTOBUF_NAMESPACE_ID::int64 l2_unicast_count() const;
  void set_l2_unicast_count(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 l2_multicast_count = 11;
  bool has_l2_multicast_count() const;
  void clear_l2_multicast_count();
  ::PROTOBUF_NAMESPACE_ID::int64 l2_multicast_count() const;
  void set_l2_multicast_count(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 l2_broadcast_count = 12;
  bool has_l2_broadcast_count() const;
  void clear_l2_broadcast_count();
  ::PROTOBUF_NAMESPACE_ID::int64 l2_broadcast_count() const;
  void set_l2_broadcast_count(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:clearcut.connectivity.WakeupStats)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair > ethertype_counts_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair > ip_next_header_counts_;
  ::PROTOBUF_NAMESPACE_ID::int64 duration_sec_;
  ::PROTOBUF_NAMESPACE_ID::int64 total_wakeups_;
  ::PROTOBUF_NAMESPACE_ID::int64 root_wakeups_;
  ::PROTOBUF_NAMESPACE_ID::int64 system_wakeups_;
  ::PROTOBUF_NAMESPACE_ID::int64 application_wakeups_;
  ::PROTOBUF_NAMESPACE_ID::int64 non_application_wakeups_;
  ::PROTOBUF_NAMESPACE_ID::int64 no_uid_wakeups_;
  ::PROTOBUF_NAMESPACE_ID::int64 l2_unicast_count_;
  ::PROTOBUF_NAMESPACE_ID::int64 l2_multicast_count_;
  ::PROTOBUF_NAMESPACE_ID::int64 l2_broadcast_count_;
  friend struct ::TableStruct_frameworks_2fbase_2fproto_2fsrc_2fipconnectivity_2eproto;
};
// -------------------------------------------------------------------

class IpConnectivityEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:clearcut.connectivity.IpConnectivityEvent) */ {
 public:
  IpConnectivityEvent();
  virtual ~IpConnectivityEvent();

  IpConnectivityEvent(const IpConnectivityEvent& from);
  IpConnectivityEvent(IpConnectivityEvent&& from) noexcept
    : IpConnectivityEvent() {
    *this = ::std::move(from);
  }

  inline IpConnectivityEvent& operator=(const IpConnectivityEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IpConnectivityEvent& operator=(IpConnectivityEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IpConnectivityEvent& default_instance();

  enum EventCase {
    kDefaultNetworkEvent = 2,
    kIpReachabilityEvent = 3,
    kNetworkEvent = 4,
    kDnsLookupBatch = 5,
    kDnsLatencies = 13,
    kConnectStatistics = 14,
    kDhcpEvent = 6,
    kIpProvisioningEvent = 7,
    kValidationProbeEvent = 8,
    kApfProgramEvent = 9,
    kApfStatistics = 10,
    kRaEvent = 11,
    kNetworkStats = 19,
    kWakeupStats = 20,
    EVENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IpConnectivityEvent* internal_default_instance() {
    return reinterpret_cast<const IpConnectivityEvent*>(
               &_IpConnectivityEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(IpConnectivityEvent& a, IpConnectivityEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IpConnectivityEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IpConnectivityEvent* New() const final {
    return CreateMaybeMessage<IpConnectivityEvent>(nullptr);
  }

  IpConnectivityEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IpConnectivityEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IpConnectivityEvent& from);
  void MergeFrom(const IpConnectivityEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IpConnectivityEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clearcut.connectivity.IpConnectivityEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIfNameFieldNumber = 17,
    kTimeMsFieldNumber = 1,
    kLinkLayerFieldNumber = 15,
    kNetworkIdFieldNumber = 16,
    kTransportsFieldNumber = 18,
    kDefaultNetworkEventFieldNumber = 2,
    kIpReachabilityEventFieldNumber = 3,
    kNetworkEventFieldNumber = 4,
    kDnsLookupBatchFieldNumber = 5,
    kDnsLatenciesFieldNumber = 13,
    kConnectStatisticsFieldNumber = 14,
    kDhcpEventFieldNumber = 6,
    kIpProvisioningEventFieldNumber = 7,
    kValidationProbeEventFieldNumber = 8,
    kApfProgramEventFieldNumber = 9,
    kApfStatisticsFieldNumber = 10,
    kRaEventFieldNumber = 11,
    kNetworkStatsFieldNumber = 19,
    kWakeupStatsFieldNumber = 20,
  };
  // optional string if_name = 17;
  bool has_if_name() const;
  void clear_if_name();
  const std::string& if_name() const;
  void set_if_name(const std::string& value);
  void set_if_name(std::string&& value);
  void set_if_name(const char* value);
  void set_if_name(const char* value, size_t size);
  std::string* mutable_if_name();
  std::string* release_if_name();
  void set_allocated_if_name(std::string* if_name);

  // optional int64 time_ms = 1;
  bool has_time_ms() const;
  void clear_time_ms();
  ::PROTOBUF_NAMESPACE_ID::int64 time_ms() const;
  void set_time_ms(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional .clearcut.connectivity.LinkLayer link_layer = 15;
  bool has_link_layer() const;
  void clear_link_layer();
  ::clearcut::connectivity::LinkLayer link_layer() const;
  void set_link_layer(::clearcut::connectivity::LinkLayer value);

  // optional int32 network_id = 16;
  bool has_network_id() const;
  void clear_network_id();
  ::PROTOBUF_NAMESPACE_ID::int32 network_id() const;
  void set_network_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int64 transports = 18;
  bool has_transports() const;
  void clear_transports();
  ::PROTOBUF_NAMESPACE_ID::int64 transports() const;
  void set_transports(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional .clearcut.connectivity.DefaultNetworkEvent default_network_event = 2;
  bool has_default_network_event() const;
  void clear_default_network_event();
  const ::clearcut::connectivity::DefaultNetworkEvent& default_network_event() const;
  ::clearcut::connectivity::DefaultNetworkEvent* release_default_network_event();
  ::clearcut::connectivity::DefaultNetworkEvent* mutable_default_network_event();
  void set_allocated_default_network_event(::clearcut::connectivity::DefaultNetworkEvent* default_network_event);

  // optional .clearcut.connectivity.IpReachabilityEvent ip_reachability_event = 3;
  bool has_ip_reachability_event() const;
  void clear_ip_reachability_event();
  const ::clearcut::connectivity::IpReachabilityEvent& ip_reachability_event() const;
  ::clearcut::connectivity::IpReachabilityEvent* release_ip_reachability_event();
  ::clearcut::connectivity::IpReachabilityEvent* mutable_ip_reachability_event();
  void set_allocated_ip_reachability_event(::clearcut::connectivity::IpReachabilityEvent* ip_reachability_event);

  // optional .clearcut.connectivity.NetworkEvent network_event = 4 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_network_event() const;
  PROTOBUF_DEPRECATED void clear_network_event();
  PROTOBUF_DEPRECATED const ::clearcut::connectivity::NetworkEvent& network_event() const;
  PROTOBUF_DEPRECATED ::clearcut::connectivity::NetworkEvent* release_network_event();
  PROTOBUF_DEPRECATED ::clearcut::connectivity::NetworkEvent* mutable_network_event();
  PROTOBUF_DEPRECATED void set_allocated_network_event(::clearcut::connectivity::NetworkEvent* network_event);

  // optional .clearcut.connectivity.DNSLookupBatch dns_lookup_batch = 5 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_dns_lookup_batch() const;
  PROTOBUF_DEPRECATED void clear_dns_lookup_batch();
  PROTOBUF_DEPRECATED const ::clearcut::connectivity::DNSLookupBatch& dns_lookup_batch() const;
  PROTOBUF_DEPRECATED ::clearcut::connectivity::DNSLookupBatch* release_dns_lookup_batch();
  PROTOBUF_DEPRECATED ::clearcut::connectivity::DNSLookupBatch* mutable_dns_lookup_batch();
  PROTOBUF_DEPRECATED void set_allocated_dns_lookup_batch(::clearcut::connectivity::DNSLookupBatch* dns_lookup_batch);

  // optional .clearcut.connectivity.DNSLatencies dns_latencies = 13;
  bool has_dns_latencies() const;
  void clear_dns_latencies();
  const ::clearcut::connectivity::DNSLatencies& dns_latencies() const;
  ::clearcut::connectivity::DNSLatencies* release_dns_latencies();
  ::clearcut::connectivity::DNSLatencies* mutable_dns_latencies();
  void set_allocated_dns_latencies(::clearcut::connectivity::DNSLatencies* dns_latencies);

  // optional .clearcut.connectivity.ConnectStatistics connect_statistics = 14;
  bool has_connect_statistics() const;
  void clear_connect_statistics();
  const ::clearcut::connectivity::ConnectStatistics& connect_statistics() const;
  ::clearcut::connectivity::ConnectStatistics* release_connect_statistics();
  ::clearcut::connectivity::ConnectStatistics* mutable_connect_statistics();
  void set_allocated_connect_statistics(::clearcut::connectivity::ConnectStatistics* connect_statistics);

  // optional .clearcut.connectivity.DHCPEvent dhcp_event = 6;
  bool has_dhcp_event() const;
  void clear_dhcp_event();
  const ::clearcut::connectivity::DHCPEvent& dhcp_event() const;
  ::clearcut::connectivity::DHCPEvent* release_dhcp_event();
  ::clearcut::connectivity::DHCPEvent* mutable_dhcp_event();
  void set_allocated_dhcp_event(::clearcut::connectivity::DHCPEvent* dhcp_event);

  // optional .clearcut.connectivity.IpProvisioningEvent ip_provisioning_event = 7;
  bool has_ip_provisioning_event() const;
  void clear_ip_provisioning_event();
  const ::clearcut::connectivity::IpProvisioningEvent& ip_provisioning_event() const;
  ::clearcut::connectivity::IpProvisioningEvent* release_ip_provisioning_event();
  ::clearcut::connectivity::IpProvisioningEvent* mutable_ip_provisioning_event();
  void set_allocated_ip_provisioning_event(::clearcut::connectivity::IpProvisioningEvent* ip_provisioning_event);

  // optional .clearcut.connectivity.ValidationProbeEvent validation_probe_event = 8;
  bool has_validation_probe_event() const;
  void clear_validation_probe_event();
  const ::clearcut::connectivity::ValidationProbeEvent& validation_probe_event() const;
  ::clearcut::connectivity::ValidationProbeEvent* release_validation_probe_event();
  ::clearcut::connectivity::ValidationProbeEvent* mutable_validation_probe_event();
  void set_allocated_validation_probe_event(::clearcut::connectivity::ValidationProbeEvent* validation_probe_event);

  // optional .clearcut.connectivity.ApfProgramEvent apf_program_event = 9;
  bool has_apf_program_event() const;
  void clear_apf_program_event();
  const ::clearcut::connectivity::ApfProgramEvent& apf_program_event() const;
  ::clearcut::connectivity::ApfProgramEvent* release_apf_program_event();
  ::clearcut::connectivity::ApfProgramEvent* mutable_apf_program_event();
  void set_allocated_apf_program_event(::clearcut::connectivity::ApfProgramEvent* apf_program_event);

  // optional .clearcut.connectivity.ApfStatistics apf_statistics = 10;
  bool has_apf_statistics() const;
  void clear_apf_statistics();
  const ::clearcut::connectivity::ApfStatistics& apf_statistics() const;
  ::clearcut::connectivity::ApfStatistics* release_apf_statistics();
  ::clearcut::connectivity::ApfStatistics* mutable_apf_statistics();
  void set_allocated_apf_statistics(::clearcut::connectivity::ApfStatistics* apf_statistics);

  // optional .clearcut.connectivity.RaEvent ra_event = 11;
  bool has_ra_event() const;
  void clear_ra_event();
  const ::clearcut::connectivity::RaEvent& ra_event() const;
  ::clearcut::connectivity::RaEvent* release_ra_event();
  ::clearcut::connectivity::RaEvent* mutable_ra_event();
  void set_allocated_ra_event(::clearcut::connectivity::RaEvent* ra_event);

  // optional .clearcut.connectivity.NetworkStats network_stats = 19;
  bool has_network_stats() const;
  void clear_network_stats();
  const ::clearcut::connectivity::NetworkStats& network_stats() const;
  ::clearcut::connectivity::NetworkStats* release_network_stats();
  ::clearcut::connectivity::NetworkStats* mutable_network_stats();
  void set_allocated_network_stats(::clearcut::connectivity::NetworkStats* network_stats);

  // optional .clearcut.connectivity.WakeupStats wakeup_stats = 20;
  bool has_wakeup_stats() const;
  void clear_wakeup_stats();
  const ::clearcut::connectivity::WakeupStats& wakeup_stats() const;
  ::clearcut::connectivity::WakeupStats* release_wakeup_stats();
  ::clearcut::connectivity::WakeupStats* mutable_wakeup_stats();
  void set_allocated_wakeup_stats(::clearcut::connectivity::WakeupStats* wakeup_stats);

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:clearcut.connectivity.IpConnectivityEvent)
 private:
  class _Internal;
  void set_has_default_network_event();
  void set_has_ip_reachability_event();
  void set_has_network_event();
  void set_has_dns_lookup_batch();
  void set_has_dns_latencies();
  void set_has_connect_statistics();
  void set_has_dhcp_event();
  void set_has_ip_provisioning_event();
  void set_has_validation_probe_event();
  void set_has_apf_program_event();
  void set_has_apf_statistics();
  void set_has_ra_event();
  void set_has_network_stats();
  void set_has_wakeup_stats();

  inline bool has_event() const;
  inline void clear_has_event();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr if_name_;
  ::PROTOBUF_NAMESPACE_ID::int64 time_ms_;
  int link_layer_;
  ::PROTOBUF_NAMESPACE_ID::int32 network_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 transports_;
  union EventUnion {
    EventUnion() {}
    ::clearcut::connectivity::DefaultNetworkEvent* default_network_event_;
    ::clearcut::connectivity::IpReachabilityEvent* ip_reachability_event_;
    ::clearcut::connectivity::NetworkEvent* network_event_;
    ::clearcut::connectivity::DNSLookupBatch* dns_lookup_batch_;
    ::clearcut::connectivity::DNSLatencies* dns_latencies_;
    ::clearcut::connectivity::ConnectStatistics* connect_statistics_;
    ::clearcut::connectivity::DHCPEvent* dhcp_event_;
    ::clearcut::connectivity::IpProvisioningEvent* ip_provisioning_event_;
    ::clearcut::connectivity::ValidationProbeEvent* validation_probe_event_;
    ::clearcut::connectivity::ApfProgramEvent* apf_program_event_;
    ::clearcut::connectivity::ApfStatistics* apf_statistics_;
    ::clearcut::connectivity::RaEvent* ra_event_;
    ::clearcut::connectivity::NetworkStats* network_stats_;
    ::clearcut::connectivity::WakeupStats* wakeup_stats_;
  } event_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_frameworks_2fbase_2fproto_2fsrc_2fipconnectivity_2eproto;
};
// -------------------------------------------------------------------

class IpConnectivityLog :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:clearcut.connectivity.IpConnectivityLog) */ {
 public:
  IpConnectivityLog();
  virtual ~IpConnectivityLog();

  IpConnectivityLog(const IpConnectivityLog& from);
  IpConnectivityLog(IpConnectivityLog&& from) noexcept
    : IpConnectivityLog() {
    *this = ::std::move(from);
  }

  inline IpConnectivityLog& operator=(const IpConnectivityLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline IpConnectivityLog& operator=(IpConnectivityLog&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IpConnectivityLog& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IpConnectivityLog* internal_default_instance() {
    return reinterpret_cast<const IpConnectivityLog*>(
               &_IpConnectivityLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(IpConnectivityLog& a, IpConnectivityLog& b) {
    a.Swap(&b);
  }
  inline void Swap(IpConnectivityLog* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IpConnectivityLog* New() const final {
    return CreateMaybeMessage<IpConnectivityLog>(nullptr);
  }

  IpConnectivityLog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IpConnectivityLog>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IpConnectivityLog& from);
  void MergeFrom(const IpConnectivityLog& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IpConnectivityLog* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clearcut.connectivity.IpConnectivityLog";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 1,
    kDroppedEventsFieldNumber = 2,
    kVersionFieldNumber = 3,
  };
  // repeated .clearcut.connectivity.IpConnectivityEvent events = 1;
  int events_size() const;
  void clear_events();
  ::clearcut::connectivity::IpConnectivityEvent* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::IpConnectivityEvent >*
      mutable_events();
  const ::clearcut::connectivity::IpConnectivityEvent& events(int index) const;
  ::clearcut::connectivity::IpConnectivityEvent* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::IpConnectivityEvent >&
      events() const;

  // optional int32 dropped_events = 2;
  bool has_dropped_events() const;
  void clear_dropped_events();
  ::PROTOBUF_NAMESPACE_ID::int32 dropped_events() const;
  void set_dropped_events(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 version = 3;
  bool has_version() const;
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:clearcut.connectivity.IpConnectivityLog)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::IpConnectivityEvent > events_;
  ::PROTOBUF_NAMESPACE_ID::int32 dropped_events_;
  ::PROTOBUF_NAMESPACE_ID::int32 version_;
  friend struct ::TableStruct_frameworks_2fbase_2fproto_2fsrc_2fipconnectivity_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NetworkId

// optional int32 network_id = 1;
inline bool NetworkId::has_network_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetworkId::clear_network_id() {
  network_id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NetworkId::network_id() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.NetworkId.network_id)
  return network_id_;
}
inline void NetworkId::set_network_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  network_id_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.NetworkId.network_id)
}

// -------------------------------------------------------------------

// Pair

// optional int32 key = 1;
inline bool Pair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pair::clear_key() {
  key_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Pair::key() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.Pair.key)
  return key_;
}
inline void Pair::set_key(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  key_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.Pair.key)
}

// optional int32 value = 2;
inline bool Pair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pair::clear_value() {
  value_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Pair::value() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.Pair.value)
  return value_;
}
inline void Pair::set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  value_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.Pair.value)
}

// -------------------------------------------------------------------

// DefaultNetworkEvent

// optional int64 default_network_duration_ms = 5;
inline bool DefaultNetworkEvent::has_default_network_duration_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DefaultNetworkEvent::clear_default_network_duration_ms() {
  default_network_duration_ms_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DefaultNetworkEvent::default_network_duration_ms() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DefaultNetworkEvent.default_network_duration_ms)
  return default_network_duration_ms_;
}
inline void DefaultNetworkEvent::set_default_network_duration_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  default_network_duration_ms_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DefaultNetworkEvent.default_network_duration_ms)
}

// optional int64 validation_duration_ms = 11;
inline bool DefaultNetworkEvent::has_validation_duration_ms() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DefaultNetworkEvent::clear_validation_duration_ms() {
  validation_duration_ms_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DefaultNetworkEvent::validation_duration_ms() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DefaultNetworkEvent.validation_duration_ms)
  return validation_duration_ms_;
}
inline void DefaultNetworkEvent::set_validation_duration_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000100u;
  validation_duration_ms_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DefaultNetworkEvent.validation_duration_ms)
}

// optional int64 initial_score = 7;
inline bool DefaultNetworkEvent::has_initial_score() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DefaultNetworkEvent::clear_initial_score() {
  initial_score_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DefaultNetworkEvent::initial_score() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DefaultNetworkEvent.initial_score)
  return initial_score_;
}
inline void DefaultNetworkEvent::set_initial_score(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  initial_score_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DefaultNetworkEvent.initial_score)
}

// optional int64 final_score = 8;
inline bool DefaultNetworkEvent::has_final_score() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DefaultNetworkEvent::clear_final_score() {
  final_score_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DefaultNetworkEvent::final_score() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DefaultNetworkEvent.final_score)
  return final_score_;
}
inline void DefaultNetworkEvent::set_final_score(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000080u;
  final_score_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DefaultNetworkEvent.final_score)
}

// optional .clearcut.connectivity.DefaultNetworkEvent.IPSupport ip_support = 9;
inline bool DefaultNetworkEvent::has_ip_support() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DefaultNetworkEvent::clear_ip_support() {
  ip_support_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::clearcut::connectivity::DefaultNetworkEvent_IPSupport DefaultNetworkEvent::ip_support() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DefaultNetworkEvent.ip_support)
  return static_cast< ::clearcut::connectivity::DefaultNetworkEvent_IPSupport >(ip_support_);
}
inline void DefaultNetworkEvent::set_ip_support(::clearcut::connectivity::DefaultNetworkEvent_IPSupport value) {
  assert(::clearcut::connectivity::DefaultNetworkEvent_IPSupport_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  ip_support_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DefaultNetworkEvent.ip_support)
}

// optional .clearcut.connectivity.LinkLayer previous_default_network_link_layer = 10;
inline bool DefaultNetworkEvent::has_previous_default_network_link_layer() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DefaultNetworkEvent::clear_previous_default_network_link_layer() {
  previous_default_network_link_layer_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::clearcut::connectivity::LinkLayer DefaultNetworkEvent::previous_default_network_link_layer() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DefaultNetworkEvent.previous_default_network_link_layer)
  return static_cast< ::clearcut::connectivity::LinkLayer >(previous_default_network_link_layer_);
}
inline void DefaultNetworkEvent::set_previous_default_network_link_layer(::clearcut::connectivity::LinkLayer value) {
  assert(::clearcut::connectivity::LinkLayer_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  previous_default_network_link_layer_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DefaultNetworkEvent.previous_default_network_link_layer)
}

// optional .clearcut.connectivity.NetworkId network_id = 1 [deprecated = true];
inline bool DefaultNetworkEvent::has_network_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DefaultNetworkEvent::clear_network_id() {
  if (network_id_ != nullptr) network_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::clearcut::connectivity::NetworkId& DefaultNetworkEvent::network_id() const {
  const ::clearcut::connectivity::NetworkId* p = network_id_;
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DefaultNetworkEvent.network_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::clearcut::connectivity::NetworkId*>(
      &::clearcut::connectivity::_NetworkId_default_instance_);
}
inline ::clearcut::connectivity::NetworkId* DefaultNetworkEvent::release_network_id() {
  // @@protoc_insertion_point(field_release:clearcut.connectivity.DefaultNetworkEvent.network_id)
  _has_bits_[0] &= ~0x00000001u;
  ::clearcut::connectivity::NetworkId* temp = network_id_;
  network_id_ = nullptr;
  return temp;
}
inline ::clearcut::connectivity::NetworkId* DefaultNetworkEvent::mutable_network_id() {
  _has_bits_[0] |= 0x00000001u;
  if (network_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::clearcut::connectivity::NetworkId>(GetArenaNoVirtual());
    network_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.DefaultNetworkEvent.network_id)
  return network_id_;
}
inline void DefaultNetworkEvent::set_allocated_network_id(::clearcut::connectivity::NetworkId* network_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete network_id_;
  }
  if (network_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      network_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, network_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  network_id_ = network_id;
  // @@protoc_insertion_point(field_set_allocated:clearcut.connectivity.DefaultNetworkEvent.network_id)
}

// optional .clearcut.connectivity.NetworkId previous_network_id = 2 [deprecated = true];
inline bool DefaultNetworkEvent::has_previous_network_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DefaultNetworkEvent::clear_previous_network_id() {
  if (previous_network_id_ != nullptr) previous_network_id_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::clearcut::connectivity::NetworkId& DefaultNetworkEvent::previous_network_id() const {
  const ::clearcut::connectivity::NetworkId* p = previous_network_id_;
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DefaultNetworkEvent.previous_network_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::clearcut::connectivity::NetworkId*>(
      &::clearcut::connectivity::_NetworkId_default_instance_);
}
inline ::clearcut::connectivity::NetworkId* DefaultNetworkEvent::release_previous_network_id() {
  // @@protoc_insertion_point(field_release:clearcut.connectivity.DefaultNetworkEvent.previous_network_id)
  _has_bits_[0] &= ~0x00000002u;
  ::clearcut::connectivity::NetworkId* temp = previous_network_id_;
  previous_network_id_ = nullptr;
  return temp;
}
inline ::clearcut::connectivity::NetworkId* DefaultNetworkEvent::mutable_previous_network_id() {
  _has_bits_[0] |= 0x00000002u;
  if (previous_network_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::clearcut::connectivity::NetworkId>(GetArenaNoVirtual());
    previous_network_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.DefaultNetworkEvent.previous_network_id)
  return previous_network_id_;
}
inline void DefaultNetworkEvent::set_allocated_previous_network_id(::clearcut::connectivity::NetworkId* previous_network_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete previous_network_id_;
  }
  if (previous_network_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      previous_network_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, previous_network_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  previous_network_id_ = previous_network_id;
  // @@protoc_insertion_point(field_set_allocated:clearcut.connectivity.DefaultNetworkEvent.previous_network_id)
}

// optional .clearcut.connectivity.DefaultNetworkEvent.IPSupport previous_network_ip_support = 3 [deprecated = true];
inline bool DefaultNetworkEvent::has_previous_network_ip_support() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DefaultNetworkEvent::clear_previous_network_ip_support() {
  previous_network_ip_support_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::clearcut::connectivity::DefaultNetworkEvent_IPSupport DefaultNetworkEvent::previous_network_ip_support() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DefaultNetworkEvent.previous_network_ip_support)
  return static_cast< ::clearcut::connectivity::DefaultNetworkEvent_IPSupport >(previous_network_ip_support_);
}
inline void DefaultNetworkEvent::set_previous_network_ip_support(::clearcut::connectivity::DefaultNetworkEvent_IPSupport value) {
  assert(::clearcut::connectivity::DefaultNetworkEvent_IPSupport_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  previous_network_ip_support_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DefaultNetworkEvent.previous_network_ip_support)
}

// repeated int32 transport_types = 4 [deprecated = true];
inline int DefaultNetworkEvent::transport_types_size() const {
  return transport_types_.size();
}
inline void DefaultNetworkEvent::clear_transport_types() {
  transport_types_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DefaultNetworkEvent::transport_types(int index) const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DefaultNetworkEvent.transport_types)
  return transport_types_.Get(index);
}
inline void DefaultNetworkEvent::set_transport_types(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  transport_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DefaultNetworkEvent.transport_types)
}
inline void DefaultNetworkEvent::add_transport_types(::PROTOBUF_NAMESPACE_ID::int32 value) {
  transport_types_.Add(value);
  // @@protoc_insertion_point(field_add:clearcut.connectivity.DefaultNetworkEvent.transport_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
DefaultNetworkEvent::transport_types() const {
  // @@protoc_insertion_point(field_list:clearcut.connectivity.DefaultNetworkEvent.transport_types)
  return transport_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
DefaultNetworkEvent::mutable_transport_types() {
  // @@protoc_insertion_point(field_mutable_list:clearcut.connectivity.DefaultNetworkEvent.transport_types)
  return &transport_types_;
}

// optional int64 no_default_network_duration_ms = 6 [deprecated = true];
inline bool DefaultNetworkEvent::has_no_default_network_duration_ms() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DefaultNetworkEvent::clear_no_default_network_duration_ms() {
  no_default_network_duration_ms_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DefaultNetworkEvent::no_default_network_duration_ms() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DefaultNetworkEvent.no_default_network_duration_ms)
  return no_default_network_duration_ms_;
}
inline void DefaultNetworkEvent::set_no_default_network_duration_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  no_default_network_duration_ms_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DefaultNetworkEvent.no_default_network_duration_ms)
}

// -------------------------------------------------------------------

// IpReachabilityEvent

// optional string if_name = 1 [deprecated = true];
inline bool IpReachabilityEvent::has_if_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IpReachabilityEvent::clear_if_name() {
  if_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IpReachabilityEvent::if_name() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpReachabilityEvent.if_name)
  return if_name_.GetNoArena();
}
inline void IpReachabilityEvent::set_if_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  if_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:clearcut.connectivity.IpReachabilityEvent.if_name)
}
inline void IpReachabilityEvent::set_if_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  if_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:clearcut.connectivity.IpReachabilityEvent.if_name)
}
inline void IpReachabilityEvent::set_if_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  if_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:clearcut.connectivity.IpReachabilityEvent.if_name)
}
inline void IpReachabilityEvent::set_if_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  if_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:clearcut.connectivity.IpReachabilityEvent.if_name)
}
inline std::string* IpReachabilityEvent::mutable_if_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.IpReachabilityEvent.if_name)
  return if_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* IpReachabilityEvent::release_if_name() {
  // @@protoc_insertion_point(field_release:clearcut.connectivity.IpReachabilityEvent.if_name)
  if (!has_if_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return if_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void IpReachabilityEvent::set_allocated_if_name(std::string* if_name) {
  if (if_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  if_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), if_name);
  // @@protoc_insertion_point(field_set_allocated:clearcut.connectivity.IpReachabilityEvent.if_name)
}

// optional int32 event_type = 2;
inline bool IpReachabilityEvent::has_event_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IpReachabilityEvent::clear_event_type() {
  event_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IpReachabilityEvent::event_type() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpReachabilityEvent.event_type)
  return event_type_;
}
inline void IpReachabilityEvent::set_event_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  event_type_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.IpReachabilityEvent.event_type)
}

// -------------------------------------------------------------------

// NetworkEvent

// optional .clearcut.connectivity.NetworkId network_id = 1 [deprecated = true];
inline bool NetworkEvent::has_network_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetworkEvent::clear_network_id() {
  if (network_id_ != nullptr) network_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::clearcut::connectivity::NetworkId& NetworkEvent::network_id() const {
  const ::clearcut::connectivity::NetworkId* p = network_id_;
  // @@protoc_insertion_point(field_get:clearcut.connectivity.NetworkEvent.network_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::clearcut::connectivity::NetworkId*>(
      &::clearcut::connectivity::_NetworkId_default_instance_);
}
inline ::clearcut::connectivity::NetworkId* NetworkEvent::release_network_id() {
  // @@protoc_insertion_point(field_release:clearcut.connectivity.NetworkEvent.network_id)
  _has_bits_[0] &= ~0x00000001u;
  ::clearcut::connectivity::NetworkId* temp = network_id_;
  network_id_ = nullptr;
  return temp;
}
inline ::clearcut::connectivity::NetworkId* NetworkEvent::mutable_network_id() {
  _has_bits_[0] |= 0x00000001u;
  if (network_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::clearcut::connectivity::NetworkId>(GetArenaNoVirtual());
    network_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.NetworkEvent.network_id)
  return network_id_;
}
inline void NetworkEvent::set_allocated_network_id(::clearcut::connectivity::NetworkId* network_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete network_id_;
  }
  if (network_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      network_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, network_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  network_id_ = network_id;
  // @@protoc_insertion_point(field_set_allocated:clearcut.connectivity.NetworkEvent.network_id)
}

// optional int32 event_type = 2;
inline bool NetworkEvent::has_event_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetworkEvent::clear_event_type() {
  event_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NetworkEvent::event_type() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.NetworkEvent.event_type)
  return event_type_;
}
inline void NetworkEvent::set_event_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  event_type_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.NetworkEvent.event_type)
}

// optional int32 latency_ms = 3;
inline bool NetworkEvent::has_latency_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetworkEvent::clear_latency_ms() {
  latency_ms_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NetworkEvent::latency_ms() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.NetworkEvent.latency_ms)
  return latency_ms_;
}
inline void NetworkEvent::set_latency_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  latency_ms_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.NetworkEvent.latency_ms)
}

// -------------------------------------------------------------------

// ValidationProbeEvent

// optional .clearcut.connectivity.NetworkId network_id = 1 [deprecated = true];
inline bool ValidationProbeEvent::has_network_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ValidationProbeEvent::clear_network_id() {
  if (network_id_ != nullptr) network_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::clearcut::connectivity::NetworkId& ValidationProbeEvent::network_id() const {
  const ::clearcut::connectivity::NetworkId* p = network_id_;
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ValidationProbeEvent.network_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::clearcut::connectivity::NetworkId*>(
      &::clearcut::connectivity::_NetworkId_default_instance_);
}
inline ::clearcut::connectivity::NetworkId* ValidationProbeEvent::release_network_id() {
  // @@protoc_insertion_point(field_release:clearcut.connectivity.ValidationProbeEvent.network_id)
  _has_bits_[0] &= ~0x00000001u;
  ::clearcut::connectivity::NetworkId* temp = network_id_;
  network_id_ = nullptr;
  return temp;
}
inline ::clearcut::connectivity::NetworkId* ValidationProbeEvent::mutable_network_id() {
  _has_bits_[0] |= 0x00000001u;
  if (network_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::clearcut::connectivity::NetworkId>(GetArenaNoVirtual());
    network_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.ValidationProbeEvent.network_id)
  return network_id_;
}
inline void ValidationProbeEvent::set_allocated_network_id(::clearcut::connectivity::NetworkId* network_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete network_id_;
  }
  if (network_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      network_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, network_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  network_id_ = network_id;
  // @@protoc_insertion_point(field_set_allocated:clearcut.connectivity.ValidationProbeEvent.network_id)
}

// optional int32 latency_ms = 2;
inline bool ValidationProbeEvent::has_latency_ms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ValidationProbeEvent::clear_latency_ms() {
  latency_ms_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ValidationProbeEvent::latency_ms() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ValidationProbeEvent.latency_ms)
  return latency_ms_;
}
inline void ValidationProbeEvent::set_latency_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  latency_ms_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ValidationProbeEvent.latency_ms)
}

// optional int32 probe_type = 3;
inline bool ValidationProbeEvent::has_probe_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ValidationProbeEvent::clear_probe_type() {
  probe_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ValidationProbeEvent::probe_type() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ValidationProbeEvent.probe_type)
  return probe_type_;
}
inline void ValidationProbeEvent::set_probe_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  probe_type_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ValidationProbeEvent.probe_type)
}

// optional int32 probe_result = 4;
inline bool ValidationProbeEvent::has_probe_result() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ValidationProbeEvent::clear_probe_result() {
  probe_result_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ValidationProbeEvent::probe_result() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ValidationProbeEvent.probe_result)
  return probe_result_;
}
inline void ValidationProbeEvent::set_probe_result(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  probe_result_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ValidationProbeEvent.probe_result)
}

// -------------------------------------------------------------------

// DNSLookupBatch

// repeated int32 latencies_ms = 4;
inline int DNSLookupBatch::latencies_ms_size() const {
  return latencies_ms_.size();
}
inline void DNSLookupBatch::clear_latencies_ms() {
  latencies_ms_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DNSLookupBatch::latencies_ms(int index) const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DNSLookupBatch.latencies_ms)
  return latencies_ms_.Get(index);
}
inline void DNSLookupBatch::set_latencies_ms(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  latencies_ms_.Set(index, value);
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DNSLookupBatch.latencies_ms)
}
inline void DNSLookupBatch::add_latencies_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  latencies_ms_.Add(value);
  // @@protoc_insertion_point(field_add:clearcut.connectivity.DNSLookupBatch.latencies_ms)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
DNSLookupBatch::latencies_ms() const {
  // @@protoc_insertion_point(field_list:clearcut.connectivity.DNSLookupBatch.latencies_ms)
  return latencies_ms_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
DNSLookupBatch::mutable_latencies_ms() {
  // @@protoc_insertion_point(field_mutable_list:clearcut.connectivity.DNSLookupBatch.latencies_ms)
  return &latencies_ms_;
}

// optional int64 getaddrinfo_query_count = 5;
inline bool DNSLookupBatch::has_getaddrinfo_query_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DNSLookupBatch::clear_getaddrinfo_query_count() {
  getaddrinfo_query_count_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DNSLookupBatch::getaddrinfo_query_count() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DNSLookupBatch.getaddrinfo_query_count)
  return getaddrinfo_query_count_;
}
inline void DNSLookupBatch::set_getaddrinfo_query_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  getaddrinfo_query_count_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DNSLookupBatch.getaddrinfo_query_count)
}

// optional int64 gethostbyname_query_count = 6;
inline bool DNSLookupBatch::has_gethostbyname_query_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DNSLookupBatch::clear_gethostbyname_query_count() {
  gethostbyname_query_count_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DNSLookupBatch::gethostbyname_query_count() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DNSLookupBatch.gethostbyname_query_count)
  return gethostbyname_query_count_;
}
inline void DNSLookupBatch::set_gethostbyname_query_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  gethostbyname_query_count_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DNSLookupBatch.gethostbyname_query_count)
}

// optional int64 getaddrinfo_error_count = 7;
inline bool DNSLookupBatch::has_getaddrinfo_error_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DNSLookupBatch::clear_getaddrinfo_error_count() {
  getaddrinfo_error_count_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DNSLookupBatch::getaddrinfo_error_count() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DNSLookupBatch.getaddrinfo_error_count)
  return getaddrinfo_error_count_;
}
inline void DNSLookupBatch::set_getaddrinfo_error_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  getaddrinfo_error_count_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DNSLookupBatch.getaddrinfo_error_count)
}

// optional int64 gethostbyname_error_count = 8;
inline bool DNSLookupBatch::has_gethostbyname_error_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DNSLookupBatch::clear_gethostbyname_error_count() {
  gethostbyname_error_count_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DNSLookupBatch::gethostbyname_error_count() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DNSLookupBatch.gethostbyname_error_count)
  return gethostbyname_error_count_;
}
inline void DNSLookupBatch::set_gethostbyname_error_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  gethostbyname_error_count_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DNSLookupBatch.gethostbyname_error_count)
}

// repeated .clearcut.connectivity.Pair getaddrinfo_errors = 9;
inline int DNSLookupBatch::getaddrinfo_errors_size() const {
  return getaddrinfo_errors_.size();
}
inline void DNSLookupBatch::clear_getaddrinfo_errors() {
  getaddrinfo_errors_.Clear();
}
inline ::clearcut::connectivity::Pair* DNSLookupBatch::mutable_getaddrinfo_errors(int index) {
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.DNSLookupBatch.getaddrinfo_errors)
  return getaddrinfo_errors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >*
DNSLookupBatch::mutable_getaddrinfo_errors() {
  // @@protoc_insertion_point(field_mutable_list:clearcut.connectivity.DNSLookupBatch.getaddrinfo_errors)
  return &getaddrinfo_errors_;
}
inline const ::clearcut::connectivity::Pair& DNSLookupBatch::getaddrinfo_errors(int index) const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DNSLookupBatch.getaddrinfo_errors)
  return getaddrinfo_errors_.Get(index);
}
inline ::clearcut::connectivity::Pair* DNSLookupBatch::add_getaddrinfo_errors() {
  // @@protoc_insertion_point(field_add:clearcut.connectivity.DNSLookupBatch.getaddrinfo_errors)
  return getaddrinfo_errors_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >&
DNSLookupBatch::getaddrinfo_errors() const {
  // @@protoc_insertion_point(field_list:clearcut.connectivity.DNSLookupBatch.getaddrinfo_errors)
  return getaddrinfo_errors_;
}

// repeated .clearcut.connectivity.Pair gethostbyname_errors = 10;
inline int DNSLookupBatch::gethostbyname_errors_size() const {
  return gethostbyname_errors_.size();
}
inline void DNSLookupBatch::clear_gethostbyname_errors() {
  gethostbyname_errors_.Clear();
}
inline ::clearcut::connectivity::Pair* DNSLookupBatch::mutable_gethostbyname_errors(int index) {
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.DNSLookupBatch.gethostbyname_errors)
  return gethostbyname_errors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >*
DNSLookupBatch::mutable_gethostbyname_errors() {
  // @@protoc_insertion_point(field_mutable_list:clearcut.connectivity.DNSLookupBatch.gethostbyname_errors)
  return &gethostbyname_errors_;
}
inline const ::clearcut::connectivity::Pair& DNSLookupBatch::gethostbyname_errors(int index) const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DNSLookupBatch.gethostbyname_errors)
  return gethostbyname_errors_.Get(index);
}
inline ::clearcut::connectivity::Pair* DNSLookupBatch::add_gethostbyname_errors() {
  // @@protoc_insertion_point(field_add:clearcut.connectivity.DNSLookupBatch.gethostbyname_errors)
  return gethostbyname_errors_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >&
DNSLookupBatch::gethostbyname_errors() const {
  // @@protoc_insertion_point(field_list:clearcut.connectivity.DNSLookupBatch.gethostbyname_errors)
  return gethostbyname_errors_;
}

// optional .clearcut.connectivity.NetworkId network_id = 1 [deprecated = true];
inline bool DNSLookupBatch::has_network_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DNSLookupBatch::clear_network_id() {
  if (network_id_ != nullptr) network_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::clearcut::connectivity::NetworkId& DNSLookupBatch::network_id() const {
  const ::clearcut::connectivity::NetworkId* p = network_id_;
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DNSLookupBatch.network_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::clearcut::connectivity::NetworkId*>(
      &::clearcut::connectivity::_NetworkId_default_instance_);
}
inline ::clearcut::connectivity::NetworkId* DNSLookupBatch::release_network_id() {
  // @@protoc_insertion_point(field_release:clearcut.connectivity.DNSLookupBatch.network_id)
  _has_bits_[0] &= ~0x00000001u;
  ::clearcut::connectivity::NetworkId* temp = network_id_;
  network_id_ = nullptr;
  return temp;
}
inline ::clearcut::connectivity::NetworkId* DNSLookupBatch::mutable_network_id() {
  _has_bits_[0] |= 0x00000001u;
  if (network_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::clearcut::connectivity::NetworkId>(GetArenaNoVirtual());
    network_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.DNSLookupBatch.network_id)
  return network_id_;
}
inline void DNSLookupBatch::set_allocated_network_id(::clearcut::connectivity::NetworkId* network_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete network_id_;
  }
  if (network_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      network_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, network_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  network_id_ = network_id;
  // @@protoc_insertion_point(field_set_allocated:clearcut.connectivity.DNSLookupBatch.network_id)
}

// repeated int32 event_types = 2 [deprecated = true];
inline int DNSLookupBatch::event_types_size() const {
  return event_types_.size();
}
inline void DNSLookupBatch::clear_event_types() {
  event_types_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DNSLookupBatch::event_types(int index) const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DNSLookupBatch.event_types)
  return event_types_.Get(index);
}
inline void DNSLookupBatch::set_event_types(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  event_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DNSLookupBatch.event_types)
}
inline void DNSLookupBatch::add_event_types(::PROTOBUF_NAMESPACE_ID::int32 value) {
  event_types_.Add(value);
  // @@protoc_insertion_point(field_add:clearcut.connectivity.DNSLookupBatch.event_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
DNSLookupBatch::event_types() const {
  // @@protoc_insertion_point(field_list:clearcut.connectivity.DNSLookupBatch.event_types)
  return event_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
DNSLookupBatch::mutable_event_types() {
  // @@protoc_insertion_point(field_mutable_list:clearcut.connectivity.DNSLookupBatch.event_types)
  return &event_types_;
}

// repeated int32 return_codes = 3 [deprecated = true];
inline int DNSLookupBatch::return_codes_size() const {
  return return_codes_.size();
}
inline void DNSLookupBatch::clear_return_codes() {
  return_codes_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DNSLookupBatch::return_codes(int index) const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DNSLookupBatch.return_codes)
  return return_codes_.Get(index);
}
inline void DNSLookupBatch::set_return_codes(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  return_codes_.Set(index, value);
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DNSLookupBatch.return_codes)
}
inline void DNSLookupBatch::add_return_codes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  return_codes_.Add(value);
  // @@protoc_insertion_point(field_add:clearcut.connectivity.DNSLookupBatch.return_codes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
DNSLookupBatch::return_codes() const {
  // @@protoc_insertion_point(field_list:clearcut.connectivity.DNSLookupBatch.return_codes)
  return return_codes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
DNSLookupBatch::mutable_return_codes() {
  // @@protoc_insertion_point(field_mutable_list:clearcut.connectivity.DNSLookupBatch.return_codes)
  return &return_codes_;
}

// -------------------------------------------------------------------

// DNSLatencies

// optional int32 type = 1;
inline bool DNSLatencies::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DNSLatencies::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DNSLatencies::type() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DNSLatencies.type)
  return type_;
}
inline void DNSLatencies::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DNSLatencies.type)
}

// optional int32 return_code = 2;
inline bool DNSLatencies::has_return_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DNSLatencies::clear_return_code() {
  return_code_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DNSLatencies::return_code() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DNSLatencies.return_code)
  return return_code_;
}
inline void DNSLatencies::set_return_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  return_code_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DNSLatencies.return_code)
}

// optional int32 query_count = 3;
inline bool DNSLatencies::has_query_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DNSLatencies::clear_query_count() {
  query_count_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DNSLatencies::query_count() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DNSLatencies.query_count)
  return query_count_;
}
inline void DNSLatencies::set_query_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  query_count_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DNSLatencies.query_count)
}

// optional int32 a_count = 4;
inline bool DNSLatencies::has_a_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DNSLatencies::clear_a_count() {
  a_count_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DNSLatencies::a_count() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DNSLatencies.a_count)
  return a_count_;
}
inline void DNSLatencies::set_a_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  a_count_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DNSLatencies.a_count)
}

// optional int32 aaaa_count = 5;
inline bool DNSLatencies::has_aaaa_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DNSLatencies::clear_aaaa_count() {
  aaaa_count_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DNSLatencies::aaaa_count() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DNSLatencies.aaaa_count)
  return aaaa_count_;
}
inline void DNSLatencies::set_aaaa_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  aaaa_count_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DNSLatencies.aaaa_count)
}

// repeated int32 latencies_ms = 6;
inline int DNSLatencies::latencies_ms_size() const {
  return latencies_ms_.size();
}
inline void DNSLatencies::clear_latencies_ms() {
  latencies_ms_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DNSLatencies::latencies_ms(int index) const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DNSLatencies.latencies_ms)
  return latencies_ms_.Get(index);
}
inline void DNSLatencies::set_latencies_ms(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  latencies_ms_.Set(index, value);
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DNSLatencies.latencies_ms)
}
inline void DNSLatencies::add_latencies_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  latencies_ms_.Add(value);
  // @@protoc_insertion_point(field_add:clearcut.connectivity.DNSLatencies.latencies_ms)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
DNSLatencies::latencies_ms() const {
  // @@protoc_insertion_point(field_list:clearcut.connectivity.DNSLatencies.latencies_ms)
  return latencies_ms_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
DNSLatencies::mutable_latencies_ms() {
  // @@protoc_insertion_point(field_mutable_list:clearcut.connectivity.DNSLatencies.latencies_ms)
  return &latencies_ms_;
}

// -------------------------------------------------------------------

// ConnectStatistics

// optional int32 connect_count = 1;
inline bool ConnectStatistics::has_connect_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectStatistics::clear_connect_count() {
  connect_count_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ConnectStatistics::connect_count() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ConnectStatistics.connect_count)
  return connect_count_;
}
inline void ConnectStatistics::set_connect_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  connect_count_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ConnectStatistics.connect_count)
}

// optional int32 connect_blocking_count = 5;
inline bool ConnectStatistics::has_connect_blocking_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectStatistics::clear_connect_blocking_count() {
  connect_blocking_count_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ConnectStatistics::connect_blocking_count() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ConnectStatistics.connect_blocking_count)
  return connect_blocking_count_;
}
inline void ConnectStatistics::set_connect_blocking_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  connect_blocking_count_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ConnectStatistics.connect_blocking_count)
}

// optional int32 ipv6_addr_count = 2;
inline bool ConnectStatistics::has_ipv6_addr_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectStatistics::clear_ipv6_addr_count() {
  ipv6_addr_count_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ConnectStatistics::ipv6_addr_count() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ConnectStatistics.ipv6_addr_count)
  return ipv6_addr_count_;
}
inline void ConnectStatistics::set_ipv6_addr_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  ipv6_addr_count_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ConnectStatistics.ipv6_addr_count)
}

// repeated int32 latencies_ms = 3;
inline int ConnectStatistics::latencies_ms_size() const {
  return latencies_ms_.size();
}
inline void ConnectStatistics::clear_latencies_ms() {
  latencies_ms_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ConnectStatistics::latencies_ms(int index) const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ConnectStatistics.latencies_ms)
  return latencies_ms_.Get(index);
}
inline void ConnectStatistics::set_latencies_ms(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  latencies_ms_.Set(index, value);
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ConnectStatistics.latencies_ms)
}
inline void ConnectStatistics::add_latencies_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  latencies_ms_.Add(value);
  // @@protoc_insertion_point(field_add:clearcut.connectivity.ConnectStatistics.latencies_ms)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
ConnectStatistics::latencies_ms() const {
  // @@protoc_insertion_point(field_list:clearcut.connectivity.ConnectStatistics.latencies_ms)
  return latencies_ms_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
ConnectStatistics::mutable_latencies_ms() {
  // @@protoc_insertion_point(field_mutable_list:clearcut.connectivity.ConnectStatistics.latencies_ms)
  return &latencies_ms_;
}

// repeated int32 non_blocking_latencies_ms = 6;
inline int ConnectStatistics::non_blocking_latencies_ms_size() const {
  return non_blocking_latencies_ms_.size();
}
inline void ConnectStatistics::clear_non_blocking_latencies_ms() {
  non_blocking_latencies_ms_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ConnectStatistics::non_blocking_latencies_ms(int index) const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ConnectStatistics.non_blocking_latencies_ms)
  return non_blocking_latencies_ms_.Get(index);
}
inline void ConnectStatistics::set_non_blocking_latencies_ms(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  non_blocking_latencies_ms_.Set(index, value);
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ConnectStatistics.non_blocking_latencies_ms)
}
inline void ConnectStatistics::add_non_blocking_latencies_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  non_blocking_latencies_ms_.Add(value);
  // @@protoc_insertion_point(field_add:clearcut.connectivity.ConnectStatistics.non_blocking_latencies_ms)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
ConnectStatistics::non_blocking_latencies_ms() const {
  // @@protoc_insertion_point(field_list:clearcut.connectivity.ConnectStatistics.non_blocking_latencies_ms)
  return non_blocking_latencies_ms_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
ConnectStatistics::mutable_non_blocking_latencies_ms() {
  // @@protoc_insertion_point(field_mutable_list:clearcut.connectivity.ConnectStatistics.non_blocking_latencies_ms)
  return &non_blocking_latencies_ms_;
}

// repeated .clearcut.connectivity.Pair errnos_counters = 4;
inline int ConnectStatistics::errnos_counters_size() const {
  return errnos_counters_.size();
}
inline void ConnectStatistics::clear_errnos_counters() {
  errnos_counters_.Clear();
}
inline ::clearcut::connectivity::Pair* ConnectStatistics::mutable_errnos_counters(int index) {
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.ConnectStatistics.errnos_counters)
  return errnos_counters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >*
ConnectStatistics::mutable_errnos_counters() {
  // @@protoc_insertion_point(field_mutable_list:clearcut.connectivity.ConnectStatistics.errnos_counters)
  return &errnos_counters_;
}
inline const ::clearcut::connectivity::Pair& ConnectStatistics::errnos_counters(int index) const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ConnectStatistics.errnos_counters)
  return errnos_counters_.Get(index);
}
inline ::clearcut::connectivity::Pair* ConnectStatistics::add_errnos_counters() {
  // @@protoc_insertion_point(field_add:clearcut.connectivity.ConnectStatistics.errnos_counters)
  return errnos_counters_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >&
ConnectStatistics::errnos_counters() const {
  // @@protoc_insertion_point(field_list:clearcut.connectivity.ConnectStatistics.errnos_counters)
  return errnos_counters_;
}

// -------------------------------------------------------------------

// DHCPEvent

// optional string if_name = 1 [deprecated = true];
inline bool DHCPEvent::has_if_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DHCPEvent::clear_if_name() {
  if_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DHCPEvent::if_name() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DHCPEvent.if_name)
  return if_name_.GetNoArena();
}
inline void DHCPEvent::set_if_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  if_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DHCPEvent.if_name)
}
inline void DHCPEvent::set_if_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  if_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:clearcut.connectivity.DHCPEvent.if_name)
}
inline void DHCPEvent::set_if_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  if_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:clearcut.connectivity.DHCPEvent.if_name)
}
inline void DHCPEvent::set_if_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  if_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:clearcut.connectivity.DHCPEvent.if_name)
}
inline std::string* DHCPEvent::mutable_if_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.DHCPEvent.if_name)
  return if_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DHCPEvent::release_if_name() {
  // @@protoc_insertion_point(field_release:clearcut.connectivity.DHCPEvent.if_name)
  if (!has_if_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return if_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DHCPEvent::set_allocated_if_name(std::string* if_name) {
  if (if_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  if_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), if_name);
  // @@protoc_insertion_point(field_set_allocated:clearcut.connectivity.DHCPEvent.if_name)
}

// optional string state_transition = 2;
inline bool DHCPEvent::has_state_transition() const {
  return value_case() == kStateTransition;
}
inline void DHCPEvent::set_has_state_transition() {
  _oneof_case_[0] = kStateTransition;
}
inline void DHCPEvent::clear_state_transition() {
  if (has_state_transition()) {
    value_.state_transition_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_value();
  }
}
inline const std::string& DHCPEvent::state_transition() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DHCPEvent.state_transition)
  if (has_state_transition()) {
    return value_.state_transition_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DHCPEvent::set_state_transition(const std::string& value) {
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DHCPEvent.state_transition)
  if (!has_state_transition()) {
    clear_value();
    set_has_state_transition();
    value_.state_transition_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.state_transition_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DHCPEvent.state_transition)
}
inline void DHCPEvent::set_state_transition(std::string&& value) {
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DHCPEvent.state_transition)
  if (!has_state_transition()) {
    clear_value();
    set_has_state_transition();
    value_.state_transition_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.state_transition_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:clearcut.connectivity.DHCPEvent.state_transition)
}
inline void DHCPEvent::set_state_transition(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_state_transition()) {
    clear_value();
    set_has_state_transition();
    value_.state_transition_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.state_transition_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:clearcut.connectivity.DHCPEvent.state_transition)
}
inline void DHCPEvent::set_state_transition(const char* value, size_t size) {
  if (!has_state_transition()) {
    clear_value();
    set_has_state_transition();
    value_.state_transition_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.state_transition_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:clearcut.connectivity.DHCPEvent.state_transition)
}
inline std::string* DHCPEvent::mutable_state_transition() {
  if (!has_state_transition()) {
    clear_value();
    set_has_state_transition();
    value_.state_transition_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.DHCPEvent.state_transition)
  return value_.state_transition_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DHCPEvent::release_state_transition() {
  // @@protoc_insertion_point(field_release:clearcut.connectivity.DHCPEvent.state_transition)
  if (has_state_transition()) {
    clear_has_value();
    return value_.state_transition_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void DHCPEvent::set_allocated_state_transition(std::string* state_transition) {
  if (has_value()) {
    clear_value();
  }
  if (state_transition != nullptr) {
    set_has_state_transition();
    value_.state_transition_.UnsafeSetDefault(state_transition);
  }
  // @@protoc_insertion_point(field_set_allocated:clearcut.connectivity.DHCPEvent.state_transition)
}

// optional int32 error_code = 3;
inline bool DHCPEvent::has_error_code() const {
  return value_case() == kErrorCode;
}
inline void DHCPEvent::set_has_error_code() {
  _oneof_case_[0] = kErrorCode;
}
inline void DHCPEvent::clear_error_code() {
  if (has_error_code()) {
    value_.error_code_ = 0;
    clear_has_value();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DHCPEvent::error_code() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DHCPEvent.error_code)
  if (has_error_code()) {
    return value_.error_code_;
  }
  return 0;
}
inline void DHCPEvent::set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  if (!has_error_code()) {
    clear_value();
    set_has_error_code();
  }
  value_.error_code_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DHCPEvent.error_code)
}

// optional int32 duration_ms = 4;
inline bool DHCPEvent::has_duration_ms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DHCPEvent::clear_duration_ms() {
  duration_ms_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DHCPEvent::duration_ms() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.DHCPEvent.duration_ms)
  return duration_ms_;
}
inline void DHCPEvent::set_duration_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  duration_ms_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.DHCPEvent.duration_ms)
}

inline bool DHCPEvent::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void DHCPEvent::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline DHCPEvent::ValueCase DHCPEvent::value_case() const {
  return DHCPEvent::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ApfProgramEvent

// optional int64 lifetime = 1;
inline bool ApfProgramEvent::has_lifetime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApfProgramEvent::clear_lifetime() {
  lifetime_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ApfProgramEvent::lifetime() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ApfProgramEvent.lifetime)
  return lifetime_;
}
inline void ApfProgramEvent::set_lifetime(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  lifetime_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ApfProgramEvent.lifetime)
}

// optional int64 effective_lifetime = 7;
inline bool ApfProgramEvent::has_effective_lifetime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ApfProgramEvent::clear_effective_lifetime() {
  effective_lifetime_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ApfProgramEvent::effective_lifetime() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ApfProgramEvent.effective_lifetime)
  return effective_lifetime_;
}
inline void ApfProgramEvent::set_effective_lifetime(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  effective_lifetime_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ApfProgramEvent.effective_lifetime)
}

// optional int32 filtered_ras = 2;
inline bool ApfProgramEvent::has_filtered_ras() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApfProgramEvent::clear_filtered_ras() {
  filtered_ras_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ApfProgramEvent::filtered_ras() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ApfProgramEvent.filtered_ras)
  return filtered_ras_;
}
inline void ApfProgramEvent::set_filtered_ras(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  filtered_ras_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ApfProgramEvent.filtered_ras)
}

// optional int32 current_ras = 3;
inline bool ApfProgramEvent::has_current_ras() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApfProgramEvent::clear_current_ras() {
  current_ras_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ApfProgramEvent::current_ras() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ApfProgramEvent.current_ras)
  return current_ras_;
}
inline void ApfProgramEvent::set_current_ras(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  current_ras_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ApfProgramEvent.current_ras)
}

// optional int32 program_length = 4;
inline bool ApfProgramEvent::has_program_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ApfProgramEvent::clear_program_length() {
  program_length_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ApfProgramEvent::program_length() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ApfProgramEvent.program_length)
  return program_length_;
}
inline void ApfProgramEvent::set_program_length(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  program_length_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ApfProgramEvent.program_length)
}

// optional bool drop_multicast = 5;
inline bool ApfProgramEvent::has_drop_multicast() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ApfProgramEvent::clear_drop_multicast() {
  drop_multicast_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ApfProgramEvent::drop_multicast() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ApfProgramEvent.drop_multicast)
  return drop_multicast_;
}
inline void ApfProgramEvent::set_drop_multicast(bool value) {
  _has_bits_[0] |= 0x00000010u;
  drop_multicast_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ApfProgramEvent.drop_multicast)
}

// optional bool has_ipv4_addr = 6;
inline bool ApfProgramEvent::has_has_ipv4_addr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ApfProgramEvent::clear_has_ipv4_addr() {
  has_ipv4_addr_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ApfProgramEvent::has_ipv4_addr() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ApfProgramEvent.has_ipv4_addr)
  return has_ipv4_addr_;
}
inline void ApfProgramEvent::set_has_ipv4_addr(bool value) {
  _has_bits_[0] |= 0x00000020u;
  has_ipv4_addr_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ApfProgramEvent.has_ipv4_addr)
}

// -------------------------------------------------------------------

// ApfStatistics

// optional int64 duration_ms = 1;
inline bool ApfStatistics::has_duration_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApfStatistics::clear_duration_ms() {
  duration_ms_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ApfStatistics::duration_ms() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ApfStatistics.duration_ms)
  return duration_ms_;
}
inline void ApfStatistics::set_duration_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  duration_ms_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ApfStatistics.duration_ms)
}

// optional int32 received_ras = 2;
inline bool ApfStatistics::has_received_ras() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApfStatistics::clear_received_ras() {
  received_ras_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ApfStatistics::received_ras() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ApfStatistics.received_ras)
  return received_ras_;
}
inline void ApfStatistics::set_received_ras(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  received_ras_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ApfStatistics.received_ras)
}

// optional int32 matching_ras = 3;
inline bool ApfStatistics::has_matching_ras() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApfStatistics::clear_matching_ras() {
  matching_ras_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ApfStatistics::matching_ras() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ApfStatistics.matching_ras)
  return matching_ras_;
}
inline void ApfStatistics::set_matching_ras(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  matching_ras_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ApfStatistics.matching_ras)
}

// optional int32 dropped_ras = 5;
inline bool ApfStatistics::has_dropped_ras() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ApfStatistics::clear_dropped_ras() {
  dropped_ras_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ApfStatistics::dropped_ras() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ApfStatistics.dropped_ras)
  return dropped_ras_;
}
inline void ApfStatistics::set_dropped_ras(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  dropped_ras_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ApfStatistics.dropped_ras)
}

// optional int32 zero_lifetime_ras = 6;
inline bool ApfStatistics::has_zero_lifetime_ras() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ApfStatistics::clear_zero_lifetime_ras() {
  zero_lifetime_ras_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ApfStatistics::zero_lifetime_ras() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ApfStatistics.zero_lifetime_ras)
  return zero_lifetime_ras_;
}
inline void ApfStatistics::set_zero_lifetime_ras(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  zero_lifetime_ras_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ApfStatistics.zero_lifetime_ras)
}

// optional int32 parse_errors = 7;
inline bool ApfStatistics::has_parse_errors() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ApfStatistics::clear_parse_errors() {
  parse_errors_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ApfStatistics::parse_errors() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ApfStatistics.parse_errors)
  return parse_errors_;
}
inline void ApfStatistics::set_parse_errors(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  parse_errors_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ApfStatistics.parse_errors)
}

// optional int32 program_updates = 8;
inline bool ApfStatistics::has_program_updates() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ApfStatistics::clear_program_updates() {
  program_updates_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ApfStatistics::program_updates() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ApfStatistics.program_updates)
  return program_updates_;
}
inline void ApfStatistics::set_program_updates(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  program_updates_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ApfStatistics.program_updates)
}

// optional int32 max_program_size = 9;
inline bool ApfStatistics::has_max_program_size() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ApfStatistics::clear_max_program_size() {
  max_program_size_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ApfStatistics::max_program_size() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ApfStatistics.max_program_size)
  return max_program_size_;
}
inline void ApfStatistics::set_max_program_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  max_program_size_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ApfStatistics.max_program_size)
}

// optional int32 program_updates_all = 10;
inline bool ApfStatistics::has_program_updates_all() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ApfStatistics::clear_program_updates_all() {
  program_updates_all_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ApfStatistics::program_updates_all() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ApfStatistics.program_updates_all)
  return program_updates_all_;
}
inline void ApfStatistics::set_program_updates_all(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  program_updates_all_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ApfStatistics.program_updates_all)
}

// optional int32 program_updates_allowing_multicast = 11;
inline bool ApfStatistics::has_program_updates_allowing_multicast() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ApfStatistics::clear_program_updates_allowing_multicast() {
  program_updates_allowing_multicast_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ApfStatistics::program_updates_allowing_multicast() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ApfStatistics.program_updates_allowing_multicast)
  return program_updates_allowing_multicast_;
}
inline void ApfStatistics::set_program_updates_allowing_multicast(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000200u;
  program_updates_allowing_multicast_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ApfStatistics.program_updates_allowing_multicast)
}

// optional int32 total_packet_processed = 12;
inline bool ApfStatistics::has_total_packet_processed() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ApfStatistics::clear_total_packet_processed() {
  total_packet_processed_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ApfStatistics::total_packet_processed() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ApfStatistics.total_packet_processed)
  return total_packet_processed_;
}
inline void ApfStatistics::set_total_packet_processed(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000400u;
  total_packet_processed_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ApfStatistics.total_packet_processed)
}

// optional int32 total_packet_dropped = 13;
inline bool ApfStatistics::has_total_packet_dropped() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ApfStatistics::clear_total_packet_dropped() {
  total_packet_dropped_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ApfStatistics::total_packet_dropped() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ApfStatistics.total_packet_dropped)
  return total_packet_dropped_;
}
inline void ApfStatistics::set_total_packet_dropped(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000800u;
  total_packet_dropped_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.ApfStatistics.total_packet_dropped)
}

// repeated .clearcut.connectivity.Pair hardware_counters = 14;
inline int ApfStatistics::hardware_counters_size() const {
  return hardware_counters_.size();
}
inline void ApfStatistics::clear_hardware_counters() {
  hardware_counters_.Clear();
}
inline ::clearcut::connectivity::Pair* ApfStatistics::mutable_hardware_counters(int index) {
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.ApfStatistics.hardware_counters)
  return hardware_counters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >*
ApfStatistics::mutable_hardware_counters() {
  // @@protoc_insertion_point(field_mutable_list:clearcut.connectivity.ApfStatistics.hardware_counters)
  return &hardware_counters_;
}
inline const ::clearcut::connectivity::Pair& ApfStatistics::hardware_counters(int index) const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.ApfStatistics.hardware_counters)
  return hardware_counters_.Get(index);
}
inline ::clearcut::connectivity::Pair* ApfStatistics::add_hardware_counters() {
  // @@protoc_insertion_point(field_add:clearcut.connectivity.ApfStatistics.hardware_counters)
  return hardware_counters_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >&
ApfStatistics::hardware_counters() const {
  // @@protoc_insertion_point(field_list:clearcut.connectivity.ApfStatistics.hardware_counters)
  return hardware_counters_;
}

// -------------------------------------------------------------------

// RaEvent

// optional int64 router_lifetime = 1;
inline bool RaEvent::has_router_lifetime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RaEvent::clear_router_lifetime() {
  router_lifetime_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RaEvent::router_lifetime() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.RaEvent.router_lifetime)
  return router_lifetime_;
}
inline void RaEvent::set_router_lifetime(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  router_lifetime_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.RaEvent.router_lifetime)
}

// optional int64 prefix_valid_lifetime = 2;
inline bool RaEvent::has_prefix_valid_lifetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RaEvent::clear_prefix_valid_lifetime() {
  prefix_valid_lifetime_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RaEvent::prefix_valid_lifetime() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.RaEvent.prefix_valid_lifetime)
  return prefix_valid_lifetime_;
}
inline void RaEvent::set_prefix_valid_lifetime(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  prefix_valid_lifetime_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.RaEvent.prefix_valid_lifetime)
}

// optional int64 prefix_preferred_lifetime = 3;
inline bool RaEvent::has_prefix_preferred_lifetime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RaEvent::clear_prefix_preferred_lifetime() {
  prefix_preferred_lifetime_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RaEvent::prefix_preferred_lifetime() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.RaEvent.prefix_preferred_lifetime)
  return prefix_preferred_lifetime_;
}
inline void RaEvent::set_prefix_preferred_lifetime(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  prefix_preferred_lifetime_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.RaEvent.prefix_preferred_lifetime)
}

// optional int64 route_info_lifetime = 4;
inline bool RaEvent::has_route_info_lifetime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RaEvent::clear_route_info_lifetime() {
  route_info_lifetime_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RaEvent::route_info_lifetime() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.RaEvent.route_info_lifetime)
  return route_info_lifetime_;
}
inline void RaEvent::set_route_info_lifetime(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  route_info_lifetime_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.RaEvent.route_info_lifetime)
}

// optional int64 rdnss_lifetime = 5;
inline bool RaEvent::has_rdnss_lifetime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RaEvent::clear_rdnss_lifetime() {
  rdnss_lifetime_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RaEvent::rdnss_lifetime() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.RaEvent.rdnss_lifetime)
  return rdnss_lifetime_;
}
inline void RaEvent::set_rdnss_lifetime(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  rdnss_lifetime_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.RaEvent.rdnss_lifetime)
}

// optional int64 dnssl_lifetime = 6;
inline bool RaEvent::has_dnssl_lifetime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RaEvent::clear_dnssl_lifetime() {
  dnssl_lifetime_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RaEvent::dnssl_lifetime() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.RaEvent.dnssl_lifetime)
  return dnssl_lifetime_;
}
inline void RaEvent::set_dnssl_lifetime(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  dnssl_lifetime_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.RaEvent.dnssl_lifetime)
}

// -------------------------------------------------------------------

// IpProvisioningEvent

// optional string if_name = 1 [deprecated = true];
inline bool IpProvisioningEvent::has_if_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IpProvisioningEvent::clear_if_name() {
  if_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IpProvisioningEvent::if_name() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpProvisioningEvent.if_name)
  return if_name_.GetNoArena();
}
inline void IpProvisioningEvent::set_if_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  if_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:clearcut.connectivity.IpProvisioningEvent.if_name)
}
inline void IpProvisioningEvent::set_if_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  if_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:clearcut.connectivity.IpProvisioningEvent.if_name)
}
inline void IpProvisioningEvent::set_if_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  if_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:clearcut.connectivity.IpProvisioningEvent.if_name)
}
inline void IpProvisioningEvent::set_if_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  if_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:clearcut.connectivity.IpProvisioningEvent.if_name)
}
inline std::string* IpProvisioningEvent::mutable_if_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.IpProvisioningEvent.if_name)
  return if_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* IpProvisioningEvent::release_if_name() {
  // @@protoc_insertion_point(field_release:clearcut.connectivity.IpProvisioningEvent.if_name)
  if (!has_if_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return if_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void IpProvisioningEvent::set_allocated_if_name(std::string* if_name) {
  if (if_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  if_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), if_name);
  // @@protoc_insertion_point(field_set_allocated:clearcut.connectivity.IpProvisioningEvent.if_name)
}

// optional int32 event_type = 2;
inline bool IpProvisioningEvent::has_event_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IpProvisioningEvent::clear_event_type() {
  event_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IpProvisioningEvent::event_type() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpProvisioningEvent.event_type)
  return event_type_;
}
inline void IpProvisioningEvent::set_event_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  event_type_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.IpProvisioningEvent.event_type)
}

// optional int32 latency_ms = 3;
inline bool IpProvisioningEvent::has_latency_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IpProvisioningEvent::clear_latency_ms() {
  latency_ms_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IpProvisioningEvent::latency_ms() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpProvisioningEvent.latency_ms)
  return latency_ms_;
}
inline void IpProvisioningEvent::set_latency_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  latency_ms_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.IpProvisioningEvent.latency_ms)
}

// -------------------------------------------------------------------

// NetworkStats

// optional int64 duration_ms = 1;
inline bool NetworkStats::has_duration_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetworkStats::clear_duration_ms() {
  duration_ms_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NetworkStats::duration_ms() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.NetworkStats.duration_ms)
  return duration_ms_;
}
inline void NetworkStats::set_duration_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  duration_ms_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.NetworkStats.duration_ms)
}

// optional .clearcut.connectivity.DefaultNetworkEvent.IPSupport ip_support = 2;
inline bool NetworkStats::has_ip_support() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetworkStats::clear_ip_support() {
  ip_support_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::clearcut::connectivity::DefaultNetworkEvent_IPSupport NetworkStats::ip_support() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.NetworkStats.ip_support)
  return static_cast< ::clearcut::connectivity::DefaultNetworkEvent_IPSupport >(ip_support_);
}
inline void NetworkStats::set_ip_support(::clearcut::connectivity::DefaultNetworkEvent_IPSupport value) {
  assert(::clearcut::connectivity::DefaultNetworkEvent_IPSupport_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  ip_support_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.NetworkStats.ip_support)
}

// optional bool ever_validated = 3;
inline bool NetworkStats::has_ever_validated() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetworkStats::clear_ever_validated() {
  ever_validated_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool NetworkStats::ever_validated() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.NetworkStats.ever_validated)
  return ever_validated_;
}
inline void NetworkStats::set_ever_validated(bool value) {
  _has_bits_[0] |= 0x00000004u;
  ever_validated_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.NetworkStats.ever_validated)
}

// optional bool portal_found = 4;
inline bool NetworkStats::has_portal_found() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NetworkStats::clear_portal_found() {
  portal_found_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool NetworkStats::portal_found() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.NetworkStats.portal_found)
  return portal_found_;
}
inline void NetworkStats::set_portal_found(bool value) {
  _has_bits_[0] |= 0x00000008u;
  portal_found_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.NetworkStats.portal_found)
}

// optional int32 no_connectivity_reports = 5;
inline bool NetworkStats::has_no_connectivity_reports() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NetworkStats::clear_no_connectivity_reports() {
  no_connectivity_reports_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NetworkStats::no_connectivity_reports() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.NetworkStats.no_connectivity_reports)
  return no_connectivity_reports_;
}
inline void NetworkStats::set_no_connectivity_reports(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  no_connectivity_reports_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.NetworkStats.no_connectivity_reports)
}

// optional int32 validation_attempts = 6;
inline bool NetworkStats::has_validation_attempts() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NetworkStats::clear_validation_attempts() {
  validation_attempts_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NetworkStats::validation_attempts() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.NetworkStats.validation_attempts)
  return validation_attempts_;
}
inline void NetworkStats::set_validation_attempts(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  validation_attempts_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.NetworkStats.validation_attempts)
}

// repeated .clearcut.connectivity.Pair validation_events = 7;
inline int NetworkStats::validation_events_size() const {
  return validation_events_.size();
}
inline void NetworkStats::clear_validation_events() {
  validation_events_.Clear();
}
inline ::clearcut::connectivity::Pair* NetworkStats::mutable_validation_events(int index) {
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.NetworkStats.validation_events)
  return validation_events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >*
NetworkStats::mutable_validation_events() {
  // @@protoc_insertion_point(field_mutable_list:clearcut.connectivity.NetworkStats.validation_events)
  return &validation_events_;
}
inline const ::clearcut::connectivity::Pair& NetworkStats::validation_events(int index) const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.NetworkStats.validation_events)
  return validation_events_.Get(index);
}
inline ::clearcut::connectivity::Pair* NetworkStats::add_validation_events() {
  // @@protoc_insertion_point(field_add:clearcut.connectivity.NetworkStats.validation_events)
  return validation_events_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >&
NetworkStats::validation_events() const {
  // @@protoc_insertion_point(field_list:clearcut.connectivity.NetworkStats.validation_events)
  return validation_events_;
}

// repeated .clearcut.connectivity.Pair validation_states = 8;
inline int NetworkStats::validation_states_size() const {
  return validation_states_.size();
}
inline void NetworkStats::clear_validation_states() {
  validation_states_.Clear();
}
inline ::clearcut::connectivity::Pair* NetworkStats::mutable_validation_states(int index) {
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.NetworkStats.validation_states)
  return validation_states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >*
NetworkStats::mutable_validation_states() {
  // @@protoc_insertion_point(field_mutable_list:clearcut.connectivity.NetworkStats.validation_states)
  return &validation_states_;
}
inline const ::clearcut::connectivity::Pair& NetworkStats::validation_states(int index) const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.NetworkStats.validation_states)
  return validation_states_.Get(index);
}
inline ::clearcut::connectivity::Pair* NetworkStats::add_validation_states() {
  // @@protoc_insertion_point(field_add:clearcut.connectivity.NetworkStats.validation_states)
  return validation_states_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >&
NetworkStats::validation_states() const {
  // @@protoc_insertion_point(field_list:clearcut.connectivity.NetworkStats.validation_states)
  return validation_states_;
}

// -------------------------------------------------------------------

// WakeupStats

// optional int64 duration_sec = 1;
inline bool WakeupStats::has_duration_sec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WakeupStats::clear_duration_sec() {
  duration_sec_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WakeupStats::duration_sec() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.WakeupStats.duration_sec)
  return duration_sec_;
}
inline void WakeupStats::set_duration_sec(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  duration_sec_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.WakeupStats.duration_sec)
}

// optional int64 total_wakeups = 2;
inline bool WakeupStats::has_total_wakeups() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WakeupStats::clear_total_wakeups() {
  total_wakeups_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WakeupStats::total_wakeups() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.WakeupStats.total_wakeups)
  return total_wakeups_;
}
inline void WakeupStats::set_total_wakeups(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  total_wakeups_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.WakeupStats.total_wakeups)
}

// optional int64 root_wakeups = 3;
inline bool WakeupStats::has_root_wakeups() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WakeupStats::clear_root_wakeups() {
  root_wakeups_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WakeupStats::root_wakeups() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.WakeupStats.root_wakeups)
  return root_wakeups_;
}
inline void WakeupStats::set_root_wakeups(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  root_wakeups_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.WakeupStats.root_wakeups)
}

// optional int64 system_wakeups = 4;
inline bool WakeupStats::has_system_wakeups() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WakeupStats::clear_system_wakeups() {
  system_wakeups_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WakeupStats::system_wakeups() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.WakeupStats.system_wakeups)
  return system_wakeups_;
}
inline void WakeupStats::set_system_wakeups(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  system_wakeups_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.WakeupStats.system_wakeups)
}

// optional int64 application_wakeups = 5;
inline bool WakeupStats::has_application_wakeups() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WakeupStats::clear_application_wakeups() {
  application_wakeups_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WakeupStats::application_wakeups() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.WakeupStats.application_wakeups)
  return application_wakeups_;
}
inline void WakeupStats::set_application_wakeups(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  application_wakeups_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.WakeupStats.application_wakeups)
}

// optional int64 non_application_wakeups = 6;
inline bool WakeupStats::has_non_application_wakeups() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WakeupStats::clear_non_application_wakeups() {
  non_application_wakeups_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WakeupStats::non_application_wakeups() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.WakeupStats.non_application_wakeups)
  return non_application_wakeups_;
}
inline void WakeupStats::set_non_application_wakeups(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  non_application_wakeups_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.WakeupStats.non_application_wakeups)
}

// optional int64 no_uid_wakeups = 7;
inline bool WakeupStats::has_no_uid_wakeups() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WakeupStats::clear_no_uid_wakeups() {
  no_uid_wakeups_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WakeupStats::no_uid_wakeups() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.WakeupStats.no_uid_wakeups)
  return no_uid_wakeups_;
}
inline void WakeupStats::set_no_uid_wakeups(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  no_uid_wakeups_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.WakeupStats.no_uid_wakeups)
}

// repeated .clearcut.connectivity.Pair ethertype_counts = 8;
inline int WakeupStats::ethertype_counts_size() const {
  return ethertype_counts_.size();
}
inline void WakeupStats::clear_ethertype_counts() {
  ethertype_counts_.Clear();
}
inline ::clearcut::connectivity::Pair* WakeupStats::mutable_ethertype_counts(int index) {
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.WakeupStats.ethertype_counts)
  return ethertype_counts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >*
WakeupStats::mutable_ethertype_counts() {
  // @@protoc_insertion_point(field_mutable_list:clearcut.connectivity.WakeupStats.ethertype_counts)
  return &ethertype_counts_;
}
inline const ::clearcut::connectivity::Pair& WakeupStats::ethertype_counts(int index) const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.WakeupStats.ethertype_counts)
  return ethertype_counts_.Get(index);
}
inline ::clearcut::connectivity::Pair* WakeupStats::add_ethertype_counts() {
  // @@protoc_insertion_point(field_add:clearcut.connectivity.WakeupStats.ethertype_counts)
  return ethertype_counts_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >&
WakeupStats::ethertype_counts() const {
  // @@protoc_insertion_point(field_list:clearcut.connectivity.WakeupStats.ethertype_counts)
  return ethertype_counts_;
}

// repeated .clearcut.connectivity.Pair ip_next_header_counts = 9;
inline int WakeupStats::ip_next_header_counts_size() const {
  return ip_next_header_counts_.size();
}
inline void WakeupStats::clear_ip_next_header_counts() {
  ip_next_header_counts_.Clear();
}
inline ::clearcut::connectivity::Pair* WakeupStats::mutable_ip_next_header_counts(int index) {
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.WakeupStats.ip_next_header_counts)
  return ip_next_header_counts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >*
WakeupStats::mutable_ip_next_header_counts() {
  // @@protoc_insertion_point(field_mutable_list:clearcut.connectivity.WakeupStats.ip_next_header_counts)
  return &ip_next_header_counts_;
}
inline const ::clearcut::connectivity::Pair& WakeupStats::ip_next_header_counts(int index) const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.WakeupStats.ip_next_header_counts)
  return ip_next_header_counts_.Get(index);
}
inline ::clearcut::connectivity::Pair* WakeupStats::add_ip_next_header_counts() {
  // @@protoc_insertion_point(field_add:clearcut.connectivity.WakeupStats.ip_next_header_counts)
  return ip_next_header_counts_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::Pair >&
WakeupStats::ip_next_header_counts() const {
  // @@protoc_insertion_point(field_list:clearcut.connectivity.WakeupStats.ip_next_header_counts)
  return ip_next_header_counts_;
}

// optional int64 l2_unicast_count = 10;
inline bool WakeupStats::has_l2_unicast_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void WakeupStats::clear_l2_unicast_count() {
  l2_unicast_count_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WakeupStats::l2_unicast_count() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.WakeupStats.l2_unicast_count)
  return l2_unicast_count_;
}
inline void WakeupStats::set_l2_unicast_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000080u;
  l2_unicast_count_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.WakeupStats.l2_unicast_count)
}

// optional int64 l2_multicast_count = 11;
inline bool WakeupStats::has_l2_multicast_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void WakeupStats::clear_l2_multicast_count() {
  l2_multicast_count_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WakeupStats::l2_multicast_count() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.WakeupStats.l2_multicast_count)
  return l2_multicast_count_;
}
inline void WakeupStats::set_l2_multicast_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000100u;
  l2_multicast_count_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.WakeupStats.l2_multicast_count)
}

// optional int64 l2_broadcast_count = 12;
inline bool WakeupStats::has_l2_broadcast_count() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void WakeupStats::clear_l2_broadcast_count() {
  l2_broadcast_count_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WakeupStats::l2_broadcast_count() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.WakeupStats.l2_broadcast_count)
  return l2_broadcast_count_;
}
inline void WakeupStats::set_l2_broadcast_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000200u;
  l2_broadcast_count_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.WakeupStats.l2_broadcast_count)
}

// -------------------------------------------------------------------

// IpConnectivityEvent

// optional int64 time_ms = 1;
inline bool IpConnectivityEvent::has_time_ms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IpConnectivityEvent::clear_time_ms() {
  time_ms_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IpConnectivityEvent::time_ms() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpConnectivityEvent.time_ms)
  return time_ms_;
}
inline void IpConnectivityEvent::set_time_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  time_ms_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.IpConnectivityEvent.time_ms)
}

// optional .clearcut.connectivity.LinkLayer link_layer = 15;
inline bool IpConnectivityEvent::has_link_layer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IpConnectivityEvent::clear_link_layer() {
  link_layer_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::clearcut::connectivity::LinkLayer IpConnectivityEvent::link_layer() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpConnectivityEvent.link_layer)
  return static_cast< ::clearcut::connectivity::LinkLayer >(link_layer_);
}
inline void IpConnectivityEvent::set_link_layer(::clearcut::connectivity::LinkLayer value) {
  assert(::clearcut::connectivity::LinkLayer_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  link_layer_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.IpConnectivityEvent.link_layer)
}

// optional int32 network_id = 16;
inline bool IpConnectivityEvent::has_network_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IpConnectivityEvent::clear_network_id() {
  network_id_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IpConnectivityEvent::network_id() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpConnectivityEvent.network_id)
  return network_id_;
}
inline void IpConnectivityEvent::set_network_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  network_id_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.IpConnectivityEvent.network_id)
}

// optional string if_name = 17;
inline bool IpConnectivityEvent::has_if_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IpConnectivityEvent::clear_if_name() {
  if_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IpConnectivityEvent::if_name() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpConnectivityEvent.if_name)
  return if_name_.GetNoArena();
}
inline void IpConnectivityEvent::set_if_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  if_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:clearcut.connectivity.IpConnectivityEvent.if_name)
}
inline void IpConnectivityEvent::set_if_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  if_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:clearcut.connectivity.IpConnectivityEvent.if_name)
}
inline void IpConnectivityEvent::set_if_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  if_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:clearcut.connectivity.IpConnectivityEvent.if_name)
}
inline void IpConnectivityEvent::set_if_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  if_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:clearcut.connectivity.IpConnectivityEvent.if_name)
}
inline std::string* IpConnectivityEvent::mutable_if_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.IpConnectivityEvent.if_name)
  return if_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* IpConnectivityEvent::release_if_name() {
  // @@protoc_insertion_point(field_release:clearcut.connectivity.IpConnectivityEvent.if_name)
  if (!has_if_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return if_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void IpConnectivityEvent::set_allocated_if_name(std::string* if_name) {
  if (if_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  if_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), if_name);
  // @@protoc_insertion_point(field_set_allocated:clearcut.connectivity.IpConnectivityEvent.if_name)
}

// optional int64 transports = 18;
inline bool IpConnectivityEvent::has_transports() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IpConnectivityEvent::clear_transports() {
  transports_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IpConnectivityEvent::transports() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpConnectivityEvent.transports)
  return transports_;
}
inline void IpConnectivityEvent::set_transports(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  transports_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.IpConnectivityEvent.transports)
}

// optional .clearcut.connectivity.DefaultNetworkEvent default_network_event = 2;
inline bool IpConnectivityEvent::has_default_network_event() const {
  return event_case() == kDefaultNetworkEvent;
}
inline void IpConnectivityEvent::set_has_default_network_event() {
  _oneof_case_[0] = kDefaultNetworkEvent;
}
inline void IpConnectivityEvent::clear_default_network_event() {
  if (has_default_network_event()) {
    delete event_.default_network_event_;
    clear_has_event();
  }
}
inline ::clearcut::connectivity::DefaultNetworkEvent* IpConnectivityEvent::release_default_network_event() {
  // @@protoc_insertion_point(field_release:clearcut.connectivity.IpConnectivityEvent.default_network_event)
  if (has_default_network_event()) {
    clear_has_event();
      ::clearcut::connectivity::DefaultNetworkEvent* temp = event_.default_network_event_;
    event_.default_network_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clearcut::connectivity::DefaultNetworkEvent& IpConnectivityEvent::default_network_event() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpConnectivityEvent.default_network_event)
  return has_default_network_event()
      ? *event_.default_network_event_
      : *reinterpret_cast< ::clearcut::connectivity::DefaultNetworkEvent*>(&::clearcut::connectivity::_DefaultNetworkEvent_default_instance_);
}
inline ::clearcut::connectivity::DefaultNetworkEvent* IpConnectivityEvent::mutable_default_network_event() {
  if (!has_default_network_event()) {
    clear_event();
    set_has_default_network_event();
    event_.default_network_event_ = CreateMaybeMessage< ::clearcut::connectivity::DefaultNetworkEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.IpConnectivityEvent.default_network_event)
  return event_.default_network_event_;
}

// optional .clearcut.connectivity.IpReachabilityEvent ip_reachability_event = 3;
inline bool IpConnectivityEvent::has_ip_reachability_event() const {
  return event_case() == kIpReachabilityEvent;
}
inline void IpConnectivityEvent::set_has_ip_reachability_event() {
  _oneof_case_[0] = kIpReachabilityEvent;
}
inline void IpConnectivityEvent::clear_ip_reachability_event() {
  if (has_ip_reachability_event()) {
    delete event_.ip_reachability_event_;
    clear_has_event();
  }
}
inline ::clearcut::connectivity::IpReachabilityEvent* IpConnectivityEvent::release_ip_reachability_event() {
  // @@protoc_insertion_point(field_release:clearcut.connectivity.IpConnectivityEvent.ip_reachability_event)
  if (has_ip_reachability_event()) {
    clear_has_event();
      ::clearcut::connectivity::IpReachabilityEvent* temp = event_.ip_reachability_event_;
    event_.ip_reachability_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clearcut::connectivity::IpReachabilityEvent& IpConnectivityEvent::ip_reachability_event() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpConnectivityEvent.ip_reachability_event)
  return has_ip_reachability_event()
      ? *event_.ip_reachability_event_
      : *reinterpret_cast< ::clearcut::connectivity::IpReachabilityEvent*>(&::clearcut::connectivity::_IpReachabilityEvent_default_instance_);
}
inline ::clearcut::connectivity::IpReachabilityEvent* IpConnectivityEvent::mutable_ip_reachability_event() {
  if (!has_ip_reachability_event()) {
    clear_event();
    set_has_ip_reachability_event();
    event_.ip_reachability_event_ = CreateMaybeMessage< ::clearcut::connectivity::IpReachabilityEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.IpConnectivityEvent.ip_reachability_event)
  return event_.ip_reachability_event_;
}

// optional .clearcut.connectivity.NetworkEvent network_event = 4 [deprecated = true];
inline bool IpConnectivityEvent::has_network_event() const {
  return event_case() == kNetworkEvent;
}
inline void IpConnectivityEvent::set_has_network_event() {
  _oneof_case_[0] = kNetworkEvent;
}
inline void IpConnectivityEvent::clear_network_event() {
  if (has_network_event()) {
    delete event_.network_event_;
    clear_has_event();
  }
}
inline ::clearcut::connectivity::NetworkEvent* IpConnectivityEvent::release_network_event() {
  // @@protoc_insertion_point(field_release:clearcut.connectivity.IpConnectivityEvent.network_event)
  if (has_network_event()) {
    clear_has_event();
      ::clearcut::connectivity::NetworkEvent* temp = event_.network_event_;
    event_.network_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clearcut::connectivity::NetworkEvent& IpConnectivityEvent::network_event() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpConnectivityEvent.network_event)
  return has_network_event()
      ? *event_.network_event_
      : *reinterpret_cast< ::clearcut::connectivity::NetworkEvent*>(&::clearcut::connectivity::_NetworkEvent_default_instance_);
}
inline ::clearcut::connectivity::NetworkEvent* IpConnectivityEvent::mutable_network_event() {
  if (!has_network_event()) {
    clear_event();
    set_has_network_event();
    event_.network_event_ = CreateMaybeMessage< ::clearcut::connectivity::NetworkEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.IpConnectivityEvent.network_event)
  return event_.network_event_;
}

// optional .clearcut.connectivity.DNSLookupBatch dns_lookup_batch = 5 [deprecated = true];
inline bool IpConnectivityEvent::has_dns_lookup_batch() const {
  return event_case() == kDnsLookupBatch;
}
inline void IpConnectivityEvent::set_has_dns_lookup_batch() {
  _oneof_case_[0] = kDnsLookupBatch;
}
inline void IpConnectivityEvent::clear_dns_lookup_batch() {
  if (has_dns_lookup_batch()) {
    delete event_.dns_lookup_batch_;
    clear_has_event();
  }
}
inline ::clearcut::connectivity::DNSLookupBatch* IpConnectivityEvent::release_dns_lookup_batch() {
  // @@protoc_insertion_point(field_release:clearcut.connectivity.IpConnectivityEvent.dns_lookup_batch)
  if (has_dns_lookup_batch()) {
    clear_has_event();
      ::clearcut::connectivity::DNSLookupBatch* temp = event_.dns_lookup_batch_;
    event_.dns_lookup_batch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clearcut::connectivity::DNSLookupBatch& IpConnectivityEvent::dns_lookup_batch() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpConnectivityEvent.dns_lookup_batch)
  return has_dns_lookup_batch()
      ? *event_.dns_lookup_batch_
      : *reinterpret_cast< ::clearcut::connectivity::DNSLookupBatch*>(&::clearcut::connectivity::_DNSLookupBatch_default_instance_);
}
inline ::clearcut::connectivity::DNSLookupBatch* IpConnectivityEvent::mutable_dns_lookup_batch() {
  if (!has_dns_lookup_batch()) {
    clear_event();
    set_has_dns_lookup_batch();
    event_.dns_lookup_batch_ = CreateMaybeMessage< ::clearcut::connectivity::DNSLookupBatch >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.IpConnectivityEvent.dns_lookup_batch)
  return event_.dns_lookup_batch_;
}

// optional .clearcut.connectivity.DNSLatencies dns_latencies = 13;
inline bool IpConnectivityEvent::has_dns_latencies() const {
  return event_case() == kDnsLatencies;
}
inline void IpConnectivityEvent::set_has_dns_latencies() {
  _oneof_case_[0] = kDnsLatencies;
}
inline void IpConnectivityEvent::clear_dns_latencies() {
  if (has_dns_latencies()) {
    delete event_.dns_latencies_;
    clear_has_event();
  }
}
inline ::clearcut::connectivity::DNSLatencies* IpConnectivityEvent::release_dns_latencies() {
  // @@protoc_insertion_point(field_release:clearcut.connectivity.IpConnectivityEvent.dns_latencies)
  if (has_dns_latencies()) {
    clear_has_event();
      ::clearcut::connectivity::DNSLatencies* temp = event_.dns_latencies_;
    event_.dns_latencies_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clearcut::connectivity::DNSLatencies& IpConnectivityEvent::dns_latencies() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpConnectivityEvent.dns_latencies)
  return has_dns_latencies()
      ? *event_.dns_latencies_
      : *reinterpret_cast< ::clearcut::connectivity::DNSLatencies*>(&::clearcut::connectivity::_DNSLatencies_default_instance_);
}
inline ::clearcut::connectivity::DNSLatencies* IpConnectivityEvent::mutable_dns_latencies() {
  if (!has_dns_latencies()) {
    clear_event();
    set_has_dns_latencies();
    event_.dns_latencies_ = CreateMaybeMessage< ::clearcut::connectivity::DNSLatencies >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.IpConnectivityEvent.dns_latencies)
  return event_.dns_latencies_;
}

// optional .clearcut.connectivity.ConnectStatistics connect_statistics = 14;
inline bool IpConnectivityEvent::has_connect_statistics() const {
  return event_case() == kConnectStatistics;
}
inline void IpConnectivityEvent::set_has_connect_statistics() {
  _oneof_case_[0] = kConnectStatistics;
}
inline void IpConnectivityEvent::clear_connect_statistics() {
  if (has_connect_statistics()) {
    delete event_.connect_statistics_;
    clear_has_event();
  }
}
inline ::clearcut::connectivity::ConnectStatistics* IpConnectivityEvent::release_connect_statistics() {
  // @@protoc_insertion_point(field_release:clearcut.connectivity.IpConnectivityEvent.connect_statistics)
  if (has_connect_statistics()) {
    clear_has_event();
      ::clearcut::connectivity::ConnectStatistics* temp = event_.connect_statistics_;
    event_.connect_statistics_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clearcut::connectivity::ConnectStatistics& IpConnectivityEvent::connect_statistics() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpConnectivityEvent.connect_statistics)
  return has_connect_statistics()
      ? *event_.connect_statistics_
      : *reinterpret_cast< ::clearcut::connectivity::ConnectStatistics*>(&::clearcut::connectivity::_ConnectStatistics_default_instance_);
}
inline ::clearcut::connectivity::ConnectStatistics* IpConnectivityEvent::mutable_connect_statistics() {
  if (!has_connect_statistics()) {
    clear_event();
    set_has_connect_statistics();
    event_.connect_statistics_ = CreateMaybeMessage< ::clearcut::connectivity::ConnectStatistics >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.IpConnectivityEvent.connect_statistics)
  return event_.connect_statistics_;
}

// optional .clearcut.connectivity.DHCPEvent dhcp_event = 6;
inline bool IpConnectivityEvent::has_dhcp_event() const {
  return event_case() == kDhcpEvent;
}
inline void IpConnectivityEvent::set_has_dhcp_event() {
  _oneof_case_[0] = kDhcpEvent;
}
inline void IpConnectivityEvent::clear_dhcp_event() {
  if (has_dhcp_event()) {
    delete event_.dhcp_event_;
    clear_has_event();
  }
}
inline ::clearcut::connectivity::DHCPEvent* IpConnectivityEvent::release_dhcp_event() {
  // @@protoc_insertion_point(field_release:clearcut.connectivity.IpConnectivityEvent.dhcp_event)
  if (has_dhcp_event()) {
    clear_has_event();
      ::clearcut::connectivity::DHCPEvent* temp = event_.dhcp_event_;
    event_.dhcp_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clearcut::connectivity::DHCPEvent& IpConnectivityEvent::dhcp_event() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpConnectivityEvent.dhcp_event)
  return has_dhcp_event()
      ? *event_.dhcp_event_
      : *reinterpret_cast< ::clearcut::connectivity::DHCPEvent*>(&::clearcut::connectivity::_DHCPEvent_default_instance_);
}
inline ::clearcut::connectivity::DHCPEvent* IpConnectivityEvent::mutable_dhcp_event() {
  if (!has_dhcp_event()) {
    clear_event();
    set_has_dhcp_event();
    event_.dhcp_event_ = CreateMaybeMessage< ::clearcut::connectivity::DHCPEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.IpConnectivityEvent.dhcp_event)
  return event_.dhcp_event_;
}

// optional .clearcut.connectivity.IpProvisioningEvent ip_provisioning_event = 7;
inline bool IpConnectivityEvent::has_ip_provisioning_event() const {
  return event_case() == kIpProvisioningEvent;
}
inline void IpConnectivityEvent::set_has_ip_provisioning_event() {
  _oneof_case_[0] = kIpProvisioningEvent;
}
inline void IpConnectivityEvent::clear_ip_provisioning_event() {
  if (has_ip_provisioning_event()) {
    delete event_.ip_provisioning_event_;
    clear_has_event();
  }
}
inline ::clearcut::connectivity::IpProvisioningEvent* IpConnectivityEvent::release_ip_provisioning_event() {
  // @@protoc_insertion_point(field_release:clearcut.connectivity.IpConnectivityEvent.ip_provisioning_event)
  if (has_ip_provisioning_event()) {
    clear_has_event();
      ::clearcut::connectivity::IpProvisioningEvent* temp = event_.ip_provisioning_event_;
    event_.ip_provisioning_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clearcut::connectivity::IpProvisioningEvent& IpConnectivityEvent::ip_provisioning_event() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpConnectivityEvent.ip_provisioning_event)
  return has_ip_provisioning_event()
      ? *event_.ip_provisioning_event_
      : *reinterpret_cast< ::clearcut::connectivity::IpProvisioningEvent*>(&::clearcut::connectivity::_IpProvisioningEvent_default_instance_);
}
inline ::clearcut::connectivity::IpProvisioningEvent* IpConnectivityEvent::mutable_ip_provisioning_event() {
  if (!has_ip_provisioning_event()) {
    clear_event();
    set_has_ip_provisioning_event();
    event_.ip_provisioning_event_ = CreateMaybeMessage< ::clearcut::connectivity::IpProvisioningEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.IpConnectivityEvent.ip_provisioning_event)
  return event_.ip_provisioning_event_;
}

// optional .clearcut.connectivity.ValidationProbeEvent validation_probe_event = 8;
inline bool IpConnectivityEvent::has_validation_probe_event() const {
  return event_case() == kValidationProbeEvent;
}
inline void IpConnectivityEvent::set_has_validation_probe_event() {
  _oneof_case_[0] = kValidationProbeEvent;
}
inline void IpConnectivityEvent::clear_validation_probe_event() {
  if (has_validation_probe_event()) {
    delete event_.validation_probe_event_;
    clear_has_event();
  }
}
inline ::clearcut::connectivity::ValidationProbeEvent* IpConnectivityEvent::release_validation_probe_event() {
  // @@protoc_insertion_point(field_release:clearcut.connectivity.IpConnectivityEvent.validation_probe_event)
  if (has_validation_probe_event()) {
    clear_has_event();
      ::clearcut::connectivity::ValidationProbeEvent* temp = event_.validation_probe_event_;
    event_.validation_probe_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clearcut::connectivity::ValidationProbeEvent& IpConnectivityEvent::validation_probe_event() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpConnectivityEvent.validation_probe_event)
  return has_validation_probe_event()
      ? *event_.validation_probe_event_
      : *reinterpret_cast< ::clearcut::connectivity::ValidationProbeEvent*>(&::clearcut::connectivity::_ValidationProbeEvent_default_instance_);
}
inline ::clearcut::connectivity::ValidationProbeEvent* IpConnectivityEvent::mutable_validation_probe_event() {
  if (!has_validation_probe_event()) {
    clear_event();
    set_has_validation_probe_event();
    event_.validation_probe_event_ = CreateMaybeMessage< ::clearcut::connectivity::ValidationProbeEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.IpConnectivityEvent.validation_probe_event)
  return event_.validation_probe_event_;
}

// optional .clearcut.connectivity.ApfProgramEvent apf_program_event = 9;
inline bool IpConnectivityEvent::has_apf_program_event() const {
  return event_case() == kApfProgramEvent;
}
inline void IpConnectivityEvent::set_has_apf_program_event() {
  _oneof_case_[0] = kApfProgramEvent;
}
inline void IpConnectivityEvent::clear_apf_program_event() {
  if (has_apf_program_event()) {
    delete event_.apf_program_event_;
    clear_has_event();
  }
}
inline ::clearcut::connectivity::ApfProgramEvent* IpConnectivityEvent::release_apf_program_event() {
  // @@protoc_insertion_point(field_release:clearcut.connectivity.IpConnectivityEvent.apf_program_event)
  if (has_apf_program_event()) {
    clear_has_event();
      ::clearcut::connectivity::ApfProgramEvent* temp = event_.apf_program_event_;
    event_.apf_program_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clearcut::connectivity::ApfProgramEvent& IpConnectivityEvent::apf_program_event() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpConnectivityEvent.apf_program_event)
  return has_apf_program_event()
      ? *event_.apf_program_event_
      : *reinterpret_cast< ::clearcut::connectivity::ApfProgramEvent*>(&::clearcut::connectivity::_ApfProgramEvent_default_instance_);
}
inline ::clearcut::connectivity::ApfProgramEvent* IpConnectivityEvent::mutable_apf_program_event() {
  if (!has_apf_program_event()) {
    clear_event();
    set_has_apf_program_event();
    event_.apf_program_event_ = CreateMaybeMessage< ::clearcut::connectivity::ApfProgramEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.IpConnectivityEvent.apf_program_event)
  return event_.apf_program_event_;
}

// optional .clearcut.connectivity.ApfStatistics apf_statistics = 10;
inline bool IpConnectivityEvent::has_apf_statistics() const {
  return event_case() == kApfStatistics;
}
inline void IpConnectivityEvent::set_has_apf_statistics() {
  _oneof_case_[0] = kApfStatistics;
}
inline void IpConnectivityEvent::clear_apf_statistics() {
  if (has_apf_statistics()) {
    delete event_.apf_statistics_;
    clear_has_event();
  }
}
inline ::clearcut::connectivity::ApfStatistics* IpConnectivityEvent::release_apf_statistics() {
  // @@protoc_insertion_point(field_release:clearcut.connectivity.IpConnectivityEvent.apf_statistics)
  if (has_apf_statistics()) {
    clear_has_event();
      ::clearcut::connectivity::ApfStatistics* temp = event_.apf_statistics_;
    event_.apf_statistics_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clearcut::connectivity::ApfStatistics& IpConnectivityEvent::apf_statistics() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpConnectivityEvent.apf_statistics)
  return has_apf_statistics()
      ? *event_.apf_statistics_
      : *reinterpret_cast< ::clearcut::connectivity::ApfStatistics*>(&::clearcut::connectivity::_ApfStatistics_default_instance_);
}
inline ::clearcut::connectivity::ApfStatistics* IpConnectivityEvent::mutable_apf_statistics() {
  if (!has_apf_statistics()) {
    clear_event();
    set_has_apf_statistics();
    event_.apf_statistics_ = CreateMaybeMessage< ::clearcut::connectivity::ApfStatistics >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.IpConnectivityEvent.apf_statistics)
  return event_.apf_statistics_;
}

// optional .clearcut.connectivity.RaEvent ra_event = 11;
inline bool IpConnectivityEvent::has_ra_event() const {
  return event_case() == kRaEvent;
}
inline void IpConnectivityEvent::set_has_ra_event() {
  _oneof_case_[0] = kRaEvent;
}
inline void IpConnectivityEvent::clear_ra_event() {
  if (has_ra_event()) {
    delete event_.ra_event_;
    clear_has_event();
  }
}
inline ::clearcut::connectivity::RaEvent* IpConnectivityEvent::release_ra_event() {
  // @@protoc_insertion_point(field_release:clearcut.connectivity.IpConnectivityEvent.ra_event)
  if (has_ra_event()) {
    clear_has_event();
      ::clearcut::connectivity::RaEvent* temp = event_.ra_event_;
    event_.ra_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clearcut::connectivity::RaEvent& IpConnectivityEvent::ra_event() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpConnectivityEvent.ra_event)
  return has_ra_event()
      ? *event_.ra_event_
      : *reinterpret_cast< ::clearcut::connectivity::RaEvent*>(&::clearcut::connectivity::_RaEvent_default_instance_);
}
inline ::clearcut::connectivity::RaEvent* IpConnectivityEvent::mutable_ra_event() {
  if (!has_ra_event()) {
    clear_event();
    set_has_ra_event();
    event_.ra_event_ = CreateMaybeMessage< ::clearcut::connectivity::RaEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.IpConnectivityEvent.ra_event)
  return event_.ra_event_;
}

// optional .clearcut.connectivity.NetworkStats network_stats = 19;
inline bool IpConnectivityEvent::has_network_stats() const {
  return event_case() == kNetworkStats;
}
inline void IpConnectivityEvent::set_has_network_stats() {
  _oneof_case_[0] = kNetworkStats;
}
inline void IpConnectivityEvent::clear_network_stats() {
  if (has_network_stats()) {
    delete event_.network_stats_;
    clear_has_event();
  }
}
inline ::clearcut::connectivity::NetworkStats* IpConnectivityEvent::release_network_stats() {
  // @@protoc_insertion_point(field_release:clearcut.connectivity.IpConnectivityEvent.network_stats)
  if (has_network_stats()) {
    clear_has_event();
      ::clearcut::connectivity::NetworkStats* temp = event_.network_stats_;
    event_.network_stats_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clearcut::connectivity::NetworkStats& IpConnectivityEvent::network_stats() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpConnectivityEvent.network_stats)
  return has_network_stats()
      ? *event_.network_stats_
      : *reinterpret_cast< ::clearcut::connectivity::NetworkStats*>(&::clearcut::connectivity::_NetworkStats_default_instance_);
}
inline ::clearcut::connectivity::NetworkStats* IpConnectivityEvent::mutable_network_stats() {
  if (!has_network_stats()) {
    clear_event();
    set_has_network_stats();
    event_.network_stats_ = CreateMaybeMessage< ::clearcut::connectivity::NetworkStats >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.IpConnectivityEvent.network_stats)
  return event_.network_stats_;
}

// optional .clearcut.connectivity.WakeupStats wakeup_stats = 20;
inline bool IpConnectivityEvent::has_wakeup_stats() const {
  return event_case() == kWakeupStats;
}
inline void IpConnectivityEvent::set_has_wakeup_stats() {
  _oneof_case_[0] = kWakeupStats;
}
inline void IpConnectivityEvent::clear_wakeup_stats() {
  if (has_wakeup_stats()) {
    delete event_.wakeup_stats_;
    clear_has_event();
  }
}
inline ::clearcut::connectivity::WakeupStats* IpConnectivityEvent::release_wakeup_stats() {
  // @@protoc_insertion_point(field_release:clearcut.connectivity.IpConnectivityEvent.wakeup_stats)
  if (has_wakeup_stats()) {
    clear_has_event();
      ::clearcut::connectivity::WakeupStats* temp = event_.wakeup_stats_;
    event_.wakeup_stats_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clearcut::connectivity::WakeupStats& IpConnectivityEvent::wakeup_stats() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpConnectivityEvent.wakeup_stats)
  return has_wakeup_stats()
      ? *event_.wakeup_stats_
      : *reinterpret_cast< ::clearcut::connectivity::WakeupStats*>(&::clearcut::connectivity::_WakeupStats_default_instance_);
}
inline ::clearcut::connectivity::WakeupStats* IpConnectivityEvent::mutable_wakeup_stats() {
  if (!has_wakeup_stats()) {
    clear_event();
    set_has_wakeup_stats();
    event_.wakeup_stats_ = CreateMaybeMessage< ::clearcut::connectivity::WakeupStats >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.IpConnectivityEvent.wakeup_stats)
  return event_.wakeup_stats_;
}

inline bool IpConnectivityEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void IpConnectivityEvent::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline IpConnectivityEvent::EventCase IpConnectivityEvent::event_case() const {
  return IpConnectivityEvent::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// IpConnectivityLog

// repeated .clearcut.connectivity.IpConnectivityEvent events = 1;
inline int IpConnectivityLog::events_size() const {
  return events_.size();
}
inline void IpConnectivityLog::clear_events() {
  events_.Clear();
}
inline ::clearcut::connectivity::IpConnectivityEvent* IpConnectivityLog::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:clearcut.connectivity.IpConnectivityLog.events)
  return events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::IpConnectivityEvent >*
IpConnectivityLog::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:clearcut.connectivity.IpConnectivityLog.events)
  return &events_;
}
inline const ::clearcut::connectivity::IpConnectivityEvent& IpConnectivityLog::events(int index) const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpConnectivityLog.events)
  return events_.Get(index);
}
inline ::clearcut::connectivity::IpConnectivityEvent* IpConnectivityLog::add_events() {
  // @@protoc_insertion_point(field_add:clearcut.connectivity.IpConnectivityLog.events)
  return events_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clearcut::connectivity::IpConnectivityEvent >&
IpConnectivityLog::events() const {
  // @@protoc_insertion_point(field_list:clearcut.connectivity.IpConnectivityLog.events)
  return events_;
}

// optional int32 dropped_events = 2;
inline bool IpConnectivityLog::has_dropped_events() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IpConnectivityLog::clear_dropped_events() {
  dropped_events_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IpConnectivityLog::dropped_events() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpConnectivityLog.dropped_events)
  return dropped_events_;
}
inline void IpConnectivityLog::set_dropped_events(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  dropped_events_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.IpConnectivityLog.dropped_events)
}

// optional int32 version = 3;
inline bool IpConnectivityLog::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IpConnectivityLog::clear_version() {
  version_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IpConnectivityLog::version() const {
  // @@protoc_insertion_point(field_get:clearcut.connectivity.IpConnectivityLog.version)
  return version_;
}
inline void IpConnectivityLog::set_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  version_ = value;
  // @@protoc_insertion_point(field_set:clearcut.connectivity.IpConnectivityLog.version)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace connectivity
}  // namespace clearcut

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::clearcut::connectivity::DefaultNetworkEvent_LostReason> : ::std::true_type {};
template <> struct is_proto_enum< ::clearcut::connectivity::DefaultNetworkEvent_IPSupport> : ::std::true_type {};
template <> struct is_proto_enum< ::clearcut::connectivity::LinkLayer> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_frameworks_2fbase_2fproto_2fsrc_2fipconnectivity_2eproto
