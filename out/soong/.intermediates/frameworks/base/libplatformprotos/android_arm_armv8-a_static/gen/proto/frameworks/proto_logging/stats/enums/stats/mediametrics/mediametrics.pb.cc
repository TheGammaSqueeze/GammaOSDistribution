// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/stats/mediametrics/mediametrics.proto

#include "frameworks/proto_logging/stats/enums/stats/mediametrics/mediametrics.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
namespace android {
namespace stats {
namespace mediametrics {
}  // namespace mediametrics
}  // namespace stats
}  // namespace android
namespace android {
namespace stats {
namespace mediametrics {
bool StreamType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> StreamType_strings[6] = {};

static const char StreamType_names[] =
  "STREAM_TYPE_DASH"
  "STREAM_TYPE_HLS"
  "STREAM_TYPE_OTHER"
  "STREAM_TYPE_PROGRESSIVE"
  "STREAM_TYPE_SS"
  "STREAM_TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry StreamType_entries[] = {
  { {StreamType_names + 0, 16}, 3 },
  { {StreamType_names + 16, 15}, 4 },
  { {StreamType_names + 31, 17}, 1 },
  { {StreamType_names + 48, 23}, 2 },
  { {StreamType_names + 71, 14}, 5 },
  { {StreamType_names + 85, 19}, 0 },
};

static const int StreamType_entries_by_number[] = {
  5, // 0 -> STREAM_TYPE_UNKNOWN
  2, // 1 -> STREAM_TYPE_OTHER
  3, // 2 -> STREAM_TYPE_PROGRESSIVE
  0, // 3 -> STREAM_TYPE_DASH
  1, // 4 -> STREAM_TYPE_HLS
  4, // 5 -> STREAM_TYPE_SS
};

const std::string& StreamType_Name(
    StreamType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          StreamType_entries,
          StreamType_entries_by_number,
          6, StreamType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      StreamType_entries,
      StreamType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     StreamType_strings[idx].get();
}
bool StreamType_Parse(
    const std::string& name, StreamType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      StreamType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<StreamType>(int_value);
  }
  return success;
}
bool DrmType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DrmType_strings[5] = {};

static const char DrmType_names[] =
  "DRM_TYPE_NONE"
  "DRM_TYPE_OTHER"
  "DRM_TYPE_PLAY_READY"
  "DRM_TYPE_WV_L1"
  "DRM_TYPE_WV_L3";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DrmType_entries[] = {
  { {DrmType_names + 0, 13}, 0 },
  { {DrmType_names + 13, 14}, 1 },
  { {DrmType_names + 27, 19}, 2 },
  { {DrmType_names + 46, 14}, 3 },
  { {DrmType_names + 60, 14}, 4 },
};

static const int DrmType_entries_by_number[] = {
  0, // 0 -> DRM_TYPE_NONE
  1, // 1 -> DRM_TYPE_OTHER
  2, // 2 -> DRM_TYPE_PLAY_READY
  3, // 3 -> DRM_TYPE_WV_L1
  4, // 4 -> DRM_TYPE_WV_L3
};

const std::string& DrmType_Name(
    DrmType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DrmType_entries,
          DrmType_entries_by_number,
          5, DrmType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DrmType_entries,
      DrmType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DrmType_strings[idx].get();
}
bool DrmType_Parse(
    const std::string& name, DrmType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DrmType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<DrmType>(int_value);
  }
  return success;
}
bool PlaybackType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PlaybackType_strings[4] = {};

static const char PlaybackType_names[] =
  "PLAYBACK_TYPE_LIVE"
  "PLAYBACK_TYPE_OTHER"
  "PLAYBACK_TYPE_UNKNOWN"
  "PLAYBACK_TYPE_VOD";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PlaybackType_entries[] = {
  { {PlaybackType_names + 0, 18}, 2 },
  { {PlaybackType_names + 18, 19}, 3 },
  { {PlaybackType_names + 37, 21}, 0 },
  { {PlaybackType_names + 58, 17}, 1 },
};

static const int PlaybackType_entries_by_number[] = {
  2, // 0 -> PLAYBACK_TYPE_UNKNOWN
  3, // 1 -> PLAYBACK_TYPE_VOD
  0, // 2 -> PLAYBACK_TYPE_LIVE
  1, // 3 -> PLAYBACK_TYPE_OTHER
};

const std::string& PlaybackType_Name(
    PlaybackType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PlaybackType_entries,
          PlaybackType_entries_by_number,
          4, PlaybackType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PlaybackType_entries,
      PlaybackType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PlaybackType_strings[idx].get();
}
bool PlaybackType_Parse(
    const std::string& name, PlaybackType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PlaybackType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<PlaybackType>(int_value);
  }
  return success;
}
bool ContentType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ContentType_strings[4] = {};

static const char ContentType_names[] =
  "CONTENT_TYPE_AD"
  "CONTENT_TYPE_MAIN"
  "CONTENT_TYPE_OTHER"
  "CONTENT_TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ContentType_entries[] = {
  { {ContentType_names + 0, 15}, 2 },
  { {ContentType_names + 15, 17}, 1 },
  { {ContentType_names + 32, 18}, 3 },
  { {ContentType_names + 50, 20}, 0 },
};

static const int ContentType_entries_by_number[] = {
  3, // 0 -> CONTENT_TYPE_UNKNOWN
  1, // 1 -> CONTENT_TYPE_MAIN
  0, // 2 -> CONTENT_TYPE_AD
  2, // 3 -> CONTENT_TYPE_OTHER
};

const std::string& ContentType_Name(
    ContentType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ContentType_entries,
          ContentType_entries_by_number,
          4, ContentType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ContentType_entries,
      ContentType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ContentType_strings[idx].get();
}
bool ContentType_Parse(
    const std::string& name, ContentType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ContentType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ContentType>(int_value);
  }
  return success;
}
bool StreamSourceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> StreamSourceType_strings[4] = {};

static const char StreamSourceType_names[] =
  "STREAM_SOURCE_DEVICE"
  "STREAM_SOURCE_MIXED"
  "STREAM_SOURCE_NETWORK"
  "STREAM_SOURCE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry StreamSourceType_entries[] = {
  { {StreamSourceType_names + 0, 20}, 2 },
  { {StreamSourceType_names + 20, 19}, 3 },
  { {StreamSourceType_names + 39, 21}, 1 },
  { {StreamSourceType_names + 60, 21}, 0 },
};

static const int StreamSourceType_entries_by_number[] = {
  3, // 0 -> STREAM_SOURCE_UNKNOWN
  2, // 1 -> STREAM_SOURCE_NETWORK
  0, // 2 -> STREAM_SOURCE_DEVICE
  1, // 3 -> STREAM_SOURCE_MIXED
};

const std::string& StreamSourceType_Name(
    StreamSourceType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          StreamSourceType_entries,
          StreamSourceType_entries_by_number,
          4, StreamSourceType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      StreamSourceType_entries,
      StreamSourceType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     StreamSourceType_strings[idx].get();
}
bool StreamSourceType_Parse(
    const std::string& name, StreamSourceType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      StreamSourceType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<StreamSourceType>(int_value);
  }
  return success;
}
bool NetworkType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NetworkType_strings[10] = {};

static const char NetworkType_names[] =
  "NETWORK_TYPE_2G"
  "NETWORK_TYPE_3G"
  "NETWORK_TYPE_4G"
  "NETWORK_TYPE_5G_NSA"
  "NETWORK_TYPE_5G_SA"
  "NETWORK_TYPE_ETHERNET"
  "NETWORK_TYPE_OFFLINE"
  "NETWORK_TYPE_OTHER"
  "NETWORK_TYPE_UNKNOWN"
  "NETWORK_TYPE_WIFI";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NetworkType_entries[] = {
  { {NetworkType_names + 0, 15}, 4 },
  { {NetworkType_names + 15, 15}, 5 },
  { {NetworkType_names + 30, 15}, 6 },
  { {NetworkType_names + 45, 19}, 7 },
  { {NetworkType_names + 64, 18}, 8 },
  { {NetworkType_names + 82, 21}, 3 },
  { {NetworkType_names + 103, 20}, 9 },
  { {NetworkType_names + 123, 18}, 1 },
  { {NetworkType_names + 141, 20}, 0 },
  { {NetworkType_names + 161, 17}, 2 },
};

static const int NetworkType_entries_by_number[] = {
  8, // 0 -> NETWORK_TYPE_UNKNOWN
  7, // 1 -> NETWORK_TYPE_OTHER
  9, // 2 -> NETWORK_TYPE_WIFI
  5, // 3 -> NETWORK_TYPE_ETHERNET
  0, // 4 -> NETWORK_TYPE_2G
  1, // 5 -> NETWORK_TYPE_3G
  2, // 6 -> NETWORK_TYPE_4G
  3, // 7 -> NETWORK_TYPE_5G_NSA
  4, // 8 -> NETWORK_TYPE_5G_SA
  6, // 9 -> NETWORK_TYPE_OFFLINE
};

const std::string& NetworkType_Name(
    NetworkType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NetworkType_entries,
          NetworkType_entries_by_number,
          10, NetworkType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NetworkType_entries,
      NetworkType_entries_by_number,
      10, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NetworkType_strings[idx].get();
}
bool NetworkType_Parse(
    const std::string& name, NetworkType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NetworkType_entries, 10, name, &int_value);
  if (success) {
    *value = static_cast<NetworkType>(int_value);
  }
  return success;
}
bool PlaybackState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PlaybackState_strings[15] = {};

static const char PlaybackState_names[] =
  "ABANDONED"
  "BUFFERING"
  "ENDED"
  "FAILED"
  "INTERRUPTED_BY_AD"
  "JOINING_BACKGROUND"
  "JOINING_FOREGROUND"
  "NOT_STARTED"
  "PAUSED"
  "PAUSED_BUFFERING"
  "PLAYING"
  "SEEKING"
  "STOPPED"
  "SUPPRESSED"
  "SUPPRESSED_BUFFERING";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PlaybackState_entries[] = {
  { {PlaybackState_names + 0, 9}, 14 },
  { {PlaybackState_names + 9, 9}, 6 },
  { {PlaybackState_names + 18, 5}, 10 },
  { {PlaybackState_names + 23, 6}, 12 },
  { {PlaybackState_names + 29, 17}, 13 },
  { {PlaybackState_names + 46, 18}, 1 },
  { {PlaybackState_names + 64, 18}, 2 },
  { {PlaybackState_names + 82, 11}, 0 },
  { {PlaybackState_names + 93, 6}, 4 },
  { {PlaybackState_names + 99, 16}, 7 },
  { {PlaybackState_names + 115, 7}, 3 },
  { {PlaybackState_names + 122, 7}, 5 },
  { {PlaybackState_names + 129, 7}, 11 },
  { {PlaybackState_names + 136, 10}, 8 },
  { {PlaybackState_names + 146, 20}, 9 },
};

static const int PlaybackState_entries_by_number[] = {
  7, // 0 -> NOT_STARTED
  5, // 1 -> JOINING_BACKGROUND
  6, // 2 -> JOINING_FOREGROUND
  10, // 3 -> PLAYING
  8, // 4 -> PAUSED
  11, // 5 -> SEEKING
  1, // 6 -> BUFFERING
  9, // 7 -> PAUSED_BUFFERING
  13, // 8 -> SUPPRESSED
  14, // 9 -> SUPPRESSED_BUFFERING
  2, // 10 -> ENDED
  12, // 11 -> STOPPED
  3, // 12 -> FAILED
  4, // 13 -> INTERRUPTED_BY_AD
  0, // 14 -> ABANDONED
};

const std::string& PlaybackState_Name(
    PlaybackState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PlaybackState_entries,
          PlaybackState_entries_by_number,
          15, PlaybackState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PlaybackState_entries,
      PlaybackState_entries_by_number,
      15, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PlaybackState_strings[idx].get();
}
bool PlaybackState_Parse(
    const std::string& name, PlaybackState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PlaybackState_entries, 15, name, &int_value);
  if (success) {
    *value = static_cast<PlaybackState>(int_value);
  }
  return success;
}
bool PlaybackErrorCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 30:
    case 39:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PlaybackErrorCode_strings[31] = {};

static const char PlaybackErrorCode_names[] =
  "ERROR_CODE_AUDIOTRACK_INIT"
  "ERROR_CODE_AUDIOTRACK_OTHER"
  "ERROR_CODE_AUDIOTRACK_WRITE"
  "ERROR_CODE_DECODER_DECODE"
  "ERROR_CODE_DECODER_INIT"
  "ERROR_CODE_DECODER_OOM"
  "ERROR_CODE_DECODER_OTHER"
  "ERROR_CODE_DRM_CONTENT_ERROR"
  "ERROR_CODE_DRM_DISALLOWED"
  "ERROR_CODE_DRM_LICENSE_ERROR"
  "ERROR_CODE_DRM_OTHER"
  "ERROR_CODE_DRM_PROVISIONING_FAILED"
  "ERROR_CODE_DRM_REVOKED"
  "ERROR_CODE_DRM_SYSTEM_ERROR"
  "ERROR_CODE_DRM_UNAVAILABLE"
  "ERROR_CODE_MEDIA_MANIFET"
  "ERROR_CODE_MEDIA_OTHER"
  "ERROR_CODE_MEDIA_PARSER"
  "ERROR_CODE_NETWORK_BAD_STATUS"
  "ERROR_CODE_NETWORK_CLOSED"
  "ERROR_CODE_NETWORK_CONNECT"
  "ERROR_CODE_NETWORK_DNS"
  "ERROR_CODE_NETWORK_OFFLINE"
  "ERROR_CODE_NETWORK_OTHER"
  "ERROR_CODE_NETWORK_TIMEOUT"
  "ERROR_CODE_OTHER"
  "ERROR_CODE_PLAYER_BEHIND_LIVE_WINDOW"
  "ERROR_CODE_PLAYER_OTHER"
  "ERROR_CODE_PLAYER_REMOTE"
  "ERROR_CODE_RUNTIME"
  "ERROR_CODE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PlaybackErrorCode_entries[] = {
  { {PlaybackErrorCode_names + 0, 26}, 17 },
  { {PlaybackErrorCode_names + 26, 27}, 19 },
  { {PlaybackErrorCode_names + 53, 27}, 18 },
  { {PlaybackErrorCode_names + 80, 25}, 14 },
  { {PlaybackErrorCode_names + 105, 23}, 13 },
  { {PlaybackErrorCode_names + 128, 22}, 15 },
  { {PlaybackErrorCode_names + 150, 24}, 16 },
  { {PlaybackErrorCode_names + 174, 28}, 28 },
  { {PlaybackErrorCode_names + 202, 25}, 26 },
  { {PlaybackErrorCode_names + 227, 28}, 25 },
  { {PlaybackErrorCode_names + 255, 20}, 30 },
  { {PlaybackErrorCode_names + 275, 34}, 24 },
  { {PlaybackErrorCode_names + 309, 22}, 39 },
  { {PlaybackErrorCode_names + 331, 27}, 27 },
  { {PlaybackErrorCode_names + 358, 26}, 23 },
  { {PlaybackErrorCode_names + 384, 24}, 10 },
  { {PlaybackErrorCode_names + 408, 22}, 12 },
  { {PlaybackErrorCode_names + 430, 23}, 11 },
  { {PlaybackErrorCode_names + 453, 29}, 5 },
  { {PlaybackErrorCode_names + 482, 25}, 8 },
  { {PlaybackErrorCode_names + 507, 26}, 4 },
  { {PlaybackErrorCode_names + 533, 22}, 6 },
  { {PlaybackErrorCode_names + 555, 26}, 3 },
  { {PlaybackErrorCode_names + 581, 24}, 9 },
  { {PlaybackErrorCode_names + 605, 26}, 7 },
  { {PlaybackErrorCode_names + 631, 16}, 1 },
  { {PlaybackErrorCode_names + 647, 36}, 21 },
  { {PlaybackErrorCode_names + 683, 23}, 22 },
  { {PlaybackErrorCode_names + 706, 24}, 20 },
  { {PlaybackErrorCode_names + 730, 18}, 2 },
  { {PlaybackErrorCode_names + 748, 18}, 0 },
};

static const int PlaybackErrorCode_entries_by_number[] = {
  30, // 0 -> ERROR_CODE_UNKNOWN
  25, // 1 -> ERROR_CODE_OTHER
  29, // 2 -> ERROR_CODE_RUNTIME
  22, // 3 -> ERROR_CODE_NETWORK_OFFLINE
  20, // 4 -> ERROR_CODE_NETWORK_CONNECT
  18, // 5 -> ERROR_CODE_NETWORK_BAD_STATUS
  21, // 6 -> ERROR_CODE_NETWORK_DNS
  24, // 7 -> ERROR_CODE_NETWORK_TIMEOUT
  19, // 8 -> ERROR_CODE_NETWORK_CLOSED
  23, // 9 -> ERROR_CODE_NETWORK_OTHER
  15, // 10 -> ERROR_CODE_MEDIA_MANIFET
  17, // 11 -> ERROR_CODE_MEDIA_PARSER
  16, // 12 -> ERROR_CODE_MEDIA_OTHER
  4, // 13 -> ERROR_CODE_DECODER_INIT
  3, // 14 -> ERROR_CODE_DECODER_DECODE
  5, // 15 -> ERROR_CODE_DECODER_OOM
  6, // 16 -> ERROR_CODE_DECODER_OTHER
  0, // 17 -> ERROR_CODE_AUDIOTRACK_INIT
  2, // 18 -> ERROR_CODE_AUDIOTRACK_WRITE
  1, // 19 -> ERROR_CODE_AUDIOTRACK_OTHER
  28, // 20 -> ERROR_CODE_PLAYER_REMOTE
  26, // 21 -> ERROR_CODE_PLAYER_BEHIND_LIVE_WINDOW
  27, // 22 -> ERROR_CODE_PLAYER_OTHER
  14, // 23 -> ERROR_CODE_DRM_UNAVAILABLE
  11, // 24 -> ERROR_CODE_DRM_PROVISIONING_FAILED
  9, // 25 -> ERROR_CODE_DRM_LICENSE_ERROR
  8, // 26 -> ERROR_CODE_DRM_DISALLOWED
  13, // 27 -> ERROR_CODE_DRM_SYSTEM_ERROR
  7, // 28 -> ERROR_CODE_DRM_CONTENT_ERROR
  10, // 30 -> ERROR_CODE_DRM_OTHER
  12, // 39 -> ERROR_CODE_DRM_REVOKED
};

const std::string& PlaybackErrorCode_Name(
    PlaybackErrorCode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PlaybackErrorCode_entries,
          PlaybackErrorCode_entries_by_number,
          31, PlaybackErrorCode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PlaybackErrorCode_entries,
      PlaybackErrorCode_entries_by_number,
      31, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PlaybackErrorCode_strings[idx].get();
}
bool PlaybackErrorCode_Parse(
    const std::string& name, PlaybackErrorCode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PlaybackErrorCode_entries, 31, name, &int_value);
  if (success) {
    *value = static_cast<PlaybackErrorCode>(int_value);
  }
  return success;
}
bool TrackType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TrackType_strings[3] = {};

static const char TrackType_names[] =
  "AUDIO"
  "TEXT"
  "VIDEO";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TrackType_entries[] = {
  { {TrackType_names + 0, 5}, 0 },
  { {TrackType_names + 5, 4}, 2 },
  { {TrackType_names + 9, 5}, 1 },
};

static const int TrackType_entries_by_number[] = {
  0, // 0 -> AUDIO
  2, // 1 -> VIDEO
  1, // 2 -> TEXT
};

const std::string& TrackType_Name(
    TrackType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TrackType_entries,
          TrackType_entries_by_number,
          3, TrackType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TrackType_entries,
      TrackType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TrackType_strings[idx].get();
}
bool TrackType_Parse(
    const std::string& name, TrackType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TrackType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<TrackType>(int_value);
  }
  return success;
}
bool TrackState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TrackState_strings[2] = {};

static const char TrackState_names[] =
  "OFF"
  "ON";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TrackState_entries[] = {
  { {TrackState_names + 0, 3}, 0 },
  { {TrackState_names + 3, 2}, 1 },
};

static const int TrackState_entries_by_number[] = {
  0, // 0 -> OFF
  1, // 1 -> ON
};

const std::string& TrackState_Name(
    TrackState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TrackState_entries,
          TrackState_entries_by_number,
          2, TrackState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TrackState_entries,
      TrackState_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TrackState_strings[idx].get();
}
bool TrackState_Parse(
    const std::string& name, TrackState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TrackState_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<TrackState>(int_value);
  }
  return success;
}
bool TrackChangeReason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TrackChangeReason_strings[5] = {};

static const char TrackChangeReason_names[] =
  "REASON_ADAPTIVE"
  "REASON_INITIAL"
  "REASON_MANUAL"
  "REASON_OTHER"
  "REASON_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TrackChangeReason_entries[] = {
  { {TrackChangeReason_names + 0, 15}, 4 },
  { {TrackChangeReason_names + 15, 14}, 2 },
  { {TrackChangeReason_names + 29, 13}, 3 },
  { {TrackChangeReason_names + 42, 12}, 1 },
  { {TrackChangeReason_names + 54, 14}, 0 },
};

static const int TrackChangeReason_entries_by_number[] = {
  4, // 0 -> REASON_UNKNOWN
  3, // 1 -> REASON_OTHER
  1, // 2 -> REASON_INITIAL
  2, // 3 -> REASON_MANUAL
  0, // 4 -> REASON_ADAPTIVE
};

const std::string& TrackChangeReason_Name(
    TrackChangeReason value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TrackChangeReason_entries,
          TrackChangeReason_entries_by_number,
          5, TrackChangeReason_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TrackChangeReason_entries,
      TrackChangeReason_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TrackChangeReason_strings[idx].get();
}
bool TrackChangeReason_Parse(
    const std::string& name, TrackChangeReason* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TrackChangeReason_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<TrackChangeReason>(int_value);
  }
  return success;
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace mediametrics
}  // namespace stats
}  // namespace android
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
