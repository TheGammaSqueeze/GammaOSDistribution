// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/stats/dnsresolver/dns_resolver.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fdnsresolver_2fdns_5fresolver_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fdnsresolver_2fdns_5fresolver_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fdnsresolver_2fdns_5fresolver_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fdnsresolver_2fdns_5fresolver_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[2]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace android {
namespace stats {
namespace dnsresolver {
class DnsQueryEvent;
class DnsQueryEventDefaultTypeInternal;
extern DnsQueryEventDefaultTypeInternal _DnsQueryEvent_default_instance_;
class DnsQueryEvents;
class DnsQueryEventsDefaultTypeInternal;
extern DnsQueryEventsDefaultTypeInternal _DnsQueryEvents_default_instance_;
}  // namespace dnsresolver
}  // namespace stats
}  // namespace android
PROTOBUF_NAMESPACE_OPEN
template<> ::android::stats::dnsresolver::DnsQueryEvent* Arena::CreateMaybeMessage<::android::stats::dnsresolver::DnsQueryEvent>(Arena*);
template<> ::android::stats::dnsresolver::DnsQueryEvents* Arena::CreateMaybeMessage<::android::stats::dnsresolver::DnsQueryEvents>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace android {
namespace stats {
namespace dnsresolver {

enum EventType : int {
  EVENT_UNKNOWN = 0,
  EVENT_GETADDRINFO = 1,
  EVENT_GETHOSTBYNAME = 2,
  EVENT_GETHOSTBYADDR = 3,
  EVENT_RES_NSEND = 4
};
bool EventType_IsValid(int value);
constexpr EventType EventType_MIN = EVENT_UNKNOWN;
constexpr EventType EventType_MAX = EVENT_RES_NSEND;
constexpr int EventType_ARRAYSIZE = EventType_MAX + 1;

const std::string& EventType_Name(EventType value);
template<typename T>
inline const std::string& EventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EventType_Name.");
  return EventType_Name(static_cast<EventType>(enum_t_value));
}
bool EventType_Parse(
    const std::string& name, EventType* value);
enum ReturnCode : int {
  RC_EAI_NO_ERROR = 0,
  RC_EAI_ADDRFAMILY = 1,
  RC_EAI_AGAIN = 2,
  RC_EAI_BADFLAGS = 3,
  RC_EAI_FAIL = 4,
  RC_EAI_FAMILY = 5,
  RC_EAI_MEMORY = 6,
  RC_EAI_NODATA = 7,
  RC_EAI_NONAME = 8,
  RC_EAI_SERVICE = 9,
  RC_EAI_SOCKTYPE = 10,
  RC_EAI_SYSTEM = 11,
  RC_EAI_BADHINTS = 12,
  RC_EAI_PROTOCOL = 13,
  RC_EAI_OVERFLOW = 14,
  RC_RESOLV_INTERNAL_ERROR = 254,
  RC_RESOLV_TIMEOUT = 255,
  RC_EAI_MAX = 256
};
bool ReturnCode_IsValid(int value);
constexpr ReturnCode ReturnCode_MIN = RC_EAI_NO_ERROR;
constexpr ReturnCode ReturnCode_MAX = RC_EAI_MAX;
constexpr int ReturnCode_ARRAYSIZE = ReturnCode_MAX + 1;

const std::string& ReturnCode_Name(ReturnCode value);
template<typename T>
inline const std::string& ReturnCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReturnCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReturnCode_Name.");
  return ReturnCode_Name(static_cast<ReturnCode>(enum_t_value));
}
bool ReturnCode_Parse(
    const std::string& name, ReturnCode* value);
enum NsRcode : int {
  NS_R_NO_ERROR = 0,
  NS_R_FORMERR = 1,
  NS_R_SERVFAIL = 2,
  NS_R_NXDOMAIN = 3,
  NS_R_NOTIMPL = 4,
  NS_R_REFUSED = 5,
  NS_R_YXDOMAIN = 6,
  NS_R_YXRRSET = 7,
  NS_R_NXRRSET = 8,
  NS_R_NOTAUTH = 9,
  NS_R_NOTZONE = 10,
  NS_R_MAX = 11,
  NS_R_UNASSIGNED12 = 12,
  NS_R_UNASSIGNED13 = 13,
  NS_R_UNASSIGNED14 = 14,
  NS_R_UNASSIGNED15 = 15,
  NS_R_BADVERS = 16,
  NS_R_BADKEY = 17,
  NS_R_BADTIME = 18,
  NS_R_INTERNAL_ERROR = 254,
  NS_R_TIMEOUT = 255
};
bool NsRcode_IsValid(int value);
constexpr NsRcode NsRcode_MIN = NS_R_NO_ERROR;
constexpr NsRcode NsRcode_MAX = NS_R_TIMEOUT;
constexpr int NsRcode_ARRAYSIZE = NsRcode_MAX + 1;

const std::string& NsRcode_Name(NsRcode value);
template<typename T>
inline const std::string& NsRcode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NsRcode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NsRcode_Name.");
  return NsRcode_Name(static_cast<NsRcode>(enum_t_value));
}
bool NsRcode_Parse(
    const std::string& name, NsRcode* value);
enum NsType : int {
  NS_T_INVALID = 0,
  NS_T_A = 1,
  NS_T_NS = 2,
  NS_T_MD = 3,
  NS_T_MF = 4,
  NS_T_CNAME = 5,
  NS_T_SOA = 6,
  NS_T_MB = 7,
  NS_T_MG = 8,
  NS_T_MR = 9,
  NS_T_NULL = 10,
  NS_T_WKS = 11,
  NS_T_PTR = 12,
  NS_T_HINFO = 13,
  NS_T_MINFO = 14,
  NS_T_MX = 15,
  NS_T_TXT = 16,
  NS_T_RP = 17,
  NS_T_AFSDB = 18,
  NS_T_X25 = 19,
  NS_T_ISDN = 20,
  NS_T_RT = 21,
  NS_T_NSAP = 22,
  NS_T_NSAP_PTR = 23,
  NS_T_SIG = 24,
  NS_T_KEY = 25,
  NS_T_PX = 26,
  NS_T_GPOS = 27,
  NS_T_AAAA = 28,
  NS_T_LOC = 29,
  NS_T_NXT = 30,
  NS_T_EID = 31,
  NS_T_NIMLOC = 32,
  NS_T_SRV = 33,
  NS_T_ATMA = 34,
  NS_T_NAPTR = 35,
  NS_T_KX = 36,
  NS_T_CERT = 37,
  NS_T_A6 = 38,
  NS_T_DNAME = 39,
  NS_T_SINK = 40,
  NS_T_OPT = 41,
  NS_T_APL = 42,
  NS_T_DS = 43,
  NS_T_SSHFP = 44,
  NS_T_IPSECKEY = 45,
  NS_T_RRSIG = 46,
  NS_T_NSEC = 47,
  NS_T_DNSKEY = 48,
  NS_T_DHCID = 49,
  NS_T_NSEC3 = 50,
  NS_T_NSEC3PARAM = 51,
  NS_T_HIP = 55,
  NS_T_SPF = 99,
  NS_T_TKEY = 249,
  NS_T_TSIG = 250,
  NS_T_IXFR = 251,
  NS_T_AXFR = 252,
  NS_T_MAILB = 253,
  NS_T_MAILA = 254,
  NS_T_ANY = 255,
  NS_T_ZXFR = 256,
  NS_T_DLV = 32769,
  NS_T_MAX = 65536
};
bool NsType_IsValid(int value);
constexpr NsType NsType_MIN = NS_T_INVALID;
constexpr NsType NsType_MAX = NS_T_MAX;
constexpr int NsType_ARRAYSIZE = NsType_MAX + 1;

const std::string& NsType_Name(NsType value);
template<typename T>
inline const std::string& NsType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NsType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NsType_Name.");
  return NsType_Name(static_cast<NsType>(enum_t_value));
}
bool NsType_Parse(
    const std::string& name, NsType* value);
enum IpVersion : int {
  IV_UNKNOWN = 0,
  IV_IPV4 = 1,
  IV_IPV6 = 2
};
bool IpVersion_IsValid(int value);
constexpr IpVersion IpVersion_MIN = IV_UNKNOWN;
constexpr IpVersion IpVersion_MAX = IV_IPV6;
constexpr int IpVersion_ARRAYSIZE = IpVersion_MAX + 1;

const std::string& IpVersion_Name(IpVersion value);
template<typename T>
inline const std::string& IpVersion_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IpVersion>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IpVersion_Name.");
  return IpVersion_Name(static_cast<IpVersion>(enum_t_value));
}
bool IpVersion_Parse(
    const std::string& name, IpVersion* value);
enum Protocol : int {
  PROTO_UNKNOWN = 0,
  PROTO_UDP = 1,
  PROTO_TCP = 2,
  PROTO_DOT = 3,
  PROTO_DOH = 4
};
bool Protocol_IsValid(int value);
constexpr Protocol Protocol_MIN = PROTO_UNKNOWN;
constexpr Protocol Protocol_MAX = PROTO_DOH;
constexpr int Protocol_ARRAYSIZE = Protocol_MAX + 1;

const std::string& Protocol_Name(Protocol value);
template<typename T>
inline const std::string& Protocol_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Protocol>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Protocol_Name.");
  return Protocol_Name(static_cast<Protocol>(enum_t_value));
}
bool Protocol_Parse(
    const std::string& name, Protocol* value);
enum PrivateDnsModes : int {
  PDM_UNKNOWN = 0,
  PDM_OFF = 1,
  PDM_OPPORTUNISTIC = 2,
  PDM_STRICT = 3
};
bool PrivateDnsModes_IsValid(int value);
constexpr PrivateDnsModes PrivateDnsModes_MIN = PDM_UNKNOWN;
constexpr PrivateDnsModes PrivateDnsModes_MAX = PDM_STRICT;
constexpr int PrivateDnsModes_ARRAYSIZE = PrivateDnsModes_MAX + 1;

const std::string& PrivateDnsModes_Name(PrivateDnsModes value);
template<typename T>
inline const std::string& PrivateDnsModes_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PrivateDnsModes>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PrivateDnsModes_Name.");
  return PrivateDnsModes_Name(static_cast<PrivateDnsModes>(enum_t_value));
}
bool PrivateDnsModes_Parse(
    const std::string& name, PrivateDnsModes* value);
enum NetworkType : int {
  NT_UNKNOWN = 0,
  NT_CELLULAR = 1,
  NT_WIFI = 2,
  NT_BLUETOOTH = 3,
  NT_ETHERNET = 4,
  NT_VPN PROTOBUF_DEPRECATED = 5,
  NT_WIFI_AWARE = 6,
  NT_LOWPAN = 7,
  NT_CELLULAR_VPN = 8,
  NT_WIFI_VPN = 9,
  NT_BLUETOOTH_VPN = 10,
  NT_ETHERNET_VPN = 11,
  NT_WIFI_CELLULAR_VPN = 12
};
bool NetworkType_IsValid(int value);
constexpr NetworkType NetworkType_MIN = NT_UNKNOWN;
constexpr NetworkType NetworkType_MAX = NT_WIFI_CELLULAR_VPN;
constexpr int NetworkType_ARRAYSIZE = NetworkType_MAX + 1;

const std::string& NetworkType_Name(NetworkType value);
template<typename T>
inline const std::string& NetworkType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NetworkType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NetworkType_Name.");
  return NetworkType_Name(static_cast<NetworkType>(enum_t_value));
}
bool NetworkType_Parse(
    const std::string& name, NetworkType* value);
enum CacheStatus : int {
  CS_UNSUPPORTED = 0,
  CS_NOTFOUND = 1,
  CS_FOUND = 2,
  CS_SKIP = 3
};
bool CacheStatus_IsValid(int value);
constexpr CacheStatus CacheStatus_MIN = CS_UNSUPPORTED;
constexpr CacheStatus CacheStatus_MAX = CS_SKIP;
constexpr int CacheStatus_ARRAYSIZE = CacheStatus_MAX + 1;

const std::string& CacheStatus_Name(CacheStatus value);
template<typename T>
inline const std::string& CacheStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CacheStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CacheStatus_Name.");
  return CacheStatus_Name(static_cast<CacheStatus>(enum_t_value));
}
bool CacheStatus_Parse(
    const std::string& name, CacheStatus* value);
enum LinuxErrno : int {
  SYS_NO_ERROR = 0,
  SYS_EPERM = 1,
  SYS_ENOENT = 2,
  SYS_ESRCH = 3,
  SYS_EINTR = 4,
  SYS_EIO = 5,
  SYS_ENXIO = 6,
  SYS_E2BIG = 7,
  SYS_ENOEXEC = 8,
  SYS_EBADF = 9,
  SYS_ECHILD = 10,
  SYS_EAGAIN = 11,
  SYS_ENOMEM = 12,
  SYS_EACCES = 13,
  SYS_EFAULT = 14,
  SYS_ENOTBLK = 15,
  SYS_EBUSY = 16,
  SYS_EEXIST = 17,
  SYS_EXDEV = 18,
  SYS_ENODEV = 19,
  SYS_ENOTDIR = 20,
  SYS_EISDIR = 21,
  SYS_EINVAL = 22,
  SYS_ENFILE = 23,
  SYS_EMFILE = 24,
  SYS_ENOTTY = 25,
  SYS_ETXTBSY = 26,
  SYS_EFBIG = 27,
  SYS_ENOSPC = 28,
  SYS_ESPIPE = 29,
  SYS_EROFS = 30,
  SYS_EMLINK = 31,
  SYS_EPIPE = 32,
  SYS_EDOM = 33,
  SYS_ERANGE = 34,
  SYS_EDEADLOCK = 35,
  SYS_ENAMETOOLONG = 36,
  SYS_ENOLCK = 37,
  SYS_ENOSYS = 38,
  SYS_ENOTEMPTY = 39,
  SYS_ELOOP = 40,
  SYS_ENOMSG = 42,
  SYS_EIDRM = 43,
  SYS_ECHRNG = 44,
  SYS_EL2NSYNC = 45,
  SYS_EL3HLT = 46,
  SYS_EL3RST = 47,
  SYS_ELNRNG = 48,
  SYS_EUNATCH = 49,
  SYS_ENOCSI = 50,
  SYS_EL2HLT = 51,
  SYS_EBADE = 52,
  SYS_EBADR = 53,
  SYS_EXFULL = 54,
  SYS_ENOANO = 55,
  SYS_EBADRQC = 56,
  SYS_EBADSLT = 57,
  SYS_EBFONT = 59,
  SYS_ENOSTR = 60,
  SYS_ENODATA = 61,
  SYS_ETIME = 62,
  SYS_ENOSR = 63,
  SYS_ENONET = 64,
  SYS_ENOPKG = 65,
  SYS_EREMOTE = 66,
  SYS_ENOLINK = 67,
  SYS_EADV = 68,
  SYS_ESRMNT = 69,
  SYS_ECOMM = 70,
  SYS_EPROTO = 71,
  SYS_EMULTIHOP = 72,
  SYS_EDOTDOT = 73,
  SYS_EBADMSG = 74,
  SYS_EOVERFLOW = 75,
  SYS_ENOTUNIQ = 76,
  SYS_EBADFD = 77,
  SYS_EREMCHG = 78,
  SYS_ELIBACC = 79,
  SYS_ELIBBAD = 80,
  SYS_ELIBSCN = 81,
  SYS_ELIBMAX = 82,
  SYS_ELIBEXEC = 83,
  SYS_EILSEQ = 84,
  SYS_ERESTART = 85,
  SYS_ESTRPIPE = 86,
  SYS_EUSERS = 87,
  SYS_ENOTSOCK = 88,
  SYS_EDESTADDRREQ = 89,
  SYS_EMSGSIZE = 90,
  SYS_EPROTOTYPE = 91,
  SYS_ENOPROTOOPT = 92,
  SYS_EPROTONOSUPPORT = 93,
  SYS_ESOCKTNOSUPPORT = 94,
  SYS_EOPNOTSUPP = 95,
  SYS_EPFNOSUPPORT = 96,
  SYS_EAFNOSUPPORT = 97,
  SYS_EADDRINUSE = 98,
  SYS_EADDRNOTAVAIL = 99,
  SYS_ENETDOWN = 100,
  SYS_ENETUNREACH = 101,
  SYS_ENETRESET = 102,
  SYS_ECONNABORTED = 103,
  SYS_ECONNRESET = 104,
  SYS_ENOBUFS = 105,
  SYS_EISCONN = 106,
  SYS_ENOTCONN = 107,
  SYS_ESHUTDOWN = 108,
  SYS_ETOOMANYREFS = 109,
  SYS_ETIMEDOUT = 110,
  SYS_ECONNREFUSED = 111,
  SYS_EHOSTDOWN = 112,
  SYS_EHOSTUNREACH = 113,
  SYS_EALREADY = 114,
  SYS_EINPROGRESS = 115,
  SYS_ESTALE = 116,
  SYS_EUCLEAN = 117,
  SYS_ENOTNAM = 118,
  SYS_ENAVAIL = 119,
  SYS_EISNAM = 120,
  SYS_EREMOTEIO = 121,
  SYS_EDQUOT = 122,
  SYS_ENOMEDIUM = 123,
  SYS_EMEDIUMTYPE = 124,
  SYS_ECANCELED = 125,
  SYS_ENOKEY = 126,
  SYS_EKEYEXPIRED = 127,
  SYS_EKEYREVOKED = 128,
  SYS_EKEYREJECTED = 129,
  SYS_EOWNERDEAD = 130,
  SYS_ENOTRECOVERABLE = 131,
  SYS_ERFKILL = 132,
  SYS_EHWPOISON = 133
};
bool LinuxErrno_IsValid(int value);
constexpr LinuxErrno LinuxErrno_MIN = SYS_NO_ERROR;
constexpr LinuxErrno LinuxErrno_MAX = SYS_EHWPOISON;
constexpr int LinuxErrno_ARRAYSIZE = LinuxErrno_MAX + 1;

const std::string& LinuxErrno_Name(LinuxErrno value);
template<typename T>
inline const std::string& LinuxErrno_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LinuxErrno>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LinuxErrno_Name.");
  return LinuxErrno_Name(static_cast<LinuxErrno>(enum_t_value));
}
bool LinuxErrno_Parse(
    const std::string& name, LinuxErrno* value);
// ===================================================================

class DnsQueryEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:android.stats.dnsresolver.DnsQueryEvent) */ {
 public:
  DnsQueryEvent();
  virtual ~DnsQueryEvent();

  DnsQueryEvent(const DnsQueryEvent& from);
  DnsQueryEvent(DnsQueryEvent&& from) noexcept
    : DnsQueryEvent() {
    *this = ::std::move(from);
  }

  inline DnsQueryEvent& operator=(const DnsQueryEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DnsQueryEvent& operator=(DnsQueryEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DnsQueryEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DnsQueryEvent* internal_default_instance() {
    return reinterpret_cast<const DnsQueryEvent*>(
               &_DnsQueryEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DnsQueryEvent& a, DnsQueryEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(DnsQueryEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DnsQueryEvent* New() const final {
    return CreateMaybeMessage<DnsQueryEvent>(nullptr);
  }

  DnsQueryEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DnsQueryEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DnsQueryEvent& from);
  void MergeFrom(const DnsQueryEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DnsQueryEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.stats.dnsresolver.DnsQueryEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRcodeFieldNumber = 1,
    kTypeFieldNumber = 2,
    kCacheHitFieldNumber = 3,
    kIpVersionFieldNumber = 4,
    kProtocolFieldNumber = 5,
    kRetryTimesFieldNumber = 6,
    kDnsServerIndexFieldNumber = 7,
    kConnectedFieldNumber = 8,
    kLatencyMicrosFieldNumber = 9,
    kLinuxErrnoFieldNumber = 10,
  };
  // optional .android.stats.dnsresolver.NsRcode rcode = 1;
  bool has_rcode() const;
  void clear_rcode();
  ::android::stats::dnsresolver::NsRcode rcode() const;
  void set_rcode(::android::stats::dnsresolver::NsRcode value);

  // optional .android.stats.dnsresolver.NsType type = 2;
  bool has_type() const;
  void clear_type();
  ::android::stats::dnsresolver::NsType type() const;
  void set_type(::android::stats::dnsresolver::NsType value);

  // optional .android.stats.dnsresolver.CacheStatus cache_hit = 3;
  bool has_cache_hit() const;
  void clear_cache_hit();
  ::android::stats::dnsresolver::CacheStatus cache_hit() const;
  void set_cache_hit(::android::stats::dnsresolver::CacheStatus value);

  // optional .android.stats.dnsresolver.IpVersion ip_version = 4;
  bool has_ip_version() const;
  void clear_ip_version();
  ::android::stats::dnsresolver::IpVersion ip_version() const;
  void set_ip_version(::android::stats::dnsresolver::IpVersion value);

  // optional .android.stats.dnsresolver.Protocol protocol = 5;
  bool has_protocol() const;
  void clear_protocol();
  ::android::stats::dnsresolver::Protocol protocol() const;
  void set_protocol(::android::stats::dnsresolver::Protocol value);

  // optional int32 retry_times = 6;
  bool has_retry_times() const;
  void clear_retry_times();
  ::PROTOBUF_NAMESPACE_ID::int32 retry_times() const;
  void set_retry_times(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 dns_server_index = 7;
  bool has_dns_server_index() const;
  void clear_dns_server_index();
  ::PROTOBUF_NAMESPACE_ID::int32 dns_server_index() const;
  void set_dns_server_index(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional bool connected = 8;
  bool has_connected() const;
  void clear_connected();
  bool connected() const;
  void set_connected(bool value);

  // optional int32 latency_micros = 9;
  bool has_latency_micros() const;
  void clear_latency_micros();
  ::PROTOBUF_NAMESPACE_ID::int32 latency_micros() const;
  void set_latency_micros(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional .android.stats.dnsresolver.LinuxErrno linux_errno = 10;
  bool has_linux_errno() const;
  void clear_linux_errno();
  ::android::stats::dnsresolver::LinuxErrno linux_errno() const;
  void set_linux_errno(::android::stats::dnsresolver::LinuxErrno value);

  // @@protoc_insertion_point(class_scope:android.stats.dnsresolver.DnsQueryEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int rcode_;
  int type_;
  int cache_hit_;
  int ip_version_;
  int protocol_;
  ::PROTOBUF_NAMESPACE_ID::int32 retry_times_;
  ::PROTOBUF_NAMESPACE_ID::int32 dns_server_index_;
  bool connected_;
  ::PROTOBUF_NAMESPACE_ID::int32 latency_micros_;
  int linux_errno_;
  friend struct ::TableStruct_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fdnsresolver_2fdns_5fresolver_2eproto;
};
// -------------------------------------------------------------------

class DnsQueryEvents :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:android.stats.dnsresolver.DnsQueryEvents) */ {
 public:
  DnsQueryEvents();
  virtual ~DnsQueryEvents();

  DnsQueryEvents(const DnsQueryEvents& from);
  DnsQueryEvents(DnsQueryEvents&& from) noexcept
    : DnsQueryEvents() {
    *this = ::std::move(from);
  }

  inline DnsQueryEvents& operator=(const DnsQueryEvents& from) {
    CopyFrom(from);
    return *this;
  }
  inline DnsQueryEvents& operator=(DnsQueryEvents&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DnsQueryEvents& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DnsQueryEvents* internal_default_instance() {
    return reinterpret_cast<const DnsQueryEvents*>(
               &_DnsQueryEvents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DnsQueryEvents& a, DnsQueryEvents& b) {
    a.Swap(&b);
  }
  inline void Swap(DnsQueryEvents* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DnsQueryEvents* New() const final {
    return CreateMaybeMessage<DnsQueryEvents>(nullptr);
  }

  DnsQueryEvents* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DnsQueryEvents>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DnsQueryEvents& from);
  void MergeFrom(const DnsQueryEvents& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DnsQueryEvents* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.stats.dnsresolver.DnsQueryEvents";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDnsQueryEventFieldNumber = 1,
  };
  // repeated .android.stats.dnsresolver.DnsQueryEvent dns_query_event = 1;
  int dns_query_event_size() const;
  void clear_dns_query_event();
  ::android::stats::dnsresolver::DnsQueryEvent* mutable_dns_query_event(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::stats::dnsresolver::DnsQueryEvent >*
      mutable_dns_query_event();
  const ::android::stats::dnsresolver::DnsQueryEvent& dns_query_event(int index) const;
  ::android::stats::dnsresolver::DnsQueryEvent* add_dns_query_event();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::stats::dnsresolver::DnsQueryEvent >&
      dns_query_event() const;

  // @@protoc_insertion_point(class_scope:android.stats.dnsresolver.DnsQueryEvents)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::stats::dnsresolver::DnsQueryEvent > dns_query_event_;
  friend struct ::TableStruct_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fdnsresolver_2fdns_5fresolver_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DnsQueryEvent

// optional .android.stats.dnsresolver.NsRcode rcode = 1;
inline bool DnsQueryEvent::has_rcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DnsQueryEvent::clear_rcode() {
  rcode_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::android::stats::dnsresolver::NsRcode DnsQueryEvent::rcode() const {
  // @@protoc_insertion_point(field_get:android.stats.dnsresolver.DnsQueryEvent.rcode)
  return static_cast< ::android::stats::dnsresolver::NsRcode >(rcode_);
}
inline void DnsQueryEvent::set_rcode(::android::stats::dnsresolver::NsRcode value) {
  assert(::android::stats::dnsresolver::NsRcode_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  rcode_ = value;
  // @@protoc_insertion_point(field_set:android.stats.dnsresolver.DnsQueryEvent.rcode)
}

// optional .android.stats.dnsresolver.NsType type = 2;
inline bool DnsQueryEvent::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DnsQueryEvent::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::android::stats::dnsresolver::NsType DnsQueryEvent::type() const {
  // @@protoc_insertion_point(field_get:android.stats.dnsresolver.DnsQueryEvent.type)
  return static_cast< ::android::stats::dnsresolver::NsType >(type_);
}
inline void DnsQueryEvent::set_type(::android::stats::dnsresolver::NsType value) {
  assert(::android::stats::dnsresolver::NsType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
  // @@protoc_insertion_point(field_set:android.stats.dnsresolver.DnsQueryEvent.type)
}

// optional .android.stats.dnsresolver.CacheStatus cache_hit = 3;
inline bool DnsQueryEvent::has_cache_hit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DnsQueryEvent::clear_cache_hit() {
  cache_hit_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::android::stats::dnsresolver::CacheStatus DnsQueryEvent::cache_hit() const {
  // @@protoc_insertion_point(field_get:android.stats.dnsresolver.DnsQueryEvent.cache_hit)
  return static_cast< ::android::stats::dnsresolver::CacheStatus >(cache_hit_);
}
inline void DnsQueryEvent::set_cache_hit(::android::stats::dnsresolver::CacheStatus value) {
  assert(::android::stats::dnsresolver::CacheStatus_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  cache_hit_ = value;
  // @@protoc_insertion_point(field_set:android.stats.dnsresolver.DnsQueryEvent.cache_hit)
}

// optional .android.stats.dnsresolver.IpVersion ip_version = 4;
inline bool DnsQueryEvent::has_ip_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DnsQueryEvent::clear_ip_version() {
  ip_version_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::android::stats::dnsresolver::IpVersion DnsQueryEvent::ip_version() const {
  // @@protoc_insertion_point(field_get:android.stats.dnsresolver.DnsQueryEvent.ip_version)
  return static_cast< ::android::stats::dnsresolver::IpVersion >(ip_version_);
}
inline void DnsQueryEvent::set_ip_version(::android::stats::dnsresolver::IpVersion value) {
  assert(::android::stats::dnsresolver::IpVersion_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  ip_version_ = value;
  // @@protoc_insertion_point(field_set:android.stats.dnsresolver.DnsQueryEvent.ip_version)
}

// optional .android.stats.dnsresolver.Protocol protocol = 5;
inline bool DnsQueryEvent::has_protocol() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DnsQueryEvent::clear_protocol() {
  protocol_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::android::stats::dnsresolver::Protocol DnsQueryEvent::protocol() const {
  // @@protoc_insertion_point(field_get:android.stats.dnsresolver.DnsQueryEvent.protocol)
  return static_cast< ::android::stats::dnsresolver::Protocol >(protocol_);
}
inline void DnsQueryEvent::set_protocol(::android::stats::dnsresolver::Protocol value) {
  assert(::android::stats::dnsresolver::Protocol_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  protocol_ = value;
  // @@protoc_insertion_point(field_set:android.stats.dnsresolver.DnsQueryEvent.protocol)
}

// optional int32 retry_times = 6;
inline bool DnsQueryEvent::has_retry_times() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DnsQueryEvent::clear_retry_times() {
  retry_times_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DnsQueryEvent::retry_times() const {
  // @@protoc_insertion_point(field_get:android.stats.dnsresolver.DnsQueryEvent.retry_times)
  return retry_times_;
}
inline void DnsQueryEvent::set_retry_times(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  retry_times_ = value;
  // @@protoc_insertion_point(field_set:android.stats.dnsresolver.DnsQueryEvent.retry_times)
}

// optional int32 dns_server_index = 7;
inline bool DnsQueryEvent::has_dns_server_index() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DnsQueryEvent::clear_dns_server_index() {
  dns_server_index_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DnsQueryEvent::dns_server_index() const {
  // @@protoc_insertion_point(field_get:android.stats.dnsresolver.DnsQueryEvent.dns_server_index)
  return dns_server_index_;
}
inline void DnsQueryEvent::set_dns_server_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  dns_server_index_ = value;
  // @@protoc_insertion_point(field_set:android.stats.dnsresolver.DnsQueryEvent.dns_server_index)
}

// optional bool connected = 8;
inline bool DnsQueryEvent::has_connected() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DnsQueryEvent::clear_connected() {
  connected_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool DnsQueryEvent::connected() const {
  // @@protoc_insertion_point(field_get:android.stats.dnsresolver.DnsQueryEvent.connected)
  return connected_;
}
inline void DnsQueryEvent::set_connected(bool value) {
  _has_bits_[0] |= 0x00000080u;
  connected_ = value;
  // @@protoc_insertion_point(field_set:android.stats.dnsresolver.DnsQueryEvent.connected)
}

// optional int32 latency_micros = 9;
inline bool DnsQueryEvent::has_latency_micros() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DnsQueryEvent::clear_latency_micros() {
  latency_micros_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DnsQueryEvent::latency_micros() const {
  // @@protoc_insertion_point(field_get:android.stats.dnsresolver.DnsQueryEvent.latency_micros)
  return latency_micros_;
}
inline void DnsQueryEvent::set_latency_micros(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  latency_micros_ = value;
  // @@protoc_insertion_point(field_set:android.stats.dnsresolver.DnsQueryEvent.latency_micros)
}

// optional .android.stats.dnsresolver.LinuxErrno linux_errno = 10;
inline bool DnsQueryEvent::has_linux_errno() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DnsQueryEvent::clear_linux_errno() {
  linux_errno_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::android::stats::dnsresolver::LinuxErrno DnsQueryEvent::linux_errno() const {
  // @@protoc_insertion_point(field_get:android.stats.dnsresolver.DnsQueryEvent.linux_errno)
  return static_cast< ::android::stats::dnsresolver::LinuxErrno >(linux_errno_);
}
inline void DnsQueryEvent::set_linux_errno(::android::stats::dnsresolver::LinuxErrno value) {
  assert(::android::stats::dnsresolver::LinuxErrno_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  linux_errno_ = value;
  // @@protoc_insertion_point(field_set:android.stats.dnsresolver.DnsQueryEvent.linux_errno)
}

// -------------------------------------------------------------------

// DnsQueryEvents

// repeated .android.stats.dnsresolver.DnsQueryEvent dns_query_event = 1;
inline int DnsQueryEvents::dns_query_event_size() const {
  return dns_query_event_.size();
}
inline void DnsQueryEvents::clear_dns_query_event() {
  dns_query_event_.Clear();
}
inline ::android::stats::dnsresolver::DnsQueryEvent* DnsQueryEvents::mutable_dns_query_event(int index) {
  // @@protoc_insertion_point(field_mutable:android.stats.dnsresolver.DnsQueryEvents.dns_query_event)
  return dns_query_event_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::stats::dnsresolver::DnsQueryEvent >*
DnsQueryEvents::mutable_dns_query_event() {
  // @@protoc_insertion_point(field_mutable_list:android.stats.dnsresolver.DnsQueryEvents.dns_query_event)
  return &dns_query_event_;
}
inline const ::android::stats::dnsresolver::DnsQueryEvent& DnsQueryEvents::dns_query_event(int index) const {
  // @@protoc_insertion_point(field_get:android.stats.dnsresolver.DnsQueryEvents.dns_query_event)
  return dns_query_event_.Get(index);
}
inline ::android::stats::dnsresolver::DnsQueryEvent* DnsQueryEvents::add_dns_query_event() {
  // @@protoc_insertion_point(field_add:android.stats.dnsresolver.DnsQueryEvents.dns_query_event)
  return dns_query_event_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::stats::dnsresolver::DnsQueryEvent >&
DnsQueryEvents::dns_query_event() const {
  // @@protoc_insertion_point(field_list:android.stats.dnsresolver.DnsQueryEvents.dns_query_event)
  return dns_query_event_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace dnsresolver
}  // namespace stats
}  // namespace android

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::android::stats::dnsresolver::EventType> : ::std::true_type {};
template <> struct is_proto_enum< ::android::stats::dnsresolver::ReturnCode> : ::std::true_type {};
template <> struct is_proto_enum< ::android::stats::dnsresolver::NsRcode> : ::std::true_type {};
template <> struct is_proto_enum< ::android::stats::dnsresolver::NsType> : ::std::true_type {};
template <> struct is_proto_enum< ::android::stats::dnsresolver::IpVersion> : ::std::true_type {};
template <> struct is_proto_enum< ::android::stats::dnsresolver::Protocol> : ::std::true_type {};
template <> struct is_proto_enum< ::android::stats::dnsresolver::PrivateDnsModes> : ::std::true_type {};
template <> struct is_proto_enum< ::android::stats::dnsresolver::NetworkType> : ::std::true_type {};
template <> struct is_proto_enum< ::android::stats::dnsresolver::CacheStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::android::stats::dnsresolver::LinuxErrno> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fdnsresolver_2fdns_5fresolver_2eproto
