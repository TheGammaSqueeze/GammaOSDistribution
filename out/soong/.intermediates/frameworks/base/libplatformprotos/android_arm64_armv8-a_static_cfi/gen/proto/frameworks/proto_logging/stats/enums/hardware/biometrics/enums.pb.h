// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/hardware/biometrics/enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fhardware_2fbiometrics_2fenums_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fhardware_2fbiometrics_2fenums_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_frameworks_2fproto_5flogging_2fstats_2fenums_2fhardware_2fbiometrics_2fenums_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_frameworks_2fproto_5flogging_2fstats_2fenums_2fhardware_2fbiometrics_2fenums_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace android {
namespace hardware {
namespace biometrics {

enum ModalityEnum : int {
  MODALITY_UNKNOWN = 0,
  MODALITY_FINGERPRINT = 1,
  MODALITY_IRIS = 2,
  MODALITY_FACE = 4
};
bool ModalityEnum_IsValid(int value);
constexpr ModalityEnum ModalityEnum_MIN = MODALITY_UNKNOWN;
constexpr ModalityEnum ModalityEnum_MAX = MODALITY_FACE;
constexpr int ModalityEnum_ARRAYSIZE = ModalityEnum_MAX + 1;

const std::string& ModalityEnum_Name(ModalityEnum value);
template<typename T>
inline const std::string& ModalityEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModalityEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModalityEnum_Name.");
  return ModalityEnum_Name(static_cast<ModalityEnum>(enum_t_value));
}
bool ModalityEnum_Parse(
    const std::string& name, ModalityEnum* value);
enum ClientEnum : int {
  CLIENT_UNKNOWN = 0,
  CLIENT_KEYGUARD = 1,
  CLIENT_BIOMETRIC_PROMPT = 2,
  CLIENT_FINGERPRINT_MANAGER = 3
};
bool ClientEnum_IsValid(int value);
constexpr ClientEnum ClientEnum_MIN = CLIENT_UNKNOWN;
constexpr ClientEnum ClientEnum_MAX = CLIENT_FINGERPRINT_MANAGER;
constexpr int ClientEnum_ARRAYSIZE = ClientEnum_MAX + 1;

const std::string& ClientEnum_Name(ClientEnum value);
template<typename T>
inline const std::string& ClientEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientEnum_Name.");
  return ClientEnum_Name(static_cast<ClientEnum>(enum_t_value));
}
bool ClientEnum_Parse(
    const std::string& name, ClientEnum* value);
enum ActionEnum : int {
  ACTION_UNKNOWN = 0,
  ACTION_ENROLL = 1,
  ACTION_AUTHENTICATE = 2,
  ACTION_ENUMERATE = 3,
  ACTION_REMOVE = 4
};
bool ActionEnum_IsValid(int value);
constexpr ActionEnum ActionEnum_MIN = ACTION_UNKNOWN;
constexpr ActionEnum ActionEnum_MAX = ACTION_REMOVE;
constexpr int ActionEnum_ARRAYSIZE = ActionEnum_MAX + 1;

const std::string& ActionEnum_Name(ActionEnum value);
template<typename T>
inline const std::string& ActionEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActionEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActionEnum_Name.");
  return ActionEnum_Name(static_cast<ActionEnum>(enum_t_value));
}
bool ActionEnum_Parse(
    const std::string& name, ActionEnum* value);
enum IssueEnum : int {
  ISSUE_UNKNOWN = 0,
  ISSUE_HAL_DEATH = 1,
  ISSUE_UNKNOWN_TEMPLATE_ENROLLED_FRAMEWORK = 2,
  ISSUE_UNKNOWN_TEMPLATE_ENROLLED_HAL = 3,
  ISSUE_CANCEL_TIMED_OUT = 4
};
bool IssueEnum_IsValid(int value);
constexpr IssueEnum IssueEnum_MIN = ISSUE_UNKNOWN;
constexpr IssueEnum IssueEnum_MAX = ISSUE_CANCEL_TIMED_OUT;
constexpr int IssueEnum_ARRAYSIZE = IssueEnum_MAX + 1;

const std::string& IssueEnum_Name(IssueEnum value);
template<typename T>
inline const std::string& IssueEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IssueEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IssueEnum_Name.");
  return IssueEnum_Name(static_cast<IssueEnum>(enum_t_value));
}
bool IssueEnum_Parse(
    const std::string& name, IssueEnum* value);
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace biometrics
}  // namespace hardware
}  // namespace android

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::android::hardware::biometrics::ModalityEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::hardware::biometrics::ClientEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::hardware::biometrics::ActionEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::hardware::biometrics::IssueEnum> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fhardware_2fbiometrics_2fenums_2eproto
