// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/server/location/enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fserver_2flocation_2fenums_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fserver_2flocation_2fenums_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_frameworks_2fproto_5flogging_2fstats_2fenums_2fserver_2flocation_2fenums_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_frameworks_2fproto_5flogging_2fstats_2fenums_2fserver_2flocation_2fenums_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace android {
namespace server {
namespace location {

enum GpsSignalQualityEnum : int {
  GPS_SIGNAL_QUALITY_UNKNOWN = -1,
  GPS_SIGNAL_QUALITY_POOR = 0,
  GPS_SIGNAL_QUALITY_GOOD = 1
};
bool GpsSignalQualityEnum_IsValid(int value);
constexpr GpsSignalQualityEnum GpsSignalQualityEnum_MIN = GPS_SIGNAL_QUALITY_UNKNOWN;
constexpr GpsSignalQualityEnum GpsSignalQualityEnum_MAX = GPS_SIGNAL_QUALITY_GOOD;
constexpr int GpsSignalQualityEnum_ARRAYSIZE = GpsSignalQualityEnum_MAX + 1;

const std::string& GpsSignalQualityEnum_Name(GpsSignalQualityEnum value);
template<typename T>
inline const std::string& GpsSignalQualityEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GpsSignalQualityEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GpsSignalQualityEnum_Name.");
  return GpsSignalQualityEnum_Name(static_cast<GpsSignalQualityEnum>(enum_t_value));
}
bool GpsSignalQualityEnum_Parse(
    const std::string& name, GpsSignalQualityEnum* value);
enum GnssNiType : int {
  VOICE = 1,
  UMTS_SUPL = 2,
  UMTS_CTRL_PLANE = 3,
  EMERGENCY_SUPL = 4
};
bool GnssNiType_IsValid(int value);
constexpr GnssNiType GnssNiType_MIN = VOICE;
constexpr GnssNiType GnssNiType_MAX = EMERGENCY_SUPL;
constexpr int GnssNiType_ARRAYSIZE = GnssNiType_MAX + 1;

const std::string& GnssNiType_Name(GnssNiType value);
template<typename T>
inline const std::string& GnssNiType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GnssNiType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GnssNiType_Name.");
  return GnssNiType_Name(static_cast<GnssNiType>(enum_t_value));
}
bool GnssNiType_Parse(
    const std::string& name, GnssNiType* value);
enum GnssUserResponseType : int {
  RESPONSE_ACCEPT = 1,
  RESPONSE_DENY = 2,
  RESPONSE_NORESP = 3
};
bool GnssUserResponseType_IsValid(int value);
constexpr GnssUserResponseType GnssUserResponseType_MIN = RESPONSE_ACCEPT;
constexpr GnssUserResponseType GnssUserResponseType_MAX = RESPONSE_NORESP;
constexpr int GnssUserResponseType_ARRAYSIZE = GnssUserResponseType_MAX + 1;

const std::string& GnssUserResponseType_Name(GnssUserResponseType value);
template<typename T>
inline const std::string& GnssUserResponseType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GnssUserResponseType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GnssUserResponseType_Name.");
  return GnssUserResponseType_Name(static_cast<GnssUserResponseType>(enum_t_value));
}
bool GnssUserResponseType_Parse(
    const std::string& name, GnssUserResponseType* value);
enum GnssNiEncodingType : int {
  ENC_NONE = 0,
  ENC_SUPL_GSM_DEFAULT = 1,
  ENC_SUPL_UTF8 = 2,
  ENC_SUPL_UCS2 = 3,
  ENC_UNKNOWN = -1
};
bool GnssNiEncodingType_IsValid(int value);
constexpr GnssNiEncodingType GnssNiEncodingType_MIN = ENC_UNKNOWN;
constexpr GnssNiEncodingType GnssNiEncodingType_MAX = ENC_SUPL_UCS2;
constexpr int GnssNiEncodingType_ARRAYSIZE = GnssNiEncodingType_MAX + 1;

const std::string& GnssNiEncodingType_Name(GnssNiEncodingType value);
template<typename T>
inline const std::string& GnssNiEncodingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GnssNiEncodingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GnssNiEncodingType_Name.");
  return GnssNiEncodingType_Name(static_cast<GnssNiEncodingType>(enum_t_value));
}
bool GnssNiEncodingType_Parse(
    const std::string& name, GnssNiEncodingType* value);
enum NfwProtocolStack : int {
  CTRL_PLANE = 0,
  SUPL = 1,
  IMS = 10,
  SIM = 11,
  OTHER_PROTOCOL_STACK = 100
};
bool NfwProtocolStack_IsValid(int value);
constexpr NfwProtocolStack NfwProtocolStack_MIN = CTRL_PLANE;
constexpr NfwProtocolStack NfwProtocolStack_MAX = OTHER_PROTOCOL_STACK;
constexpr int NfwProtocolStack_ARRAYSIZE = NfwProtocolStack_MAX + 1;

const std::string& NfwProtocolStack_Name(NfwProtocolStack value);
template<typename T>
inline const std::string& NfwProtocolStack_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NfwProtocolStack>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NfwProtocolStack_Name.");
  return NfwProtocolStack_Name(static_cast<NfwProtocolStack>(enum_t_value));
}
bool NfwProtocolStack_Parse(
    const std::string& name, NfwProtocolStack* value);
enum NfwRequestor : int {
  CARRIER = 0,
  OEM = 10,
  MODEM_CHIPSET_VENDOR = 11,
  GNSS_CHIPSET_VENDOR = 12,
  OTHER_CHIPSET_VENDOR = 13,
  AUTOMOBILE_CLIENT = 20,
  OTHER_REQUESTOR = 100
};
bool NfwRequestor_IsValid(int value);
constexpr NfwRequestor NfwRequestor_MIN = CARRIER;
constexpr NfwRequestor NfwRequestor_MAX = OTHER_REQUESTOR;
constexpr int NfwRequestor_ARRAYSIZE = NfwRequestor_MAX + 1;

const std::string& NfwRequestor_Name(NfwRequestor value);
template<typename T>
inline const std::string& NfwRequestor_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NfwRequestor>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NfwRequestor_Name.");
  return NfwRequestor_Name(static_cast<NfwRequestor>(enum_t_value));
}
bool NfwRequestor_Parse(
    const std::string& name, NfwRequestor* value);
enum NfwResponseType : int {
  REJECTED = 0,
  ACCEPTED_NO_LOCATION_PROVIDED = 1,
  ACCEPTED_LOCATION_PROVIDED = 2
};
bool NfwResponseType_IsValid(int value);
constexpr NfwResponseType NfwResponseType_MIN = REJECTED;
constexpr NfwResponseType NfwResponseType_MAX = ACCEPTED_LOCATION_PROVIDED;
constexpr int NfwResponseType_ARRAYSIZE = NfwResponseType_MAX + 1;

const std::string& NfwResponseType_Name(NfwResponseType value);
template<typename T>
inline const std::string& NfwResponseType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NfwResponseType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NfwResponseType_Name.");
  return NfwResponseType_Name(static_cast<NfwResponseType>(enum_t_value));
}
bool NfwResponseType_Parse(
    const std::string& name, NfwResponseType* value);
enum SuplMode : int {
  MSB = 1,
  MSA = 2
};
bool SuplMode_IsValid(int value);
constexpr SuplMode SuplMode_MIN = MSB;
constexpr SuplMode SuplMode_MAX = MSA;
constexpr int SuplMode_ARRAYSIZE = SuplMode_MAX + 1;

const std::string& SuplMode_Name(SuplMode value);
template<typename T>
inline const std::string& SuplMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SuplMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SuplMode_Name.");
  return SuplMode_Name(static_cast<SuplMode>(enum_t_value));
}
bool SuplMode_Parse(
    const std::string& name, SuplMode* value);
enum LppProfile : int {
  USER_PLANE = 1,
  CONTROL_PLANE = 2
};
bool LppProfile_IsValid(int value);
constexpr LppProfile LppProfile_MIN = USER_PLANE;
constexpr LppProfile LppProfile_MAX = CONTROL_PLANE;
constexpr int LppProfile_ARRAYSIZE = LppProfile_MAX + 1;

const std::string& LppProfile_Name(LppProfile value);
template<typename T>
inline const std::string& LppProfile_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LppProfile>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LppProfile_Name.");
  return LppProfile_Name(static_cast<LppProfile>(enum_t_value));
}
bool LppProfile_Parse(
    const std::string& name, LppProfile* value);
enum GlonassPosProtocol : int {
  RRC_CPLANE = 1,
  RRLP_CPLANE = 2,
  LPP_UPLANE = 4
};
bool GlonassPosProtocol_IsValid(int value);
constexpr GlonassPosProtocol GlonassPosProtocol_MIN = RRC_CPLANE;
constexpr GlonassPosProtocol GlonassPosProtocol_MAX = LPP_UPLANE;
constexpr int GlonassPosProtocol_ARRAYSIZE = GlonassPosProtocol_MAX + 1;

const std::string& GlonassPosProtocol_Name(GlonassPosProtocol value);
template<typename T>
inline const std::string& GlonassPosProtocol_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GlonassPosProtocol>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GlonassPosProtocol_Name.");
  return GlonassPosProtocol_Name(static_cast<GlonassPosProtocol>(enum_t_value));
}
bool GlonassPosProtocol_Parse(
    const std::string& name, GlonassPosProtocol* value);
enum GpsLock : int {
  MO = 1,
  NI = 2
};
bool GpsLock_IsValid(int value);
constexpr GpsLock GpsLock_MIN = MO;
constexpr GpsLock GpsLock_MAX = NI;
constexpr int GpsLock_ARRAYSIZE = GpsLock_MAX + 1;

const std::string& GpsLock_Name(GpsLock value);
template<typename T>
inline const std::string& GpsLock_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GpsLock>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GpsLock_Name.");
  return GpsLock_Name(static_cast<GpsLock>(enum_t_value));
}
bool GpsLock_Parse(
    const std::string& name, GpsLock* value);
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace location
}  // namespace server
}  // namespace android

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::android::server::location::GpsSignalQualityEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::server::location::GnssNiType> : ::std::true_type {};
template <> struct is_proto_enum< ::android::server::location::GnssUserResponseType> : ::std::true_type {};
template <> struct is_proto_enum< ::android::server::location::GnssNiEncodingType> : ::std::true_type {};
template <> struct is_proto_enum< ::android::server::location::NfwProtocolStack> : ::std::true_type {};
template <> struct is_proto_enum< ::android::server::location::NfwRequestor> : ::std::true_type {};
template <> struct is_proto_enum< ::android::server::location::NfwResponseType> : ::std::true_type {};
template <> struct is_proto_enum< ::android::server::location::SuplMode> : ::std::true_type {};
template <> struct is_proto_enum< ::android::server::location::LppProfile> : ::std::true_type {};
template <> struct is_proto_enum< ::android::server::location::GlonassPosProtocol> : ::std::true_type {};
template <> struct is_proto_enum< ::android::server::location::GpsLock> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fserver_2flocation_2fenums_2eproto
