// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/base/core/proto/android/service/usb.proto

#include "frameworks/base/core/proto/android/service/usb.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fcontent_2fcomponent_5fname_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ComponentNameProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fcontent_2fcomponent_5fname_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbAccessoryAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbAccessoryFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbAccessoryPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbAccessoryPersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbAccessoryProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbAlsaDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbAlsaManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbConfigurationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbConnectionRecordProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbDebuggingManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbDeviceAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbDeviceFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbDeviceManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbDevicePermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbDevicePersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbEndPointProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbHandlerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_UsbHostManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbInterfaceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbIsHeadsetProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbMidiDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbPortInfoProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbPortManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbPortProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbPortStatusProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbPortStatusRoleCombinationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbProfileGroupSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbSettingsAccessoryPreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbSettingsDevicePreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbUidPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_UsbUserPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbUserSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UserPackageProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
namespace android {
namespace service {
namespace usb {
class UsbServiceDumpProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbServiceDumpProto> _instance;
} _UsbServiceDumpProto_default_instance_;
class UsbDeviceManagerProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbDeviceManagerProto> _instance;
} _UsbDeviceManagerProto_default_instance_;
class UsbHandlerProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbHandlerProto> _instance;
} _UsbHandlerProto_default_instance_;
class UsbAccessoryProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbAccessoryProto> _instance;
} _UsbAccessoryProto_default_instance_;
class UsbDebuggingManagerProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbDebuggingManagerProto> _instance;
} _UsbDebuggingManagerProto_default_instance_;
class UsbHostManagerProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbHostManagerProto> _instance;
} _UsbHostManagerProto_default_instance_;
class UsbDeviceProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbDeviceProto> _instance;
} _UsbDeviceProto_default_instance_;
class UsbConfigurationProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbConfigurationProto> _instance;
} _UsbConfigurationProto_default_instance_;
class UsbInterfaceProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbInterfaceProto> _instance;
} _UsbInterfaceProto_default_instance_;
class UsbEndPointProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbEndPointProto> _instance;
} _UsbEndPointProto_default_instance_;
class UsbConnectionRecordProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbConnectionRecordProto> _instance;
} _UsbConnectionRecordProto_default_instance_;
class UsbIsHeadsetProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbIsHeadsetProto> _instance;
} _UsbIsHeadsetProto_default_instance_;
class UsbPortManagerProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbPortManagerProto> _instance;
} _UsbPortManagerProto_default_instance_;
class UsbPortInfoProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbPortInfoProto> _instance;
} _UsbPortInfoProto_default_instance_;
class UsbPortProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbPortProto> _instance;
} _UsbPortProto_default_instance_;
class UsbPortStatusProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbPortStatusProto> _instance;
} _UsbPortStatusProto_default_instance_;
class UsbPortStatusRoleCombinationProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbPortStatusRoleCombinationProto> _instance;
} _UsbPortStatusRoleCombinationProto_default_instance_;
class UsbAlsaManagerProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbAlsaManagerProto> _instance;
} _UsbAlsaManagerProto_default_instance_;
class UsbAlsaDeviceProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbAlsaDeviceProto> _instance;
} _UsbAlsaDeviceProto_default_instance_;
class UsbMidiDeviceProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbMidiDeviceProto> _instance;
} _UsbMidiDeviceProto_default_instance_;
class UsbSettingsManagerProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbSettingsManagerProto> _instance;
} _UsbSettingsManagerProto_default_instance_;
class UsbUserSettingsManagerProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbUserSettingsManagerProto> _instance;
} _UsbUserSettingsManagerProto_default_instance_;
class UsbProfileGroupSettingsManagerProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbProfileGroupSettingsManagerProto> _instance;
} _UsbProfileGroupSettingsManagerProto_default_instance_;
class UsbSettingsDevicePreferenceProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbSettingsDevicePreferenceProto> _instance;
} _UsbSettingsDevicePreferenceProto_default_instance_;
class UsbPermissionsManagerProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbPermissionsManagerProto> _instance;
} _UsbPermissionsManagerProto_default_instance_;
class UsbUserPermissionsManagerProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbUserPermissionsManagerProto> _instance;
} _UsbUserPermissionsManagerProto_default_instance_;
class UsbDevicePermissionProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbDevicePermissionProto> _instance;
} _UsbDevicePermissionProto_default_instance_;
class UsbAccessoryPermissionProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbAccessoryPermissionProto> _instance;
} _UsbAccessoryPermissionProto_default_instance_;
class UsbDevicePersistentPermissionProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbDevicePersistentPermissionProto> _instance;
} _UsbDevicePersistentPermissionProto_default_instance_;
class UsbAccessoryPersistentPermissionProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbAccessoryPersistentPermissionProto> _instance;
} _UsbAccessoryPersistentPermissionProto_default_instance_;
class UsbUidPermissionProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbUidPermissionProto> _instance;
} _UsbUidPermissionProto_default_instance_;
class UsbDeviceFilterProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbDeviceFilterProto> _instance;
} _UsbDeviceFilterProto_default_instance_;
class UserPackageProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UserPackageProto> _instance;
} _UserPackageProto_default_instance_;
class UsbSettingsAccessoryPreferenceProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbSettingsAccessoryPreferenceProto> _instance;
} _UsbSettingsAccessoryPreferenceProto_default_instance_;
class UsbAccessoryFilterProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbAccessoryFilterProto> _instance;
} _UsbAccessoryFilterProto_default_instance_;
class UsbDeviceAttachedActivitiesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbDeviceAttachedActivities> _instance;
} _UsbDeviceAttachedActivities_default_instance_;
class UsbAccessoryAttachedActivitiesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbAccessoryAttachedActivities> _instance;
} _UsbAccessoryAttachedActivities_default_instance_;
}  // namespace usb
}  // namespace service
}  // namespace android
static void InitDefaultsscc_info_UsbAccessoryAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbAccessoryAttachedActivities_default_instance_;
    new (ptr) ::android::service::usb::UsbAccessoryAttachedActivities();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbAccessoryAttachedActivities::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbAccessoryAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_UsbAccessoryAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_ComponentNameProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fcontent_2fcomponent_5fname_2eproto.base,
      &scc_info_UsbAccessoryFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbAccessoryFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbAccessoryFilterProto_default_instance_;
    new (ptr) ::android::service::usb::UsbAccessoryFilterProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbAccessoryFilterProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbAccessoryFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbAccessoryFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbAccessoryPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbAccessoryPermissionProto_default_instance_;
    new (ptr) ::android::service::usb::UsbAccessoryPermissionProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbAccessoryPermissionProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbAccessoryPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbAccessoryPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbAccessoryPersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbAccessoryPersistentPermissionProto_default_instance_;
    new (ptr) ::android::service::usb::UsbAccessoryPersistentPermissionProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbAccessoryPersistentPermissionProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbAccessoryPersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_UsbAccessoryPersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbAccessoryFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbUidPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbAccessoryProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbAccessoryProto_default_instance_;
    new (ptr) ::android::service::usb::UsbAccessoryProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbAccessoryProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbAccessoryProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbAccessoryProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbAlsaDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbAlsaDeviceProto_default_instance_;
    new (ptr) ::android::service::usb::UsbAlsaDeviceProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbAlsaDeviceProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbAlsaDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbAlsaDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbAlsaManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbAlsaManagerProto_default_instance_;
    new (ptr) ::android::service::usb::UsbAlsaManagerProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbAlsaManagerProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbAlsaManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_UsbAlsaManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbAlsaDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbMidiDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbConfigurationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbConfigurationProto_default_instance_;
    new (ptr) ::android::service::usb::UsbConfigurationProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbConfigurationProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbConfigurationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_UsbConfigurationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbInterfaceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbConnectionRecordProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbConnectionRecordProto_default_instance_;
    new (ptr) ::android::service::usb::UsbConnectionRecordProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbConnectionRecordProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbConnectionRecordProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_UsbConnectionRecordProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbIsHeadsetProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbDebuggingManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbDebuggingManagerProto_default_instance_;
    new (ptr) ::android::service::usb::UsbDebuggingManagerProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbDebuggingManagerProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbDebuggingManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbDebuggingManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbDeviceAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbDeviceAttachedActivities_default_instance_;
    new (ptr) ::android::service::usb::UsbDeviceAttachedActivities();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbDeviceAttachedActivities::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbDeviceAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_UsbDeviceAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_ComponentNameProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fcontent_2fcomponent_5fname_2eproto.base,
      &scc_info_UsbDeviceFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbDeviceFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbDeviceFilterProto_default_instance_;
    new (ptr) ::android::service::usb::UsbDeviceFilterProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbDeviceFilterProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbDeviceFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbDeviceFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbDeviceManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbDeviceManagerProto_default_instance_;
    new (ptr) ::android::service::usb::UsbDeviceManagerProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbDeviceManagerProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbDeviceManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_UsbDeviceManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbHandlerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbDebuggingManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbDevicePermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbDevicePermissionProto_default_instance_;
    new (ptr) ::android::service::usb::UsbDevicePermissionProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbDevicePermissionProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbDevicePermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbDevicePermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbDevicePersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbDevicePersistentPermissionProto_default_instance_;
    new (ptr) ::android::service::usb::UsbDevicePersistentPermissionProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbDevicePersistentPermissionProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbDevicePersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_UsbDevicePersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbDeviceFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbUidPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbDeviceProto_default_instance_;
    new (ptr) ::android::service::usb::UsbDeviceProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbDeviceProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_UsbDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbConfigurationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbEndPointProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbEndPointProto_default_instance_;
    new (ptr) ::android::service::usb::UsbEndPointProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbEndPointProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbEndPointProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbEndPointProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbHandlerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbHandlerProto_default_instance_;
    new (ptr) ::android::service::usb::UsbHandlerProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbHandlerProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbHandlerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_UsbHandlerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbAccessoryProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbHostManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbHostManagerProto_default_instance_;
    new (ptr) ::android::service::usb::UsbHostManagerProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbHostManagerProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_UsbHostManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, InitDefaultsscc_info_UsbHostManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_ComponentNameProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fcontent_2fcomponent_5fname_2eproto.base,
      &scc_info_UsbDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbConnectionRecordProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbInterfaceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbInterfaceProto_default_instance_;
    new (ptr) ::android::service::usb::UsbInterfaceProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbInterfaceProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbInterfaceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_UsbInterfaceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbEndPointProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbIsHeadsetProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbIsHeadsetProto_default_instance_;
    new (ptr) ::android::service::usb::UsbIsHeadsetProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbIsHeadsetProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbIsHeadsetProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbIsHeadsetProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbMidiDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbMidiDeviceProto_default_instance_;
    new (ptr) ::android::service::usb::UsbMidiDeviceProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbMidiDeviceProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbMidiDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbMidiDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbPermissionsManagerProto_default_instance_;
    new (ptr) ::android::service::usb::UsbPermissionsManagerProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbPermissionsManagerProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_UsbPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbUserPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbPortInfoProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbPortInfoProto_default_instance_;
    new (ptr) ::android::service::usb::UsbPortInfoProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbPortInfoProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbPortInfoProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_UsbPortInfoProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbPortProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbPortStatusProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbPortManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbPortManagerProto_default_instance_;
    new (ptr) ::android::service::usb::UsbPortManagerProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbPortManagerProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbPortManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_UsbPortManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbPortInfoProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbPortProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbPortProto_default_instance_;
    new (ptr) ::android::service::usb::UsbPortProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbPortProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbPortProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbPortProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbPortStatusProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbPortStatusProto_default_instance_;
    new (ptr) ::android::service::usb::UsbPortStatusProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbPortStatusProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbPortStatusProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_UsbPortStatusProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbPortStatusRoleCombinationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbPortStatusRoleCombinationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbPortStatusRoleCombinationProto_default_instance_;
    new (ptr) ::android::service::usb::UsbPortStatusRoleCombinationProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbPortStatusRoleCombinationProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbPortStatusRoleCombinationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbPortStatusRoleCombinationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbProfileGroupSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbProfileGroupSettingsManagerProto_default_instance_;
    new (ptr) ::android::service::usb::UsbProfileGroupSettingsManagerProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbProfileGroupSettingsManagerProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbProfileGroupSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_UsbProfileGroupSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbSettingsDevicePreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbSettingsAccessoryPreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbServiceDumpProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbServiceDumpProto_default_instance_;
    new (ptr) ::android::service::usb::UsbServiceDumpProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbServiceDumpProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<6> scc_info_UsbServiceDumpProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 6, InitDefaultsscc_info_UsbServiceDumpProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbDeviceManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbHostManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbPortManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbAlsaManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbSettingsAccessoryPreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbSettingsAccessoryPreferenceProto_default_instance_;
    new (ptr) ::android::service::usb::UsbSettingsAccessoryPreferenceProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbSettingsAccessoryPreferenceProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbSettingsAccessoryPreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_UsbSettingsAccessoryPreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbAccessoryFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UserPackageProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbSettingsDevicePreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbSettingsDevicePreferenceProto_default_instance_;
    new (ptr) ::android::service::usb::UsbSettingsDevicePreferenceProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbSettingsDevicePreferenceProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbSettingsDevicePreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_UsbSettingsDevicePreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbDeviceFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UserPackageProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbSettingsManagerProto_default_instance_;
    new (ptr) ::android::service::usb::UsbSettingsManagerProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbSettingsManagerProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_UsbSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbUserSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbProfileGroupSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbUidPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbUidPermissionProto_default_instance_;
    new (ptr) ::android::service::usb::UsbUidPermissionProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbUidPermissionProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbUidPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbUidPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbUserPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbUserPermissionsManagerProto_default_instance_;
    new (ptr) ::android::service::usb::UsbUserPermissionsManagerProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbUserPermissionsManagerProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_UsbUserPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 4, InitDefaultsscc_info_UsbUserPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbDevicePermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbAccessoryPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbDevicePersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbAccessoryPersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbUserSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbUserSettingsManagerProto_default_instance_;
    new (ptr) ::android::service::usb::UsbUserSettingsManagerProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbUserSettingsManagerProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbUserSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_UsbUserSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbDeviceAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbAccessoryAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UserPackageProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UserPackageProto_default_instance_;
    new (ptr) ::android::service::usb::UserPackageProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UserPackageProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UserPackageProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UserPackageProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

namespace android {
namespace service {
namespace usb {
bool UsbHandlerProto_Function_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
    case 32:
    case 64:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UsbHandlerProto_Function_strings[7] = {};

static const char UsbHandlerProto_Function_names[] =
  "FUNCTION_ACCESSORY"
  "FUNCTION_ADB"
  "FUNCTION_AUDIO_SOURCE"
  "FUNCTION_MIDI"
  "FUNCTION_MTP"
  "FUNCTION_PTP"
  "FUNCTION_RNDIS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UsbHandlerProto_Function_entries[] = {
  { {UsbHandlerProto_Function_names + 0, 18}, 2 },
  { {UsbHandlerProto_Function_names + 18, 12}, 1 },
  { {UsbHandlerProto_Function_names + 30, 21}, 64 },
  { {UsbHandlerProto_Function_names + 51, 13}, 8 },
  { {UsbHandlerProto_Function_names + 64, 12}, 4 },
  { {UsbHandlerProto_Function_names + 76, 12}, 16 },
  { {UsbHandlerProto_Function_names + 88, 14}, 32 },
};

static const int UsbHandlerProto_Function_entries_by_number[] = {
  1, // 1 -> FUNCTION_ADB
  0, // 2 -> FUNCTION_ACCESSORY
  4, // 4 -> FUNCTION_MTP
  3, // 8 -> FUNCTION_MIDI
  5, // 16 -> FUNCTION_PTP
  6, // 32 -> FUNCTION_RNDIS
  2, // 64 -> FUNCTION_AUDIO_SOURCE
};

const std::string& UsbHandlerProto_Function_Name(
    UsbHandlerProto_Function value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UsbHandlerProto_Function_entries,
          UsbHandlerProto_Function_entries_by_number,
          7, UsbHandlerProto_Function_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UsbHandlerProto_Function_entries,
      UsbHandlerProto_Function_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UsbHandlerProto_Function_strings[idx].get();
}
bool UsbHandlerProto_Function_Parse(
    const std::string& name, UsbHandlerProto_Function* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UsbHandlerProto_Function_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<UsbHandlerProto_Function>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr UsbHandlerProto_Function UsbHandlerProto::FUNCTION_ADB;
constexpr UsbHandlerProto_Function UsbHandlerProto::FUNCTION_ACCESSORY;
constexpr UsbHandlerProto_Function UsbHandlerProto::FUNCTION_MTP;
constexpr UsbHandlerProto_Function UsbHandlerProto::FUNCTION_MIDI;
constexpr UsbHandlerProto_Function UsbHandlerProto::FUNCTION_PTP;
constexpr UsbHandlerProto_Function UsbHandlerProto::FUNCTION_RNDIS;
constexpr UsbHandlerProto_Function UsbHandlerProto::FUNCTION_AUDIO_SOURCE;
constexpr UsbHandlerProto_Function UsbHandlerProto::Function_MIN;
constexpr UsbHandlerProto_Function UsbHandlerProto::Function_MAX;
constexpr int UsbHandlerProto::Function_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool UsbPortProto_Mode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 8:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UsbPortProto_Mode_strings[6] = {};

static const char UsbPortProto_Mode_names[] =
  "MODE_AUDIO_ACCESSORY"
  "MODE_DEBUG_ACCESSORY"
  "MODE_DFP"
  "MODE_DRP"
  "MODE_NONE"
  "MODE_UFP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UsbPortProto_Mode_entries[] = {
  { {UsbPortProto_Mode_names + 0, 20}, 4 },
  { {UsbPortProto_Mode_names + 20, 20}, 8 },
  { {UsbPortProto_Mode_names + 40, 8}, 2 },
  { {UsbPortProto_Mode_names + 48, 8}, 3 },
  { {UsbPortProto_Mode_names + 56, 9}, 0 },
  { {UsbPortProto_Mode_names + 65, 8}, 1 },
};

static const int UsbPortProto_Mode_entries_by_number[] = {
  4, // 0 -> MODE_NONE
  5, // 1 -> MODE_UFP
  2, // 2 -> MODE_DFP
  3, // 3 -> MODE_DRP
  0, // 4 -> MODE_AUDIO_ACCESSORY
  1, // 8 -> MODE_DEBUG_ACCESSORY
};

const std::string& UsbPortProto_Mode_Name(
    UsbPortProto_Mode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UsbPortProto_Mode_entries,
          UsbPortProto_Mode_entries_by_number,
          6, UsbPortProto_Mode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UsbPortProto_Mode_entries,
      UsbPortProto_Mode_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UsbPortProto_Mode_strings[idx].get();
}
bool UsbPortProto_Mode_Parse(
    const std::string& name, UsbPortProto_Mode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UsbPortProto_Mode_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<UsbPortProto_Mode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr UsbPortProto_Mode UsbPortProto::MODE_NONE;
constexpr UsbPortProto_Mode UsbPortProto::MODE_UFP;
constexpr UsbPortProto_Mode UsbPortProto::MODE_DFP;
constexpr UsbPortProto_Mode UsbPortProto::MODE_DRP;
constexpr UsbPortProto_Mode UsbPortProto::MODE_AUDIO_ACCESSORY;
constexpr UsbPortProto_Mode UsbPortProto::MODE_DEBUG_ACCESSORY;
constexpr UsbPortProto_Mode UsbPortProto::Mode_MIN;
constexpr UsbPortProto_Mode UsbPortProto::Mode_MAX;
constexpr int UsbPortProto::Mode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool UsbPortStatusProto_PowerRole_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UsbPortStatusProto_PowerRole_strings[3] = {};

static const char UsbPortStatusProto_PowerRole_names[] =
  "POWER_ROLE_NONE"
  "POWER_ROLE_SINK"
  "POWER_ROLE_SOURCE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UsbPortStatusProto_PowerRole_entries[] = {
  { {UsbPortStatusProto_PowerRole_names + 0, 15}, 0 },
  { {UsbPortStatusProto_PowerRole_names + 15, 15}, 2 },
  { {UsbPortStatusProto_PowerRole_names + 30, 17}, 1 },
};

static const int UsbPortStatusProto_PowerRole_entries_by_number[] = {
  0, // 0 -> POWER_ROLE_NONE
  2, // 1 -> POWER_ROLE_SOURCE
  1, // 2 -> POWER_ROLE_SINK
};

const std::string& UsbPortStatusProto_PowerRole_Name(
    UsbPortStatusProto_PowerRole value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UsbPortStatusProto_PowerRole_entries,
          UsbPortStatusProto_PowerRole_entries_by_number,
          3, UsbPortStatusProto_PowerRole_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UsbPortStatusProto_PowerRole_entries,
      UsbPortStatusProto_PowerRole_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UsbPortStatusProto_PowerRole_strings[idx].get();
}
bool UsbPortStatusProto_PowerRole_Parse(
    const std::string& name, UsbPortStatusProto_PowerRole* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UsbPortStatusProto_PowerRole_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<UsbPortStatusProto_PowerRole>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr UsbPortStatusProto_PowerRole UsbPortStatusProto::POWER_ROLE_NONE;
constexpr UsbPortStatusProto_PowerRole UsbPortStatusProto::POWER_ROLE_SOURCE;
constexpr UsbPortStatusProto_PowerRole UsbPortStatusProto::POWER_ROLE_SINK;
constexpr UsbPortStatusProto_PowerRole UsbPortStatusProto::PowerRole_MIN;
constexpr UsbPortStatusProto_PowerRole UsbPortStatusProto::PowerRole_MAX;
constexpr int UsbPortStatusProto::PowerRole_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool UsbPortStatusProto_DataRole_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UsbPortStatusProto_DataRole_strings[3] = {};

static const char UsbPortStatusProto_DataRole_names[] =
  "DATA_ROLE_DEVICE"
  "DATA_ROLE_HOST"
  "DATA_ROLE_NONE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UsbPortStatusProto_DataRole_entries[] = {
  { {UsbPortStatusProto_DataRole_names + 0, 16}, 2 },
  { {UsbPortStatusProto_DataRole_names + 16, 14}, 1 },
  { {UsbPortStatusProto_DataRole_names + 30, 14}, 0 },
};

static const int UsbPortStatusProto_DataRole_entries_by_number[] = {
  2, // 0 -> DATA_ROLE_NONE
  1, // 1 -> DATA_ROLE_HOST
  0, // 2 -> DATA_ROLE_DEVICE
};

const std::string& UsbPortStatusProto_DataRole_Name(
    UsbPortStatusProto_DataRole value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UsbPortStatusProto_DataRole_entries,
          UsbPortStatusProto_DataRole_entries_by_number,
          3, UsbPortStatusProto_DataRole_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UsbPortStatusProto_DataRole_entries,
      UsbPortStatusProto_DataRole_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UsbPortStatusProto_DataRole_strings[idx].get();
}
bool UsbPortStatusProto_DataRole_Parse(
    const std::string& name, UsbPortStatusProto_DataRole* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UsbPortStatusProto_DataRole_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<UsbPortStatusProto_DataRole>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr UsbPortStatusProto_DataRole UsbPortStatusProto::DATA_ROLE_NONE;
constexpr UsbPortStatusProto_DataRole UsbPortStatusProto::DATA_ROLE_HOST;
constexpr UsbPortStatusProto_DataRole UsbPortStatusProto::DATA_ROLE_DEVICE;
constexpr UsbPortStatusProto_DataRole UsbPortStatusProto::DataRole_MIN;
constexpr UsbPortStatusProto_DataRole UsbPortStatusProto::DataRole_MAX;
constexpr int UsbPortStatusProto::DataRole_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void UsbServiceDumpProto::InitAsDefaultInstance() {
  ::android::service::usb::_UsbServiceDumpProto_default_instance_._instance.get_mutable()->device_manager_ = const_cast< ::android::service::usb::UsbDeviceManagerProto*>(
      ::android::service::usb::UsbDeviceManagerProto::internal_default_instance());
  ::android::service::usb::_UsbServiceDumpProto_default_instance_._instance.get_mutable()->host_manager_ = const_cast< ::android::service::usb::UsbHostManagerProto*>(
      ::android::service::usb::UsbHostManagerProto::internal_default_instance());
  ::android::service::usb::_UsbServiceDumpProto_default_instance_._instance.get_mutable()->port_manager_ = const_cast< ::android::service::usb::UsbPortManagerProto*>(
      ::android::service::usb::UsbPortManagerProto::internal_default_instance());
  ::android::service::usb::_UsbServiceDumpProto_default_instance_._instance.get_mutable()->alsa_manager_ = const_cast< ::android::service::usb::UsbAlsaManagerProto*>(
      ::android::service::usb::UsbAlsaManagerProto::internal_default_instance());
  ::android::service::usb::_UsbServiceDumpProto_default_instance_._instance.get_mutable()->settings_manager_ = const_cast< ::android::service::usb::UsbSettingsManagerProto*>(
      ::android::service::usb::UsbSettingsManagerProto::internal_default_instance());
  ::android::service::usb::_UsbServiceDumpProto_default_instance_._instance.get_mutable()->permissions_manager_ = const_cast< ::android::service::usb::UsbPermissionsManagerProto*>(
      ::android::service::usb::UsbPermissionsManagerProto::internal_default_instance());
}
class UsbServiceDumpProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbServiceDumpProto>()._has_bits_);
  static const ::android::service::usb::UsbDeviceManagerProto& device_manager(const UsbServiceDumpProto* msg);
  static void set_has_device_manager(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::android::service::usb::UsbHostManagerProto& host_manager(const UsbServiceDumpProto* msg);
  static void set_has_host_manager(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::android::service::usb::UsbPortManagerProto& port_manager(const UsbServiceDumpProto* msg);
  static void set_has_port_manager(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::android::service::usb::UsbAlsaManagerProto& alsa_manager(const UsbServiceDumpProto* msg);
  static void set_has_alsa_manager(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::android::service::usb::UsbSettingsManagerProto& settings_manager(const UsbServiceDumpProto* msg);
  static void set_has_settings_manager(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::android::service::usb::UsbPermissionsManagerProto& permissions_manager(const UsbServiceDumpProto* msg);
  static void set_has_permissions_manager(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::android::service::usb::UsbDeviceManagerProto&
UsbServiceDumpProto::_Internal::device_manager(const UsbServiceDumpProto* msg) {
  return *msg->device_manager_;
}
const ::android::service::usb::UsbHostManagerProto&
UsbServiceDumpProto::_Internal::host_manager(const UsbServiceDumpProto* msg) {
  return *msg->host_manager_;
}
const ::android::service::usb::UsbPortManagerProto&
UsbServiceDumpProto::_Internal::port_manager(const UsbServiceDumpProto* msg) {
  return *msg->port_manager_;
}
const ::android::service::usb::UsbAlsaManagerProto&
UsbServiceDumpProto::_Internal::alsa_manager(const UsbServiceDumpProto* msg) {
  return *msg->alsa_manager_;
}
const ::android::service::usb::UsbSettingsManagerProto&
UsbServiceDumpProto::_Internal::settings_manager(const UsbServiceDumpProto* msg) {
  return *msg->settings_manager_;
}
const ::android::service::usb::UsbPermissionsManagerProto&
UsbServiceDumpProto::_Internal::permissions_manager(const UsbServiceDumpProto* msg) {
  return *msg->permissions_manager_;
}
UsbServiceDumpProto::UsbServiceDumpProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbServiceDumpProto)
}
UsbServiceDumpProto::UsbServiceDumpProto(const UsbServiceDumpProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_device_manager()) {
    device_manager_ = new ::android::service::usb::UsbDeviceManagerProto(*from.device_manager_);
  } else {
    device_manager_ = nullptr;
  }
  if (from.has_host_manager()) {
    host_manager_ = new ::android::service::usb::UsbHostManagerProto(*from.host_manager_);
  } else {
    host_manager_ = nullptr;
  }
  if (from.has_port_manager()) {
    port_manager_ = new ::android::service::usb::UsbPortManagerProto(*from.port_manager_);
  } else {
    port_manager_ = nullptr;
  }
  if (from.has_alsa_manager()) {
    alsa_manager_ = new ::android::service::usb::UsbAlsaManagerProto(*from.alsa_manager_);
  } else {
    alsa_manager_ = nullptr;
  }
  if (from.has_settings_manager()) {
    settings_manager_ = new ::android::service::usb::UsbSettingsManagerProto(*from.settings_manager_);
  } else {
    settings_manager_ = nullptr;
  }
  if (from.has_permissions_manager()) {
    permissions_manager_ = new ::android::service::usb::UsbPermissionsManagerProto(*from.permissions_manager_);
  } else {
    permissions_manager_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbServiceDumpProto)
}

void UsbServiceDumpProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbServiceDumpProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  ::memset(&device_manager_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&permissions_manager_) -
      reinterpret_cast<char*>(&device_manager_)) + sizeof(permissions_manager_));
}

UsbServiceDumpProto::~UsbServiceDumpProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbServiceDumpProto)
  SharedDtor();
}

void UsbServiceDumpProto::SharedDtor() {
  if (this != internal_default_instance()) delete device_manager_;
  if (this != internal_default_instance()) delete host_manager_;
  if (this != internal_default_instance()) delete port_manager_;
  if (this != internal_default_instance()) delete alsa_manager_;
  if (this != internal_default_instance()) delete settings_manager_;
  if (this != internal_default_instance()) delete permissions_manager_;
}

void UsbServiceDumpProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbServiceDumpProto& UsbServiceDumpProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbServiceDumpProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbServiceDumpProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbServiceDumpProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(device_manager_ != nullptr);
      device_manager_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(host_manager_ != nullptr);
      host_manager_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(port_manager_ != nullptr);
      port_manager_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(alsa_manager_ != nullptr);
      alsa_manager_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(settings_manager_ != nullptr);
      settings_manager_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(permissions_manager_ != nullptr);
      permissions_manager_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbServiceDumpProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .android.service.usb.UsbDeviceManagerProto device_manager = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_device_manager(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbHostManagerProto host_manager = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_host_manager(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbPortManagerProto port_manager = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_port_manager(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbAlsaManagerProto alsa_manager = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(mutable_alsa_manager(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbSettingsManagerProto settings_manager = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(mutable_settings_manager(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbPermissionsManagerProto permissions_manager = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(mutable_permissions_manager(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbServiceDumpProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbServiceDumpProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .android.service.usb.UsbDeviceManagerProto device_manager = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_device_manager()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbHostManagerProto host_manager = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_host_manager()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbPortManagerProto port_manager = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_port_manager()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbAlsaManagerProto alsa_manager = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_alsa_manager()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbSettingsManagerProto settings_manager = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_settings_manager()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbPermissionsManagerProto permissions_manager = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_permissions_manager()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbServiceDumpProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbServiceDumpProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbServiceDumpProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbServiceDumpProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.service.usb.UsbDeviceManagerProto device_manager = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1, _Internal::device_manager(this), output);
  }

  // optional .android.service.usb.UsbHostManagerProto host_manager = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2, _Internal::host_manager(this), output);
  }

  // optional .android.service.usb.UsbPortManagerProto port_manager = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      3, _Internal::port_manager(this), output);
  }

  // optional .android.service.usb.UsbAlsaManagerProto alsa_manager = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      4, _Internal::alsa_manager(this), output);
  }

  // optional .android.service.usb.UsbSettingsManagerProto settings_manager = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      5, _Internal::settings_manager(this), output);
  }

  // optional .android.service.usb.UsbPermissionsManagerProto permissions_manager = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      6, _Internal::permissions_manager(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbServiceDumpProto)
}

size_t UsbServiceDumpProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbServiceDumpProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .android.service.usb.UsbDeviceManagerProto device_manager = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *device_manager_);
    }

    // optional .android.service.usb.UsbHostManagerProto host_manager = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *host_manager_);
    }

    // optional .android.service.usb.UsbPortManagerProto port_manager = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *port_manager_);
    }

    // optional .android.service.usb.UsbAlsaManagerProto alsa_manager = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *alsa_manager_);
    }

    // optional .android.service.usb.UsbSettingsManagerProto settings_manager = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *settings_manager_);
    }

    // optional .android.service.usb.UsbPermissionsManagerProto permissions_manager = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *permissions_manager_);
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbServiceDumpProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbServiceDumpProto*>(
      &from));
}

void UsbServiceDumpProto::MergeFrom(const UsbServiceDumpProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbServiceDumpProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_device_manager()->::android::service::usb::UsbDeviceManagerProto::MergeFrom(from.device_manager());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_host_manager()->::android::service::usb::UsbHostManagerProto::MergeFrom(from.host_manager());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_port_manager()->::android::service::usb::UsbPortManagerProto::MergeFrom(from.port_manager());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_alsa_manager()->::android::service::usb::UsbAlsaManagerProto::MergeFrom(from.alsa_manager());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_settings_manager()->::android::service::usb::UsbSettingsManagerProto::MergeFrom(from.settings_manager());
    }
    if (cached_has_bits & 0x00000020u) {
      mutable_permissions_manager()->::android::service::usb::UsbPermissionsManagerProto::MergeFrom(from.permissions_manager());
    }
  }
}

void UsbServiceDumpProto::CopyFrom(const UsbServiceDumpProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbServiceDumpProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbServiceDumpProto::IsInitialized() const {
  return true;
}

void UsbServiceDumpProto::InternalSwap(UsbServiceDumpProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(device_manager_, other->device_manager_);
  swap(host_manager_, other->host_manager_);
  swap(port_manager_, other->port_manager_);
  swap(alsa_manager_, other->alsa_manager_);
  swap(settings_manager_, other->settings_manager_);
  swap(permissions_manager_, other->permissions_manager_);
}

std::string UsbServiceDumpProto::GetTypeName() const {
  return "android.service.usb.UsbServiceDumpProto";
}


// ===================================================================

void UsbDeviceManagerProto::InitAsDefaultInstance() {
  ::android::service::usb::_UsbDeviceManagerProto_default_instance_._instance.get_mutable()->handler_ = const_cast< ::android::service::usb::UsbHandlerProto*>(
      ::android::service::usb::UsbHandlerProto::internal_default_instance());
  ::android::service::usb::_UsbDeviceManagerProto_default_instance_._instance.get_mutable()->debugging_manager_ = const_cast< ::android::service::usb::UsbDebuggingManagerProto*>(
      ::android::service::usb::UsbDebuggingManagerProto::internal_default_instance());
}
class UsbDeviceManagerProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbDeviceManagerProto>()._has_bits_);
  static const ::android::service::usb::UsbHandlerProto& handler(const UsbDeviceManagerProto* msg);
  static void set_has_handler(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::android::service::usb::UsbDebuggingManagerProto& debugging_manager(const UsbDeviceManagerProto* msg);
  static void set_has_debugging_manager(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::android::service::usb::UsbHandlerProto&
UsbDeviceManagerProto::_Internal::handler(const UsbDeviceManagerProto* msg) {
  return *msg->handler_;
}
const ::android::service::usb::UsbDebuggingManagerProto&
UsbDeviceManagerProto::_Internal::debugging_manager(const UsbDeviceManagerProto* msg) {
  return *msg->debugging_manager_;
}
UsbDeviceManagerProto::UsbDeviceManagerProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbDeviceManagerProto)
}
UsbDeviceManagerProto::UsbDeviceManagerProto(const UsbDeviceManagerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_handler()) {
    handler_ = new ::android::service::usb::UsbHandlerProto(*from.handler_);
  } else {
    handler_ = nullptr;
  }
  if (from.has_debugging_manager()) {
    debugging_manager_ = new ::android::service::usb::UsbDebuggingManagerProto(*from.debugging_manager_);
  } else {
    debugging_manager_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbDeviceManagerProto)
}

void UsbDeviceManagerProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbDeviceManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  ::memset(&handler_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&debugging_manager_) -
      reinterpret_cast<char*>(&handler_)) + sizeof(debugging_manager_));
}

UsbDeviceManagerProto::~UsbDeviceManagerProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbDeviceManagerProto)
  SharedDtor();
}

void UsbDeviceManagerProto::SharedDtor() {
  if (this != internal_default_instance()) delete handler_;
  if (this != internal_default_instance()) delete debugging_manager_;
}

void UsbDeviceManagerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbDeviceManagerProto& UsbDeviceManagerProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbDeviceManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbDeviceManagerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbDeviceManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(handler_ != nullptr);
      handler_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(debugging_manager_ != nullptr);
      debugging_manager_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbDeviceManagerProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .android.service.usb.UsbHandlerProto handler = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_handler(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbDebuggingManagerProto debugging_manager = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_debugging_manager(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbDeviceManagerProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbDeviceManagerProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .android.service.usb.UsbHandlerProto handler = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_handler()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbDebuggingManagerProto debugging_manager = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_debugging_manager()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbDeviceManagerProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbDeviceManagerProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbDeviceManagerProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbDeviceManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.service.usb.UsbHandlerProto handler = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1, _Internal::handler(this), output);
  }

  // optional .android.service.usb.UsbDebuggingManagerProto debugging_manager = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2, _Internal::debugging_manager(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbDeviceManagerProto)
}

size_t UsbDeviceManagerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbDeviceManagerProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .android.service.usb.UsbHandlerProto handler = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *handler_);
    }

    // optional .android.service.usb.UsbDebuggingManagerProto debugging_manager = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *debugging_manager_);
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbDeviceManagerProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbDeviceManagerProto*>(
      &from));
}

void UsbDeviceManagerProto::MergeFrom(const UsbDeviceManagerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbDeviceManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_handler()->::android::service::usb::UsbHandlerProto::MergeFrom(from.handler());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_debugging_manager()->::android::service::usb::UsbDebuggingManagerProto::MergeFrom(from.debugging_manager());
    }
  }
}

void UsbDeviceManagerProto::CopyFrom(const UsbDeviceManagerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbDeviceManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbDeviceManagerProto::IsInitialized() const {
  return true;
}

void UsbDeviceManagerProto::InternalSwap(UsbDeviceManagerProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(handler_, other->handler_);
  swap(debugging_manager_, other->debugging_manager_);
}

std::string UsbDeviceManagerProto::GetTypeName() const {
  return "android.service.usb.UsbDeviceManagerProto";
}


// ===================================================================

void UsbHandlerProto::InitAsDefaultInstance() {
  ::android::service::usb::_UsbHandlerProto_default_instance_._instance.get_mutable()->current_accessory_ = const_cast< ::android::service::usb::UsbAccessoryProto*>(
      ::android::service::usb::UsbAccessoryProto::internal_default_instance());
}
class UsbHandlerProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbHandlerProto>()._has_bits_);
  static void set_has_current_functions_applied(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_screen_locked(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_connected(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_configured(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::android::service::usb::UsbAccessoryProto& current_accessory(const UsbHandlerProto* msg);
  static void set_has_current_accessory(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_host_connected(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_source_power(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_sink_power(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_usb_charging(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_hide_usb_notification(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_audio_accessory_connected(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_adb_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_kernel_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_kernel_function_list(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::android::service::usb::UsbAccessoryProto&
UsbHandlerProto::_Internal::current_accessory(const UsbHandlerProto* msg) {
  return *msg->current_accessory_;
}
UsbHandlerProto::UsbHandlerProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbHandlerProto)
}
UsbHandlerProto::UsbHandlerProto(const UsbHandlerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      current_functions_(from.current_functions_),
      screen_unlocked_functions_(from.screen_unlocked_functions_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  kernel_state_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_kernel_state()) {
    kernel_state_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.kernel_state_);
  }
  kernel_function_list_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_kernel_function_list()) {
    kernel_function_list_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.kernel_function_list_);
  }
  if (from.has_current_accessory()) {
    current_accessory_ = new ::android::service::usb::UsbAccessoryProto(*from.current_accessory_);
  } else {
    current_accessory_ = nullptr;
  }
  ::memcpy(&current_functions_applied_, &from.current_functions_applied_,
    static_cast<size_t>(reinterpret_cast<char*>(&adb_enabled_) -
    reinterpret_cast<char*>(&current_functions_applied_)) + sizeof(adb_enabled_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbHandlerProto)
}

void UsbHandlerProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbHandlerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  kernel_state_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  kernel_function_list_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&current_accessory_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&adb_enabled_) -
      reinterpret_cast<char*>(&current_accessory_)) + sizeof(adb_enabled_));
}

UsbHandlerProto::~UsbHandlerProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbHandlerProto)
  SharedDtor();
}

void UsbHandlerProto::SharedDtor() {
  kernel_state_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  kernel_function_list_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete current_accessory_;
}

void UsbHandlerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbHandlerProto& UsbHandlerProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbHandlerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbHandlerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbHandlerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  current_functions_.Clear();
  screen_unlocked_functions_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      kernel_state_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      kernel_function_list_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(current_accessory_ != nullptr);
      current_accessory_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&current_functions_applied_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&host_connected_) -
        reinterpret_cast<char*>(&current_functions_applied_)) + sizeof(host_connected_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&source_power_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&adb_enabled_) -
        reinterpret_cast<char*>(&source_power_)) + sizeof(adb_enabled_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbHandlerProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .android.service.usb.UsbHandlerProto.Function current_functions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::android::service::usb::UsbHandlerProto_Function_IsValid(val))) {
              add_current_functions(static_cast<::android::service::usb::UsbHandlerProto_Function>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 8);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(mutable_current_functions(), ptr, ctx, ::android::service::usb::UsbHandlerProto_Function_IsValid, &_internal_metadata_, 1);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool current_functions_applied = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_current_functions_applied(&has_bits);
          current_functions_applied_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbHandlerProto.Function screen_unlocked_functions = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::android::service::usb::UsbHandlerProto_Function_IsValid(val))) {
              add_screen_unlocked_functions(static_cast<::android::service::usb::UsbHandlerProto_Function>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 24);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(mutable_screen_unlocked_functions(), ptr, ctx, ::android::service::usb::UsbHandlerProto_Function_IsValid, &_internal_metadata_, 3);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool screen_locked = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_screen_locked(&has_bits);
          screen_locked_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool connected = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_connected(&has_bits);
          connected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool configured = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_configured(&has_bits);
          configured_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbAccessoryProto current_accessory = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(mutable_current_accessory(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool host_connected = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_host_connected(&has_bits);
          host_connected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool source_power = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_source_power(&has_bits);
          source_power_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool sink_power = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_sink_power(&has_bits);
          sink_power_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool usb_charging = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_usb_charging(&has_bits);
          usb_charging_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool hide_usb_notification = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_hide_usb_notification(&has_bits);
          hide_usb_notification_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool audio_accessory_connected = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_audio_accessory_connected(&has_bits);
          audio_accessory_connected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool adb_enabled = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_adb_enabled(&has_bits);
          adb_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string kernel_state = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 122)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_kernel_state(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string kernel_function_list = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 130)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_kernel_function_list(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbHandlerProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbHandlerProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .android.service.usb.UsbHandlerProto.Function current_functions = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::service::usb::UsbHandlerProto_Function_IsValid(value)) {
            add_current_functions(static_cast< ::android::service::usb::UsbHandlerProto_Function >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                 input,
                 1,
                 ::android::service::usb::UsbHandlerProto_Function_IsValid,
                 &unknown_fields_stream,
                 this->mutable_current_functions())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool current_functions_applied = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_current_functions_applied(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &current_functions_applied_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbHandlerProto.Function screen_unlocked_functions = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::service::usb::UsbHandlerProto_Function_IsValid(value)) {
            add_screen_unlocked_functions(static_cast< ::android::service::usb::UsbHandlerProto_Function >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                 input,
                 3,
                 ::android::service::usb::UsbHandlerProto_Function_IsValid,
                 &unknown_fields_stream,
                 this->mutable_screen_unlocked_functions())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool screen_locked = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_screen_locked(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &screen_locked_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool connected = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_connected(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &connected_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool configured = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_configured(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &configured_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbAccessoryProto current_accessory = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (58 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_current_accessory()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool host_connected = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          _Internal::set_has_host_connected(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &host_connected_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool source_power = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          _Internal::set_has_source_power(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &source_power_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool sink_power = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (80 & 0xFF)) {
          _Internal::set_has_sink_power(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &sink_power_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool usb_charging = 11;
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (88 & 0xFF)) {
          _Internal::set_has_usb_charging(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &usb_charging_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool hide_usb_notification = 12;
      case 12: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (96 & 0xFF)) {
          _Internal::set_has_hide_usb_notification(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &hide_usb_notification_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool audio_accessory_connected = 13;
      case 13: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (104 & 0xFF)) {
          _Internal::set_has_audio_accessory_connected(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &audio_accessory_connected_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool adb_enabled = 14;
      case 14: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (112 & 0xFF)) {
          _Internal::set_has_adb_enabled(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &adb_enabled_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string kernel_state = 15;
      case 15: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (122 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_kernel_state()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string kernel_function_list = 16;
      case 16: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (130 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_kernel_function_list()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbHandlerProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbHandlerProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbHandlerProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbHandlerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbHandlerProto.Function current_functions = 1;
  for (int i = 0, n = this->current_functions_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->current_functions(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool current_functions_applied = 2;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(2, this->current_functions_applied(), output);
  }

  // repeated .android.service.usb.UsbHandlerProto.Function screen_unlocked_functions = 3;
  for (int i = 0, n = this->screen_unlocked_functions_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      3, this->screen_unlocked_functions(i), output);
  }

  // optional bool screen_locked = 4;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(4, this->screen_locked(), output);
  }

  // optional bool connected = 5;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(5, this->connected(), output);
  }

  // optional bool configured = 6;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(6, this->configured(), output);
  }

  // optional .android.service.usb.UsbAccessoryProto current_accessory = 7;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      7, _Internal::current_accessory(this), output);
  }

  // optional bool host_connected = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(8, this->host_connected(), output);
  }

  // optional bool source_power = 9;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(9, this->source_power(), output);
  }

  // optional bool sink_power = 10;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(10, this->sink_power(), output);
  }

  // optional bool usb_charging = 11;
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(11, this->usb_charging(), output);
  }

  // optional bool hide_usb_notification = 12;
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(12, this->hide_usb_notification(), output);
  }

  // optional bool audio_accessory_connected = 13;
  if (cached_has_bits & 0x00001000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(13, this->audio_accessory_connected(), output);
  }

  // optional bool adb_enabled = 14;
  if (cached_has_bits & 0x00002000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(14, this->adb_enabled(), output);
  }

  // optional string kernel_state = 15;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      15, this->kernel_state(), output);
  }

  // optional string kernel_function_list = 16;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      16, this->kernel_function_list(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbHandlerProto)
}

size_t UsbHandlerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbHandlerProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbHandlerProto.Function current_functions = 1;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->current_functions_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->current_functions(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .android.service.usb.UsbHandlerProto.Function screen_unlocked_functions = 3;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->screen_unlocked_functions_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->screen_unlocked_functions(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string kernel_state = 15;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->kernel_state());
    }

    // optional string kernel_function_list = 16;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->kernel_function_list());
    }

    // optional .android.service.usb.UsbAccessoryProto current_accessory = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *current_accessory_);
    }

    // optional bool current_functions_applied = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool screen_locked = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool connected = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool configured = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool host_connected = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional bool source_power = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool sink_power = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool usb_charging = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool hide_usb_notification = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool audio_accessory_connected = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool adb_enabled = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbHandlerProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbHandlerProto*>(
      &from));
}

void UsbHandlerProto::MergeFrom(const UsbHandlerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbHandlerProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  current_functions_.MergeFrom(from.current_functions_);
  screen_unlocked_functions_.MergeFrom(from.screen_unlocked_functions_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      kernel_state_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.kernel_state_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      kernel_function_list_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.kernel_function_list_);
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_current_accessory()->::android::service::usb::UsbAccessoryProto::MergeFrom(from.current_accessory());
    }
    if (cached_has_bits & 0x00000008u) {
      current_functions_applied_ = from.current_functions_applied_;
    }
    if (cached_has_bits & 0x00000010u) {
      screen_locked_ = from.screen_locked_;
    }
    if (cached_has_bits & 0x00000020u) {
      connected_ = from.connected_;
    }
    if (cached_has_bits & 0x00000040u) {
      configured_ = from.configured_;
    }
    if (cached_has_bits & 0x00000080u) {
      host_connected_ = from.host_connected_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      source_power_ = from.source_power_;
    }
    if (cached_has_bits & 0x00000200u) {
      sink_power_ = from.sink_power_;
    }
    if (cached_has_bits & 0x00000400u) {
      usb_charging_ = from.usb_charging_;
    }
    if (cached_has_bits & 0x00000800u) {
      hide_usb_notification_ = from.hide_usb_notification_;
    }
    if (cached_has_bits & 0x00001000u) {
      audio_accessory_connected_ = from.audio_accessory_connected_;
    }
    if (cached_has_bits & 0x00002000u) {
      adb_enabled_ = from.adb_enabled_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbHandlerProto::CopyFrom(const UsbHandlerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbHandlerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbHandlerProto::IsInitialized() const {
  return true;
}

void UsbHandlerProto::InternalSwap(UsbHandlerProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  current_functions_.InternalSwap(&other->current_functions_);
  screen_unlocked_functions_.InternalSwap(&other->screen_unlocked_functions_);
  kernel_state_.Swap(&other->kernel_state_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  kernel_function_list_.Swap(&other->kernel_function_list_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(current_accessory_, other->current_accessory_);
  swap(current_functions_applied_, other->current_functions_applied_);
  swap(screen_locked_, other->screen_locked_);
  swap(connected_, other->connected_);
  swap(configured_, other->configured_);
  swap(host_connected_, other->host_connected_);
  swap(source_power_, other->source_power_);
  swap(sink_power_, other->sink_power_);
  swap(usb_charging_, other->usb_charging_);
  swap(hide_usb_notification_, other->hide_usb_notification_);
  swap(audio_accessory_connected_, other->audio_accessory_connected_);
  swap(adb_enabled_, other->adb_enabled_);
}

std::string UsbHandlerProto::GetTypeName() const {
  return "android.service.usb.UsbHandlerProto";
}


// ===================================================================

void UsbAccessoryProto::InitAsDefaultInstance() {
}
class UsbAccessoryProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbAccessoryProto>()._has_bits_);
  static void set_has_manufacturer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_model(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_uri(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_serial(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

UsbAccessoryProto::UsbAccessoryProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbAccessoryProto)
}
UsbAccessoryProto::UsbAccessoryProto(const UsbAccessoryProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  manufacturer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_manufacturer()) {
    manufacturer_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.manufacturer_);
  }
  model_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_model()) {
    model_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.model_);
  }
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_description()) {
    description_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.description_);
  }
  version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_version()) {
    version_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.version_);
  }
  uri_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_uri()) {
    uri_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.uri_);
  }
  serial_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_serial()) {
    serial_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.serial_);
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbAccessoryProto)
}

void UsbAccessoryProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbAccessoryProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  manufacturer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  model_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  uri_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  serial_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

UsbAccessoryProto::~UsbAccessoryProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbAccessoryProto)
  SharedDtor();
}

void UsbAccessoryProto::SharedDtor() {
  manufacturer_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  model_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  uri_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  serial_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UsbAccessoryProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbAccessoryProto& UsbAccessoryProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbAccessoryProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbAccessoryProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbAccessoryProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      manufacturer_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      model_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      description_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      version_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      uri_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000020u) {
      serial_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbAccessoryProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string manufacturer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_manufacturer(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string model = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_model(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string description = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_description(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string version = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_version(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string uri = 5 [(.android.privacy) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_uri(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string serial = 6 [(.android.privacy) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_serial(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbAccessoryProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbAccessoryProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string manufacturer = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_manufacturer()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string model = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_model()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string description = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string version = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string uri = 5 [(.android.privacy) = {
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_uri()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string serial = 6 [(.android.privacy) = {
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_serial()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbAccessoryProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbAccessoryProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbAccessoryProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbAccessoryProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string manufacturer = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->manufacturer(), output);
  }

  // optional string model = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->model(), output);
  }

  // optional string description = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->description(), output);
  }

  // optional string version = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->version(), output);
  }

  // optional string uri = 5 [(.android.privacy) = {
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->uri(), output);
  }

  // optional string serial = 6 [(.android.privacy) = {
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->serial(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbAccessoryProto)
}

size_t UsbAccessoryProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbAccessoryProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string manufacturer = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->manufacturer());
    }

    // optional string model = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->model());
    }

    // optional string description = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->description());
    }

    // optional string version = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional string uri = 5 [(.android.privacy) = {
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->uri());
    }

    // optional string serial = 6 [(.android.privacy) = {
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->serial());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbAccessoryProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbAccessoryProto*>(
      &from));
}

void UsbAccessoryProto::MergeFrom(const UsbAccessoryProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbAccessoryProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      manufacturer_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.manufacturer_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      model_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.model_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      description_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.description_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      version_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.version_);
    }
    if (cached_has_bits & 0x00000010u) {
      _has_bits_[0] |= 0x00000010u;
      uri_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.uri_);
    }
    if (cached_has_bits & 0x00000020u) {
      _has_bits_[0] |= 0x00000020u;
      serial_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.serial_);
    }
  }
}

void UsbAccessoryProto::CopyFrom(const UsbAccessoryProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbAccessoryProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbAccessoryProto::IsInitialized() const {
  return true;
}

void UsbAccessoryProto::InternalSwap(UsbAccessoryProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  manufacturer_.Swap(&other->manufacturer_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  model_.Swap(&other->model_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  description_.Swap(&other->description_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  version_.Swap(&other->version_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  uri_.Swap(&other->uri_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  serial_.Swap(&other->serial_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

std::string UsbAccessoryProto::GetTypeName() const {
  return "android.service.usb.UsbAccessoryProto";
}


// ===================================================================

void UsbDebuggingManagerProto::InitAsDefaultInstance() {
}
class UsbDebuggingManagerProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbDebuggingManagerProto>()._has_bits_);
  static void set_has_connected_to_adb(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_last_key_received(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_user_keys(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_system_keys(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

UsbDebuggingManagerProto::UsbDebuggingManagerProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbDebuggingManagerProto)
}
UsbDebuggingManagerProto::UsbDebuggingManagerProto(const UsbDebuggingManagerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  last_key_received_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_last_key_received()) {
    last_key_received_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.last_key_received_);
  }
  user_keys_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_user_keys()) {
    user_keys_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.user_keys_);
  }
  system_keys_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_system_keys()) {
    system_keys_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.system_keys_);
  }
  connected_to_adb_ = from.connected_to_adb_;
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbDebuggingManagerProto)
}

void UsbDebuggingManagerProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbDebuggingManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  last_key_received_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  user_keys_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  system_keys_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  connected_to_adb_ = false;
}

UsbDebuggingManagerProto::~UsbDebuggingManagerProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbDebuggingManagerProto)
  SharedDtor();
}

void UsbDebuggingManagerProto::SharedDtor() {
  last_key_received_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  user_keys_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  system_keys_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UsbDebuggingManagerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbDebuggingManagerProto& UsbDebuggingManagerProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbDebuggingManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbDebuggingManagerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbDebuggingManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      last_key_received_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      user_keys_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      system_keys_.ClearNonDefaultToEmptyNoArena();
    }
  }
  connected_to_adb_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbDebuggingManagerProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bool connected_to_adb = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_connected_to_adb(&has_bits);
          connected_to_adb_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string last_key_received = 2 [(.android.privacy) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_last_key_received(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string user_keys = 3 [(.android.privacy) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_user_keys(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string system_keys = 4 [(.android.privacy) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_system_keys(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbDebuggingManagerProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbDebuggingManagerProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool connected_to_adb = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_connected_to_adb(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &connected_to_adb_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string last_key_received = 2 [(.android.privacy) = {
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_last_key_received()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string user_keys = 3 [(.android.privacy) = {
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_user_keys()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string system_keys = 4 [(.android.privacy) = {
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_system_keys()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbDebuggingManagerProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbDebuggingManagerProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbDebuggingManagerProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbDebuggingManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool connected_to_adb = 1;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(1, this->connected_to_adb(), output);
  }

  // optional string last_key_received = 2 [(.android.privacy) = {
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->last_key_received(), output);
  }

  // optional string user_keys = 3 [(.android.privacy) = {
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->user_keys(), output);
  }

  // optional string system_keys = 4 [(.android.privacy) = {
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->system_keys(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbDebuggingManagerProto)
}

size_t UsbDebuggingManagerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbDebuggingManagerProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string last_key_received = 2 [(.android.privacy) = {
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->last_key_received());
    }

    // optional string user_keys = 3 [(.android.privacy) = {
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->user_keys());
    }

    // optional string system_keys = 4 [(.android.privacy) = {
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->system_keys());
    }

    // optional bool connected_to_adb = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbDebuggingManagerProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbDebuggingManagerProto*>(
      &from));
}

void UsbDebuggingManagerProto::MergeFrom(const UsbDebuggingManagerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbDebuggingManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      last_key_received_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.last_key_received_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      user_keys_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.user_keys_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      system_keys_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.system_keys_);
    }
    if (cached_has_bits & 0x00000008u) {
      connected_to_adb_ = from.connected_to_adb_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbDebuggingManagerProto::CopyFrom(const UsbDebuggingManagerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbDebuggingManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbDebuggingManagerProto::IsInitialized() const {
  return true;
}

void UsbDebuggingManagerProto::InternalSwap(UsbDebuggingManagerProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  last_key_received_.Swap(&other->last_key_received_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  user_keys_.Swap(&other->user_keys_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  system_keys_.Swap(&other->system_keys_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(connected_to_adb_, other->connected_to_adb_);
}

std::string UsbDebuggingManagerProto::GetTypeName() const {
  return "android.service.usb.UsbDebuggingManagerProto";
}


// ===================================================================

void UsbHostManagerProto::InitAsDefaultInstance() {
  ::android::service::usb::_UsbHostManagerProto_default_instance_._instance.get_mutable()->default_usb_host_connection_handler_ = const_cast< ::android::content::ComponentNameProto*>(
      ::android::content::ComponentNameProto::internal_default_instance());
}
class UsbHostManagerProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbHostManagerProto>()._has_bits_);
  static const ::android::content::ComponentNameProto& default_usb_host_connection_handler(const UsbHostManagerProto* msg);
  static void set_has_default_usb_host_connection_handler(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_connects(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::android::content::ComponentNameProto&
UsbHostManagerProto::_Internal::default_usb_host_connection_handler(const UsbHostManagerProto* msg) {
  return *msg->default_usb_host_connection_handler_;
}
void UsbHostManagerProto::clear_default_usb_host_connection_handler() {
  if (default_usb_host_connection_handler_ != nullptr) default_usb_host_connection_handler_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
UsbHostManagerProto::UsbHostManagerProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbHostManagerProto)
}
UsbHostManagerProto::UsbHostManagerProto(const UsbHostManagerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      devices_(from.devices_),
      connections_(from.connections_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_default_usb_host_connection_handler()) {
    default_usb_host_connection_handler_ = new ::android::content::ComponentNameProto(*from.default_usb_host_connection_handler_);
  } else {
    default_usb_host_connection_handler_ = nullptr;
  }
  num_connects_ = from.num_connects_;
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbHostManagerProto)
}

void UsbHostManagerProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbHostManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  ::memset(&default_usb_host_connection_handler_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&num_connects_) -
      reinterpret_cast<char*>(&default_usb_host_connection_handler_)) + sizeof(num_connects_));
}

UsbHostManagerProto::~UsbHostManagerProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbHostManagerProto)
  SharedDtor();
}

void UsbHostManagerProto::SharedDtor() {
  if (this != internal_default_instance()) delete default_usb_host_connection_handler_;
}

void UsbHostManagerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbHostManagerProto& UsbHostManagerProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbHostManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbHostManagerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbHostManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  devices_.Clear();
  connections_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(default_usb_host_connection_handler_ != nullptr);
    default_usb_host_connection_handler_->Clear();
  }
  num_connects_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbHostManagerProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .android.content.ComponentNameProto default_usb_host_connection_handler = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_default_usb_host_connection_handler(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbDeviceProto devices = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_devices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      // optional int32 num_connects = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_num_connects(&has_bits);
          num_connects_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbConnectionRecordProto connections = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_connections(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 34);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbHostManagerProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbHostManagerProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .android.content.ComponentNameProto default_usb_host_connection_handler = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_default_usb_host_connection_handler()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbDeviceProto devices = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_devices()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_connects = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_num_connects(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_connects_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbConnectionRecordProto connections = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_connections()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbHostManagerProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbHostManagerProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbHostManagerProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbHostManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.content.ComponentNameProto default_usb_host_connection_handler = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1, _Internal::default_usb_host_connection_handler(this), output);
  }

  // repeated .android.service.usb.UsbDeviceProto devices = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->devices_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2,
      this->devices(static_cast<int>(i)),
      output);
  }

  // optional int32 num_connects = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->num_connects(), output);
  }

  // repeated .android.service.usb.UsbConnectionRecordProto connections = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->connections_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      4,
      this->connections(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbHostManagerProto)
}

size_t UsbHostManagerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbHostManagerProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbDeviceProto devices = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->devices_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->devices(static_cast<int>(i)));
    }
  }

  // repeated .android.service.usb.UsbConnectionRecordProto connections = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->connections_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->connections(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .android.content.ComponentNameProto default_usb_host_connection_handler = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *default_usb_host_connection_handler_);
    }

    // optional int32 num_connects = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_connects());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbHostManagerProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbHostManagerProto*>(
      &from));
}

void UsbHostManagerProto::MergeFrom(const UsbHostManagerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbHostManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  devices_.MergeFrom(from.devices_);
  connections_.MergeFrom(from.connections_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_default_usb_host_connection_handler()->::android::content::ComponentNameProto::MergeFrom(from.default_usb_host_connection_handler());
    }
    if (cached_has_bits & 0x00000002u) {
      num_connects_ = from.num_connects_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbHostManagerProto::CopyFrom(const UsbHostManagerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbHostManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbHostManagerProto::IsInitialized() const {
  return true;
}

void UsbHostManagerProto::InternalSwap(UsbHostManagerProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&devices_)->InternalSwap(CastToBase(&other->devices_));
  CastToBase(&connections_)->InternalSwap(CastToBase(&other->connections_));
  swap(default_usb_host_connection_handler_, other->default_usb_host_connection_handler_);
  swap(num_connects_, other->num_connects_);
}

std::string UsbHostManagerProto::GetTypeName() const {
  return "android.service.usb.UsbHostManagerProto";
}


// ===================================================================

void UsbDeviceProto::InitAsDefaultInstance() {
}
class UsbDeviceProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbDeviceProto>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_vendor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_product_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_class_(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_subclass(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_protocol(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_manufacturer_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_product_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_serial_number(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

UsbDeviceProto::UsbDeviceProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbDeviceProto)
}
UsbDeviceProto::UsbDeviceProto(const UsbDeviceProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      configurations_(from.configurations_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  manufacturer_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_manufacturer_name()) {
    manufacturer_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.manufacturer_name_);
  }
  product_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_product_name()) {
    product_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.product_name_);
  }
  version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_version()) {
    version_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.version_);
  }
  serial_number_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_serial_number()) {
    serial_number_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.serial_number_);
  }
  ::memcpy(&vendor_id_, &from.vendor_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&protocol_) -
    reinterpret_cast<char*>(&vendor_id_)) + sizeof(protocol_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbDeviceProto)
}

void UsbDeviceProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  manufacturer_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  product_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  serial_number_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&vendor_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&protocol_) -
      reinterpret_cast<char*>(&vendor_id_)) + sizeof(protocol_));
}

UsbDeviceProto::~UsbDeviceProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbDeviceProto)
  SharedDtor();
}

void UsbDeviceProto::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  manufacturer_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  product_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  serial_number_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UsbDeviceProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbDeviceProto& UsbDeviceProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbDeviceProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbDeviceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  configurations_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      manufacturer_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      product_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      version_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      serial_number_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&vendor_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&class__) -
        reinterpret_cast<char*>(&vendor_id_)) + sizeof(class__));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&subclass_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&protocol_) -
        reinterpret_cast<char*>(&subclass_)) + sizeof(protocol_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbDeviceProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 vendor_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_vendor_id(&has_bits);
          vendor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 product_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_product_id(&has_bits);
          product_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 class = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_class_(&has_bits);
          class__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 subclass = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_subclass(&has_bits);
          subclass_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 protocol = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_protocol(&has_bits);
          protocol_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string manufacturer_name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_manufacturer_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string product_name = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_product_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string version = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_version(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string serial_number = 10 [(.android.privacy) = {
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_serial_number(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbConfigurationProto configurations = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_configurations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 90);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbDeviceProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbDeviceProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 vendor_id = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_vendor_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &vendor_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 product_id = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_product_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &product_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 class = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_class_(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &class__)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 subclass = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_subclass(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &subclass_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 protocol = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_protocol(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &protocol_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string manufacturer_name = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (58 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_manufacturer_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string product_name = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (66 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_product_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string version = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (74 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string serial_number = 10 [(.android.privacy) = {
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (82 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_serial_number()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbConfigurationProto configurations = 11;
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (90 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_configurations()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbDeviceProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbDeviceProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbDeviceProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbDeviceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional int32 vendor_id = 2;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->vendor_id(), output);
  }

  // optional int32 product_id = 3;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->product_id(), output);
  }

  // optional int32 class = 4;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->class_(), output);
  }

  // optional int32 subclass = 5;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->subclass(), output);
  }

  // optional int32 protocol = 6;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(6, this->protocol(), output);
  }

  // optional string manufacturer_name = 7;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->manufacturer_name(), output);
  }

  // optional string product_name = 8;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->product_name(), output);
  }

  // optional string version = 9;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->version(), output);
  }

  // optional string serial_number = 10 [(.android.privacy) = {
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      10, this->serial_number(), output);
  }

  // repeated .android.service.usb.UsbConfigurationProto configurations = 11;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->configurations_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      11,
      this->configurations(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbDeviceProto)
}

size_t UsbDeviceProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbDeviceProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbConfigurationProto configurations = 11;
  {
    unsigned int count = static_cast<unsigned int>(this->configurations_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->configurations(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string manufacturer_name = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->manufacturer_name());
    }

    // optional string product_name = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->product_name());
    }

    // optional string version = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional string serial_number = 10 [(.android.privacy) = {
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->serial_number());
    }

    // optional int32 vendor_id = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->vendor_id());
    }

    // optional int32 product_id = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->product_id());
    }

    // optional int32 class = 4;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->class_());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional int32 subclass = 5;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->subclass());
    }

    // optional int32 protocol = 6;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->protocol());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbDeviceProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbDeviceProto*>(
      &from));
}

void UsbDeviceProto::MergeFrom(const UsbDeviceProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbDeviceProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  configurations_.MergeFrom(from.configurations_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      manufacturer_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.manufacturer_name_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      product_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.product_name_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      version_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.version_);
    }
    if (cached_has_bits & 0x00000010u) {
      _has_bits_[0] |= 0x00000010u;
      serial_number_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.serial_number_);
    }
    if (cached_has_bits & 0x00000020u) {
      vendor_id_ = from.vendor_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      product_id_ = from.product_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      class__ = from.class__;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      subclass_ = from.subclass_;
    }
    if (cached_has_bits & 0x00000200u) {
      protocol_ = from.protocol_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbDeviceProto::CopyFrom(const UsbDeviceProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbDeviceProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbDeviceProto::IsInitialized() const {
  return true;
}

void UsbDeviceProto::InternalSwap(UsbDeviceProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&configurations_)->InternalSwap(CastToBase(&other->configurations_));
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  manufacturer_name_.Swap(&other->manufacturer_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  product_name_.Swap(&other->product_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  version_.Swap(&other->version_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  serial_number_.Swap(&other->serial_number_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(vendor_id_, other->vendor_id_);
  swap(product_id_, other->product_id_);
  swap(class__, other->class__);
  swap(subclass_, other->subclass_);
  swap(protocol_, other->protocol_);
}

std::string UsbDeviceProto::GetTypeName() const {
  return "android.service.usb.UsbDeviceProto";
}


// ===================================================================

void UsbConfigurationProto::InitAsDefaultInstance() {
}
class UsbConfigurationProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbConfigurationProto>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_attributes(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_max_power(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

UsbConfigurationProto::UsbConfigurationProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbConfigurationProto)
}
UsbConfigurationProto::UsbConfigurationProto(const UsbConfigurationProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      interfaces_(from.interfaces_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_power_) -
    reinterpret_cast<char*>(&id_)) + sizeof(max_power_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbConfigurationProto)
}

void UsbConfigurationProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbConfigurationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_power_) -
      reinterpret_cast<char*>(&id_)) + sizeof(max_power_));
}

UsbConfigurationProto::~UsbConfigurationProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbConfigurationProto)
  SharedDtor();
}

void UsbConfigurationProto::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UsbConfigurationProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbConfigurationProto& UsbConfigurationProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbConfigurationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbConfigurationProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbConfigurationProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  interfaces_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_power_) -
        reinterpret_cast<char*>(&id_)) + sizeof(max_power_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbConfigurationProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 attributes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_attributes(&has_bits);
          attributes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 max_power = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_max_power(&has_bits);
          max_power_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbInterfaceProto interfaces = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_interfaces(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 42);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbConfigurationProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbConfigurationProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string name = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 attributes = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_attributes(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &attributes_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 max_power = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_max_power(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_power_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbInterfaceProto interfaces = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_interfaces()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbConfigurationProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbConfigurationProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbConfigurationProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbConfigurationProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 id = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // optional uint32 attributes = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->attributes(), output);
  }

  // optional int32 max_power = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->max_power(), output);
  }

  // repeated .android.service.usb.UsbInterfaceProto interfaces = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->interfaces_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      5,
      this->interfaces(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbConfigurationProto)
}

size_t UsbConfigurationProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbConfigurationProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbInterfaceProto interfaces = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->interfaces_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->interfaces(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional uint32 attributes = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->attributes());
    }

    // optional int32 max_power = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->max_power());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbConfigurationProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbConfigurationProto*>(
      &from));
}

void UsbConfigurationProto::MergeFrom(const UsbConfigurationProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbConfigurationProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  interfaces_.MergeFrom(from.interfaces_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      attributes_ = from.attributes_;
    }
    if (cached_has_bits & 0x00000008u) {
      max_power_ = from.max_power_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbConfigurationProto::CopyFrom(const UsbConfigurationProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbConfigurationProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbConfigurationProto::IsInitialized() const {
  return true;
}

void UsbConfigurationProto::InternalSwap(UsbConfigurationProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&interfaces_)->InternalSwap(CastToBase(&other->interfaces_));
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(id_, other->id_);
  swap(attributes_, other->attributes_);
  swap(max_power_, other->max_power_);
}

std::string UsbConfigurationProto::GetTypeName() const {
  return "android.service.usb.UsbConfigurationProto";
}


// ===================================================================

void UsbInterfaceProto::InitAsDefaultInstance() {
}
class UsbInterfaceProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbInterfaceProto>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_alternate_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_class_(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_subclass(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_protocol(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

UsbInterfaceProto::UsbInterfaceProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbInterfaceProto)
}
UsbInterfaceProto::UsbInterfaceProto(const UsbInterfaceProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      endpoints_(from.endpoints_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&protocol_) -
    reinterpret_cast<char*>(&id_)) + sizeof(protocol_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbInterfaceProto)
}

void UsbInterfaceProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbInterfaceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&protocol_) -
      reinterpret_cast<char*>(&id_)) + sizeof(protocol_));
}

UsbInterfaceProto::~UsbInterfaceProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbInterfaceProto)
  SharedDtor();
}

void UsbInterfaceProto::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UsbInterfaceProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbInterfaceProto& UsbInterfaceProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbInterfaceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbInterfaceProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbInterfaceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  endpoints_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&protocol_) -
        reinterpret_cast<char*>(&id_)) + sizeof(protocol_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbInterfaceProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 alternate_settings = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_alternate_settings(&has_bits);
          alternate_settings_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 class = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_class_(&has_bits);
          class__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 subclass = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_subclass(&has_bits);
          subclass_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 protocol = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_protocol(&has_bits);
          protocol_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbEndPointProto endpoints = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_endpoints(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 58);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbInterfaceProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbInterfaceProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 alternate_settings = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_alternate_settings(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &alternate_settings_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string name = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 class = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_class_(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &class__)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 subclass = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_subclass(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &subclass_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 protocol = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_protocol(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &protocol_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbEndPointProto endpoints = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (58 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_endpoints()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbInterfaceProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbInterfaceProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbInterfaceProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbInterfaceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 id = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional int32 alternate_settings = 2;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->alternate_settings(), output);
  }

  // optional string name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->name(), output);
  }

  // optional int32 class = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->class_(), output);
  }

  // optional int32 subclass = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->subclass(), output);
  }

  // optional int32 protocol = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(6, this->protocol(), output);
  }

  // repeated .android.service.usb.UsbEndPointProto endpoints = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->endpoints_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      7,
      this->endpoints(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbInterfaceProto)
}

size_t UsbInterfaceProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbInterfaceProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbEndPointProto endpoints = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->endpoints_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->endpoints(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional int32 alternate_settings = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->alternate_settings());
    }

    // optional int32 class = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->class_());
    }

    // optional int32 subclass = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->subclass());
    }

    // optional int32 protocol = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->protocol());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbInterfaceProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbInterfaceProto*>(
      &from));
}

void UsbInterfaceProto::MergeFrom(const UsbInterfaceProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbInterfaceProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  endpoints_.MergeFrom(from.endpoints_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      alternate_settings_ = from.alternate_settings_;
    }
    if (cached_has_bits & 0x00000008u) {
      class__ = from.class__;
    }
    if (cached_has_bits & 0x00000010u) {
      subclass_ = from.subclass_;
    }
    if (cached_has_bits & 0x00000020u) {
      protocol_ = from.protocol_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbInterfaceProto::CopyFrom(const UsbInterfaceProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbInterfaceProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbInterfaceProto::IsInitialized() const {
  return true;
}

void UsbInterfaceProto::InternalSwap(UsbInterfaceProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&endpoints_)->InternalSwap(CastToBase(&other->endpoints_));
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(id_, other->id_);
  swap(alternate_settings_, other->alternate_settings_);
  swap(class__, other->class__);
  swap(subclass_, other->subclass_);
  swap(protocol_, other->protocol_);
}

std::string UsbInterfaceProto::GetTypeName() const {
  return "android.service.usb.UsbInterfaceProto";
}


// ===================================================================

void UsbEndPointProto::InitAsDefaultInstance() {
}
class UsbEndPointProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbEndPointProto>()._has_bits_);
  static void set_has_endpoint_number(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_address(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_attributes(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_max_packet_size(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_interval(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

UsbEndPointProto::UsbEndPointProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbEndPointProto)
}
UsbEndPointProto::UsbEndPointProto(const UsbEndPointProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&endpoint_number_, &from.endpoint_number_,
    static_cast<size_t>(reinterpret_cast<char*>(&interval_) -
    reinterpret_cast<char*>(&endpoint_number_)) + sizeof(interval_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbEndPointProto)
}

void UsbEndPointProto::SharedCtor() {
  ::memset(&endpoint_number_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&interval_) -
      reinterpret_cast<char*>(&endpoint_number_)) + sizeof(interval_));
}

UsbEndPointProto::~UsbEndPointProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbEndPointProto)
  SharedDtor();
}

void UsbEndPointProto::SharedDtor() {
}

void UsbEndPointProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbEndPointProto& UsbEndPointProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbEndPointProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbEndPointProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbEndPointProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&endpoint_number_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&interval_) -
        reinterpret_cast<char*>(&endpoint_number_)) + sizeof(interval_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbEndPointProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 endpoint_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_endpoint_number(&has_bits);
          endpoint_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.UsbEndPointDirection direction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::android::service::UsbEndPointDirection_IsValid(val))) {
            set_direction(static_cast<::android::service::UsbEndPointDirection>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional int32 address = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_address(&has_bits);
          address_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.UsbEndPointType type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::android::service::UsbEndPointType_IsValid(val))) {
            set_type(static_cast<::android::service::UsbEndPointType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 attributes = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_attributes(&has_bits);
          attributes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 max_packet_size = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_max_packet_size(&has_bits);
          max_packet_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 interval = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_interval(&has_bits);
          interval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbEndPointProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbEndPointProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 endpoint_number = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_endpoint_number(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &endpoint_number_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.UsbEndPointDirection direction = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::service::UsbEndPointDirection_IsValid(value)) {
            set_direction(static_cast< ::android::service::UsbEndPointDirection >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 address = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_address(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &address_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.UsbEndPointType type = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::service::UsbEndPointType_IsValid(value)) {
            set_type(static_cast< ::android::service::UsbEndPointType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(32u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 attributes = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_attributes(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &attributes_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 max_packet_size = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_max_packet_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_packet_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 interval = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_interval(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &interval_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbEndPointProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbEndPointProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbEndPointProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbEndPointProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 endpoint_number = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->endpoint_number(), output);
  }

  // optional .android.service.UsbEndPointDirection direction = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      2, this->direction(), output);
  }

  // optional int32 address = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->address(), output);
  }

  // optional .android.service.UsbEndPointType type = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      4, this->type(), output);
  }

  // optional uint32 attributes = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->attributes(), output);
  }

  // optional int32 max_packet_size = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(6, this->max_packet_size(), output);
  }

  // optional int32 interval = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(7, this->interval(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbEndPointProto)
}

size_t UsbEndPointProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbEndPointProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional int32 endpoint_number = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->endpoint_number());
    }

    // optional .android.service.UsbEndPointDirection direction = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->direction());
    }

    // optional int32 address = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->address());
    }

    // optional .android.service.UsbEndPointType type = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional uint32 attributes = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->attributes());
    }

    // optional int32 max_packet_size = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->max_packet_size());
    }

    // optional int32 interval = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->interval());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbEndPointProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbEndPointProto*>(
      &from));
}

void UsbEndPointProto::MergeFrom(const UsbEndPointProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbEndPointProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      endpoint_number_ = from.endpoint_number_;
    }
    if (cached_has_bits & 0x00000002u) {
      direction_ = from.direction_;
    }
    if (cached_has_bits & 0x00000004u) {
      address_ = from.address_;
    }
    if (cached_has_bits & 0x00000008u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000010u) {
      attributes_ = from.attributes_;
    }
    if (cached_has_bits & 0x00000020u) {
      max_packet_size_ = from.max_packet_size_;
    }
    if (cached_has_bits & 0x00000040u) {
      interval_ = from.interval_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbEndPointProto::CopyFrom(const UsbEndPointProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbEndPointProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbEndPointProto::IsInitialized() const {
  return true;
}

void UsbEndPointProto::InternalSwap(UsbEndPointProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(endpoint_number_, other->endpoint_number_);
  swap(direction_, other->direction_);
  swap(address_, other->address_);
  swap(type_, other->type_);
  swap(attributes_, other->attributes_);
  swap(max_packet_size_, other->max_packet_size_);
  swap(interval_, other->interval_);
}

std::string UsbEndPointProto::GetTypeName() const {
  return "android.service.usb.UsbEndPointProto";
}


// ===================================================================

void UsbConnectionRecordProto::InitAsDefaultInstance() {
  ::android::service::usb::_UsbConnectionRecordProto_default_instance_._instance.get_mutable()->is_headset_ = const_cast< ::android::service::usb::UsbIsHeadsetProto*>(
      ::android::service::usb::UsbIsHeadsetProto::internal_default_instance());
}
class UsbConnectionRecordProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbConnectionRecordProto>()._has_bits_);
  static void set_has_device_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_manufacturer(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_product(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::android::service::usb::UsbIsHeadsetProto& is_headset(const UsbConnectionRecordProto* msg);
  static void set_has_is_headset(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::android::service::usb::UsbIsHeadsetProto&
UsbConnectionRecordProto::_Internal::is_headset(const UsbConnectionRecordProto* msg) {
  return *msg->is_headset_;
}
UsbConnectionRecordProto::UsbConnectionRecordProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbConnectionRecordProto)
}
UsbConnectionRecordProto::UsbConnectionRecordProto(const UsbConnectionRecordProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  device_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_device_address()) {
    device_address_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.device_address_);
  }
  if (from.has_is_headset()) {
    is_headset_ = new ::android::service::usb::UsbIsHeadsetProto(*from.is_headset_);
  } else {
    is_headset_ = nullptr;
  }
  ::memcpy(&timestamp_, &from.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&product_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(product_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbConnectionRecordProto)
}

void UsbConnectionRecordProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbConnectionRecordProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  device_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&is_headset_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&product_) -
      reinterpret_cast<char*>(&is_headset_)) + sizeof(product_));
}

UsbConnectionRecordProto::~UsbConnectionRecordProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbConnectionRecordProto)
  SharedDtor();
}

void UsbConnectionRecordProto::SharedDtor() {
  device_address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete is_headset_;
}

void UsbConnectionRecordProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbConnectionRecordProto& UsbConnectionRecordProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbConnectionRecordProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbConnectionRecordProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbConnectionRecordProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      device_address_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(is_headset_ != nullptr);
      is_headset_->Clear();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&product_) -
        reinterpret_cast<char*>(&timestamp_)) + sizeof(product_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbConnectionRecordProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string device_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_device_address(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.UsbConnectionRecordMode mode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::android::service::UsbConnectionRecordMode_IsValid(val))) {
            set_mode(static_cast<::android::service::UsbConnectionRecordMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional int64 timestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 manufacturer = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_manufacturer(&has_bits);
          manufacturer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 product = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_product(&has_bits);
          product_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbIsHeadsetProto is_headset = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(mutable_is_headset(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbConnectionRecordProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbConnectionRecordProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string device_address = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_device_address()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.UsbConnectionRecordMode mode = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::service::UsbConnectionRecordMode_IsValid(value)) {
            set_mode(static_cast< ::android::service::UsbConnectionRecordMode >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 timestamp = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_timestamp(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &timestamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 manufacturer = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_manufacturer(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &manufacturer_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 product = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_product(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &product_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbIsHeadsetProto is_headset = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_is_headset()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbConnectionRecordProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbConnectionRecordProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbConnectionRecordProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbConnectionRecordProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string device_address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->device_address(), output);
  }

  // optional .android.service.UsbConnectionRecordMode mode = 2;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      2, this->mode(), output);
  }

  // optional int64 timestamp = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(3, this->timestamp(), output);
  }

  // optional int32 manufacturer = 4;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->manufacturer(), output);
  }

  // optional int32 product = 5;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->product(), output);
  }

  // optional .android.service.usb.UsbIsHeadsetProto is_headset = 6;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      6, _Internal::is_headset(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbConnectionRecordProto)
}

size_t UsbConnectionRecordProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbConnectionRecordProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string device_address = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->device_address());
    }

    // optional .android.service.usb.UsbIsHeadsetProto is_headset = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *is_headset_);
    }

    // optional int64 timestamp = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->timestamp());
    }

    // optional .android.service.UsbConnectionRecordMode mode = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->mode());
    }

    // optional int32 manufacturer = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->manufacturer());
    }

    // optional int32 product = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->product());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbConnectionRecordProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbConnectionRecordProto*>(
      &from));
}

void UsbConnectionRecordProto::MergeFrom(const UsbConnectionRecordProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbConnectionRecordProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      device_address_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.device_address_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_is_headset()->::android::service::usb::UsbIsHeadsetProto::MergeFrom(from.is_headset());
    }
    if (cached_has_bits & 0x00000004u) {
      timestamp_ = from.timestamp_;
    }
    if (cached_has_bits & 0x00000008u) {
      mode_ = from.mode_;
    }
    if (cached_has_bits & 0x00000010u) {
      manufacturer_ = from.manufacturer_;
    }
    if (cached_has_bits & 0x00000020u) {
      product_ = from.product_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbConnectionRecordProto::CopyFrom(const UsbConnectionRecordProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbConnectionRecordProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbConnectionRecordProto::IsInitialized() const {
  return true;
}

void UsbConnectionRecordProto::InternalSwap(UsbConnectionRecordProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  device_address_.Swap(&other->device_address_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(is_headset_, other->is_headset_);
  swap(timestamp_, other->timestamp_);
  swap(mode_, other->mode_);
  swap(manufacturer_, other->manufacturer_);
  swap(product_, other->product_);
}

std::string UsbConnectionRecordProto::GetTypeName() const {
  return "android.service.usb.UsbConnectionRecordProto";
}


// ===================================================================

void UsbIsHeadsetProto::InitAsDefaultInstance() {
}
class UsbIsHeadsetProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbIsHeadsetProto>()._has_bits_);
  static void set_has_in(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_out(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

UsbIsHeadsetProto::UsbIsHeadsetProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbIsHeadsetProto)
}
UsbIsHeadsetProto::UsbIsHeadsetProto(const UsbIsHeadsetProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&in_, &from.in_,
    static_cast<size_t>(reinterpret_cast<char*>(&out_) -
    reinterpret_cast<char*>(&in_)) + sizeof(out_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbIsHeadsetProto)
}

void UsbIsHeadsetProto::SharedCtor() {
  ::memset(&in_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&out_) -
      reinterpret_cast<char*>(&in_)) + sizeof(out_));
}

UsbIsHeadsetProto::~UsbIsHeadsetProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbIsHeadsetProto)
  SharedDtor();
}

void UsbIsHeadsetProto::SharedDtor() {
}

void UsbIsHeadsetProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbIsHeadsetProto& UsbIsHeadsetProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbIsHeadsetProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbIsHeadsetProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbIsHeadsetProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&in_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&out_) -
      reinterpret_cast<char*>(&in_)) + sizeof(out_));
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbIsHeadsetProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bool in = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_in(&has_bits);
          in_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool out = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_out(&has_bits);
          out_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbIsHeadsetProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbIsHeadsetProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool in = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_in(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &in_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool out = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_out(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &out_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbIsHeadsetProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbIsHeadsetProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbIsHeadsetProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbIsHeadsetProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool in = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(1, this->in(), output);
  }

  // optional bool out = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(2, this->out(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbIsHeadsetProto)
}

size_t UsbIsHeadsetProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbIsHeadsetProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool in = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool out = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbIsHeadsetProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbIsHeadsetProto*>(
      &from));
}

void UsbIsHeadsetProto::MergeFrom(const UsbIsHeadsetProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbIsHeadsetProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      in_ = from.in_;
    }
    if (cached_has_bits & 0x00000002u) {
      out_ = from.out_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbIsHeadsetProto::CopyFrom(const UsbIsHeadsetProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbIsHeadsetProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbIsHeadsetProto::IsInitialized() const {
  return true;
}

void UsbIsHeadsetProto::InternalSwap(UsbIsHeadsetProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(in_, other->in_);
  swap(out_, other->out_);
}

std::string UsbIsHeadsetProto::GetTypeName() const {
  return "android.service.usb.UsbIsHeadsetProto";
}


// ===================================================================

void UsbPortManagerProto::InitAsDefaultInstance() {
}
class UsbPortManagerProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbPortManagerProto>()._has_bits_);
  static void set_has_is_simulation_active(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_enable_usb_data_signaling(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

UsbPortManagerProto::UsbPortManagerProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbPortManagerProto)
}
UsbPortManagerProto::UsbPortManagerProto(const UsbPortManagerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      usb_ports_(from.usb_ports_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&is_simulation_active_, &from.is_simulation_active_,
    static_cast<size_t>(reinterpret_cast<char*>(&enable_usb_data_signaling_) -
    reinterpret_cast<char*>(&is_simulation_active_)) + sizeof(enable_usb_data_signaling_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbPortManagerProto)
}

void UsbPortManagerProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbPortManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  ::memset(&is_simulation_active_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&enable_usb_data_signaling_) -
      reinterpret_cast<char*>(&is_simulation_active_)) + sizeof(enable_usb_data_signaling_));
}

UsbPortManagerProto::~UsbPortManagerProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbPortManagerProto)
  SharedDtor();
}

void UsbPortManagerProto::SharedDtor() {
}

void UsbPortManagerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbPortManagerProto& UsbPortManagerProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbPortManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbPortManagerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbPortManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  usb_ports_.Clear();
  ::memset(&is_simulation_active_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&enable_usb_data_signaling_) -
      reinterpret_cast<char*>(&is_simulation_active_)) + sizeof(enable_usb_data_signaling_));
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbPortManagerProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bool is_simulation_active = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_is_simulation_active(&has_bits);
          is_simulation_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbPortInfoProto usb_ports = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_usb_ports(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      // optional bool enable_usb_data_signaling = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_enable_usb_data_signaling(&has_bits);
          enable_usb_data_signaling_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbPortManagerProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbPortManagerProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool is_simulation_active = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_is_simulation_active(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_simulation_active_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbPortInfoProto usb_ports = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_usb_ports()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool enable_usb_data_signaling = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_enable_usb_data_signaling(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enable_usb_data_signaling_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbPortManagerProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbPortManagerProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbPortManagerProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbPortManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool is_simulation_active = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(1, this->is_simulation_active(), output);
  }

  // repeated .android.service.usb.UsbPortInfoProto usb_ports = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->usb_ports_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2,
      this->usb_ports(static_cast<int>(i)),
      output);
  }

  // optional bool enable_usb_data_signaling = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(3, this->enable_usb_data_signaling(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbPortManagerProto)
}

size_t UsbPortManagerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbPortManagerProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbPortInfoProto usb_ports = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->usb_ports_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->usb_ports(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool is_simulation_active = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool enable_usb_data_signaling = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbPortManagerProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbPortManagerProto*>(
      &from));
}

void UsbPortManagerProto::MergeFrom(const UsbPortManagerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbPortManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  usb_ports_.MergeFrom(from.usb_ports_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      is_simulation_active_ = from.is_simulation_active_;
    }
    if (cached_has_bits & 0x00000002u) {
      enable_usb_data_signaling_ = from.enable_usb_data_signaling_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbPortManagerProto::CopyFrom(const UsbPortManagerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbPortManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbPortManagerProto::IsInitialized() const {
  return true;
}

void UsbPortManagerProto::InternalSwap(UsbPortManagerProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&usb_ports_)->InternalSwap(CastToBase(&other->usb_ports_));
  swap(is_simulation_active_, other->is_simulation_active_);
  swap(enable_usb_data_signaling_, other->enable_usb_data_signaling_);
}

std::string UsbPortManagerProto::GetTypeName() const {
  return "android.service.usb.UsbPortManagerProto";
}


// ===================================================================

void UsbPortInfoProto::InitAsDefaultInstance() {
  ::android::service::usb::_UsbPortInfoProto_default_instance_._instance.get_mutable()->port_ = const_cast< ::android::service::usb::UsbPortProto*>(
      ::android::service::usb::UsbPortProto::internal_default_instance());
  ::android::service::usb::_UsbPortInfoProto_default_instance_._instance.get_mutable()->status_ = const_cast< ::android::service::usb::UsbPortStatusProto*>(
      ::android::service::usb::UsbPortStatusProto::internal_default_instance());
}
class UsbPortInfoProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbPortInfoProto>()._has_bits_);
  static const ::android::service::usb::UsbPortProto& port(const UsbPortInfoProto* msg);
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::android::service::usb::UsbPortStatusProto& status(const UsbPortInfoProto* msg);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_can_change_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_can_change_power_role(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_can_change_data_role(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_connected_at_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_last_connect_duration_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::android::service::usb::UsbPortProto&
UsbPortInfoProto::_Internal::port(const UsbPortInfoProto* msg) {
  return *msg->port_;
}
const ::android::service::usb::UsbPortStatusProto&
UsbPortInfoProto::_Internal::status(const UsbPortInfoProto* msg) {
  return *msg->status_;
}
UsbPortInfoProto::UsbPortInfoProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbPortInfoProto)
}
UsbPortInfoProto::UsbPortInfoProto(const UsbPortInfoProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_port()) {
    port_ = new ::android::service::usb::UsbPortProto(*from.port_);
  } else {
    port_ = nullptr;
  }
  if (from.has_status()) {
    status_ = new ::android::service::usb::UsbPortStatusProto(*from.status_);
  } else {
    status_ = nullptr;
  }
  ::memcpy(&connected_at_millis_, &from.connected_at_millis_,
    static_cast<size_t>(reinterpret_cast<char*>(&can_change_data_role_) -
    reinterpret_cast<char*>(&connected_at_millis_)) + sizeof(can_change_data_role_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbPortInfoProto)
}

void UsbPortInfoProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbPortInfoProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  ::memset(&port_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&can_change_data_role_) -
      reinterpret_cast<char*>(&port_)) + sizeof(can_change_data_role_));
}

UsbPortInfoProto::~UsbPortInfoProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbPortInfoProto)
  SharedDtor();
}

void UsbPortInfoProto::SharedDtor() {
  if (this != internal_default_instance()) delete port_;
  if (this != internal_default_instance()) delete status_;
}

void UsbPortInfoProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbPortInfoProto& UsbPortInfoProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbPortInfoProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbPortInfoProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbPortInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(port_ != nullptr);
      port_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(status_ != nullptr);
      status_->Clear();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&connected_at_millis_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&can_change_data_role_) -
        reinterpret_cast<char*>(&connected_at_millis_)) + sizeof(can_change_data_role_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbPortInfoProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .android.service.usb.UsbPortProto port = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_port(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbPortStatusProto status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_status(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool can_change_mode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_can_change_mode(&has_bits);
          can_change_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool can_change_power_role = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_can_change_power_role(&has_bits);
          can_change_power_role_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool can_change_data_role = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_can_change_data_role(&has_bits);
          can_change_data_role_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 connected_at_millis = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_connected_at_millis(&has_bits);
          connected_at_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 last_connect_duration_millis = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_last_connect_duration_millis(&has_bits);
          last_connect_duration_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbPortInfoProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbPortInfoProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .android.service.usb.UsbPortProto port = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_port()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbPortStatusProto status = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_status()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool can_change_mode = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_can_change_mode(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &can_change_mode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool can_change_power_role = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_can_change_power_role(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &can_change_power_role_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool can_change_data_role = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_can_change_data_role(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &can_change_data_role_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 connected_at_millis = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_connected_at_millis(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &connected_at_millis_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 last_connect_duration_millis = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_last_connect_duration_millis(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &last_connect_duration_millis_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbPortInfoProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbPortInfoProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbPortInfoProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbPortInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.service.usb.UsbPortProto port = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1, _Internal::port(this), output);
  }

  // optional .android.service.usb.UsbPortStatusProto status = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2, _Internal::status(this), output);
  }

  // optional bool can_change_mode = 3;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(3, this->can_change_mode(), output);
  }

  // optional bool can_change_power_role = 4;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(4, this->can_change_power_role(), output);
  }

  // optional bool can_change_data_role = 5;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(5, this->can_change_data_role(), output);
  }

  // optional int64 connected_at_millis = 6;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(6, this->connected_at_millis(), output);
  }

  // optional int64 last_connect_duration_millis = 7;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(7, this->last_connect_duration_millis(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbPortInfoProto)
}

size_t UsbPortInfoProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbPortInfoProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .android.service.usb.UsbPortProto port = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *port_);
    }

    // optional .android.service.usb.UsbPortStatusProto status = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *status_);
    }

    // optional int64 connected_at_millis = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->connected_at_millis());
    }

    // optional int64 last_connect_duration_millis = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->last_connect_duration_millis());
    }

    // optional bool can_change_mode = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool can_change_power_role = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool can_change_data_role = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbPortInfoProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbPortInfoProto*>(
      &from));
}

void UsbPortInfoProto::MergeFrom(const UsbPortInfoProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbPortInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_port()->::android::service::usb::UsbPortProto::MergeFrom(from.port());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_status()->::android::service::usb::UsbPortStatusProto::MergeFrom(from.status());
    }
    if (cached_has_bits & 0x00000004u) {
      connected_at_millis_ = from.connected_at_millis_;
    }
    if (cached_has_bits & 0x00000008u) {
      last_connect_duration_millis_ = from.last_connect_duration_millis_;
    }
    if (cached_has_bits & 0x00000010u) {
      can_change_mode_ = from.can_change_mode_;
    }
    if (cached_has_bits & 0x00000020u) {
      can_change_power_role_ = from.can_change_power_role_;
    }
    if (cached_has_bits & 0x00000040u) {
      can_change_data_role_ = from.can_change_data_role_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbPortInfoProto::CopyFrom(const UsbPortInfoProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbPortInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbPortInfoProto::IsInitialized() const {
  return true;
}

void UsbPortInfoProto::InternalSwap(UsbPortInfoProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(port_, other->port_);
  swap(status_, other->status_);
  swap(connected_at_millis_, other->connected_at_millis_);
  swap(last_connect_duration_millis_, other->last_connect_duration_millis_);
  swap(can_change_mode_, other->can_change_mode_);
  swap(can_change_power_role_, other->can_change_power_role_);
  swap(can_change_data_role_, other->can_change_data_role_);
}

std::string UsbPortInfoProto::GetTypeName() const {
  return "android.service.usb.UsbPortInfoProto";
}


// ===================================================================

void UsbPortProto::InitAsDefaultInstance() {
}
class UsbPortProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbPortProto>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UsbPortProto::UsbPortProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbPortProto)
}
UsbPortProto::UsbPortProto(const UsbPortProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      supported_modes_(from.supported_modes_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_id()) {
    id_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.id_);
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbPortProto)
}

void UsbPortProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbPortProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

UsbPortProto::~UsbPortProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbPortProto)
  SharedDtor();
}

void UsbPortProto::SharedDtor() {
  id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UsbPortProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbPortProto& UsbPortProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbPortProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbPortProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbPortProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  supported_modes_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    id_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbPortProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_id(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbPortProto.Mode supported_modes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::android::service::usb::UsbPortProto_Mode_IsValid(val))) {
              add_supported_modes(static_cast<::android::service::usb::UsbPortProto_Mode>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 16);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(mutable_supported_modes(), ptr, ctx, ::android::service::usb::UsbPortProto_Mode_IsValid, &_internal_metadata_, 2);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbPortProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbPortProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string id = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbPortProto.Mode supported_modes = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::service::usb::UsbPortProto_Mode_IsValid(value)) {
            add_supported_modes(static_cast< ::android::service::usb::UsbPortProto_Mode >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                 input,
                 2,
                 ::android::service::usb::UsbPortProto_Mode_IsValid,
                 &unknown_fields_stream,
                 this->mutable_supported_modes())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbPortProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbPortProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbPortProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbPortProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->id(), output);
  }

  // repeated .android.service.usb.UsbPortProto.Mode supported_modes = 2;
  for (int i = 0, n = this->supported_modes_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      2, this->supported_modes(i), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbPortProto)
}

size_t UsbPortProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbPortProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbPortProto.Mode supported_modes = 2;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->supported_modes_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->supported_modes(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // optional string id = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->id());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbPortProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbPortProto*>(
      &from));
}

void UsbPortProto::MergeFrom(const UsbPortProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbPortProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  supported_modes_.MergeFrom(from.supported_modes_);
  if (from.has_id()) {
    _has_bits_[0] |= 0x00000001u;
    id_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.id_);
  }
}

void UsbPortProto::CopyFrom(const UsbPortProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbPortProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbPortProto::IsInitialized() const {
  return true;
}

void UsbPortProto::InternalSwap(UsbPortProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  supported_modes_.InternalSwap(&other->supported_modes_);
  id_.Swap(&other->id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

std::string UsbPortProto::GetTypeName() const {
  return "android.service.usb.UsbPortProto";
}


// ===================================================================

void UsbPortStatusProto::InitAsDefaultInstance() {
}
class UsbPortStatusProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbPortStatusProto>()._has_bits_);
  static void set_has_connected(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_current_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_power_role(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_data_role(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_contaminant_presence_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

UsbPortStatusProto::UsbPortStatusProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbPortStatusProto)
}
UsbPortStatusProto::UsbPortStatusProto(const UsbPortStatusProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      role_combinations_(from.role_combinations_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&connected_, &from.connected_,
    static_cast<size_t>(reinterpret_cast<char*>(&contaminant_presence_status_) -
    reinterpret_cast<char*>(&connected_)) + sizeof(contaminant_presence_status_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbPortStatusProto)
}

void UsbPortStatusProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbPortStatusProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  ::memset(&connected_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&contaminant_presence_status_) -
      reinterpret_cast<char*>(&connected_)) + sizeof(contaminant_presence_status_));
}

UsbPortStatusProto::~UsbPortStatusProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbPortStatusProto)
  SharedDtor();
}

void UsbPortStatusProto::SharedDtor() {
}

void UsbPortStatusProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbPortStatusProto& UsbPortStatusProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbPortStatusProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbPortStatusProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbPortStatusProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  role_combinations_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&connected_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&contaminant_presence_status_) -
        reinterpret_cast<char*>(&connected_)) + sizeof(contaminant_presence_status_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbPortStatusProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bool connected = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_connected(&has_bits);
          connected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbPortProto.Mode current_mode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::android::service::usb::UsbPortProto_Mode_IsValid(val))) {
            set_current_mode(static_cast<::android::service::usb::UsbPortProto_Mode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbPortStatusProto.PowerRole power_role = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::android::service::usb::UsbPortStatusProto_PowerRole_IsValid(val))) {
            set_power_role(static_cast<::android::service::usb::UsbPortStatusProto_PowerRole>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbPortStatusProto.DataRole data_role = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::android::service::usb::UsbPortStatusProto_DataRole_IsValid(val))) {
            set_data_role(static_cast<::android::service::usb::UsbPortStatusProto_DataRole>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbPortStatusRoleCombinationProto role_combinations = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_role_combinations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 42);
        } else goto handle_unusual;
        continue;
      // optional .android.service.ContaminantPresenceStatus contaminant_presence_status = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::android::service::ContaminantPresenceStatus_IsValid(val))) {
            set_contaminant_presence_status(static_cast<::android::service::ContaminantPresenceStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbPortStatusProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbPortStatusProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool connected = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_connected(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &connected_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbPortProto.Mode current_mode = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::service::usb::UsbPortProto_Mode_IsValid(value)) {
            set_current_mode(static_cast< ::android::service::usb::UsbPortProto_Mode >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbPortStatusProto.PowerRole power_role = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::service::usb::UsbPortStatusProto_PowerRole_IsValid(value)) {
            set_power_role(static_cast< ::android::service::usb::UsbPortStatusProto_PowerRole >(value));
          } else {
            unknown_fields_stream.WriteVarint32(24u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbPortStatusProto.DataRole data_role = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::service::usb::UsbPortStatusProto_DataRole_IsValid(value)) {
            set_data_role(static_cast< ::android::service::usb::UsbPortStatusProto_DataRole >(value));
          } else {
            unknown_fields_stream.WriteVarint32(32u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbPortStatusRoleCombinationProto role_combinations = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_role_combinations()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.ContaminantPresenceStatus contaminant_presence_status = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::service::ContaminantPresenceStatus_IsValid(value)) {
            set_contaminant_presence_status(static_cast< ::android::service::ContaminantPresenceStatus >(value));
          } else {
            unknown_fields_stream.WriteVarint32(48u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbPortStatusProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbPortStatusProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbPortStatusProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbPortStatusProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool connected = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(1, this->connected(), output);
  }

  // optional .android.service.usb.UsbPortProto.Mode current_mode = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      2, this->current_mode(), output);
  }

  // optional .android.service.usb.UsbPortStatusProto.PowerRole power_role = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      3, this->power_role(), output);
  }

  // optional .android.service.usb.UsbPortStatusProto.DataRole data_role = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      4, this->data_role(), output);
  }

  // repeated .android.service.usb.UsbPortStatusRoleCombinationProto role_combinations = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->role_combinations_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      5,
      this->role_combinations(static_cast<int>(i)),
      output);
  }

  // optional .android.service.ContaminantPresenceStatus contaminant_presence_status = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      6, this->contaminant_presence_status(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbPortStatusProto)
}

size_t UsbPortStatusProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbPortStatusProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbPortStatusRoleCombinationProto role_combinations = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->role_combinations_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->role_combinations(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bool connected = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional .android.service.usb.UsbPortProto.Mode current_mode = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->current_mode());
    }

    // optional .android.service.usb.UsbPortStatusProto.PowerRole power_role = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->power_role());
    }

    // optional .android.service.usb.UsbPortStatusProto.DataRole data_role = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->data_role());
    }

    // optional .android.service.ContaminantPresenceStatus contaminant_presence_status = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->contaminant_presence_status());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbPortStatusProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbPortStatusProto*>(
      &from));
}

void UsbPortStatusProto::MergeFrom(const UsbPortStatusProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbPortStatusProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  role_combinations_.MergeFrom(from.role_combinations_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      connected_ = from.connected_;
    }
    if (cached_has_bits & 0x00000002u) {
      current_mode_ = from.current_mode_;
    }
    if (cached_has_bits & 0x00000004u) {
      power_role_ = from.power_role_;
    }
    if (cached_has_bits & 0x00000008u) {
      data_role_ = from.data_role_;
    }
    if (cached_has_bits & 0x00000010u) {
      contaminant_presence_status_ = from.contaminant_presence_status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbPortStatusProto::CopyFrom(const UsbPortStatusProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbPortStatusProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbPortStatusProto::IsInitialized() const {
  return true;
}

void UsbPortStatusProto::InternalSwap(UsbPortStatusProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&role_combinations_)->InternalSwap(CastToBase(&other->role_combinations_));
  swap(connected_, other->connected_);
  swap(current_mode_, other->current_mode_);
  swap(power_role_, other->power_role_);
  swap(data_role_, other->data_role_);
  swap(contaminant_presence_status_, other->contaminant_presence_status_);
}

std::string UsbPortStatusProto::GetTypeName() const {
  return "android.service.usb.UsbPortStatusProto";
}


// ===================================================================

void UsbPortStatusRoleCombinationProto::InitAsDefaultInstance() {
}
class UsbPortStatusRoleCombinationProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbPortStatusRoleCombinationProto>()._has_bits_);
  static void set_has_power_role(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_data_role(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

UsbPortStatusRoleCombinationProto::UsbPortStatusRoleCombinationProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbPortStatusRoleCombinationProto)
}
UsbPortStatusRoleCombinationProto::UsbPortStatusRoleCombinationProto(const UsbPortStatusRoleCombinationProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&power_role_, &from.power_role_,
    static_cast<size_t>(reinterpret_cast<char*>(&data_role_) -
    reinterpret_cast<char*>(&power_role_)) + sizeof(data_role_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbPortStatusRoleCombinationProto)
}

void UsbPortStatusRoleCombinationProto::SharedCtor() {
  ::memset(&power_role_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&data_role_) -
      reinterpret_cast<char*>(&power_role_)) + sizeof(data_role_));
}

UsbPortStatusRoleCombinationProto::~UsbPortStatusRoleCombinationProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbPortStatusRoleCombinationProto)
  SharedDtor();
}

void UsbPortStatusRoleCombinationProto::SharedDtor() {
}

void UsbPortStatusRoleCombinationProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbPortStatusRoleCombinationProto& UsbPortStatusRoleCombinationProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbPortStatusRoleCombinationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbPortStatusRoleCombinationProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbPortStatusRoleCombinationProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&power_role_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&data_role_) -
        reinterpret_cast<char*>(&power_role_)) + sizeof(data_role_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbPortStatusRoleCombinationProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .android.service.usb.UsbPortStatusProto.PowerRole power_role = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::android::service::usb::UsbPortStatusProto_PowerRole_IsValid(val))) {
            set_power_role(static_cast<::android::service::usb::UsbPortStatusProto_PowerRole>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbPortStatusProto.DataRole data_role = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::android::service::usb::UsbPortStatusProto_DataRole_IsValid(val))) {
            set_data_role(static_cast<::android::service::usb::UsbPortStatusProto_DataRole>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbPortStatusRoleCombinationProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbPortStatusRoleCombinationProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .android.service.usb.UsbPortStatusProto.PowerRole power_role = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::service::usb::UsbPortStatusProto_PowerRole_IsValid(value)) {
            set_power_role(static_cast< ::android::service::usb::UsbPortStatusProto_PowerRole >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbPortStatusProto.DataRole data_role = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::service::usb::UsbPortStatusProto_DataRole_IsValid(value)) {
            set_data_role(static_cast< ::android::service::usb::UsbPortStatusProto_DataRole >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbPortStatusRoleCombinationProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbPortStatusRoleCombinationProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbPortStatusRoleCombinationProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbPortStatusRoleCombinationProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.service.usb.UsbPortStatusProto.PowerRole power_role = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->power_role(), output);
  }

  // optional .android.service.usb.UsbPortStatusProto.DataRole data_role = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      2, this->data_role(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbPortStatusRoleCombinationProto)
}

size_t UsbPortStatusRoleCombinationProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbPortStatusRoleCombinationProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .android.service.usb.UsbPortStatusProto.PowerRole power_role = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->power_role());
    }

    // optional .android.service.usb.UsbPortStatusProto.DataRole data_role = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->data_role());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbPortStatusRoleCombinationProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbPortStatusRoleCombinationProto*>(
      &from));
}

void UsbPortStatusRoleCombinationProto::MergeFrom(const UsbPortStatusRoleCombinationProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbPortStatusRoleCombinationProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      power_role_ = from.power_role_;
    }
    if (cached_has_bits & 0x00000002u) {
      data_role_ = from.data_role_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbPortStatusRoleCombinationProto::CopyFrom(const UsbPortStatusRoleCombinationProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbPortStatusRoleCombinationProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbPortStatusRoleCombinationProto::IsInitialized() const {
  return true;
}

void UsbPortStatusRoleCombinationProto::InternalSwap(UsbPortStatusRoleCombinationProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(power_role_, other->power_role_);
  swap(data_role_, other->data_role_);
}

std::string UsbPortStatusRoleCombinationProto::GetTypeName() const {
  return "android.service.usb.UsbPortStatusRoleCombinationProto";
}


// ===================================================================

void UsbAlsaManagerProto::InitAsDefaultInstance() {
}
class UsbAlsaManagerProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbAlsaManagerProto>()._has_bits_);
  static void set_has_cards_parser(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UsbAlsaManagerProto::UsbAlsaManagerProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbAlsaManagerProto)
}
UsbAlsaManagerProto::UsbAlsaManagerProto(const UsbAlsaManagerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      alsa_devices_(from.alsa_devices_),
      midi_devices_(from.midi_devices_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  cards_parser_ = from.cards_parser_;
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbAlsaManagerProto)
}

void UsbAlsaManagerProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbAlsaManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  cards_parser_ = 0;
}

UsbAlsaManagerProto::~UsbAlsaManagerProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbAlsaManagerProto)
  SharedDtor();
}

void UsbAlsaManagerProto::SharedDtor() {
}

void UsbAlsaManagerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbAlsaManagerProto& UsbAlsaManagerProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbAlsaManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbAlsaManagerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbAlsaManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  alsa_devices_.Clear();
  midi_devices_.Clear();
  cards_parser_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbAlsaManagerProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 cards_parser = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_cards_parser(&has_bits);
          cards_parser_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbAlsaDeviceProto alsa_devices = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_alsa_devices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbMidiDeviceProto midi_devices = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_midi_devices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 26);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbAlsaManagerProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbAlsaManagerProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 cards_parser = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_cards_parser(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &cards_parser_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbAlsaDeviceProto alsa_devices = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_alsa_devices()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbMidiDeviceProto midi_devices = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_midi_devices()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbAlsaManagerProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbAlsaManagerProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbAlsaManagerProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbAlsaManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 cards_parser = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->cards_parser(), output);
  }

  // repeated .android.service.usb.UsbAlsaDeviceProto alsa_devices = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->alsa_devices_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2,
      this->alsa_devices(static_cast<int>(i)),
      output);
  }

  // repeated .android.service.usb.UsbMidiDeviceProto midi_devices = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->midi_devices_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      3,
      this->midi_devices(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbAlsaManagerProto)
}

size_t UsbAlsaManagerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbAlsaManagerProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbAlsaDeviceProto alsa_devices = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->alsa_devices_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->alsa_devices(static_cast<int>(i)));
    }
  }

  // repeated .android.service.usb.UsbMidiDeviceProto midi_devices = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->midi_devices_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->midi_devices(static_cast<int>(i)));
    }
  }

  // optional int32 cards_parser = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->cards_parser());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbAlsaManagerProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbAlsaManagerProto*>(
      &from));
}

void UsbAlsaManagerProto::MergeFrom(const UsbAlsaManagerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbAlsaManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  alsa_devices_.MergeFrom(from.alsa_devices_);
  midi_devices_.MergeFrom(from.midi_devices_);
  if (from.has_cards_parser()) {
    set_cards_parser(from.cards_parser());
  }
}

void UsbAlsaManagerProto::CopyFrom(const UsbAlsaManagerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbAlsaManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbAlsaManagerProto::IsInitialized() const {
  return true;
}

void UsbAlsaManagerProto::InternalSwap(UsbAlsaManagerProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&alsa_devices_)->InternalSwap(CastToBase(&other->alsa_devices_));
  CastToBase(&midi_devices_)->InternalSwap(CastToBase(&other->midi_devices_));
  swap(cards_parser_, other->cards_parser_);
}

std::string UsbAlsaManagerProto::GetTypeName() const {
  return "android.service.usb.UsbAlsaManagerProto";
}


// ===================================================================

void UsbAlsaDeviceProto::InitAsDefaultInstance() {
}
class UsbAlsaDeviceProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbAlsaDeviceProto>()._has_bits_);
  static void set_has_card(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_device(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_has_playback(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_has_capture(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_address(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

UsbAlsaDeviceProto::UsbAlsaDeviceProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbAlsaDeviceProto)
}
UsbAlsaDeviceProto::UsbAlsaDeviceProto(const UsbAlsaDeviceProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_address()) {
    address_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  ::memcpy(&card_, &from.card_,
    static_cast<size_t>(reinterpret_cast<char*>(&has_capture_) -
    reinterpret_cast<char*>(&card_)) + sizeof(has_capture_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbAlsaDeviceProto)
}

void UsbAlsaDeviceProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbAlsaDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&card_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&has_capture_) -
      reinterpret_cast<char*>(&card_)) + sizeof(has_capture_));
}

UsbAlsaDeviceProto::~UsbAlsaDeviceProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbAlsaDeviceProto)
  SharedDtor();
}

void UsbAlsaDeviceProto::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UsbAlsaDeviceProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbAlsaDeviceProto& UsbAlsaDeviceProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbAlsaDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbAlsaDeviceProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbAlsaDeviceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      address_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&card_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&has_capture_) -
        reinterpret_cast<char*>(&card_)) + sizeof(has_capture_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbAlsaDeviceProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 card = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_card(&has_bits);
          card_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 device = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_device(&has_bits);
          device_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool has_playback = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_has_playback(&has_bits);
          has_playback_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool has_capture = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_has_capture(&has_bits);
          has_capture_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string address = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_address(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbAlsaDeviceProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbAlsaDeviceProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 card = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_card(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &card_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 device = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_device(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &device_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string name = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool has_playback = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_has_playback(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_playback_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool has_capture = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_has_capture(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_capture_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string address = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbAlsaDeviceProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbAlsaDeviceProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbAlsaDeviceProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbAlsaDeviceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 card = 1;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->card(), output);
  }

  // optional int32 device = 2;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->device(), output);
  }

  // optional string name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->name(), output);
  }

  // optional bool has_playback = 4;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(4, this->has_playback(), output);
  }

  // optional bool has_capture = 5;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(5, this->has_capture(), output);
  }

  // optional string address = 6;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->address(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbAlsaDeviceProto)
}

size_t UsbAlsaDeviceProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbAlsaDeviceProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string address = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->address());
    }

    // optional int32 card = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->card());
    }

    // optional int32 device = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->device());
    }

    // optional bool has_playback = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool has_capture = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbAlsaDeviceProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbAlsaDeviceProto*>(
      &from));
}

void UsbAlsaDeviceProto::MergeFrom(const UsbAlsaDeviceProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbAlsaDeviceProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      address_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.address_);
    }
    if (cached_has_bits & 0x00000004u) {
      card_ = from.card_;
    }
    if (cached_has_bits & 0x00000008u) {
      device_ = from.device_;
    }
    if (cached_has_bits & 0x00000010u) {
      has_playback_ = from.has_playback_;
    }
    if (cached_has_bits & 0x00000020u) {
      has_capture_ = from.has_capture_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbAlsaDeviceProto::CopyFrom(const UsbAlsaDeviceProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbAlsaDeviceProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbAlsaDeviceProto::IsInitialized() const {
  return true;
}

void UsbAlsaDeviceProto::InternalSwap(UsbAlsaDeviceProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  address_.Swap(&other->address_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(card_, other->card_);
  swap(device_, other->device_);
  swap(has_playback_, other->has_playback_);
  swap(has_capture_, other->has_capture_);
}

std::string UsbAlsaDeviceProto::GetTypeName() const {
  return "android.service.usb.UsbAlsaDeviceProto";
}


// ===================================================================

void UsbMidiDeviceProto::InitAsDefaultInstance() {
}
class UsbMidiDeviceProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbMidiDeviceProto>()._has_bits_);
  static void set_has_card(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_device(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_device_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UsbMidiDeviceProto::UsbMidiDeviceProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbMidiDeviceProto)
}
UsbMidiDeviceProto::UsbMidiDeviceProto(const UsbMidiDeviceProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  device_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_device_address()) {
    device_address_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.device_address_);
  }
  ::memcpy(&card_, &from.card_,
    static_cast<size_t>(reinterpret_cast<char*>(&device_) -
    reinterpret_cast<char*>(&card_)) + sizeof(device_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbMidiDeviceProto)
}

void UsbMidiDeviceProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbMidiDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  device_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&card_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&device_) -
      reinterpret_cast<char*>(&card_)) + sizeof(device_));
}

UsbMidiDeviceProto::~UsbMidiDeviceProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbMidiDeviceProto)
  SharedDtor();
}

void UsbMidiDeviceProto::SharedDtor() {
  device_address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UsbMidiDeviceProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbMidiDeviceProto& UsbMidiDeviceProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbMidiDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbMidiDeviceProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbMidiDeviceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    device_address_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&card_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&device_) -
        reinterpret_cast<char*>(&card_)) + sizeof(device_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbMidiDeviceProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 card = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_card(&has_bits);
          card_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 device = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_device(&has_bits);
          device_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string device_address = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_device_address(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbMidiDeviceProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbMidiDeviceProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 card = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_card(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &card_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 device = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_device(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &device_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string device_address = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_device_address()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbMidiDeviceProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbMidiDeviceProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbMidiDeviceProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbMidiDeviceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 card = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->card(), output);
  }

  // optional int32 device = 2;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->device(), output);
  }

  // optional string device_address = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->device_address(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbMidiDeviceProto)
}

size_t UsbMidiDeviceProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbMidiDeviceProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string device_address = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->device_address());
    }

    // optional int32 card = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->card());
    }

    // optional int32 device = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->device());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbMidiDeviceProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbMidiDeviceProto*>(
      &from));
}

void UsbMidiDeviceProto::MergeFrom(const UsbMidiDeviceProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbMidiDeviceProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      device_address_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.device_address_);
    }
    if (cached_has_bits & 0x00000002u) {
      card_ = from.card_;
    }
    if (cached_has_bits & 0x00000004u) {
      device_ = from.device_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbMidiDeviceProto::CopyFrom(const UsbMidiDeviceProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbMidiDeviceProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbMidiDeviceProto::IsInitialized() const {
  return true;
}

void UsbMidiDeviceProto::InternalSwap(UsbMidiDeviceProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  device_address_.Swap(&other->device_address_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(card_, other->card_);
  swap(device_, other->device_);
}

std::string UsbMidiDeviceProto::GetTypeName() const {
  return "android.service.usb.UsbMidiDeviceProto";
}


// ===================================================================

void UsbSettingsManagerProto::InitAsDefaultInstance() {
}
class UsbSettingsManagerProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbSettingsManagerProto>()._has_bits_);
};

UsbSettingsManagerProto::UsbSettingsManagerProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbSettingsManagerProto)
}
UsbSettingsManagerProto::UsbSettingsManagerProto(const UsbSettingsManagerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      user_settings_(from.user_settings_),
      profile_group_settings_(from.profile_group_settings_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbSettingsManagerProto)
}

void UsbSettingsManagerProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
}

UsbSettingsManagerProto::~UsbSettingsManagerProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbSettingsManagerProto)
  SharedDtor();
}

void UsbSettingsManagerProto::SharedDtor() {
}

void UsbSettingsManagerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbSettingsManagerProto& UsbSettingsManagerProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbSettingsManagerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbSettingsManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_settings_.Clear();
  profile_group_settings_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbSettingsManagerProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .android.service.usb.UsbUserSettingsManagerProto user_settings = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_user_settings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbProfileGroupSettingsManagerProto profile_group_settings = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_profile_group_settings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbSettingsManagerProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbSettingsManagerProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .android.service.usb.UsbUserSettingsManagerProto user_settings = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_user_settings()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbProfileGroupSettingsManagerProto profile_group_settings = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_profile_group_settings()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbSettingsManagerProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbSettingsManagerProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbSettingsManagerProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbSettingsManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbUserSettingsManagerProto user_settings = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->user_settings_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1,
      this->user_settings(static_cast<int>(i)),
      output);
  }

  // repeated .android.service.usb.UsbProfileGroupSettingsManagerProto profile_group_settings = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->profile_group_settings_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2,
      this->profile_group_settings(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbSettingsManagerProto)
}

size_t UsbSettingsManagerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbSettingsManagerProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbUserSettingsManagerProto user_settings = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->user_settings_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->user_settings(static_cast<int>(i)));
    }
  }

  // repeated .android.service.usb.UsbProfileGroupSettingsManagerProto profile_group_settings = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->profile_group_settings_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->profile_group_settings(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbSettingsManagerProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbSettingsManagerProto*>(
      &from));
}

void UsbSettingsManagerProto::MergeFrom(const UsbSettingsManagerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbSettingsManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  user_settings_.MergeFrom(from.user_settings_);
  profile_group_settings_.MergeFrom(from.profile_group_settings_);
}

void UsbSettingsManagerProto::CopyFrom(const UsbSettingsManagerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbSettingsManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbSettingsManagerProto::IsInitialized() const {
  return true;
}

void UsbSettingsManagerProto::InternalSwap(UsbSettingsManagerProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&user_settings_)->InternalSwap(CastToBase(&other->user_settings_));
  CastToBase(&profile_group_settings_)->InternalSwap(CastToBase(&other->profile_group_settings_));
}

std::string UsbSettingsManagerProto::GetTypeName() const {
  return "android.service.usb.UsbSettingsManagerProto";
}


// ===================================================================

void UsbUserSettingsManagerProto::InitAsDefaultInstance() {
}
class UsbUserSettingsManagerProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbUserSettingsManagerProto>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UsbUserSettingsManagerProto::UsbUserSettingsManagerProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbUserSettingsManagerProto)
}
UsbUserSettingsManagerProto::UsbUserSettingsManagerProto(const UsbUserSettingsManagerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      device_attached_activities_(from.device_attached_activities_),
      accessory_attached_activities_(from.accessory_attached_activities_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  user_id_ = from.user_id_;
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbUserSettingsManagerProto)
}

void UsbUserSettingsManagerProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbUserSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  user_id_ = 0;
}

UsbUserSettingsManagerProto::~UsbUserSettingsManagerProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbUserSettingsManagerProto)
  SharedDtor();
}

void UsbUserSettingsManagerProto::SharedDtor() {
}

void UsbUserSettingsManagerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbUserSettingsManagerProto& UsbUserSettingsManagerProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbUserSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbUserSettingsManagerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbUserSettingsManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  device_attached_activities_.Clear();
  accessory_attached_activities_.Clear();
  user_id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbUserSettingsManagerProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbDeviceAttachedActivities device_attached_activities = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_device_attached_activities(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 34);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbAccessoryAttachedActivities accessory_attached_activities = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_accessory_attached_activities(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 42);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbUserSettingsManagerProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbUserSettingsManagerProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 user_id = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_user_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &user_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbDeviceAttachedActivities device_attached_activities = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_device_attached_activities()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbAccessoryAttachedActivities accessory_attached_activities = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_accessory_attached_activities()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbUserSettingsManagerProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbUserSettingsManagerProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbUserSettingsManagerProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbUserSettingsManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->user_id(), output);
  }

  // repeated .android.service.usb.UsbDeviceAttachedActivities device_attached_activities = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->device_attached_activities_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      4,
      this->device_attached_activities(static_cast<int>(i)),
      output);
  }

  // repeated .android.service.usb.UsbAccessoryAttachedActivities accessory_attached_activities = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->accessory_attached_activities_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      5,
      this->accessory_attached_activities(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbUserSettingsManagerProto)
}

size_t UsbUserSettingsManagerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbUserSettingsManagerProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbDeviceAttachedActivities device_attached_activities = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->device_attached_activities_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->device_attached_activities(static_cast<int>(i)));
    }
  }

  // repeated .android.service.usb.UsbAccessoryAttachedActivities accessory_attached_activities = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->accessory_attached_activities_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->accessory_attached_activities(static_cast<int>(i)));
    }
  }

  // optional int32 user_id = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->user_id());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbUserSettingsManagerProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbUserSettingsManagerProto*>(
      &from));
}

void UsbUserSettingsManagerProto::MergeFrom(const UsbUserSettingsManagerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbUserSettingsManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  device_attached_activities_.MergeFrom(from.device_attached_activities_);
  accessory_attached_activities_.MergeFrom(from.accessory_attached_activities_);
  if (from.has_user_id()) {
    set_user_id(from.user_id());
  }
}

void UsbUserSettingsManagerProto::CopyFrom(const UsbUserSettingsManagerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbUserSettingsManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbUserSettingsManagerProto::IsInitialized() const {
  return true;
}

void UsbUserSettingsManagerProto::InternalSwap(UsbUserSettingsManagerProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&device_attached_activities_)->InternalSwap(CastToBase(&other->device_attached_activities_));
  CastToBase(&accessory_attached_activities_)->InternalSwap(CastToBase(&other->accessory_attached_activities_));
  swap(user_id_, other->user_id_);
}

std::string UsbUserSettingsManagerProto::GetTypeName() const {
  return "android.service.usb.UsbUserSettingsManagerProto";
}


// ===================================================================

void UsbProfileGroupSettingsManagerProto::InitAsDefaultInstance() {
}
class UsbProfileGroupSettingsManagerProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbProfileGroupSettingsManagerProto>()._has_bits_);
  static void set_has_parent_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UsbProfileGroupSettingsManagerProto::UsbProfileGroupSettingsManagerProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbProfileGroupSettingsManagerProto)
}
UsbProfileGroupSettingsManagerProto::UsbProfileGroupSettingsManagerProto(const UsbProfileGroupSettingsManagerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      device_preferences_(from.device_preferences_),
      accessory_preferences_(from.accessory_preferences_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  parent_user_id_ = from.parent_user_id_;
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbProfileGroupSettingsManagerProto)
}

void UsbProfileGroupSettingsManagerProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbProfileGroupSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  parent_user_id_ = 0;
}

UsbProfileGroupSettingsManagerProto::~UsbProfileGroupSettingsManagerProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbProfileGroupSettingsManagerProto)
  SharedDtor();
}

void UsbProfileGroupSettingsManagerProto::SharedDtor() {
}

void UsbProfileGroupSettingsManagerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbProfileGroupSettingsManagerProto& UsbProfileGroupSettingsManagerProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbProfileGroupSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbProfileGroupSettingsManagerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbProfileGroupSettingsManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  device_preferences_.Clear();
  accessory_preferences_.Clear();
  parent_user_id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbProfileGroupSettingsManagerProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 parent_user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_parent_user_id(&has_bits);
          parent_user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbSettingsDevicePreferenceProto device_preferences = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_device_preferences(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbSettingsAccessoryPreferenceProto accessory_preferences = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_accessory_preferences(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 26);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbProfileGroupSettingsManagerProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbProfileGroupSettingsManagerProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 parent_user_id = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_parent_user_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &parent_user_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbSettingsDevicePreferenceProto device_preferences = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_device_preferences()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbSettingsAccessoryPreferenceProto accessory_preferences = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_accessory_preferences()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbProfileGroupSettingsManagerProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbProfileGroupSettingsManagerProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbProfileGroupSettingsManagerProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbProfileGroupSettingsManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 parent_user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->parent_user_id(), output);
  }

  // repeated .android.service.usb.UsbSettingsDevicePreferenceProto device_preferences = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->device_preferences_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2,
      this->device_preferences(static_cast<int>(i)),
      output);
  }

  // repeated .android.service.usb.UsbSettingsAccessoryPreferenceProto accessory_preferences = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->accessory_preferences_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      3,
      this->accessory_preferences(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbProfileGroupSettingsManagerProto)
}

size_t UsbProfileGroupSettingsManagerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbProfileGroupSettingsManagerProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbSettingsDevicePreferenceProto device_preferences = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->device_preferences_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->device_preferences(static_cast<int>(i)));
    }
  }

  // repeated .android.service.usb.UsbSettingsAccessoryPreferenceProto accessory_preferences = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->accessory_preferences_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->accessory_preferences(static_cast<int>(i)));
    }
  }

  // optional int32 parent_user_id = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->parent_user_id());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbProfileGroupSettingsManagerProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbProfileGroupSettingsManagerProto*>(
      &from));
}

void UsbProfileGroupSettingsManagerProto::MergeFrom(const UsbProfileGroupSettingsManagerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbProfileGroupSettingsManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  device_preferences_.MergeFrom(from.device_preferences_);
  accessory_preferences_.MergeFrom(from.accessory_preferences_);
  if (from.has_parent_user_id()) {
    set_parent_user_id(from.parent_user_id());
  }
}

void UsbProfileGroupSettingsManagerProto::CopyFrom(const UsbProfileGroupSettingsManagerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbProfileGroupSettingsManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbProfileGroupSettingsManagerProto::IsInitialized() const {
  return true;
}

void UsbProfileGroupSettingsManagerProto::InternalSwap(UsbProfileGroupSettingsManagerProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&device_preferences_)->InternalSwap(CastToBase(&other->device_preferences_));
  CastToBase(&accessory_preferences_)->InternalSwap(CastToBase(&other->accessory_preferences_));
  swap(parent_user_id_, other->parent_user_id_);
}

std::string UsbProfileGroupSettingsManagerProto::GetTypeName() const {
  return "android.service.usb.UsbProfileGroupSettingsManagerProto";
}


// ===================================================================

void UsbSettingsDevicePreferenceProto::InitAsDefaultInstance() {
  ::android::service::usb::_UsbSettingsDevicePreferenceProto_default_instance_._instance.get_mutable()->filter_ = const_cast< ::android::service::usb::UsbDeviceFilterProto*>(
      ::android::service::usb::UsbDeviceFilterProto::internal_default_instance());
  ::android::service::usb::_UsbSettingsDevicePreferenceProto_default_instance_._instance.get_mutable()->user_package_ = const_cast< ::android::service::usb::UserPackageProto*>(
      ::android::service::usb::UserPackageProto::internal_default_instance());
}
class UsbSettingsDevicePreferenceProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbSettingsDevicePreferenceProto>()._has_bits_);
  static const ::android::service::usb::UsbDeviceFilterProto& filter(const UsbSettingsDevicePreferenceProto* msg);
  static void set_has_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::android::service::usb::UserPackageProto& user_package(const UsbSettingsDevicePreferenceProto* msg);
  static void set_has_user_package(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::android::service::usb::UsbDeviceFilterProto&
UsbSettingsDevicePreferenceProto::_Internal::filter(const UsbSettingsDevicePreferenceProto* msg) {
  return *msg->filter_;
}
const ::android::service::usb::UserPackageProto&
UsbSettingsDevicePreferenceProto::_Internal::user_package(const UsbSettingsDevicePreferenceProto* msg) {
  return *msg->user_package_;
}
UsbSettingsDevicePreferenceProto::UsbSettingsDevicePreferenceProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbSettingsDevicePreferenceProto)
}
UsbSettingsDevicePreferenceProto::UsbSettingsDevicePreferenceProto(const UsbSettingsDevicePreferenceProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_filter()) {
    filter_ = new ::android::service::usb::UsbDeviceFilterProto(*from.filter_);
  } else {
    filter_ = nullptr;
  }
  if (from.has_user_package()) {
    user_package_ = new ::android::service::usb::UserPackageProto(*from.user_package_);
  } else {
    user_package_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbSettingsDevicePreferenceProto)
}

void UsbSettingsDevicePreferenceProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbSettingsDevicePreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  ::memset(&filter_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&user_package_) -
      reinterpret_cast<char*>(&filter_)) + sizeof(user_package_));
}

UsbSettingsDevicePreferenceProto::~UsbSettingsDevicePreferenceProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbSettingsDevicePreferenceProto)
  SharedDtor();
}

void UsbSettingsDevicePreferenceProto::SharedDtor() {
  if (this != internal_default_instance()) delete filter_;
  if (this != internal_default_instance()) delete user_package_;
}

void UsbSettingsDevicePreferenceProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbSettingsDevicePreferenceProto& UsbSettingsDevicePreferenceProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbSettingsDevicePreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbSettingsDevicePreferenceProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbSettingsDevicePreferenceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(filter_ != nullptr);
      filter_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(user_package_ != nullptr);
      user_package_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbSettingsDevicePreferenceProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .android.service.usb.UsbDeviceFilterProto filter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_filter(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UserPackageProto user_package = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_user_package(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbSettingsDevicePreferenceProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbSettingsDevicePreferenceProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .android.service.usb.UsbDeviceFilterProto filter = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_filter()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UserPackageProto user_package = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_user_package()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbSettingsDevicePreferenceProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbSettingsDevicePreferenceProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbSettingsDevicePreferenceProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbSettingsDevicePreferenceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.service.usb.UsbDeviceFilterProto filter = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1, _Internal::filter(this), output);
  }

  // optional .android.service.usb.UserPackageProto user_package = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2, _Internal::user_package(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbSettingsDevicePreferenceProto)
}

size_t UsbSettingsDevicePreferenceProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbSettingsDevicePreferenceProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .android.service.usb.UsbDeviceFilterProto filter = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *filter_);
    }

    // optional .android.service.usb.UserPackageProto user_package = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *user_package_);
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbSettingsDevicePreferenceProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbSettingsDevicePreferenceProto*>(
      &from));
}

void UsbSettingsDevicePreferenceProto::MergeFrom(const UsbSettingsDevicePreferenceProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbSettingsDevicePreferenceProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_filter()->::android::service::usb::UsbDeviceFilterProto::MergeFrom(from.filter());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_user_package()->::android::service::usb::UserPackageProto::MergeFrom(from.user_package());
    }
  }
}

void UsbSettingsDevicePreferenceProto::CopyFrom(const UsbSettingsDevicePreferenceProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbSettingsDevicePreferenceProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbSettingsDevicePreferenceProto::IsInitialized() const {
  return true;
}

void UsbSettingsDevicePreferenceProto::InternalSwap(UsbSettingsDevicePreferenceProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(filter_, other->filter_);
  swap(user_package_, other->user_package_);
}

std::string UsbSettingsDevicePreferenceProto::GetTypeName() const {
  return "android.service.usb.UsbSettingsDevicePreferenceProto";
}


// ===================================================================

void UsbPermissionsManagerProto::InitAsDefaultInstance() {
}
class UsbPermissionsManagerProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbPermissionsManagerProto>()._has_bits_);
};

UsbPermissionsManagerProto::UsbPermissionsManagerProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbPermissionsManagerProto)
}
UsbPermissionsManagerProto::UsbPermissionsManagerProto(const UsbPermissionsManagerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      user_permissions_(from.user_permissions_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbPermissionsManagerProto)
}

void UsbPermissionsManagerProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
}

UsbPermissionsManagerProto::~UsbPermissionsManagerProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbPermissionsManagerProto)
  SharedDtor();
}

void UsbPermissionsManagerProto::SharedDtor() {
}

void UsbPermissionsManagerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbPermissionsManagerProto& UsbPermissionsManagerProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbPermissionsManagerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbPermissionsManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_permissions_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbPermissionsManagerProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .android.service.usb.UsbUserPermissionsManagerProto user_permissions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_user_permissions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbPermissionsManagerProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbPermissionsManagerProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .android.service.usb.UsbUserPermissionsManagerProto user_permissions = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_user_permissions()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbPermissionsManagerProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbPermissionsManagerProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbPermissionsManagerProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbPermissionsManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbUserPermissionsManagerProto user_permissions = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->user_permissions_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1,
      this->user_permissions(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbPermissionsManagerProto)
}

size_t UsbPermissionsManagerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbPermissionsManagerProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbUserPermissionsManagerProto user_permissions = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->user_permissions_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->user_permissions(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbPermissionsManagerProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbPermissionsManagerProto*>(
      &from));
}

void UsbPermissionsManagerProto::MergeFrom(const UsbPermissionsManagerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbPermissionsManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  user_permissions_.MergeFrom(from.user_permissions_);
}

void UsbPermissionsManagerProto::CopyFrom(const UsbPermissionsManagerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbPermissionsManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbPermissionsManagerProto::IsInitialized() const {
  return true;
}

void UsbPermissionsManagerProto::InternalSwap(UsbPermissionsManagerProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&user_permissions_)->InternalSwap(CastToBase(&other->user_permissions_));
}

std::string UsbPermissionsManagerProto::GetTypeName() const {
  return "android.service.usb.UsbPermissionsManagerProto";
}


// ===================================================================

void UsbUserPermissionsManagerProto::InitAsDefaultInstance() {
}
class UsbUserPermissionsManagerProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbUserPermissionsManagerProto>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UsbUserPermissionsManagerProto::UsbUserPermissionsManagerProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbUserPermissionsManagerProto)
}
UsbUserPermissionsManagerProto::UsbUserPermissionsManagerProto(const UsbUserPermissionsManagerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      device_permissions_(from.device_permissions_),
      accessory_permissions_(from.accessory_permissions_),
      device_persistent_permissions_(from.device_persistent_permissions_),
      accessory_persistent_permissions_(from.accessory_persistent_permissions_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  user_id_ = from.user_id_;
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbUserPermissionsManagerProto)
}

void UsbUserPermissionsManagerProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbUserPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  user_id_ = 0;
}

UsbUserPermissionsManagerProto::~UsbUserPermissionsManagerProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbUserPermissionsManagerProto)
  SharedDtor();
}

void UsbUserPermissionsManagerProto::SharedDtor() {
}

void UsbUserPermissionsManagerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbUserPermissionsManagerProto& UsbUserPermissionsManagerProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbUserPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbUserPermissionsManagerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbUserPermissionsManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  device_permissions_.Clear();
  accessory_permissions_.Clear();
  device_persistent_permissions_.Clear();
  accessory_persistent_permissions_.Clear();
  user_id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbUserPermissionsManagerProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbDevicePermissionProto device_permissions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_device_permissions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbAccessoryPermissionProto accessory_permissions = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_accessory_permissions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 26);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbDevicePersistentPermissionProto device_persistent_permissions = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_device_persistent_permissions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 34);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbAccessoryPersistentPermissionProto accessory_persistent_permissions = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_accessory_persistent_permissions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 42);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbUserPermissionsManagerProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbUserPermissionsManagerProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 user_id = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_user_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &user_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbDevicePermissionProto device_permissions = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_device_permissions()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbAccessoryPermissionProto accessory_permissions = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_accessory_permissions()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbDevicePersistentPermissionProto device_persistent_permissions = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_device_persistent_permissions()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbAccessoryPersistentPermissionProto accessory_persistent_permissions = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_accessory_persistent_permissions()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbUserPermissionsManagerProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbUserPermissionsManagerProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbUserPermissionsManagerProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbUserPermissionsManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->user_id(), output);
  }

  // repeated .android.service.usb.UsbDevicePermissionProto device_permissions = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->device_permissions_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2,
      this->device_permissions(static_cast<int>(i)),
      output);
  }

  // repeated .android.service.usb.UsbAccessoryPermissionProto accessory_permissions = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->accessory_permissions_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      3,
      this->accessory_permissions(static_cast<int>(i)),
      output);
  }

  // repeated .android.service.usb.UsbDevicePersistentPermissionProto device_persistent_permissions = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->device_persistent_permissions_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      4,
      this->device_persistent_permissions(static_cast<int>(i)),
      output);
  }

  // repeated .android.service.usb.UsbAccessoryPersistentPermissionProto accessory_persistent_permissions = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->accessory_persistent_permissions_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      5,
      this->accessory_persistent_permissions(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbUserPermissionsManagerProto)
}

size_t UsbUserPermissionsManagerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbUserPermissionsManagerProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbDevicePermissionProto device_permissions = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->device_permissions_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->device_permissions(static_cast<int>(i)));
    }
  }

  // repeated .android.service.usb.UsbAccessoryPermissionProto accessory_permissions = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->accessory_permissions_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->accessory_permissions(static_cast<int>(i)));
    }
  }

  // repeated .android.service.usb.UsbDevicePersistentPermissionProto device_persistent_permissions = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->device_persistent_permissions_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->device_persistent_permissions(static_cast<int>(i)));
    }
  }

  // repeated .android.service.usb.UsbAccessoryPersistentPermissionProto accessory_persistent_permissions = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->accessory_persistent_permissions_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->accessory_persistent_permissions(static_cast<int>(i)));
    }
  }

  // optional int32 user_id = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->user_id());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbUserPermissionsManagerProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbUserPermissionsManagerProto*>(
      &from));
}

void UsbUserPermissionsManagerProto::MergeFrom(const UsbUserPermissionsManagerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbUserPermissionsManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  device_permissions_.MergeFrom(from.device_permissions_);
  accessory_permissions_.MergeFrom(from.accessory_permissions_);
  device_persistent_permissions_.MergeFrom(from.device_persistent_permissions_);
  accessory_persistent_permissions_.MergeFrom(from.accessory_persistent_permissions_);
  if (from.has_user_id()) {
    set_user_id(from.user_id());
  }
}

void UsbUserPermissionsManagerProto::CopyFrom(const UsbUserPermissionsManagerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbUserPermissionsManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbUserPermissionsManagerProto::IsInitialized() const {
  return true;
}

void UsbUserPermissionsManagerProto::InternalSwap(UsbUserPermissionsManagerProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&device_permissions_)->InternalSwap(CastToBase(&other->device_permissions_));
  CastToBase(&accessory_permissions_)->InternalSwap(CastToBase(&other->accessory_permissions_));
  CastToBase(&device_persistent_permissions_)->InternalSwap(CastToBase(&other->device_persistent_permissions_));
  CastToBase(&accessory_persistent_permissions_)->InternalSwap(CastToBase(&other->accessory_persistent_permissions_));
  swap(user_id_, other->user_id_);
}

std::string UsbUserPermissionsManagerProto::GetTypeName() const {
  return "android.service.usb.UsbUserPermissionsManagerProto";
}


// ===================================================================

void UsbDevicePermissionProto::InitAsDefaultInstance() {
}
class UsbDevicePermissionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbDevicePermissionProto>()._has_bits_);
  static void set_has_device_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UsbDevicePermissionProto::UsbDevicePermissionProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbDevicePermissionProto)
}
UsbDevicePermissionProto::UsbDevicePermissionProto(const UsbDevicePermissionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      uids_(from.uids_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  device_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_device_name()) {
    device_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.device_name_);
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbDevicePermissionProto)
}

void UsbDevicePermissionProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbDevicePermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  device_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

UsbDevicePermissionProto::~UsbDevicePermissionProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbDevicePermissionProto)
  SharedDtor();
}

void UsbDevicePermissionProto::SharedDtor() {
  device_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UsbDevicePermissionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbDevicePermissionProto& UsbDevicePermissionProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbDevicePermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbDevicePermissionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbDevicePermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  uids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    device_name_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbDevicePermissionProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string device_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_device_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int32 uids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_uids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 16);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(mutable_uids(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbDevicePermissionProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbDevicePermissionProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string device_name = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_device_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int32 uids = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 1, 16u, input, this->mutable_uids())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_uids())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbDevicePermissionProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbDevicePermissionProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbDevicePermissionProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbDevicePermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string device_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->device_name(), output);
  }

  // repeated int32 uids = 2;
  for (int i = 0, n = this->uids_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(
      2, this->uids(i), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbDevicePermissionProto)
}

size_t UsbDevicePermissionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbDevicePermissionProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 uids = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->uids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->uids_size());
    total_size += data_size;
  }

  // optional string device_name = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->device_name());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbDevicePermissionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbDevicePermissionProto*>(
      &from));
}

void UsbDevicePermissionProto::MergeFrom(const UsbDevicePermissionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbDevicePermissionProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  uids_.MergeFrom(from.uids_);
  if (from.has_device_name()) {
    _has_bits_[0] |= 0x00000001u;
    device_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.device_name_);
  }
}

void UsbDevicePermissionProto::CopyFrom(const UsbDevicePermissionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbDevicePermissionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbDevicePermissionProto::IsInitialized() const {
  return true;
}

void UsbDevicePermissionProto::InternalSwap(UsbDevicePermissionProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  uids_.InternalSwap(&other->uids_);
  device_name_.Swap(&other->device_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

std::string UsbDevicePermissionProto::GetTypeName() const {
  return "android.service.usb.UsbDevicePermissionProto";
}


// ===================================================================

void UsbAccessoryPermissionProto::InitAsDefaultInstance() {
}
class UsbAccessoryPermissionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbAccessoryPermissionProto>()._has_bits_);
  static void set_has_accessory_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UsbAccessoryPermissionProto::UsbAccessoryPermissionProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbAccessoryPermissionProto)
}
UsbAccessoryPermissionProto::UsbAccessoryPermissionProto(const UsbAccessoryPermissionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      uids_(from.uids_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  accessory_description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_accessory_description()) {
    accessory_description_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.accessory_description_);
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbAccessoryPermissionProto)
}

void UsbAccessoryPermissionProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbAccessoryPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  accessory_description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

UsbAccessoryPermissionProto::~UsbAccessoryPermissionProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbAccessoryPermissionProto)
  SharedDtor();
}

void UsbAccessoryPermissionProto::SharedDtor() {
  accessory_description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UsbAccessoryPermissionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbAccessoryPermissionProto& UsbAccessoryPermissionProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbAccessoryPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbAccessoryPermissionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbAccessoryPermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  uids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    accessory_description_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbAccessoryPermissionProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string accessory_description = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_accessory_description(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int32 uids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_uids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 16);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(mutable_uids(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbAccessoryPermissionProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbAccessoryPermissionProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string accessory_description = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_accessory_description()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int32 uids = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 1, 16u, input, this->mutable_uids())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_uids())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbAccessoryPermissionProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbAccessoryPermissionProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbAccessoryPermissionProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbAccessoryPermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string accessory_description = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->accessory_description(), output);
  }

  // repeated int32 uids = 2;
  for (int i = 0, n = this->uids_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(
      2, this->uids(i), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbAccessoryPermissionProto)
}

size_t UsbAccessoryPermissionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbAccessoryPermissionProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 uids = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->uids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->uids_size());
    total_size += data_size;
  }

  // optional string accessory_description = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->accessory_description());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbAccessoryPermissionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbAccessoryPermissionProto*>(
      &from));
}

void UsbAccessoryPermissionProto::MergeFrom(const UsbAccessoryPermissionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbAccessoryPermissionProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  uids_.MergeFrom(from.uids_);
  if (from.has_accessory_description()) {
    _has_bits_[0] |= 0x00000001u;
    accessory_description_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.accessory_description_);
  }
}

void UsbAccessoryPermissionProto::CopyFrom(const UsbAccessoryPermissionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbAccessoryPermissionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbAccessoryPermissionProto::IsInitialized() const {
  return true;
}

void UsbAccessoryPermissionProto::InternalSwap(UsbAccessoryPermissionProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  uids_.InternalSwap(&other->uids_);
  accessory_description_.Swap(&other->accessory_description_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

std::string UsbAccessoryPermissionProto::GetTypeName() const {
  return "android.service.usb.UsbAccessoryPermissionProto";
}


// ===================================================================

void UsbDevicePersistentPermissionProto::InitAsDefaultInstance() {
  ::android::service::usb::_UsbDevicePersistentPermissionProto_default_instance_._instance.get_mutable()->device_filter_ = const_cast< ::android::service::usb::UsbDeviceFilterProto*>(
      ::android::service::usb::UsbDeviceFilterProto::internal_default_instance());
}
class UsbDevicePersistentPermissionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbDevicePersistentPermissionProto>()._has_bits_);
  static const ::android::service::usb::UsbDeviceFilterProto& device_filter(const UsbDevicePersistentPermissionProto* msg);
  static void set_has_device_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::android::service::usb::UsbDeviceFilterProto&
UsbDevicePersistentPermissionProto::_Internal::device_filter(const UsbDevicePersistentPermissionProto* msg) {
  return *msg->device_filter_;
}
UsbDevicePersistentPermissionProto::UsbDevicePersistentPermissionProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbDevicePersistentPermissionProto)
}
UsbDevicePersistentPermissionProto::UsbDevicePersistentPermissionProto(const UsbDevicePersistentPermissionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      permission_values_(from.permission_values_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_device_filter()) {
    device_filter_ = new ::android::service::usb::UsbDeviceFilterProto(*from.device_filter_);
  } else {
    device_filter_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbDevicePersistentPermissionProto)
}

void UsbDevicePersistentPermissionProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbDevicePersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  device_filter_ = nullptr;
}

UsbDevicePersistentPermissionProto::~UsbDevicePersistentPermissionProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbDevicePersistentPermissionProto)
  SharedDtor();
}

void UsbDevicePersistentPermissionProto::SharedDtor() {
  if (this != internal_default_instance()) delete device_filter_;
}

void UsbDevicePersistentPermissionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbDevicePersistentPermissionProto& UsbDevicePersistentPermissionProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbDevicePersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbDevicePersistentPermissionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbDevicePersistentPermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  permission_values_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(device_filter_ != nullptr);
    device_filter_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbDevicePersistentPermissionProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .android.service.usb.UsbDeviceFilterProto device_filter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_device_filter(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbUidPermissionProto permission_values = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_permission_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbDevicePersistentPermissionProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbDevicePersistentPermissionProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .android.service.usb.UsbDeviceFilterProto device_filter = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_device_filter()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbUidPermissionProto permission_values = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_permission_values()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbDevicePersistentPermissionProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbDevicePersistentPermissionProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbDevicePersistentPermissionProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbDevicePersistentPermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.service.usb.UsbDeviceFilterProto device_filter = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1, _Internal::device_filter(this), output);
  }

  // repeated .android.service.usb.UsbUidPermissionProto permission_values = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->permission_values_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2,
      this->permission_values(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbDevicePersistentPermissionProto)
}

size_t UsbDevicePersistentPermissionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbDevicePersistentPermissionProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbUidPermissionProto permission_values = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->permission_values_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->permission_values(static_cast<int>(i)));
    }
  }

  // optional .android.service.usb.UsbDeviceFilterProto device_filter = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *device_filter_);
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbDevicePersistentPermissionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbDevicePersistentPermissionProto*>(
      &from));
}

void UsbDevicePersistentPermissionProto::MergeFrom(const UsbDevicePersistentPermissionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbDevicePersistentPermissionProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  permission_values_.MergeFrom(from.permission_values_);
  if (from.has_device_filter()) {
    mutable_device_filter()->::android::service::usb::UsbDeviceFilterProto::MergeFrom(from.device_filter());
  }
}

void UsbDevicePersistentPermissionProto::CopyFrom(const UsbDevicePersistentPermissionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbDevicePersistentPermissionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbDevicePersistentPermissionProto::IsInitialized() const {
  return true;
}

void UsbDevicePersistentPermissionProto::InternalSwap(UsbDevicePersistentPermissionProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&permission_values_)->InternalSwap(CastToBase(&other->permission_values_));
  swap(device_filter_, other->device_filter_);
}

std::string UsbDevicePersistentPermissionProto::GetTypeName() const {
  return "android.service.usb.UsbDevicePersistentPermissionProto";
}


// ===================================================================

void UsbAccessoryPersistentPermissionProto::InitAsDefaultInstance() {
  ::android::service::usb::_UsbAccessoryPersistentPermissionProto_default_instance_._instance.get_mutable()->accessory_filter_ = const_cast< ::android::service::usb::UsbAccessoryFilterProto*>(
      ::android::service::usb::UsbAccessoryFilterProto::internal_default_instance());
}
class UsbAccessoryPersistentPermissionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbAccessoryPersistentPermissionProto>()._has_bits_);
  static const ::android::service::usb::UsbAccessoryFilterProto& accessory_filter(const UsbAccessoryPersistentPermissionProto* msg);
  static void set_has_accessory_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::android::service::usb::UsbAccessoryFilterProto&
UsbAccessoryPersistentPermissionProto::_Internal::accessory_filter(const UsbAccessoryPersistentPermissionProto* msg) {
  return *msg->accessory_filter_;
}
UsbAccessoryPersistentPermissionProto::UsbAccessoryPersistentPermissionProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbAccessoryPersistentPermissionProto)
}
UsbAccessoryPersistentPermissionProto::UsbAccessoryPersistentPermissionProto(const UsbAccessoryPersistentPermissionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      permission_values_(from.permission_values_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_accessory_filter()) {
    accessory_filter_ = new ::android::service::usb::UsbAccessoryFilterProto(*from.accessory_filter_);
  } else {
    accessory_filter_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbAccessoryPersistentPermissionProto)
}

void UsbAccessoryPersistentPermissionProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbAccessoryPersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  accessory_filter_ = nullptr;
}

UsbAccessoryPersistentPermissionProto::~UsbAccessoryPersistentPermissionProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbAccessoryPersistentPermissionProto)
  SharedDtor();
}

void UsbAccessoryPersistentPermissionProto::SharedDtor() {
  if (this != internal_default_instance()) delete accessory_filter_;
}

void UsbAccessoryPersistentPermissionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbAccessoryPersistentPermissionProto& UsbAccessoryPersistentPermissionProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbAccessoryPersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbAccessoryPersistentPermissionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbAccessoryPersistentPermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  permission_values_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(accessory_filter_ != nullptr);
    accessory_filter_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbAccessoryPersistentPermissionProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .android.service.usb.UsbAccessoryFilterProto accessory_filter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_accessory_filter(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbUidPermissionProto permission_values = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_permission_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbAccessoryPersistentPermissionProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbAccessoryPersistentPermissionProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .android.service.usb.UsbAccessoryFilterProto accessory_filter = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_accessory_filter()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbUidPermissionProto permission_values = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_permission_values()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbAccessoryPersistentPermissionProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbAccessoryPersistentPermissionProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbAccessoryPersistentPermissionProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbAccessoryPersistentPermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.service.usb.UsbAccessoryFilterProto accessory_filter = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1, _Internal::accessory_filter(this), output);
  }

  // repeated .android.service.usb.UsbUidPermissionProto permission_values = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->permission_values_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2,
      this->permission_values(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbAccessoryPersistentPermissionProto)
}

size_t UsbAccessoryPersistentPermissionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbAccessoryPersistentPermissionProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbUidPermissionProto permission_values = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->permission_values_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->permission_values(static_cast<int>(i)));
    }
  }

  // optional .android.service.usb.UsbAccessoryFilterProto accessory_filter = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *accessory_filter_);
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbAccessoryPersistentPermissionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbAccessoryPersistentPermissionProto*>(
      &from));
}

void UsbAccessoryPersistentPermissionProto::MergeFrom(const UsbAccessoryPersistentPermissionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbAccessoryPersistentPermissionProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  permission_values_.MergeFrom(from.permission_values_);
  if (from.has_accessory_filter()) {
    mutable_accessory_filter()->::android::service::usb::UsbAccessoryFilterProto::MergeFrom(from.accessory_filter());
  }
}

void UsbAccessoryPersistentPermissionProto::CopyFrom(const UsbAccessoryPersistentPermissionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbAccessoryPersistentPermissionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbAccessoryPersistentPermissionProto::IsInitialized() const {
  return true;
}

void UsbAccessoryPersistentPermissionProto::InternalSwap(UsbAccessoryPersistentPermissionProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&permission_values_)->InternalSwap(CastToBase(&other->permission_values_));
  swap(accessory_filter_, other->accessory_filter_);
}

std::string UsbAccessoryPersistentPermissionProto::GetTypeName() const {
  return "android.service.usb.UsbAccessoryPersistentPermissionProto";
}


// ===================================================================

void UsbUidPermissionProto::InitAsDefaultInstance() {
}
class UsbUidPermissionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbUidPermissionProto>()._has_bits_);
  static void set_has_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_granted(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

UsbUidPermissionProto::UsbUidPermissionProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbUidPermissionProto)
}
UsbUidPermissionProto::UsbUidPermissionProto(const UsbUidPermissionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&uid_, &from.uid_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_granted_) -
    reinterpret_cast<char*>(&uid_)) + sizeof(is_granted_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbUidPermissionProto)
}

void UsbUidPermissionProto::SharedCtor() {
  ::memset(&uid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_granted_) -
      reinterpret_cast<char*>(&uid_)) + sizeof(is_granted_));
}

UsbUidPermissionProto::~UsbUidPermissionProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbUidPermissionProto)
  SharedDtor();
}

void UsbUidPermissionProto::SharedDtor() {
}

void UsbUidPermissionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbUidPermissionProto& UsbUidPermissionProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbUidPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbUidPermissionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbUidPermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&uid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_granted_) -
        reinterpret_cast<char*>(&uid_)) + sizeof(is_granted_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbUidPermissionProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 uid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_uid(&has_bits);
          uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_granted = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_is_granted(&has_bits);
          is_granted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbUidPermissionProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbUidPermissionProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 uid = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_uid(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &uid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool is_granted = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_is_granted(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_granted_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbUidPermissionProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbUidPermissionProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbUidPermissionProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbUidPermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 uid = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->uid(), output);
  }

  // optional bool is_granted = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(2, this->is_granted(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbUidPermissionProto)
}

size_t UsbUidPermissionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbUidPermissionProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 uid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->uid());
    }

    // optional bool is_granted = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbUidPermissionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbUidPermissionProto*>(
      &from));
}

void UsbUidPermissionProto::MergeFrom(const UsbUidPermissionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbUidPermissionProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      uid_ = from.uid_;
    }
    if (cached_has_bits & 0x00000002u) {
      is_granted_ = from.is_granted_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbUidPermissionProto::CopyFrom(const UsbUidPermissionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbUidPermissionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbUidPermissionProto::IsInitialized() const {
  return true;
}

void UsbUidPermissionProto::InternalSwap(UsbUidPermissionProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(uid_, other->uid_);
  swap(is_granted_, other->is_granted_);
}

std::string UsbUidPermissionProto::GetTypeName() const {
  return "android.service.usb.UsbUidPermissionProto";
}


// ===================================================================

void UsbDeviceFilterProto::InitAsDefaultInstance() {
}
class UsbDeviceFilterProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbDeviceFilterProto>()._has_bits_);
  static void set_has_vendor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_product_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_class_(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_subclass(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_protocol(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_manufacturer_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_product_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_serial_number(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

UsbDeviceFilterProto::UsbDeviceFilterProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbDeviceFilterProto)
}
UsbDeviceFilterProto::UsbDeviceFilterProto(const UsbDeviceFilterProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  manufacturer_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_manufacturer_name()) {
    manufacturer_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.manufacturer_name_);
  }
  product_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_product_name()) {
    product_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.product_name_);
  }
  serial_number_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_serial_number()) {
    serial_number_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.serial_number_);
  }
  ::memcpy(&vendor_id_, &from.vendor_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&protocol_) -
    reinterpret_cast<char*>(&vendor_id_)) + sizeof(protocol_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbDeviceFilterProto)
}

void UsbDeviceFilterProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbDeviceFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  manufacturer_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  product_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  serial_number_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&vendor_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&protocol_) -
      reinterpret_cast<char*>(&vendor_id_)) + sizeof(protocol_));
}

UsbDeviceFilterProto::~UsbDeviceFilterProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbDeviceFilterProto)
  SharedDtor();
}

void UsbDeviceFilterProto::SharedDtor() {
  manufacturer_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  product_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  serial_number_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UsbDeviceFilterProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbDeviceFilterProto& UsbDeviceFilterProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbDeviceFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbDeviceFilterProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbDeviceFilterProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      manufacturer_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      product_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      serial_number_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&vendor_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&protocol_) -
        reinterpret_cast<char*>(&vendor_id_)) + sizeof(protocol_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbDeviceFilterProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 vendor_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_vendor_id(&has_bits);
          vendor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 product_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_product_id(&has_bits);
          product_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 class = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_class_(&has_bits);
          class__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 subclass = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_subclass(&has_bits);
          subclass_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 protocol = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_protocol(&has_bits);
          protocol_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string manufacturer_name = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_manufacturer_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string product_name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_product_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string serial_number = 8 [(.android.privacy) = {
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_serial_number(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbDeviceFilterProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbDeviceFilterProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 vendor_id = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_vendor_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &vendor_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 product_id = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_product_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &product_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 class = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_class_(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &class__)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 subclass = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_subclass(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &subclass_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 protocol = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_protocol(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &protocol_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string manufacturer_name = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_manufacturer_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string product_name = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (58 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_product_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string serial_number = 8 [(.android.privacy) = {
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (66 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_serial_number()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbDeviceFilterProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbDeviceFilterProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbDeviceFilterProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbDeviceFilterProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 vendor_id = 1;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->vendor_id(), output);
  }

  // optional int32 product_id = 2;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->product_id(), output);
  }

  // optional int32 class = 3;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->class_(), output);
  }

  // optional int32 subclass = 4;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->subclass(), output);
  }

  // optional int32 protocol = 5;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->protocol(), output);
  }

  // optional string manufacturer_name = 6;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->manufacturer_name(), output);
  }

  // optional string product_name = 7;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->product_name(), output);
  }

  // optional string serial_number = 8 [(.android.privacy) = {
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->serial_number(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbDeviceFilterProto)
}

size_t UsbDeviceFilterProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbDeviceFilterProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string manufacturer_name = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->manufacturer_name());
    }

    // optional string product_name = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->product_name());
    }

    // optional string serial_number = 8 [(.android.privacy) = {
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->serial_number());
    }

    // optional int32 vendor_id = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->vendor_id());
    }

    // optional int32 product_id = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->product_id());
    }

    // optional int32 class = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->class_());
    }

    // optional int32 subclass = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->subclass());
    }

    // optional int32 protocol = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->protocol());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbDeviceFilterProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbDeviceFilterProto*>(
      &from));
}

void UsbDeviceFilterProto::MergeFrom(const UsbDeviceFilterProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbDeviceFilterProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      manufacturer_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.manufacturer_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      product_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.product_name_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      serial_number_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.serial_number_);
    }
    if (cached_has_bits & 0x00000008u) {
      vendor_id_ = from.vendor_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      product_id_ = from.product_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      class__ = from.class__;
    }
    if (cached_has_bits & 0x00000040u) {
      subclass_ = from.subclass_;
    }
    if (cached_has_bits & 0x00000080u) {
      protocol_ = from.protocol_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbDeviceFilterProto::CopyFrom(const UsbDeviceFilterProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbDeviceFilterProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbDeviceFilterProto::IsInitialized() const {
  return true;
}

void UsbDeviceFilterProto::InternalSwap(UsbDeviceFilterProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  manufacturer_name_.Swap(&other->manufacturer_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  product_name_.Swap(&other->product_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  serial_number_.Swap(&other->serial_number_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(vendor_id_, other->vendor_id_);
  swap(product_id_, other->product_id_);
  swap(class__, other->class__);
  swap(subclass_, other->subclass_);
  swap(protocol_, other->protocol_);
}

std::string UsbDeviceFilterProto::GetTypeName() const {
  return "android.service.usb.UsbDeviceFilterProto";
}


// ===================================================================

void UserPackageProto::InitAsDefaultInstance() {
}
class UserPackageProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UserPackageProto>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_package_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UserPackageProto::UserPackageProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UserPackageProto)
}
UserPackageProto::UserPackageProto(const UserPackageProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  package_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_package_name()) {
    package_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.package_name_);
  }
  user_id_ = from.user_id_;
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UserPackageProto)
}

void UserPackageProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UserPackageProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  package_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  user_id_ = 0;
}

UserPackageProto::~UserPackageProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UserPackageProto)
  SharedDtor();
}

void UserPackageProto::SharedDtor() {
  package_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UserPackageProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UserPackageProto& UserPackageProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UserPackageProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UserPackageProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UserPackageProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    package_name_.ClearNonDefaultToEmptyNoArena();
  }
  user_id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UserPackageProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string package_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_package_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UserPackageProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UserPackageProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 user_id = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_user_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &user_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string package_name = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_package_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UserPackageProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UserPackageProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UserPackageProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UserPackageProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 user_id = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->user_id(), output);
  }

  // optional string package_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->package_name(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UserPackageProto)
}

size_t UserPackageProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UserPackageProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string package_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->package_name());
    }

    // optional int32 user_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->user_id());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserPackageProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UserPackageProto*>(
      &from));
}

void UserPackageProto::MergeFrom(const UserPackageProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UserPackageProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      package_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.package_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      user_id_ = from.user_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UserPackageProto::CopyFrom(const UserPackageProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UserPackageProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserPackageProto::IsInitialized() const {
  return true;
}

void UserPackageProto::InternalSwap(UserPackageProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  package_name_.Swap(&other->package_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(user_id_, other->user_id_);
}

std::string UserPackageProto::GetTypeName() const {
  return "android.service.usb.UserPackageProto";
}


// ===================================================================

void UsbSettingsAccessoryPreferenceProto::InitAsDefaultInstance() {
  ::android::service::usb::_UsbSettingsAccessoryPreferenceProto_default_instance_._instance.get_mutable()->filter_ = const_cast< ::android::service::usb::UsbAccessoryFilterProto*>(
      ::android::service::usb::UsbAccessoryFilterProto::internal_default_instance());
  ::android::service::usb::_UsbSettingsAccessoryPreferenceProto_default_instance_._instance.get_mutable()->user_package_ = const_cast< ::android::service::usb::UserPackageProto*>(
      ::android::service::usb::UserPackageProto::internal_default_instance());
}
class UsbSettingsAccessoryPreferenceProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbSettingsAccessoryPreferenceProto>()._has_bits_);
  static const ::android::service::usb::UsbAccessoryFilterProto& filter(const UsbSettingsAccessoryPreferenceProto* msg);
  static void set_has_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::android::service::usb::UserPackageProto& user_package(const UsbSettingsAccessoryPreferenceProto* msg);
  static void set_has_user_package(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::android::service::usb::UsbAccessoryFilterProto&
UsbSettingsAccessoryPreferenceProto::_Internal::filter(const UsbSettingsAccessoryPreferenceProto* msg) {
  return *msg->filter_;
}
const ::android::service::usb::UserPackageProto&
UsbSettingsAccessoryPreferenceProto::_Internal::user_package(const UsbSettingsAccessoryPreferenceProto* msg) {
  return *msg->user_package_;
}
UsbSettingsAccessoryPreferenceProto::UsbSettingsAccessoryPreferenceProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbSettingsAccessoryPreferenceProto)
}
UsbSettingsAccessoryPreferenceProto::UsbSettingsAccessoryPreferenceProto(const UsbSettingsAccessoryPreferenceProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_filter()) {
    filter_ = new ::android::service::usb::UsbAccessoryFilterProto(*from.filter_);
  } else {
    filter_ = nullptr;
  }
  if (from.has_user_package()) {
    user_package_ = new ::android::service::usb::UserPackageProto(*from.user_package_);
  } else {
    user_package_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbSettingsAccessoryPreferenceProto)
}

void UsbSettingsAccessoryPreferenceProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbSettingsAccessoryPreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  ::memset(&filter_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&user_package_) -
      reinterpret_cast<char*>(&filter_)) + sizeof(user_package_));
}

UsbSettingsAccessoryPreferenceProto::~UsbSettingsAccessoryPreferenceProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbSettingsAccessoryPreferenceProto)
  SharedDtor();
}

void UsbSettingsAccessoryPreferenceProto::SharedDtor() {
  if (this != internal_default_instance()) delete filter_;
  if (this != internal_default_instance()) delete user_package_;
}

void UsbSettingsAccessoryPreferenceProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbSettingsAccessoryPreferenceProto& UsbSettingsAccessoryPreferenceProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbSettingsAccessoryPreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbSettingsAccessoryPreferenceProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbSettingsAccessoryPreferenceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(filter_ != nullptr);
      filter_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(user_package_ != nullptr);
      user_package_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbSettingsAccessoryPreferenceProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .android.service.usb.UsbAccessoryFilterProto filter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_filter(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UserPackageProto user_package = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_user_package(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbSettingsAccessoryPreferenceProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbSettingsAccessoryPreferenceProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .android.service.usb.UsbAccessoryFilterProto filter = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_filter()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UserPackageProto user_package = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_user_package()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbSettingsAccessoryPreferenceProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbSettingsAccessoryPreferenceProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbSettingsAccessoryPreferenceProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbSettingsAccessoryPreferenceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.service.usb.UsbAccessoryFilterProto filter = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1, _Internal::filter(this), output);
  }

  // optional .android.service.usb.UserPackageProto user_package = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2, _Internal::user_package(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbSettingsAccessoryPreferenceProto)
}

size_t UsbSettingsAccessoryPreferenceProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbSettingsAccessoryPreferenceProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .android.service.usb.UsbAccessoryFilterProto filter = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *filter_);
    }

    // optional .android.service.usb.UserPackageProto user_package = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *user_package_);
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbSettingsAccessoryPreferenceProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbSettingsAccessoryPreferenceProto*>(
      &from));
}

void UsbSettingsAccessoryPreferenceProto::MergeFrom(const UsbSettingsAccessoryPreferenceProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbSettingsAccessoryPreferenceProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_filter()->::android::service::usb::UsbAccessoryFilterProto::MergeFrom(from.filter());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_user_package()->::android::service::usb::UserPackageProto::MergeFrom(from.user_package());
    }
  }
}

void UsbSettingsAccessoryPreferenceProto::CopyFrom(const UsbSettingsAccessoryPreferenceProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbSettingsAccessoryPreferenceProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbSettingsAccessoryPreferenceProto::IsInitialized() const {
  return true;
}

void UsbSettingsAccessoryPreferenceProto::InternalSwap(UsbSettingsAccessoryPreferenceProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(filter_, other->filter_);
  swap(user_package_, other->user_package_);
}

std::string UsbSettingsAccessoryPreferenceProto::GetTypeName() const {
  return "android.service.usb.UsbSettingsAccessoryPreferenceProto";
}


// ===================================================================

void UsbAccessoryFilterProto::InitAsDefaultInstance() {
}
class UsbAccessoryFilterProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbAccessoryFilterProto>()._has_bits_);
  static void set_has_manufacturer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_model(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

UsbAccessoryFilterProto::UsbAccessoryFilterProto()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbAccessoryFilterProto)
}
UsbAccessoryFilterProto::UsbAccessoryFilterProto(const UsbAccessoryFilterProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  manufacturer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_manufacturer()) {
    manufacturer_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.manufacturer_);
  }
  model_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_model()) {
    model_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.model_);
  }
  version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_version()) {
    version_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.version_);
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbAccessoryFilterProto)
}

void UsbAccessoryFilterProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbAccessoryFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  manufacturer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  model_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

UsbAccessoryFilterProto::~UsbAccessoryFilterProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbAccessoryFilterProto)
  SharedDtor();
}

void UsbAccessoryFilterProto::SharedDtor() {
  manufacturer_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  model_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UsbAccessoryFilterProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbAccessoryFilterProto& UsbAccessoryFilterProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbAccessoryFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbAccessoryFilterProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbAccessoryFilterProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      manufacturer_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      model_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      version_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbAccessoryFilterProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string manufacturer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_manufacturer(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string model = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_model(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_version(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbAccessoryFilterProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbAccessoryFilterProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string manufacturer = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_manufacturer()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string model = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_model()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string version = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbAccessoryFilterProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbAccessoryFilterProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbAccessoryFilterProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbAccessoryFilterProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string manufacturer = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->manufacturer(), output);
  }

  // optional string model = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->model(), output);
  }

  // optional string version = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->version(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbAccessoryFilterProto)
}

size_t UsbAccessoryFilterProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbAccessoryFilterProto)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string manufacturer = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->manufacturer());
    }

    // optional string model = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->model());
    }

    // optional string version = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->version());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbAccessoryFilterProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbAccessoryFilterProto*>(
      &from));
}

void UsbAccessoryFilterProto::MergeFrom(const UsbAccessoryFilterProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbAccessoryFilterProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      manufacturer_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.manufacturer_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      model_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.model_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      version_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.version_);
    }
  }
}

void UsbAccessoryFilterProto::CopyFrom(const UsbAccessoryFilterProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbAccessoryFilterProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbAccessoryFilterProto::IsInitialized() const {
  return true;
}

void UsbAccessoryFilterProto::InternalSwap(UsbAccessoryFilterProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  manufacturer_.Swap(&other->manufacturer_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  model_.Swap(&other->model_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  version_.Swap(&other->version_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

std::string UsbAccessoryFilterProto::GetTypeName() const {
  return "android.service.usb.UsbAccessoryFilterProto";
}


// ===================================================================

void UsbDeviceAttachedActivities::InitAsDefaultInstance() {
  ::android::service::usb::_UsbDeviceAttachedActivities_default_instance_._instance.get_mutable()->activity_ = const_cast< ::android::content::ComponentNameProto*>(
      ::android::content::ComponentNameProto::internal_default_instance());
}
class UsbDeviceAttachedActivities::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbDeviceAttachedActivities>()._has_bits_);
  static const ::android::content::ComponentNameProto& activity(const UsbDeviceAttachedActivities* msg);
  static void set_has_activity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::android::content::ComponentNameProto&
UsbDeviceAttachedActivities::_Internal::activity(const UsbDeviceAttachedActivities* msg) {
  return *msg->activity_;
}
void UsbDeviceAttachedActivities::clear_activity() {
  if (activity_ != nullptr) activity_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
UsbDeviceAttachedActivities::UsbDeviceAttachedActivities()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbDeviceAttachedActivities)
}
UsbDeviceAttachedActivities::UsbDeviceAttachedActivities(const UsbDeviceAttachedActivities& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      filters_(from.filters_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_activity()) {
    activity_ = new ::android::content::ComponentNameProto(*from.activity_);
  } else {
    activity_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbDeviceAttachedActivities)
}

void UsbDeviceAttachedActivities::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbDeviceAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  activity_ = nullptr;
}

UsbDeviceAttachedActivities::~UsbDeviceAttachedActivities() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbDeviceAttachedActivities)
  SharedDtor();
}

void UsbDeviceAttachedActivities::SharedDtor() {
  if (this != internal_default_instance()) delete activity_;
}

void UsbDeviceAttachedActivities::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbDeviceAttachedActivities& UsbDeviceAttachedActivities::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbDeviceAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbDeviceAttachedActivities::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbDeviceAttachedActivities)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  filters_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(activity_ != nullptr);
    activity_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbDeviceAttachedActivities::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .android.content.ComponentNameProto activity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_activity(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbDeviceFilterProto filters = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_filters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbDeviceAttachedActivities::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbDeviceAttachedActivities)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .android.content.ComponentNameProto activity = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_activity()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbDeviceFilterProto filters = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_filters()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbDeviceAttachedActivities)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbDeviceAttachedActivities)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbDeviceAttachedActivities::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbDeviceAttachedActivities)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.content.ComponentNameProto activity = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1, _Internal::activity(this), output);
  }

  // repeated .android.service.usb.UsbDeviceFilterProto filters = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->filters_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2,
      this->filters(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbDeviceAttachedActivities)
}

size_t UsbDeviceAttachedActivities::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbDeviceAttachedActivities)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbDeviceFilterProto filters = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->filters_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->filters(static_cast<int>(i)));
    }
  }

  // optional .android.content.ComponentNameProto activity = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *activity_);
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbDeviceAttachedActivities::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbDeviceAttachedActivities*>(
      &from));
}

void UsbDeviceAttachedActivities::MergeFrom(const UsbDeviceAttachedActivities& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbDeviceAttachedActivities)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  filters_.MergeFrom(from.filters_);
  if (from.has_activity()) {
    mutable_activity()->::android::content::ComponentNameProto::MergeFrom(from.activity());
  }
}

void UsbDeviceAttachedActivities::CopyFrom(const UsbDeviceAttachedActivities& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbDeviceAttachedActivities)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbDeviceAttachedActivities::IsInitialized() const {
  return true;
}

void UsbDeviceAttachedActivities::InternalSwap(UsbDeviceAttachedActivities* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&filters_)->InternalSwap(CastToBase(&other->filters_));
  swap(activity_, other->activity_);
}

std::string UsbDeviceAttachedActivities::GetTypeName() const {
  return "android.service.usb.UsbDeviceAttachedActivities";
}


// ===================================================================

void UsbAccessoryAttachedActivities::InitAsDefaultInstance() {
  ::android::service::usb::_UsbAccessoryAttachedActivities_default_instance_._instance.get_mutable()->activity_ = const_cast< ::android::content::ComponentNameProto*>(
      ::android::content::ComponentNameProto::internal_default_instance());
}
class UsbAccessoryAttachedActivities::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbAccessoryAttachedActivities>()._has_bits_);
  static const ::android::content::ComponentNameProto& activity(const UsbAccessoryAttachedActivities* msg);
  static void set_has_activity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::android::content::ComponentNameProto&
UsbAccessoryAttachedActivities::_Internal::activity(const UsbAccessoryAttachedActivities* msg) {
  return *msg->activity_;
}
void UsbAccessoryAttachedActivities::clear_activity() {
  if (activity_ != nullptr) activity_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
UsbAccessoryAttachedActivities::UsbAccessoryAttachedActivities()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbAccessoryAttachedActivities)
}
UsbAccessoryAttachedActivities::UsbAccessoryAttachedActivities(const UsbAccessoryAttachedActivities& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      filters_(from.filters_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_activity()) {
    activity_ = new ::android::content::ComponentNameProto(*from.activity_);
  } else {
    activity_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbAccessoryAttachedActivities)
}

void UsbAccessoryAttachedActivities::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbAccessoryAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  activity_ = nullptr;
}

UsbAccessoryAttachedActivities::~UsbAccessoryAttachedActivities() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbAccessoryAttachedActivities)
  SharedDtor();
}

void UsbAccessoryAttachedActivities::SharedDtor() {
  if (this != internal_default_instance()) delete activity_;
}

void UsbAccessoryAttachedActivities::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbAccessoryAttachedActivities& UsbAccessoryAttachedActivities::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbAccessoryAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbAccessoryAttachedActivities::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbAccessoryAttachedActivities)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  filters_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(activity_ != nullptr);
    activity_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbAccessoryAttachedActivities::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .android.content.ComponentNameProto activity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_activity(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbAccessoryFilterProto filters = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_filters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbAccessoryAttachedActivities::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbAccessoryAttachedActivities)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .android.content.ComponentNameProto activity = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_activity()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbAccessoryFilterProto filters = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_filters()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbAccessoryAttachedActivities)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbAccessoryAttachedActivities)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbAccessoryAttachedActivities::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbAccessoryAttachedActivities)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.content.ComponentNameProto activity = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1, _Internal::activity(this), output);
  }

  // repeated .android.service.usb.UsbAccessoryFilterProto filters = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->filters_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2,
      this->filters(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbAccessoryAttachedActivities)
}

size_t UsbAccessoryAttachedActivities::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbAccessoryAttachedActivities)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbAccessoryFilterProto filters = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->filters_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->filters(static_cast<int>(i)));
    }
  }

  // optional .android.content.ComponentNameProto activity = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *activity_);
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbAccessoryAttachedActivities::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UsbAccessoryAttachedActivities*>(
      &from));
}

void UsbAccessoryAttachedActivities::MergeFrom(const UsbAccessoryAttachedActivities& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbAccessoryAttachedActivities)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  filters_.MergeFrom(from.filters_);
  if (from.has_activity()) {
    mutable_activity()->::android::content::ComponentNameProto::MergeFrom(from.activity());
  }
}

void UsbAccessoryAttachedActivities::CopyFrom(const UsbAccessoryAttachedActivities& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbAccessoryAttachedActivities)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbAccessoryAttachedActivities::IsInitialized() const {
  return true;
}

void UsbAccessoryAttachedActivities::InternalSwap(UsbAccessoryAttachedActivities* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&filters_)->InternalSwap(CastToBase(&other->filters_));
  swap(activity_, other->activity_);
}

std::string UsbAccessoryAttachedActivities::GetTypeName() const {
  return "android.service.usb.UsbAccessoryAttachedActivities";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace usb
}  // namespace service
}  // namespace android
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbServiceDumpProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbServiceDumpProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbServiceDumpProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbDeviceManagerProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbDeviceManagerProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbDeviceManagerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbHandlerProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbHandlerProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbHandlerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbAccessoryProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbAccessoryProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbAccessoryProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbDebuggingManagerProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbDebuggingManagerProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbDebuggingManagerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbHostManagerProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbHostManagerProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbHostManagerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbDeviceProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbDeviceProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbDeviceProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbConfigurationProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbConfigurationProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbConfigurationProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbInterfaceProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbInterfaceProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbInterfaceProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbEndPointProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbEndPointProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbEndPointProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbConnectionRecordProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbConnectionRecordProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbConnectionRecordProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbIsHeadsetProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbIsHeadsetProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbIsHeadsetProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbPortManagerProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbPortManagerProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbPortManagerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbPortInfoProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbPortInfoProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbPortInfoProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbPortProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbPortProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbPortProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbPortStatusProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbPortStatusProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbPortStatusProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbPortStatusRoleCombinationProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbPortStatusRoleCombinationProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbPortStatusRoleCombinationProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbAlsaManagerProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbAlsaManagerProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbAlsaManagerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbAlsaDeviceProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbAlsaDeviceProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbAlsaDeviceProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbMidiDeviceProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbMidiDeviceProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbMidiDeviceProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbSettingsManagerProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbSettingsManagerProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbSettingsManagerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbUserSettingsManagerProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbUserSettingsManagerProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbUserSettingsManagerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbProfileGroupSettingsManagerProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbProfileGroupSettingsManagerProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbProfileGroupSettingsManagerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbSettingsDevicePreferenceProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbSettingsDevicePreferenceProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbSettingsDevicePreferenceProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbPermissionsManagerProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbPermissionsManagerProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbPermissionsManagerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbUserPermissionsManagerProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbUserPermissionsManagerProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbUserPermissionsManagerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbDevicePermissionProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbDevicePermissionProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbDevicePermissionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbAccessoryPermissionProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbAccessoryPermissionProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbAccessoryPermissionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbDevicePersistentPermissionProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbDevicePersistentPermissionProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbDevicePersistentPermissionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbAccessoryPersistentPermissionProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbAccessoryPersistentPermissionProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbAccessoryPersistentPermissionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbUidPermissionProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbUidPermissionProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbUidPermissionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbDeviceFilterProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbDeviceFilterProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbDeviceFilterProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UserPackageProto* Arena::CreateMaybeMessage< ::android::service::usb::UserPackageProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UserPackageProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbSettingsAccessoryPreferenceProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbSettingsAccessoryPreferenceProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbSettingsAccessoryPreferenceProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbAccessoryFilterProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbAccessoryFilterProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbAccessoryFilterProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbDeviceAttachedActivities* Arena::CreateMaybeMessage< ::android::service::usb::UsbDeviceAttachedActivities >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbDeviceAttachedActivities >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbAccessoryAttachedActivities* Arena::CreateMaybeMessage< ::android::service::usb::UsbAccessoryAttachedActivities >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbAccessoryAttachedActivities >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
