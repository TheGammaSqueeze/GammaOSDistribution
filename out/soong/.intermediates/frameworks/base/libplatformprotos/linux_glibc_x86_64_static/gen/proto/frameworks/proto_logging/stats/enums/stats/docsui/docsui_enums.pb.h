// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/stats/docsui/docsui_enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fdocsui_2fdocsui_5fenums_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fdocsui_2fdocsui_5fenums_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fdocsui_2fdocsui_5fenums_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fdocsui_2fdocsui_5fenums_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fdocsui_2fdocsui_5fenums_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace android {
namespace stats {
namespace docsui {

enum LaunchAction : int {
  UNKNOWN = 0,
  OPEN = 1,
  CREATE = 2,
  GET_CONTENT = 3,
  OPEN_TREE = 4,
  PICK_COPY_DEST = 5,
  BROWSE = 6,
  OTHER = 7
};
bool LaunchAction_IsValid(int value);
constexpr LaunchAction LaunchAction_MIN = UNKNOWN;
constexpr LaunchAction LaunchAction_MAX = OTHER;
constexpr int LaunchAction_ARRAYSIZE = LaunchAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LaunchAction_descriptor();
template<typename T>
inline const std::string& LaunchAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LaunchAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LaunchAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LaunchAction_descriptor(), enum_t_value);
}
inline bool LaunchAction_Parse(
    const std::string& name, LaunchAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LaunchAction>(
    LaunchAction_descriptor(), name, value);
}
enum MimeType : int {
  MIME_UNKNOWN = 0,
  MIME_NONE = 1,
  MIME_ANY = 2,
  MIME_APPLICATION = 3,
  MIME_AUDIO = 4,
  MIME_IMAGE = 5,
  MIME_MESSAGE = 6,
  MIME_MULTIPART = 7,
  MIME_TEXT = 8,
  MIME_VIDEO = 9,
  MIME_OTHER = 10
};
bool MimeType_IsValid(int value);
constexpr MimeType MimeType_MIN = MIME_UNKNOWN;
constexpr MimeType MimeType_MAX = MIME_OTHER;
constexpr int MimeType_ARRAYSIZE = MimeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MimeType_descriptor();
template<typename T>
inline const std::string& MimeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MimeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MimeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MimeType_descriptor(), enum_t_value);
}
inline bool MimeType_Parse(
    const std::string& name, MimeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MimeType>(
    MimeType_descriptor(), name, value);
}
enum Root : int {
  ROOT_UNKNOWN = 0,
  ROOT_NONE = 1,
  ROOT_OTHER_DOCS_PROVIDER = 2,
  ROOT_AUDIO = 3,
  ROOT_DEVICE_STORAGE = 4,
  ROOT_DOWNLOADS = 5,
  ROOT_HOME = 6,
  ROOT_IMAGES = 7,
  ROOT_RECENTS = 8,
  ROOT_VIDEOS = 9,
  ROOT_MTP = 10,
  ROOT_THIRD_PARTY_APP = 11,
  ROOT_DOCUMENTS = 12
};
bool Root_IsValid(int value);
constexpr Root Root_MIN = ROOT_UNKNOWN;
constexpr Root Root_MAX = ROOT_DOCUMENTS;
constexpr int Root_ARRAYSIZE = Root_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Root_descriptor();
template<typename T>
inline const std::string& Root_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Root>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Root_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Root_descriptor(), enum_t_value);
}
inline bool Root_Parse(
    const std::string& name, Root* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Root>(
    Root_descriptor(), name, value);
}
enum ContextScope : int {
  SCOPE_UNKNOWN = 0,
  SCOPE_FILES = 1,
  SCOPE_PICKER = 2
};
bool ContextScope_IsValid(int value);
constexpr ContextScope ContextScope_MIN = SCOPE_UNKNOWN;
constexpr ContextScope ContextScope_MAX = SCOPE_PICKER;
constexpr int ContextScope_ARRAYSIZE = ContextScope_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContextScope_descriptor();
template<typename T>
inline const std::string& ContextScope_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContextScope>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContextScope_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ContextScope_descriptor(), enum_t_value);
}
inline bool ContextScope_Parse(
    const std::string& name, ContextScope* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ContextScope>(
    ContextScope_descriptor(), name, value);
}
enum Provider : int {
  PROVIDER_UNKNOWN = 0,
  PROVIDER_SYSTEM = 1,
  PROVIDER_EXTERNAL = 2
};
bool Provider_IsValid(int value);
constexpr Provider Provider_MIN = PROVIDER_UNKNOWN;
constexpr Provider Provider_MAX = PROVIDER_EXTERNAL;
constexpr int Provider_ARRAYSIZE = Provider_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Provider_descriptor();
template<typename T>
inline const std::string& Provider_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Provider>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Provider_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Provider_descriptor(), enum_t_value);
}
inline bool Provider_Parse(
    const std::string& name, Provider* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Provider>(
    Provider_descriptor(), name, value);
}
enum FileOperation : int {
  OP_UNKNOWN = 0,
  OP_OTHER = 1,
  OP_COPY = 2,
  OP_COPY_INTRA_PROVIDER = 3,
  OP_COPY_SYSTEM_PROVIDER = 4,
  OP_COPY_EXTERNAL_PROVIDER = 5,
  OP_MOVE = 6,
  OP_MOVE_INTRA_PROVIDER = 7,
  OP_MOVE_SYSTEM_PROVIDER = 8,
  OP_MOVE_EXTERNAL_PROVIDER = 9,
  OP_DELETE = 10,
  OP_RENAME = 11,
  OP_CREATE_DIR = 12,
  OP_OTHER_ERROR = 13,
  OP_DELETE_ERROR = 14,
  OP_MOVE_ERROR = 15,
  OP_COPY_ERROR = 16,
  OP_RENAME_ERROR = 17,
  OP_CREATE_DIR_ERROR = 18,
  OP_COMPRESS_INTRA_PROVIDER = 19,
  OP_COMPRESS_SYSTEM_PROVIDER = 20,
  OP_COMPRESS_EXTERNAL_PROVIDER = 21,
  OP_EXTRACT_INTRA_PROVIDER = 22,
  OP_EXTRACT_SYSTEM_PROVIDER = 23,
  OP_EXTRACT_EXTERNAL_PROVIDER = 24,
  OP_COMPRESS_ERROR = 25,
  OP_EXTRACT_ERROR = 26
};
bool FileOperation_IsValid(int value);
constexpr FileOperation FileOperation_MIN = OP_UNKNOWN;
constexpr FileOperation FileOperation_MAX = OP_EXTRACT_ERROR;
constexpr int FileOperation_ARRAYSIZE = FileOperation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FileOperation_descriptor();
template<typename T>
inline const std::string& FileOperation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FileOperation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FileOperation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FileOperation_descriptor(), enum_t_value);
}
inline bool FileOperation_Parse(
    const std::string& name, FileOperation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FileOperation>(
    FileOperation_descriptor(), name, value);
}
enum SubFileOperation : int {
  SUB_OP_UNKNOWN = 0,
  SUB_OP_QUERY_DOC = 1,
  SUB_OP_QUERY_CHILD = 2,
  SUB_OP_OPEN_FILE = 3,
  SUB_OP_READ_FILE = 4,
  SUB_OP_CREATE_DOC = 5,
  SUB_OP_WRITE_FILE = 6,
  SUB_OP_DELETE_DOC = 7,
  SUB_OP_OBTAIN_STREAM_TYPE = 8,
  SUB_OP_QUICK_MOVE = 9,
  SUB_OP_QUICK_COPY = 10
};
bool SubFileOperation_IsValid(int value);
constexpr SubFileOperation SubFileOperation_MIN = SUB_OP_UNKNOWN;
constexpr SubFileOperation SubFileOperation_MAX = SUB_OP_QUICK_COPY;
constexpr int SubFileOperation_ARRAYSIZE = SubFileOperation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SubFileOperation_descriptor();
template<typename T>
inline const std::string& SubFileOperation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SubFileOperation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SubFileOperation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SubFileOperation_descriptor(), enum_t_value);
}
inline bool SubFileOperation_Parse(
    const std::string& name, SubFileOperation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SubFileOperation>(
    SubFileOperation_descriptor(), name, value);
}
enum CopyMoveOpMode : int {
  MODE_UNKNOWN = 0,
  MODE_PROVIDER = 1,
  MODE_CONVERTED = 2,
  MODE_CONVENTIONAL = 3
};
bool CopyMoveOpMode_IsValid(int value);
constexpr CopyMoveOpMode CopyMoveOpMode_MIN = MODE_UNKNOWN;
constexpr CopyMoveOpMode CopyMoveOpMode_MAX = MODE_CONVENTIONAL;
constexpr int CopyMoveOpMode_ARRAYSIZE = CopyMoveOpMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CopyMoveOpMode_descriptor();
template<typename T>
inline const std::string& CopyMoveOpMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CopyMoveOpMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CopyMoveOpMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CopyMoveOpMode_descriptor(), enum_t_value);
}
inline bool CopyMoveOpMode_Parse(
    const std::string& name, CopyMoveOpMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CopyMoveOpMode>(
    CopyMoveOpMode_descriptor(), name, value);
}
enum Authority : int {
  AUTH_UNKNOWN = 0,
  AUTH_OTHER = 1,
  AUTH_MEDIA = 2,
  AUTH_STORAGE_INTERNAL = 3,
  AUTH_STORAGE_EXTERNAL = 4,
  AUTH_DOWNLOADS = 5,
  AUTH_MTP = 6
};
bool Authority_IsValid(int value);
constexpr Authority Authority_MIN = AUTH_UNKNOWN;
constexpr Authority Authority_MAX = AUTH_MTP;
constexpr int Authority_ARRAYSIZE = Authority_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Authority_descriptor();
template<typename T>
inline const std::string& Authority_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Authority>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Authority_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Authority_descriptor(), enum_t_value);
}
inline bool Authority_Parse(
    const std::string& name, Authority* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Authority>(
    Authority_descriptor(), name, value);
}
enum UserAction : int {
  ACTION_UNKNOWN = 0,
  ACTION_OTHER = 1,
  ACTION_GRID = 2,
  ACTION_LIST = 3,
  ACTION_SORT_NAME = 4,
  ACTION_SORT_DATE = 5,
  ACTION_SORT_SIZE = 6,
  ACTION_SORT_TYPE = 7,
  ACTION_SEARCH = 8,
  ACTION_SHOW_SIZE = 9,
  ACTION_HIDE_SIZE = 10,
  ACTION_SETTINGS = 11,
  ACTION_COPY_TO = 12,
  ACTION_MOVE_TO = 13,
  ACTION_DELETE = 14,
  ACTION_RENAME = 15,
  ACTION_CREATE_DIR = 16,
  ACTION_SELECT_ALL = 17,
  ACTION_SHARE = 18,
  ACTION_OPEN = 19,
  ACTION_SHOW_ADVANCED = 20,
  ACTION_HIDE_ADVANCED = 21,
  ACTION_NEW_WINDOW = 22,
  ACTION_PASTE_CLIPBOARD = 23,
  ACTION_COPY_CLIPBOARD = 24,
  ACTION_DRAG_N_DROP = 25,
  ACTION_DRAG_N_DROP_MULTI_WINDOW = 26,
  ACTION_CUT_CLIPBOARD = 27,
  ACTION_COMPRESS = 28,
  ACTION_EXTRACT_TO = 29,
  ACTION_VIEW_IN_APPLICATION = 30,
  ACTION_INSPECTOR = 31,
  ACTION_SEARCH_CHIP = 32,
  ACTION_SEARCH_HISTORY = 33
};
bool UserAction_IsValid(int value);
constexpr UserAction UserAction_MIN = ACTION_UNKNOWN;
constexpr UserAction UserAction_MAX = ACTION_SEARCH_HISTORY;
constexpr int UserAction_ARRAYSIZE = UserAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserAction_descriptor();
template<typename T>
inline const std::string& UserAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UserAction_descriptor(), enum_t_value);
}
inline bool UserAction_Parse(
    const std::string& name, UserAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UserAction>(
    UserAction_descriptor(), name, value);
}
enum InvalidScopedAccess : int {
  SCOPED_DIR_ACCESS_UNKNOWN = 0,
  SCOPED_DIR_ACCESS_INVALID_ARGUMENTS = 1,
  SCOPED_DIR_ACCESS_INVALID_DIRECTORY = 2,
  SCOPED_DIR_ACCESS_ERROR = 3,
  SCOPED_DIR_ACCESS_DEPRECATED = 4
};
bool InvalidScopedAccess_IsValid(int value);
constexpr InvalidScopedAccess InvalidScopedAccess_MIN = SCOPED_DIR_ACCESS_UNKNOWN;
constexpr InvalidScopedAccess InvalidScopedAccess_MAX = SCOPED_DIR_ACCESS_DEPRECATED;
constexpr int InvalidScopedAccess_ARRAYSIZE = InvalidScopedAccess_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InvalidScopedAccess_descriptor();
template<typename T>
inline const std::string& InvalidScopedAccess_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InvalidScopedAccess>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InvalidScopedAccess_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InvalidScopedAccess_descriptor(), enum_t_value);
}
inline bool InvalidScopedAccess_Parse(
    const std::string& name, InvalidScopedAccess* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InvalidScopedAccess>(
    InvalidScopedAccess_descriptor(), name, value);
}
enum SearchType : int {
  TYPE_UNKNOWN = 0,
  TYPE_CHIP_IMAGES = 1,
  TYPE_CHIP_AUDIOS = 2,
  TYPE_CHIP_VIDEOS = 3,
  TYPE_CHIP_DOCS = 4,
  TYPE_SEARCH_HISTORY = 5,
  TYPE_SEARCH_STRING = 6,
  TYPE_CHIP_LARGE_FILES = 7,
  TYPE_CHIP_FROM_THIS_WEEK = 8
};
bool SearchType_IsValid(int value);
constexpr SearchType SearchType_MIN = TYPE_UNKNOWN;
constexpr SearchType SearchType_MAX = TYPE_CHIP_FROM_THIS_WEEK;
constexpr int SearchType_ARRAYSIZE = SearchType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SearchType_descriptor();
template<typename T>
inline const std::string& SearchType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SearchType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SearchType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SearchType_descriptor(), enum_t_value);
}
inline bool SearchType_Parse(
    const std::string& name, SearchType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SearchType>(
    SearchType_descriptor(), name, value);
}
enum SearchMode : int {
  SEARCH_UNKNOWN = 0,
  SEARCH_KEYWORD = 1,
  SEARCH_CHIPS = 2,
  SEARCH_KEYWORD_N_CHIPS = 3
};
bool SearchMode_IsValid(int value);
constexpr SearchMode SearchMode_MIN = SEARCH_UNKNOWN;
constexpr SearchMode SearchMode_MAX = SEARCH_KEYWORD_N_CHIPS;
constexpr int SearchMode_ARRAYSIZE = SearchMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SearchMode_descriptor();
template<typename T>
inline const std::string& SearchMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SearchMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SearchMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SearchMode_descriptor(), enum_t_value);
}
inline bool SearchMode_Parse(
    const std::string& name, SearchMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SearchMode>(
    SearchMode_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace docsui
}  // namespace stats
}  // namespace android

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::android::stats::docsui::LaunchAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::docsui::LaunchAction>() {
  return ::android::stats::docsui::LaunchAction_descriptor();
}
template <> struct is_proto_enum< ::android::stats::docsui::MimeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::docsui::MimeType>() {
  return ::android::stats::docsui::MimeType_descriptor();
}
template <> struct is_proto_enum< ::android::stats::docsui::Root> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::docsui::Root>() {
  return ::android::stats::docsui::Root_descriptor();
}
template <> struct is_proto_enum< ::android::stats::docsui::ContextScope> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::docsui::ContextScope>() {
  return ::android::stats::docsui::ContextScope_descriptor();
}
template <> struct is_proto_enum< ::android::stats::docsui::Provider> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::docsui::Provider>() {
  return ::android::stats::docsui::Provider_descriptor();
}
template <> struct is_proto_enum< ::android::stats::docsui::FileOperation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::docsui::FileOperation>() {
  return ::android::stats::docsui::FileOperation_descriptor();
}
template <> struct is_proto_enum< ::android::stats::docsui::SubFileOperation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::docsui::SubFileOperation>() {
  return ::android::stats::docsui::SubFileOperation_descriptor();
}
template <> struct is_proto_enum< ::android::stats::docsui::CopyMoveOpMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::docsui::CopyMoveOpMode>() {
  return ::android::stats::docsui::CopyMoveOpMode_descriptor();
}
template <> struct is_proto_enum< ::android::stats::docsui::Authority> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::docsui::Authority>() {
  return ::android::stats::docsui::Authority_descriptor();
}
template <> struct is_proto_enum< ::android::stats::docsui::UserAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::docsui::UserAction>() {
  return ::android::stats::docsui::UserAction_descriptor();
}
template <> struct is_proto_enum< ::android::stats::docsui::InvalidScopedAccess> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::docsui::InvalidScopedAccess>() {
  return ::android::stats::docsui::InvalidScopedAccess_descriptor();
}
template <> struct is_proto_enum< ::android::stats::docsui::SearchType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::docsui::SearchType>() {
  return ::android::stats::docsui::SearchType_descriptor();
}
template <> struct is_proto_enum< ::android::stats::docsui::SearchMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::docsui::SearchMode>() {
  return ::android::stats::docsui::SearchMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fdocsui_2fdocsui_5fenums_2eproto
