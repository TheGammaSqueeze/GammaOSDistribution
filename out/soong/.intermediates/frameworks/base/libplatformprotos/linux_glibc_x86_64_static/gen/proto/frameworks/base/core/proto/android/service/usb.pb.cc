// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/base/core/proto/android/service/usb.proto

#include "frameworks/base/core/proto/android/service/usb.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fcontent_2fcomponent_5fname_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ComponentNameProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fcontent_2fcomponent_5fname_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbAccessoryAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbAccessoryFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbAccessoryPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbAccessoryPersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbAccessoryProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbAlsaDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbAlsaManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbConfigurationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbConnectionRecordProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbDebuggingManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbDeviceAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbDeviceFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbDeviceManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbDevicePermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbDevicePersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbEndPointProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbHandlerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_UsbHostManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbInterfaceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbIsHeadsetProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbMidiDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbPortInfoProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbPortManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbPortProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbPortStatusProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbPortStatusRoleCombinationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbProfileGroupSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbSettingsAccessoryPreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbSettingsDevicePreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbUidPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_UsbUserPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbUserSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UserPackageProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
namespace android {
namespace service {
namespace usb {
class UsbServiceDumpProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbServiceDumpProto> _instance;
} _UsbServiceDumpProto_default_instance_;
class UsbDeviceManagerProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbDeviceManagerProto> _instance;
} _UsbDeviceManagerProto_default_instance_;
class UsbHandlerProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbHandlerProto> _instance;
} _UsbHandlerProto_default_instance_;
class UsbAccessoryProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbAccessoryProto> _instance;
} _UsbAccessoryProto_default_instance_;
class UsbDebuggingManagerProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbDebuggingManagerProto> _instance;
} _UsbDebuggingManagerProto_default_instance_;
class UsbHostManagerProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbHostManagerProto> _instance;
} _UsbHostManagerProto_default_instance_;
class UsbDeviceProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbDeviceProto> _instance;
} _UsbDeviceProto_default_instance_;
class UsbConfigurationProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbConfigurationProto> _instance;
} _UsbConfigurationProto_default_instance_;
class UsbInterfaceProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbInterfaceProto> _instance;
} _UsbInterfaceProto_default_instance_;
class UsbEndPointProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbEndPointProto> _instance;
} _UsbEndPointProto_default_instance_;
class UsbConnectionRecordProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbConnectionRecordProto> _instance;
} _UsbConnectionRecordProto_default_instance_;
class UsbIsHeadsetProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbIsHeadsetProto> _instance;
} _UsbIsHeadsetProto_default_instance_;
class UsbPortManagerProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbPortManagerProto> _instance;
} _UsbPortManagerProto_default_instance_;
class UsbPortInfoProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbPortInfoProto> _instance;
} _UsbPortInfoProto_default_instance_;
class UsbPortProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbPortProto> _instance;
} _UsbPortProto_default_instance_;
class UsbPortStatusProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbPortStatusProto> _instance;
} _UsbPortStatusProto_default_instance_;
class UsbPortStatusRoleCombinationProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbPortStatusRoleCombinationProto> _instance;
} _UsbPortStatusRoleCombinationProto_default_instance_;
class UsbAlsaManagerProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbAlsaManagerProto> _instance;
} _UsbAlsaManagerProto_default_instance_;
class UsbAlsaDeviceProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbAlsaDeviceProto> _instance;
} _UsbAlsaDeviceProto_default_instance_;
class UsbMidiDeviceProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbMidiDeviceProto> _instance;
} _UsbMidiDeviceProto_default_instance_;
class UsbSettingsManagerProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbSettingsManagerProto> _instance;
} _UsbSettingsManagerProto_default_instance_;
class UsbUserSettingsManagerProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbUserSettingsManagerProto> _instance;
} _UsbUserSettingsManagerProto_default_instance_;
class UsbProfileGroupSettingsManagerProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbProfileGroupSettingsManagerProto> _instance;
} _UsbProfileGroupSettingsManagerProto_default_instance_;
class UsbSettingsDevicePreferenceProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbSettingsDevicePreferenceProto> _instance;
} _UsbSettingsDevicePreferenceProto_default_instance_;
class UsbPermissionsManagerProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbPermissionsManagerProto> _instance;
} _UsbPermissionsManagerProto_default_instance_;
class UsbUserPermissionsManagerProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbUserPermissionsManagerProto> _instance;
} _UsbUserPermissionsManagerProto_default_instance_;
class UsbDevicePermissionProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbDevicePermissionProto> _instance;
} _UsbDevicePermissionProto_default_instance_;
class UsbAccessoryPermissionProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbAccessoryPermissionProto> _instance;
} _UsbAccessoryPermissionProto_default_instance_;
class UsbDevicePersistentPermissionProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbDevicePersistentPermissionProto> _instance;
} _UsbDevicePersistentPermissionProto_default_instance_;
class UsbAccessoryPersistentPermissionProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbAccessoryPersistentPermissionProto> _instance;
} _UsbAccessoryPersistentPermissionProto_default_instance_;
class UsbUidPermissionProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbUidPermissionProto> _instance;
} _UsbUidPermissionProto_default_instance_;
class UsbDeviceFilterProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbDeviceFilterProto> _instance;
} _UsbDeviceFilterProto_default_instance_;
class UserPackageProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UserPackageProto> _instance;
} _UserPackageProto_default_instance_;
class UsbSettingsAccessoryPreferenceProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbSettingsAccessoryPreferenceProto> _instance;
} _UsbSettingsAccessoryPreferenceProto_default_instance_;
class UsbAccessoryFilterProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbAccessoryFilterProto> _instance;
} _UsbAccessoryFilterProto_default_instance_;
class UsbDeviceAttachedActivitiesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbDeviceAttachedActivities> _instance;
} _UsbDeviceAttachedActivities_default_instance_;
class UsbAccessoryAttachedActivitiesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsbAccessoryAttachedActivities> _instance;
} _UsbAccessoryAttachedActivities_default_instance_;
}  // namespace usb
}  // namespace service
}  // namespace android
static void InitDefaultsscc_info_UsbAccessoryAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbAccessoryAttachedActivities_default_instance_;
    new (ptr) ::android::service::usb::UsbAccessoryAttachedActivities();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbAccessoryAttachedActivities::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbAccessoryAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_UsbAccessoryAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_ComponentNameProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fcontent_2fcomponent_5fname_2eproto.base,
      &scc_info_UsbAccessoryFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbAccessoryFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbAccessoryFilterProto_default_instance_;
    new (ptr) ::android::service::usb::UsbAccessoryFilterProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbAccessoryFilterProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbAccessoryFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbAccessoryFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbAccessoryPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbAccessoryPermissionProto_default_instance_;
    new (ptr) ::android::service::usb::UsbAccessoryPermissionProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbAccessoryPermissionProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbAccessoryPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbAccessoryPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbAccessoryPersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbAccessoryPersistentPermissionProto_default_instance_;
    new (ptr) ::android::service::usb::UsbAccessoryPersistentPermissionProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbAccessoryPersistentPermissionProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbAccessoryPersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_UsbAccessoryPersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbAccessoryFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbUidPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbAccessoryProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbAccessoryProto_default_instance_;
    new (ptr) ::android::service::usb::UsbAccessoryProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbAccessoryProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbAccessoryProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbAccessoryProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbAlsaDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbAlsaDeviceProto_default_instance_;
    new (ptr) ::android::service::usb::UsbAlsaDeviceProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbAlsaDeviceProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbAlsaDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbAlsaDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbAlsaManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbAlsaManagerProto_default_instance_;
    new (ptr) ::android::service::usb::UsbAlsaManagerProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbAlsaManagerProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbAlsaManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_UsbAlsaManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbAlsaDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbMidiDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbConfigurationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbConfigurationProto_default_instance_;
    new (ptr) ::android::service::usb::UsbConfigurationProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbConfigurationProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbConfigurationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_UsbConfigurationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbInterfaceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbConnectionRecordProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbConnectionRecordProto_default_instance_;
    new (ptr) ::android::service::usb::UsbConnectionRecordProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbConnectionRecordProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbConnectionRecordProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_UsbConnectionRecordProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbIsHeadsetProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbDebuggingManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbDebuggingManagerProto_default_instance_;
    new (ptr) ::android::service::usb::UsbDebuggingManagerProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbDebuggingManagerProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbDebuggingManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbDebuggingManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbDeviceAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbDeviceAttachedActivities_default_instance_;
    new (ptr) ::android::service::usb::UsbDeviceAttachedActivities();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbDeviceAttachedActivities::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbDeviceAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_UsbDeviceAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_ComponentNameProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fcontent_2fcomponent_5fname_2eproto.base,
      &scc_info_UsbDeviceFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbDeviceFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbDeviceFilterProto_default_instance_;
    new (ptr) ::android::service::usb::UsbDeviceFilterProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbDeviceFilterProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbDeviceFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbDeviceFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbDeviceManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbDeviceManagerProto_default_instance_;
    new (ptr) ::android::service::usb::UsbDeviceManagerProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbDeviceManagerProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbDeviceManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_UsbDeviceManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbHandlerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbDebuggingManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbDevicePermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbDevicePermissionProto_default_instance_;
    new (ptr) ::android::service::usb::UsbDevicePermissionProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbDevicePermissionProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbDevicePermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbDevicePermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbDevicePersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbDevicePersistentPermissionProto_default_instance_;
    new (ptr) ::android::service::usb::UsbDevicePersistentPermissionProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbDevicePersistentPermissionProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbDevicePersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_UsbDevicePersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbDeviceFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbUidPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbDeviceProto_default_instance_;
    new (ptr) ::android::service::usb::UsbDeviceProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbDeviceProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_UsbDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbConfigurationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbEndPointProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbEndPointProto_default_instance_;
    new (ptr) ::android::service::usb::UsbEndPointProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbEndPointProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbEndPointProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbEndPointProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbHandlerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbHandlerProto_default_instance_;
    new (ptr) ::android::service::usb::UsbHandlerProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbHandlerProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbHandlerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_UsbHandlerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbAccessoryProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbHostManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbHostManagerProto_default_instance_;
    new (ptr) ::android::service::usb::UsbHostManagerProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbHostManagerProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_UsbHostManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, InitDefaultsscc_info_UsbHostManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_ComponentNameProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fcontent_2fcomponent_5fname_2eproto.base,
      &scc_info_UsbDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbConnectionRecordProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbInterfaceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbInterfaceProto_default_instance_;
    new (ptr) ::android::service::usb::UsbInterfaceProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbInterfaceProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbInterfaceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_UsbInterfaceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbEndPointProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbIsHeadsetProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbIsHeadsetProto_default_instance_;
    new (ptr) ::android::service::usb::UsbIsHeadsetProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbIsHeadsetProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbIsHeadsetProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbIsHeadsetProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbMidiDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbMidiDeviceProto_default_instance_;
    new (ptr) ::android::service::usb::UsbMidiDeviceProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbMidiDeviceProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbMidiDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbMidiDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbPermissionsManagerProto_default_instance_;
    new (ptr) ::android::service::usb::UsbPermissionsManagerProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbPermissionsManagerProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_UsbPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbUserPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbPortInfoProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbPortInfoProto_default_instance_;
    new (ptr) ::android::service::usb::UsbPortInfoProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbPortInfoProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbPortInfoProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_UsbPortInfoProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbPortProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbPortStatusProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbPortManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbPortManagerProto_default_instance_;
    new (ptr) ::android::service::usb::UsbPortManagerProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbPortManagerProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbPortManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_UsbPortManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbPortInfoProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbPortProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbPortProto_default_instance_;
    new (ptr) ::android::service::usb::UsbPortProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbPortProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbPortProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbPortProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbPortStatusProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbPortStatusProto_default_instance_;
    new (ptr) ::android::service::usb::UsbPortStatusProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbPortStatusProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsbPortStatusProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_UsbPortStatusProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbPortStatusRoleCombinationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbPortStatusRoleCombinationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbPortStatusRoleCombinationProto_default_instance_;
    new (ptr) ::android::service::usb::UsbPortStatusRoleCombinationProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbPortStatusRoleCombinationProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbPortStatusRoleCombinationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbPortStatusRoleCombinationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbProfileGroupSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbProfileGroupSettingsManagerProto_default_instance_;
    new (ptr) ::android::service::usb::UsbProfileGroupSettingsManagerProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbProfileGroupSettingsManagerProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbProfileGroupSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_UsbProfileGroupSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbSettingsDevicePreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbSettingsAccessoryPreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbServiceDumpProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbServiceDumpProto_default_instance_;
    new (ptr) ::android::service::usb::UsbServiceDumpProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbServiceDumpProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<6> scc_info_UsbServiceDumpProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 6, InitDefaultsscc_info_UsbServiceDumpProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbDeviceManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbHostManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbPortManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbAlsaManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbSettingsAccessoryPreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbSettingsAccessoryPreferenceProto_default_instance_;
    new (ptr) ::android::service::usb::UsbSettingsAccessoryPreferenceProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbSettingsAccessoryPreferenceProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbSettingsAccessoryPreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_UsbSettingsAccessoryPreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbAccessoryFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UserPackageProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbSettingsDevicePreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbSettingsDevicePreferenceProto_default_instance_;
    new (ptr) ::android::service::usb::UsbSettingsDevicePreferenceProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbSettingsDevicePreferenceProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbSettingsDevicePreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_UsbSettingsDevicePreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbDeviceFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UserPackageProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbSettingsManagerProto_default_instance_;
    new (ptr) ::android::service::usb::UsbSettingsManagerProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbSettingsManagerProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_UsbSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbUserSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbProfileGroupSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbUidPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbUidPermissionProto_default_instance_;
    new (ptr) ::android::service::usb::UsbUidPermissionProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbUidPermissionProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UsbUidPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UsbUidPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static void InitDefaultsscc_info_UsbUserPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbUserPermissionsManagerProto_default_instance_;
    new (ptr) ::android::service::usb::UsbUserPermissionsManagerProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbUserPermissionsManagerProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_UsbUserPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 4, InitDefaultsscc_info_UsbUserPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbDevicePermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbAccessoryPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbDevicePersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbAccessoryPersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UsbUserSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UsbUserSettingsManagerProto_default_instance_;
    new (ptr) ::android::service::usb::UsbUserSettingsManagerProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UsbUserSettingsManagerProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UsbUserSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_UsbUserSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {
      &scc_info_UsbDeviceAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
      &scc_info_UsbAccessoryAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,}};

static void InitDefaultsscc_info_UserPackageProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::android::service::usb::_UserPackageProto_default_instance_;
    new (ptr) ::android::service::usb::UserPackageProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::android::service::usb::UserPackageProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UserPackageProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_UserPackageProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto[37];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto[4];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbServiceDumpProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbServiceDumpProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbServiceDumpProto, device_manager_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbServiceDumpProto, host_manager_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbServiceDumpProto, port_manager_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbServiceDumpProto, alsa_manager_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbServiceDumpProto, settings_manager_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbServiceDumpProto, permissions_manager_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceManagerProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceManagerProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceManagerProto, handler_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceManagerProto, debugging_manager_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbHandlerProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbHandlerProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbHandlerProto, current_functions_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbHandlerProto, current_functions_applied_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbHandlerProto, screen_unlocked_functions_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbHandlerProto, screen_locked_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbHandlerProto, connected_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbHandlerProto, configured_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbHandlerProto, current_accessory_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbHandlerProto, host_connected_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbHandlerProto, source_power_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbHandlerProto, sink_power_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbHandlerProto, usb_charging_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbHandlerProto, hide_usb_notification_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbHandlerProto, audio_accessory_connected_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbHandlerProto, adb_enabled_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbHandlerProto, kernel_state_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbHandlerProto, kernel_function_list_),
  ~0u,
  3,
  ~0u,
  4,
  5,
  6,
  2,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAccessoryProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAccessoryProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAccessoryProto, manufacturer_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAccessoryProto, model_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAccessoryProto, description_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAccessoryProto, version_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAccessoryProto, uri_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAccessoryProto, serial_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDebuggingManagerProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDebuggingManagerProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDebuggingManagerProto, connected_to_adb_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDebuggingManagerProto, last_key_received_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDebuggingManagerProto, user_keys_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDebuggingManagerProto, system_keys_),
  3,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbHostManagerProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbHostManagerProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbHostManagerProto, default_usb_host_connection_handler_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbHostManagerProto, devices_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbHostManagerProto, num_connects_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbHostManagerProto, connections_),
  0,
  ~0u,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceProto, name_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceProto, vendor_id_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceProto, product_id_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceProto, class__),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceProto, subclass_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceProto, protocol_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceProto, manufacturer_name_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceProto, product_name_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceProto, version_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceProto, serial_number_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceProto, configurations_),
  0,
  5,
  6,
  7,
  8,
  9,
  1,
  2,
  3,
  4,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbConfigurationProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbConfigurationProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbConfigurationProto, id_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbConfigurationProto, name_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbConfigurationProto, attributes_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbConfigurationProto, max_power_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbConfigurationProto, interfaces_),
  1,
  0,
  2,
  3,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbInterfaceProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbInterfaceProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbInterfaceProto, id_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbInterfaceProto, alternate_settings_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbInterfaceProto, name_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbInterfaceProto, class__),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbInterfaceProto, subclass_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbInterfaceProto, protocol_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbInterfaceProto, endpoints_),
  1,
  2,
  0,
  3,
  4,
  5,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbEndPointProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbEndPointProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbEndPointProto, endpoint_number_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbEndPointProto, direction_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbEndPointProto, address_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbEndPointProto, type_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbEndPointProto, attributes_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbEndPointProto, max_packet_size_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbEndPointProto, interval_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbConnectionRecordProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbConnectionRecordProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbConnectionRecordProto, device_address_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbConnectionRecordProto, mode_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbConnectionRecordProto, timestamp_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbConnectionRecordProto, manufacturer_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbConnectionRecordProto, product_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbConnectionRecordProto, is_headset_),
  0,
  3,
  2,
  4,
  5,
  1,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbIsHeadsetProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbIsHeadsetProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbIsHeadsetProto, in_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbIsHeadsetProto, out_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortManagerProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortManagerProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortManagerProto, is_simulation_active_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortManagerProto, usb_ports_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortManagerProto, enable_usb_data_signaling_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortInfoProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortInfoProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortInfoProto, port_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortInfoProto, status_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortInfoProto, can_change_mode_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortInfoProto, can_change_power_role_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortInfoProto, can_change_data_role_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortInfoProto, connected_at_millis_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortInfoProto, last_connect_duration_millis_),
  0,
  1,
  4,
  5,
  6,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortProto, id_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortProto, supported_modes_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortStatusProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortStatusProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortStatusProto, connected_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortStatusProto, current_mode_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortStatusProto, power_role_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortStatusProto, data_role_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortStatusProto, role_combinations_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortStatusProto, contaminant_presence_status_),
  0,
  1,
  2,
  3,
  ~0u,
  4,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortStatusRoleCombinationProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortStatusRoleCombinationProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortStatusRoleCombinationProto, power_role_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPortStatusRoleCombinationProto, data_role_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAlsaManagerProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAlsaManagerProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAlsaManagerProto, cards_parser_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAlsaManagerProto, alsa_devices_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAlsaManagerProto, midi_devices_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAlsaDeviceProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAlsaDeviceProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAlsaDeviceProto, card_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAlsaDeviceProto, device_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAlsaDeviceProto, name_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAlsaDeviceProto, has_playback_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAlsaDeviceProto, has_capture_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAlsaDeviceProto, address_),
  2,
  3,
  0,
  4,
  5,
  1,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbMidiDeviceProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbMidiDeviceProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbMidiDeviceProto, card_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbMidiDeviceProto, device_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbMidiDeviceProto, device_address_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbSettingsManagerProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbSettingsManagerProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbSettingsManagerProto, user_settings_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbSettingsManagerProto, profile_group_settings_),
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbUserSettingsManagerProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbUserSettingsManagerProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbUserSettingsManagerProto, user_id_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbUserSettingsManagerProto, device_attached_activities_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbUserSettingsManagerProto, accessory_attached_activities_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbProfileGroupSettingsManagerProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbProfileGroupSettingsManagerProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbProfileGroupSettingsManagerProto, parent_user_id_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbProfileGroupSettingsManagerProto, device_preferences_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbProfileGroupSettingsManagerProto, accessory_preferences_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbSettingsDevicePreferenceProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbSettingsDevicePreferenceProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbSettingsDevicePreferenceProto, filter_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbSettingsDevicePreferenceProto, user_package_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPermissionsManagerProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPermissionsManagerProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbPermissionsManagerProto, user_permissions_),
  ~0u,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbUserPermissionsManagerProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbUserPermissionsManagerProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbUserPermissionsManagerProto, user_id_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbUserPermissionsManagerProto, device_permissions_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbUserPermissionsManagerProto, accessory_permissions_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbUserPermissionsManagerProto, device_persistent_permissions_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbUserPermissionsManagerProto, accessory_persistent_permissions_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDevicePermissionProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDevicePermissionProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDevicePermissionProto, device_name_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDevicePermissionProto, uids_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAccessoryPermissionProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAccessoryPermissionProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAccessoryPermissionProto, accessory_description_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAccessoryPermissionProto, uids_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDevicePersistentPermissionProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDevicePersistentPermissionProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDevicePersistentPermissionProto, device_filter_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDevicePersistentPermissionProto, permission_values_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAccessoryPersistentPermissionProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAccessoryPersistentPermissionProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAccessoryPersistentPermissionProto, accessory_filter_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAccessoryPersistentPermissionProto, permission_values_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbUidPermissionProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbUidPermissionProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbUidPermissionProto, uid_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbUidPermissionProto, is_granted_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceFilterProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceFilterProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceFilterProto, vendor_id_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceFilterProto, product_id_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceFilterProto, class__),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceFilterProto, subclass_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceFilterProto, protocol_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceFilterProto, manufacturer_name_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceFilterProto, product_name_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceFilterProto, serial_number_),
  3,
  4,
  5,
  6,
  7,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UserPackageProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UserPackageProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UserPackageProto, user_id_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UserPackageProto, package_name_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbSettingsAccessoryPreferenceProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbSettingsAccessoryPreferenceProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbSettingsAccessoryPreferenceProto, filter_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbSettingsAccessoryPreferenceProto, user_package_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAccessoryFilterProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAccessoryFilterProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAccessoryFilterProto, manufacturer_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAccessoryFilterProto, model_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAccessoryFilterProto, version_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceAttachedActivities, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceAttachedActivities, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceAttachedActivities, activity_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbDeviceAttachedActivities, filters_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAccessoryAttachedActivities, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAccessoryAttachedActivities, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAccessoryAttachedActivities, activity_),
  PROTOBUF_FIELD_OFFSET(::android::service::usb::UsbAccessoryAttachedActivities, filters_),
  0,
  ~0u,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 11, sizeof(::android::service::usb::UsbServiceDumpProto)},
  { 17, 24, sizeof(::android::service::usb::UsbDeviceManagerProto)},
  { 26, 47, sizeof(::android::service::usb::UsbHandlerProto)},
  { 63, 74, sizeof(::android::service::usb::UsbAccessoryProto)},
  { 80, 89, sizeof(::android::service::usb::UsbDebuggingManagerProto)},
  { 93, 102, sizeof(::android::service::usb::UsbHostManagerProto)},
  { 106, 122, sizeof(::android::service::usb::UsbDeviceProto)},
  { 133, 143, sizeof(::android::service::usb::UsbConfigurationProto)},
  { 148, 160, sizeof(::android::service::usb::UsbInterfaceProto)},
  { 167, 179, sizeof(::android::service::usb::UsbEndPointProto)},
  { 186, 197, sizeof(::android::service::usb::UsbConnectionRecordProto)},
  { 203, 210, sizeof(::android::service::usb::UsbIsHeadsetProto)},
  { 212, 220, sizeof(::android::service::usb::UsbPortManagerProto)},
  { 223, 235, sizeof(::android::service::usb::UsbPortInfoProto)},
  { 242, 249, sizeof(::android::service::usb::UsbPortProto)},
  { 251, 262, sizeof(::android::service::usb::UsbPortStatusProto)},
  { 268, 275, sizeof(::android::service::usb::UsbPortStatusRoleCombinationProto)},
  { 277, 285, sizeof(::android::service::usb::UsbAlsaManagerProto)},
  { 288, 299, sizeof(::android::service::usb::UsbAlsaDeviceProto)},
  { 305, 313, sizeof(::android::service::usb::UsbMidiDeviceProto)},
  { 316, 323, sizeof(::android::service::usb::UsbSettingsManagerProto)},
  { 325, 333, sizeof(::android::service::usb::UsbUserSettingsManagerProto)},
  { 336, 344, sizeof(::android::service::usb::UsbProfileGroupSettingsManagerProto)},
  { 347, 354, sizeof(::android::service::usb::UsbSettingsDevicePreferenceProto)},
  { 356, 362, sizeof(::android::service::usb::UsbPermissionsManagerProto)},
  { 363, 373, sizeof(::android::service::usb::UsbUserPermissionsManagerProto)},
  { 378, 385, sizeof(::android::service::usb::UsbDevicePermissionProto)},
  { 387, 394, sizeof(::android::service::usb::UsbAccessoryPermissionProto)},
  { 396, 403, sizeof(::android::service::usb::UsbDevicePersistentPermissionProto)},
  { 405, 412, sizeof(::android::service::usb::UsbAccessoryPersistentPermissionProto)},
  { 414, 421, sizeof(::android::service::usb::UsbUidPermissionProto)},
  { 423, 436, sizeof(::android::service::usb::UsbDeviceFilterProto)},
  { 444, 451, sizeof(::android::service::usb::UserPackageProto)},
  { 453, 460, sizeof(::android::service::usb::UsbSettingsAccessoryPreferenceProto)},
  { 462, 470, sizeof(::android::service::usb::UsbAccessoryFilterProto)},
  { 473, 480, sizeof(::android::service::usb::UsbDeviceAttachedActivities)},
  { 482, 489, sizeof(::android::service::usb::UsbAccessoryAttachedActivities)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbServiceDumpProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbDeviceManagerProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbHandlerProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbAccessoryProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbDebuggingManagerProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbHostManagerProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbDeviceProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbConfigurationProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbInterfaceProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbEndPointProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbConnectionRecordProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbIsHeadsetProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbPortManagerProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbPortInfoProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbPortProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbPortStatusProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbPortStatusRoleCombinationProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbAlsaManagerProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbAlsaDeviceProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbMidiDeviceProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbSettingsManagerProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbUserSettingsManagerProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbProfileGroupSettingsManagerProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbSettingsDevicePreferenceProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbPermissionsManagerProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbUserPermissionsManagerProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbDevicePermissionProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbAccessoryPermissionProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbDevicePersistentPermissionProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbAccessoryPersistentPermissionProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbUidPermissionProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbDeviceFilterProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UserPackageProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbSettingsAccessoryPreferenceProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbAccessoryFilterProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbDeviceAttachedActivities_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::android::service::usb::_UsbAccessoryAttachedActivities_default_instance_),
};

const char descriptor_table_protodef_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n4frameworks/base/core/proto/android/ser"
  "vice/usb.proto\022\023android.service.usb\032\?fra"
  "meworks/base/core/proto/android/content/"
  "component_name.proto\0320frameworks/base/co"
  "re/proto/android/privacy.proto\0328framewor"
  "ks/proto_logging/stats/enums/service/enu"
  "ms.proto\"\272\003\n\023UsbServiceDumpProto\022B\n\016devi"
  "ce_manager\030\001 \001(\0132*.android.service.usb.U"
  "sbDeviceManagerProto\022>\n\014host_manager\030\002 \001"
  "(\0132(.android.service.usb.UsbHostManagerP"
  "roto\022>\n\014port_manager\030\003 \001(\0132(.android.ser"
  "vice.usb.UsbPortManagerProto\022>\n\014alsa_man"
  "ager\030\004 \001(\0132(.android.service.usb.UsbAlsa"
  "ManagerProto\022F\n\020settings_manager\030\005 \001(\0132,"
  ".android.service.usb.UsbSettingsManagerP"
  "roto\022L\n\023permissions_manager\030\006 \001(\0132/.andr"
  "oid.service.usb.UsbPermissionsManagerPro"
  "to:\t\232\237\325\207\003\003\010\310\001\"\243\001\n\025UsbDeviceManagerProto\022"
  "5\n\007handler\030\001 \001(\0132$.android.service.usb.U"
  "sbHandlerProto\022H\n\021debugging_manager\030\002 \001("
  "\0132-.android.service.usb.UsbDebuggingMana"
  "gerProto:\t\232\237\325\207\003\003\010\310\001\"\334\005\n\017UsbHandlerProto\022"
  "H\n\021current_functions\030\001 \003(\0162-.android.ser"
  "vice.usb.UsbHandlerProto.Function\022!\n\031cur"
  "rent_functions_applied\030\002 \001(\010\022P\n\031screen_u"
  "nlocked_functions\030\003 \003(\0162-.android.servic"
  "e.usb.UsbHandlerProto.Function\022\025\n\rscreen"
  "_locked\030\004 \001(\010\022\021\n\tconnected\030\005 \001(\010\022\022\n\nconf"
  "igured\030\006 \001(\010\022A\n\021current_accessory\030\007 \001(\0132"
  "&.android.service.usb.UsbAccessoryProto\022"
  "\026\n\016host_connected\030\010 \001(\010\022\024\n\014source_power\030"
  "\t \001(\010\022\022\n\nsink_power\030\n \001(\010\022\024\n\014usb_chargin"
  "g\030\013 \001(\010\022\035\n\025hide_usb_notification\030\014 \001(\010\022!"
  "\n\031audio_accessory_connected\030\r \001(\010\022\023\n\013adb"
  "_enabled\030\016 \001(\010\022\024\n\014kernel_state\030\017 \001(\t\022\034\n\024"
  "kernel_function_list\030\020 \001(\t\"\232\001\n\010Function\022"
  "\020\n\014FUNCTION_ADB\020\001\022\026\n\022FUNCTION_ACCESSORY\020"
  "\002\022\020\n\014FUNCTION_MTP\020\004\022\021\n\rFUNCTION_MIDI\020\010\022\020"
  "\n\014FUNCTION_PTP\020\020\022\022\n\016FUNCTION_RNDIS\020 \022\031\n\025"
  "FUNCTION_AUDIO_SOURCE\020@:\t\232\237\325\207\003\003\010\310\001\"\232\001\n\021U"
  "sbAccessoryProto\022\024\n\014manufacturer\030\001 \001(\t\022\r"
  "\n\005model\030\002 \001(\t\022\023\n\013description\030\003 \001(\t\022\017\n\007ve"
  "rsion\030\004 \001(\t\022\025\n\003uri\030\005 \001(\tB\010\232\237\325\207\003\002\010d\022\030\n\006se"
  "rial\030\006 \001(\tB\010\232\237\325\207\003\002\010\000:\t\232\237\325\207\003\003\010\310\001\"\240\001\n\030UsbD"
  "ebuggingManagerProto\022\030\n\020connected_to_adb"
  "\030\001 \001(\010\022#\n\021last_key_received\030\002 \001(\tB\010\232\237\325\207\003"
  "\002\010d\022\033\n\tuser_keys\030\003 \001(\tB\010\232\237\325\207\003\002\010\000\022\035\n\013syst"
  "em_keys\030\004 \001(\tB\010\232\237\325\207\003\002\010\000:\t\232\237\325\207\003\003\010\310\001\"\202\002\n\023U"
  "sbHostManagerProto\022P\n#default_usb_host_c"
  "onnection_handler\030\001 \001(\0132#.android.conten"
  "t.ComponentNameProto\0224\n\007devices\030\002 \003(\0132#."
  "android.service.usb.UsbDeviceProto\022\024\n\014nu"
  "m_connects\030\003 \001(\005\022B\n\013connections\030\004 \003(\0132-."
  "android.service.usb.UsbConnectionRecordP"
  "roto:\t\232\237\325\207\003\003\010\310\001\"\252\002\n\016UsbDeviceProto\022\014\n\004na"
  "me\030\001 \001(\t\022\021\n\tvendor_id\030\002 \001(\005\022\022\n\nproduct_i"
  "d\030\003 \001(\005\022\r\n\005class\030\004 \001(\005\022\020\n\010subclass\030\005 \001(\005"
  "\022\020\n\010protocol\030\006 \001(\005\022\031\n\021manufacturer_name\030"
  "\007 \001(\t\022\024\n\014product_name\030\010 \001(\t\022\017\n\007version\030\t"
  " \001(\t\022\037\n\rserial_number\030\n \001(\tB\010\232\237\325\207\003\002\010\000\022B\n"
  "\016configurations\030\013 \003(\0132*.android.service."
  "usb.UsbConfigurationProto:\t\232\237\325\207\003\003\010\310\001\"\237\001\n"
  "\025UsbConfigurationProto\022\n\n\002id\030\001 \001(\005\022\014\n\004na"
  "me\030\002 \001(\t\022\022\n\nattributes\030\003 \001(\r\022\021\n\tmax_powe"
  "r\030\004 \001(\005\022:\n\ninterfaces\030\005 \003(\0132&.android.se"
  "rvice.usb.UsbInterfaceProto:\t\232\237\325\207\003\003\010\310\001\"\301"
  "\001\n\021UsbInterfaceProto\022\n\n\002id\030\001 \001(\005\022\032\n\022alte"
  "rnate_settings\030\002 \001(\005\022\014\n\004name\030\003 \001(\t\022\r\n\005cl"
  "ass\030\004 \001(\005\022\020\n\010subclass\030\005 \001(\005\022\020\n\010protocol\030"
  "\006 \001(\005\0228\n\tendpoints\030\007 \003(\0132%.android.servi"
  "ce.usb.UsbEndPointProto:\t\232\237\325\207\003\003\010\310\001\"\360\001\n\020U"
  "sbEndPointProto\022\027\n\017endpoint_number\030\001 \001(\005"
  "\0228\n\tdirection\030\002 \001(\0162%.android.service.Us"
  "bEndPointDirection\022\017\n\007address\030\003 \001(\005\022.\n\004t"
  "ype\030\004 \001(\0162 .android.service.UsbEndPointT"
  "ype\022\022\n\nattributes\030\005 \001(\r\022\027\n\017max_packet_si"
  "ze\030\006 \001(\005\022\020\n\010interval\030\007 \001(\005:\t\232\237\325\207\003\003\010\310\001\"\353\001"
  "\n\030UsbConnectionRecordProto\022\026\n\016device_add"
  "ress\030\001 \001(\t\0226\n\004mode\030\002 \001(\0162(.android.servi"
  "ce.UsbConnectionRecordMode\022\021\n\ttimestamp\030"
  "\003 \001(\003\022\024\n\014manufacturer\030\004 \001(\005\022\017\n\007product\030\005"
  " \001(\005\022:\n\nis_headset\030\006 \001(\0132&.android.servi"
  "ce.usb.UsbIsHeadsetProto:\t\232\237\325\207\003\003\010\310\001\"7\n\021U"
  "sbIsHeadsetProto\022\n\n\002in\030\001 \001(\010\022\013\n\003out\030\002 \001("
  "\010:\t\232\237\325\207\003\003\010\310\001\"\233\001\n\023UsbPortManagerProto\022\034\n\024"
  "is_simulation_active\030\001 \001(\010\0228\n\tusb_ports\030"
  "\002 \003(\0132%.android.service.usb.UsbPortInfoP"
  "roto\022!\n\031enable_usb_data_signaling\030\003 \001(\010:"
  "\t\232\237\325\207\003\003\010\310\001\"\240\002\n\020UsbPortInfoProto\022/\n\004port\030"
  "\001 \001(\0132!.android.service.usb.UsbPortProto"
  "\0227\n\006status\030\002 \001(\0132\'.android.service.usb.U"
  "sbPortStatusProto\022\027\n\017can_change_mode\030\003 \001"
  "(\010\022\035\n\025can_change_power_role\030\004 \001(\010\022\034\n\024can"
  "_change_data_role\030\005 \001(\010\022\033\n\023connected_at_"
  "millis\030\006 \001(\003\022$\n\034last_connect_duration_mi"
  "llis\030\007 \001(\003:\t\232\237\325\207\003\003\010\310\001\"\333\001\n\014UsbPortProto\022\n"
  "\n\002id\030\001 \001(\t\022\?\n\017supported_modes\030\002 \003(\0162&.an"
  "droid.service.usb.UsbPortProto.Mode\"s\n\004M"
  "ode\022\r\n\tMODE_NONE\020\000\022\014\n\010MODE_UFP\020\001\022\014\n\010MODE"
  "_DFP\020\002\022\014\n\010MODE_DRP\020\003\022\030\n\024MODE_AUDIO_ACCES"
  "SORY\020\004\022\030\n\024MODE_DEBUG_ACCESSORY\020\010:\t\232\237\325\207\003\003"
  "\010\310\001\"\270\004\n\022UsbPortStatusProto\022\021\n\tconnected\030"
  "\001 \001(\010\022<\n\014current_mode\030\002 \001(\0162&.android.se"
  "rvice.usb.UsbPortProto.Mode\022E\n\npower_rol"
  "e\030\003 \001(\01621.android.service.usb.UsbPortSta"
  "tusProto.PowerRole\022C\n\tdata_role\030\004 \001(\01620."
  "android.service.usb.UsbPortStatusProto.D"
  "ataRole\022Q\n\021role_combinations\030\005 \003(\01326.and"
  "roid.service.usb.UsbPortStatusRoleCombin"
  "ationProto\022O\n\033contaminant_presence_statu"
  "s\030\006 \001(\0162*.android.service.ContaminantPre"
  "senceStatus\"L\n\tPowerRole\022\023\n\017POWER_ROLE_N"
  "ONE\020\000\022\025\n\021POWER_ROLE_SOURCE\020\001\022\023\n\017POWER_RO"
  "LE_SINK\020\002\"H\n\010DataRole\022\022\n\016DATA_ROLE_NONE\020"
  "\000\022\022\n\016DATA_ROLE_HOST\020\001\022\024\n\020DATA_ROLE_DEVIC"
  "E\020\002:\t\232\237\325\207\003\003\010\310\001\"\272\001\n!UsbPortStatusRoleComb"
  "inationProto\022E\n\npower_role\030\001 \001(\01621.andro"
  "id.service.usb.UsbPortStatusProto.PowerR"
  "ole\022C\n\tdata_role\030\002 \001(\01620.android.service"
  ".usb.UsbPortStatusProto.DataRole:\t\232\237\325\207\003\003"
  "\010\310\001\"\264\001\n\023UsbAlsaManagerProto\022\024\n\014cards_par"
  "ser\030\001 \001(\005\022=\n\014alsa_devices\030\002 \003(\0132\'.androi"
  "d.service.usb.UsbAlsaDeviceProto\022=\n\014midi"
  "_devices\030\003 \003(\0132\'.android.service.usb.Usb"
  "MidiDeviceProto:\t\232\237\325\207\003\003\010\310\001\"\207\001\n\022UsbAlsaDe"
  "viceProto\022\014\n\004card\030\001 \001(\005\022\016\n\006device\030\002 \001(\005\022"
  "\014\n\004name\030\003 \001(\t\022\024\n\014has_playback\030\004 \001(\010\022\023\n\013h"
  "as_capture\030\005 \001(\010\022\017\n\007address\030\006 \001(\t:\t\232\237\325\207\003"
  "\003\010\310\001\"U\n\022UsbMidiDeviceProto\022\014\n\004card\030\001 \001(\005"
  "\022\016\n\006device\030\002 \001(\005\022\026\n\016device_address\030\003 \001(\t"
  ":\t\232\237\325\207\003\003\010\310\001\"\307\001\n\027UsbSettingsManagerProto\022"
  "G\n\ruser_settings\030\001 \003(\01320.android.service"
  ".usb.UsbUserSettingsManagerProto\022X\n\026prof"
  "ile_group_settings\030\002 \003(\01328.android.servi"
  "ce.usb.UsbProfileGroupSettingsManagerPro"
  "to:\t\232\237\325\207\003\003\010\310\001\"\367\001\n\033UsbUserSettingsManager"
  "Proto\022\017\n\007user_id\030\001 \001(\005\022T\n\032device_attache"
  "d_activities\030\004 \003(\01320.android.service.usb"
  ".UsbDeviceAttachedActivities\022Z\n\035accessor"
  "y_attached_activities\030\005 \003(\01323.android.se"
  "rvice.usb.UsbAccessoryAttachedActivities"
  ":\t\232\237\325\207\003\003\010\310\001J\004\010\002\020\003J\004\010\003\020\004\"\364\001\n#UsbProfileGr"
  "oupSettingsManagerProto\022\026\n\016parent_user_i"
  "d\030\001 \001(\005\022Q\n\022device_preferences\030\002 \003(\01325.an"
  "droid.service.usb.UsbSettingsDevicePrefe"
  "renceProto\022W\n\025accessory_preferences\030\003 \003("
  "\01328.android.service.usb.UsbSettingsAcces"
  "soryPreferenceProto:\t\232\237\325\207\003\003\010\310\001\"\245\001\n UsbSe"
  "ttingsDevicePreferenceProto\0229\n\006filter\030\001 "
  "\001(\0132).android.service.usb.UsbDeviceFilte"
  "rProto\022;\n\014user_package\030\002 \001(\0132%.android.s"
  "ervice.usb.UserPackageProto:\t\232\237\325\207\003\003\010\310\001\"v"
  "\n\032UsbPermissionsManagerProto\022M\n\020user_per"
  "missions\030\001 \003(\01323.android.service.usb.Usb"
  "UserPermissionsManagerProto:\t\232\237\325\207\003\003\010\310\001\"\236"
  "\003\n\036UsbUserPermissionsManagerProto\022\017\n\007use"
  "r_id\030\001 \001(\005\022I\n\022device_permissions\030\002 \003(\0132-"
  ".android.service.usb.UsbDevicePermission"
  "Proto\022O\n\025accessory_permissions\030\003 \003(\01320.a"
  "ndroid.service.usb.UsbAccessoryPermissio"
  "nProto\022^\n\035device_persistent_permissions\030"
  "\004 \003(\01327.android.service.usb.UsbDevicePer"
  "sistentPermissionProto\022d\n accessory_pers"
  "istent_permissions\030\005 \003(\0132:.android.servi"
  "ce.usb.UsbAccessoryPersistentPermissionP"
  "roto:\t\232\237\325\207\003\003\010\310\001\"H\n\030UsbDevicePermissionPr"
  "oto\022\023\n\013device_name\030\001 \001(\t\022\014\n\004uids\030\002 \003(\005:\t"
  "\232\237\325\207\003\003\010\310\001\"U\n\033UsbAccessoryPermissionProto"
  "\022\035\n\025accessory_description\030\001 \001(\t\022\014\n\004uids\030"
  "\002 \003(\005:\t\232\237\325\207\003\003\010\310\001\"\270\001\n\"UsbDevicePersistent"
  "PermissionProto\022@\n\rdevice_filter\030\001 \001(\0132)"
  ".android.service.usb.UsbDeviceFilterProt"
  "o\022E\n\021permission_values\030\002 \003(\0132*.android.s"
  "ervice.usb.UsbUidPermissionProto:\t\232\237\325\207\003\003"
  "\010\310\001\"\301\001\n%UsbAccessoryPersistentPermission"
  "Proto\022F\n\020accessory_filter\030\001 \001(\0132,.androi"
  "d.service.usb.UsbAccessoryFilterProto\022E\n"
  "\021permission_values\030\002 \003(\0132*.android.servi"
  "ce.usb.UsbUidPermissionProto:\t\232\237\325\207\003\003\010\310\001\""
  "C\n\025UsbUidPermissionProto\022\013\n\003uid\030\001 \001(\005\022\022\n"
  "\nis_granted\030\002 \001(\010:\t\232\237\325\207\003\003\010\310\001\"\315\001\n\024UsbDevi"
  "ceFilterProto\022\021\n\tvendor_id\030\001 \001(\005\022\022\n\nprod"
  "uct_id\030\002 \001(\005\022\r\n\005class\030\003 \001(\005\022\020\n\010subclass\030"
  "\004 \001(\005\022\020\n\010protocol\030\005 \001(\005\022\031\n\021manufacturer_"
  "name\030\006 \001(\t\022\024\n\014product_name\030\007 \001(\t\022\037\n\rseri"
  "al_number\030\010 \001(\tB\010\232\237\325\207\003\002\010d:\t\232\237\325\207\003\003\010\310\001\"D\n\020"
  "UserPackageProto\022\017\n\007user_id\030\001 \001(\005\022\024\n\014pac"
  "kage_name\030\002 \001(\t:\t\232\237\325\207\003\003\010\310\001\"\253\001\n#UsbSettin"
  "gsAccessoryPreferenceProto\022<\n\006filter\030\001 \001"
  "(\0132,.android.service.usb.UsbAccessoryFil"
  "terProto\022;\n\014user_package\030\002 \001(\0132%.android"
  ".service.usb.UserPackageProto:\t\232\237\325\207\003\003\010\310\001"
  "\"Z\n\027UsbAccessoryFilterProto\022\024\n\014manufactu"
  "rer\030\001 \001(\t\022\r\n\005model\030\002 \001(\t\022\017\n\007version\030\003 \001("
  "\t:\t\232\237\325\207\003\003\010\310\001\"\233\001\n\033UsbDeviceAttachedActivi"
  "ties\0225\n\010activity\030\001 \001(\0132#.android.content"
  ".ComponentNameProto\022:\n\007filters\030\002 \003(\0132).a"
  "ndroid.service.usb.UsbDeviceFilterProto:"
  "\t\232\237\325\207\003\003\010\310\001\"\241\001\n\036UsbAccessoryAttachedActiv"
  "ities\0225\n\010activity\030\001 \001(\0132#.android.conten"
  "t.ComponentNameProto\022=\n\007filters\030\002 \003(\0132,."
  "android.service.usb.UsbAccessoryFilterPr"
  "oto:\t\232\237\325\207\003\003\010\310\001B\023B\017UsbServiceProtoP\001"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto_deps[3] = {
  &::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fcontent_2fcomponent_5fname_2eproto,
  &::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fprivacy_2eproto,
  &::descriptor_table_frameworks_2fproto_5flogging_2fstats_2fenums_2fservice_2fenums_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto_sccs[37] = {
  &scc_info_UsbAccessoryAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbAccessoryFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbAccessoryPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbAccessoryPersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbAccessoryProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbAlsaDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbAlsaManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbConfigurationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbConnectionRecordProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbDebuggingManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbDeviceAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbDeviceFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbDeviceManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbDevicePermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbDevicePersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbEndPointProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbHandlerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbHostManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbInterfaceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbIsHeadsetProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbMidiDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbPortInfoProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbPortManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbPortProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbPortStatusProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbPortStatusRoleCombinationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbProfileGroupSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbServiceDumpProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbSettingsAccessoryPreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbSettingsDevicePreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbUidPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbUserPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UsbUserSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
  &scc_info_UserPackageProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto_once;
static bool descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto_initialized = false;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto = {
  &descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto_initialized, descriptor_table_protodef_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto, "frameworks/base/core/proto/android/service/usb.proto", 8115,
  &descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto_once, descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto_sccs, descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto_deps, 37, 3,
  schemas, file_default_instances, TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto::offsets,
  file_level_metadata_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto, 37, file_level_enum_descriptors_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto, file_level_service_descriptors_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto = (  ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto), true);
namespace android {
namespace service {
namespace usb {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UsbHandlerProto_Function_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
  return file_level_enum_descriptors_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto[0];
}
bool UsbHandlerProto_Function_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
    case 32:
    case 64:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr UsbHandlerProto_Function UsbHandlerProto::FUNCTION_ADB;
constexpr UsbHandlerProto_Function UsbHandlerProto::FUNCTION_ACCESSORY;
constexpr UsbHandlerProto_Function UsbHandlerProto::FUNCTION_MTP;
constexpr UsbHandlerProto_Function UsbHandlerProto::FUNCTION_MIDI;
constexpr UsbHandlerProto_Function UsbHandlerProto::FUNCTION_PTP;
constexpr UsbHandlerProto_Function UsbHandlerProto::FUNCTION_RNDIS;
constexpr UsbHandlerProto_Function UsbHandlerProto::FUNCTION_AUDIO_SOURCE;
constexpr UsbHandlerProto_Function UsbHandlerProto::Function_MIN;
constexpr UsbHandlerProto_Function UsbHandlerProto::Function_MAX;
constexpr int UsbHandlerProto::Function_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UsbPortProto_Mode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
  return file_level_enum_descriptors_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto[1];
}
bool UsbPortProto_Mode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 8:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr UsbPortProto_Mode UsbPortProto::MODE_NONE;
constexpr UsbPortProto_Mode UsbPortProto::MODE_UFP;
constexpr UsbPortProto_Mode UsbPortProto::MODE_DFP;
constexpr UsbPortProto_Mode UsbPortProto::MODE_DRP;
constexpr UsbPortProto_Mode UsbPortProto::MODE_AUDIO_ACCESSORY;
constexpr UsbPortProto_Mode UsbPortProto::MODE_DEBUG_ACCESSORY;
constexpr UsbPortProto_Mode UsbPortProto::Mode_MIN;
constexpr UsbPortProto_Mode UsbPortProto::Mode_MAX;
constexpr int UsbPortProto::Mode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UsbPortStatusProto_PowerRole_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
  return file_level_enum_descriptors_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto[2];
}
bool UsbPortStatusProto_PowerRole_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr UsbPortStatusProto_PowerRole UsbPortStatusProto::POWER_ROLE_NONE;
constexpr UsbPortStatusProto_PowerRole UsbPortStatusProto::POWER_ROLE_SOURCE;
constexpr UsbPortStatusProto_PowerRole UsbPortStatusProto::POWER_ROLE_SINK;
constexpr UsbPortStatusProto_PowerRole UsbPortStatusProto::PowerRole_MIN;
constexpr UsbPortStatusProto_PowerRole UsbPortStatusProto::PowerRole_MAX;
constexpr int UsbPortStatusProto::PowerRole_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UsbPortStatusProto_DataRole_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
  return file_level_enum_descriptors_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto[3];
}
bool UsbPortStatusProto_DataRole_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr UsbPortStatusProto_DataRole UsbPortStatusProto::DATA_ROLE_NONE;
constexpr UsbPortStatusProto_DataRole UsbPortStatusProto::DATA_ROLE_HOST;
constexpr UsbPortStatusProto_DataRole UsbPortStatusProto::DATA_ROLE_DEVICE;
constexpr UsbPortStatusProto_DataRole UsbPortStatusProto::DataRole_MIN;
constexpr UsbPortStatusProto_DataRole UsbPortStatusProto::DataRole_MAX;
constexpr int UsbPortStatusProto::DataRole_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void UsbServiceDumpProto::InitAsDefaultInstance() {
  ::android::service::usb::_UsbServiceDumpProto_default_instance_._instance.get_mutable()->device_manager_ = const_cast< ::android::service::usb::UsbDeviceManagerProto*>(
      ::android::service::usb::UsbDeviceManagerProto::internal_default_instance());
  ::android::service::usb::_UsbServiceDumpProto_default_instance_._instance.get_mutable()->host_manager_ = const_cast< ::android::service::usb::UsbHostManagerProto*>(
      ::android::service::usb::UsbHostManagerProto::internal_default_instance());
  ::android::service::usb::_UsbServiceDumpProto_default_instance_._instance.get_mutable()->port_manager_ = const_cast< ::android::service::usb::UsbPortManagerProto*>(
      ::android::service::usb::UsbPortManagerProto::internal_default_instance());
  ::android::service::usb::_UsbServiceDumpProto_default_instance_._instance.get_mutable()->alsa_manager_ = const_cast< ::android::service::usb::UsbAlsaManagerProto*>(
      ::android::service::usb::UsbAlsaManagerProto::internal_default_instance());
  ::android::service::usb::_UsbServiceDumpProto_default_instance_._instance.get_mutable()->settings_manager_ = const_cast< ::android::service::usb::UsbSettingsManagerProto*>(
      ::android::service::usb::UsbSettingsManagerProto::internal_default_instance());
  ::android::service::usb::_UsbServiceDumpProto_default_instance_._instance.get_mutable()->permissions_manager_ = const_cast< ::android::service::usb::UsbPermissionsManagerProto*>(
      ::android::service::usb::UsbPermissionsManagerProto::internal_default_instance());
}
class UsbServiceDumpProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbServiceDumpProto>()._has_bits_);
  static const ::android::service::usb::UsbDeviceManagerProto& device_manager(const UsbServiceDumpProto* msg);
  static void set_has_device_manager(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::android::service::usb::UsbHostManagerProto& host_manager(const UsbServiceDumpProto* msg);
  static void set_has_host_manager(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::android::service::usb::UsbPortManagerProto& port_manager(const UsbServiceDumpProto* msg);
  static void set_has_port_manager(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::android::service::usb::UsbAlsaManagerProto& alsa_manager(const UsbServiceDumpProto* msg);
  static void set_has_alsa_manager(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::android::service::usb::UsbSettingsManagerProto& settings_manager(const UsbServiceDumpProto* msg);
  static void set_has_settings_manager(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::android::service::usb::UsbPermissionsManagerProto& permissions_manager(const UsbServiceDumpProto* msg);
  static void set_has_permissions_manager(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::android::service::usb::UsbDeviceManagerProto&
UsbServiceDumpProto::_Internal::device_manager(const UsbServiceDumpProto* msg) {
  return *msg->device_manager_;
}
const ::android::service::usb::UsbHostManagerProto&
UsbServiceDumpProto::_Internal::host_manager(const UsbServiceDumpProto* msg) {
  return *msg->host_manager_;
}
const ::android::service::usb::UsbPortManagerProto&
UsbServiceDumpProto::_Internal::port_manager(const UsbServiceDumpProto* msg) {
  return *msg->port_manager_;
}
const ::android::service::usb::UsbAlsaManagerProto&
UsbServiceDumpProto::_Internal::alsa_manager(const UsbServiceDumpProto* msg) {
  return *msg->alsa_manager_;
}
const ::android::service::usb::UsbSettingsManagerProto&
UsbServiceDumpProto::_Internal::settings_manager(const UsbServiceDumpProto* msg) {
  return *msg->settings_manager_;
}
const ::android::service::usb::UsbPermissionsManagerProto&
UsbServiceDumpProto::_Internal::permissions_manager(const UsbServiceDumpProto* msg) {
  return *msg->permissions_manager_;
}
UsbServiceDumpProto::UsbServiceDumpProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbServiceDumpProto)
}
UsbServiceDumpProto::UsbServiceDumpProto(const UsbServiceDumpProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_device_manager()) {
    device_manager_ = new ::android::service::usb::UsbDeviceManagerProto(*from.device_manager_);
  } else {
    device_manager_ = nullptr;
  }
  if (from.has_host_manager()) {
    host_manager_ = new ::android::service::usb::UsbHostManagerProto(*from.host_manager_);
  } else {
    host_manager_ = nullptr;
  }
  if (from.has_port_manager()) {
    port_manager_ = new ::android::service::usb::UsbPortManagerProto(*from.port_manager_);
  } else {
    port_manager_ = nullptr;
  }
  if (from.has_alsa_manager()) {
    alsa_manager_ = new ::android::service::usb::UsbAlsaManagerProto(*from.alsa_manager_);
  } else {
    alsa_manager_ = nullptr;
  }
  if (from.has_settings_manager()) {
    settings_manager_ = new ::android::service::usb::UsbSettingsManagerProto(*from.settings_manager_);
  } else {
    settings_manager_ = nullptr;
  }
  if (from.has_permissions_manager()) {
    permissions_manager_ = new ::android::service::usb::UsbPermissionsManagerProto(*from.permissions_manager_);
  } else {
    permissions_manager_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbServiceDumpProto)
}

void UsbServiceDumpProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbServiceDumpProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  ::memset(&device_manager_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&permissions_manager_) -
      reinterpret_cast<char*>(&device_manager_)) + sizeof(permissions_manager_));
}

UsbServiceDumpProto::~UsbServiceDumpProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbServiceDumpProto)
  SharedDtor();
}

void UsbServiceDumpProto::SharedDtor() {
  if (this != internal_default_instance()) delete device_manager_;
  if (this != internal_default_instance()) delete host_manager_;
  if (this != internal_default_instance()) delete port_manager_;
  if (this != internal_default_instance()) delete alsa_manager_;
  if (this != internal_default_instance()) delete settings_manager_;
  if (this != internal_default_instance()) delete permissions_manager_;
}

void UsbServiceDumpProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbServiceDumpProto& UsbServiceDumpProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbServiceDumpProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbServiceDumpProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbServiceDumpProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(device_manager_ != nullptr);
      device_manager_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(host_manager_ != nullptr);
      host_manager_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(port_manager_ != nullptr);
      port_manager_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(alsa_manager_ != nullptr);
      alsa_manager_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(settings_manager_ != nullptr);
      settings_manager_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(permissions_manager_ != nullptr);
      permissions_manager_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbServiceDumpProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .android.service.usb.UsbDeviceManagerProto device_manager = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_device_manager(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbHostManagerProto host_manager = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_host_manager(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbPortManagerProto port_manager = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_port_manager(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbAlsaManagerProto alsa_manager = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(mutable_alsa_manager(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbSettingsManagerProto settings_manager = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(mutable_settings_manager(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbPermissionsManagerProto permissions_manager = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(mutable_permissions_manager(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbServiceDumpProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbServiceDumpProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .android.service.usb.UsbDeviceManagerProto device_manager = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_device_manager()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbHostManagerProto host_manager = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_host_manager()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbPortManagerProto port_manager = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_port_manager()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbAlsaManagerProto alsa_manager = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_alsa_manager()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbSettingsManagerProto settings_manager = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_settings_manager()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbPermissionsManagerProto permissions_manager = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_permissions_manager()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbServiceDumpProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbServiceDumpProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbServiceDumpProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbServiceDumpProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.service.usb.UsbDeviceManagerProto device_manager = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, _Internal::device_manager(this), output);
  }

  // optional .android.service.usb.UsbHostManagerProto host_manager = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, _Internal::host_manager(this), output);
  }

  // optional .android.service.usb.UsbPortManagerProto port_manager = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, _Internal::port_manager(this), output);
  }

  // optional .android.service.usb.UsbAlsaManagerProto alsa_manager = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, _Internal::alsa_manager(this), output);
  }

  // optional .android.service.usb.UsbSettingsManagerProto settings_manager = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, _Internal::settings_manager(this), output);
  }

  // optional .android.service.usb.UsbPermissionsManagerProto permissions_manager = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, _Internal::permissions_manager(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbServiceDumpProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbServiceDumpProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbServiceDumpProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.service.usb.UsbDeviceManagerProto device_manager = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::device_manager(this), target);
  }

  // optional .android.service.usb.UsbHostManagerProto host_manager = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, _Internal::host_manager(this), target);
  }

  // optional .android.service.usb.UsbPortManagerProto port_manager = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, _Internal::port_manager(this), target);
  }

  // optional .android.service.usb.UsbAlsaManagerProto alsa_manager = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, _Internal::alsa_manager(this), target);
  }

  // optional .android.service.usb.UsbSettingsManagerProto settings_manager = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, _Internal::settings_manager(this), target);
  }

  // optional .android.service.usb.UsbPermissionsManagerProto permissions_manager = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, _Internal::permissions_manager(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbServiceDumpProto)
  return target;
}

size_t UsbServiceDumpProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbServiceDumpProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .android.service.usb.UsbDeviceManagerProto device_manager = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *device_manager_);
    }

    // optional .android.service.usb.UsbHostManagerProto host_manager = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *host_manager_);
    }

    // optional .android.service.usb.UsbPortManagerProto port_manager = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *port_manager_);
    }

    // optional .android.service.usb.UsbAlsaManagerProto alsa_manager = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *alsa_manager_);
    }

    // optional .android.service.usb.UsbSettingsManagerProto settings_manager = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *settings_manager_);
    }

    // optional .android.service.usb.UsbPermissionsManagerProto permissions_manager = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *permissions_manager_);
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbServiceDumpProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbServiceDumpProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbServiceDumpProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbServiceDumpProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbServiceDumpProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbServiceDumpProto)
    MergeFrom(*source);
  }
}

void UsbServiceDumpProto::MergeFrom(const UsbServiceDumpProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbServiceDumpProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_device_manager()->::android::service::usb::UsbDeviceManagerProto::MergeFrom(from.device_manager());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_host_manager()->::android::service::usb::UsbHostManagerProto::MergeFrom(from.host_manager());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_port_manager()->::android::service::usb::UsbPortManagerProto::MergeFrom(from.port_manager());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_alsa_manager()->::android::service::usb::UsbAlsaManagerProto::MergeFrom(from.alsa_manager());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_settings_manager()->::android::service::usb::UsbSettingsManagerProto::MergeFrom(from.settings_manager());
    }
    if (cached_has_bits & 0x00000020u) {
      mutable_permissions_manager()->::android::service::usb::UsbPermissionsManagerProto::MergeFrom(from.permissions_manager());
    }
  }
}

void UsbServiceDumpProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbServiceDumpProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbServiceDumpProto::CopyFrom(const UsbServiceDumpProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbServiceDumpProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbServiceDumpProto::IsInitialized() const {
  return true;
}

void UsbServiceDumpProto::InternalSwap(UsbServiceDumpProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(device_manager_, other->device_manager_);
  swap(host_manager_, other->host_manager_);
  swap(port_manager_, other->port_manager_);
  swap(alsa_manager_, other->alsa_manager_);
  swap(settings_manager_, other->settings_manager_);
  swap(permissions_manager_, other->permissions_manager_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbServiceDumpProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbDeviceManagerProto::InitAsDefaultInstance() {
  ::android::service::usb::_UsbDeviceManagerProto_default_instance_._instance.get_mutable()->handler_ = const_cast< ::android::service::usb::UsbHandlerProto*>(
      ::android::service::usb::UsbHandlerProto::internal_default_instance());
  ::android::service::usb::_UsbDeviceManagerProto_default_instance_._instance.get_mutable()->debugging_manager_ = const_cast< ::android::service::usb::UsbDebuggingManagerProto*>(
      ::android::service::usb::UsbDebuggingManagerProto::internal_default_instance());
}
class UsbDeviceManagerProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbDeviceManagerProto>()._has_bits_);
  static const ::android::service::usb::UsbHandlerProto& handler(const UsbDeviceManagerProto* msg);
  static void set_has_handler(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::android::service::usb::UsbDebuggingManagerProto& debugging_manager(const UsbDeviceManagerProto* msg);
  static void set_has_debugging_manager(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::android::service::usb::UsbHandlerProto&
UsbDeviceManagerProto::_Internal::handler(const UsbDeviceManagerProto* msg) {
  return *msg->handler_;
}
const ::android::service::usb::UsbDebuggingManagerProto&
UsbDeviceManagerProto::_Internal::debugging_manager(const UsbDeviceManagerProto* msg) {
  return *msg->debugging_manager_;
}
UsbDeviceManagerProto::UsbDeviceManagerProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbDeviceManagerProto)
}
UsbDeviceManagerProto::UsbDeviceManagerProto(const UsbDeviceManagerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_handler()) {
    handler_ = new ::android::service::usb::UsbHandlerProto(*from.handler_);
  } else {
    handler_ = nullptr;
  }
  if (from.has_debugging_manager()) {
    debugging_manager_ = new ::android::service::usb::UsbDebuggingManagerProto(*from.debugging_manager_);
  } else {
    debugging_manager_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbDeviceManagerProto)
}

void UsbDeviceManagerProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbDeviceManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  ::memset(&handler_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&debugging_manager_) -
      reinterpret_cast<char*>(&handler_)) + sizeof(debugging_manager_));
}

UsbDeviceManagerProto::~UsbDeviceManagerProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbDeviceManagerProto)
  SharedDtor();
}

void UsbDeviceManagerProto::SharedDtor() {
  if (this != internal_default_instance()) delete handler_;
  if (this != internal_default_instance()) delete debugging_manager_;
}

void UsbDeviceManagerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbDeviceManagerProto& UsbDeviceManagerProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbDeviceManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbDeviceManagerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbDeviceManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(handler_ != nullptr);
      handler_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(debugging_manager_ != nullptr);
      debugging_manager_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbDeviceManagerProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .android.service.usb.UsbHandlerProto handler = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_handler(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbDebuggingManagerProto debugging_manager = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_debugging_manager(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbDeviceManagerProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbDeviceManagerProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .android.service.usb.UsbHandlerProto handler = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_handler()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbDebuggingManagerProto debugging_manager = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_debugging_manager()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbDeviceManagerProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbDeviceManagerProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbDeviceManagerProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbDeviceManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.service.usb.UsbHandlerProto handler = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, _Internal::handler(this), output);
  }

  // optional .android.service.usb.UsbDebuggingManagerProto debugging_manager = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, _Internal::debugging_manager(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbDeviceManagerProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbDeviceManagerProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbDeviceManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.service.usb.UsbHandlerProto handler = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::handler(this), target);
  }

  // optional .android.service.usb.UsbDebuggingManagerProto debugging_manager = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, _Internal::debugging_manager(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbDeviceManagerProto)
  return target;
}

size_t UsbDeviceManagerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbDeviceManagerProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .android.service.usb.UsbHandlerProto handler = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *handler_);
    }

    // optional .android.service.usb.UsbDebuggingManagerProto debugging_manager = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *debugging_manager_);
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbDeviceManagerProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbDeviceManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbDeviceManagerProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbDeviceManagerProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbDeviceManagerProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbDeviceManagerProto)
    MergeFrom(*source);
  }
}

void UsbDeviceManagerProto::MergeFrom(const UsbDeviceManagerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbDeviceManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_handler()->::android::service::usb::UsbHandlerProto::MergeFrom(from.handler());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_debugging_manager()->::android::service::usb::UsbDebuggingManagerProto::MergeFrom(from.debugging_manager());
    }
  }
}

void UsbDeviceManagerProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbDeviceManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbDeviceManagerProto::CopyFrom(const UsbDeviceManagerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbDeviceManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbDeviceManagerProto::IsInitialized() const {
  return true;
}

void UsbDeviceManagerProto::InternalSwap(UsbDeviceManagerProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(handler_, other->handler_);
  swap(debugging_manager_, other->debugging_manager_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbDeviceManagerProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbHandlerProto::InitAsDefaultInstance() {
  ::android::service::usb::_UsbHandlerProto_default_instance_._instance.get_mutable()->current_accessory_ = const_cast< ::android::service::usb::UsbAccessoryProto*>(
      ::android::service::usb::UsbAccessoryProto::internal_default_instance());
}
class UsbHandlerProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbHandlerProto>()._has_bits_);
  static void set_has_current_functions_applied(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_screen_locked(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_connected(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_configured(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::android::service::usb::UsbAccessoryProto& current_accessory(const UsbHandlerProto* msg);
  static void set_has_current_accessory(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_host_connected(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_source_power(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_sink_power(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_usb_charging(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_hide_usb_notification(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_audio_accessory_connected(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_adb_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_kernel_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_kernel_function_list(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::android::service::usb::UsbAccessoryProto&
UsbHandlerProto::_Internal::current_accessory(const UsbHandlerProto* msg) {
  return *msg->current_accessory_;
}
UsbHandlerProto::UsbHandlerProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbHandlerProto)
}
UsbHandlerProto::UsbHandlerProto(const UsbHandlerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      current_functions_(from.current_functions_),
      screen_unlocked_functions_(from.screen_unlocked_functions_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  kernel_state_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_kernel_state()) {
    kernel_state_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.kernel_state_);
  }
  kernel_function_list_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_kernel_function_list()) {
    kernel_function_list_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.kernel_function_list_);
  }
  if (from.has_current_accessory()) {
    current_accessory_ = new ::android::service::usb::UsbAccessoryProto(*from.current_accessory_);
  } else {
    current_accessory_ = nullptr;
  }
  ::memcpy(&current_functions_applied_, &from.current_functions_applied_,
    static_cast<size_t>(reinterpret_cast<char*>(&adb_enabled_) -
    reinterpret_cast<char*>(&current_functions_applied_)) + sizeof(adb_enabled_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbHandlerProto)
}

void UsbHandlerProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbHandlerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  kernel_state_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  kernel_function_list_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&current_accessory_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&adb_enabled_) -
      reinterpret_cast<char*>(&current_accessory_)) + sizeof(adb_enabled_));
}

UsbHandlerProto::~UsbHandlerProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbHandlerProto)
  SharedDtor();
}

void UsbHandlerProto::SharedDtor() {
  kernel_state_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  kernel_function_list_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete current_accessory_;
}

void UsbHandlerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbHandlerProto& UsbHandlerProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbHandlerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbHandlerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbHandlerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  current_functions_.Clear();
  screen_unlocked_functions_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      kernel_state_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      kernel_function_list_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(current_accessory_ != nullptr);
      current_accessory_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&current_functions_applied_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&host_connected_) -
        reinterpret_cast<char*>(&current_functions_applied_)) + sizeof(host_connected_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&source_power_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&adb_enabled_) -
        reinterpret_cast<char*>(&source_power_)) + sizeof(adb_enabled_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbHandlerProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .android.service.usb.UsbHandlerProto.Function current_functions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::android::service::usb::UsbHandlerProto_Function_IsValid(val))) {
              add_current_functions(static_cast<::android::service::usb::UsbHandlerProto_Function>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 8);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(mutable_current_functions(), ptr, ctx, ::android::service::usb::UsbHandlerProto_Function_IsValid, &_internal_metadata_, 1);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool current_functions_applied = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_current_functions_applied(&has_bits);
          current_functions_applied_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbHandlerProto.Function screen_unlocked_functions = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::android::service::usb::UsbHandlerProto_Function_IsValid(val))) {
              add_screen_unlocked_functions(static_cast<::android::service::usb::UsbHandlerProto_Function>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 24);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(mutable_screen_unlocked_functions(), ptr, ctx, ::android::service::usb::UsbHandlerProto_Function_IsValid, &_internal_metadata_, 3);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool screen_locked = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_screen_locked(&has_bits);
          screen_locked_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool connected = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_connected(&has_bits);
          connected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool configured = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_configured(&has_bits);
          configured_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbAccessoryProto current_accessory = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(mutable_current_accessory(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool host_connected = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_host_connected(&has_bits);
          host_connected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool source_power = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_source_power(&has_bits);
          source_power_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool sink_power = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_sink_power(&has_bits);
          sink_power_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool usb_charging = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_usb_charging(&has_bits);
          usb_charging_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool hide_usb_notification = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_hide_usb_notification(&has_bits);
          hide_usb_notification_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool audio_accessory_connected = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_audio_accessory_connected(&has_bits);
          audio_accessory_connected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool adb_enabled = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_adb_enabled(&has_bits);
          adb_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string kernel_state = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 122)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_kernel_state(), ptr, ctx, "android.service.usb.UsbHandlerProto.kernel_state");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string kernel_function_list = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 130)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_kernel_function_list(), ptr, ctx, "android.service.usb.UsbHandlerProto.kernel_function_list");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbHandlerProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbHandlerProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .android.service.usb.UsbHandlerProto.Function current_functions = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::service::usb::UsbHandlerProto_Function_IsValid(value)) {
            add_current_functions(static_cast< ::android::service::usb::UsbHandlerProto_Function >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ReadPackedEnumPreserveUnknowns(
                 input,
                 1,
                 ::android::service::usb::UsbHandlerProto_Function_IsValid,
                 mutable_unknown_fields(),
                 this->mutable_current_functions())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool current_functions_applied = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_current_functions_applied(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &current_functions_applied_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbHandlerProto.Function screen_unlocked_functions = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::service::usb::UsbHandlerProto_Function_IsValid(value)) {
            add_screen_unlocked_functions(static_cast< ::android::service::usb::UsbHandlerProto_Function >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                3, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ReadPackedEnumPreserveUnknowns(
                 input,
                 3,
                 ::android::service::usb::UsbHandlerProto_Function_IsValid,
                 mutable_unknown_fields(),
                 this->mutable_screen_unlocked_functions())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool screen_locked = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_screen_locked(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &screen_locked_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool connected = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_connected(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &connected_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool configured = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_configured(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &configured_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbAccessoryProto current_accessory = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (58 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_current_accessory()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool host_connected = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          _Internal::set_has_host_connected(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &host_connected_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool source_power = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          _Internal::set_has_source_power(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &source_power_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool sink_power = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (80 & 0xFF)) {
          _Internal::set_has_sink_power(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &sink_power_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool usb_charging = 11;
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (88 & 0xFF)) {
          _Internal::set_has_usb_charging(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &usb_charging_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool hide_usb_notification = 12;
      case 12: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (96 & 0xFF)) {
          _Internal::set_has_hide_usb_notification(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &hide_usb_notification_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool audio_accessory_connected = 13;
      case 13: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (104 & 0xFF)) {
          _Internal::set_has_audio_accessory_connected(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &audio_accessory_connected_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool adb_enabled = 14;
      case 14: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (112 & 0xFF)) {
          _Internal::set_has_adb_enabled(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &adb_enabled_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string kernel_state = 15;
      case 15: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (122 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_kernel_state()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->kernel_state().data(), static_cast<int>(this->kernel_state().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbHandlerProto.kernel_state");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string kernel_function_list = 16;
      case 16: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (130 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_kernel_function_list()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->kernel_function_list().data(), static_cast<int>(this->kernel_function_list().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbHandlerProto.kernel_function_list");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbHandlerProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbHandlerProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbHandlerProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbHandlerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbHandlerProto.Function current_functions = 1;
  for (int i = 0, n = this->current_functions_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->current_functions(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool current_functions_applied = 2;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(2, this->current_functions_applied(), output);
  }

  // repeated .android.service.usb.UsbHandlerProto.Function screen_unlocked_functions = 3;
  for (int i = 0, n = this->screen_unlocked_functions_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      3, this->screen_unlocked_functions(i), output);
  }

  // optional bool screen_locked = 4;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(4, this->screen_locked(), output);
  }

  // optional bool connected = 5;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(5, this->connected(), output);
  }

  // optional bool configured = 6;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(6, this->configured(), output);
  }

  // optional .android.service.usb.UsbAccessoryProto current_accessory = 7;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, _Internal::current_accessory(this), output);
  }

  // optional bool host_connected = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(8, this->host_connected(), output);
  }

  // optional bool source_power = 9;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(9, this->source_power(), output);
  }

  // optional bool sink_power = 10;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(10, this->sink_power(), output);
  }

  // optional bool usb_charging = 11;
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(11, this->usb_charging(), output);
  }

  // optional bool hide_usb_notification = 12;
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(12, this->hide_usb_notification(), output);
  }

  // optional bool audio_accessory_connected = 13;
  if (cached_has_bits & 0x00001000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(13, this->audio_accessory_connected(), output);
  }

  // optional bool adb_enabled = 14;
  if (cached_has_bits & 0x00002000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(14, this->adb_enabled(), output);
  }

  // optional string kernel_state = 15;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->kernel_state().data(), static_cast<int>(this->kernel_state().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbHandlerProto.kernel_state");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      15, this->kernel_state(), output);
  }

  // optional string kernel_function_list = 16;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->kernel_function_list().data(), static_cast<int>(this->kernel_function_list().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbHandlerProto.kernel_function_list");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      16, this->kernel_function_list(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbHandlerProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbHandlerProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbHandlerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbHandlerProto.Function current_functions = 1;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
    1, this->current_functions_, target);

  cached_has_bits = _has_bits_[0];
  // optional bool current_functions_applied = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->current_functions_applied(), target);
  }

  // repeated .android.service.usb.UsbHandlerProto.Function screen_unlocked_functions = 3;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
    3, this->screen_unlocked_functions_, target);

  // optional bool screen_locked = 4;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->screen_locked(), target);
  }

  // optional bool connected = 5;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->connected(), target);
  }

  // optional bool configured = 6;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->configured(), target);
  }

  // optional .android.service.usb.UsbAccessoryProto current_accessory = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, _Internal::current_accessory(this), target);
  }

  // optional bool host_connected = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->host_connected(), target);
  }

  // optional bool source_power = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->source_power(), target);
  }

  // optional bool sink_power = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->sink_power(), target);
  }

  // optional bool usb_charging = 11;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->usb_charging(), target);
  }

  // optional bool hide_usb_notification = 12;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->hide_usb_notification(), target);
  }

  // optional bool audio_accessory_connected = 13;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->audio_accessory_connected(), target);
  }

  // optional bool adb_enabled = 14;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->adb_enabled(), target);
  }

  // optional string kernel_state = 15;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->kernel_state().data(), static_cast<int>(this->kernel_state().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbHandlerProto.kernel_state");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        15, this->kernel_state(), target);
  }

  // optional string kernel_function_list = 16;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->kernel_function_list().data(), static_cast<int>(this->kernel_function_list().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbHandlerProto.kernel_function_list");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        16, this->kernel_function_list(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbHandlerProto)
  return target;
}

size_t UsbHandlerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbHandlerProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbHandlerProto.Function current_functions = 1;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->current_functions_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->current_functions(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .android.service.usb.UsbHandlerProto.Function screen_unlocked_functions = 3;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->screen_unlocked_functions_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->screen_unlocked_functions(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string kernel_state = 15;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->kernel_state());
    }

    // optional string kernel_function_list = 16;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->kernel_function_list());
    }

    // optional .android.service.usb.UsbAccessoryProto current_accessory = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *current_accessory_);
    }

    // optional bool current_functions_applied = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool screen_locked = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool connected = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool configured = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool host_connected = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional bool source_power = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool sink_power = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool usb_charging = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool hide_usb_notification = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool audio_accessory_connected = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool adb_enabled = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbHandlerProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbHandlerProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbHandlerProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbHandlerProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbHandlerProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbHandlerProto)
    MergeFrom(*source);
  }
}

void UsbHandlerProto::MergeFrom(const UsbHandlerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbHandlerProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  current_functions_.MergeFrom(from.current_functions_);
  screen_unlocked_functions_.MergeFrom(from.screen_unlocked_functions_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      kernel_state_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.kernel_state_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      kernel_function_list_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.kernel_function_list_);
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_current_accessory()->::android::service::usb::UsbAccessoryProto::MergeFrom(from.current_accessory());
    }
    if (cached_has_bits & 0x00000008u) {
      current_functions_applied_ = from.current_functions_applied_;
    }
    if (cached_has_bits & 0x00000010u) {
      screen_locked_ = from.screen_locked_;
    }
    if (cached_has_bits & 0x00000020u) {
      connected_ = from.connected_;
    }
    if (cached_has_bits & 0x00000040u) {
      configured_ = from.configured_;
    }
    if (cached_has_bits & 0x00000080u) {
      host_connected_ = from.host_connected_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      source_power_ = from.source_power_;
    }
    if (cached_has_bits & 0x00000200u) {
      sink_power_ = from.sink_power_;
    }
    if (cached_has_bits & 0x00000400u) {
      usb_charging_ = from.usb_charging_;
    }
    if (cached_has_bits & 0x00000800u) {
      hide_usb_notification_ = from.hide_usb_notification_;
    }
    if (cached_has_bits & 0x00001000u) {
      audio_accessory_connected_ = from.audio_accessory_connected_;
    }
    if (cached_has_bits & 0x00002000u) {
      adb_enabled_ = from.adb_enabled_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbHandlerProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbHandlerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbHandlerProto::CopyFrom(const UsbHandlerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbHandlerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbHandlerProto::IsInitialized() const {
  return true;
}

void UsbHandlerProto::InternalSwap(UsbHandlerProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  current_functions_.InternalSwap(&other->current_functions_);
  screen_unlocked_functions_.InternalSwap(&other->screen_unlocked_functions_);
  kernel_state_.Swap(&other->kernel_state_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  kernel_function_list_.Swap(&other->kernel_function_list_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(current_accessory_, other->current_accessory_);
  swap(current_functions_applied_, other->current_functions_applied_);
  swap(screen_locked_, other->screen_locked_);
  swap(connected_, other->connected_);
  swap(configured_, other->configured_);
  swap(host_connected_, other->host_connected_);
  swap(source_power_, other->source_power_);
  swap(sink_power_, other->sink_power_);
  swap(usb_charging_, other->usb_charging_);
  swap(hide_usb_notification_, other->hide_usb_notification_);
  swap(audio_accessory_connected_, other->audio_accessory_connected_);
  swap(adb_enabled_, other->adb_enabled_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbHandlerProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbAccessoryProto::InitAsDefaultInstance() {
}
class UsbAccessoryProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbAccessoryProto>()._has_bits_);
  static void set_has_manufacturer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_model(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_uri(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_serial(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

UsbAccessoryProto::UsbAccessoryProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbAccessoryProto)
}
UsbAccessoryProto::UsbAccessoryProto(const UsbAccessoryProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  manufacturer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_manufacturer()) {
    manufacturer_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.manufacturer_);
  }
  model_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_model()) {
    model_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.model_);
  }
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_description()) {
    description_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.description_);
  }
  version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_version()) {
    version_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.version_);
  }
  uri_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_uri()) {
    uri_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.uri_);
  }
  serial_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_serial()) {
    serial_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.serial_);
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbAccessoryProto)
}

void UsbAccessoryProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbAccessoryProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  manufacturer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  model_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  uri_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  serial_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

UsbAccessoryProto::~UsbAccessoryProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbAccessoryProto)
  SharedDtor();
}

void UsbAccessoryProto::SharedDtor() {
  manufacturer_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  model_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  uri_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  serial_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UsbAccessoryProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbAccessoryProto& UsbAccessoryProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbAccessoryProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbAccessoryProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbAccessoryProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      manufacturer_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      model_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      description_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      version_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      uri_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000020u) {
      serial_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbAccessoryProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string manufacturer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_manufacturer(), ptr, ctx, "android.service.usb.UsbAccessoryProto.manufacturer");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string model = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_model(), ptr, ctx, "android.service.usb.UsbAccessoryProto.model");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string description = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_description(), ptr, ctx, "android.service.usb.UsbAccessoryProto.description");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string version = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_version(), ptr, ctx, "android.service.usb.UsbAccessoryProto.version");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string uri = 5 [(.android.privacy) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_uri(), ptr, ctx, "android.service.usb.UsbAccessoryProto.uri");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string serial = 6 [(.android.privacy) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_serial(), ptr, ctx, "android.service.usb.UsbAccessoryProto.serial");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbAccessoryProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbAccessoryProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string manufacturer = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_manufacturer()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->manufacturer().data(), static_cast<int>(this->manufacturer().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbAccessoryProto.manufacturer");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string model = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_model()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model().data(), static_cast<int>(this->model().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbAccessoryProto.model");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string description = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->description().data(), static_cast<int>(this->description().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbAccessoryProto.description");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string version = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->version().data(), static_cast<int>(this->version().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbAccessoryProto.version");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string uri = 5 [(.android.privacy) = {
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_uri()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->uri().data(), static_cast<int>(this->uri().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbAccessoryProto.uri");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string serial = 6 [(.android.privacy) = {
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_serial()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->serial().data(), static_cast<int>(this->serial().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbAccessoryProto.serial");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbAccessoryProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbAccessoryProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbAccessoryProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbAccessoryProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string manufacturer = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->manufacturer().data(), static_cast<int>(this->manufacturer().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbAccessoryProto.manufacturer");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->manufacturer(), output);
  }

  // optional string model = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model().data(), static_cast<int>(this->model().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbAccessoryProto.model");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->model(), output);
  }

  // optional string description = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->description().data(), static_cast<int>(this->description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbAccessoryProto.description");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->description(), output);
  }

  // optional string version = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), static_cast<int>(this->version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbAccessoryProto.version");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->version(), output);
  }

  // optional string uri = 5 [(.android.privacy) = {
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->uri().data(), static_cast<int>(this->uri().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbAccessoryProto.uri");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->uri(), output);
  }

  // optional string serial = 6 [(.android.privacy) = {
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->serial().data(), static_cast<int>(this->serial().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbAccessoryProto.serial");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->serial(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbAccessoryProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbAccessoryProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbAccessoryProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string manufacturer = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->manufacturer().data(), static_cast<int>(this->manufacturer().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbAccessoryProto.manufacturer");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        1, this->manufacturer(), target);
  }

  // optional string model = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model().data(), static_cast<int>(this->model().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbAccessoryProto.model");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        2, this->model(), target);
  }

  // optional string description = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->description().data(), static_cast<int>(this->description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbAccessoryProto.description");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        3, this->description(), target);
  }

  // optional string version = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), static_cast<int>(this->version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbAccessoryProto.version");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        4, this->version(), target);
  }

  // optional string uri = 5 [(.android.privacy) = {
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->uri().data(), static_cast<int>(this->uri().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbAccessoryProto.uri");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        5, this->uri(), target);
  }

  // optional string serial = 6 [(.android.privacy) = {
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->serial().data(), static_cast<int>(this->serial().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbAccessoryProto.serial");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        6, this->serial(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbAccessoryProto)
  return target;
}

size_t UsbAccessoryProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbAccessoryProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string manufacturer = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->manufacturer());
    }

    // optional string model = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->model());
    }

    // optional string description = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->description());
    }

    // optional string version = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional string uri = 5 [(.android.privacy) = {
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->uri());
    }

    // optional string serial = 6 [(.android.privacy) = {
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->serial());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbAccessoryProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbAccessoryProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbAccessoryProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbAccessoryProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbAccessoryProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbAccessoryProto)
    MergeFrom(*source);
  }
}

void UsbAccessoryProto::MergeFrom(const UsbAccessoryProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbAccessoryProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      manufacturer_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.manufacturer_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      model_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.model_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      description_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.description_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      version_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.version_);
    }
    if (cached_has_bits & 0x00000010u) {
      _has_bits_[0] |= 0x00000010u;
      uri_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.uri_);
    }
    if (cached_has_bits & 0x00000020u) {
      _has_bits_[0] |= 0x00000020u;
      serial_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.serial_);
    }
  }
}

void UsbAccessoryProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbAccessoryProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbAccessoryProto::CopyFrom(const UsbAccessoryProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbAccessoryProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbAccessoryProto::IsInitialized() const {
  return true;
}

void UsbAccessoryProto::InternalSwap(UsbAccessoryProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  manufacturer_.Swap(&other->manufacturer_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  model_.Swap(&other->model_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  description_.Swap(&other->description_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  version_.Swap(&other->version_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  uri_.Swap(&other->uri_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  serial_.Swap(&other->serial_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbAccessoryProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbDebuggingManagerProto::InitAsDefaultInstance() {
}
class UsbDebuggingManagerProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbDebuggingManagerProto>()._has_bits_);
  static void set_has_connected_to_adb(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_last_key_received(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_user_keys(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_system_keys(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

UsbDebuggingManagerProto::UsbDebuggingManagerProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbDebuggingManagerProto)
}
UsbDebuggingManagerProto::UsbDebuggingManagerProto(const UsbDebuggingManagerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  last_key_received_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_last_key_received()) {
    last_key_received_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.last_key_received_);
  }
  user_keys_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_user_keys()) {
    user_keys_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.user_keys_);
  }
  system_keys_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_system_keys()) {
    system_keys_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.system_keys_);
  }
  connected_to_adb_ = from.connected_to_adb_;
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbDebuggingManagerProto)
}

void UsbDebuggingManagerProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbDebuggingManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  last_key_received_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  user_keys_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  system_keys_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  connected_to_adb_ = false;
}

UsbDebuggingManagerProto::~UsbDebuggingManagerProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbDebuggingManagerProto)
  SharedDtor();
}

void UsbDebuggingManagerProto::SharedDtor() {
  last_key_received_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  user_keys_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  system_keys_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UsbDebuggingManagerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbDebuggingManagerProto& UsbDebuggingManagerProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbDebuggingManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbDebuggingManagerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbDebuggingManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      last_key_received_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      user_keys_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      system_keys_.ClearNonDefaultToEmptyNoArena();
    }
  }
  connected_to_adb_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbDebuggingManagerProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bool connected_to_adb = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_connected_to_adb(&has_bits);
          connected_to_adb_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string last_key_received = 2 [(.android.privacy) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_last_key_received(), ptr, ctx, "android.service.usb.UsbDebuggingManagerProto.last_key_received");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string user_keys = 3 [(.android.privacy) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_user_keys(), ptr, ctx, "android.service.usb.UsbDebuggingManagerProto.user_keys");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string system_keys = 4 [(.android.privacy) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_system_keys(), ptr, ctx, "android.service.usb.UsbDebuggingManagerProto.system_keys");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbDebuggingManagerProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbDebuggingManagerProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool connected_to_adb = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_connected_to_adb(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &connected_to_adb_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string last_key_received = 2 [(.android.privacy) = {
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_last_key_received()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->last_key_received().data(), static_cast<int>(this->last_key_received().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbDebuggingManagerProto.last_key_received");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string user_keys = 3 [(.android.privacy) = {
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_user_keys()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->user_keys().data(), static_cast<int>(this->user_keys().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbDebuggingManagerProto.user_keys");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string system_keys = 4 [(.android.privacy) = {
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_system_keys()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->system_keys().data(), static_cast<int>(this->system_keys().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbDebuggingManagerProto.system_keys");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbDebuggingManagerProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbDebuggingManagerProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbDebuggingManagerProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbDebuggingManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool connected_to_adb = 1;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(1, this->connected_to_adb(), output);
  }

  // optional string last_key_received = 2 [(.android.privacy) = {
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->last_key_received().data(), static_cast<int>(this->last_key_received().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbDebuggingManagerProto.last_key_received");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->last_key_received(), output);
  }

  // optional string user_keys = 3 [(.android.privacy) = {
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user_keys().data(), static_cast<int>(this->user_keys().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbDebuggingManagerProto.user_keys");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->user_keys(), output);
  }

  // optional string system_keys = 4 [(.android.privacy) = {
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->system_keys().data(), static_cast<int>(this->system_keys().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbDebuggingManagerProto.system_keys");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->system_keys(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbDebuggingManagerProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbDebuggingManagerProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbDebuggingManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool connected_to_adb = 1;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->connected_to_adb(), target);
  }

  // optional string last_key_received = 2 [(.android.privacy) = {
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->last_key_received().data(), static_cast<int>(this->last_key_received().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbDebuggingManagerProto.last_key_received");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        2, this->last_key_received(), target);
  }

  // optional string user_keys = 3 [(.android.privacy) = {
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user_keys().data(), static_cast<int>(this->user_keys().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbDebuggingManagerProto.user_keys");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        3, this->user_keys(), target);
  }

  // optional string system_keys = 4 [(.android.privacy) = {
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->system_keys().data(), static_cast<int>(this->system_keys().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbDebuggingManagerProto.system_keys");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        4, this->system_keys(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbDebuggingManagerProto)
  return target;
}

size_t UsbDebuggingManagerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbDebuggingManagerProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string last_key_received = 2 [(.android.privacy) = {
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->last_key_received());
    }

    // optional string user_keys = 3 [(.android.privacy) = {
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->user_keys());
    }

    // optional string system_keys = 4 [(.android.privacy) = {
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->system_keys());
    }

    // optional bool connected_to_adb = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbDebuggingManagerProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbDebuggingManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbDebuggingManagerProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbDebuggingManagerProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbDebuggingManagerProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbDebuggingManagerProto)
    MergeFrom(*source);
  }
}

void UsbDebuggingManagerProto::MergeFrom(const UsbDebuggingManagerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbDebuggingManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      last_key_received_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.last_key_received_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      user_keys_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.user_keys_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      system_keys_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.system_keys_);
    }
    if (cached_has_bits & 0x00000008u) {
      connected_to_adb_ = from.connected_to_adb_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbDebuggingManagerProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbDebuggingManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbDebuggingManagerProto::CopyFrom(const UsbDebuggingManagerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbDebuggingManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbDebuggingManagerProto::IsInitialized() const {
  return true;
}

void UsbDebuggingManagerProto::InternalSwap(UsbDebuggingManagerProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  last_key_received_.Swap(&other->last_key_received_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  user_keys_.Swap(&other->user_keys_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  system_keys_.Swap(&other->system_keys_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(connected_to_adb_, other->connected_to_adb_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbDebuggingManagerProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbHostManagerProto::InitAsDefaultInstance() {
  ::android::service::usb::_UsbHostManagerProto_default_instance_._instance.get_mutable()->default_usb_host_connection_handler_ = const_cast< ::android::content::ComponentNameProto*>(
      ::android::content::ComponentNameProto::internal_default_instance());
}
class UsbHostManagerProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbHostManagerProto>()._has_bits_);
  static const ::android::content::ComponentNameProto& default_usb_host_connection_handler(const UsbHostManagerProto* msg);
  static void set_has_default_usb_host_connection_handler(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_connects(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::android::content::ComponentNameProto&
UsbHostManagerProto::_Internal::default_usb_host_connection_handler(const UsbHostManagerProto* msg) {
  return *msg->default_usb_host_connection_handler_;
}
void UsbHostManagerProto::clear_default_usb_host_connection_handler() {
  if (default_usb_host_connection_handler_ != nullptr) default_usb_host_connection_handler_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
UsbHostManagerProto::UsbHostManagerProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbHostManagerProto)
}
UsbHostManagerProto::UsbHostManagerProto(const UsbHostManagerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      devices_(from.devices_),
      connections_(from.connections_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_default_usb_host_connection_handler()) {
    default_usb_host_connection_handler_ = new ::android::content::ComponentNameProto(*from.default_usb_host_connection_handler_);
  } else {
    default_usb_host_connection_handler_ = nullptr;
  }
  num_connects_ = from.num_connects_;
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbHostManagerProto)
}

void UsbHostManagerProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbHostManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  ::memset(&default_usb_host_connection_handler_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&num_connects_) -
      reinterpret_cast<char*>(&default_usb_host_connection_handler_)) + sizeof(num_connects_));
}

UsbHostManagerProto::~UsbHostManagerProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbHostManagerProto)
  SharedDtor();
}

void UsbHostManagerProto::SharedDtor() {
  if (this != internal_default_instance()) delete default_usb_host_connection_handler_;
}

void UsbHostManagerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbHostManagerProto& UsbHostManagerProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbHostManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbHostManagerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbHostManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  devices_.Clear();
  connections_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(default_usb_host_connection_handler_ != nullptr);
    default_usb_host_connection_handler_->Clear();
  }
  num_connects_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbHostManagerProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .android.content.ComponentNameProto default_usb_host_connection_handler = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_default_usb_host_connection_handler(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbDeviceProto devices = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_devices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      // optional int32 num_connects = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_num_connects(&has_bits);
          num_connects_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbConnectionRecordProto connections = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_connections(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 34);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbHostManagerProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbHostManagerProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .android.content.ComponentNameProto default_usb_host_connection_handler = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_default_usb_host_connection_handler()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbDeviceProto devices = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_devices()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_connects = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_num_connects(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_connects_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbConnectionRecordProto connections = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_connections()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbHostManagerProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbHostManagerProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbHostManagerProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbHostManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.content.ComponentNameProto default_usb_host_connection_handler = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, _Internal::default_usb_host_connection_handler(this), output);
  }

  // repeated .android.service.usb.UsbDeviceProto devices = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->devices_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->devices(static_cast<int>(i)),
      output);
  }

  // optional int32 num_connects = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->num_connects(), output);
  }

  // repeated .android.service.usb.UsbConnectionRecordProto connections = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->connections_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      4,
      this->connections(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbHostManagerProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbHostManagerProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbHostManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.content.ComponentNameProto default_usb_host_connection_handler = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::default_usb_host_connection_handler(this), target);
  }

  // repeated .android.service.usb.UsbDeviceProto devices = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->devices_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->devices(static_cast<int>(i)), target);
  }

  // optional int32 num_connects = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->num_connects(), target);
  }

  // repeated .android.service.usb.UsbConnectionRecordProto connections = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->connections_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, this->connections(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbHostManagerProto)
  return target;
}

size_t UsbHostManagerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbHostManagerProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbDeviceProto devices = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->devices_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->devices(static_cast<int>(i)));
    }
  }

  // repeated .android.service.usb.UsbConnectionRecordProto connections = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->connections_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->connections(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .android.content.ComponentNameProto default_usb_host_connection_handler = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *default_usb_host_connection_handler_);
    }

    // optional int32 num_connects = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_connects());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbHostManagerProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbHostManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbHostManagerProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbHostManagerProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbHostManagerProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbHostManagerProto)
    MergeFrom(*source);
  }
}

void UsbHostManagerProto::MergeFrom(const UsbHostManagerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbHostManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  devices_.MergeFrom(from.devices_);
  connections_.MergeFrom(from.connections_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_default_usb_host_connection_handler()->::android::content::ComponentNameProto::MergeFrom(from.default_usb_host_connection_handler());
    }
    if (cached_has_bits & 0x00000002u) {
      num_connects_ = from.num_connects_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbHostManagerProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbHostManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbHostManagerProto::CopyFrom(const UsbHostManagerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbHostManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbHostManagerProto::IsInitialized() const {
  return true;
}

void UsbHostManagerProto::InternalSwap(UsbHostManagerProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&devices_)->InternalSwap(CastToBase(&other->devices_));
  CastToBase(&connections_)->InternalSwap(CastToBase(&other->connections_));
  swap(default_usb_host_connection_handler_, other->default_usb_host_connection_handler_);
  swap(num_connects_, other->num_connects_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbHostManagerProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbDeviceProto::InitAsDefaultInstance() {
}
class UsbDeviceProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbDeviceProto>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_vendor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_product_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_class_(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_subclass(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_protocol(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_manufacturer_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_product_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_serial_number(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

UsbDeviceProto::UsbDeviceProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbDeviceProto)
}
UsbDeviceProto::UsbDeviceProto(const UsbDeviceProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      configurations_(from.configurations_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  manufacturer_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_manufacturer_name()) {
    manufacturer_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.manufacturer_name_);
  }
  product_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_product_name()) {
    product_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.product_name_);
  }
  version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_version()) {
    version_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.version_);
  }
  serial_number_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_serial_number()) {
    serial_number_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.serial_number_);
  }
  ::memcpy(&vendor_id_, &from.vendor_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&protocol_) -
    reinterpret_cast<char*>(&vendor_id_)) + sizeof(protocol_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbDeviceProto)
}

void UsbDeviceProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  manufacturer_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  product_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  serial_number_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&vendor_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&protocol_) -
      reinterpret_cast<char*>(&vendor_id_)) + sizeof(protocol_));
}

UsbDeviceProto::~UsbDeviceProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbDeviceProto)
  SharedDtor();
}

void UsbDeviceProto::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  manufacturer_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  product_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  serial_number_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UsbDeviceProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbDeviceProto& UsbDeviceProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbDeviceProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbDeviceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  configurations_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      manufacturer_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      product_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      version_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      serial_number_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&vendor_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&class__) -
        reinterpret_cast<char*>(&vendor_id_)) + sizeof(class__));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&subclass_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&protocol_) -
        reinterpret_cast<char*>(&subclass_)) + sizeof(protocol_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbDeviceProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_name(), ptr, ctx, "android.service.usb.UsbDeviceProto.name");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 vendor_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_vendor_id(&has_bits);
          vendor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 product_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_product_id(&has_bits);
          product_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 class = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_class_(&has_bits);
          class__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 subclass = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_subclass(&has_bits);
          subclass_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 protocol = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_protocol(&has_bits);
          protocol_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string manufacturer_name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_manufacturer_name(), ptr, ctx, "android.service.usb.UsbDeviceProto.manufacturer_name");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string product_name = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_product_name(), ptr, ctx, "android.service.usb.UsbDeviceProto.product_name");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string version = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_version(), ptr, ctx, "android.service.usb.UsbDeviceProto.version");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string serial_number = 10 [(.android.privacy) = {
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_serial_number(), ptr, ctx, "android.service.usb.UsbDeviceProto.serial_number");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbConfigurationProto configurations = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_configurations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 90);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbDeviceProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbDeviceProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), static_cast<int>(this->name().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbDeviceProto.name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 vendor_id = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_vendor_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &vendor_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 product_id = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_product_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &product_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 class = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_class_(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &class__)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 subclass = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_subclass(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &subclass_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 protocol = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_protocol(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &protocol_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string manufacturer_name = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (58 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_manufacturer_name()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->manufacturer_name().data(), static_cast<int>(this->manufacturer_name().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbDeviceProto.manufacturer_name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string product_name = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (66 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_product_name()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->product_name().data(), static_cast<int>(this->product_name().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbDeviceProto.product_name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string version = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (74 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->version().data(), static_cast<int>(this->version().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbDeviceProto.version");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string serial_number = 10 [(.android.privacy) = {
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (82 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_serial_number()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->serial_number().data(), static_cast<int>(this->serial_number().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbDeviceProto.serial_number");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbConfigurationProto configurations = 11;
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (90 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_configurations()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbDeviceProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbDeviceProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbDeviceProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbDeviceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbDeviceProto.name");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional int32 vendor_id = 2;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->vendor_id(), output);
  }

  // optional int32 product_id = 3;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->product_id(), output);
  }

  // optional int32 class = 4;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->class_(), output);
  }

  // optional int32 subclass = 5;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->subclass(), output);
  }

  // optional int32 protocol = 6;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(6, this->protocol(), output);
  }

  // optional string manufacturer_name = 7;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->manufacturer_name().data(), static_cast<int>(this->manufacturer_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbDeviceProto.manufacturer_name");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->manufacturer_name(), output);
  }

  // optional string product_name = 8;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->product_name().data(), static_cast<int>(this->product_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbDeviceProto.product_name");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->product_name(), output);
  }

  // optional string version = 9;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), static_cast<int>(this->version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbDeviceProto.version");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->version(), output);
  }

  // optional string serial_number = 10 [(.android.privacy) = {
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->serial_number().data(), static_cast<int>(this->serial_number().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbDeviceProto.serial_number");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      10, this->serial_number(), output);
  }

  // repeated .android.service.usb.UsbConfigurationProto configurations = 11;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->configurations_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      11,
      this->configurations(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbDeviceProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbDeviceProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbDeviceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbDeviceProto.name");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional int32 vendor_id = 2;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->vendor_id(), target);
  }

  // optional int32 product_id = 3;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->product_id(), target);
  }

  // optional int32 class = 4;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->class_(), target);
  }

  // optional int32 subclass = 5;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->subclass(), target);
  }

  // optional int32 protocol = 6;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->protocol(), target);
  }

  // optional string manufacturer_name = 7;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->manufacturer_name().data(), static_cast<int>(this->manufacturer_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbDeviceProto.manufacturer_name");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        7, this->manufacturer_name(), target);
  }

  // optional string product_name = 8;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->product_name().data(), static_cast<int>(this->product_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbDeviceProto.product_name");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        8, this->product_name(), target);
  }

  // optional string version = 9;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), static_cast<int>(this->version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbDeviceProto.version");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        9, this->version(), target);
  }

  // optional string serial_number = 10 [(.android.privacy) = {
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->serial_number().data(), static_cast<int>(this->serial_number().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbDeviceProto.serial_number");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        10, this->serial_number(), target);
  }

  // repeated .android.service.usb.UsbConfigurationProto configurations = 11;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->configurations_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        11, this->configurations(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbDeviceProto)
  return target;
}

size_t UsbDeviceProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbDeviceProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbConfigurationProto configurations = 11;
  {
    unsigned int count = static_cast<unsigned int>(this->configurations_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->configurations(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string manufacturer_name = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->manufacturer_name());
    }

    // optional string product_name = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->product_name());
    }

    // optional string version = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional string serial_number = 10 [(.android.privacy) = {
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->serial_number());
    }

    // optional int32 vendor_id = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->vendor_id());
    }

    // optional int32 product_id = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->product_id());
    }

    // optional int32 class = 4;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->class_());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional int32 subclass = 5;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->subclass());
    }

    // optional int32 protocol = 6;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->protocol());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbDeviceProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbDeviceProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbDeviceProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbDeviceProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbDeviceProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbDeviceProto)
    MergeFrom(*source);
  }
}

void UsbDeviceProto::MergeFrom(const UsbDeviceProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbDeviceProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  configurations_.MergeFrom(from.configurations_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      manufacturer_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.manufacturer_name_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      product_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.product_name_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      version_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.version_);
    }
    if (cached_has_bits & 0x00000010u) {
      _has_bits_[0] |= 0x00000010u;
      serial_number_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.serial_number_);
    }
    if (cached_has_bits & 0x00000020u) {
      vendor_id_ = from.vendor_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      product_id_ = from.product_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      class__ = from.class__;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      subclass_ = from.subclass_;
    }
    if (cached_has_bits & 0x00000200u) {
      protocol_ = from.protocol_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbDeviceProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbDeviceProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbDeviceProto::CopyFrom(const UsbDeviceProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbDeviceProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbDeviceProto::IsInitialized() const {
  return true;
}

void UsbDeviceProto::InternalSwap(UsbDeviceProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&configurations_)->InternalSwap(CastToBase(&other->configurations_));
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  manufacturer_name_.Swap(&other->manufacturer_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  product_name_.Swap(&other->product_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  version_.Swap(&other->version_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  serial_number_.Swap(&other->serial_number_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(vendor_id_, other->vendor_id_);
  swap(product_id_, other->product_id_);
  swap(class__, other->class__);
  swap(subclass_, other->subclass_);
  swap(protocol_, other->protocol_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbDeviceProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbConfigurationProto::InitAsDefaultInstance() {
}
class UsbConfigurationProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbConfigurationProto>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_attributes(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_max_power(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

UsbConfigurationProto::UsbConfigurationProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbConfigurationProto)
}
UsbConfigurationProto::UsbConfigurationProto(const UsbConfigurationProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      interfaces_(from.interfaces_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_power_) -
    reinterpret_cast<char*>(&id_)) + sizeof(max_power_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbConfigurationProto)
}

void UsbConfigurationProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbConfigurationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_power_) -
      reinterpret_cast<char*>(&id_)) + sizeof(max_power_));
}

UsbConfigurationProto::~UsbConfigurationProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbConfigurationProto)
  SharedDtor();
}

void UsbConfigurationProto::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UsbConfigurationProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbConfigurationProto& UsbConfigurationProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbConfigurationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbConfigurationProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbConfigurationProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  interfaces_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_power_) -
        reinterpret_cast<char*>(&id_)) + sizeof(max_power_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbConfigurationProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_name(), ptr, ctx, "android.service.usb.UsbConfigurationProto.name");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 attributes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_attributes(&has_bits);
          attributes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 max_power = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_max_power(&has_bits);
          max_power_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbInterfaceProto interfaces = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_interfaces(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 42);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbConfigurationProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbConfigurationProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string name = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), static_cast<int>(this->name().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbConfigurationProto.name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 attributes = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_attributes(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &attributes_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 max_power = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_max_power(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_power_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbInterfaceProto interfaces = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_interfaces()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbConfigurationProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbConfigurationProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbConfigurationProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbConfigurationProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 id = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbConfigurationProto.name");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // optional uint32 attributes = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->attributes(), output);
  }

  // optional int32 max_power = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->max_power(), output);
  }

  // repeated .android.service.usb.UsbInterfaceProto interfaces = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->interfaces_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      5,
      this->interfaces(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbConfigurationProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbConfigurationProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbConfigurationProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbConfigurationProto.name");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // optional uint32 attributes = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->attributes(), target);
  }

  // optional int32 max_power = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->max_power(), target);
  }

  // repeated .android.service.usb.UsbInterfaceProto interfaces = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->interfaces_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, this->interfaces(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbConfigurationProto)
  return target;
}

size_t UsbConfigurationProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbConfigurationProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbInterfaceProto interfaces = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->interfaces_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->interfaces(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional uint32 attributes = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->attributes());
    }

    // optional int32 max_power = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->max_power());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbConfigurationProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbConfigurationProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbConfigurationProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbConfigurationProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbConfigurationProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbConfigurationProto)
    MergeFrom(*source);
  }
}

void UsbConfigurationProto::MergeFrom(const UsbConfigurationProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbConfigurationProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  interfaces_.MergeFrom(from.interfaces_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      attributes_ = from.attributes_;
    }
    if (cached_has_bits & 0x00000008u) {
      max_power_ = from.max_power_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbConfigurationProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbConfigurationProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbConfigurationProto::CopyFrom(const UsbConfigurationProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbConfigurationProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbConfigurationProto::IsInitialized() const {
  return true;
}

void UsbConfigurationProto::InternalSwap(UsbConfigurationProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&interfaces_)->InternalSwap(CastToBase(&other->interfaces_));
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(id_, other->id_);
  swap(attributes_, other->attributes_);
  swap(max_power_, other->max_power_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbConfigurationProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbInterfaceProto::InitAsDefaultInstance() {
}
class UsbInterfaceProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbInterfaceProto>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_alternate_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_class_(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_subclass(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_protocol(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

UsbInterfaceProto::UsbInterfaceProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbInterfaceProto)
}
UsbInterfaceProto::UsbInterfaceProto(const UsbInterfaceProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      endpoints_(from.endpoints_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&protocol_) -
    reinterpret_cast<char*>(&id_)) + sizeof(protocol_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbInterfaceProto)
}

void UsbInterfaceProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbInterfaceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&protocol_) -
      reinterpret_cast<char*>(&id_)) + sizeof(protocol_));
}

UsbInterfaceProto::~UsbInterfaceProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbInterfaceProto)
  SharedDtor();
}

void UsbInterfaceProto::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UsbInterfaceProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbInterfaceProto& UsbInterfaceProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbInterfaceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbInterfaceProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbInterfaceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  endpoints_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&protocol_) -
        reinterpret_cast<char*>(&id_)) + sizeof(protocol_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbInterfaceProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 alternate_settings = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_alternate_settings(&has_bits);
          alternate_settings_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_name(), ptr, ctx, "android.service.usb.UsbInterfaceProto.name");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 class = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_class_(&has_bits);
          class__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 subclass = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_subclass(&has_bits);
          subclass_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 protocol = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_protocol(&has_bits);
          protocol_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbEndPointProto endpoints = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_endpoints(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 58);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbInterfaceProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbInterfaceProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 alternate_settings = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_alternate_settings(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &alternate_settings_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string name = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), static_cast<int>(this->name().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbInterfaceProto.name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 class = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_class_(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &class__)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 subclass = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_subclass(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &subclass_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 protocol = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_protocol(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &protocol_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbEndPointProto endpoints = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (58 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_endpoints()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbInterfaceProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbInterfaceProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbInterfaceProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbInterfaceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 id = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional int32 alternate_settings = 2;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->alternate_settings(), output);
  }

  // optional string name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbInterfaceProto.name");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->name(), output);
  }

  // optional int32 class = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->class_(), output);
  }

  // optional int32 subclass = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->subclass(), output);
  }

  // optional int32 protocol = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(6, this->protocol(), output);
  }

  // repeated .android.service.usb.UsbEndPointProto endpoints = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->endpoints_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      7,
      this->endpoints(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbInterfaceProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbInterfaceProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbInterfaceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // optional int32 alternate_settings = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->alternate_settings(), target);
  }

  // optional string name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbInterfaceProto.name");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        3, this->name(), target);
  }

  // optional int32 class = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->class_(), target);
  }

  // optional int32 subclass = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->subclass(), target);
  }

  // optional int32 protocol = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->protocol(), target);
  }

  // repeated .android.service.usb.UsbEndPointProto endpoints = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->endpoints_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, this->endpoints(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbInterfaceProto)
  return target;
}

size_t UsbInterfaceProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbInterfaceProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbEndPointProto endpoints = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->endpoints_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->endpoints(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional int32 alternate_settings = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->alternate_settings());
    }

    // optional int32 class = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->class_());
    }

    // optional int32 subclass = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->subclass());
    }

    // optional int32 protocol = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->protocol());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbInterfaceProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbInterfaceProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbInterfaceProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbInterfaceProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbInterfaceProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbInterfaceProto)
    MergeFrom(*source);
  }
}

void UsbInterfaceProto::MergeFrom(const UsbInterfaceProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbInterfaceProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  endpoints_.MergeFrom(from.endpoints_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      alternate_settings_ = from.alternate_settings_;
    }
    if (cached_has_bits & 0x00000008u) {
      class__ = from.class__;
    }
    if (cached_has_bits & 0x00000010u) {
      subclass_ = from.subclass_;
    }
    if (cached_has_bits & 0x00000020u) {
      protocol_ = from.protocol_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbInterfaceProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbInterfaceProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbInterfaceProto::CopyFrom(const UsbInterfaceProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbInterfaceProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbInterfaceProto::IsInitialized() const {
  return true;
}

void UsbInterfaceProto::InternalSwap(UsbInterfaceProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&endpoints_)->InternalSwap(CastToBase(&other->endpoints_));
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(id_, other->id_);
  swap(alternate_settings_, other->alternate_settings_);
  swap(class__, other->class__);
  swap(subclass_, other->subclass_);
  swap(protocol_, other->protocol_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbInterfaceProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbEndPointProto::InitAsDefaultInstance() {
}
class UsbEndPointProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbEndPointProto>()._has_bits_);
  static void set_has_endpoint_number(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_address(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_attributes(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_max_packet_size(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_interval(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

UsbEndPointProto::UsbEndPointProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbEndPointProto)
}
UsbEndPointProto::UsbEndPointProto(const UsbEndPointProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&endpoint_number_, &from.endpoint_number_,
    static_cast<size_t>(reinterpret_cast<char*>(&interval_) -
    reinterpret_cast<char*>(&endpoint_number_)) + sizeof(interval_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbEndPointProto)
}

void UsbEndPointProto::SharedCtor() {
  ::memset(&endpoint_number_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&interval_) -
      reinterpret_cast<char*>(&endpoint_number_)) + sizeof(interval_));
}

UsbEndPointProto::~UsbEndPointProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbEndPointProto)
  SharedDtor();
}

void UsbEndPointProto::SharedDtor() {
}

void UsbEndPointProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbEndPointProto& UsbEndPointProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbEndPointProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbEndPointProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbEndPointProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&endpoint_number_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&interval_) -
        reinterpret_cast<char*>(&endpoint_number_)) + sizeof(interval_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbEndPointProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 endpoint_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_endpoint_number(&has_bits);
          endpoint_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.UsbEndPointDirection direction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::android::service::UsbEndPointDirection_IsValid(val))) {
            set_direction(static_cast<::android::service::UsbEndPointDirection>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional int32 address = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_address(&has_bits);
          address_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.UsbEndPointType type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::android::service::UsbEndPointType_IsValid(val))) {
            set_type(static_cast<::android::service::UsbEndPointType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 attributes = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_attributes(&has_bits);
          attributes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 max_packet_size = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_max_packet_size(&has_bits);
          max_packet_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 interval = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_interval(&has_bits);
          interval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbEndPointProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbEndPointProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 endpoint_number = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_endpoint_number(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &endpoint_number_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.UsbEndPointDirection direction = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::service::UsbEndPointDirection_IsValid(value)) {
            set_direction(static_cast< ::android::service::UsbEndPointDirection >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 address = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_address(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &address_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.UsbEndPointType type = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::service::UsbEndPointType_IsValid(value)) {
            set_type(static_cast< ::android::service::UsbEndPointType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                4, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 attributes = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_attributes(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &attributes_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 max_packet_size = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_max_packet_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_packet_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 interval = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_interval(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &interval_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbEndPointProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbEndPointProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbEndPointProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbEndPointProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 endpoint_number = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->endpoint_number(), output);
  }

  // optional .android.service.UsbEndPointDirection direction = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      2, this->direction(), output);
  }

  // optional int32 address = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->address(), output);
  }

  // optional .android.service.UsbEndPointType type = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      4, this->type(), output);
  }

  // optional uint32 attributes = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->attributes(), output);
  }

  // optional int32 max_packet_size = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(6, this->max_packet_size(), output);
  }

  // optional int32 interval = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(7, this->interval(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbEndPointProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbEndPointProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbEndPointProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 endpoint_number = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->endpoint_number(), target);
  }

  // optional .android.service.UsbEndPointDirection direction = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->direction(), target);
  }

  // optional int32 address = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->address(), target);
  }

  // optional .android.service.UsbEndPointType type = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->type(), target);
  }

  // optional uint32 attributes = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->attributes(), target);
  }

  // optional int32 max_packet_size = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->max_packet_size(), target);
  }

  // optional int32 interval = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->interval(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbEndPointProto)
  return target;
}

size_t UsbEndPointProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbEndPointProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional int32 endpoint_number = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->endpoint_number());
    }

    // optional .android.service.UsbEndPointDirection direction = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->direction());
    }

    // optional int32 address = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->address());
    }

    // optional .android.service.UsbEndPointType type = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional uint32 attributes = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->attributes());
    }

    // optional int32 max_packet_size = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->max_packet_size());
    }

    // optional int32 interval = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->interval());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbEndPointProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbEndPointProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbEndPointProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbEndPointProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbEndPointProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbEndPointProto)
    MergeFrom(*source);
  }
}

void UsbEndPointProto::MergeFrom(const UsbEndPointProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbEndPointProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      endpoint_number_ = from.endpoint_number_;
    }
    if (cached_has_bits & 0x00000002u) {
      direction_ = from.direction_;
    }
    if (cached_has_bits & 0x00000004u) {
      address_ = from.address_;
    }
    if (cached_has_bits & 0x00000008u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000010u) {
      attributes_ = from.attributes_;
    }
    if (cached_has_bits & 0x00000020u) {
      max_packet_size_ = from.max_packet_size_;
    }
    if (cached_has_bits & 0x00000040u) {
      interval_ = from.interval_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbEndPointProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbEndPointProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbEndPointProto::CopyFrom(const UsbEndPointProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbEndPointProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbEndPointProto::IsInitialized() const {
  return true;
}

void UsbEndPointProto::InternalSwap(UsbEndPointProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(endpoint_number_, other->endpoint_number_);
  swap(direction_, other->direction_);
  swap(address_, other->address_);
  swap(type_, other->type_);
  swap(attributes_, other->attributes_);
  swap(max_packet_size_, other->max_packet_size_);
  swap(interval_, other->interval_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbEndPointProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbConnectionRecordProto::InitAsDefaultInstance() {
  ::android::service::usb::_UsbConnectionRecordProto_default_instance_._instance.get_mutable()->is_headset_ = const_cast< ::android::service::usb::UsbIsHeadsetProto*>(
      ::android::service::usb::UsbIsHeadsetProto::internal_default_instance());
}
class UsbConnectionRecordProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbConnectionRecordProto>()._has_bits_);
  static void set_has_device_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_manufacturer(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_product(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::android::service::usb::UsbIsHeadsetProto& is_headset(const UsbConnectionRecordProto* msg);
  static void set_has_is_headset(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::android::service::usb::UsbIsHeadsetProto&
UsbConnectionRecordProto::_Internal::is_headset(const UsbConnectionRecordProto* msg) {
  return *msg->is_headset_;
}
UsbConnectionRecordProto::UsbConnectionRecordProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbConnectionRecordProto)
}
UsbConnectionRecordProto::UsbConnectionRecordProto(const UsbConnectionRecordProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  device_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_device_address()) {
    device_address_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.device_address_);
  }
  if (from.has_is_headset()) {
    is_headset_ = new ::android::service::usb::UsbIsHeadsetProto(*from.is_headset_);
  } else {
    is_headset_ = nullptr;
  }
  ::memcpy(&timestamp_, &from.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&product_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(product_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbConnectionRecordProto)
}

void UsbConnectionRecordProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbConnectionRecordProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  device_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&is_headset_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&product_) -
      reinterpret_cast<char*>(&is_headset_)) + sizeof(product_));
}

UsbConnectionRecordProto::~UsbConnectionRecordProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbConnectionRecordProto)
  SharedDtor();
}

void UsbConnectionRecordProto::SharedDtor() {
  device_address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete is_headset_;
}

void UsbConnectionRecordProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbConnectionRecordProto& UsbConnectionRecordProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbConnectionRecordProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbConnectionRecordProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbConnectionRecordProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      device_address_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(is_headset_ != nullptr);
      is_headset_->Clear();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&product_) -
        reinterpret_cast<char*>(&timestamp_)) + sizeof(product_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbConnectionRecordProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string device_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_device_address(), ptr, ctx, "android.service.usb.UsbConnectionRecordProto.device_address");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.UsbConnectionRecordMode mode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::android::service::UsbConnectionRecordMode_IsValid(val))) {
            set_mode(static_cast<::android::service::UsbConnectionRecordMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional int64 timestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 manufacturer = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_manufacturer(&has_bits);
          manufacturer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 product = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_product(&has_bits);
          product_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbIsHeadsetProto is_headset = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(mutable_is_headset(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbConnectionRecordProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbConnectionRecordProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string device_address = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_device_address()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->device_address().data(), static_cast<int>(this->device_address().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbConnectionRecordProto.device_address");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.UsbConnectionRecordMode mode = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::service::UsbConnectionRecordMode_IsValid(value)) {
            set_mode(static_cast< ::android::service::UsbConnectionRecordMode >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 timestamp = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_timestamp(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &timestamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 manufacturer = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_manufacturer(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &manufacturer_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 product = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_product(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &product_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbIsHeadsetProto is_headset = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_is_headset()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbConnectionRecordProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbConnectionRecordProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbConnectionRecordProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbConnectionRecordProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string device_address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->device_address().data(), static_cast<int>(this->device_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbConnectionRecordProto.device_address");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->device_address(), output);
  }

  // optional .android.service.UsbConnectionRecordMode mode = 2;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      2, this->mode(), output);
  }

  // optional int64 timestamp = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(3, this->timestamp(), output);
  }

  // optional int32 manufacturer = 4;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->manufacturer(), output);
  }

  // optional int32 product = 5;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->product(), output);
  }

  // optional .android.service.usb.UsbIsHeadsetProto is_headset = 6;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, _Internal::is_headset(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbConnectionRecordProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbConnectionRecordProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbConnectionRecordProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string device_address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->device_address().data(), static_cast<int>(this->device_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbConnectionRecordProto.device_address");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        1, this->device_address(), target);
  }

  // optional .android.service.UsbConnectionRecordMode mode = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->mode(), target);
  }

  // optional int64 timestamp = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->timestamp(), target);
  }

  // optional int32 manufacturer = 4;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->manufacturer(), target);
  }

  // optional int32 product = 5;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->product(), target);
  }

  // optional .android.service.usb.UsbIsHeadsetProto is_headset = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, _Internal::is_headset(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbConnectionRecordProto)
  return target;
}

size_t UsbConnectionRecordProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbConnectionRecordProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string device_address = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->device_address());
    }

    // optional .android.service.usb.UsbIsHeadsetProto is_headset = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *is_headset_);
    }

    // optional int64 timestamp = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->timestamp());
    }

    // optional .android.service.UsbConnectionRecordMode mode = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->mode());
    }

    // optional int32 manufacturer = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->manufacturer());
    }

    // optional int32 product = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->product());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbConnectionRecordProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbConnectionRecordProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbConnectionRecordProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbConnectionRecordProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbConnectionRecordProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbConnectionRecordProto)
    MergeFrom(*source);
  }
}

void UsbConnectionRecordProto::MergeFrom(const UsbConnectionRecordProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbConnectionRecordProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      device_address_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.device_address_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_is_headset()->::android::service::usb::UsbIsHeadsetProto::MergeFrom(from.is_headset());
    }
    if (cached_has_bits & 0x00000004u) {
      timestamp_ = from.timestamp_;
    }
    if (cached_has_bits & 0x00000008u) {
      mode_ = from.mode_;
    }
    if (cached_has_bits & 0x00000010u) {
      manufacturer_ = from.manufacturer_;
    }
    if (cached_has_bits & 0x00000020u) {
      product_ = from.product_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbConnectionRecordProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbConnectionRecordProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbConnectionRecordProto::CopyFrom(const UsbConnectionRecordProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbConnectionRecordProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbConnectionRecordProto::IsInitialized() const {
  return true;
}

void UsbConnectionRecordProto::InternalSwap(UsbConnectionRecordProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  device_address_.Swap(&other->device_address_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(is_headset_, other->is_headset_);
  swap(timestamp_, other->timestamp_);
  swap(mode_, other->mode_);
  swap(manufacturer_, other->manufacturer_);
  swap(product_, other->product_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbConnectionRecordProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbIsHeadsetProto::InitAsDefaultInstance() {
}
class UsbIsHeadsetProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbIsHeadsetProto>()._has_bits_);
  static void set_has_in(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_out(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

UsbIsHeadsetProto::UsbIsHeadsetProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbIsHeadsetProto)
}
UsbIsHeadsetProto::UsbIsHeadsetProto(const UsbIsHeadsetProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&in_, &from.in_,
    static_cast<size_t>(reinterpret_cast<char*>(&out_) -
    reinterpret_cast<char*>(&in_)) + sizeof(out_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbIsHeadsetProto)
}

void UsbIsHeadsetProto::SharedCtor() {
  ::memset(&in_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&out_) -
      reinterpret_cast<char*>(&in_)) + sizeof(out_));
}

UsbIsHeadsetProto::~UsbIsHeadsetProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbIsHeadsetProto)
  SharedDtor();
}

void UsbIsHeadsetProto::SharedDtor() {
}

void UsbIsHeadsetProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbIsHeadsetProto& UsbIsHeadsetProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbIsHeadsetProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbIsHeadsetProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbIsHeadsetProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&in_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&out_) -
      reinterpret_cast<char*>(&in_)) + sizeof(out_));
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbIsHeadsetProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bool in = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_in(&has_bits);
          in_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool out = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_out(&has_bits);
          out_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbIsHeadsetProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbIsHeadsetProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool in = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_in(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &in_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool out = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_out(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &out_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbIsHeadsetProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbIsHeadsetProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbIsHeadsetProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbIsHeadsetProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool in = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(1, this->in(), output);
  }

  // optional bool out = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(2, this->out(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbIsHeadsetProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbIsHeadsetProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbIsHeadsetProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool in = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->in(), target);
  }

  // optional bool out = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->out(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbIsHeadsetProto)
  return target;
}

size_t UsbIsHeadsetProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbIsHeadsetProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool in = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool out = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbIsHeadsetProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbIsHeadsetProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbIsHeadsetProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbIsHeadsetProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbIsHeadsetProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbIsHeadsetProto)
    MergeFrom(*source);
  }
}

void UsbIsHeadsetProto::MergeFrom(const UsbIsHeadsetProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbIsHeadsetProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      in_ = from.in_;
    }
    if (cached_has_bits & 0x00000002u) {
      out_ = from.out_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbIsHeadsetProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbIsHeadsetProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbIsHeadsetProto::CopyFrom(const UsbIsHeadsetProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbIsHeadsetProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbIsHeadsetProto::IsInitialized() const {
  return true;
}

void UsbIsHeadsetProto::InternalSwap(UsbIsHeadsetProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(in_, other->in_);
  swap(out_, other->out_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbIsHeadsetProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbPortManagerProto::InitAsDefaultInstance() {
}
class UsbPortManagerProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbPortManagerProto>()._has_bits_);
  static void set_has_is_simulation_active(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_enable_usb_data_signaling(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

UsbPortManagerProto::UsbPortManagerProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbPortManagerProto)
}
UsbPortManagerProto::UsbPortManagerProto(const UsbPortManagerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      usb_ports_(from.usb_ports_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&is_simulation_active_, &from.is_simulation_active_,
    static_cast<size_t>(reinterpret_cast<char*>(&enable_usb_data_signaling_) -
    reinterpret_cast<char*>(&is_simulation_active_)) + sizeof(enable_usb_data_signaling_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbPortManagerProto)
}

void UsbPortManagerProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbPortManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  ::memset(&is_simulation_active_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&enable_usb_data_signaling_) -
      reinterpret_cast<char*>(&is_simulation_active_)) + sizeof(enable_usb_data_signaling_));
}

UsbPortManagerProto::~UsbPortManagerProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbPortManagerProto)
  SharedDtor();
}

void UsbPortManagerProto::SharedDtor() {
}

void UsbPortManagerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbPortManagerProto& UsbPortManagerProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbPortManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbPortManagerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbPortManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  usb_ports_.Clear();
  ::memset(&is_simulation_active_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&enable_usb_data_signaling_) -
      reinterpret_cast<char*>(&is_simulation_active_)) + sizeof(enable_usb_data_signaling_));
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbPortManagerProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bool is_simulation_active = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_is_simulation_active(&has_bits);
          is_simulation_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbPortInfoProto usb_ports = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_usb_ports(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      // optional bool enable_usb_data_signaling = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_enable_usb_data_signaling(&has_bits);
          enable_usb_data_signaling_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbPortManagerProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbPortManagerProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool is_simulation_active = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_is_simulation_active(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_simulation_active_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbPortInfoProto usb_ports = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_usb_ports()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool enable_usb_data_signaling = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_enable_usb_data_signaling(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enable_usb_data_signaling_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbPortManagerProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbPortManagerProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbPortManagerProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbPortManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool is_simulation_active = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(1, this->is_simulation_active(), output);
  }

  // repeated .android.service.usb.UsbPortInfoProto usb_ports = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->usb_ports_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->usb_ports(static_cast<int>(i)),
      output);
  }

  // optional bool enable_usb_data_signaling = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(3, this->enable_usb_data_signaling(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbPortManagerProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbPortManagerProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbPortManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool is_simulation_active = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->is_simulation_active(), target);
  }

  // repeated .android.service.usb.UsbPortInfoProto usb_ports = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->usb_ports_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->usb_ports(static_cast<int>(i)), target);
  }

  // optional bool enable_usb_data_signaling = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->enable_usb_data_signaling(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbPortManagerProto)
  return target;
}

size_t UsbPortManagerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbPortManagerProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbPortInfoProto usb_ports = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->usb_ports_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->usb_ports(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool is_simulation_active = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool enable_usb_data_signaling = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbPortManagerProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbPortManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbPortManagerProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbPortManagerProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbPortManagerProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbPortManagerProto)
    MergeFrom(*source);
  }
}

void UsbPortManagerProto::MergeFrom(const UsbPortManagerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbPortManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  usb_ports_.MergeFrom(from.usb_ports_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      is_simulation_active_ = from.is_simulation_active_;
    }
    if (cached_has_bits & 0x00000002u) {
      enable_usb_data_signaling_ = from.enable_usb_data_signaling_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbPortManagerProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbPortManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbPortManagerProto::CopyFrom(const UsbPortManagerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbPortManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbPortManagerProto::IsInitialized() const {
  return true;
}

void UsbPortManagerProto::InternalSwap(UsbPortManagerProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&usb_ports_)->InternalSwap(CastToBase(&other->usb_ports_));
  swap(is_simulation_active_, other->is_simulation_active_);
  swap(enable_usb_data_signaling_, other->enable_usb_data_signaling_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbPortManagerProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbPortInfoProto::InitAsDefaultInstance() {
  ::android::service::usb::_UsbPortInfoProto_default_instance_._instance.get_mutable()->port_ = const_cast< ::android::service::usb::UsbPortProto*>(
      ::android::service::usb::UsbPortProto::internal_default_instance());
  ::android::service::usb::_UsbPortInfoProto_default_instance_._instance.get_mutable()->status_ = const_cast< ::android::service::usb::UsbPortStatusProto*>(
      ::android::service::usb::UsbPortStatusProto::internal_default_instance());
}
class UsbPortInfoProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbPortInfoProto>()._has_bits_);
  static const ::android::service::usb::UsbPortProto& port(const UsbPortInfoProto* msg);
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::android::service::usb::UsbPortStatusProto& status(const UsbPortInfoProto* msg);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_can_change_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_can_change_power_role(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_can_change_data_role(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_connected_at_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_last_connect_duration_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::android::service::usb::UsbPortProto&
UsbPortInfoProto::_Internal::port(const UsbPortInfoProto* msg) {
  return *msg->port_;
}
const ::android::service::usb::UsbPortStatusProto&
UsbPortInfoProto::_Internal::status(const UsbPortInfoProto* msg) {
  return *msg->status_;
}
UsbPortInfoProto::UsbPortInfoProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbPortInfoProto)
}
UsbPortInfoProto::UsbPortInfoProto(const UsbPortInfoProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_port()) {
    port_ = new ::android::service::usb::UsbPortProto(*from.port_);
  } else {
    port_ = nullptr;
  }
  if (from.has_status()) {
    status_ = new ::android::service::usb::UsbPortStatusProto(*from.status_);
  } else {
    status_ = nullptr;
  }
  ::memcpy(&connected_at_millis_, &from.connected_at_millis_,
    static_cast<size_t>(reinterpret_cast<char*>(&can_change_data_role_) -
    reinterpret_cast<char*>(&connected_at_millis_)) + sizeof(can_change_data_role_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbPortInfoProto)
}

void UsbPortInfoProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbPortInfoProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  ::memset(&port_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&can_change_data_role_) -
      reinterpret_cast<char*>(&port_)) + sizeof(can_change_data_role_));
}

UsbPortInfoProto::~UsbPortInfoProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbPortInfoProto)
  SharedDtor();
}

void UsbPortInfoProto::SharedDtor() {
  if (this != internal_default_instance()) delete port_;
  if (this != internal_default_instance()) delete status_;
}

void UsbPortInfoProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbPortInfoProto& UsbPortInfoProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbPortInfoProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbPortInfoProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbPortInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(port_ != nullptr);
      port_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(status_ != nullptr);
      status_->Clear();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&connected_at_millis_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&can_change_data_role_) -
        reinterpret_cast<char*>(&connected_at_millis_)) + sizeof(can_change_data_role_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbPortInfoProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .android.service.usb.UsbPortProto port = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_port(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbPortStatusProto status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_status(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool can_change_mode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_can_change_mode(&has_bits);
          can_change_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool can_change_power_role = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_can_change_power_role(&has_bits);
          can_change_power_role_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool can_change_data_role = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_can_change_data_role(&has_bits);
          can_change_data_role_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 connected_at_millis = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_connected_at_millis(&has_bits);
          connected_at_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 last_connect_duration_millis = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_last_connect_duration_millis(&has_bits);
          last_connect_duration_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbPortInfoProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbPortInfoProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .android.service.usb.UsbPortProto port = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_port()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbPortStatusProto status = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_status()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool can_change_mode = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_can_change_mode(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &can_change_mode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool can_change_power_role = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_can_change_power_role(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &can_change_power_role_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool can_change_data_role = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_can_change_data_role(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &can_change_data_role_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 connected_at_millis = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_connected_at_millis(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &connected_at_millis_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 last_connect_duration_millis = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_last_connect_duration_millis(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &last_connect_duration_millis_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbPortInfoProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbPortInfoProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbPortInfoProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbPortInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.service.usb.UsbPortProto port = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, _Internal::port(this), output);
  }

  // optional .android.service.usb.UsbPortStatusProto status = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, _Internal::status(this), output);
  }

  // optional bool can_change_mode = 3;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(3, this->can_change_mode(), output);
  }

  // optional bool can_change_power_role = 4;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(4, this->can_change_power_role(), output);
  }

  // optional bool can_change_data_role = 5;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(5, this->can_change_data_role(), output);
  }

  // optional int64 connected_at_millis = 6;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(6, this->connected_at_millis(), output);
  }

  // optional int64 last_connect_duration_millis = 7;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(7, this->last_connect_duration_millis(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbPortInfoProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbPortInfoProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbPortInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.service.usb.UsbPortProto port = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::port(this), target);
  }

  // optional .android.service.usb.UsbPortStatusProto status = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, _Internal::status(this), target);
  }

  // optional bool can_change_mode = 3;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->can_change_mode(), target);
  }

  // optional bool can_change_power_role = 4;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->can_change_power_role(), target);
  }

  // optional bool can_change_data_role = 5;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->can_change_data_role(), target);
  }

  // optional int64 connected_at_millis = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->connected_at_millis(), target);
  }

  // optional int64 last_connect_duration_millis = 7;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(7, this->last_connect_duration_millis(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbPortInfoProto)
  return target;
}

size_t UsbPortInfoProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbPortInfoProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .android.service.usb.UsbPortProto port = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *port_);
    }

    // optional .android.service.usb.UsbPortStatusProto status = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *status_);
    }

    // optional int64 connected_at_millis = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->connected_at_millis());
    }

    // optional int64 last_connect_duration_millis = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->last_connect_duration_millis());
    }

    // optional bool can_change_mode = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool can_change_power_role = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool can_change_data_role = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbPortInfoProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbPortInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbPortInfoProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbPortInfoProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbPortInfoProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbPortInfoProto)
    MergeFrom(*source);
  }
}

void UsbPortInfoProto::MergeFrom(const UsbPortInfoProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbPortInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_port()->::android::service::usb::UsbPortProto::MergeFrom(from.port());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_status()->::android::service::usb::UsbPortStatusProto::MergeFrom(from.status());
    }
    if (cached_has_bits & 0x00000004u) {
      connected_at_millis_ = from.connected_at_millis_;
    }
    if (cached_has_bits & 0x00000008u) {
      last_connect_duration_millis_ = from.last_connect_duration_millis_;
    }
    if (cached_has_bits & 0x00000010u) {
      can_change_mode_ = from.can_change_mode_;
    }
    if (cached_has_bits & 0x00000020u) {
      can_change_power_role_ = from.can_change_power_role_;
    }
    if (cached_has_bits & 0x00000040u) {
      can_change_data_role_ = from.can_change_data_role_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbPortInfoProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbPortInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbPortInfoProto::CopyFrom(const UsbPortInfoProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbPortInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbPortInfoProto::IsInitialized() const {
  return true;
}

void UsbPortInfoProto::InternalSwap(UsbPortInfoProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(port_, other->port_);
  swap(status_, other->status_);
  swap(connected_at_millis_, other->connected_at_millis_);
  swap(last_connect_duration_millis_, other->last_connect_duration_millis_);
  swap(can_change_mode_, other->can_change_mode_);
  swap(can_change_power_role_, other->can_change_power_role_);
  swap(can_change_data_role_, other->can_change_data_role_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbPortInfoProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbPortProto::InitAsDefaultInstance() {
}
class UsbPortProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbPortProto>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UsbPortProto::UsbPortProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbPortProto)
}
UsbPortProto::UsbPortProto(const UsbPortProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      supported_modes_(from.supported_modes_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_id()) {
    id_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.id_);
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbPortProto)
}

void UsbPortProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbPortProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

UsbPortProto::~UsbPortProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbPortProto)
  SharedDtor();
}

void UsbPortProto::SharedDtor() {
  id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UsbPortProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbPortProto& UsbPortProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbPortProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbPortProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbPortProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  supported_modes_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    id_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbPortProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_id(), ptr, ctx, "android.service.usb.UsbPortProto.id");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbPortProto.Mode supported_modes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::android::service::usb::UsbPortProto_Mode_IsValid(val))) {
              add_supported_modes(static_cast<::android::service::usb::UsbPortProto_Mode>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 16);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(mutable_supported_modes(), ptr, ctx, ::android::service::usb::UsbPortProto_Mode_IsValid, &_internal_metadata_, 2);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbPortProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbPortProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string id = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->id().data(), static_cast<int>(this->id().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbPortProto.id");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbPortProto.Mode supported_modes = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::service::usb::UsbPortProto_Mode_IsValid(value)) {
            add_supported_modes(static_cast< ::android::service::usb::UsbPortProto_Mode >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ReadPackedEnumPreserveUnknowns(
                 input,
                 2,
                 ::android::service::usb::UsbPortProto_Mode_IsValid,
                 mutable_unknown_fields(),
                 this->mutable_supported_modes())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbPortProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbPortProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbPortProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbPortProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), static_cast<int>(this->id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbPortProto.id");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->id(), output);
  }

  // repeated .android.service.usb.UsbPortProto.Mode supported_modes = 2;
  for (int i = 0, n = this->supported_modes_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      2, this->supported_modes(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbPortProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbPortProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbPortProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), static_cast<int>(this->id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbPortProto.id");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        1, this->id(), target);
  }

  // repeated .android.service.usb.UsbPortProto.Mode supported_modes = 2;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
    2, this->supported_modes_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbPortProto)
  return target;
}

size_t UsbPortProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbPortProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbPortProto.Mode supported_modes = 2;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->supported_modes_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->supported_modes(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // optional string id = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->id());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbPortProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbPortProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbPortProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbPortProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbPortProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbPortProto)
    MergeFrom(*source);
  }
}

void UsbPortProto::MergeFrom(const UsbPortProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbPortProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  supported_modes_.MergeFrom(from.supported_modes_);
  if (from.has_id()) {
    _has_bits_[0] |= 0x00000001u;
    id_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.id_);
  }
}

void UsbPortProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbPortProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbPortProto::CopyFrom(const UsbPortProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbPortProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbPortProto::IsInitialized() const {
  return true;
}

void UsbPortProto::InternalSwap(UsbPortProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  supported_modes_.InternalSwap(&other->supported_modes_);
  id_.Swap(&other->id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbPortProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbPortStatusProto::InitAsDefaultInstance() {
}
class UsbPortStatusProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbPortStatusProto>()._has_bits_);
  static void set_has_connected(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_current_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_power_role(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_data_role(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_contaminant_presence_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

UsbPortStatusProto::UsbPortStatusProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbPortStatusProto)
}
UsbPortStatusProto::UsbPortStatusProto(const UsbPortStatusProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      role_combinations_(from.role_combinations_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&connected_, &from.connected_,
    static_cast<size_t>(reinterpret_cast<char*>(&contaminant_presence_status_) -
    reinterpret_cast<char*>(&connected_)) + sizeof(contaminant_presence_status_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbPortStatusProto)
}

void UsbPortStatusProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbPortStatusProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  ::memset(&connected_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&contaminant_presence_status_) -
      reinterpret_cast<char*>(&connected_)) + sizeof(contaminant_presence_status_));
}

UsbPortStatusProto::~UsbPortStatusProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbPortStatusProto)
  SharedDtor();
}

void UsbPortStatusProto::SharedDtor() {
}

void UsbPortStatusProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbPortStatusProto& UsbPortStatusProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbPortStatusProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbPortStatusProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbPortStatusProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  role_combinations_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&connected_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&contaminant_presence_status_) -
        reinterpret_cast<char*>(&connected_)) + sizeof(contaminant_presence_status_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbPortStatusProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bool connected = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_connected(&has_bits);
          connected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbPortProto.Mode current_mode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::android::service::usb::UsbPortProto_Mode_IsValid(val))) {
            set_current_mode(static_cast<::android::service::usb::UsbPortProto_Mode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbPortStatusProto.PowerRole power_role = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::android::service::usb::UsbPortStatusProto_PowerRole_IsValid(val))) {
            set_power_role(static_cast<::android::service::usb::UsbPortStatusProto_PowerRole>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbPortStatusProto.DataRole data_role = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::android::service::usb::UsbPortStatusProto_DataRole_IsValid(val))) {
            set_data_role(static_cast<::android::service::usb::UsbPortStatusProto_DataRole>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbPortStatusRoleCombinationProto role_combinations = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_role_combinations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 42);
        } else goto handle_unusual;
        continue;
      // optional .android.service.ContaminantPresenceStatus contaminant_presence_status = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::android::service::ContaminantPresenceStatus_IsValid(val))) {
            set_contaminant_presence_status(static_cast<::android::service::ContaminantPresenceStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbPortStatusProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbPortStatusProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool connected = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_connected(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &connected_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbPortProto.Mode current_mode = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::service::usb::UsbPortProto_Mode_IsValid(value)) {
            set_current_mode(static_cast< ::android::service::usb::UsbPortProto_Mode >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbPortStatusProto.PowerRole power_role = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::service::usb::UsbPortStatusProto_PowerRole_IsValid(value)) {
            set_power_role(static_cast< ::android::service::usb::UsbPortStatusProto_PowerRole >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                3, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbPortStatusProto.DataRole data_role = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::service::usb::UsbPortStatusProto_DataRole_IsValid(value)) {
            set_data_role(static_cast< ::android::service::usb::UsbPortStatusProto_DataRole >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                4, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbPortStatusRoleCombinationProto role_combinations = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_role_combinations()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.ContaminantPresenceStatus contaminant_presence_status = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::service::ContaminantPresenceStatus_IsValid(value)) {
            set_contaminant_presence_status(static_cast< ::android::service::ContaminantPresenceStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                6, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbPortStatusProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbPortStatusProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbPortStatusProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbPortStatusProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool connected = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(1, this->connected(), output);
  }

  // optional .android.service.usb.UsbPortProto.Mode current_mode = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      2, this->current_mode(), output);
  }

  // optional .android.service.usb.UsbPortStatusProto.PowerRole power_role = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      3, this->power_role(), output);
  }

  // optional .android.service.usb.UsbPortStatusProto.DataRole data_role = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      4, this->data_role(), output);
  }

  // repeated .android.service.usb.UsbPortStatusRoleCombinationProto role_combinations = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->role_combinations_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      5,
      this->role_combinations(static_cast<int>(i)),
      output);
  }

  // optional .android.service.ContaminantPresenceStatus contaminant_presence_status = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      6, this->contaminant_presence_status(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbPortStatusProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbPortStatusProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbPortStatusProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool connected = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->connected(), target);
  }

  // optional .android.service.usb.UsbPortProto.Mode current_mode = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->current_mode(), target);
  }

  // optional .android.service.usb.UsbPortStatusProto.PowerRole power_role = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->power_role(), target);
  }

  // optional .android.service.usb.UsbPortStatusProto.DataRole data_role = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->data_role(), target);
  }

  // repeated .android.service.usb.UsbPortStatusRoleCombinationProto role_combinations = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->role_combinations_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, this->role_combinations(static_cast<int>(i)), target);
  }

  // optional .android.service.ContaminantPresenceStatus contaminant_presence_status = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->contaminant_presence_status(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbPortStatusProto)
  return target;
}

size_t UsbPortStatusProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbPortStatusProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbPortStatusRoleCombinationProto role_combinations = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->role_combinations_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->role_combinations(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bool connected = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional .android.service.usb.UsbPortProto.Mode current_mode = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->current_mode());
    }

    // optional .android.service.usb.UsbPortStatusProto.PowerRole power_role = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->power_role());
    }

    // optional .android.service.usb.UsbPortStatusProto.DataRole data_role = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->data_role());
    }

    // optional .android.service.ContaminantPresenceStatus contaminant_presence_status = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->contaminant_presence_status());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbPortStatusProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbPortStatusProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbPortStatusProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbPortStatusProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbPortStatusProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbPortStatusProto)
    MergeFrom(*source);
  }
}

void UsbPortStatusProto::MergeFrom(const UsbPortStatusProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbPortStatusProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  role_combinations_.MergeFrom(from.role_combinations_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      connected_ = from.connected_;
    }
    if (cached_has_bits & 0x00000002u) {
      current_mode_ = from.current_mode_;
    }
    if (cached_has_bits & 0x00000004u) {
      power_role_ = from.power_role_;
    }
    if (cached_has_bits & 0x00000008u) {
      data_role_ = from.data_role_;
    }
    if (cached_has_bits & 0x00000010u) {
      contaminant_presence_status_ = from.contaminant_presence_status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbPortStatusProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbPortStatusProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbPortStatusProto::CopyFrom(const UsbPortStatusProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbPortStatusProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbPortStatusProto::IsInitialized() const {
  return true;
}

void UsbPortStatusProto::InternalSwap(UsbPortStatusProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&role_combinations_)->InternalSwap(CastToBase(&other->role_combinations_));
  swap(connected_, other->connected_);
  swap(current_mode_, other->current_mode_);
  swap(power_role_, other->power_role_);
  swap(data_role_, other->data_role_);
  swap(contaminant_presence_status_, other->contaminant_presence_status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbPortStatusProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbPortStatusRoleCombinationProto::InitAsDefaultInstance() {
}
class UsbPortStatusRoleCombinationProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbPortStatusRoleCombinationProto>()._has_bits_);
  static void set_has_power_role(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_data_role(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

UsbPortStatusRoleCombinationProto::UsbPortStatusRoleCombinationProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbPortStatusRoleCombinationProto)
}
UsbPortStatusRoleCombinationProto::UsbPortStatusRoleCombinationProto(const UsbPortStatusRoleCombinationProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&power_role_, &from.power_role_,
    static_cast<size_t>(reinterpret_cast<char*>(&data_role_) -
    reinterpret_cast<char*>(&power_role_)) + sizeof(data_role_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbPortStatusRoleCombinationProto)
}

void UsbPortStatusRoleCombinationProto::SharedCtor() {
  ::memset(&power_role_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&data_role_) -
      reinterpret_cast<char*>(&power_role_)) + sizeof(data_role_));
}

UsbPortStatusRoleCombinationProto::~UsbPortStatusRoleCombinationProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbPortStatusRoleCombinationProto)
  SharedDtor();
}

void UsbPortStatusRoleCombinationProto::SharedDtor() {
}

void UsbPortStatusRoleCombinationProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbPortStatusRoleCombinationProto& UsbPortStatusRoleCombinationProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbPortStatusRoleCombinationProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbPortStatusRoleCombinationProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbPortStatusRoleCombinationProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&power_role_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&data_role_) -
        reinterpret_cast<char*>(&power_role_)) + sizeof(data_role_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbPortStatusRoleCombinationProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .android.service.usb.UsbPortStatusProto.PowerRole power_role = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::android::service::usb::UsbPortStatusProto_PowerRole_IsValid(val))) {
            set_power_role(static_cast<::android::service::usb::UsbPortStatusProto_PowerRole>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UsbPortStatusProto.DataRole data_role = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::android::service::usb::UsbPortStatusProto_DataRole_IsValid(val))) {
            set_data_role(static_cast<::android::service::usb::UsbPortStatusProto_DataRole>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbPortStatusRoleCombinationProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbPortStatusRoleCombinationProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .android.service.usb.UsbPortStatusProto.PowerRole power_role = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::service::usb::UsbPortStatusProto_PowerRole_IsValid(value)) {
            set_power_role(static_cast< ::android::service::usb::UsbPortStatusProto_PowerRole >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UsbPortStatusProto.DataRole data_role = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::android::service::usb::UsbPortStatusProto_DataRole_IsValid(value)) {
            set_data_role(static_cast< ::android::service::usb::UsbPortStatusProto_DataRole >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbPortStatusRoleCombinationProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbPortStatusRoleCombinationProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbPortStatusRoleCombinationProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbPortStatusRoleCombinationProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.service.usb.UsbPortStatusProto.PowerRole power_role = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->power_role(), output);
  }

  // optional .android.service.usb.UsbPortStatusProto.DataRole data_role = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      2, this->data_role(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbPortStatusRoleCombinationProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbPortStatusRoleCombinationProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbPortStatusRoleCombinationProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.service.usb.UsbPortStatusProto.PowerRole power_role = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->power_role(), target);
  }

  // optional .android.service.usb.UsbPortStatusProto.DataRole data_role = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->data_role(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbPortStatusRoleCombinationProto)
  return target;
}

size_t UsbPortStatusRoleCombinationProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbPortStatusRoleCombinationProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .android.service.usb.UsbPortStatusProto.PowerRole power_role = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->power_role());
    }

    // optional .android.service.usb.UsbPortStatusProto.DataRole data_role = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->data_role());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbPortStatusRoleCombinationProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbPortStatusRoleCombinationProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbPortStatusRoleCombinationProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbPortStatusRoleCombinationProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbPortStatusRoleCombinationProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbPortStatusRoleCombinationProto)
    MergeFrom(*source);
  }
}

void UsbPortStatusRoleCombinationProto::MergeFrom(const UsbPortStatusRoleCombinationProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbPortStatusRoleCombinationProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      power_role_ = from.power_role_;
    }
    if (cached_has_bits & 0x00000002u) {
      data_role_ = from.data_role_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbPortStatusRoleCombinationProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbPortStatusRoleCombinationProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbPortStatusRoleCombinationProto::CopyFrom(const UsbPortStatusRoleCombinationProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbPortStatusRoleCombinationProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbPortStatusRoleCombinationProto::IsInitialized() const {
  return true;
}

void UsbPortStatusRoleCombinationProto::InternalSwap(UsbPortStatusRoleCombinationProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(power_role_, other->power_role_);
  swap(data_role_, other->data_role_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbPortStatusRoleCombinationProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbAlsaManagerProto::InitAsDefaultInstance() {
}
class UsbAlsaManagerProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbAlsaManagerProto>()._has_bits_);
  static void set_has_cards_parser(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UsbAlsaManagerProto::UsbAlsaManagerProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbAlsaManagerProto)
}
UsbAlsaManagerProto::UsbAlsaManagerProto(const UsbAlsaManagerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      alsa_devices_(from.alsa_devices_),
      midi_devices_(from.midi_devices_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  cards_parser_ = from.cards_parser_;
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbAlsaManagerProto)
}

void UsbAlsaManagerProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbAlsaManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  cards_parser_ = 0;
}

UsbAlsaManagerProto::~UsbAlsaManagerProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbAlsaManagerProto)
  SharedDtor();
}

void UsbAlsaManagerProto::SharedDtor() {
}

void UsbAlsaManagerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbAlsaManagerProto& UsbAlsaManagerProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbAlsaManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbAlsaManagerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbAlsaManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  alsa_devices_.Clear();
  midi_devices_.Clear();
  cards_parser_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbAlsaManagerProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 cards_parser = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_cards_parser(&has_bits);
          cards_parser_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbAlsaDeviceProto alsa_devices = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_alsa_devices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbMidiDeviceProto midi_devices = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_midi_devices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 26);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbAlsaManagerProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbAlsaManagerProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 cards_parser = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_cards_parser(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &cards_parser_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbAlsaDeviceProto alsa_devices = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_alsa_devices()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbMidiDeviceProto midi_devices = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_midi_devices()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbAlsaManagerProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbAlsaManagerProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbAlsaManagerProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbAlsaManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 cards_parser = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->cards_parser(), output);
  }

  // repeated .android.service.usb.UsbAlsaDeviceProto alsa_devices = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->alsa_devices_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->alsa_devices(static_cast<int>(i)),
      output);
  }

  // repeated .android.service.usb.UsbMidiDeviceProto midi_devices = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->midi_devices_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      3,
      this->midi_devices(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbAlsaManagerProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbAlsaManagerProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbAlsaManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 cards_parser = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->cards_parser(), target);
  }

  // repeated .android.service.usb.UsbAlsaDeviceProto alsa_devices = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->alsa_devices_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->alsa_devices(static_cast<int>(i)), target);
  }

  // repeated .android.service.usb.UsbMidiDeviceProto midi_devices = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->midi_devices_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->midi_devices(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbAlsaManagerProto)
  return target;
}

size_t UsbAlsaManagerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbAlsaManagerProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbAlsaDeviceProto alsa_devices = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->alsa_devices_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->alsa_devices(static_cast<int>(i)));
    }
  }

  // repeated .android.service.usb.UsbMidiDeviceProto midi_devices = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->midi_devices_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->midi_devices(static_cast<int>(i)));
    }
  }

  // optional int32 cards_parser = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->cards_parser());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbAlsaManagerProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbAlsaManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbAlsaManagerProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbAlsaManagerProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbAlsaManagerProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbAlsaManagerProto)
    MergeFrom(*source);
  }
}

void UsbAlsaManagerProto::MergeFrom(const UsbAlsaManagerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbAlsaManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  alsa_devices_.MergeFrom(from.alsa_devices_);
  midi_devices_.MergeFrom(from.midi_devices_);
  if (from.has_cards_parser()) {
    set_cards_parser(from.cards_parser());
  }
}

void UsbAlsaManagerProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbAlsaManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbAlsaManagerProto::CopyFrom(const UsbAlsaManagerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbAlsaManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbAlsaManagerProto::IsInitialized() const {
  return true;
}

void UsbAlsaManagerProto::InternalSwap(UsbAlsaManagerProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&alsa_devices_)->InternalSwap(CastToBase(&other->alsa_devices_));
  CastToBase(&midi_devices_)->InternalSwap(CastToBase(&other->midi_devices_));
  swap(cards_parser_, other->cards_parser_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbAlsaManagerProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbAlsaDeviceProto::InitAsDefaultInstance() {
}
class UsbAlsaDeviceProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbAlsaDeviceProto>()._has_bits_);
  static void set_has_card(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_device(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_has_playback(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_has_capture(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_address(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

UsbAlsaDeviceProto::UsbAlsaDeviceProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbAlsaDeviceProto)
}
UsbAlsaDeviceProto::UsbAlsaDeviceProto(const UsbAlsaDeviceProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_address()) {
    address_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  ::memcpy(&card_, &from.card_,
    static_cast<size_t>(reinterpret_cast<char*>(&has_capture_) -
    reinterpret_cast<char*>(&card_)) + sizeof(has_capture_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbAlsaDeviceProto)
}

void UsbAlsaDeviceProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbAlsaDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&card_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&has_capture_) -
      reinterpret_cast<char*>(&card_)) + sizeof(has_capture_));
}

UsbAlsaDeviceProto::~UsbAlsaDeviceProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbAlsaDeviceProto)
  SharedDtor();
}

void UsbAlsaDeviceProto::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UsbAlsaDeviceProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbAlsaDeviceProto& UsbAlsaDeviceProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbAlsaDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbAlsaDeviceProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbAlsaDeviceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      address_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&card_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&has_capture_) -
        reinterpret_cast<char*>(&card_)) + sizeof(has_capture_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbAlsaDeviceProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 card = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_card(&has_bits);
          card_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 device = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_device(&has_bits);
          device_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_name(), ptr, ctx, "android.service.usb.UsbAlsaDeviceProto.name");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool has_playback = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_has_playback(&has_bits);
          has_playback_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool has_capture = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_has_capture(&has_bits);
          has_capture_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string address = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_address(), ptr, ctx, "android.service.usb.UsbAlsaDeviceProto.address");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbAlsaDeviceProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbAlsaDeviceProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 card = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_card(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &card_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 device = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_device(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &device_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string name = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), static_cast<int>(this->name().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbAlsaDeviceProto.name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool has_playback = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_has_playback(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_playback_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool has_capture = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_has_capture(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_capture_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string address = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), static_cast<int>(this->address().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbAlsaDeviceProto.address");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbAlsaDeviceProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbAlsaDeviceProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbAlsaDeviceProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbAlsaDeviceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 card = 1;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->card(), output);
  }

  // optional int32 device = 2;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->device(), output);
  }

  // optional string name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbAlsaDeviceProto.name");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->name(), output);
  }

  // optional bool has_playback = 4;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(4, this->has_playback(), output);
  }

  // optional bool has_capture = 5;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(5, this->has_capture(), output);
  }

  // optional string address = 6;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbAlsaDeviceProto.address");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->address(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbAlsaDeviceProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbAlsaDeviceProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbAlsaDeviceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 card = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->card(), target);
  }

  // optional int32 device = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->device(), target);
  }

  // optional string name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbAlsaDeviceProto.name");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        3, this->name(), target);
  }

  // optional bool has_playback = 4;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->has_playback(), target);
  }

  // optional bool has_capture = 5;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->has_capture(), target);
  }

  // optional string address = 6;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbAlsaDeviceProto.address");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        6, this->address(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbAlsaDeviceProto)
  return target;
}

size_t UsbAlsaDeviceProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbAlsaDeviceProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string address = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->address());
    }

    // optional int32 card = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->card());
    }

    // optional int32 device = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->device());
    }

    // optional bool has_playback = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool has_capture = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbAlsaDeviceProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbAlsaDeviceProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbAlsaDeviceProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbAlsaDeviceProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbAlsaDeviceProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbAlsaDeviceProto)
    MergeFrom(*source);
  }
}

void UsbAlsaDeviceProto::MergeFrom(const UsbAlsaDeviceProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbAlsaDeviceProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      address_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.address_);
    }
    if (cached_has_bits & 0x00000004u) {
      card_ = from.card_;
    }
    if (cached_has_bits & 0x00000008u) {
      device_ = from.device_;
    }
    if (cached_has_bits & 0x00000010u) {
      has_playback_ = from.has_playback_;
    }
    if (cached_has_bits & 0x00000020u) {
      has_capture_ = from.has_capture_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbAlsaDeviceProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbAlsaDeviceProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbAlsaDeviceProto::CopyFrom(const UsbAlsaDeviceProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbAlsaDeviceProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbAlsaDeviceProto::IsInitialized() const {
  return true;
}

void UsbAlsaDeviceProto::InternalSwap(UsbAlsaDeviceProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  address_.Swap(&other->address_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(card_, other->card_);
  swap(device_, other->device_);
  swap(has_playback_, other->has_playback_);
  swap(has_capture_, other->has_capture_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbAlsaDeviceProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbMidiDeviceProto::InitAsDefaultInstance() {
}
class UsbMidiDeviceProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbMidiDeviceProto>()._has_bits_);
  static void set_has_card(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_device(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_device_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UsbMidiDeviceProto::UsbMidiDeviceProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbMidiDeviceProto)
}
UsbMidiDeviceProto::UsbMidiDeviceProto(const UsbMidiDeviceProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  device_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_device_address()) {
    device_address_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.device_address_);
  }
  ::memcpy(&card_, &from.card_,
    static_cast<size_t>(reinterpret_cast<char*>(&device_) -
    reinterpret_cast<char*>(&card_)) + sizeof(device_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbMidiDeviceProto)
}

void UsbMidiDeviceProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbMidiDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  device_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&card_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&device_) -
      reinterpret_cast<char*>(&card_)) + sizeof(device_));
}

UsbMidiDeviceProto::~UsbMidiDeviceProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbMidiDeviceProto)
  SharedDtor();
}

void UsbMidiDeviceProto::SharedDtor() {
  device_address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UsbMidiDeviceProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbMidiDeviceProto& UsbMidiDeviceProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbMidiDeviceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbMidiDeviceProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbMidiDeviceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    device_address_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&card_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&device_) -
        reinterpret_cast<char*>(&card_)) + sizeof(device_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbMidiDeviceProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 card = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_card(&has_bits);
          card_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 device = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_device(&has_bits);
          device_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string device_address = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_device_address(), ptr, ctx, "android.service.usb.UsbMidiDeviceProto.device_address");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbMidiDeviceProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbMidiDeviceProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 card = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_card(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &card_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 device = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_device(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &device_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string device_address = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_device_address()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->device_address().data(), static_cast<int>(this->device_address().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbMidiDeviceProto.device_address");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbMidiDeviceProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbMidiDeviceProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbMidiDeviceProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbMidiDeviceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 card = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->card(), output);
  }

  // optional int32 device = 2;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->device(), output);
  }

  // optional string device_address = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->device_address().data(), static_cast<int>(this->device_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbMidiDeviceProto.device_address");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->device_address(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbMidiDeviceProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbMidiDeviceProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbMidiDeviceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 card = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->card(), target);
  }

  // optional int32 device = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->device(), target);
  }

  // optional string device_address = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->device_address().data(), static_cast<int>(this->device_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbMidiDeviceProto.device_address");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        3, this->device_address(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbMidiDeviceProto)
  return target;
}

size_t UsbMidiDeviceProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbMidiDeviceProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string device_address = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->device_address());
    }

    // optional int32 card = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->card());
    }

    // optional int32 device = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->device());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbMidiDeviceProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbMidiDeviceProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbMidiDeviceProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbMidiDeviceProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbMidiDeviceProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbMidiDeviceProto)
    MergeFrom(*source);
  }
}

void UsbMidiDeviceProto::MergeFrom(const UsbMidiDeviceProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbMidiDeviceProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      device_address_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.device_address_);
    }
    if (cached_has_bits & 0x00000002u) {
      card_ = from.card_;
    }
    if (cached_has_bits & 0x00000004u) {
      device_ = from.device_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbMidiDeviceProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbMidiDeviceProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbMidiDeviceProto::CopyFrom(const UsbMidiDeviceProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbMidiDeviceProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbMidiDeviceProto::IsInitialized() const {
  return true;
}

void UsbMidiDeviceProto::InternalSwap(UsbMidiDeviceProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  device_address_.Swap(&other->device_address_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(card_, other->card_);
  swap(device_, other->device_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbMidiDeviceProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbSettingsManagerProto::InitAsDefaultInstance() {
}
class UsbSettingsManagerProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbSettingsManagerProto>()._has_bits_);
};

UsbSettingsManagerProto::UsbSettingsManagerProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbSettingsManagerProto)
}
UsbSettingsManagerProto::UsbSettingsManagerProto(const UsbSettingsManagerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      user_settings_(from.user_settings_),
      profile_group_settings_(from.profile_group_settings_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbSettingsManagerProto)
}

void UsbSettingsManagerProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
}

UsbSettingsManagerProto::~UsbSettingsManagerProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbSettingsManagerProto)
  SharedDtor();
}

void UsbSettingsManagerProto::SharedDtor() {
}

void UsbSettingsManagerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbSettingsManagerProto& UsbSettingsManagerProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbSettingsManagerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbSettingsManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_settings_.Clear();
  profile_group_settings_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbSettingsManagerProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .android.service.usb.UsbUserSettingsManagerProto user_settings = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_user_settings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbProfileGroupSettingsManagerProto profile_group_settings = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_profile_group_settings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbSettingsManagerProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbSettingsManagerProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .android.service.usb.UsbUserSettingsManagerProto user_settings = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_user_settings()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbProfileGroupSettingsManagerProto profile_group_settings = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_profile_group_settings()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbSettingsManagerProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbSettingsManagerProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbSettingsManagerProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbSettingsManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbUserSettingsManagerProto user_settings = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->user_settings_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->user_settings(static_cast<int>(i)),
      output);
  }

  // repeated .android.service.usb.UsbProfileGroupSettingsManagerProto profile_group_settings = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->profile_group_settings_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->profile_group_settings(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbSettingsManagerProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbSettingsManagerProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbSettingsManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbUserSettingsManagerProto user_settings = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->user_settings_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->user_settings(static_cast<int>(i)), target);
  }

  // repeated .android.service.usb.UsbProfileGroupSettingsManagerProto profile_group_settings = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->profile_group_settings_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->profile_group_settings(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbSettingsManagerProto)
  return target;
}

size_t UsbSettingsManagerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbSettingsManagerProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbUserSettingsManagerProto user_settings = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->user_settings_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->user_settings(static_cast<int>(i)));
    }
  }

  // repeated .android.service.usb.UsbProfileGroupSettingsManagerProto profile_group_settings = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->profile_group_settings_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->profile_group_settings(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbSettingsManagerProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbSettingsManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbSettingsManagerProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbSettingsManagerProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbSettingsManagerProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbSettingsManagerProto)
    MergeFrom(*source);
  }
}

void UsbSettingsManagerProto::MergeFrom(const UsbSettingsManagerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbSettingsManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  user_settings_.MergeFrom(from.user_settings_);
  profile_group_settings_.MergeFrom(from.profile_group_settings_);
}

void UsbSettingsManagerProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbSettingsManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbSettingsManagerProto::CopyFrom(const UsbSettingsManagerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbSettingsManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbSettingsManagerProto::IsInitialized() const {
  return true;
}

void UsbSettingsManagerProto::InternalSwap(UsbSettingsManagerProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&user_settings_)->InternalSwap(CastToBase(&other->user_settings_));
  CastToBase(&profile_group_settings_)->InternalSwap(CastToBase(&other->profile_group_settings_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbSettingsManagerProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbUserSettingsManagerProto::InitAsDefaultInstance() {
}
class UsbUserSettingsManagerProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbUserSettingsManagerProto>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UsbUserSettingsManagerProto::UsbUserSettingsManagerProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbUserSettingsManagerProto)
}
UsbUserSettingsManagerProto::UsbUserSettingsManagerProto(const UsbUserSettingsManagerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      device_attached_activities_(from.device_attached_activities_),
      accessory_attached_activities_(from.accessory_attached_activities_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  user_id_ = from.user_id_;
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbUserSettingsManagerProto)
}

void UsbUserSettingsManagerProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbUserSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  user_id_ = 0;
}

UsbUserSettingsManagerProto::~UsbUserSettingsManagerProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbUserSettingsManagerProto)
  SharedDtor();
}

void UsbUserSettingsManagerProto::SharedDtor() {
}

void UsbUserSettingsManagerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbUserSettingsManagerProto& UsbUserSettingsManagerProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbUserSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbUserSettingsManagerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbUserSettingsManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  device_attached_activities_.Clear();
  accessory_attached_activities_.Clear();
  user_id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbUserSettingsManagerProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbDeviceAttachedActivities device_attached_activities = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_device_attached_activities(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 34);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbAccessoryAttachedActivities accessory_attached_activities = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_accessory_attached_activities(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 42);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbUserSettingsManagerProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbUserSettingsManagerProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 user_id = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_user_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &user_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbDeviceAttachedActivities device_attached_activities = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_device_attached_activities()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbAccessoryAttachedActivities accessory_attached_activities = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_accessory_attached_activities()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbUserSettingsManagerProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbUserSettingsManagerProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbUserSettingsManagerProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbUserSettingsManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->user_id(), output);
  }

  // repeated .android.service.usb.UsbDeviceAttachedActivities device_attached_activities = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->device_attached_activities_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      4,
      this->device_attached_activities(static_cast<int>(i)),
      output);
  }

  // repeated .android.service.usb.UsbAccessoryAttachedActivities accessory_attached_activities = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->accessory_attached_activities_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      5,
      this->accessory_attached_activities(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbUserSettingsManagerProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbUserSettingsManagerProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbUserSettingsManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->user_id(), target);
  }

  // repeated .android.service.usb.UsbDeviceAttachedActivities device_attached_activities = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->device_attached_activities_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, this->device_attached_activities(static_cast<int>(i)), target);
  }

  // repeated .android.service.usb.UsbAccessoryAttachedActivities accessory_attached_activities = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->accessory_attached_activities_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, this->accessory_attached_activities(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbUserSettingsManagerProto)
  return target;
}

size_t UsbUserSettingsManagerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbUserSettingsManagerProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbDeviceAttachedActivities device_attached_activities = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->device_attached_activities_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->device_attached_activities(static_cast<int>(i)));
    }
  }

  // repeated .android.service.usb.UsbAccessoryAttachedActivities accessory_attached_activities = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->accessory_attached_activities_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->accessory_attached_activities(static_cast<int>(i)));
    }
  }

  // optional int32 user_id = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->user_id());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbUserSettingsManagerProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbUserSettingsManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbUserSettingsManagerProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbUserSettingsManagerProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbUserSettingsManagerProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbUserSettingsManagerProto)
    MergeFrom(*source);
  }
}

void UsbUserSettingsManagerProto::MergeFrom(const UsbUserSettingsManagerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbUserSettingsManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  device_attached_activities_.MergeFrom(from.device_attached_activities_);
  accessory_attached_activities_.MergeFrom(from.accessory_attached_activities_);
  if (from.has_user_id()) {
    set_user_id(from.user_id());
  }
}

void UsbUserSettingsManagerProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbUserSettingsManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbUserSettingsManagerProto::CopyFrom(const UsbUserSettingsManagerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbUserSettingsManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbUserSettingsManagerProto::IsInitialized() const {
  return true;
}

void UsbUserSettingsManagerProto::InternalSwap(UsbUserSettingsManagerProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&device_attached_activities_)->InternalSwap(CastToBase(&other->device_attached_activities_));
  CastToBase(&accessory_attached_activities_)->InternalSwap(CastToBase(&other->accessory_attached_activities_));
  swap(user_id_, other->user_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbUserSettingsManagerProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbProfileGroupSettingsManagerProto::InitAsDefaultInstance() {
}
class UsbProfileGroupSettingsManagerProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbProfileGroupSettingsManagerProto>()._has_bits_);
  static void set_has_parent_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UsbProfileGroupSettingsManagerProto::UsbProfileGroupSettingsManagerProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbProfileGroupSettingsManagerProto)
}
UsbProfileGroupSettingsManagerProto::UsbProfileGroupSettingsManagerProto(const UsbProfileGroupSettingsManagerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      device_preferences_(from.device_preferences_),
      accessory_preferences_(from.accessory_preferences_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  parent_user_id_ = from.parent_user_id_;
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbProfileGroupSettingsManagerProto)
}

void UsbProfileGroupSettingsManagerProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbProfileGroupSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  parent_user_id_ = 0;
}

UsbProfileGroupSettingsManagerProto::~UsbProfileGroupSettingsManagerProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbProfileGroupSettingsManagerProto)
  SharedDtor();
}

void UsbProfileGroupSettingsManagerProto::SharedDtor() {
}

void UsbProfileGroupSettingsManagerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbProfileGroupSettingsManagerProto& UsbProfileGroupSettingsManagerProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbProfileGroupSettingsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbProfileGroupSettingsManagerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbProfileGroupSettingsManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  device_preferences_.Clear();
  accessory_preferences_.Clear();
  parent_user_id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbProfileGroupSettingsManagerProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 parent_user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_parent_user_id(&has_bits);
          parent_user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbSettingsDevicePreferenceProto device_preferences = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_device_preferences(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbSettingsAccessoryPreferenceProto accessory_preferences = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_accessory_preferences(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 26);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbProfileGroupSettingsManagerProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbProfileGroupSettingsManagerProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 parent_user_id = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_parent_user_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &parent_user_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbSettingsDevicePreferenceProto device_preferences = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_device_preferences()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbSettingsAccessoryPreferenceProto accessory_preferences = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_accessory_preferences()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbProfileGroupSettingsManagerProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbProfileGroupSettingsManagerProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbProfileGroupSettingsManagerProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbProfileGroupSettingsManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 parent_user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->parent_user_id(), output);
  }

  // repeated .android.service.usb.UsbSettingsDevicePreferenceProto device_preferences = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->device_preferences_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->device_preferences(static_cast<int>(i)),
      output);
  }

  // repeated .android.service.usb.UsbSettingsAccessoryPreferenceProto accessory_preferences = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->accessory_preferences_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      3,
      this->accessory_preferences(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbProfileGroupSettingsManagerProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbProfileGroupSettingsManagerProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbProfileGroupSettingsManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 parent_user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->parent_user_id(), target);
  }

  // repeated .android.service.usb.UsbSettingsDevicePreferenceProto device_preferences = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->device_preferences_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->device_preferences(static_cast<int>(i)), target);
  }

  // repeated .android.service.usb.UsbSettingsAccessoryPreferenceProto accessory_preferences = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->accessory_preferences_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->accessory_preferences(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbProfileGroupSettingsManagerProto)
  return target;
}

size_t UsbProfileGroupSettingsManagerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbProfileGroupSettingsManagerProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbSettingsDevicePreferenceProto device_preferences = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->device_preferences_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->device_preferences(static_cast<int>(i)));
    }
  }

  // repeated .android.service.usb.UsbSettingsAccessoryPreferenceProto accessory_preferences = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->accessory_preferences_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->accessory_preferences(static_cast<int>(i)));
    }
  }

  // optional int32 parent_user_id = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->parent_user_id());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbProfileGroupSettingsManagerProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbProfileGroupSettingsManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbProfileGroupSettingsManagerProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbProfileGroupSettingsManagerProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbProfileGroupSettingsManagerProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbProfileGroupSettingsManagerProto)
    MergeFrom(*source);
  }
}

void UsbProfileGroupSettingsManagerProto::MergeFrom(const UsbProfileGroupSettingsManagerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbProfileGroupSettingsManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  device_preferences_.MergeFrom(from.device_preferences_);
  accessory_preferences_.MergeFrom(from.accessory_preferences_);
  if (from.has_parent_user_id()) {
    set_parent_user_id(from.parent_user_id());
  }
}

void UsbProfileGroupSettingsManagerProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbProfileGroupSettingsManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbProfileGroupSettingsManagerProto::CopyFrom(const UsbProfileGroupSettingsManagerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbProfileGroupSettingsManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbProfileGroupSettingsManagerProto::IsInitialized() const {
  return true;
}

void UsbProfileGroupSettingsManagerProto::InternalSwap(UsbProfileGroupSettingsManagerProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&device_preferences_)->InternalSwap(CastToBase(&other->device_preferences_));
  CastToBase(&accessory_preferences_)->InternalSwap(CastToBase(&other->accessory_preferences_));
  swap(parent_user_id_, other->parent_user_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbProfileGroupSettingsManagerProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbSettingsDevicePreferenceProto::InitAsDefaultInstance() {
  ::android::service::usb::_UsbSettingsDevicePreferenceProto_default_instance_._instance.get_mutable()->filter_ = const_cast< ::android::service::usb::UsbDeviceFilterProto*>(
      ::android::service::usb::UsbDeviceFilterProto::internal_default_instance());
  ::android::service::usb::_UsbSettingsDevicePreferenceProto_default_instance_._instance.get_mutable()->user_package_ = const_cast< ::android::service::usb::UserPackageProto*>(
      ::android::service::usb::UserPackageProto::internal_default_instance());
}
class UsbSettingsDevicePreferenceProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbSettingsDevicePreferenceProto>()._has_bits_);
  static const ::android::service::usb::UsbDeviceFilterProto& filter(const UsbSettingsDevicePreferenceProto* msg);
  static void set_has_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::android::service::usb::UserPackageProto& user_package(const UsbSettingsDevicePreferenceProto* msg);
  static void set_has_user_package(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::android::service::usb::UsbDeviceFilterProto&
UsbSettingsDevicePreferenceProto::_Internal::filter(const UsbSettingsDevicePreferenceProto* msg) {
  return *msg->filter_;
}
const ::android::service::usb::UserPackageProto&
UsbSettingsDevicePreferenceProto::_Internal::user_package(const UsbSettingsDevicePreferenceProto* msg) {
  return *msg->user_package_;
}
UsbSettingsDevicePreferenceProto::UsbSettingsDevicePreferenceProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbSettingsDevicePreferenceProto)
}
UsbSettingsDevicePreferenceProto::UsbSettingsDevicePreferenceProto(const UsbSettingsDevicePreferenceProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_filter()) {
    filter_ = new ::android::service::usb::UsbDeviceFilterProto(*from.filter_);
  } else {
    filter_ = nullptr;
  }
  if (from.has_user_package()) {
    user_package_ = new ::android::service::usb::UserPackageProto(*from.user_package_);
  } else {
    user_package_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbSettingsDevicePreferenceProto)
}

void UsbSettingsDevicePreferenceProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbSettingsDevicePreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  ::memset(&filter_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&user_package_) -
      reinterpret_cast<char*>(&filter_)) + sizeof(user_package_));
}

UsbSettingsDevicePreferenceProto::~UsbSettingsDevicePreferenceProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbSettingsDevicePreferenceProto)
  SharedDtor();
}

void UsbSettingsDevicePreferenceProto::SharedDtor() {
  if (this != internal_default_instance()) delete filter_;
  if (this != internal_default_instance()) delete user_package_;
}

void UsbSettingsDevicePreferenceProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbSettingsDevicePreferenceProto& UsbSettingsDevicePreferenceProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbSettingsDevicePreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbSettingsDevicePreferenceProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbSettingsDevicePreferenceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(filter_ != nullptr);
      filter_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(user_package_ != nullptr);
      user_package_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbSettingsDevicePreferenceProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .android.service.usb.UsbDeviceFilterProto filter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_filter(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UserPackageProto user_package = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_user_package(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbSettingsDevicePreferenceProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbSettingsDevicePreferenceProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .android.service.usb.UsbDeviceFilterProto filter = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_filter()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UserPackageProto user_package = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_user_package()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbSettingsDevicePreferenceProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbSettingsDevicePreferenceProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbSettingsDevicePreferenceProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbSettingsDevicePreferenceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.service.usb.UsbDeviceFilterProto filter = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, _Internal::filter(this), output);
  }

  // optional .android.service.usb.UserPackageProto user_package = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, _Internal::user_package(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbSettingsDevicePreferenceProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbSettingsDevicePreferenceProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbSettingsDevicePreferenceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.service.usb.UsbDeviceFilterProto filter = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::filter(this), target);
  }

  // optional .android.service.usb.UserPackageProto user_package = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, _Internal::user_package(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbSettingsDevicePreferenceProto)
  return target;
}

size_t UsbSettingsDevicePreferenceProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbSettingsDevicePreferenceProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .android.service.usb.UsbDeviceFilterProto filter = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *filter_);
    }

    // optional .android.service.usb.UserPackageProto user_package = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *user_package_);
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbSettingsDevicePreferenceProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbSettingsDevicePreferenceProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbSettingsDevicePreferenceProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbSettingsDevicePreferenceProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbSettingsDevicePreferenceProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbSettingsDevicePreferenceProto)
    MergeFrom(*source);
  }
}

void UsbSettingsDevicePreferenceProto::MergeFrom(const UsbSettingsDevicePreferenceProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbSettingsDevicePreferenceProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_filter()->::android::service::usb::UsbDeviceFilterProto::MergeFrom(from.filter());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_user_package()->::android::service::usb::UserPackageProto::MergeFrom(from.user_package());
    }
  }
}

void UsbSettingsDevicePreferenceProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbSettingsDevicePreferenceProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbSettingsDevicePreferenceProto::CopyFrom(const UsbSettingsDevicePreferenceProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbSettingsDevicePreferenceProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbSettingsDevicePreferenceProto::IsInitialized() const {
  return true;
}

void UsbSettingsDevicePreferenceProto::InternalSwap(UsbSettingsDevicePreferenceProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(filter_, other->filter_);
  swap(user_package_, other->user_package_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbSettingsDevicePreferenceProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbPermissionsManagerProto::InitAsDefaultInstance() {
}
class UsbPermissionsManagerProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbPermissionsManagerProto>()._has_bits_);
};

UsbPermissionsManagerProto::UsbPermissionsManagerProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbPermissionsManagerProto)
}
UsbPermissionsManagerProto::UsbPermissionsManagerProto(const UsbPermissionsManagerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      user_permissions_(from.user_permissions_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbPermissionsManagerProto)
}

void UsbPermissionsManagerProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
}

UsbPermissionsManagerProto::~UsbPermissionsManagerProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbPermissionsManagerProto)
  SharedDtor();
}

void UsbPermissionsManagerProto::SharedDtor() {
}

void UsbPermissionsManagerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbPermissionsManagerProto& UsbPermissionsManagerProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbPermissionsManagerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbPermissionsManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_permissions_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbPermissionsManagerProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .android.service.usb.UsbUserPermissionsManagerProto user_permissions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_user_permissions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbPermissionsManagerProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbPermissionsManagerProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .android.service.usb.UsbUserPermissionsManagerProto user_permissions = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_user_permissions()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbPermissionsManagerProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbPermissionsManagerProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbPermissionsManagerProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbPermissionsManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbUserPermissionsManagerProto user_permissions = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->user_permissions_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->user_permissions(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbPermissionsManagerProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbPermissionsManagerProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbPermissionsManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbUserPermissionsManagerProto user_permissions = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->user_permissions_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->user_permissions(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbPermissionsManagerProto)
  return target;
}

size_t UsbPermissionsManagerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbPermissionsManagerProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbUserPermissionsManagerProto user_permissions = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->user_permissions_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->user_permissions(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbPermissionsManagerProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbPermissionsManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbPermissionsManagerProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbPermissionsManagerProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbPermissionsManagerProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbPermissionsManagerProto)
    MergeFrom(*source);
  }
}

void UsbPermissionsManagerProto::MergeFrom(const UsbPermissionsManagerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbPermissionsManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  user_permissions_.MergeFrom(from.user_permissions_);
}

void UsbPermissionsManagerProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbPermissionsManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbPermissionsManagerProto::CopyFrom(const UsbPermissionsManagerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbPermissionsManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbPermissionsManagerProto::IsInitialized() const {
  return true;
}

void UsbPermissionsManagerProto::InternalSwap(UsbPermissionsManagerProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&user_permissions_)->InternalSwap(CastToBase(&other->user_permissions_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbPermissionsManagerProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbUserPermissionsManagerProto::InitAsDefaultInstance() {
}
class UsbUserPermissionsManagerProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbUserPermissionsManagerProto>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UsbUserPermissionsManagerProto::UsbUserPermissionsManagerProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbUserPermissionsManagerProto)
}
UsbUserPermissionsManagerProto::UsbUserPermissionsManagerProto(const UsbUserPermissionsManagerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      device_permissions_(from.device_permissions_),
      accessory_permissions_(from.accessory_permissions_),
      device_persistent_permissions_(from.device_persistent_permissions_),
      accessory_persistent_permissions_(from.accessory_persistent_permissions_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  user_id_ = from.user_id_;
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbUserPermissionsManagerProto)
}

void UsbUserPermissionsManagerProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbUserPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  user_id_ = 0;
}

UsbUserPermissionsManagerProto::~UsbUserPermissionsManagerProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbUserPermissionsManagerProto)
  SharedDtor();
}

void UsbUserPermissionsManagerProto::SharedDtor() {
}

void UsbUserPermissionsManagerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbUserPermissionsManagerProto& UsbUserPermissionsManagerProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbUserPermissionsManagerProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbUserPermissionsManagerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbUserPermissionsManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  device_permissions_.Clear();
  accessory_permissions_.Clear();
  device_persistent_permissions_.Clear();
  accessory_persistent_permissions_.Clear();
  user_id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbUserPermissionsManagerProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbDevicePermissionProto device_permissions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_device_permissions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbAccessoryPermissionProto accessory_permissions = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_accessory_permissions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 26);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbDevicePersistentPermissionProto device_persistent_permissions = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_device_persistent_permissions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 34);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbAccessoryPersistentPermissionProto accessory_persistent_permissions = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_accessory_persistent_permissions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 42);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbUserPermissionsManagerProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbUserPermissionsManagerProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 user_id = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_user_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &user_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbDevicePermissionProto device_permissions = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_device_permissions()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbAccessoryPermissionProto accessory_permissions = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_accessory_permissions()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbDevicePersistentPermissionProto device_persistent_permissions = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_device_persistent_permissions()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbAccessoryPersistentPermissionProto accessory_persistent_permissions = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_accessory_persistent_permissions()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbUserPermissionsManagerProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbUserPermissionsManagerProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbUserPermissionsManagerProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbUserPermissionsManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->user_id(), output);
  }

  // repeated .android.service.usb.UsbDevicePermissionProto device_permissions = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->device_permissions_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->device_permissions(static_cast<int>(i)),
      output);
  }

  // repeated .android.service.usb.UsbAccessoryPermissionProto accessory_permissions = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->accessory_permissions_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      3,
      this->accessory_permissions(static_cast<int>(i)),
      output);
  }

  // repeated .android.service.usb.UsbDevicePersistentPermissionProto device_persistent_permissions = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->device_persistent_permissions_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      4,
      this->device_persistent_permissions(static_cast<int>(i)),
      output);
  }

  // repeated .android.service.usb.UsbAccessoryPersistentPermissionProto accessory_persistent_permissions = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->accessory_persistent_permissions_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      5,
      this->accessory_persistent_permissions(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbUserPermissionsManagerProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbUserPermissionsManagerProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbUserPermissionsManagerProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->user_id(), target);
  }

  // repeated .android.service.usb.UsbDevicePermissionProto device_permissions = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->device_permissions_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->device_permissions(static_cast<int>(i)), target);
  }

  // repeated .android.service.usb.UsbAccessoryPermissionProto accessory_permissions = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->accessory_permissions_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->accessory_permissions(static_cast<int>(i)), target);
  }

  // repeated .android.service.usb.UsbDevicePersistentPermissionProto device_persistent_permissions = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->device_persistent_permissions_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, this->device_persistent_permissions(static_cast<int>(i)), target);
  }

  // repeated .android.service.usb.UsbAccessoryPersistentPermissionProto accessory_persistent_permissions = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->accessory_persistent_permissions_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, this->accessory_persistent_permissions(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbUserPermissionsManagerProto)
  return target;
}

size_t UsbUserPermissionsManagerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbUserPermissionsManagerProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbDevicePermissionProto device_permissions = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->device_permissions_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->device_permissions(static_cast<int>(i)));
    }
  }

  // repeated .android.service.usb.UsbAccessoryPermissionProto accessory_permissions = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->accessory_permissions_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->accessory_permissions(static_cast<int>(i)));
    }
  }

  // repeated .android.service.usb.UsbDevicePersistentPermissionProto device_persistent_permissions = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->device_persistent_permissions_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->device_persistent_permissions(static_cast<int>(i)));
    }
  }

  // repeated .android.service.usb.UsbAccessoryPersistentPermissionProto accessory_persistent_permissions = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->accessory_persistent_permissions_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->accessory_persistent_permissions(static_cast<int>(i)));
    }
  }

  // optional int32 user_id = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->user_id());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbUserPermissionsManagerProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbUserPermissionsManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbUserPermissionsManagerProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbUserPermissionsManagerProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbUserPermissionsManagerProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbUserPermissionsManagerProto)
    MergeFrom(*source);
  }
}

void UsbUserPermissionsManagerProto::MergeFrom(const UsbUserPermissionsManagerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbUserPermissionsManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  device_permissions_.MergeFrom(from.device_permissions_);
  accessory_permissions_.MergeFrom(from.accessory_permissions_);
  device_persistent_permissions_.MergeFrom(from.device_persistent_permissions_);
  accessory_persistent_permissions_.MergeFrom(from.accessory_persistent_permissions_);
  if (from.has_user_id()) {
    set_user_id(from.user_id());
  }
}

void UsbUserPermissionsManagerProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbUserPermissionsManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbUserPermissionsManagerProto::CopyFrom(const UsbUserPermissionsManagerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbUserPermissionsManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbUserPermissionsManagerProto::IsInitialized() const {
  return true;
}

void UsbUserPermissionsManagerProto::InternalSwap(UsbUserPermissionsManagerProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&device_permissions_)->InternalSwap(CastToBase(&other->device_permissions_));
  CastToBase(&accessory_permissions_)->InternalSwap(CastToBase(&other->accessory_permissions_));
  CastToBase(&device_persistent_permissions_)->InternalSwap(CastToBase(&other->device_persistent_permissions_));
  CastToBase(&accessory_persistent_permissions_)->InternalSwap(CastToBase(&other->accessory_persistent_permissions_));
  swap(user_id_, other->user_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbUserPermissionsManagerProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbDevicePermissionProto::InitAsDefaultInstance() {
}
class UsbDevicePermissionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbDevicePermissionProto>()._has_bits_);
  static void set_has_device_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UsbDevicePermissionProto::UsbDevicePermissionProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbDevicePermissionProto)
}
UsbDevicePermissionProto::UsbDevicePermissionProto(const UsbDevicePermissionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      uids_(from.uids_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  device_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_device_name()) {
    device_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.device_name_);
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbDevicePermissionProto)
}

void UsbDevicePermissionProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbDevicePermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  device_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

UsbDevicePermissionProto::~UsbDevicePermissionProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbDevicePermissionProto)
  SharedDtor();
}

void UsbDevicePermissionProto::SharedDtor() {
  device_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UsbDevicePermissionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbDevicePermissionProto& UsbDevicePermissionProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbDevicePermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbDevicePermissionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbDevicePermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  uids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    device_name_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbDevicePermissionProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string device_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_device_name(), ptr, ctx, "android.service.usb.UsbDevicePermissionProto.device_name");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int32 uids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_uids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 16);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(mutable_uids(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbDevicePermissionProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbDevicePermissionProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string device_name = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_device_name()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->device_name().data(), static_cast<int>(this->device_name().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbDevicePermissionProto.device_name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int32 uids = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 1, 16u, input, this->mutable_uids())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_uids())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbDevicePermissionProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbDevicePermissionProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbDevicePermissionProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbDevicePermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string device_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->device_name().data(), static_cast<int>(this->device_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbDevicePermissionProto.device_name");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->device_name(), output);
  }

  // repeated int32 uids = 2;
  for (int i = 0, n = this->uids_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(
      2, this->uids(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbDevicePermissionProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbDevicePermissionProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbDevicePermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string device_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->device_name().data(), static_cast<int>(this->device_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbDevicePermissionProto.device_name");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        1, this->device_name(), target);
  }

  // repeated int32 uids = 2;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
    WriteInt32ToArray(2, this->uids_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbDevicePermissionProto)
  return target;
}

size_t UsbDevicePermissionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbDevicePermissionProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 uids = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->uids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->uids_size());
    total_size += data_size;
  }

  // optional string device_name = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->device_name());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbDevicePermissionProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbDevicePermissionProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbDevicePermissionProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbDevicePermissionProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbDevicePermissionProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbDevicePermissionProto)
    MergeFrom(*source);
  }
}

void UsbDevicePermissionProto::MergeFrom(const UsbDevicePermissionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbDevicePermissionProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  uids_.MergeFrom(from.uids_);
  if (from.has_device_name()) {
    _has_bits_[0] |= 0x00000001u;
    device_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.device_name_);
  }
}

void UsbDevicePermissionProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbDevicePermissionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbDevicePermissionProto::CopyFrom(const UsbDevicePermissionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbDevicePermissionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbDevicePermissionProto::IsInitialized() const {
  return true;
}

void UsbDevicePermissionProto::InternalSwap(UsbDevicePermissionProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  uids_.InternalSwap(&other->uids_);
  device_name_.Swap(&other->device_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbDevicePermissionProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbAccessoryPermissionProto::InitAsDefaultInstance() {
}
class UsbAccessoryPermissionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbAccessoryPermissionProto>()._has_bits_);
  static void set_has_accessory_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UsbAccessoryPermissionProto::UsbAccessoryPermissionProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbAccessoryPermissionProto)
}
UsbAccessoryPermissionProto::UsbAccessoryPermissionProto(const UsbAccessoryPermissionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      uids_(from.uids_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  accessory_description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_accessory_description()) {
    accessory_description_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.accessory_description_);
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbAccessoryPermissionProto)
}

void UsbAccessoryPermissionProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbAccessoryPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  accessory_description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

UsbAccessoryPermissionProto::~UsbAccessoryPermissionProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbAccessoryPermissionProto)
  SharedDtor();
}

void UsbAccessoryPermissionProto::SharedDtor() {
  accessory_description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UsbAccessoryPermissionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbAccessoryPermissionProto& UsbAccessoryPermissionProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbAccessoryPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbAccessoryPermissionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbAccessoryPermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  uids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    accessory_description_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbAccessoryPermissionProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string accessory_description = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_accessory_description(), ptr, ctx, "android.service.usb.UsbAccessoryPermissionProto.accessory_description");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int32 uids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_uids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 16);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(mutable_uids(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbAccessoryPermissionProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbAccessoryPermissionProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string accessory_description = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_accessory_description()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->accessory_description().data(), static_cast<int>(this->accessory_description().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbAccessoryPermissionProto.accessory_description");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int32 uids = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 1, 16u, input, this->mutable_uids())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_uids())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbAccessoryPermissionProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbAccessoryPermissionProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbAccessoryPermissionProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbAccessoryPermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string accessory_description = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->accessory_description().data(), static_cast<int>(this->accessory_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbAccessoryPermissionProto.accessory_description");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->accessory_description(), output);
  }

  // repeated int32 uids = 2;
  for (int i = 0, n = this->uids_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(
      2, this->uids(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbAccessoryPermissionProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbAccessoryPermissionProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbAccessoryPermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string accessory_description = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->accessory_description().data(), static_cast<int>(this->accessory_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbAccessoryPermissionProto.accessory_description");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        1, this->accessory_description(), target);
  }

  // repeated int32 uids = 2;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
    WriteInt32ToArray(2, this->uids_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbAccessoryPermissionProto)
  return target;
}

size_t UsbAccessoryPermissionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbAccessoryPermissionProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 uids = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->uids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->uids_size());
    total_size += data_size;
  }

  // optional string accessory_description = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->accessory_description());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbAccessoryPermissionProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbAccessoryPermissionProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbAccessoryPermissionProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbAccessoryPermissionProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbAccessoryPermissionProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbAccessoryPermissionProto)
    MergeFrom(*source);
  }
}

void UsbAccessoryPermissionProto::MergeFrom(const UsbAccessoryPermissionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbAccessoryPermissionProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  uids_.MergeFrom(from.uids_);
  if (from.has_accessory_description()) {
    _has_bits_[0] |= 0x00000001u;
    accessory_description_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.accessory_description_);
  }
}

void UsbAccessoryPermissionProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbAccessoryPermissionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbAccessoryPermissionProto::CopyFrom(const UsbAccessoryPermissionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbAccessoryPermissionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbAccessoryPermissionProto::IsInitialized() const {
  return true;
}

void UsbAccessoryPermissionProto::InternalSwap(UsbAccessoryPermissionProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  uids_.InternalSwap(&other->uids_);
  accessory_description_.Swap(&other->accessory_description_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbAccessoryPermissionProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbDevicePersistentPermissionProto::InitAsDefaultInstance() {
  ::android::service::usb::_UsbDevicePersistentPermissionProto_default_instance_._instance.get_mutable()->device_filter_ = const_cast< ::android::service::usb::UsbDeviceFilterProto*>(
      ::android::service::usb::UsbDeviceFilterProto::internal_default_instance());
}
class UsbDevicePersistentPermissionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbDevicePersistentPermissionProto>()._has_bits_);
  static const ::android::service::usb::UsbDeviceFilterProto& device_filter(const UsbDevicePersistentPermissionProto* msg);
  static void set_has_device_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::android::service::usb::UsbDeviceFilterProto&
UsbDevicePersistentPermissionProto::_Internal::device_filter(const UsbDevicePersistentPermissionProto* msg) {
  return *msg->device_filter_;
}
UsbDevicePersistentPermissionProto::UsbDevicePersistentPermissionProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbDevicePersistentPermissionProto)
}
UsbDevicePersistentPermissionProto::UsbDevicePersistentPermissionProto(const UsbDevicePersistentPermissionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      permission_values_(from.permission_values_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_device_filter()) {
    device_filter_ = new ::android::service::usb::UsbDeviceFilterProto(*from.device_filter_);
  } else {
    device_filter_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbDevicePersistentPermissionProto)
}

void UsbDevicePersistentPermissionProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbDevicePersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  device_filter_ = nullptr;
}

UsbDevicePersistentPermissionProto::~UsbDevicePersistentPermissionProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbDevicePersistentPermissionProto)
  SharedDtor();
}

void UsbDevicePersistentPermissionProto::SharedDtor() {
  if (this != internal_default_instance()) delete device_filter_;
}

void UsbDevicePersistentPermissionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbDevicePersistentPermissionProto& UsbDevicePersistentPermissionProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbDevicePersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbDevicePersistentPermissionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbDevicePersistentPermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  permission_values_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(device_filter_ != nullptr);
    device_filter_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbDevicePersistentPermissionProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .android.service.usb.UsbDeviceFilterProto device_filter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_device_filter(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbUidPermissionProto permission_values = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_permission_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbDevicePersistentPermissionProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbDevicePersistentPermissionProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .android.service.usb.UsbDeviceFilterProto device_filter = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_device_filter()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbUidPermissionProto permission_values = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_permission_values()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbDevicePersistentPermissionProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbDevicePersistentPermissionProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbDevicePersistentPermissionProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbDevicePersistentPermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.service.usb.UsbDeviceFilterProto device_filter = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, _Internal::device_filter(this), output);
  }

  // repeated .android.service.usb.UsbUidPermissionProto permission_values = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->permission_values_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->permission_values(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbDevicePersistentPermissionProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbDevicePersistentPermissionProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbDevicePersistentPermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.service.usb.UsbDeviceFilterProto device_filter = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::device_filter(this), target);
  }

  // repeated .android.service.usb.UsbUidPermissionProto permission_values = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->permission_values_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->permission_values(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbDevicePersistentPermissionProto)
  return target;
}

size_t UsbDevicePersistentPermissionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbDevicePersistentPermissionProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbUidPermissionProto permission_values = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->permission_values_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->permission_values(static_cast<int>(i)));
    }
  }

  // optional .android.service.usb.UsbDeviceFilterProto device_filter = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *device_filter_);
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbDevicePersistentPermissionProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbDevicePersistentPermissionProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbDevicePersistentPermissionProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbDevicePersistentPermissionProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbDevicePersistentPermissionProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbDevicePersistentPermissionProto)
    MergeFrom(*source);
  }
}

void UsbDevicePersistentPermissionProto::MergeFrom(const UsbDevicePersistentPermissionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbDevicePersistentPermissionProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  permission_values_.MergeFrom(from.permission_values_);
  if (from.has_device_filter()) {
    mutable_device_filter()->::android::service::usb::UsbDeviceFilterProto::MergeFrom(from.device_filter());
  }
}

void UsbDevicePersistentPermissionProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbDevicePersistentPermissionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbDevicePersistentPermissionProto::CopyFrom(const UsbDevicePersistentPermissionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbDevicePersistentPermissionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbDevicePersistentPermissionProto::IsInitialized() const {
  return true;
}

void UsbDevicePersistentPermissionProto::InternalSwap(UsbDevicePersistentPermissionProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&permission_values_)->InternalSwap(CastToBase(&other->permission_values_));
  swap(device_filter_, other->device_filter_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbDevicePersistentPermissionProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbAccessoryPersistentPermissionProto::InitAsDefaultInstance() {
  ::android::service::usb::_UsbAccessoryPersistentPermissionProto_default_instance_._instance.get_mutable()->accessory_filter_ = const_cast< ::android::service::usb::UsbAccessoryFilterProto*>(
      ::android::service::usb::UsbAccessoryFilterProto::internal_default_instance());
}
class UsbAccessoryPersistentPermissionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbAccessoryPersistentPermissionProto>()._has_bits_);
  static const ::android::service::usb::UsbAccessoryFilterProto& accessory_filter(const UsbAccessoryPersistentPermissionProto* msg);
  static void set_has_accessory_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::android::service::usb::UsbAccessoryFilterProto&
UsbAccessoryPersistentPermissionProto::_Internal::accessory_filter(const UsbAccessoryPersistentPermissionProto* msg) {
  return *msg->accessory_filter_;
}
UsbAccessoryPersistentPermissionProto::UsbAccessoryPersistentPermissionProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbAccessoryPersistentPermissionProto)
}
UsbAccessoryPersistentPermissionProto::UsbAccessoryPersistentPermissionProto(const UsbAccessoryPersistentPermissionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      permission_values_(from.permission_values_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_accessory_filter()) {
    accessory_filter_ = new ::android::service::usb::UsbAccessoryFilterProto(*from.accessory_filter_);
  } else {
    accessory_filter_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbAccessoryPersistentPermissionProto)
}

void UsbAccessoryPersistentPermissionProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbAccessoryPersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  accessory_filter_ = nullptr;
}

UsbAccessoryPersistentPermissionProto::~UsbAccessoryPersistentPermissionProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbAccessoryPersistentPermissionProto)
  SharedDtor();
}

void UsbAccessoryPersistentPermissionProto::SharedDtor() {
  if (this != internal_default_instance()) delete accessory_filter_;
}

void UsbAccessoryPersistentPermissionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbAccessoryPersistentPermissionProto& UsbAccessoryPersistentPermissionProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbAccessoryPersistentPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbAccessoryPersistentPermissionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbAccessoryPersistentPermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  permission_values_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(accessory_filter_ != nullptr);
    accessory_filter_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbAccessoryPersistentPermissionProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .android.service.usb.UsbAccessoryFilterProto accessory_filter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_accessory_filter(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbUidPermissionProto permission_values = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_permission_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbAccessoryPersistentPermissionProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbAccessoryPersistentPermissionProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .android.service.usb.UsbAccessoryFilterProto accessory_filter = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_accessory_filter()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbUidPermissionProto permission_values = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_permission_values()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbAccessoryPersistentPermissionProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbAccessoryPersistentPermissionProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbAccessoryPersistentPermissionProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbAccessoryPersistentPermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.service.usb.UsbAccessoryFilterProto accessory_filter = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, _Internal::accessory_filter(this), output);
  }

  // repeated .android.service.usb.UsbUidPermissionProto permission_values = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->permission_values_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->permission_values(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbAccessoryPersistentPermissionProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbAccessoryPersistentPermissionProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbAccessoryPersistentPermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.service.usb.UsbAccessoryFilterProto accessory_filter = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::accessory_filter(this), target);
  }

  // repeated .android.service.usb.UsbUidPermissionProto permission_values = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->permission_values_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->permission_values(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbAccessoryPersistentPermissionProto)
  return target;
}

size_t UsbAccessoryPersistentPermissionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbAccessoryPersistentPermissionProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbUidPermissionProto permission_values = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->permission_values_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->permission_values(static_cast<int>(i)));
    }
  }

  // optional .android.service.usb.UsbAccessoryFilterProto accessory_filter = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *accessory_filter_);
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbAccessoryPersistentPermissionProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbAccessoryPersistentPermissionProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbAccessoryPersistentPermissionProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbAccessoryPersistentPermissionProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbAccessoryPersistentPermissionProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbAccessoryPersistentPermissionProto)
    MergeFrom(*source);
  }
}

void UsbAccessoryPersistentPermissionProto::MergeFrom(const UsbAccessoryPersistentPermissionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbAccessoryPersistentPermissionProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  permission_values_.MergeFrom(from.permission_values_);
  if (from.has_accessory_filter()) {
    mutable_accessory_filter()->::android::service::usb::UsbAccessoryFilterProto::MergeFrom(from.accessory_filter());
  }
}

void UsbAccessoryPersistentPermissionProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbAccessoryPersistentPermissionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbAccessoryPersistentPermissionProto::CopyFrom(const UsbAccessoryPersistentPermissionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbAccessoryPersistentPermissionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbAccessoryPersistentPermissionProto::IsInitialized() const {
  return true;
}

void UsbAccessoryPersistentPermissionProto::InternalSwap(UsbAccessoryPersistentPermissionProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&permission_values_)->InternalSwap(CastToBase(&other->permission_values_));
  swap(accessory_filter_, other->accessory_filter_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbAccessoryPersistentPermissionProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbUidPermissionProto::InitAsDefaultInstance() {
}
class UsbUidPermissionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbUidPermissionProto>()._has_bits_);
  static void set_has_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_granted(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

UsbUidPermissionProto::UsbUidPermissionProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbUidPermissionProto)
}
UsbUidPermissionProto::UsbUidPermissionProto(const UsbUidPermissionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&uid_, &from.uid_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_granted_) -
    reinterpret_cast<char*>(&uid_)) + sizeof(is_granted_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbUidPermissionProto)
}

void UsbUidPermissionProto::SharedCtor() {
  ::memset(&uid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_granted_) -
      reinterpret_cast<char*>(&uid_)) + sizeof(is_granted_));
}

UsbUidPermissionProto::~UsbUidPermissionProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbUidPermissionProto)
  SharedDtor();
}

void UsbUidPermissionProto::SharedDtor() {
}

void UsbUidPermissionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbUidPermissionProto& UsbUidPermissionProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbUidPermissionProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbUidPermissionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbUidPermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&uid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_granted_) -
        reinterpret_cast<char*>(&uid_)) + sizeof(is_granted_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbUidPermissionProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 uid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_uid(&has_bits);
          uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_granted = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_is_granted(&has_bits);
          is_granted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbUidPermissionProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbUidPermissionProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 uid = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_uid(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &uid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool is_granted = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_is_granted(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_granted_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbUidPermissionProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbUidPermissionProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbUidPermissionProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbUidPermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 uid = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->uid(), output);
  }

  // optional bool is_granted = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(2, this->is_granted(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbUidPermissionProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbUidPermissionProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbUidPermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 uid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->uid(), target);
  }

  // optional bool is_granted = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->is_granted(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbUidPermissionProto)
  return target;
}

size_t UsbUidPermissionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbUidPermissionProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 uid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->uid());
    }

    // optional bool is_granted = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbUidPermissionProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbUidPermissionProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbUidPermissionProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbUidPermissionProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbUidPermissionProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbUidPermissionProto)
    MergeFrom(*source);
  }
}

void UsbUidPermissionProto::MergeFrom(const UsbUidPermissionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbUidPermissionProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      uid_ = from.uid_;
    }
    if (cached_has_bits & 0x00000002u) {
      is_granted_ = from.is_granted_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbUidPermissionProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbUidPermissionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbUidPermissionProto::CopyFrom(const UsbUidPermissionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbUidPermissionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbUidPermissionProto::IsInitialized() const {
  return true;
}

void UsbUidPermissionProto::InternalSwap(UsbUidPermissionProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(uid_, other->uid_);
  swap(is_granted_, other->is_granted_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbUidPermissionProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbDeviceFilterProto::InitAsDefaultInstance() {
}
class UsbDeviceFilterProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbDeviceFilterProto>()._has_bits_);
  static void set_has_vendor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_product_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_class_(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_subclass(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_protocol(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_manufacturer_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_product_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_serial_number(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

UsbDeviceFilterProto::UsbDeviceFilterProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbDeviceFilterProto)
}
UsbDeviceFilterProto::UsbDeviceFilterProto(const UsbDeviceFilterProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  manufacturer_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_manufacturer_name()) {
    manufacturer_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.manufacturer_name_);
  }
  product_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_product_name()) {
    product_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.product_name_);
  }
  serial_number_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_serial_number()) {
    serial_number_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.serial_number_);
  }
  ::memcpy(&vendor_id_, &from.vendor_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&protocol_) -
    reinterpret_cast<char*>(&vendor_id_)) + sizeof(protocol_));
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbDeviceFilterProto)
}

void UsbDeviceFilterProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbDeviceFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  manufacturer_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  product_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  serial_number_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&vendor_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&protocol_) -
      reinterpret_cast<char*>(&vendor_id_)) + sizeof(protocol_));
}

UsbDeviceFilterProto::~UsbDeviceFilterProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbDeviceFilterProto)
  SharedDtor();
}

void UsbDeviceFilterProto::SharedDtor() {
  manufacturer_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  product_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  serial_number_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UsbDeviceFilterProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbDeviceFilterProto& UsbDeviceFilterProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbDeviceFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbDeviceFilterProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbDeviceFilterProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      manufacturer_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      product_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      serial_number_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&vendor_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&protocol_) -
        reinterpret_cast<char*>(&vendor_id_)) + sizeof(protocol_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbDeviceFilterProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 vendor_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_vendor_id(&has_bits);
          vendor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 product_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_product_id(&has_bits);
          product_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 class = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_class_(&has_bits);
          class__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 subclass = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_subclass(&has_bits);
          subclass_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 protocol = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_protocol(&has_bits);
          protocol_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string manufacturer_name = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_manufacturer_name(), ptr, ctx, "android.service.usb.UsbDeviceFilterProto.manufacturer_name");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string product_name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_product_name(), ptr, ctx, "android.service.usb.UsbDeviceFilterProto.product_name");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string serial_number = 8 [(.android.privacy) = {
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_serial_number(), ptr, ctx, "android.service.usb.UsbDeviceFilterProto.serial_number");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbDeviceFilterProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbDeviceFilterProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 vendor_id = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_vendor_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &vendor_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 product_id = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_product_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &product_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 class = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_class_(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &class__)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 subclass = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_subclass(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &subclass_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 protocol = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_protocol(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &protocol_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string manufacturer_name = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_manufacturer_name()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->manufacturer_name().data(), static_cast<int>(this->manufacturer_name().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbDeviceFilterProto.manufacturer_name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string product_name = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (58 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_product_name()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->product_name().data(), static_cast<int>(this->product_name().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbDeviceFilterProto.product_name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string serial_number = 8 [(.android.privacy) = {
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (66 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_serial_number()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->serial_number().data(), static_cast<int>(this->serial_number().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbDeviceFilterProto.serial_number");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbDeviceFilterProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbDeviceFilterProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbDeviceFilterProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbDeviceFilterProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 vendor_id = 1;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->vendor_id(), output);
  }

  // optional int32 product_id = 2;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->product_id(), output);
  }

  // optional int32 class = 3;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->class_(), output);
  }

  // optional int32 subclass = 4;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->subclass(), output);
  }

  // optional int32 protocol = 5;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->protocol(), output);
  }

  // optional string manufacturer_name = 6;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->manufacturer_name().data(), static_cast<int>(this->manufacturer_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbDeviceFilterProto.manufacturer_name");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->manufacturer_name(), output);
  }

  // optional string product_name = 7;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->product_name().data(), static_cast<int>(this->product_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbDeviceFilterProto.product_name");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->product_name(), output);
  }

  // optional string serial_number = 8 [(.android.privacy) = {
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->serial_number().data(), static_cast<int>(this->serial_number().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbDeviceFilterProto.serial_number");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->serial_number(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbDeviceFilterProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbDeviceFilterProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbDeviceFilterProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 vendor_id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->vendor_id(), target);
  }

  // optional int32 product_id = 2;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->product_id(), target);
  }

  // optional int32 class = 3;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->class_(), target);
  }

  // optional int32 subclass = 4;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->subclass(), target);
  }

  // optional int32 protocol = 5;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->protocol(), target);
  }

  // optional string manufacturer_name = 6;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->manufacturer_name().data(), static_cast<int>(this->manufacturer_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbDeviceFilterProto.manufacturer_name");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        6, this->manufacturer_name(), target);
  }

  // optional string product_name = 7;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->product_name().data(), static_cast<int>(this->product_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbDeviceFilterProto.product_name");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        7, this->product_name(), target);
  }

  // optional string serial_number = 8 [(.android.privacy) = {
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->serial_number().data(), static_cast<int>(this->serial_number().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbDeviceFilterProto.serial_number");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        8, this->serial_number(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbDeviceFilterProto)
  return target;
}

size_t UsbDeviceFilterProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbDeviceFilterProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string manufacturer_name = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->manufacturer_name());
    }

    // optional string product_name = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->product_name());
    }

    // optional string serial_number = 8 [(.android.privacy) = {
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->serial_number());
    }

    // optional int32 vendor_id = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->vendor_id());
    }

    // optional int32 product_id = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->product_id());
    }

    // optional int32 class = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->class_());
    }

    // optional int32 subclass = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->subclass());
    }

    // optional int32 protocol = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->protocol());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbDeviceFilterProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbDeviceFilterProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbDeviceFilterProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbDeviceFilterProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbDeviceFilterProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbDeviceFilterProto)
    MergeFrom(*source);
  }
}

void UsbDeviceFilterProto::MergeFrom(const UsbDeviceFilterProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbDeviceFilterProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      manufacturer_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.manufacturer_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      product_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.product_name_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      serial_number_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.serial_number_);
    }
    if (cached_has_bits & 0x00000008u) {
      vendor_id_ = from.vendor_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      product_id_ = from.product_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      class__ = from.class__;
    }
    if (cached_has_bits & 0x00000040u) {
      subclass_ = from.subclass_;
    }
    if (cached_has_bits & 0x00000080u) {
      protocol_ = from.protocol_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UsbDeviceFilterProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbDeviceFilterProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbDeviceFilterProto::CopyFrom(const UsbDeviceFilterProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbDeviceFilterProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbDeviceFilterProto::IsInitialized() const {
  return true;
}

void UsbDeviceFilterProto::InternalSwap(UsbDeviceFilterProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  manufacturer_name_.Swap(&other->manufacturer_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  product_name_.Swap(&other->product_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  serial_number_.Swap(&other->serial_number_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(vendor_id_, other->vendor_id_);
  swap(product_id_, other->product_id_);
  swap(class__, other->class__);
  swap(subclass_, other->subclass_);
  swap(protocol_, other->protocol_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbDeviceFilterProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UserPackageProto::InitAsDefaultInstance() {
}
class UserPackageProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UserPackageProto>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_package_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UserPackageProto::UserPackageProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UserPackageProto)
}
UserPackageProto::UserPackageProto(const UserPackageProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  package_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_package_name()) {
    package_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.package_name_);
  }
  user_id_ = from.user_id_;
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UserPackageProto)
}

void UserPackageProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UserPackageProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  package_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  user_id_ = 0;
}

UserPackageProto::~UserPackageProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UserPackageProto)
  SharedDtor();
}

void UserPackageProto::SharedDtor() {
  package_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UserPackageProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UserPackageProto& UserPackageProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UserPackageProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UserPackageProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UserPackageProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    package_name_.ClearNonDefaultToEmptyNoArena();
  }
  user_id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UserPackageProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string package_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_package_name(), ptr, ctx, "android.service.usb.UserPackageProto.package_name");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UserPackageProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UserPackageProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 user_id = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_user_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &user_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string package_name = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_package_name()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->package_name().data(), static_cast<int>(this->package_name().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UserPackageProto.package_name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UserPackageProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UserPackageProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UserPackageProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UserPackageProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 user_id = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->user_id(), output);
  }

  // optional string package_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->package_name().data(), static_cast<int>(this->package_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UserPackageProto.package_name");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->package_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UserPackageProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UserPackageProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UserPackageProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 user_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->user_id(), target);
  }

  // optional string package_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->package_name().data(), static_cast<int>(this->package_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UserPackageProto.package_name");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        2, this->package_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UserPackageProto)
  return target;
}

size_t UserPackageProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UserPackageProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string package_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->package_name());
    }

    // optional int32 user_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->user_id());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserPackageProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UserPackageProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UserPackageProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UserPackageProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UserPackageProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UserPackageProto)
    MergeFrom(*source);
  }
}

void UserPackageProto::MergeFrom(const UserPackageProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UserPackageProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      package_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.package_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      user_id_ = from.user_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UserPackageProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UserPackageProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UserPackageProto::CopyFrom(const UserPackageProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UserPackageProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserPackageProto::IsInitialized() const {
  return true;
}

void UserPackageProto::InternalSwap(UserPackageProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  package_name_.Swap(&other->package_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(user_id_, other->user_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UserPackageProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbSettingsAccessoryPreferenceProto::InitAsDefaultInstance() {
  ::android::service::usb::_UsbSettingsAccessoryPreferenceProto_default_instance_._instance.get_mutable()->filter_ = const_cast< ::android::service::usb::UsbAccessoryFilterProto*>(
      ::android::service::usb::UsbAccessoryFilterProto::internal_default_instance());
  ::android::service::usb::_UsbSettingsAccessoryPreferenceProto_default_instance_._instance.get_mutable()->user_package_ = const_cast< ::android::service::usb::UserPackageProto*>(
      ::android::service::usb::UserPackageProto::internal_default_instance());
}
class UsbSettingsAccessoryPreferenceProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbSettingsAccessoryPreferenceProto>()._has_bits_);
  static const ::android::service::usb::UsbAccessoryFilterProto& filter(const UsbSettingsAccessoryPreferenceProto* msg);
  static void set_has_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::android::service::usb::UserPackageProto& user_package(const UsbSettingsAccessoryPreferenceProto* msg);
  static void set_has_user_package(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::android::service::usb::UsbAccessoryFilterProto&
UsbSettingsAccessoryPreferenceProto::_Internal::filter(const UsbSettingsAccessoryPreferenceProto* msg) {
  return *msg->filter_;
}
const ::android::service::usb::UserPackageProto&
UsbSettingsAccessoryPreferenceProto::_Internal::user_package(const UsbSettingsAccessoryPreferenceProto* msg) {
  return *msg->user_package_;
}
UsbSettingsAccessoryPreferenceProto::UsbSettingsAccessoryPreferenceProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbSettingsAccessoryPreferenceProto)
}
UsbSettingsAccessoryPreferenceProto::UsbSettingsAccessoryPreferenceProto(const UsbSettingsAccessoryPreferenceProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_filter()) {
    filter_ = new ::android::service::usb::UsbAccessoryFilterProto(*from.filter_);
  } else {
    filter_ = nullptr;
  }
  if (from.has_user_package()) {
    user_package_ = new ::android::service::usb::UserPackageProto(*from.user_package_);
  } else {
    user_package_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbSettingsAccessoryPreferenceProto)
}

void UsbSettingsAccessoryPreferenceProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbSettingsAccessoryPreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  ::memset(&filter_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&user_package_) -
      reinterpret_cast<char*>(&filter_)) + sizeof(user_package_));
}

UsbSettingsAccessoryPreferenceProto::~UsbSettingsAccessoryPreferenceProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbSettingsAccessoryPreferenceProto)
  SharedDtor();
}

void UsbSettingsAccessoryPreferenceProto::SharedDtor() {
  if (this != internal_default_instance()) delete filter_;
  if (this != internal_default_instance()) delete user_package_;
}

void UsbSettingsAccessoryPreferenceProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbSettingsAccessoryPreferenceProto& UsbSettingsAccessoryPreferenceProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbSettingsAccessoryPreferenceProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbSettingsAccessoryPreferenceProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbSettingsAccessoryPreferenceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(filter_ != nullptr);
      filter_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(user_package_ != nullptr);
      user_package_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbSettingsAccessoryPreferenceProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .android.service.usb.UsbAccessoryFilterProto filter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_filter(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .android.service.usb.UserPackageProto user_package = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_user_package(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbSettingsAccessoryPreferenceProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbSettingsAccessoryPreferenceProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .android.service.usb.UsbAccessoryFilterProto filter = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_filter()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .android.service.usb.UserPackageProto user_package = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_user_package()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbSettingsAccessoryPreferenceProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbSettingsAccessoryPreferenceProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbSettingsAccessoryPreferenceProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbSettingsAccessoryPreferenceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.service.usb.UsbAccessoryFilterProto filter = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, _Internal::filter(this), output);
  }

  // optional .android.service.usb.UserPackageProto user_package = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, _Internal::user_package(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbSettingsAccessoryPreferenceProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbSettingsAccessoryPreferenceProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbSettingsAccessoryPreferenceProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.service.usb.UsbAccessoryFilterProto filter = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::filter(this), target);
  }

  // optional .android.service.usb.UserPackageProto user_package = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, _Internal::user_package(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbSettingsAccessoryPreferenceProto)
  return target;
}

size_t UsbSettingsAccessoryPreferenceProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbSettingsAccessoryPreferenceProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .android.service.usb.UsbAccessoryFilterProto filter = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *filter_);
    }

    // optional .android.service.usb.UserPackageProto user_package = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *user_package_);
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbSettingsAccessoryPreferenceProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbSettingsAccessoryPreferenceProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbSettingsAccessoryPreferenceProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbSettingsAccessoryPreferenceProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbSettingsAccessoryPreferenceProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbSettingsAccessoryPreferenceProto)
    MergeFrom(*source);
  }
}

void UsbSettingsAccessoryPreferenceProto::MergeFrom(const UsbSettingsAccessoryPreferenceProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbSettingsAccessoryPreferenceProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_filter()->::android::service::usb::UsbAccessoryFilterProto::MergeFrom(from.filter());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_user_package()->::android::service::usb::UserPackageProto::MergeFrom(from.user_package());
    }
  }
}

void UsbSettingsAccessoryPreferenceProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbSettingsAccessoryPreferenceProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbSettingsAccessoryPreferenceProto::CopyFrom(const UsbSettingsAccessoryPreferenceProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbSettingsAccessoryPreferenceProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbSettingsAccessoryPreferenceProto::IsInitialized() const {
  return true;
}

void UsbSettingsAccessoryPreferenceProto::InternalSwap(UsbSettingsAccessoryPreferenceProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(filter_, other->filter_);
  swap(user_package_, other->user_package_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbSettingsAccessoryPreferenceProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbAccessoryFilterProto::InitAsDefaultInstance() {
}
class UsbAccessoryFilterProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbAccessoryFilterProto>()._has_bits_);
  static void set_has_manufacturer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_model(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

UsbAccessoryFilterProto::UsbAccessoryFilterProto()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbAccessoryFilterProto)
}
UsbAccessoryFilterProto::UsbAccessoryFilterProto(const UsbAccessoryFilterProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  manufacturer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_manufacturer()) {
    manufacturer_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.manufacturer_);
  }
  model_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_model()) {
    model_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.model_);
  }
  version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_version()) {
    version_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.version_);
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbAccessoryFilterProto)
}

void UsbAccessoryFilterProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbAccessoryFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  manufacturer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  model_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

UsbAccessoryFilterProto::~UsbAccessoryFilterProto() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbAccessoryFilterProto)
  SharedDtor();
}

void UsbAccessoryFilterProto::SharedDtor() {
  manufacturer_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  model_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UsbAccessoryFilterProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbAccessoryFilterProto& UsbAccessoryFilterProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbAccessoryFilterProto_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbAccessoryFilterProto::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbAccessoryFilterProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      manufacturer_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      model_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      version_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbAccessoryFilterProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string manufacturer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_manufacturer(), ptr, ctx, "android.service.usb.UsbAccessoryFilterProto.manufacturer");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string model = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_model(), ptr, ctx, "android.service.usb.UsbAccessoryFilterProto.model");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_version(), ptr, ctx, "android.service.usb.UsbAccessoryFilterProto.version");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbAccessoryFilterProto::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbAccessoryFilterProto)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string manufacturer = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_manufacturer()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->manufacturer().data(), static_cast<int>(this->manufacturer().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbAccessoryFilterProto.manufacturer");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string model = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_model()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model().data(), static_cast<int>(this->model().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbAccessoryFilterProto.model");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string version = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->version().data(), static_cast<int>(this->version().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "android.service.usb.UsbAccessoryFilterProto.version");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbAccessoryFilterProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbAccessoryFilterProto)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbAccessoryFilterProto::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbAccessoryFilterProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string manufacturer = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->manufacturer().data(), static_cast<int>(this->manufacturer().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbAccessoryFilterProto.manufacturer");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->manufacturer(), output);
  }

  // optional string model = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model().data(), static_cast<int>(this->model().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbAccessoryFilterProto.model");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->model(), output);
  }

  // optional string version = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), static_cast<int>(this->version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbAccessoryFilterProto.version");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->version(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbAccessoryFilterProto)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbAccessoryFilterProto::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbAccessoryFilterProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string manufacturer = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->manufacturer().data(), static_cast<int>(this->manufacturer().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbAccessoryFilterProto.manufacturer");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        1, this->manufacturer(), target);
  }

  // optional string model = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model().data(), static_cast<int>(this->model().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbAccessoryFilterProto.model");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        2, this->model(), target);
  }

  // optional string version = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), static_cast<int>(this->version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "android.service.usb.UsbAccessoryFilterProto.version");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        3, this->version(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbAccessoryFilterProto)
  return target;
}

size_t UsbAccessoryFilterProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbAccessoryFilterProto)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string manufacturer = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->manufacturer());
    }

    // optional string model = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->model());
    }

    // optional string version = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->version());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbAccessoryFilterProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbAccessoryFilterProto)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbAccessoryFilterProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbAccessoryFilterProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbAccessoryFilterProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbAccessoryFilterProto)
    MergeFrom(*source);
  }
}

void UsbAccessoryFilterProto::MergeFrom(const UsbAccessoryFilterProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbAccessoryFilterProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      manufacturer_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.manufacturer_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      model_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.model_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      version_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.version_);
    }
  }
}

void UsbAccessoryFilterProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbAccessoryFilterProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbAccessoryFilterProto::CopyFrom(const UsbAccessoryFilterProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbAccessoryFilterProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbAccessoryFilterProto::IsInitialized() const {
  return true;
}

void UsbAccessoryFilterProto::InternalSwap(UsbAccessoryFilterProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  manufacturer_.Swap(&other->manufacturer_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  model_.Swap(&other->model_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  version_.Swap(&other->version_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbAccessoryFilterProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbDeviceAttachedActivities::InitAsDefaultInstance() {
  ::android::service::usb::_UsbDeviceAttachedActivities_default_instance_._instance.get_mutable()->activity_ = const_cast< ::android::content::ComponentNameProto*>(
      ::android::content::ComponentNameProto::internal_default_instance());
}
class UsbDeviceAttachedActivities::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbDeviceAttachedActivities>()._has_bits_);
  static const ::android::content::ComponentNameProto& activity(const UsbDeviceAttachedActivities* msg);
  static void set_has_activity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::android::content::ComponentNameProto&
UsbDeviceAttachedActivities::_Internal::activity(const UsbDeviceAttachedActivities* msg) {
  return *msg->activity_;
}
void UsbDeviceAttachedActivities::clear_activity() {
  if (activity_ != nullptr) activity_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
UsbDeviceAttachedActivities::UsbDeviceAttachedActivities()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbDeviceAttachedActivities)
}
UsbDeviceAttachedActivities::UsbDeviceAttachedActivities(const UsbDeviceAttachedActivities& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      filters_(from.filters_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_activity()) {
    activity_ = new ::android::content::ComponentNameProto(*from.activity_);
  } else {
    activity_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbDeviceAttachedActivities)
}

void UsbDeviceAttachedActivities::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbDeviceAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  activity_ = nullptr;
}

UsbDeviceAttachedActivities::~UsbDeviceAttachedActivities() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbDeviceAttachedActivities)
  SharedDtor();
}

void UsbDeviceAttachedActivities::SharedDtor() {
  if (this != internal_default_instance()) delete activity_;
}

void UsbDeviceAttachedActivities::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbDeviceAttachedActivities& UsbDeviceAttachedActivities::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbDeviceAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbDeviceAttachedActivities::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbDeviceAttachedActivities)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  filters_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(activity_ != nullptr);
    activity_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbDeviceAttachedActivities::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .android.content.ComponentNameProto activity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_activity(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbDeviceFilterProto filters = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_filters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbDeviceAttachedActivities::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbDeviceAttachedActivities)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .android.content.ComponentNameProto activity = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_activity()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbDeviceFilterProto filters = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_filters()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbDeviceAttachedActivities)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbDeviceAttachedActivities)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbDeviceAttachedActivities::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbDeviceAttachedActivities)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.content.ComponentNameProto activity = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, _Internal::activity(this), output);
  }

  // repeated .android.service.usb.UsbDeviceFilterProto filters = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->filters_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->filters(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbDeviceAttachedActivities)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbDeviceAttachedActivities::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbDeviceAttachedActivities)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.content.ComponentNameProto activity = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::activity(this), target);
  }

  // repeated .android.service.usb.UsbDeviceFilterProto filters = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->filters_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->filters(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbDeviceAttachedActivities)
  return target;
}

size_t UsbDeviceAttachedActivities::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbDeviceAttachedActivities)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbDeviceFilterProto filters = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->filters_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->filters(static_cast<int>(i)));
    }
  }

  // optional .android.content.ComponentNameProto activity = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *activity_);
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbDeviceAttachedActivities::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbDeviceAttachedActivities)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbDeviceAttachedActivities* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbDeviceAttachedActivities>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbDeviceAttachedActivities)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbDeviceAttachedActivities)
    MergeFrom(*source);
  }
}

void UsbDeviceAttachedActivities::MergeFrom(const UsbDeviceAttachedActivities& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbDeviceAttachedActivities)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  filters_.MergeFrom(from.filters_);
  if (from.has_activity()) {
    mutable_activity()->::android::content::ComponentNameProto::MergeFrom(from.activity());
  }
}

void UsbDeviceAttachedActivities::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbDeviceAttachedActivities)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbDeviceAttachedActivities::CopyFrom(const UsbDeviceAttachedActivities& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbDeviceAttachedActivities)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbDeviceAttachedActivities::IsInitialized() const {
  return true;
}

void UsbDeviceAttachedActivities::InternalSwap(UsbDeviceAttachedActivities* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&filters_)->InternalSwap(CastToBase(&other->filters_));
  swap(activity_, other->activity_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbDeviceAttachedActivities::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsbAccessoryAttachedActivities::InitAsDefaultInstance() {
  ::android::service::usb::_UsbAccessoryAttachedActivities_default_instance_._instance.get_mutable()->activity_ = const_cast< ::android::content::ComponentNameProto*>(
      ::android::content::ComponentNameProto::internal_default_instance());
}
class UsbAccessoryAttachedActivities::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbAccessoryAttachedActivities>()._has_bits_);
  static const ::android::content::ComponentNameProto& activity(const UsbAccessoryAttachedActivities* msg);
  static void set_has_activity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::android::content::ComponentNameProto&
UsbAccessoryAttachedActivities::_Internal::activity(const UsbAccessoryAttachedActivities* msg) {
  return *msg->activity_;
}
void UsbAccessoryAttachedActivities::clear_activity() {
  if (activity_ != nullptr) activity_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
UsbAccessoryAttachedActivities::UsbAccessoryAttachedActivities()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:android.service.usb.UsbAccessoryAttachedActivities)
}
UsbAccessoryAttachedActivities::UsbAccessoryAttachedActivities(const UsbAccessoryAttachedActivities& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      filters_(from.filters_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_activity()) {
    activity_ = new ::android::content::ComponentNameProto(*from.activity_);
  } else {
    activity_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:android.service.usb.UsbAccessoryAttachedActivities)
}

void UsbAccessoryAttachedActivities::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsbAccessoryAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  activity_ = nullptr;
}

UsbAccessoryAttachedActivities::~UsbAccessoryAttachedActivities() {
  // @@protoc_insertion_point(destructor:android.service.usb.UsbAccessoryAttachedActivities)
  SharedDtor();
}

void UsbAccessoryAttachedActivities::SharedDtor() {
  if (this != internal_default_instance()) delete activity_;
}

void UsbAccessoryAttachedActivities::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsbAccessoryAttachedActivities& UsbAccessoryAttachedActivities::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsbAccessoryAttachedActivities_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.base);
  return *internal_default_instance();
}


void UsbAccessoryAttachedActivities::Clear() {
// @@protoc_insertion_point(message_clear_start:android.service.usb.UsbAccessoryAttachedActivities)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  filters_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(activity_ != nullptr);
    activity_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsbAccessoryAttachedActivities::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .android.content.ComponentNameProto activity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_activity(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .android.service.usb.UsbAccessoryFilterProto filters = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_filters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsbAccessoryAttachedActivities::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:android.service.usb.UsbAccessoryAttachedActivities)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .android.content.ComponentNameProto activity = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_activity()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .android.service.usb.UsbAccessoryFilterProto filters = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_filters()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:android.service.usb.UsbAccessoryAttachedActivities)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:android.service.usb.UsbAccessoryAttachedActivities)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsbAccessoryAttachedActivities::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:android.service.usb.UsbAccessoryAttachedActivities)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.content.ComponentNameProto activity = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, _Internal::activity(this), output);
  }

  // repeated .android.service.usb.UsbAccessoryFilterProto filters = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->filters_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->filters(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:android.service.usb.UsbAccessoryAttachedActivities)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsbAccessoryAttachedActivities::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:android.service.usb.UsbAccessoryAttachedActivities)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .android.content.ComponentNameProto activity = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::activity(this), target);
  }

  // repeated .android.service.usb.UsbAccessoryFilterProto filters = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->filters_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->filters(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:android.service.usb.UsbAccessoryAttachedActivities)
  return target;
}

size_t UsbAccessoryAttachedActivities::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:android.service.usb.UsbAccessoryAttachedActivities)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .android.service.usb.UsbAccessoryFilterProto filters = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->filters_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->filters(static_cast<int>(i)));
    }
  }

  // optional .android.content.ComponentNameProto activity = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *activity_);
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbAccessoryAttachedActivities::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:android.service.usb.UsbAccessoryAttachedActivities)
  GOOGLE_DCHECK_NE(&from, this);
  const UsbAccessoryAttachedActivities* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsbAccessoryAttachedActivities>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:android.service.usb.UsbAccessoryAttachedActivities)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:android.service.usb.UsbAccessoryAttachedActivities)
    MergeFrom(*source);
  }
}

void UsbAccessoryAttachedActivities::MergeFrom(const UsbAccessoryAttachedActivities& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:android.service.usb.UsbAccessoryAttachedActivities)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  filters_.MergeFrom(from.filters_);
  if (from.has_activity()) {
    mutable_activity()->::android::content::ComponentNameProto::MergeFrom(from.activity());
  }
}

void UsbAccessoryAttachedActivities::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:android.service.usb.UsbAccessoryAttachedActivities)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsbAccessoryAttachedActivities::CopyFrom(const UsbAccessoryAttachedActivities& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:android.service.usb.UsbAccessoryAttachedActivities)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbAccessoryAttachedActivities::IsInitialized() const {
  return true;
}

void UsbAccessoryAttachedActivities::InternalSwap(UsbAccessoryAttachedActivities* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&filters_)->InternalSwap(CastToBase(&other->filters_));
  swap(activity_, other->activity_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsbAccessoryAttachedActivities::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace usb
}  // namespace service
}  // namespace android
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbServiceDumpProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbServiceDumpProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbServiceDumpProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbDeviceManagerProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbDeviceManagerProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbDeviceManagerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbHandlerProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbHandlerProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbHandlerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbAccessoryProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbAccessoryProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbAccessoryProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbDebuggingManagerProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbDebuggingManagerProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbDebuggingManagerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbHostManagerProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbHostManagerProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbHostManagerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbDeviceProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbDeviceProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbDeviceProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbConfigurationProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbConfigurationProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbConfigurationProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbInterfaceProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbInterfaceProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbInterfaceProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbEndPointProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbEndPointProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbEndPointProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbConnectionRecordProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbConnectionRecordProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbConnectionRecordProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbIsHeadsetProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbIsHeadsetProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbIsHeadsetProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbPortManagerProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbPortManagerProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbPortManagerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbPortInfoProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbPortInfoProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbPortInfoProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbPortProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbPortProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbPortProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbPortStatusProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbPortStatusProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbPortStatusProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbPortStatusRoleCombinationProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbPortStatusRoleCombinationProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbPortStatusRoleCombinationProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbAlsaManagerProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbAlsaManagerProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbAlsaManagerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbAlsaDeviceProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbAlsaDeviceProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbAlsaDeviceProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbMidiDeviceProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbMidiDeviceProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbMidiDeviceProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbSettingsManagerProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbSettingsManagerProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbSettingsManagerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbUserSettingsManagerProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbUserSettingsManagerProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbUserSettingsManagerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbProfileGroupSettingsManagerProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbProfileGroupSettingsManagerProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbProfileGroupSettingsManagerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbSettingsDevicePreferenceProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbSettingsDevicePreferenceProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbSettingsDevicePreferenceProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbPermissionsManagerProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbPermissionsManagerProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbPermissionsManagerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbUserPermissionsManagerProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbUserPermissionsManagerProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbUserPermissionsManagerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbDevicePermissionProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbDevicePermissionProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbDevicePermissionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbAccessoryPermissionProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbAccessoryPermissionProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbAccessoryPermissionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbDevicePersistentPermissionProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbDevicePersistentPermissionProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbDevicePersistentPermissionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbAccessoryPersistentPermissionProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbAccessoryPersistentPermissionProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbAccessoryPersistentPermissionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbUidPermissionProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbUidPermissionProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbUidPermissionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbDeviceFilterProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbDeviceFilterProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbDeviceFilterProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UserPackageProto* Arena::CreateMaybeMessage< ::android::service::usb::UserPackageProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UserPackageProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbSettingsAccessoryPreferenceProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbSettingsAccessoryPreferenceProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbSettingsAccessoryPreferenceProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbAccessoryFilterProto* Arena::CreateMaybeMessage< ::android::service::usb::UsbAccessoryFilterProto >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbAccessoryFilterProto >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbDeviceAttachedActivities* Arena::CreateMaybeMessage< ::android::service::usb::UsbDeviceAttachedActivities >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbDeviceAttachedActivities >(arena);
}
template<> PROTOBUF_NOINLINE ::android::service::usb::UsbAccessoryAttachedActivities* Arena::CreateMaybeMessage< ::android::service::usb::UsbAccessoryAttachedActivities >(Arena* arena) {
  return Arena::CreateInternal< ::android::service::usb::UsbAccessoryAttachedActivities >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
