// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/stats/connectivity/tethering.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fconnectivity_2ftethering_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fconnectivity_2ftethering_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fconnectivity_2ftethering_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fconnectivity_2ftethering_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fconnectivity_2ftethering_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace android {
namespace stats {
namespace connectivity {

enum ErrorCode : int {
  EC_NO_ERROR = 0,
  EC_UNKNOWN_IFACE = 1,
  EC_SERVICE_UNAVAIL = 2,
  EC_UNSUPPORTED = 3,
  EC_UNAVAIL_IFACE = 4,
  EC_INTERNAL_ERROR = 5,
  EC_TETHER_IFACE_ERROR = 6,
  EC_UNTETHER_IFACE_ERROR = 7,
  EC_ENABLE_FORWARDING_ERROR = 8,
  EC_DISABLE_FORWARDING_ERROR = 9,
  EC_IFACE_CFG_ERROR = 10,
  EC_PROVISIONING_FAILED = 11,
  EC_DHCPSERVER_ERROR = 12,
  EC_ENTITLEMENT_UNKNOWN = 13,
  EC_NO_CHANGE_TETHERING_PERMISSION = 14,
  EC_NO_ACCESS_TETHERING_PERMISSION = 15,
  EC_UNKNOWN_TYPE = 16
};
bool ErrorCode_IsValid(int value);
constexpr ErrorCode ErrorCode_MIN = EC_NO_ERROR;
constexpr ErrorCode ErrorCode_MAX = EC_UNKNOWN_TYPE;
constexpr int ErrorCode_ARRAYSIZE = ErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ErrorCode_descriptor();
template<typename T>
inline const std::string& ErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ErrorCode_descriptor(), enum_t_value);
}
inline bool ErrorCode_Parse(
    const std::string& name, ErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ErrorCode>(
    ErrorCode_descriptor(), name, value);
}
enum DownstreamType : int {
  DS_UNSPECIFIED = 0,
  DS_TETHERING_WIFI = 1,
  DS_TETHERING_USB = 2,
  DS_TETHERING_BLUETOOTH = 3,
  DS_TETHERING_WIFI_P2P = 4,
  DS_TETHERING_NCM = 5,
  DS_TETHERING_ETHERNET = 6
};
bool DownstreamType_IsValid(int value);
constexpr DownstreamType DownstreamType_MIN = DS_UNSPECIFIED;
constexpr DownstreamType DownstreamType_MAX = DS_TETHERING_ETHERNET;
constexpr int DownstreamType_ARRAYSIZE = DownstreamType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DownstreamType_descriptor();
template<typename T>
inline const std::string& DownstreamType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DownstreamType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DownstreamType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DownstreamType_descriptor(), enum_t_value);
}
inline bool DownstreamType_Parse(
    const std::string& name, DownstreamType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DownstreamType>(
    DownstreamType_descriptor(), name, value);
}
enum UpstreamType : int {
  UT_UNKNOWN = 0,
  UT_CELLULAR = 1,
  UT_WIFI = 2,
  UT_BLUETOOTH = 3,
  UT_ETHERNET = 4,
  UT_WIFI_AWARE = 5,
  UT_LOWPAN = 6,
  UT_CELLULAR_VPN = 7,
  UT_WIFI_VPN = 8,
  UT_BLUETOOTH_VPN = 9,
  UT_ETHERNET_VPN = 10,
  UT_WIFI_CELLULAR_VPN = 11,
  UT_TEST = 12,
  UT_DUN_CELLULAR = 13
};
bool UpstreamType_IsValid(int value);
constexpr UpstreamType UpstreamType_MIN = UT_UNKNOWN;
constexpr UpstreamType UpstreamType_MAX = UT_DUN_CELLULAR;
constexpr int UpstreamType_ARRAYSIZE = UpstreamType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UpstreamType_descriptor();
template<typename T>
inline const std::string& UpstreamType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UpstreamType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UpstreamType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UpstreamType_descriptor(), enum_t_value);
}
inline bool UpstreamType_Parse(
    const std::string& name, UpstreamType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UpstreamType>(
    UpstreamType_descriptor(), name, value);
}
enum UserType : int {
  USER_UNKNOWN = 0,
  USER_SETTINGS = 1,
  USER_SYSTEMUI = 2,
  USER_GMS = 3
};
bool UserType_IsValid(int value);
constexpr UserType UserType_MIN = USER_UNKNOWN;
constexpr UserType UserType_MAX = USER_GMS;
constexpr int UserType_ARRAYSIZE = UserType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserType_descriptor();
template<typename T>
inline const std::string& UserType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UserType_descriptor(), enum_t_value);
}
inline bool UserType_Parse(
    const std::string& name, UserType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UserType>(
    UserType_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace connectivity
}  // namespace stats
}  // namespace android

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::android::stats::connectivity::ErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::connectivity::ErrorCode>() {
  return ::android::stats::connectivity::ErrorCode_descriptor();
}
template <> struct is_proto_enum< ::android::stats::connectivity::DownstreamType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::connectivity::DownstreamType>() {
  return ::android::stats::connectivity::DownstreamType_descriptor();
}
template <> struct is_proto_enum< ::android::stats::connectivity::UpstreamType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::connectivity::UpstreamType>() {
  return ::android::stats::connectivity::UpstreamType_descriptor();
}
template <> struct is_proto_enum< ::android::stats::connectivity::UserType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::stats::connectivity::UserType>() {
  return ::android::stats::connectivity::UserType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fstats_2fconnectivity_2ftethering_2eproto
