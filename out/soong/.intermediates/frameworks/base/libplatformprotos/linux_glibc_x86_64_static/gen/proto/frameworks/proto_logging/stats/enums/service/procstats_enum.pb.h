// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/service/procstats_enum.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fservice_2fprocstats_5fenum_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fservice_2fprocstats_5fenum_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_frameworks_2fproto_5flogging_2fstats_2fenums_2fservice_2fprocstats_5fenum_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_frameworks_2fproto_5flogging_2fstats_2fenums_2fservice_2fprocstats_5fenum_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_frameworks_2fproto_5flogging_2fstats_2fenums_2fservice_2fprocstats_5fenum_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace android {
namespace service {
namespace procstats {

enum ScreenState : int {
  SCREEN_STATE_UNKNOWN = 0,
  SCREEN_STATE_OFF = 1,
  SCREEN_STATE_ON = 2
};
bool ScreenState_IsValid(int value);
constexpr ScreenState ScreenState_MIN = SCREEN_STATE_UNKNOWN;
constexpr ScreenState ScreenState_MAX = SCREEN_STATE_ON;
constexpr int ScreenState_ARRAYSIZE = ScreenState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ScreenState_descriptor();
template<typename T>
inline const std::string& ScreenState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ScreenState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ScreenState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ScreenState_descriptor(), enum_t_value);
}
inline bool ScreenState_Parse(
    const std::string& name, ScreenState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ScreenState>(
    ScreenState_descriptor(), name, value);
}
enum MemoryState : int {
  MEMORY_STATE_UNKNOWN = 0,
  MEMORY_STATE_NORMAL = 1,
  MEMORY_STATE_MODERATE = 2,
  MEMORY_STATE_LOW = 3,
  MEMORY_STATE_CRITICAL = 4
};
bool MemoryState_IsValid(int value);
constexpr MemoryState MemoryState_MIN = MEMORY_STATE_UNKNOWN;
constexpr MemoryState MemoryState_MAX = MEMORY_STATE_CRITICAL;
constexpr int MemoryState_ARRAYSIZE = MemoryState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MemoryState_descriptor();
template<typename T>
inline const std::string& MemoryState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MemoryState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MemoryState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MemoryState_descriptor(), enum_t_value);
}
inline bool MemoryState_Parse(
    const std::string& name, MemoryState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MemoryState>(
    MemoryState_descriptor(), name, value);
}
enum ProcessState : int {
  PROCESS_STATE_UNKNOWN = 0,
  PROCESS_STATE_PERSISTENT = 1,
  PROCESS_STATE_TOP = 2,
  PROCESS_STATE_BOUND_TOP_OR_FGS = 15,
  PROCESS_STATE_FGS = 16,
  PROCESS_STATE_IMPORTANT_FOREGROUND = 3,
  PROCESS_STATE_IMPORTANT_BACKGROUND = 4,
  PROCESS_STATE_BACKUP = 5,
  PROCESS_STATE_SERVICE = 6,
  PROCESS_STATE_SERVICE_RESTARTING = 7,
  PROCESS_STATE_RECEIVER = 8,
  PROCESS_STATE_HEAVY_WEIGHT = 9,
  PROCESS_STATE_HOME = 10,
  PROCESS_STATE_LAST_ACTIVITY = 11,
  PROCESS_STATE_CACHED_ACTIVITY = 12,
  PROCESS_STATE_CACHED_ACTIVITY_CLIENT = 13,
  PROCESS_STATE_CACHED_EMPTY = 14
};
bool ProcessState_IsValid(int value);
constexpr ProcessState ProcessState_MIN = PROCESS_STATE_UNKNOWN;
constexpr ProcessState ProcessState_MAX = PROCESS_STATE_FGS;
constexpr int ProcessState_ARRAYSIZE = ProcessState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProcessState_descriptor();
template<typename T>
inline const std::string& ProcessState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProcessState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProcessState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProcessState_descriptor(), enum_t_value);
}
inline bool ProcessState_Parse(
    const std::string& name, ProcessState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProcessState>(
    ProcessState_descriptor(), name, value);
}
enum ServiceOperationState : int {
  SERVICE_OPERATION_STATE_UNKNOWN = 0,
  SERVICE_OPERATION_STATE_RUNNING = 1,
  SERVICE_OPERATION_STATE_STARTED = 2,
  SERVICE_OPERATION_STATE_FOREGROUND = 3,
  SERVICE_OPERATION_STATE_BOUND = 4,
  SERVICE_OPERATION_STATE_EXECUTING = 5
};
bool ServiceOperationState_IsValid(int value);
constexpr ServiceOperationState ServiceOperationState_MIN = SERVICE_OPERATION_STATE_UNKNOWN;
constexpr ServiceOperationState ServiceOperationState_MAX = SERVICE_OPERATION_STATE_EXECUTING;
constexpr int ServiceOperationState_ARRAYSIZE = ServiceOperationState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServiceOperationState_descriptor();
template<typename T>
inline const std::string& ServiceOperationState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServiceOperationState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServiceOperationState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ServiceOperationState_descriptor(), enum_t_value);
}
inline bool ServiceOperationState_Parse(
    const std::string& name, ServiceOperationState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ServiceOperationState>(
    ServiceOperationState_descriptor(), name, value);
}
enum AggregatedProcessState : int {
  AGGREGATED_PROCESS_STATE_UNKNOWN = 0,
  AGGREGATED_PROCESS_STATE_PERSISTENT = 1,
  AGGREGATED_PROCESS_STATE_TOP = 2,
  AGGREGATED_PROCESS_STATE_BOUND_TOP_OR_FGS = 3,
  AGGREGATED_PROCESS_STATE_FGS = 4,
  AGGREGATED_PROCESS_STATE_IMPORTANT_FOREGROUND = 5,
  AGGREGATED_PROCESS_STATE_BACKGROUND = 6,
  AGGREGATED_PROCESS_STATE_RECEIVER = 7,
  AGGREGATED_PROCESS_STATE_CACHED = 8
};
bool AggregatedProcessState_IsValid(int value);
constexpr AggregatedProcessState AggregatedProcessState_MIN = AGGREGATED_PROCESS_STATE_UNKNOWN;
constexpr AggregatedProcessState AggregatedProcessState_MAX = AGGREGATED_PROCESS_STATE_CACHED;
constexpr int AggregatedProcessState_ARRAYSIZE = AggregatedProcessState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AggregatedProcessState_descriptor();
template<typename T>
inline const std::string& AggregatedProcessState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AggregatedProcessState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AggregatedProcessState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AggregatedProcessState_descriptor(), enum_t_value);
}
inline bool AggregatedProcessState_Parse(
    const std::string& name, AggregatedProcessState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AggregatedProcessState>(
    AggregatedProcessState_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace procstats
}  // namespace service
}  // namespace android

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::android::service::procstats::ScreenState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::service::procstats::ScreenState>() {
  return ::android::service::procstats::ScreenState_descriptor();
}
template <> struct is_proto_enum< ::android::service::procstats::MemoryState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::service::procstats::MemoryState>() {
  return ::android::service::procstats::MemoryState_descriptor();
}
template <> struct is_proto_enum< ::android::service::procstats::ProcessState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::service::procstats::ProcessState>() {
  return ::android::service::procstats::ProcessState_descriptor();
}
template <> struct is_proto_enum< ::android::service::procstats::ServiceOperationState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::service::procstats::ServiceOperationState>() {
  return ::android::service::procstats::ServiceOperationState_descriptor();
}
template <> struct is_proto_enum< ::android::service::procstats::AggregatedProcessState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::service::procstats::AggregatedProcessState>() {
  return ::android::service::procstats::AggregatedProcessState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fservice_2fprocstats_5fenum_2eproto
