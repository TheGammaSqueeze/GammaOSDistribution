// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/base/core/proto/android/service/usb.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "frameworks/base/core/proto/android/content/component_name.pb.h"
#include "frameworks/base/core/proto/android/privacy.pb.h"
#include "frameworks/proto_logging/stats/enums/service/enums.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[37]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
namespace android {
namespace service {
namespace usb {
class UsbAccessoryAttachedActivities;
class UsbAccessoryAttachedActivitiesDefaultTypeInternal;
extern UsbAccessoryAttachedActivitiesDefaultTypeInternal _UsbAccessoryAttachedActivities_default_instance_;
class UsbAccessoryFilterProto;
class UsbAccessoryFilterProtoDefaultTypeInternal;
extern UsbAccessoryFilterProtoDefaultTypeInternal _UsbAccessoryFilterProto_default_instance_;
class UsbAccessoryPermissionProto;
class UsbAccessoryPermissionProtoDefaultTypeInternal;
extern UsbAccessoryPermissionProtoDefaultTypeInternal _UsbAccessoryPermissionProto_default_instance_;
class UsbAccessoryPersistentPermissionProto;
class UsbAccessoryPersistentPermissionProtoDefaultTypeInternal;
extern UsbAccessoryPersistentPermissionProtoDefaultTypeInternal _UsbAccessoryPersistentPermissionProto_default_instance_;
class UsbAccessoryProto;
class UsbAccessoryProtoDefaultTypeInternal;
extern UsbAccessoryProtoDefaultTypeInternal _UsbAccessoryProto_default_instance_;
class UsbAlsaDeviceProto;
class UsbAlsaDeviceProtoDefaultTypeInternal;
extern UsbAlsaDeviceProtoDefaultTypeInternal _UsbAlsaDeviceProto_default_instance_;
class UsbAlsaManagerProto;
class UsbAlsaManagerProtoDefaultTypeInternal;
extern UsbAlsaManagerProtoDefaultTypeInternal _UsbAlsaManagerProto_default_instance_;
class UsbConfigurationProto;
class UsbConfigurationProtoDefaultTypeInternal;
extern UsbConfigurationProtoDefaultTypeInternal _UsbConfigurationProto_default_instance_;
class UsbConnectionRecordProto;
class UsbConnectionRecordProtoDefaultTypeInternal;
extern UsbConnectionRecordProtoDefaultTypeInternal _UsbConnectionRecordProto_default_instance_;
class UsbDebuggingManagerProto;
class UsbDebuggingManagerProtoDefaultTypeInternal;
extern UsbDebuggingManagerProtoDefaultTypeInternal _UsbDebuggingManagerProto_default_instance_;
class UsbDeviceAttachedActivities;
class UsbDeviceAttachedActivitiesDefaultTypeInternal;
extern UsbDeviceAttachedActivitiesDefaultTypeInternal _UsbDeviceAttachedActivities_default_instance_;
class UsbDeviceFilterProto;
class UsbDeviceFilterProtoDefaultTypeInternal;
extern UsbDeviceFilterProtoDefaultTypeInternal _UsbDeviceFilterProto_default_instance_;
class UsbDeviceManagerProto;
class UsbDeviceManagerProtoDefaultTypeInternal;
extern UsbDeviceManagerProtoDefaultTypeInternal _UsbDeviceManagerProto_default_instance_;
class UsbDevicePermissionProto;
class UsbDevicePermissionProtoDefaultTypeInternal;
extern UsbDevicePermissionProtoDefaultTypeInternal _UsbDevicePermissionProto_default_instance_;
class UsbDevicePersistentPermissionProto;
class UsbDevicePersistentPermissionProtoDefaultTypeInternal;
extern UsbDevicePersistentPermissionProtoDefaultTypeInternal _UsbDevicePersistentPermissionProto_default_instance_;
class UsbDeviceProto;
class UsbDeviceProtoDefaultTypeInternal;
extern UsbDeviceProtoDefaultTypeInternal _UsbDeviceProto_default_instance_;
class UsbEndPointProto;
class UsbEndPointProtoDefaultTypeInternal;
extern UsbEndPointProtoDefaultTypeInternal _UsbEndPointProto_default_instance_;
class UsbHandlerProto;
class UsbHandlerProtoDefaultTypeInternal;
extern UsbHandlerProtoDefaultTypeInternal _UsbHandlerProto_default_instance_;
class UsbHostManagerProto;
class UsbHostManagerProtoDefaultTypeInternal;
extern UsbHostManagerProtoDefaultTypeInternal _UsbHostManagerProto_default_instance_;
class UsbInterfaceProto;
class UsbInterfaceProtoDefaultTypeInternal;
extern UsbInterfaceProtoDefaultTypeInternal _UsbInterfaceProto_default_instance_;
class UsbIsHeadsetProto;
class UsbIsHeadsetProtoDefaultTypeInternal;
extern UsbIsHeadsetProtoDefaultTypeInternal _UsbIsHeadsetProto_default_instance_;
class UsbMidiDeviceProto;
class UsbMidiDeviceProtoDefaultTypeInternal;
extern UsbMidiDeviceProtoDefaultTypeInternal _UsbMidiDeviceProto_default_instance_;
class UsbPermissionsManagerProto;
class UsbPermissionsManagerProtoDefaultTypeInternal;
extern UsbPermissionsManagerProtoDefaultTypeInternal _UsbPermissionsManagerProto_default_instance_;
class UsbPortInfoProto;
class UsbPortInfoProtoDefaultTypeInternal;
extern UsbPortInfoProtoDefaultTypeInternal _UsbPortInfoProto_default_instance_;
class UsbPortManagerProto;
class UsbPortManagerProtoDefaultTypeInternal;
extern UsbPortManagerProtoDefaultTypeInternal _UsbPortManagerProto_default_instance_;
class UsbPortProto;
class UsbPortProtoDefaultTypeInternal;
extern UsbPortProtoDefaultTypeInternal _UsbPortProto_default_instance_;
class UsbPortStatusProto;
class UsbPortStatusProtoDefaultTypeInternal;
extern UsbPortStatusProtoDefaultTypeInternal _UsbPortStatusProto_default_instance_;
class UsbPortStatusRoleCombinationProto;
class UsbPortStatusRoleCombinationProtoDefaultTypeInternal;
extern UsbPortStatusRoleCombinationProtoDefaultTypeInternal _UsbPortStatusRoleCombinationProto_default_instance_;
class UsbProfileGroupSettingsManagerProto;
class UsbProfileGroupSettingsManagerProtoDefaultTypeInternal;
extern UsbProfileGroupSettingsManagerProtoDefaultTypeInternal _UsbProfileGroupSettingsManagerProto_default_instance_;
class UsbServiceDumpProto;
class UsbServiceDumpProtoDefaultTypeInternal;
extern UsbServiceDumpProtoDefaultTypeInternal _UsbServiceDumpProto_default_instance_;
class UsbSettingsAccessoryPreferenceProto;
class UsbSettingsAccessoryPreferenceProtoDefaultTypeInternal;
extern UsbSettingsAccessoryPreferenceProtoDefaultTypeInternal _UsbSettingsAccessoryPreferenceProto_default_instance_;
class UsbSettingsDevicePreferenceProto;
class UsbSettingsDevicePreferenceProtoDefaultTypeInternal;
extern UsbSettingsDevicePreferenceProtoDefaultTypeInternal _UsbSettingsDevicePreferenceProto_default_instance_;
class UsbSettingsManagerProto;
class UsbSettingsManagerProtoDefaultTypeInternal;
extern UsbSettingsManagerProtoDefaultTypeInternal _UsbSettingsManagerProto_default_instance_;
class UsbUidPermissionProto;
class UsbUidPermissionProtoDefaultTypeInternal;
extern UsbUidPermissionProtoDefaultTypeInternal _UsbUidPermissionProto_default_instance_;
class UsbUserPermissionsManagerProto;
class UsbUserPermissionsManagerProtoDefaultTypeInternal;
extern UsbUserPermissionsManagerProtoDefaultTypeInternal _UsbUserPermissionsManagerProto_default_instance_;
class UsbUserSettingsManagerProto;
class UsbUserSettingsManagerProtoDefaultTypeInternal;
extern UsbUserSettingsManagerProtoDefaultTypeInternal _UsbUserSettingsManagerProto_default_instance_;
class UserPackageProto;
class UserPackageProtoDefaultTypeInternal;
extern UserPackageProtoDefaultTypeInternal _UserPackageProto_default_instance_;
}  // namespace usb
}  // namespace service
}  // namespace android
PROTOBUF_NAMESPACE_OPEN
template<> ::android::service::usb::UsbAccessoryAttachedActivities* Arena::CreateMaybeMessage<::android::service::usb::UsbAccessoryAttachedActivities>(Arena*);
template<> ::android::service::usb::UsbAccessoryFilterProto* Arena::CreateMaybeMessage<::android::service::usb::UsbAccessoryFilterProto>(Arena*);
template<> ::android::service::usb::UsbAccessoryPermissionProto* Arena::CreateMaybeMessage<::android::service::usb::UsbAccessoryPermissionProto>(Arena*);
template<> ::android::service::usb::UsbAccessoryPersistentPermissionProto* Arena::CreateMaybeMessage<::android::service::usb::UsbAccessoryPersistentPermissionProto>(Arena*);
template<> ::android::service::usb::UsbAccessoryProto* Arena::CreateMaybeMessage<::android::service::usb::UsbAccessoryProto>(Arena*);
template<> ::android::service::usb::UsbAlsaDeviceProto* Arena::CreateMaybeMessage<::android::service::usb::UsbAlsaDeviceProto>(Arena*);
template<> ::android::service::usb::UsbAlsaManagerProto* Arena::CreateMaybeMessage<::android::service::usb::UsbAlsaManagerProto>(Arena*);
template<> ::android::service::usb::UsbConfigurationProto* Arena::CreateMaybeMessage<::android::service::usb::UsbConfigurationProto>(Arena*);
template<> ::android::service::usb::UsbConnectionRecordProto* Arena::CreateMaybeMessage<::android::service::usb::UsbConnectionRecordProto>(Arena*);
template<> ::android::service::usb::UsbDebuggingManagerProto* Arena::CreateMaybeMessage<::android::service::usb::UsbDebuggingManagerProto>(Arena*);
template<> ::android::service::usb::UsbDeviceAttachedActivities* Arena::CreateMaybeMessage<::android::service::usb::UsbDeviceAttachedActivities>(Arena*);
template<> ::android::service::usb::UsbDeviceFilterProto* Arena::CreateMaybeMessage<::android::service::usb::UsbDeviceFilterProto>(Arena*);
template<> ::android::service::usb::UsbDeviceManagerProto* Arena::CreateMaybeMessage<::android::service::usb::UsbDeviceManagerProto>(Arena*);
template<> ::android::service::usb::UsbDevicePermissionProto* Arena::CreateMaybeMessage<::android::service::usb::UsbDevicePermissionProto>(Arena*);
template<> ::android::service::usb::UsbDevicePersistentPermissionProto* Arena::CreateMaybeMessage<::android::service::usb::UsbDevicePersistentPermissionProto>(Arena*);
template<> ::android::service::usb::UsbDeviceProto* Arena::CreateMaybeMessage<::android::service::usb::UsbDeviceProto>(Arena*);
template<> ::android::service::usb::UsbEndPointProto* Arena::CreateMaybeMessage<::android::service::usb::UsbEndPointProto>(Arena*);
template<> ::android::service::usb::UsbHandlerProto* Arena::CreateMaybeMessage<::android::service::usb::UsbHandlerProto>(Arena*);
template<> ::android::service::usb::UsbHostManagerProto* Arena::CreateMaybeMessage<::android::service::usb::UsbHostManagerProto>(Arena*);
template<> ::android::service::usb::UsbInterfaceProto* Arena::CreateMaybeMessage<::android::service::usb::UsbInterfaceProto>(Arena*);
template<> ::android::service::usb::UsbIsHeadsetProto* Arena::CreateMaybeMessage<::android::service::usb::UsbIsHeadsetProto>(Arena*);
template<> ::android::service::usb::UsbMidiDeviceProto* Arena::CreateMaybeMessage<::android::service::usb::UsbMidiDeviceProto>(Arena*);
template<> ::android::service::usb::UsbPermissionsManagerProto* Arena::CreateMaybeMessage<::android::service::usb::UsbPermissionsManagerProto>(Arena*);
template<> ::android::service::usb::UsbPortInfoProto* Arena::CreateMaybeMessage<::android::service::usb::UsbPortInfoProto>(Arena*);
template<> ::android::service::usb::UsbPortManagerProto* Arena::CreateMaybeMessage<::android::service::usb::UsbPortManagerProto>(Arena*);
template<> ::android::service::usb::UsbPortProto* Arena::CreateMaybeMessage<::android::service::usb::UsbPortProto>(Arena*);
template<> ::android::service::usb::UsbPortStatusProto* Arena::CreateMaybeMessage<::android::service::usb::UsbPortStatusProto>(Arena*);
template<> ::android::service::usb::UsbPortStatusRoleCombinationProto* Arena::CreateMaybeMessage<::android::service::usb::UsbPortStatusRoleCombinationProto>(Arena*);
template<> ::android::service::usb::UsbProfileGroupSettingsManagerProto* Arena::CreateMaybeMessage<::android::service::usb::UsbProfileGroupSettingsManagerProto>(Arena*);
template<> ::android::service::usb::UsbServiceDumpProto* Arena::CreateMaybeMessage<::android::service::usb::UsbServiceDumpProto>(Arena*);
template<> ::android::service::usb::UsbSettingsAccessoryPreferenceProto* Arena::CreateMaybeMessage<::android::service::usb::UsbSettingsAccessoryPreferenceProto>(Arena*);
template<> ::android::service::usb::UsbSettingsDevicePreferenceProto* Arena::CreateMaybeMessage<::android::service::usb::UsbSettingsDevicePreferenceProto>(Arena*);
template<> ::android::service::usb::UsbSettingsManagerProto* Arena::CreateMaybeMessage<::android::service::usb::UsbSettingsManagerProto>(Arena*);
template<> ::android::service::usb::UsbUidPermissionProto* Arena::CreateMaybeMessage<::android::service::usb::UsbUidPermissionProto>(Arena*);
template<> ::android::service::usb::UsbUserPermissionsManagerProto* Arena::CreateMaybeMessage<::android::service::usb::UsbUserPermissionsManagerProto>(Arena*);
template<> ::android::service::usb::UsbUserSettingsManagerProto* Arena::CreateMaybeMessage<::android::service::usb::UsbUserSettingsManagerProto>(Arena*);
template<> ::android::service::usb::UserPackageProto* Arena::CreateMaybeMessage<::android::service::usb::UserPackageProto>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace android {
namespace service {
namespace usb {

enum UsbHandlerProto_Function : int {
  UsbHandlerProto_Function_FUNCTION_ADB = 1,
  UsbHandlerProto_Function_FUNCTION_ACCESSORY = 2,
  UsbHandlerProto_Function_FUNCTION_MTP = 4,
  UsbHandlerProto_Function_FUNCTION_MIDI = 8,
  UsbHandlerProto_Function_FUNCTION_PTP = 16,
  UsbHandlerProto_Function_FUNCTION_RNDIS = 32,
  UsbHandlerProto_Function_FUNCTION_AUDIO_SOURCE = 64
};
bool UsbHandlerProto_Function_IsValid(int value);
constexpr UsbHandlerProto_Function UsbHandlerProto_Function_Function_MIN = UsbHandlerProto_Function_FUNCTION_ADB;
constexpr UsbHandlerProto_Function UsbHandlerProto_Function_Function_MAX = UsbHandlerProto_Function_FUNCTION_AUDIO_SOURCE;
constexpr int UsbHandlerProto_Function_Function_ARRAYSIZE = UsbHandlerProto_Function_Function_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UsbHandlerProto_Function_descriptor();
template<typename T>
inline const std::string& UsbHandlerProto_Function_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UsbHandlerProto_Function>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UsbHandlerProto_Function_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UsbHandlerProto_Function_descriptor(), enum_t_value);
}
inline bool UsbHandlerProto_Function_Parse(
    const std::string& name, UsbHandlerProto_Function* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UsbHandlerProto_Function>(
    UsbHandlerProto_Function_descriptor(), name, value);
}
enum UsbPortProto_Mode : int {
  UsbPortProto_Mode_MODE_NONE = 0,
  UsbPortProto_Mode_MODE_UFP = 1,
  UsbPortProto_Mode_MODE_DFP = 2,
  UsbPortProto_Mode_MODE_DRP = 3,
  UsbPortProto_Mode_MODE_AUDIO_ACCESSORY = 4,
  UsbPortProto_Mode_MODE_DEBUG_ACCESSORY = 8
};
bool UsbPortProto_Mode_IsValid(int value);
constexpr UsbPortProto_Mode UsbPortProto_Mode_Mode_MIN = UsbPortProto_Mode_MODE_NONE;
constexpr UsbPortProto_Mode UsbPortProto_Mode_Mode_MAX = UsbPortProto_Mode_MODE_DEBUG_ACCESSORY;
constexpr int UsbPortProto_Mode_Mode_ARRAYSIZE = UsbPortProto_Mode_Mode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UsbPortProto_Mode_descriptor();
template<typename T>
inline const std::string& UsbPortProto_Mode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UsbPortProto_Mode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UsbPortProto_Mode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UsbPortProto_Mode_descriptor(), enum_t_value);
}
inline bool UsbPortProto_Mode_Parse(
    const std::string& name, UsbPortProto_Mode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UsbPortProto_Mode>(
    UsbPortProto_Mode_descriptor(), name, value);
}
enum UsbPortStatusProto_PowerRole : int {
  UsbPortStatusProto_PowerRole_POWER_ROLE_NONE = 0,
  UsbPortStatusProto_PowerRole_POWER_ROLE_SOURCE = 1,
  UsbPortStatusProto_PowerRole_POWER_ROLE_SINK = 2
};
bool UsbPortStatusProto_PowerRole_IsValid(int value);
constexpr UsbPortStatusProto_PowerRole UsbPortStatusProto_PowerRole_PowerRole_MIN = UsbPortStatusProto_PowerRole_POWER_ROLE_NONE;
constexpr UsbPortStatusProto_PowerRole UsbPortStatusProto_PowerRole_PowerRole_MAX = UsbPortStatusProto_PowerRole_POWER_ROLE_SINK;
constexpr int UsbPortStatusProto_PowerRole_PowerRole_ARRAYSIZE = UsbPortStatusProto_PowerRole_PowerRole_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UsbPortStatusProto_PowerRole_descriptor();
template<typename T>
inline const std::string& UsbPortStatusProto_PowerRole_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UsbPortStatusProto_PowerRole>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UsbPortStatusProto_PowerRole_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UsbPortStatusProto_PowerRole_descriptor(), enum_t_value);
}
inline bool UsbPortStatusProto_PowerRole_Parse(
    const std::string& name, UsbPortStatusProto_PowerRole* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UsbPortStatusProto_PowerRole>(
    UsbPortStatusProto_PowerRole_descriptor(), name, value);
}
enum UsbPortStatusProto_DataRole : int {
  UsbPortStatusProto_DataRole_DATA_ROLE_NONE = 0,
  UsbPortStatusProto_DataRole_DATA_ROLE_HOST = 1,
  UsbPortStatusProto_DataRole_DATA_ROLE_DEVICE = 2
};
bool UsbPortStatusProto_DataRole_IsValid(int value);
constexpr UsbPortStatusProto_DataRole UsbPortStatusProto_DataRole_DataRole_MIN = UsbPortStatusProto_DataRole_DATA_ROLE_NONE;
constexpr UsbPortStatusProto_DataRole UsbPortStatusProto_DataRole_DataRole_MAX = UsbPortStatusProto_DataRole_DATA_ROLE_DEVICE;
constexpr int UsbPortStatusProto_DataRole_DataRole_ARRAYSIZE = UsbPortStatusProto_DataRole_DataRole_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UsbPortStatusProto_DataRole_descriptor();
template<typename T>
inline const std::string& UsbPortStatusProto_DataRole_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UsbPortStatusProto_DataRole>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UsbPortStatusProto_DataRole_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UsbPortStatusProto_DataRole_descriptor(), enum_t_value);
}
inline bool UsbPortStatusProto_DataRole_Parse(
    const std::string& name, UsbPortStatusProto_DataRole* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UsbPortStatusProto_DataRole>(
    UsbPortStatusProto_DataRole_descriptor(), name, value);
}
// ===================================================================

class UsbServiceDumpProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbServiceDumpProto) */ {
 public:
  UsbServiceDumpProto();
  virtual ~UsbServiceDumpProto();

  UsbServiceDumpProto(const UsbServiceDumpProto& from);
  UsbServiceDumpProto(UsbServiceDumpProto&& from) noexcept
    : UsbServiceDumpProto() {
    *this = ::std::move(from);
  }

  inline UsbServiceDumpProto& operator=(const UsbServiceDumpProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbServiceDumpProto& operator=(UsbServiceDumpProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbServiceDumpProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbServiceDumpProto* internal_default_instance() {
    return reinterpret_cast<const UsbServiceDumpProto*>(
               &_UsbServiceDumpProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UsbServiceDumpProto& a, UsbServiceDumpProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbServiceDumpProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbServiceDumpProto* New() const final {
    return CreateMaybeMessage<UsbServiceDumpProto>(nullptr);
  }

  UsbServiceDumpProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbServiceDumpProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbServiceDumpProto& from);
  void MergeFrom(const UsbServiceDumpProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbServiceDumpProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbServiceDumpProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceManagerFieldNumber = 1,
    kHostManagerFieldNumber = 2,
    kPortManagerFieldNumber = 3,
    kAlsaManagerFieldNumber = 4,
    kSettingsManagerFieldNumber = 5,
    kPermissionsManagerFieldNumber = 6,
  };
  // optional .android.service.usb.UsbDeviceManagerProto device_manager = 1;
  bool has_device_manager() const;
  void clear_device_manager();
  const ::android::service::usb::UsbDeviceManagerProto& device_manager() const;
  ::android::service::usb::UsbDeviceManagerProto* release_device_manager();
  ::android::service::usb::UsbDeviceManagerProto* mutable_device_manager();
  void set_allocated_device_manager(::android::service::usb::UsbDeviceManagerProto* device_manager);

  // optional .android.service.usb.UsbHostManagerProto host_manager = 2;
  bool has_host_manager() const;
  void clear_host_manager();
  const ::android::service::usb::UsbHostManagerProto& host_manager() const;
  ::android::service::usb::UsbHostManagerProto* release_host_manager();
  ::android::service::usb::UsbHostManagerProto* mutable_host_manager();
  void set_allocated_host_manager(::android::service::usb::UsbHostManagerProto* host_manager);

  // optional .android.service.usb.UsbPortManagerProto port_manager = 3;
  bool has_port_manager() const;
  void clear_port_manager();
  const ::android::service::usb::UsbPortManagerProto& port_manager() const;
  ::android::service::usb::UsbPortManagerProto* release_port_manager();
  ::android::service::usb::UsbPortManagerProto* mutable_port_manager();
  void set_allocated_port_manager(::android::service::usb::UsbPortManagerProto* port_manager);

  // optional .android.service.usb.UsbAlsaManagerProto alsa_manager = 4;
  bool has_alsa_manager() const;
  void clear_alsa_manager();
  const ::android::service::usb::UsbAlsaManagerProto& alsa_manager() const;
  ::android::service::usb::UsbAlsaManagerProto* release_alsa_manager();
  ::android::service::usb::UsbAlsaManagerProto* mutable_alsa_manager();
  void set_allocated_alsa_manager(::android::service::usb::UsbAlsaManagerProto* alsa_manager);

  // optional .android.service.usb.UsbSettingsManagerProto settings_manager = 5;
  bool has_settings_manager() const;
  void clear_settings_manager();
  const ::android::service::usb::UsbSettingsManagerProto& settings_manager() const;
  ::android::service::usb::UsbSettingsManagerProto* release_settings_manager();
  ::android::service::usb::UsbSettingsManagerProto* mutable_settings_manager();
  void set_allocated_settings_manager(::android::service::usb::UsbSettingsManagerProto* settings_manager);

  // optional .android.service.usb.UsbPermissionsManagerProto permissions_manager = 6;
  bool has_permissions_manager() const;
  void clear_permissions_manager();
  const ::android::service::usb::UsbPermissionsManagerProto& permissions_manager() const;
  ::android::service::usb::UsbPermissionsManagerProto* release_permissions_manager();
  ::android::service::usb::UsbPermissionsManagerProto* mutable_permissions_manager();
  void set_allocated_permissions_manager(::android::service::usb::UsbPermissionsManagerProto* permissions_manager);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbServiceDumpProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::android::service::usb::UsbDeviceManagerProto* device_manager_;
  ::android::service::usb::UsbHostManagerProto* host_manager_;
  ::android::service::usb::UsbPortManagerProto* port_manager_;
  ::android::service::usb::UsbAlsaManagerProto* alsa_manager_;
  ::android::service::usb::UsbSettingsManagerProto* settings_manager_;
  ::android::service::usb::UsbPermissionsManagerProto* permissions_manager_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbDeviceManagerProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbDeviceManagerProto) */ {
 public:
  UsbDeviceManagerProto();
  virtual ~UsbDeviceManagerProto();

  UsbDeviceManagerProto(const UsbDeviceManagerProto& from);
  UsbDeviceManagerProto(UsbDeviceManagerProto&& from) noexcept
    : UsbDeviceManagerProto() {
    *this = ::std::move(from);
  }

  inline UsbDeviceManagerProto& operator=(const UsbDeviceManagerProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbDeviceManagerProto& operator=(UsbDeviceManagerProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbDeviceManagerProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbDeviceManagerProto* internal_default_instance() {
    return reinterpret_cast<const UsbDeviceManagerProto*>(
               &_UsbDeviceManagerProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UsbDeviceManagerProto& a, UsbDeviceManagerProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbDeviceManagerProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbDeviceManagerProto* New() const final {
    return CreateMaybeMessage<UsbDeviceManagerProto>(nullptr);
  }

  UsbDeviceManagerProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbDeviceManagerProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbDeviceManagerProto& from);
  void MergeFrom(const UsbDeviceManagerProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbDeviceManagerProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbDeviceManagerProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandlerFieldNumber = 1,
    kDebuggingManagerFieldNumber = 2,
  };
  // optional .android.service.usb.UsbHandlerProto handler = 1;
  bool has_handler() const;
  void clear_handler();
  const ::android::service::usb::UsbHandlerProto& handler() const;
  ::android::service::usb::UsbHandlerProto* release_handler();
  ::android::service::usb::UsbHandlerProto* mutable_handler();
  void set_allocated_handler(::android::service::usb::UsbHandlerProto* handler);

  // optional .android.service.usb.UsbDebuggingManagerProto debugging_manager = 2;
  bool has_debugging_manager() const;
  void clear_debugging_manager();
  const ::android::service::usb::UsbDebuggingManagerProto& debugging_manager() const;
  ::android::service::usb::UsbDebuggingManagerProto* release_debugging_manager();
  ::android::service::usb::UsbDebuggingManagerProto* mutable_debugging_manager();
  void set_allocated_debugging_manager(::android::service::usb::UsbDebuggingManagerProto* debugging_manager);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbDeviceManagerProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::android::service::usb::UsbHandlerProto* handler_;
  ::android::service::usb::UsbDebuggingManagerProto* debugging_manager_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbHandlerProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbHandlerProto) */ {
 public:
  UsbHandlerProto();
  virtual ~UsbHandlerProto();

  UsbHandlerProto(const UsbHandlerProto& from);
  UsbHandlerProto(UsbHandlerProto&& from) noexcept
    : UsbHandlerProto() {
    *this = ::std::move(from);
  }

  inline UsbHandlerProto& operator=(const UsbHandlerProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbHandlerProto& operator=(UsbHandlerProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbHandlerProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbHandlerProto* internal_default_instance() {
    return reinterpret_cast<const UsbHandlerProto*>(
               &_UsbHandlerProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UsbHandlerProto& a, UsbHandlerProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbHandlerProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbHandlerProto* New() const final {
    return CreateMaybeMessage<UsbHandlerProto>(nullptr);
  }

  UsbHandlerProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbHandlerProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbHandlerProto& from);
  void MergeFrom(const UsbHandlerProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbHandlerProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbHandlerProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef UsbHandlerProto_Function Function;
  static constexpr Function FUNCTION_ADB =
    UsbHandlerProto_Function_FUNCTION_ADB;
  static constexpr Function FUNCTION_ACCESSORY =
    UsbHandlerProto_Function_FUNCTION_ACCESSORY;
  static constexpr Function FUNCTION_MTP =
    UsbHandlerProto_Function_FUNCTION_MTP;
  static constexpr Function FUNCTION_MIDI =
    UsbHandlerProto_Function_FUNCTION_MIDI;
  static constexpr Function FUNCTION_PTP =
    UsbHandlerProto_Function_FUNCTION_PTP;
  static constexpr Function FUNCTION_RNDIS =
    UsbHandlerProto_Function_FUNCTION_RNDIS;
  static constexpr Function FUNCTION_AUDIO_SOURCE =
    UsbHandlerProto_Function_FUNCTION_AUDIO_SOURCE;
  static inline bool Function_IsValid(int value) {
    return UsbHandlerProto_Function_IsValid(value);
  }
  static constexpr Function Function_MIN =
    UsbHandlerProto_Function_Function_MIN;
  static constexpr Function Function_MAX =
    UsbHandlerProto_Function_Function_MAX;
  static constexpr int Function_ARRAYSIZE =
    UsbHandlerProto_Function_Function_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Function_descriptor() {
    return UsbHandlerProto_Function_descriptor();
  }
  template<typename T>
  static inline const std::string& Function_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Function>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Function_Name.");
    return UsbHandlerProto_Function_Name(enum_t_value);
  }
  static inline bool Function_Parse(const std::string& name,
      Function* value) {
    return UsbHandlerProto_Function_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentFunctionsFieldNumber = 1,
    kScreenUnlockedFunctionsFieldNumber = 3,
    kKernelStateFieldNumber = 15,
    kKernelFunctionListFieldNumber = 16,
    kCurrentAccessoryFieldNumber = 7,
    kCurrentFunctionsAppliedFieldNumber = 2,
    kScreenLockedFieldNumber = 4,
    kConnectedFieldNumber = 5,
    kConfiguredFieldNumber = 6,
    kHostConnectedFieldNumber = 8,
    kSourcePowerFieldNumber = 9,
    kSinkPowerFieldNumber = 10,
    kUsbChargingFieldNumber = 11,
    kHideUsbNotificationFieldNumber = 12,
    kAudioAccessoryConnectedFieldNumber = 13,
    kAdbEnabledFieldNumber = 14,
  };
  // repeated .android.service.usb.UsbHandlerProto.Function current_functions = 1;
  int current_functions_size() const;
  void clear_current_functions();
  ::android::service::usb::UsbHandlerProto_Function current_functions(int index) const;
  void set_current_functions(int index, ::android::service::usb::UsbHandlerProto_Function value);
  void add_current_functions(::android::service::usb::UsbHandlerProto_Function value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& current_functions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_current_functions();

  // repeated .android.service.usb.UsbHandlerProto.Function screen_unlocked_functions = 3;
  int screen_unlocked_functions_size() const;
  void clear_screen_unlocked_functions();
  ::android::service::usb::UsbHandlerProto_Function screen_unlocked_functions(int index) const;
  void set_screen_unlocked_functions(int index, ::android::service::usb::UsbHandlerProto_Function value);
  void add_screen_unlocked_functions(::android::service::usb::UsbHandlerProto_Function value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& screen_unlocked_functions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_screen_unlocked_functions();

  // optional string kernel_state = 15;
  bool has_kernel_state() const;
  void clear_kernel_state();
  const std::string& kernel_state() const;
  void set_kernel_state(const std::string& value);
  void set_kernel_state(std::string&& value);
  void set_kernel_state(const char* value);
  void set_kernel_state(const char* value, size_t size);
  std::string* mutable_kernel_state();
  std::string* release_kernel_state();
  void set_allocated_kernel_state(std::string* kernel_state);

  // optional string kernel_function_list = 16;
  bool has_kernel_function_list() const;
  void clear_kernel_function_list();
  const std::string& kernel_function_list() const;
  void set_kernel_function_list(const std::string& value);
  void set_kernel_function_list(std::string&& value);
  void set_kernel_function_list(const char* value);
  void set_kernel_function_list(const char* value, size_t size);
  std::string* mutable_kernel_function_list();
  std::string* release_kernel_function_list();
  void set_allocated_kernel_function_list(std::string* kernel_function_list);

  // optional .android.service.usb.UsbAccessoryProto current_accessory = 7;
  bool has_current_accessory() const;
  void clear_current_accessory();
  const ::android::service::usb::UsbAccessoryProto& current_accessory() const;
  ::android::service::usb::UsbAccessoryProto* release_current_accessory();
  ::android::service::usb::UsbAccessoryProto* mutable_current_accessory();
  void set_allocated_current_accessory(::android::service::usb::UsbAccessoryProto* current_accessory);

  // optional bool current_functions_applied = 2;
  bool has_current_functions_applied() const;
  void clear_current_functions_applied();
  bool current_functions_applied() const;
  void set_current_functions_applied(bool value);

  // optional bool screen_locked = 4;
  bool has_screen_locked() const;
  void clear_screen_locked();
  bool screen_locked() const;
  void set_screen_locked(bool value);

  // optional bool connected = 5;
  bool has_connected() const;
  void clear_connected();
  bool connected() const;
  void set_connected(bool value);

  // optional bool configured = 6;
  bool has_configured() const;
  void clear_configured();
  bool configured() const;
  void set_configured(bool value);

  // optional bool host_connected = 8;
  bool has_host_connected() const;
  void clear_host_connected();
  bool host_connected() const;
  void set_host_connected(bool value);

  // optional bool source_power = 9;
  bool has_source_power() const;
  void clear_source_power();
  bool source_power() const;
  void set_source_power(bool value);

  // optional bool sink_power = 10;
  bool has_sink_power() const;
  void clear_sink_power();
  bool sink_power() const;
  void set_sink_power(bool value);

  // optional bool usb_charging = 11;
  bool has_usb_charging() const;
  void clear_usb_charging();
  bool usb_charging() const;
  void set_usb_charging(bool value);

  // optional bool hide_usb_notification = 12;
  bool has_hide_usb_notification() const;
  void clear_hide_usb_notification();
  bool hide_usb_notification() const;
  void set_hide_usb_notification(bool value);

  // optional bool audio_accessory_connected = 13;
  bool has_audio_accessory_connected() const;
  void clear_audio_accessory_connected();
  bool audio_accessory_connected() const;
  void set_audio_accessory_connected(bool value);

  // optional bool adb_enabled = 14;
  bool has_adb_enabled() const;
  void clear_adb_enabled();
  bool adb_enabled() const;
  void set_adb_enabled(bool value);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbHandlerProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> current_functions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> screen_unlocked_functions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kernel_state_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kernel_function_list_;
  ::android::service::usb::UsbAccessoryProto* current_accessory_;
  bool current_functions_applied_;
  bool screen_locked_;
  bool connected_;
  bool configured_;
  bool host_connected_;
  bool source_power_;
  bool sink_power_;
  bool usb_charging_;
  bool hide_usb_notification_;
  bool audio_accessory_connected_;
  bool adb_enabled_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbAccessoryProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbAccessoryProto) */ {
 public:
  UsbAccessoryProto();
  virtual ~UsbAccessoryProto();

  UsbAccessoryProto(const UsbAccessoryProto& from);
  UsbAccessoryProto(UsbAccessoryProto&& from) noexcept
    : UsbAccessoryProto() {
    *this = ::std::move(from);
  }

  inline UsbAccessoryProto& operator=(const UsbAccessoryProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbAccessoryProto& operator=(UsbAccessoryProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbAccessoryProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbAccessoryProto* internal_default_instance() {
    return reinterpret_cast<const UsbAccessoryProto*>(
               &_UsbAccessoryProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UsbAccessoryProto& a, UsbAccessoryProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbAccessoryProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbAccessoryProto* New() const final {
    return CreateMaybeMessage<UsbAccessoryProto>(nullptr);
  }

  UsbAccessoryProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbAccessoryProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbAccessoryProto& from);
  void MergeFrom(const UsbAccessoryProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbAccessoryProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbAccessoryProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kManufacturerFieldNumber = 1,
    kModelFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kVersionFieldNumber = 4,
    kUriFieldNumber = 5,
    kSerialFieldNumber = 6,
  };
  // optional string manufacturer = 1;
  bool has_manufacturer() const;
  void clear_manufacturer();
  const std::string& manufacturer() const;
  void set_manufacturer(const std::string& value);
  void set_manufacturer(std::string&& value);
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  std::string* mutable_manufacturer();
  std::string* release_manufacturer();
  void set_allocated_manufacturer(std::string* manufacturer);

  // optional string model = 2;
  bool has_model() const;
  void clear_model();
  const std::string& model() const;
  void set_model(const std::string& value);
  void set_model(std::string&& value);
  void set_model(const char* value);
  void set_model(const char* value, size_t size);
  std::string* mutable_model();
  std::string* release_model();
  void set_allocated_model(std::string* model);

  // optional string description = 3;
  bool has_description() const;
  void clear_description();
  const std::string& description() const;
  void set_description(const std::string& value);
  void set_description(std::string&& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  std::string* mutable_description();
  std::string* release_description();
  void set_allocated_description(std::string* description);

  // optional string version = 4;
  bool has_version() const;
  void clear_version();
  const std::string& version() const;
  void set_version(const std::string& value);
  void set_version(std::string&& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  std::string* mutable_version();
  std::string* release_version();
  void set_allocated_version(std::string* version);

  // optional string uri = 5 [(.android.privacy) = {
  bool has_uri() const;
  void clear_uri();
  const std::string& uri() const;
  void set_uri(const std::string& value);
  void set_uri(std::string&& value);
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  std::string* mutable_uri();
  std::string* release_uri();
  void set_allocated_uri(std::string* uri);

  // optional string serial = 6 [(.android.privacy) = {
  bool has_serial() const;
  void clear_serial();
  const std::string& serial() const;
  void set_serial(const std::string& value);
  void set_serial(std::string&& value);
  void set_serial(const char* value);
  void set_serial(const char* value, size_t size);
  std::string* mutable_serial();
  std::string* release_serial();
  void set_allocated_serial(std::string* serial);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbAccessoryProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacturer_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbDebuggingManagerProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbDebuggingManagerProto) */ {
 public:
  UsbDebuggingManagerProto();
  virtual ~UsbDebuggingManagerProto();

  UsbDebuggingManagerProto(const UsbDebuggingManagerProto& from);
  UsbDebuggingManagerProto(UsbDebuggingManagerProto&& from) noexcept
    : UsbDebuggingManagerProto() {
    *this = ::std::move(from);
  }

  inline UsbDebuggingManagerProto& operator=(const UsbDebuggingManagerProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbDebuggingManagerProto& operator=(UsbDebuggingManagerProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbDebuggingManagerProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbDebuggingManagerProto* internal_default_instance() {
    return reinterpret_cast<const UsbDebuggingManagerProto*>(
               &_UsbDebuggingManagerProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UsbDebuggingManagerProto& a, UsbDebuggingManagerProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbDebuggingManagerProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbDebuggingManagerProto* New() const final {
    return CreateMaybeMessage<UsbDebuggingManagerProto>(nullptr);
  }

  UsbDebuggingManagerProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbDebuggingManagerProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbDebuggingManagerProto& from);
  void MergeFrom(const UsbDebuggingManagerProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbDebuggingManagerProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbDebuggingManagerProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLastKeyReceivedFieldNumber = 2,
    kUserKeysFieldNumber = 3,
    kSystemKeysFieldNumber = 4,
    kConnectedToAdbFieldNumber = 1,
  };
  // optional string last_key_received = 2 [(.android.privacy) = {
  bool has_last_key_received() const;
  void clear_last_key_received();
  const std::string& last_key_received() const;
  void set_last_key_received(const std::string& value);
  void set_last_key_received(std::string&& value);
  void set_last_key_received(const char* value);
  void set_last_key_received(const char* value, size_t size);
  std::string* mutable_last_key_received();
  std::string* release_last_key_received();
  void set_allocated_last_key_received(std::string* last_key_received);

  // optional string user_keys = 3 [(.android.privacy) = {
  bool has_user_keys() const;
  void clear_user_keys();
  const std::string& user_keys() const;
  void set_user_keys(const std::string& value);
  void set_user_keys(std::string&& value);
  void set_user_keys(const char* value);
  void set_user_keys(const char* value, size_t size);
  std::string* mutable_user_keys();
  std::string* release_user_keys();
  void set_allocated_user_keys(std::string* user_keys);

  // optional string system_keys = 4 [(.android.privacy) = {
  bool has_system_keys() const;
  void clear_system_keys();
  const std::string& system_keys() const;
  void set_system_keys(const std::string& value);
  void set_system_keys(std::string&& value);
  void set_system_keys(const char* value);
  void set_system_keys(const char* value, size_t size);
  std::string* mutable_system_keys();
  std::string* release_system_keys();
  void set_allocated_system_keys(std::string* system_keys);

  // optional bool connected_to_adb = 1;
  bool has_connected_to_adb() const;
  void clear_connected_to_adb();
  bool connected_to_adb() const;
  void set_connected_to_adb(bool value);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbDebuggingManagerProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_key_received_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_keys_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr system_keys_;
  bool connected_to_adb_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbHostManagerProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbHostManagerProto) */ {
 public:
  UsbHostManagerProto();
  virtual ~UsbHostManagerProto();

  UsbHostManagerProto(const UsbHostManagerProto& from);
  UsbHostManagerProto(UsbHostManagerProto&& from) noexcept
    : UsbHostManagerProto() {
    *this = ::std::move(from);
  }

  inline UsbHostManagerProto& operator=(const UsbHostManagerProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbHostManagerProto& operator=(UsbHostManagerProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbHostManagerProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbHostManagerProto* internal_default_instance() {
    return reinterpret_cast<const UsbHostManagerProto*>(
               &_UsbHostManagerProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UsbHostManagerProto& a, UsbHostManagerProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbHostManagerProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbHostManagerProto* New() const final {
    return CreateMaybeMessage<UsbHostManagerProto>(nullptr);
  }

  UsbHostManagerProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbHostManagerProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbHostManagerProto& from);
  void MergeFrom(const UsbHostManagerProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbHostManagerProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbHostManagerProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicesFieldNumber = 2,
    kConnectionsFieldNumber = 4,
    kDefaultUsbHostConnectionHandlerFieldNumber = 1,
    kNumConnectsFieldNumber = 3,
  };
  // repeated .android.service.usb.UsbDeviceProto devices = 2;
  int devices_size() const;
  void clear_devices();
  ::android::service::usb::UsbDeviceProto* mutable_devices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbDeviceProto >*
      mutable_devices();
  const ::android::service::usb::UsbDeviceProto& devices(int index) const;
  ::android::service::usb::UsbDeviceProto* add_devices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbDeviceProto >&
      devices() const;

  // repeated .android.service.usb.UsbConnectionRecordProto connections = 4;
  int connections_size() const;
  void clear_connections();
  ::android::service::usb::UsbConnectionRecordProto* mutable_connections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbConnectionRecordProto >*
      mutable_connections();
  const ::android::service::usb::UsbConnectionRecordProto& connections(int index) const;
  ::android::service::usb::UsbConnectionRecordProto* add_connections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbConnectionRecordProto >&
      connections() const;

  // optional .android.content.ComponentNameProto default_usb_host_connection_handler = 1;
  bool has_default_usb_host_connection_handler() const;
  void clear_default_usb_host_connection_handler();
  const ::android::content::ComponentNameProto& default_usb_host_connection_handler() const;
  ::android::content::ComponentNameProto* release_default_usb_host_connection_handler();
  ::android::content::ComponentNameProto* mutable_default_usb_host_connection_handler();
  void set_allocated_default_usb_host_connection_handler(::android::content::ComponentNameProto* default_usb_host_connection_handler);

  // optional int32 num_connects = 3;
  bool has_num_connects() const;
  void clear_num_connects();
  ::PROTOBUF_NAMESPACE_ID::int32 num_connects() const;
  void set_num_connects(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbHostManagerProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbDeviceProto > devices_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbConnectionRecordProto > connections_;
  ::android::content::ComponentNameProto* default_usb_host_connection_handler_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_connects_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbDeviceProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbDeviceProto) */ {
 public:
  UsbDeviceProto();
  virtual ~UsbDeviceProto();

  UsbDeviceProto(const UsbDeviceProto& from);
  UsbDeviceProto(UsbDeviceProto&& from) noexcept
    : UsbDeviceProto() {
    *this = ::std::move(from);
  }

  inline UsbDeviceProto& operator=(const UsbDeviceProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbDeviceProto& operator=(UsbDeviceProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbDeviceProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbDeviceProto* internal_default_instance() {
    return reinterpret_cast<const UsbDeviceProto*>(
               &_UsbDeviceProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UsbDeviceProto& a, UsbDeviceProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbDeviceProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbDeviceProto* New() const final {
    return CreateMaybeMessage<UsbDeviceProto>(nullptr);
  }

  UsbDeviceProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbDeviceProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbDeviceProto& from);
  void MergeFrom(const UsbDeviceProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbDeviceProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbDeviceProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigurationsFieldNumber = 11,
    kNameFieldNumber = 1,
    kManufacturerNameFieldNumber = 7,
    kProductNameFieldNumber = 8,
    kVersionFieldNumber = 9,
    kSerialNumberFieldNumber = 10,
    kVendorIdFieldNumber = 2,
    kProductIdFieldNumber = 3,
    kClassFieldNumber = 4,
    kSubclassFieldNumber = 5,
    kProtocolFieldNumber = 6,
  };
  // repeated .android.service.usb.UsbConfigurationProto configurations = 11;
  int configurations_size() const;
  void clear_configurations();
  ::android::service::usb::UsbConfigurationProto* mutable_configurations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbConfigurationProto >*
      mutable_configurations();
  const ::android::service::usb::UsbConfigurationProto& configurations(int index) const;
  ::android::service::usb::UsbConfigurationProto* add_configurations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbConfigurationProto >&
      configurations() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // optional string manufacturer_name = 7;
  bool has_manufacturer_name() const;
  void clear_manufacturer_name();
  const std::string& manufacturer_name() const;
  void set_manufacturer_name(const std::string& value);
  void set_manufacturer_name(std::string&& value);
  void set_manufacturer_name(const char* value);
  void set_manufacturer_name(const char* value, size_t size);
  std::string* mutable_manufacturer_name();
  std::string* release_manufacturer_name();
  void set_allocated_manufacturer_name(std::string* manufacturer_name);

  // optional string product_name = 8;
  bool has_product_name() const;
  void clear_product_name();
  const std::string& product_name() const;
  void set_product_name(const std::string& value);
  void set_product_name(std::string&& value);
  void set_product_name(const char* value);
  void set_product_name(const char* value, size_t size);
  std::string* mutable_product_name();
  std::string* release_product_name();
  void set_allocated_product_name(std::string* product_name);

  // optional string version = 9;
  bool has_version() const;
  void clear_version();
  const std::string& version() const;
  void set_version(const std::string& value);
  void set_version(std::string&& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  std::string* mutable_version();
  std::string* release_version();
  void set_allocated_version(std::string* version);

  // optional string serial_number = 10 [(.android.privacy) = {
  bool has_serial_number() const;
  void clear_serial_number();
  const std::string& serial_number() const;
  void set_serial_number(const std::string& value);
  void set_serial_number(std::string&& value);
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  std::string* mutable_serial_number();
  std::string* release_serial_number();
  void set_allocated_serial_number(std::string* serial_number);

  // optional int32 vendor_id = 2;
  bool has_vendor_id() const;
  void clear_vendor_id();
  ::PROTOBUF_NAMESPACE_ID::int32 vendor_id() const;
  void set_vendor_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 product_id = 3;
  bool has_product_id() const;
  void clear_product_id();
  ::PROTOBUF_NAMESPACE_ID::int32 product_id() const;
  void set_product_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 class = 4;
  bool has_class_() const;
  void clear_class_();
  ::PROTOBUF_NAMESPACE_ID::int32 class_() const;
  void set_class_(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 subclass = 5;
  bool has_subclass() const;
  void clear_subclass();
  ::PROTOBUF_NAMESPACE_ID::int32 subclass() const;
  void set_subclass(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 protocol = 6;
  bool has_protocol() const;
  void clear_protocol();
  ::PROTOBUF_NAMESPACE_ID::int32 protocol() const;
  void set_protocol(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbDeviceProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbConfigurationProto > configurations_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacturer_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_number_;
  ::PROTOBUF_NAMESPACE_ID::int32 vendor_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 product_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 class__;
  ::PROTOBUF_NAMESPACE_ID::int32 subclass_;
  ::PROTOBUF_NAMESPACE_ID::int32 protocol_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbConfigurationProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbConfigurationProto) */ {
 public:
  UsbConfigurationProto();
  virtual ~UsbConfigurationProto();

  UsbConfigurationProto(const UsbConfigurationProto& from);
  UsbConfigurationProto(UsbConfigurationProto&& from) noexcept
    : UsbConfigurationProto() {
    *this = ::std::move(from);
  }

  inline UsbConfigurationProto& operator=(const UsbConfigurationProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbConfigurationProto& operator=(UsbConfigurationProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbConfigurationProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbConfigurationProto* internal_default_instance() {
    return reinterpret_cast<const UsbConfigurationProto*>(
               &_UsbConfigurationProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UsbConfigurationProto& a, UsbConfigurationProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbConfigurationProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbConfigurationProto* New() const final {
    return CreateMaybeMessage<UsbConfigurationProto>(nullptr);
  }

  UsbConfigurationProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbConfigurationProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbConfigurationProto& from);
  void MergeFrom(const UsbConfigurationProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbConfigurationProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbConfigurationProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInterfacesFieldNumber = 5,
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
    kAttributesFieldNumber = 3,
    kMaxPowerFieldNumber = 4,
  };
  // repeated .android.service.usb.UsbInterfaceProto interfaces = 5;
  int interfaces_size() const;
  void clear_interfaces();
  ::android::service::usb::UsbInterfaceProto* mutable_interfaces(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbInterfaceProto >*
      mutable_interfaces();
  const ::android::service::usb::UsbInterfaceProto& interfaces(int index) const;
  ::android::service::usb::UsbInterfaceProto* add_interfaces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbInterfaceProto >&
      interfaces() const;

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional uint32 attributes = 3;
  bool has_attributes() const;
  void clear_attributes();
  ::PROTOBUF_NAMESPACE_ID::uint32 attributes() const;
  void set_attributes(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional int32 max_power = 4;
  bool has_max_power() const;
  void clear_max_power();
  ::PROTOBUF_NAMESPACE_ID::int32 max_power() const;
  void set_max_power(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbConfigurationProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbInterfaceProto > interfaces_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 attributes_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_power_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbInterfaceProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbInterfaceProto) */ {
 public:
  UsbInterfaceProto();
  virtual ~UsbInterfaceProto();

  UsbInterfaceProto(const UsbInterfaceProto& from);
  UsbInterfaceProto(UsbInterfaceProto&& from) noexcept
    : UsbInterfaceProto() {
    *this = ::std::move(from);
  }

  inline UsbInterfaceProto& operator=(const UsbInterfaceProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbInterfaceProto& operator=(UsbInterfaceProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbInterfaceProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbInterfaceProto* internal_default_instance() {
    return reinterpret_cast<const UsbInterfaceProto*>(
               &_UsbInterfaceProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UsbInterfaceProto& a, UsbInterfaceProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbInterfaceProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbInterfaceProto* New() const final {
    return CreateMaybeMessage<UsbInterfaceProto>(nullptr);
  }

  UsbInterfaceProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbInterfaceProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbInterfaceProto& from);
  void MergeFrom(const UsbInterfaceProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbInterfaceProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbInterfaceProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointsFieldNumber = 7,
    kNameFieldNumber = 3,
    kIdFieldNumber = 1,
    kAlternateSettingsFieldNumber = 2,
    kClassFieldNumber = 4,
    kSubclassFieldNumber = 5,
    kProtocolFieldNumber = 6,
  };
  // repeated .android.service.usb.UsbEndPointProto endpoints = 7;
  int endpoints_size() const;
  void clear_endpoints();
  ::android::service::usb::UsbEndPointProto* mutable_endpoints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbEndPointProto >*
      mutable_endpoints();
  const ::android::service::usb::UsbEndPointProto& endpoints(int index) const;
  ::android::service::usb::UsbEndPointProto* add_endpoints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbEndPointProto >&
      endpoints() const;

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 alternate_settings = 2;
  bool has_alternate_settings() const;
  void clear_alternate_settings();
  ::PROTOBUF_NAMESPACE_ID::int32 alternate_settings() const;
  void set_alternate_settings(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 class = 4;
  bool has_class_() const;
  void clear_class_();
  ::PROTOBUF_NAMESPACE_ID::int32 class_() const;
  void set_class_(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 subclass = 5;
  bool has_subclass() const;
  void clear_subclass();
  ::PROTOBUF_NAMESPACE_ID::int32 subclass() const;
  void set_subclass(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 protocol = 6;
  bool has_protocol() const;
  void clear_protocol();
  ::PROTOBUF_NAMESPACE_ID::int32 protocol() const;
  void set_protocol(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbInterfaceProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbEndPointProto > endpoints_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 alternate_settings_;
  ::PROTOBUF_NAMESPACE_ID::int32 class__;
  ::PROTOBUF_NAMESPACE_ID::int32 subclass_;
  ::PROTOBUF_NAMESPACE_ID::int32 protocol_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbEndPointProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbEndPointProto) */ {
 public:
  UsbEndPointProto();
  virtual ~UsbEndPointProto();

  UsbEndPointProto(const UsbEndPointProto& from);
  UsbEndPointProto(UsbEndPointProto&& from) noexcept
    : UsbEndPointProto() {
    *this = ::std::move(from);
  }

  inline UsbEndPointProto& operator=(const UsbEndPointProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbEndPointProto& operator=(UsbEndPointProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbEndPointProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbEndPointProto* internal_default_instance() {
    return reinterpret_cast<const UsbEndPointProto*>(
               &_UsbEndPointProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UsbEndPointProto& a, UsbEndPointProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbEndPointProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbEndPointProto* New() const final {
    return CreateMaybeMessage<UsbEndPointProto>(nullptr);
  }

  UsbEndPointProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbEndPointProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbEndPointProto& from);
  void MergeFrom(const UsbEndPointProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbEndPointProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbEndPointProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointNumberFieldNumber = 1,
    kDirectionFieldNumber = 2,
    kAddressFieldNumber = 3,
    kTypeFieldNumber = 4,
    kAttributesFieldNumber = 5,
    kMaxPacketSizeFieldNumber = 6,
    kIntervalFieldNumber = 7,
  };
  // optional int32 endpoint_number = 1;
  bool has_endpoint_number() const;
  void clear_endpoint_number();
  ::PROTOBUF_NAMESPACE_ID::int32 endpoint_number() const;
  void set_endpoint_number(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional .android.service.UsbEndPointDirection direction = 2;
  bool has_direction() const;
  void clear_direction();
  ::android::service::UsbEndPointDirection direction() const;
  void set_direction(::android::service::UsbEndPointDirection value);

  // optional int32 address = 3;
  bool has_address() const;
  void clear_address();
  ::PROTOBUF_NAMESPACE_ID::int32 address() const;
  void set_address(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional .android.service.UsbEndPointType type = 4;
  bool has_type() const;
  void clear_type();
  ::android::service::UsbEndPointType type() const;
  void set_type(::android::service::UsbEndPointType value);

  // optional uint32 attributes = 5;
  bool has_attributes() const;
  void clear_attributes();
  ::PROTOBUF_NAMESPACE_ID::uint32 attributes() const;
  void set_attributes(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional int32 max_packet_size = 6;
  bool has_max_packet_size() const;
  void clear_max_packet_size();
  ::PROTOBUF_NAMESPACE_ID::int32 max_packet_size() const;
  void set_max_packet_size(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 interval = 7;
  bool has_interval() const;
  void clear_interval();
  ::PROTOBUF_NAMESPACE_ID::int32 interval() const;
  void set_interval(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbEndPointProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 endpoint_number_;
  int direction_;
  ::PROTOBUF_NAMESPACE_ID::int32 address_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 attributes_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_packet_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 interval_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbConnectionRecordProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbConnectionRecordProto) */ {
 public:
  UsbConnectionRecordProto();
  virtual ~UsbConnectionRecordProto();

  UsbConnectionRecordProto(const UsbConnectionRecordProto& from);
  UsbConnectionRecordProto(UsbConnectionRecordProto&& from) noexcept
    : UsbConnectionRecordProto() {
    *this = ::std::move(from);
  }

  inline UsbConnectionRecordProto& operator=(const UsbConnectionRecordProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbConnectionRecordProto& operator=(UsbConnectionRecordProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbConnectionRecordProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbConnectionRecordProto* internal_default_instance() {
    return reinterpret_cast<const UsbConnectionRecordProto*>(
               &_UsbConnectionRecordProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UsbConnectionRecordProto& a, UsbConnectionRecordProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbConnectionRecordProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbConnectionRecordProto* New() const final {
    return CreateMaybeMessage<UsbConnectionRecordProto>(nullptr);
  }

  UsbConnectionRecordProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbConnectionRecordProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbConnectionRecordProto& from);
  void MergeFrom(const UsbConnectionRecordProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbConnectionRecordProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbConnectionRecordProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceAddressFieldNumber = 1,
    kIsHeadsetFieldNumber = 6,
    kTimestampFieldNumber = 3,
    kModeFieldNumber = 2,
    kManufacturerFieldNumber = 4,
    kProductFieldNumber = 5,
  };
  // optional string device_address = 1;
  bool has_device_address() const;
  void clear_device_address();
  const std::string& device_address() const;
  void set_device_address(const std::string& value);
  void set_device_address(std::string&& value);
  void set_device_address(const char* value);
  void set_device_address(const char* value, size_t size);
  std::string* mutable_device_address();
  std::string* release_device_address();
  void set_allocated_device_address(std::string* device_address);

  // optional .android.service.usb.UsbIsHeadsetProto is_headset = 6;
  bool has_is_headset() const;
  void clear_is_headset();
  const ::android::service::usb::UsbIsHeadsetProto& is_headset() const;
  ::android::service::usb::UsbIsHeadsetProto* release_is_headset();
  ::android::service::usb::UsbIsHeadsetProto* mutable_is_headset();
  void set_allocated_is_headset(::android::service::usb::UsbIsHeadsetProto* is_headset);

  // optional int64 timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional .android.service.UsbConnectionRecordMode mode = 2;
  bool has_mode() const;
  void clear_mode();
  ::android::service::UsbConnectionRecordMode mode() const;
  void set_mode(::android::service::UsbConnectionRecordMode value);

  // optional int32 manufacturer = 4;
  bool has_manufacturer() const;
  void clear_manufacturer();
  ::PROTOBUF_NAMESPACE_ID::int32 manufacturer() const;
  void set_manufacturer(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 product = 5;
  bool has_product() const;
  void clear_product();
  ::PROTOBUF_NAMESPACE_ID::int32 product() const;
  void set_product(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbConnectionRecordProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_address_;
  ::android::service::usb::UsbIsHeadsetProto* is_headset_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  int mode_;
  ::PROTOBUF_NAMESPACE_ID::int32 manufacturer_;
  ::PROTOBUF_NAMESPACE_ID::int32 product_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbIsHeadsetProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbIsHeadsetProto) */ {
 public:
  UsbIsHeadsetProto();
  virtual ~UsbIsHeadsetProto();

  UsbIsHeadsetProto(const UsbIsHeadsetProto& from);
  UsbIsHeadsetProto(UsbIsHeadsetProto&& from) noexcept
    : UsbIsHeadsetProto() {
    *this = ::std::move(from);
  }

  inline UsbIsHeadsetProto& operator=(const UsbIsHeadsetProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbIsHeadsetProto& operator=(UsbIsHeadsetProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbIsHeadsetProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbIsHeadsetProto* internal_default_instance() {
    return reinterpret_cast<const UsbIsHeadsetProto*>(
               &_UsbIsHeadsetProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UsbIsHeadsetProto& a, UsbIsHeadsetProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbIsHeadsetProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbIsHeadsetProto* New() const final {
    return CreateMaybeMessage<UsbIsHeadsetProto>(nullptr);
  }

  UsbIsHeadsetProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbIsHeadsetProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbIsHeadsetProto& from);
  void MergeFrom(const UsbIsHeadsetProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbIsHeadsetProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbIsHeadsetProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInFieldNumber = 1,
    kOutFieldNumber = 2,
  };
  // optional bool in = 1;
  bool has_in() const;
  void clear_in();
  bool in() const;
  void set_in(bool value);

  // optional bool out = 2;
  bool has_out() const;
  void clear_out();
  bool out() const;
  void set_out(bool value);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbIsHeadsetProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool in_;
  bool out_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbPortManagerProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbPortManagerProto) */ {
 public:
  UsbPortManagerProto();
  virtual ~UsbPortManagerProto();

  UsbPortManagerProto(const UsbPortManagerProto& from);
  UsbPortManagerProto(UsbPortManagerProto&& from) noexcept
    : UsbPortManagerProto() {
    *this = ::std::move(from);
  }

  inline UsbPortManagerProto& operator=(const UsbPortManagerProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbPortManagerProto& operator=(UsbPortManagerProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbPortManagerProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbPortManagerProto* internal_default_instance() {
    return reinterpret_cast<const UsbPortManagerProto*>(
               &_UsbPortManagerProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UsbPortManagerProto& a, UsbPortManagerProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbPortManagerProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbPortManagerProto* New() const final {
    return CreateMaybeMessage<UsbPortManagerProto>(nullptr);
  }

  UsbPortManagerProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbPortManagerProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbPortManagerProto& from);
  void MergeFrom(const UsbPortManagerProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbPortManagerProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbPortManagerProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsbPortsFieldNumber = 2,
    kIsSimulationActiveFieldNumber = 1,
    kEnableUsbDataSignalingFieldNumber = 3,
  };
  // repeated .android.service.usb.UsbPortInfoProto usb_ports = 2;
  int usb_ports_size() const;
  void clear_usb_ports();
  ::android::service::usb::UsbPortInfoProto* mutable_usb_ports(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbPortInfoProto >*
      mutable_usb_ports();
  const ::android::service::usb::UsbPortInfoProto& usb_ports(int index) const;
  ::android::service::usb::UsbPortInfoProto* add_usb_ports();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbPortInfoProto >&
      usb_ports() const;

  // optional bool is_simulation_active = 1;
  bool has_is_simulation_active() const;
  void clear_is_simulation_active();
  bool is_simulation_active() const;
  void set_is_simulation_active(bool value);

  // optional bool enable_usb_data_signaling = 3;
  bool has_enable_usb_data_signaling() const;
  void clear_enable_usb_data_signaling();
  bool enable_usb_data_signaling() const;
  void set_enable_usb_data_signaling(bool value);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbPortManagerProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbPortInfoProto > usb_ports_;
  bool is_simulation_active_;
  bool enable_usb_data_signaling_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbPortInfoProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbPortInfoProto) */ {
 public:
  UsbPortInfoProto();
  virtual ~UsbPortInfoProto();

  UsbPortInfoProto(const UsbPortInfoProto& from);
  UsbPortInfoProto(UsbPortInfoProto&& from) noexcept
    : UsbPortInfoProto() {
    *this = ::std::move(from);
  }

  inline UsbPortInfoProto& operator=(const UsbPortInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbPortInfoProto& operator=(UsbPortInfoProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbPortInfoProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbPortInfoProto* internal_default_instance() {
    return reinterpret_cast<const UsbPortInfoProto*>(
               &_UsbPortInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UsbPortInfoProto& a, UsbPortInfoProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbPortInfoProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbPortInfoProto* New() const final {
    return CreateMaybeMessage<UsbPortInfoProto>(nullptr);
  }

  UsbPortInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbPortInfoProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbPortInfoProto& from);
  void MergeFrom(const UsbPortInfoProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbPortInfoProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbPortInfoProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortFieldNumber = 1,
    kStatusFieldNumber = 2,
    kConnectedAtMillisFieldNumber = 6,
    kLastConnectDurationMillisFieldNumber = 7,
    kCanChangeModeFieldNumber = 3,
    kCanChangePowerRoleFieldNumber = 4,
    kCanChangeDataRoleFieldNumber = 5,
  };
  // optional .android.service.usb.UsbPortProto port = 1;
  bool has_port() const;
  void clear_port();
  const ::android::service::usb::UsbPortProto& port() const;
  ::android::service::usb::UsbPortProto* release_port();
  ::android::service::usb::UsbPortProto* mutable_port();
  void set_allocated_port(::android::service::usb::UsbPortProto* port);

  // optional .android.service.usb.UsbPortStatusProto status = 2;
  bool has_status() const;
  void clear_status();
  const ::android::service::usb::UsbPortStatusProto& status() const;
  ::android::service::usb::UsbPortStatusProto* release_status();
  ::android::service::usb::UsbPortStatusProto* mutable_status();
  void set_allocated_status(::android::service::usb::UsbPortStatusProto* status);

  // optional int64 connected_at_millis = 6;
  bool has_connected_at_millis() const;
  void clear_connected_at_millis();
  ::PROTOBUF_NAMESPACE_ID::int64 connected_at_millis() const;
  void set_connected_at_millis(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 last_connect_duration_millis = 7;
  bool has_last_connect_duration_millis() const;
  void clear_last_connect_duration_millis();
  ::PROTOBUF_NAMESPACE_ID::int64 last_connect_duration_millis() const;
  void set_last_connect_duration_millis(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional bool can_change_mode = 3;
  bool has_can_change_mode() const;
  void clear_can_change_mode();
  bool can_change_mode() const;
  void set_can_change_mode(bool value);

  // optional bool can_change_power_role = 4;
  bool has_can_change_power_role() const;
  void clear_can_change_power_role();
  bool can_change_power_role() const;
  void set_can_change_power_role(bool value);

  // optional bool can_change_data_role = 5;
  bool has_can_change_data_role() const;
  void clear_can_change_data_role();
  bool can_change_data_role() const;
  void set_can_change_data_role(bool value);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbPortInfoProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::android::service::usb::UsbPortProto* port_;
  ::android::service::usb::UsbPortStatusProto* status_;
  ::PROTOBUF_NAMESPACE_ID::int64 connected_at_millis_;
  ::PROTOBUF_NAMESPACE_ID::int64 last_connect_duration_millis_;
  bool can_change_mode_;
  bool can_change_power_role_;
  bool can_change_data_role_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbPortProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbPortProto) */ {
 public:
  UsbPortProto();
  virtual ~UsbPortProto();

  UsbPortProto(const UsbPortProto& from);
  UsbPortProto(UsbPortProto&& from) noexcept
    : UsbPortProto() {
    *this = ::std::move(from);
  }

  inline UsbPortProto& operator=(const UsbPortProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbPortProto& operator=(UsbPortProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbPortProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbPortProto* internal_default_instance() {
    return reinterpret_cast<const UsbPortProto*>(
               &_UsbPortProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UsbPortProto& a, UsbPortProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbPortProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbPortProto* New() const final {
    return CreateMaybeMessage<UsbPortProto>(nullptr);
  }

  UsbPortProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbPortProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbPortProto& from);
  void MergeFrom(const UsbPortProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbPortProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbPortProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef UsbPortProto_Mode Mode;
  static constexpr Mode MODE_NONE =
    UsbPortProto_Mode_MODE_NONE;
  static constexpr Mode MODE_UFP =
    UsbPortProto_Mode_MODE_UFP;
  static constexpr Mode MODE_DFP =
    UsbPortProto_Mode_MODE_DFP;
  static constexpr Mode MODE_DRP =
    UsbPortProto_Mode_MODE_DRP;
  static constexpr Mode MODE_AUDIO_ACCESSORY =
    UsbPortProto_Mode_MODE_AUDIO_ACCESSORY;
  static constexpr Mode MODE_DEBUG_ACCESSORY =
    UsbPortProto_Mode_MODE_DEBUG_ACCESSORY;
  static inline bool Mode_IsValid(int value) {
    return UsbPortProto_Mode_IsValid(value);
  }
  static constexpr Mode Mode_MIN =
    UsbPortProto_Mode_Mode_MIN;
  static constexpr Mode Mode_MAX =
    UsbPortProto_Mode_Mode_MAX;
  static constexpr int Mode_ARRAYSIZE =
    UsbPortProto_Mode_Mode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Mode_descriptor() {
    return UsbPortProto_Mode_descriptor();
  }
  template<typename T>
  static inline const std::string& Mode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Mode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Mode_Name.");
    return UsbPortProto_Mode_Name(enum_t_value);
  }
  static inline bool Mode_Parse(const std::string& name,
      Mode* value) {
    return UsbPortProto_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSupportedModesFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .android.service.usb.UsbPortProto.Mode supported_modes = 2;
  int supported_modes_size() const;
  void clear_supported_modes();
  ::android::service::usb::UsbPortProto_Mode supported_modes(int index) const;
  void set_supported_modes(int index, ::android::service::usb::UsbPortProto_Mode value);
  void add_supported_modes(::android::service::usb::UsbPortProto_Mode value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& supported_modes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_supported_modes();

  // optional string id = 1;
  bool has_id() const;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbPortProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> supported_modes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbPortStatusProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbPortStatusProto) */ {
 public:
  UsbPortStatusProto();
  virtual ~UsbPortStatusProto();

  UsbPortStatusProto(const UsbPortStatusProto& from);
  UsbPortStatusProto(UsbPortStatusProto&& from) noexcept
    : UsbPortStatusProto() {
    *this = ::std::move(from);
  }

  inline UsbPortStatusProto& operator=(const UsbPortStatusProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbPortStatusProto& operator=(UsbPortStatusProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbPortStatusProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbPortStatusProto* internal_default_instance() {
    return reinterpret_cast<const UsbPortStatusProto*>(
               &_UsbPortStatusProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UsbPortStatusProto& a, UsbPortStatusProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbPortStatusProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbPortStatusProto* New() const final {
    return CreateMaybeMessage<UsbPortStatusProto>(nullptr);
  }

  UsbPortStatusProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbPortStatusProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbPortStatusProto& from);
  void MergeFrom(const UsbPortStatusProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbPortStatusProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbPortStatusProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef UsbPortStatusProto_PowerRole PowerRole;
  static constexpr PowerRole POWER_ROLE_NONE =
    UsbPortStatusProto_PowerRole_POWER_ROLE_NONE;
  static constexpr PowerRole POWER_ROLE_SOURCE =
    UsbPortStatusProto_PowerRole_POWER_ROLE_SOURCE;
  static constexpr PowerRole POWER_ROLE_SINK =
    UsbPortStatusProto_PowerRole_POWER_ROLE_SINK;
  static inline bool PowerRole_IsValid(int value) {
    return UsbPortStatusProto_PowerRole_IsValid(value);
  }
  static constexpr PowerRole PowerRole_MIN =
    UsbPortStatusProto_PowerRole_PowerRole_MIN;
  static constexpr PowerRole PowerRole_MAX =
    UsbPortStatusProto_PowerRole_PowerRole_MAX;
  static constexpr int PowerRole_ARRAYSIZE =
    UsbPortStatusProto_PowerRole_PowerRole_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PowerRole_descriptor() {
    return UsbPortStatusProto_PowerRole_descriptor();
  }
  template<typename T>
  static inline const std::string& PowerRole_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PowerRole>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PowerRole_Name.");
    return UsbPortStatusProto_PowerRole_Name(enum_t_value);
  }
  static inline bool PowerRole_Parse(const std::string& name,
      PowerRole* value) {
    return UsbPortStatusProto_PowerRole_Parse(name, value);
  }

  typedef UsbPortStatusProto_DataRole DataRole;
  static constexpr DataRole DATA_ROLE_NONE =
    UsbPortStatusProto_DataRole_DATA_ROLE_NONE;
  static constexpr DataRole DATA_ROLE_HOST =
    UsbPortStatusProto_DataRole_DATA_ROLE_HOST;
  static constexpr DataRole DATA_ROLE_DEVICE =
    UsbPortStatusProto_DataRole_DATA_ROLE_DEVICE;
  static inline bool DataRole_IsValid(int value) {
    return UsbPortStatusProto_DataRole_IsValid(value);
  }
  static constexpr DataRole DataRole_MIN =
    UsbPortStatusProto_DataRole_DataRole_MIN;
  static constexpr DataRole DataRole_MAX =
    UsbPortStatusProto_DataRole_DataRole_MAX;
  static constexpr int DataRole_ARRAYSIZE =
    UsbPortStatusProto_DataRole_DataRole_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DataRole_descriptor() {
    return UsbPortStatusProto_DataRole_descriptor();
  }
  template<typename T>
  static inline const std::string& DataRole_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DataRole>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DataRole_Name.");
    return UsbPortStatusProto_DataRole_Name(enum_t_value);
  }
  static inline bool DataRole_Parse(const std::string& name,
      DataRole* value) {
    return UsbPortStatusProto_DataRole_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRoleCombinationsFieldNumber = 5,
    kConnectedFieldNumber = 1,
    kCurrentModeFieldNumber = 2,
    kPowerRoleFieldNumber = 3,
    kDataRoleFieldNumber = 4,
    kContaminantPresenceStatusFieldNumber = 6,
  };
  // repeated .android.service.usb.UsbPortStatusRoleCombinationProto role_combinations = 5;
  int role_combinations_size() const;
  void clear_role_combinations();
  ::android::service::usb::UsbPortStatusRoleCombinationProto* mutable_role_combinations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbPortStatusRoleCombinationProto >*
      mutable_role_combinations();
  const ::android::service::usb::UsbPortStatusRoleCombinationProto& role_combinations(int index) const;
  ::android::service::usb::UsbPortStatusRoleCombinationProto* add_role_combinations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbPortStatusRoleCombinationProto >&
      role_combinations() const;

  // optional bool connected = 1;
  bool has_connected() const;
  void clear_connected();
  bool connected() const;
  void set_connected(bool value);

  // optional .android.service.usb.UsbPortProto.Mode current_mode = 2;
  bool has_current_mode() const;
  void clear_current_mode();
  ::android::service::usb::UsbPortProto_Mode current_mode() const;
  void set_current_mode(::android::service::usb::UsbPortProto_Mode value);

  // optional .android.service.usb.UsbPortStatusProto.PowerRole power_role = 3;
  bool has_power_role() const;
  void clear_power_role();
  ::android::service::usb::UsbPortStatusProto_PowerRole power_role() const;
  void set_power_role(::android::service::usb::UsbPortStatusProto_PowerRole value);

  // optional .android.service.usb.UsbPortStatusProto.DataRole data_role = 4;
  bool has_data_role() const;
  void clear_data_role();
  ::android::service::usb::UsbPortStatusProto_DataRole data_role() const;
  void set_data_role(::android::service::usb::UsbPortStatusProto_DataRole value);

  // optional .android.service.ContaminantPresenceStatus contaminant_presence_status = 6;
  bool has_contaminant_presence_status() const;
  void clear_contaminant_presence_status();
  ::android::service::ContaminantPresenceStatus contaminant_presence_status() const;
  void set_contaminant_presence_status(::android::service::ContaminantPresenceStatus value);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbPortStatusProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbPortStatusRoleCombinationProto > role_combinations_;
  bool connected_;
  int current_mode_;
  int power_role_;
  int data_role_;
  int contaminant_presence_status_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbPortStatusRoleCombinationProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbPortStatusRoleCombinationProto) */ {
 public:
  UsbPortStatusRoleCombinationProto();
  virtual ~UsbPortStatusRoleCombinationProto();

  UsbPortStatusRoleCombinationProto(const UsbPortStatusRoleCombinationProto& from);
  UsbPortStatusRoleCombinationProto(UsbPortStatusRoleCombinationProto&& from) noexcept
    : UsbPortStatusRoleCombinationProto() {
    *this = ::std::move(from);
  }

  inline UsbPortStatusRoleCombinationProto& operator=(const UsbPortStatusRoleCombinationProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbPortStatusRoleCombinationProto& operator=(UsbPortStatusRoleCombinationProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbPortStatusRoleCombinationProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbPortStatusRoleCombinationProto* internal_default_instance() {
    return reinterpret_cast<const UsbPortStatusRoleCombinationProto*>(
               &_UsbPortStatusRoleCombinationProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UsbPortStatusRoleCombinationProto& a, UsbPortStatusRoleCombinationProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbPortStatusRoleCombinationProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbPortStatusRoleCombinationProto* New() const final {
    return CreateMaybeMessage<UsbPortStatusRoleCombinationProto>(nullptr);
  }

  UsbPortStatusRoleCombinationProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbPortStatusRoleCombinationProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbPortStatusRoleCombinationProto& from);
  void MergeFrom(const UsbPortStatusRoleCombinationProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbPortStatusRoleCombinationProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbPortStatusRoleCombinationProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPowerRoleFieldNumber = 1,
    kDataRoleFieldNumber = 2,
  };
  // optional .android.service.usb.UsbPortStatusProto.PowerRole power_role = 1;
  bool has_power_role() const;
  void clear_power_role();
  ::android::service::usb::UsbPortStatusProto_PowerRole power_role() const;
  void set_power_role(::android::service::usb::UsbPortStatusProto_PowerRole value);

  // optional .android.service.usb.UsbPortStatusProto.DataRole data_role = 2;
  bool has_data_role() const;
  void clear_data_role();
  ::android::service::usb::UsbPortStatusProto_DataRole data_role() const;
  void set_data_role(::android::service::usb::UsbPortStatusProto_DataRole value);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbPortStatusRoleCombinationProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int power_role_;
  int data_role_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbAlsaManagerProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbAlsaManagerProto) */ {
 public:
  UsbAlsaManagerProto();
  virtual ~UsbAlsaManagerProto();

  UsbAlsaManagerProto(const UsbAlsaManagerProto& from);
  UsbAlsaManagerProto(UsbAlsaManagerProto&& from) noexcept
    : UsbAlsaManagerProto() {
    *this = ::std::move(from);
  }

  inline UsbAlsaManagerProto& operator=(const UsbAlsaManagerProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbAlsaManagerProto& operator=(UsbAlsaManagerProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbAlsaManagerProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbAlsaManagerProto* internal_default_instance() {
    return reinterpret_cast<const UsbAlsaManagerProto*>(
               &_UsbAlsaManagerProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(UsbAlsaManagerProto& a, UsbAlsaManagerProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbAlsaManagerProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbAlsaManagerProto* New() const final {
    return CreateMaybeMessage<UsbAlsaManagerProto>(nullptr);
  }

  UsbAlsaManagerProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbAlsaManagerProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbAlsaManagerProto& from);
  void MergeFrom(const UsbAlsaManagerProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbAlsaManagerProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbAlsaManagerProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlsaDevicesFieldNumber = 2,
    kMidiDevicesFieldNumber = 3,
    kCardsParserFieldNumber = 1,
  };
  // repeated .android.service.usb.UsbAlsaDeviceProto alsa_devices = 2;
  int alsa_devices_size() const;
  void clear_alsa_devices();
  ::android::service::usb::UsbAlsaDeviceProto* mutable_alsa_devices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbAlsaDeviceProto >*
      mutable_alsa_devices();
  const ::android::service::usb::UsbAlsaDeviceProto& alsa_devices(int index) const;
  ::android::service::usb::UsbAlsaDeviceProto* add_alsa_devices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbAlsaDeviceProto >&
      alsa_devices() const;

  // repeated .android.service.usb.UsbMidiDeviceProto midi_devices = 3;
  int midi_devices_size() const;
  void clear_midi_devices();
  ::android::service::usb::UsbMidiDeviceProto* mutable_midi_devices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbMidiDeviceProto >*
      mutable_midi_devices();
  const ::android::service::usb::UsbMidiDeviceProto& midi_devices(int index) const;
  ::android::service::usb::UsbMidiDeviceProto* add_midi_devices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbMidiDeviceProto >&
      midi_devices() const;

  // optional int32 cards_parser = 1;
  bool has_cards_parser() const;
  void clear_cards_parser();
  ::PROTOBUF_NAMESPACE_ID::int32 cards_parser() const;
  void set_cards_parser(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbAlsaManagerProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbAlsaDeviceProto > alsa_devices_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbMidiDeviceProto > midi_devices_;
  ::PROTOBUF_NAMESPACE_ID::int32 cards_parser_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbAlsaDeviceProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbAlsaDeviceProto) */ {
 public:
  UsbAlsaDeviceProto();
  virtual ~UsbAlsaDeviceProto();

  UsbAlsaDeviceProto(const UsbAlsaDeviceProto& from);
  UsbAlsaDeviceProto(UsbAlsaDeviceProto&& from) noexcept
    : UsbAlsaDeviceProto() {
    *this = ::std::move(from);
  }

  inline UsbAlsaDeviceProto& operator=(const UsbAlsaDeviceProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbAlsaDeviceProto& operator=(UsbAlsaDeviceProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbAlsaDeviceProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbAlsaDeviceProto* internal_default_instance() {
    return reinterpret_cast<const UsbAlsaDeviceProto*>(
               &_UsbAlsaDeviceProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(UsbAlsaDeviceProto& a, UsbAlsaDeviceProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbAlsaDeviceProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbAlsaDeviceProto* New() const final {
    return CreateMaybeMessage<UsbAlsaDeviceProto>(nullptr);
  }

  UsbAlsaDeviceProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbAlsaDeviceProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbAlsaDeviceProto& from);
  void MergeFrom(const UsbAlsaDeviceProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbAlsaDeviceProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbAlsaDeviceProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kAddressFieldNumber = 6,
    kCardFieldNumber = 1,
    kDeviceFieldNumber = 2,
    kHasPlaybackFieldNumber = 4,
    kHasCaptureFieldNumber = 5,
  };
  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // optional string address = 6;
  bool has_address() const;
  void clear_address();
  const std::string& address() const;
  void set_address(const std::string& value);
  void set_address(std::string&& value);
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  std::string* mutable_address();
  std::string* release_address();
  void set_allocated_address(std::string* address);

  // optional int32 card = 1;
  bool has_card() const;
  void clear_card();
  ::PROTOBUF_NAMESPACE_ID::int32 card() const;
  void set_card(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 device = 2;
  bool has_device() const;
  void clear_device();
  ::PROTOBUF_NAMESPACE_ID::int32 device() const;
  void set_device(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional bool has_playback = 4;
  bool has_has_playback() const;
  void clear_has_playback();
  bool has_playback() const;
  void set_has_playback(bool value);

  // optional bool has_capture = 5;
  bool has_has_capture() const;
  void clear_has_capture();
  bool has_capture() const;
  void set_has_capture(bool value);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbAlsaDeviceProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::int32 card_;
  ::PROTOBUF_NAMESPACE_ID::int32 device_;
  bool has_playback_;
  bool has_capture_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbMidiDeviceProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbMidiDeviceProto) */ {
 public:
  UsbMidiDeviceProto();
  virtual ~UsbMidiDeviceProto();

  UsbMidiDeviceProto(const UsbMidiDeviceProto& from);
  UsbMidiDeviceProto(UsbMidiDeviceProto&& from) noexcept
    : UsbMidiDeviceProto() {
    *this = ::std::move(from);
  }

  inline UsbMidiDeviceProto& operator=(const UsbMidiDeviceProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbMidiDeviceProto& operator=(UsbMidiDeviceProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbMidiDeviceProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbMidiDeviceProto* internal_default_instance() {
    return reinterpret_cast<const UsbMidiDeviceProto*>(
               &_UsbMidiDeviceProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(UsbMidiDeviceProto& a, UsbMidiDeviceProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbMidiDeviceProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbMidiDeviceProto* New() const final {
    return CreateMaybeMessage<UsbMidiDeviceProto>(nullptr);
  }

  UsbMidiDeviceProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbMidiDeviceProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbMidiDeviceProto& from);
  void MergeFrom(const UsbMidiDeviceProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbMidiDeviceProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbMidiDeviceProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceAddressFieldNumber = 3,
    kCardFieldNumber = 1,
    kDeviceFieldNumber = 2,
  };
  // optional string device_address = 3;
  bool has_device_address() const;
  void clear_device_address();
  const std::string& device_address() const;
  void set_device_address(const std::string& value);
  void set_device_address(std::string&& value);
  void set_device_address(const char* value);
  void set_device_address(const char* value, size_t size);
  std::string* mutable_device_address();
  std::string* release_device_address();
  void set_allocated_device_address(std::string* device_address);

  // optional int32 card = 1;
  bool has_card() const;
  void clear_card();
  ::PROTOBUF_NAMESPACE_ID::int32 card() const;
  void set_card(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 device = 2;
  bool has_device() const;
  void clear_device();
  ::PROTOBUF_NAMESPACE_ID::int32 device() const;
  void set_device(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbMidiDeviceProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_address_;
  ::PROTOBUF_NAMESPACE_ID::int32 card_;
  ::PROTOBUF_NAMESPACE_ID::int32 device_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbSettingsManagerProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbSettingsManagerProto) */ {
 public:
  UsbSettingsManagerProto();
  virtual ~UsbSettingsManagerProto();

  UsbSettingsManagerProto(const UsbSettingsManagerProto& from);
  UsbSettingsManagerProto(UsbSettingsManagerProto&& from) noexcept
    : UsbSettingsManagerProto() {
    *this = ::std::move(from);
  }

  inline UsbSettingsManagerProto& operator=(const UsbSettingsManagerProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbSettingsManagerProto& operator=(UsbSettingsManagerProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbSettingsManagerProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbSettingsManagerProto* internal_default_instance() {
    return reinterpret_cast<const UsbSettingsManagerProto*>(
               &_UsbSettingsManagerProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(UsbSettingsManagerProto& a, UsbSettingsManagerProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbSettingsManagerProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbSettingsManagerProto* New() const final {
    return CreateMaybeMessage<UsbSettingsManagerProto>(nullptr);
  }

  UsbSettingsManagerProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbSettingsManagerProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbSettingsManagerProto& from);
  void MergeFrom(const UsbSettingsManagerProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbSettingsManagerProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbSettingsManagerProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserSettingsFieldNumber = 1,
    kProfileGroupSettingsFieldNumber = 2,
  };
  // repeated .android.service.usb.UsbUserSettingsManagerProto user_settings = 1;
  int user_settings_size() const;
  void clear_user_settings();
  ::android::service::usb::UsbUserSettingsManagerProto* mutable_user_settings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbUserSettingsManagerProto >*
      mutable_user_settings();
  const ::android::service::usb::UsbUserSettingsManagerProto& user_settings(int index) const;
  ::android::service::usb::UsbUserSettingsManagerProto* add_user_settings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbUserSettingsManagerProto >&
      user_settings() const;

  // repeated .android.service.usb.UsbProfileGroupSettingsManagerProto profile_group_settings = 2;
  int profile_group_settings_size() const;
  void clear_profile_group_settings();
  ::android::service::usb::UsbProfileGroupSettingsManagerProto* mutable_profile_group_settings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbProfileGroupSettingsManagerProto >*
      mutable_profile_group_settings();
  const ::android::service::usb::UsbProfileGroupSettingsManagerProto& profile_group_settings(int index) const;
  ::android::service::usb::UsbProfileGroupSettingsManagerProto* add_profile_group_settings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbProfileGroupSettingsManagerProto >&
      profile_group_settings() const;

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbSettingsManagerProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbUserSettingsManagerProto > user_settings_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbProfileGroupSettingsManagerProto > profile_group_settings_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbUserSettingsManagerProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbUserSettingsManagerProto) */ {
 public:
  UsbUserSettingsManagerProto();
  virtual ~UsbUserSettingsManagerProto();

  UsbUserSettingsManagerProto(const UsbUserSettingsManagerProto& from);
  UsbUserSettingsManagerProto(UsbUserSettingsManagerProto&& from) noexcept
    : UsbUserSettingsManagerProto() {
    *this = ::std::move(from);
  }

  inline UsbUserSettingsManagerProto& operator=(const UsbUserSettingsManagerProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbUserSettingsManagerProto& operator=(UsbUserSettingsManagerProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbUserSettingsManagerProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbUserSettingsManagerProto* internal_default_instance() {
    return reinterpret_cast<const UsbUserSettingsManagerProto*>(
               &_UsbUserSettingsManagerProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(UsbUserSettingsManagerProto& a, UsbUserSettingsManagerProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbUserSettingsManagerProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbUserSettingsManagerProto* New() const final {
    return CreateMaybeMessage<UsbUserSettingsManagerProto>(nullptr);
  }

  UsbUserSettingsManagerProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbUserSettingsManagerProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbUserSettingsManagerProto& from);
  void MergeFrom(const UsbUserSettingsManagerProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbUserSettingsManagerProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbUserSettingsManagerProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceAttachedActivitiesFieldNumber = 4,
    kAccessoryAttachedActivitiesFieldNumber = 5,
    kUserIdFieldNumber = 1,
  };
  // repeated .android.service.usb.UsbDeviceAttachedActivities device_attached_activities = 4;
  int device_attached_activities_size() const;
  void clear_device_attached_activities();
  ::android::service::usb::UsbDeviceAttachedActivities* mutable_device_attached_activities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbDeviceAttachedActivities >*
      mutable_device_attached_activities();
  const ::android::service::usb::UsbDeviceAttachedActivities& device_attached_activities(int index) const;
  ::android::service::usb::UsbDeviceAttachedActivities* add_device_attached_activities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbDeviceAttachedActivities >&
      device_attached_activities() const;

  // repeated .android.service.usb.UsbAccessoryAttachedActivities accessory_attached_activities = 5;
  int accessory_attached_activities_size() const;
  void clear_accessory_attached_activities();
  ::android::service::usb::UsbAccessoryAttachedActivities* mutable_accessory_attached_activities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbAccessoryAttachedActivities >*
      mutable_accessory_attached_activities();
  const ::android::service::usb::UsbAccessoryAttachedActivities& accessory_attached_activities(int index) const;
  ::android::service::usb::UsbAccessoryAttachedActivities* add_accessory_attached_activities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbAccessoryAttachedActivities >&
      accessory_attached_activities() const;

  // optional int32 user_id = 1;
  bool has_user_id() const;
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::int32 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbUserSettingsManagerProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbDeviceAttachedActivities > device_attached_activities_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbAccessoryAttachedActivities > accessory_attached_activities_;
  ::PROTOBUF_NAMESPACE_ID::int32 user_id_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbProfileGroupSettingsManagerProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbProfileGroupSettingsManagerProto) */ {
 public:
  UsbProfileGroupSettingsManagerProto();
  virtual ~UsbProfileGroupSettingsManagerProto();

  UsbProfileGroupSettingsManagerProto(const UsbProfileGroupSettingsManagerProto& from);
  UsbProfileGroupSettingsManagerProto(UsbProfileGroupSettingsManagerProto&& from) noexcept
    : UsbProfileGroupSettingsManagerProto() {
    *this = ::std::move(from);
  }

  inline UsbProfileGroupSettingsManagerProto& operator=(const UsbProfileGroupSettingsManagerProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbProfileGroupSettingsManagerProto& operator=(UsbProfileGroupSettingsManagerProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbProfileGroupSettingsManagerProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbProfileGroupSettingsManagerProto* internal_default_instance() {
    return reinterpret_cast<const UsbProfileGroupSettingsManagerProto*>(
               &_UsbProfileGroupSettingsManagerProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(UsbProfileGroupSettingsManagerProto& a, UsbProfileGroupSettingsManagerProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbProfileGroupSettingsManagerProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbProfileGroupSettingsManagerProto* New() const final {
    return CreateMaybeMessage<UsbProfileGroupSettingsManagerProto>(nullptr);
  }

  UsbProfileGroupSettingsManagerProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbProfileGroupSettingsManagerProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbProfileGroupSettingsManagerProto& from);
  void MergeFrom(const UsbProfileGroupSettingsManagerProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbProfileGroupSettingsManagerProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbProfileGroupSettingsManagerProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicePreferencesFieldNumber = 2,
    kAccessoryPreferencesFieldNumber = 3,
    kParentUserIdFieldNumber = 1,
  };
  // repeated .android.service.usb.UsbSettingsDevicePreferenceProto device_preferences = 2;
  int device_preferences_size() const;
  void clear_device_preferences();
  ::android::service::usb::UsbSettingsDevicePreferenceProto* mutable_device_preferences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbSettingsDevicePreferenceProto >*
      mutable_device_preferences();
  const ::android::service::usb::UsbSettingsDevicePreferenceProto& device_preferences(int index) const;
  ::android::service::usb::UsbSettingsDevicePreferenceProto* add_device_preferences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbSettingsDevicePreferenceProto >&
      device_preferences() const;

  // repeated .android.service.usb.UsbSettingsAccessoryPreferenceProto accessory_preferences = 3;
  int accessory_preferences_size() const;
  void clear_accessory_preferences();
  ::android::service::usb::UsbSettingsAccessoryPreferenceProto* mutable_accessory_preferences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbSettingsAccessoryPreferenceProto >*
      mutable_accessory_preferences();
  const ::android::service::usb::UsbSettingsAccessoryPreferenceProto& accessory_preferences(int index) const;
  ::android::service::usb::UsbSettingsAccessoryPreferenceProto* add_accessory_preferences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbSettingsAccessoryPreferenceProto >&
      accessory_preferences() const;

  // optional int32 parent_user_id = 1;
  bool has_parent_user_id() const;
  void clear_parent_user_id();
  ::PROTOBUF_NAMESPACE_ID::int32 parent_user_id() const;
  void set_parent_user_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbProfileGroupSettingsManagerProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbSettingsDevicePreferenceProto > device_preferences_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbSettingsAccessoryPreferenceProto > accessory_preferences_;
  ::PROTOBUF_NAMESPACE_ID::int32 parent_user_id_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbSettingsDevicePreferenceProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbSettingsDevicePreferenceProto) */ {
 public:
  UsbSettingsDevicePreferenceProto();
  virtual ~UsbSettingsDevicePreferenceProto();

  UsbSettingsDevicePreferenceProto(const UsbSettingsDevicePreferenceProto& from);
  UsbSettingsDevicePreferenceProto(UsbSettingsDevicePreferenceProto&& from) noexcept
    : UsbSettingsDevicePreferenceProto() {
    *this = ::std::move(from);
  }

  inline UsbSettingsDevicePreferenceProto& operator=(const UsbSettingsDevicePreferenceProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbSettingsDevicePreferenceProto& operator=(UsbSettingsDevicePreferenceProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbSettingsDevicePreferenceProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbSettingsDevicePreferenceProto* internal_default_instance() {
    return reinterpret_cast<const UsbSettingsDevicePreferenceProto*>(
               &_UsbSettingsDevicePreferenceProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(UsbSettingsDevicePreferenceProto& a, UsbSettingsDevicePreferenceProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbSettingsDevicePreferenceProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbSettingsDevicePreferenceProto* New() const final {
    return CreateMaybeMessage<UsbSettingsDevicePreferenceProto>(nullptr);
  }

  UsbSettingsDevicePreferenceProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbSettingsDevicePreferenceProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbSettingsDevicePreferenceProto& from);
  void MergeFrom(const UsbSettingsDevicePreferenceProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbSettingsDevicePreferenceProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbSettingsDevicePreferenceProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 1,
    kUserPackageFieldNumber = 2,
  };
  // optional .android.service.usb.UsbDeviceFilterProto filter = 1;
  bool has_filter() const;
  void clear_filter();
  const ::android::service::usb::UsbDeviceFilterProto& filter() const;
  ::android::service::usb::UsbDeviceFilterProto* release_filter();
  ::android::service::usb::UsbDeviceFilterProto* mutable_filter();
  void set_allocated_filter(::android::service::usb::UsbDeviceFilterProto* filter);

  // optional .android.service.usb.UserPackageProto user_package = 2;
  bool has_user_package() const;
  void clear_user_package();
  const ::android::service::usb::UserPackageProto& user_package() const;
  ::android::service::usb::UserPackageProto* release_user_package();
  ::android::service::usb::UserPackageProto* mutable_user_package();
  void set_allocated_user_package(::android::service::usb::UserPackageProto* user_package);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbSettingsDevicePreferenceProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::android::service::usb::UsbDeviceFilterProto* filter_;
  ::android::service::usb::UserPackageProto* user_package_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbPermissionsManagerProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbPermissionsManagerProto) */ {
 public:
  UsbPermissionsManagerProto();
  virtual ~UsbPermissionsManagerProto();

  UsbPermissionsManagerProto(const UsbPermissionsManagerProto& from);
  UsbPermissionsManagerProto(UsbPermissionsManagerProto&& from) noexcept
    : UsbPermissionsManagerProto() {
    *this = ::std::move(from);
  }

  inline UsbPermissionsManagerProto& operator=(const UsbPermissionsManagerProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbPermissionsManagerProto& operator=(UsbPermissionsManagerProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbPermissionsManagerProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbPermissionsManagerProto* internal_default_instance() {
    return reinterpret_cast<const UsbPermissionsManagerProto*>(
               &_UsbPermissionsManagerProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(UsbPermissionsManagerProto& a, UsbPermissionsManagerProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbPermissionsManagerProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbPermissionsManagerProto* New() const final {
    return CreateMaybeMessage<UsbPermissionsManagerProto>(nullptr);
  }

  UsbPermissionsManagerProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbPermissionsManagerProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbPermissionsManagerProto& from);
  void MergeFrom(const UsbPermissionsManagerProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbPermissionsManagerProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbPermissionsManagerProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserPermissionsFieldNumber = 1,
  };
  // repeated .android.service.usb.UsbUserPermissionsManagerProto user_permissions = 1;
  int user_permissions_size() const;
  void clear_user_permissions();
  ::android::service::usb::UsbUserPermissionsManagerProto* mutable_user_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbUserPermissionsManagerProto >*
      mutable_user_permissions();
  const ::android::service::usb::UsbUserPermissionsManagerProto& user_permissions(int index) const;
  ::android::service::usb::UsbUserPermissionsManagerProto* add_user_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbUserPermissionsManagerProto >&
      user_permissions() const;

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbPermissionsManagerProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbUserPermissionsManagerProto > user_permissions_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbUserPermissionsManagerProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbUserPermissionsManagerProto) */ {
 public:
  UsbUserPermissionsManagerProto();
  virtual ~UsbUserPermissionsManagerProto();

  UsbUserPermissionsManagerProto(const UsbUserPermissionsManagerProto& from);
  UsbUserPermissionsManagerProto(UsbUserPermissionsManagerProto&& from) noexcept
    : UsbUserPermissionsManagerProto() {
    *this = ::std::move(from);
  }

  inline UsbUserPermissionsManagerProto& operator=(const UsbUserPermissionsManagerProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbUserPermissionsManagerProto& operator=(UsbUserPermissionsManagerProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbUserPermissionsManagerProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbUserPermissionsManagerProto* internal_default_instance() {
    return reinterpret_cast<const UsbUserPermissionsManagerProto*>(
               &_UsbUserPermissionsManagerProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(UsbUserPermissionsManagerProto& a, UsbUserPermissionsManagerProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbUserPermissionsManagerProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbUserPermissionsManagerProto* New() const final {
    return CreateMaybeMessage<UsbUserPermissionsManagerProto>(nullptr);
  }

  UsbUserPermissionsManagerProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbUserPermissionsManagerProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbUserPermissionsManagerProto& from);
  void MergeFrom(const UsbUserPermissionsManagerProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbUserPermissionsManagerProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbUserPermissionsManagerProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicePermissionsFieldNumber = 2,
    kAccessoryPermissionsFieldNumber = 3,
    kDevicePersistentPermissionsFieldNumber = 4,
    kAccessoryPersistentPermissionsFieldNumber = 5,
    kUserIdFieldNumber = 1,
  };
  // repeated .android.service.usb.UsbDevicePermissionProto device_permissions = 2;
  int device_permissions_size() const;
  void clear_device_permissions();
  ::android::service::usb::UsbDevicePermissionProto* mutable_device_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbDevicePermissionProto >*
      mutable_device_permissions();
  const ::android::service::usb::UsbDevicePermissionProto& device_permissions(int index) const;
  ::android::service::usb::UsbDevicePermissionProto* add_device_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbDevicePermissionProto >&
      device_permissions() const;

  // repeated .android.service.usb.UsbAccessoryPermissionProto accessory_permissions = 3;
  int accessory_permissions_size() const;
  void clear_accessory_permissions();
  ::android::service::usb::UsbAccessoryPermissionProto* mutable_accessory_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbAccessoryPermissionProto >*
      mutable_accessory_permissions();
  const ::android::service::usb::UsbAccessoryPermissionProto& accessory_permissions(int index) const;
  ::android::service::usb::UsbAccessoryPermissionProto* add_accessory_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbAccessoryPermissionProto >&
      accessory_permissions() const;

  // repeated .android.service.usb.UsbDevicePersistentPermissionProto device_persistent_permissions = 4;
  int device_persistent_permissions_size() const;
  void clear_device_persistent_permissions();
  ::android::service::usb::UsbDevicePersistentPermissionProto* mutable_device_persistent_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbDevicePersistentPermissionProto >*
      mutable_device_persistent_permissions();
  const ::android::service::usb::UsbDevicePersistentPermissionProto& device_persistent_permissions(int index) const;
  ::android::service::usb::UsbDevicePersistentPermissionProto* add_device_persistent_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbDevicePersistentPermissionProto >&
      device_persistent_permissions() const;

  // repeated .android.service.usb.UsbAccessoryPersistentPermissionProto accessory_persistent_permissions = 5;
  int accessory_persistent_permissions_size() const;
  void clear_accessory_persistent_permissions();
  ::android::service::usb::UsbAccessoryPersistentPermissionProto* mutable_accessory_persistent_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbAccessoryPersistentPermissionProto >*
      mutable_accessory_persistent_permissions();
  const ::android::service::usb::UsbAccessoryPersistentPermissionProto& accessory_persistent_permissions(int index) const;
  ::android::service::usb::UsbAccessoryPersistentPermissionProto* add_accessory_persistent_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbAccessoryPersistentPermissionProto >&
      accessory_persistent_permissions() const;

  // optional int32 user_id = 1;
  bool has_user_id() const;
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::int32 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbUserPermissionsManagerProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbDevicePermissionProto > device_permissions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbAccessoryPermissionProto > accessory_permissions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbDevicePersistentPermissionProto > device_persistent_permissions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbAccessoryPersistentPermissionProto > accessory_persistent_permissions_;
  ::PROTOBUF_NAMESPACE_ID::int32 user_id_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbDevicePermissionProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbDevicePermissionProto) */ {
 public:
  UsbDevicePermissionProto();
  virtual ~UsbDevicePermissionProto();

  UsbDevicePermissionProto(const UsbDevicePermissionProto& from);
  UsbDevicePermissionProto(UsbDevicePermissionProto&& from) noexcept
    : UsbDevicePermissionProto() {
    *this = ::std::move(from);
  }

  inline UsbDevicePermissionProto& operator=(const UsbDevicePermissionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbDevicePermissionProto& operator=(UsbDevicePermissionProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbDevicePermissionProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbDevicePermissionProto* internal_default_instance() {
    return reinterpret_cast<const UsbDevicePermissionProto*>(
               &_UsbDevicePermissionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(UsbDevicePermissionProto& a, UsbDevicePermissionProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbDevicePermissionProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbDevicePermissionProto* New() const final {
    return CreateMaybeMessage<UsbDevicePermissionProto>(nullptr);
  }

  UsbDevicePermissionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbDevicePermissionProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbDevicePermissionProto& from);
  void MergeFrom(const UsbDevicePermissionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbDevicePermissionProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbDevicePermissionProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidsFieldNumber = 2,
    kDeviceNameFieldNumber = 1,
  };
  // repeated int32 uids = 2;
  int uids_size() const;
  void clear_uids();
  ::PROTOBUF_NAMESPACE_ID::int32 uids(int index) const;
  void set_uids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_uids(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      uids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_uids();

  // optional string device_name = 1;
  bool has_device_name() const;
  void clear_device_name();
  const std::string& device_name() const;
  void set_device_name(const std::string& value);
  void set_device_name(std::string&& value);
  void set_device_name(const char* value);
  void set_device_name(const char* value, size_t size);
  std::string* mutable_device_name();
  std::string* release_device_name();
  void set_allocated_device_name(std::string* device_name);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbDevicePermissionProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > uids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_name_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbAccessoryPermissionProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbAccessoryPermissionProto) */ {
 public:
  UsbAccessoryPermissionProto();
  virtual ~UsbAccessoryPermissionProto();

  UsbAccessoryPermissionProto(const UsbAccessoryPermissionProto& from);
  UsbAccessoryPermissionProto(UsbAccessoryPermissionProto&& from) noexcept
    : UsbAccessoryPermissionProto() {
    *this = ::std::move(from);
  }

  inline UsbAccessoryPermissionProto& operator=(const UsbAccessoryPermissionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbAccessoryPermissionProto& operator=(UsbAccessoryPermissionProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbAccessoryPermissionProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbAccessoryPermissionProto* internal_default_instance() {
    return reinterpret_cast<const UsbAccessoryPermissionProto*>(
               &_UsbAccessoryPermissionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(UsbAccessoryPermissionProto& a, UsbAccessoryPermissionProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbAccessoryPermissionProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbAccessoryPermissionProto* New() const final {
    return CreateMaybeMessage<UsbAccessoryPermissionProto>(nullptr);
  }

  UsbAccessoryPermissionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbAccessoryPermissionProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbAccessoryPermissionProto& from);
  void MergeFrom(const UsbAccessoryPermissionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbAccessoryPermissionProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbAccessoryPermissionProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidsFieldNumber = 2,
    kAccessoryDescriptionFieldNumber = 1,
  };
  // repeated int32 uids = 2;
  int uids_size() const;
  void clear_uids();
  ::PROTOBUF_NAMESPACE_ID::int32 uids(int index) const;
  void set_uids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_uids(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      uids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_uids();

  // optional string accessory_description = 1;
  bool has_accessory_description() const;
  void clear_accessory_description();
  const std::string& accessory_description() const;
  void set_accessory_description(const std::string& value);
  void set_accessory_description(std::string&& value);
  void set_accessory_description(const char* value);
  void set_accessory_description(const char* value, size_t size);
  std::string* mutable_accessory_description();
  std::string* release_accessory_description();
  void set_allocated_accessory_description(std::string* accessory_description);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbAccessoryPermissionProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > uids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accessory_description_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbDevicePersistentPermissionProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbDevicePersistentPermissionProto) */ {
 public:
  UsbDevicePersistentPermissionProto();
  virtual ~UsbDevicePersistentPermissionProto();

  UsbDevicePersistentPermissionProto(const UsbDevicePersistentPermissionProto& from);
  UsbDevicePersistentPermissionProto(UsbDevicePersistentPermissionProto&& from) noexcept
    : UsbDevicePersistentPermissionProto() {
    *this = ::std::move(from);
  }

  inline UsbDevicePersistentPermissionProto& operator=(const UsbDevicePersistentPermissionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbDevicePersistentPermissionProto& operator=(UsbDevicePersistentPermissionProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbDevicePersistentPermissionProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbDevicePersistentPermissionProto* internal_default_instance() {
    return reinterpret_cast<const UsbDevicePersistentPermissionProto*>(
               &_UsbDevicePersistentPermissionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(UsbDevicePersistentPermissionProto& a, UsbDevicePersistentPermissionProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbDevicePersistentPermissionProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbDevicePersistentPermissionProto* New() const final {
    return CreateMaybeMessage<UsbDevicePersistentPermissionProto>(nullptr);
  }

  UsbDevicePersistentPermissionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbDevicePersistentPermissionProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbDevicePersistentPermissionProto& from);
  void MergeFrom(const UsbDevicePersistentPermissionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbDevicePersistentPermissionProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbDevicePersistentPermissionProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionValuesFieldNumber = 2,
    kDeviceFilterFieldNumber = 1,
  };
  // repeated .android.service.usb.UsbUidPermissionProto permission_values = 2;
  int permission_values_size() const;
  void clear_permission_values();
  ::android::service::usb::UsbUidPermissionProto* mutable_permission_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbUidPermissionProto >*
      mutable_permission_values();
  const ::android::service::usb::UsbUidPermissionProto& permission_values(int index) const;
  ::android::service::usb::UsbUidPermissionProto* add_permission_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbUidPermissionProto >&
      permission_values() const;

  // optional .android.service.usb.UsbDeviceFilterProto device_filter = 1;
  bool has_device_filter() const;
  void clear_device_filter();
  const ::android::service::usb::UsbDeviceFilterProto& device_filter() const;
  ::android::service::usb::UsbDeviceFilterProto* release_device_filter();
  ::android::service::usb::UsbDeviceFilterProto* mutable_device_filter();
  void set_allocated_device_filter(::android::service::usb::UsbDeviceFilterProto* device_filter);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbDevicePersistentPermissionProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbUidPermissionProto > permission_values_;
  ::android::service::usb::UsbDeviceFilterProto* device_filter_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbAccessoryPersistentPermissionProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbAccessoryPersistentPermissionProto) */ {
 public:
  UsbAccessoryPersistentPermissionProto();
  virtual ~UsbAccessoryPersistentPermissionProto();

  UsbAccessoryPersistentPermissionProto(const UsbAccessoryPersistentPermissionProto& from);
  UsbAccessoryPersistentPermissionProto(UsbAccessoryPersistentPermissionProto&& from) noexcept
    : UsbAccessoryPersistentPermissionProto() {
    *this = ::std::move(from);
  }

  inline UsbAccessoryPersistentPermissionProto& operator=(const UsbAccessoryPersistentPermissionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbAccessoryPersistentPermissionProto& operator=(UsbAccessoryPersistentPermissionProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbAccessoryPersistentPermissionProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbAccessoryPersistentPermissionProto* internal_default_instance() {
    return reinterpret_cast<const UsbAccessoryPersistentPermissionProto*>(
               &_UsbAccessoryPersistentPermissionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(UsbAccessoryPersistentPermissionProto& a, UsbAccessoryPersistentPermissionProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbAccessoryPersistentPermissionProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbAccessoryPersistentPermissionProto* New() const final {
    return CreateMaybeMessage<UsbAccessoryPersistentPermissionProto>(nullptr);
  }

  UsbAccessoryPersistentPermissionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbAccessoryPersistentPermissionProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbAccessoryPersistentPermissionProto& from);
  void MergeFrom(const UsbAccessoryPersistentPermissionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbAccessoryPersistentPermissionProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbAccessoryPersistentPermissionProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionValuesFieldNumber = 2,
    kAccessoryFilterFieldNumber = 1,
  };
  // repeated .android.service.usb.UsbUidPermissionProto permission_values = 2;
  int permission_values_size() const;
  void clear_permission_values();
  ::android::service::usb::UsbUidPermissionProto* mutable_permission_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbUidPermissionProto >*
      mutable_permission_values();
  const ::android::service::usb::UsbUidPermissionProto& permission_values(int index) const;
  ::android::service::usb::UsbUidPermissionProto* add_permission_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbUidPermissionProto >&
      permission_values() const;

  // optional .android.service.usb.UsbAccessoryFilterProto accessory_filter = 1;
  bool has_accessory_filter() const;
  void clear_accessory_filter();
  const ::android::service::usb::UsbAccessoryFilterProto& accessory_filter() const;
  ::android::service::usb::UsbAccessoryFilterProto* release_accessory_filter();
  ::android::service::usb::UsbAccessoryFilterProto* mutable_accessory_filter();
  void set_allocated_accessory_filter(::android::service::usb::UsbAccessoryFilterProto* accessory_filter);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbAccessoryPersistentPermissionProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbUidPermissionProto > permission_values_;
  ::android::service::usb::UsbAccessoryFilterProto* accessory_filter_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbUidPermissionProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbUidPermissionProto) */ {
 public:
  UsbUidPermissionProto();
  virtual ~UsbUidPermissionProto();

  UsbUidPermissionProto(const UsbUidPermissionProto& from);
  UsbUidPermissionProto(UsbUidPermissionProto&& from) noexcept
    : UsbUidPermissionProto() {
    *this = ::std::move(from);
  }

  inline UsbUidPermissionProto& operator=(const UsbUidPermissionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbUidPermissionProto& operator=(UsbUidPermissionProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbUidPermissionProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbUidPermissionProto* internal_default_instance() {
    return reinterpret_cast<const UsbUidPermissionProto*>(
               &_UsbUidPermissionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(UsbUidPermissionProto& a, UsbUidPermissionProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbUidPermissionProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbUidPermissionProto* New() const final {
    return CreateMaybeMessage<UsbUidPermissionProto>(nullptr);
  }

  UsbUidPermissionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbUidPermissionProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbUidPermissionProto& from);
  void MergeFrom(const UsbUidPermissionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbUidPermissionProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbUidPermissionProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kIsGrantedFieldNumber = 2,
  };
  // optional int32 uid = 1;
  bool has_uid() const;
  void clear_uid();
  ::PROTOBUF_NAMESPACE_ID::int32 uid() const;
  void set_uid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional bool is_granted = 2;
  bool has_is_granted() const;
  void clear_is_granted();
  bool is_granted() const;
  void set_is_granted(bool value);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbUidPermissionProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 uid_;
  bool is_granted_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbDeviceFilterProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbDeviceFilterProto) */ {
 public:
  UsbDeviceFilterProto();
  virtual ~UsbDeviceFilterProto();

  UsbDeviceFilterProto(const UsbDeviceFilterProto& from);
  UsbDeviceFilterProto(UsbDeviceFilterProto&& from) noexcept
    : UsbDeviceFilterProto() {
    *this = ::std::move(from);
  }

  inline UsbDeviceFilterProto& operator=(const UsbDeviceFilterProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbDeviceFilterProto& operator=(UsbDeviceFilterProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbDeviceFilterProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbDeviceFilterProto* internal_default_instance() {
    return reinterpret_cast<const UsbDeviceFilterProto*>(
               &_UsbDeviceFilterProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(UsbDeviceFilterProto& a, UsbDeviceFilterProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbDeviceFilterProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbDeviceFilterProto* New() const final {
    return CreateMaybeMessage<UsbDeviceFilterProto>(nullptr);
  }

  UsbDeviceFilterProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbDeviceFilterProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbDeviceFilterProto& from);
  void MergeFrom(const UsbDeviceFilterProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbDeviceFilterProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbDeviceFilterProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kManufacturerNameFieldNumber = 6,
    kProductNameFieldNumber = 7,
    kSerialNumberFieldNumber = 8,
    kVendorIdFieldNumber = 1,
    kProductIdFieldNumber = 2,
    kClassFieldNumber = 3,
    kSubclassFieldNumber = 4,
    kProtocolFieldNumber = 5,
  };
  // optional string manufacturer_name = 6;
  bool has_manufacturer_name() const;
  void clear_manufacturer_name();
  const std::string& manufacturer_name() const;
  void set_manufacturer_name(const std::string& value);
  void set_manufacturer_name(std::string&& value);
  void set_manufacturer_name(const char* value);
  void set_manufacturer_name(const char* value, size_t size);
  std::string* mutable_manufacturer_name();
  std::string* release_manufacturer_name();
  void set_allocated_manufacturer_name(std::string* manufacturer_name);

  // optional string product_name = 7;
  bool has_product_name() const;
  void clear_product_name();
  const std::string& product_name() const;
  void set_product_name(const std::string& value);
  void set_product_name(std::string&& value);
  void set_product_name(const char* value);
  void set_product_name(const char* value, size_t size);
  std::string* mutable_product_name();
  std::string* release_product_name();
  void set_allocated_product_name(std::string* product_name);

  // optional string serial_number = 8 [(.android.privacy) = {
  bool has_serial_number() const;
  void clear_serial_number();
  const std::string& serial_number() const;
  void set_serial_number(const std::string& value);
  void set_serial_number(std::string&& value);
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  std::string* mutable_serial_number();
  std::string* release_serial_number();
  void set_allocated_serial_number(std::string* serial_number);

  // optional int32 vendor_id = 1;
  bool has_vendor_id() const;
  void clear_vendor_id();
  ::PROTOBUF_NAMESPACE_ID::int32 vendor_id() const;
  void set_vendor_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 product_id = 2;
  bool has_product_id() const;
  void clear_product_id();
  ::PROTOBUF_NAMESPACE_ID::int32 product_id() const;
  void set_product_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 class = 3;
  bool has_class_() const;
  void clear_class_();
  ::PROTOBUF_NAMESPACE_ID::int32 class_() const;
  void set_class_(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 subclass = 4;
  bool has_subclass() const;
  void clear_subclass();
  ::PROTOBUF_NAMESPACE_ID::int32 subclass() const;
  void set_subclass(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 protocol = 5;
  bool has_protocol() const;
  void clear_protocol();
  ::PROTOBUF_NAMESPACE_ID::int32 protocol() const;
  void set_protocol(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbDeviceFilterProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacturer_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_number_;
  ::PROTOBUF_NAMESPACE_ID::int32 vendor_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 product_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 class__;
  ::PROTOBUF_NAMESPACE_ID::int32 subclass_;
  ::PROTOBUF_NAMESPACE_ID::int32 protocol_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UserPackageProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UserPackageProto) */ {
 public:
  UserPackageProto();
  virtual ~UserPackageProto();

  UserPackageProto(const UserPackageProto& from);
  UserPackageProto(UserPackageProto&& from) noexcept
    : UserPackageProto() {
    *this = ::std::move(from);
  }

  inline UserPackageProto& operator=(const UserPackageProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserPackageProto& operator=(UserPackageProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UserPackageProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserPackageProto* internal_default_instance() {
    return reinterpret_cast<const UserPackageProto*>(
               &_UserPackageProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(UserPackageProto& a, UserPackageProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UserPackageProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserPackageProto* New() const final {
    return CreateMaybeMessage<UserPackageProto>(nullptr);
  }

  UserPackageProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserPackageProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UserPackageProto& from);
  void MergeFrom(const UserPackageProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserPackageProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UserPackageProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackageNameFieldNumber = 2,
    kUserIdFieldNumber = 1,
  };
  // optional string package_name = 2;
  bool has_package_name() const;
  void clear_package_name();
  const std::string& package_name() const;
  void set_package_name(const std::string& value);
  void set_package_name(std::string&& value);
  void set_package_name(const char* value);
  void set_package_name(const char* value, size_t size);
  std::string* mutable_package_name();
  std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);

  // optional int32 user_id = 1;
  bool has_user_id() const;
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::int32 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:android.service.usb.UserPackageProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
  ::PROTOBUF_NAMESPACE_ID::int32 user_id_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbSettingsAccessoryPreferenceProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbSettingsAccessoryPreferenceProto) */ {
 public:
  UsbSettingsAccessoryPreferenceProto();
  virtual ~UsbSettingsAccessoryPreferenceProto();

  UsbSettingsAccessoryPreferenceProto(const UsbSettingsAccessoryPreferenceProto& from);
  UsbSettingsAccessoryPreferenceProto(UsbSettingsAccessoryPreferenceProto&& from) noexcept
    : UsbSettingsAccessoryPreferenceProto() {
    *this = ::std::move(from);
  }

  inline UsbSettingsAccessoryPreferenceProto& operator=(const UsbSettingsAccessoryPreferenceProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbSettingsAccessoryPreferenceProto& operator=(UsbSettingsAccessoryPreferenceProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbSettingsAccessoryPreferenceProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbSettingsAccessoryPreferenceProto* internal_default_instance() {
    return reinterpret_cast<const UsbSettingsAccessoryPreferenceProto*>(
               &_UsbSettingsAccessoryPreferenceProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(UsbSettingsAccessoryPreferenceProto& a, UsbSettingsAccessoryPreferenceProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbSettingsAccessoryPreferenceProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbSettingsAccessoryPreferenceProto* New() const final {
    return CreateMaybeMessage<UsbSettingsAccessoryPreferenceProto>(nullptr);
  }

  UsbSettingsAccessoryPreferenceProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbSettingsAccessoryPreferenceProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbSettingsAccessoryPreferenceProto& from);
  void MergeFrom(const UsbSettingsAccessoryPreferenceProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbSettingsAccessoryPreferenceProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbSettingsAccessoryPreferenceProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 1,
    kUserPackageFieldNumber = 2,
  };
  // optional .android.service.usb.UsbAccessoryFilterProto filter = 1;
  bool has_filter() const;
  void clear_filter();
  const ::android::service::usb::UsbAccessoryFilterProto& filter() const;
  ::android::service::usb::UsbAccessoryFilterProto* release_filter();
  ::android::service::usb::UsbAccessoryFilterProto* mutable_filter();
  void set_allocated_filter(::android::service::usb::UsbAccessoryFilterProto* filter);

  // optional .android.service.usb.UserPackageProto user_package = 2;
  bool has_user_package() const;
  void clear_user_package();
  const ::android::service::usb::UserPackageProto& user_package() const;
  ::android::service::usb::UserPackageProto* release_user_package();
  ::android::service::usb::UserPackageProto* mutable_user_package();
  void set_allocated_user_package(::android::service::usb::UserPackageProto* user_package);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbSettingsAccessoryPreferenceProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::android::service::usb::UsbAccessoryFilterProto* filter_;
  ::android::service::usb::UserPackageProto* user_package_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbAccessoryFilterProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbAccessoryFilterProto) */ {
 public:
  UsbAccessoryFilterProto();
  virtual ~UsbAccessoryFilterProto();

  UsbAccessoryFilterProto(const UsbAccessoryFilterProto& from);
  UsbAccessoryFilterProto(UsbAccessoryFilterProto&& from) noexcept
    : UsbAccessoryFilterProto() {
    *this = ::std::move(from);
  }

  inline UsbAccessoryFilterProto& operator=(const UsbAccessoryFilterProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbAccessoryFilterProto& operator=(UsbAccessoryFilterProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbAccessoryFilterProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbAccessoryFilterProto* internal_default_instance() {
    return reinterpret_cast<const UsbAccessoryFilterProto*>(
               &_UsbAccessoryFilterProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(UsbAccessoryFilterProto& a, UsbAccessoryFilterProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbAccessoryFilterProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbAccessoryFilterProto* New() const final {
    return CreateMaybeMessage<UsbAccessoryFilterProto>(nullptr);
  }

  UsbAccessoryFilterProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbAccessoryFilterProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbAccessoryFilterProto& from);
  void MergeFrom(const UsbAccessoryFilterProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbAccessoryFilterProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbAccessoryFilterProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kManufacturerFieldNumber = 1,
    kModelFieldNumber = 2,
    kVersionFieldNumber = 3,
  };
  // optional string manufacturer = 1;
  bool has_manufacturer() const;
  void clear_manufacturer();
  const std::string& manufacturer() const;
  void set_manufacturer(const std::string& value);
  void set_manufacturer(std::string&& value);
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  std::string* mutable_manufacturer();
  std::string* release_manufacturer();
  void set_allocated_manufacturer(std::string* manufacturer);

  // optional string model = 2;
  bool has_model() const;
  void clear_model();
  const std::string& model() const;
  void set_model(const std::string& value);
  void set_model(std::string&& value);
  void set_model(const char* value);
  void set_model(const char* value, size_t size);
  std::string* mutable_model();
  std::string* release_model();
  void set_allocated_model(std::string* model);

  // optional string version = 3;
  bool has_version() const;
  void clear_version();
  const std::string& version() const;
  void set_version(const std::string& value);
  void set_version(std::string&& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  std::string* mutable_version();
  std::string* release_version();
  void set_allocated_version(std::string* version);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbAccessoryFilterProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacturer_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbDeviceAttachedActivities :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbDeviceAttachedActivities) */ {
 public:
  UsbDeviceAttachedActivities();
  virtual ~UsbDeviceAttachedActivities();

  UsbDeviceAttachedActivities(const UsbDeviceAttachedActivities& from);
  UsbDeviceAttachedActivities(UsbDeviceAttachedActivities&& from) noexcept
    : UsbDeviceAttachedActivities() {
    *this = ::std::move(from);
  }

  inline UsbDeviceAttachedActivities& operator=(const UsbDeviceAttachedActivities& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbDeviceAttachedActivities& operator=(UsbDeviceAttachedActivities&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbDeviceAttachedActivities& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbDeviceAttachedActivities* internal_default_instance() {
    return reinterpret_cast<const UsbDeviceAttachedActivities*>(
               &_UsbDeviceAttachedActivities_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(UsbDeviceAttachedActivities& a, UsbDeviceAttachedActivities& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbDeviceAttachedActivities* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbDeviceAttachedActivities* New() const final {
    return CreateMaybeMessage<UsbDeviceAttachedActivities>(nullptr);
  }

  UsbDeviceAttachedActivities* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbDeviceAttachedActivities>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbDeviceAttachedActivities& from);
  void MergeFrom(const UsbDeviceAttachedActivities& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbDeviceAttachedActivities* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbDeviceAttachedActivities";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 2,
    kActivityFieldNumber = 1,
  };
  // repeated .android.service.usb.UsbDeviceFilterProto filters = 2;
  int filters_size() const;
  void clear_filters();
  ::android::service::usb::UsbDeviceFilterProto* mutable_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbDeviceFilterProto >*
      mutable_filters();
  const ::android::service::usb::UsbDeviceFilterProto& filters(int index) const;
  ::android::service::usb::UsbDeviceFilterProto* add_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbDeviceFilterProto >&
      filters() const;

  // optional .android.content.ComponentNameProto activity = 1;
  bool has_activity() const;
  void clear_activity();
  const ::android::content::ComponentNameProto& activity() const;
  ::android::content::ComponentNameProto* release_activity();
  ::android::content::ComponentNameProto* mutable_activity();
  void set_allocated_activity(::android::content::ComponentNameProto* activity);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbDeviceAttachedActivities)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbDeviceFilterProto > filters_;
  ::android::content::ComponentNameProto* activity_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// -------------------------------------------------------------------

class UsbAccessoryAttachedActivities :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.service.usb.UsbAccessoryAttachedActivities) */ {
 public:
  UsbAccessoryAttachedActivities();
  virtual ~UsbAccessoryAttachedActivities();

  UsbAccessoryAttachedActivities(const UsbAccessoryAttachedActivities& from);
  UsbAccessoryAttachedActivities(UsbAccessoryAttachedActivities&& from) noexcept
    : UsbAccessoryAttachedActivities() {
    *this = ::std::move(from);
  }

  inline UsbAccessoryAttachedActivities& operator=(const UsbAccessoryAttachedActivities& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbAccessoryAttachedActivities& operator=(UsbAccessoryAttachedActivities&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsbAccessoryAttachedActivities& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsbAccessoryAttachedActivities* internal_default_instance() {
    return reinterpret_cast<const UsbAccessoryAttachedActivities*>(
               &_UsbAccessoryAttachedActivities_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(UsbAccessoryAttachedActivities& a, UsbAccessoryAttachedActivities& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbAccessoryAttachedActivities* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsbAccessoryAttachedActivities* New() const final {
    return CreateMaybeMessage<UsbAccessoryAttachedActivities>(nullptr);
  }

  UsbAccessoryAttachedActivities* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsbAccessoryAttachedActivities>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsbAccessoryAttachedActivities& from);
  void MergeFrom(const UsbAccessoryAttachedActivities& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsbAccessoryAttachedActivities* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.service.usb.UsbAccessoryAttachedActivities";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto);
    return ::descriptor_table_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 2,
    kActivityFieldNumber = 1,
  };
  // repeated .android.service.usb.UsbAccessoryFilterProto filters = 2;
  int filters_size() const;
  void clear_filters();
  ::android::service::usb::UsbAccessoryFilterProto* mutable_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbAccessoryFilterProto >*
      mutable_filters();
  const ::android::service::usb::UsbAccessoryFilterProto& filters(int index) const;
  ::android::service::usb::UsbAccessoryFilterProto* add_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbAccessoryFilterProto >&
      filters() const;

  // optional .android.content.ComponentNameProto activity = 1;
  bool has_activity() const;
  void clear_activity();
  const ::android::content::ComponentNameProto& activity() const;
  ::android::content::ComponentNameProto* release_activity();
  ::android::content::ComponentNameProto* mutable_activity();
  void set_allocated_activity(::android::content::ComponentNameProto* activity);

  // @@protoc_insertion_point(class_scope:android.service.usb.UsbAccessoryAttachedActivities)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbAccessoryFilterProto > filters_;
  ::android::content::ComponentNameProto* activity_;
  friend struct ::TableStruct_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UsbServiceDumpProto

// optional .android.service.usb.UsbDeviceManagerProto device_manager = 1;
inline bool UsbServiceDumpProto::has_device_manager() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbServiceDumpProto::clear_device_manager() {
  if (device_manager_ != nullptr) device_manager_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::android::service::usb::UsbDeviceManagerProto& UsbServiceDumpProto::device_manager() const {
  const ::android::service::usb::UsbDeviceManagerProto* p = device_manager_;
  // @@protoc_insertion_point(field_get:android.service.usb.UsbServiceDumpProto.device_manager)
  return p != nullptr ? *p : *reinterpret_cast<const ::android::service::usb::UsbDeviceManagerProto*>(
      &::android::service::usb::_UsbDeviceManagerProto_default_instance_);
}
inline ::android::service::usb::UsbDeviceManagerProto* UsbServiceDumpProto::release_device_manager() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbServiceDumpProto.device_manager)
  _has_bits_[0] &= ~0x00000001u;
  ::android::service::usb::UsbDeviceManagerProto* temp = device_manager_;
  device_manager_ = nullptr;
  return temp;
}
inline ::android::service::usb::UsbDeviceManagerProto* UsbServiceDumpProto::mutable_device_manager() {
  _has_bits_[0] |= 0x00000001u;
  if (device_manager_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::service::usb::UsbDeviceManagerProto>(GetArenaNoVirtual());
    device_manager_ = p;
  }
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbServiceDumpProto.device_manager)
  return device_manager_;
}
inline void UsbServiceDumpProto::set_allocated_device_manager(::android::service::usb::UsbDeviceManagerProto* device_manager) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete device_manager_;
  }
  if (device_manager) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      device_manager = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_manager, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  device_manager_ = device_manager;
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbServiceDumpProto.device_manager)
}

// optional .android.service.usb.UsbHostManagerProto host_manager = 2;
inline bool UsbServiceDumpProto::has_host_manager() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsbServiceDumpProto::clear_host_manager() {
  if (host_manager_ != nullptr) host_manager_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::android::service::usb::UsbHostManagerProto& UsbServiceDumpProto::host_manager() const {
  const ::android::service::usb::UsbHostManagerProto* p = host_manager_;
  // @@protoc_insertion_point(field_get:android.service.usb.UsbServiceDumpProto.host_manager)
  return p != nullptr ? *p : *reinterpret_cast<const ::android::service::usb::UsbHostManagerProto*>(
      &::android::service::usb::_UsbHostManagerProto_default_instance_);
}
inline ::android::service::usb::UsbHostManagerProto* UsbServiceDumpProto::release_host_manager() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbServiceDumpProto.host_manager)
  _has_bits_[0] &= ~0x00000002u;
  ::android::service::usb::UsbHostManagerProto* temp = host_manager_;
  host_manager_ = nullptr;
  return temp;
}
inline ::android::service::usb::UsbHostManagerProto* UsbServiceDumpProto::mutable_host_manager() {
  _has_bits_[0] |= 0x00000002u;
  if (host_manager_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::service::usb::UsbHostManagerProto>(GetArenaNoVirtual());
    host_manager_ = p;
  }
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbServiceDumpProto.host_manager)
  return host_manager_;
}
inline void UsbServiceDumpProto::set_allocated_host_manager(::android::service::usb::UsbHostManagerProto* host_manager) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete host_manager_;
  }
  if (host_manager) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      host_manager = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, host_manager, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  host_manager_ = host_manager;
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbServiceDumpProto.host_manager)
}

// optional .android.service.usb.UsbPortManagerProto port_manager = 3;
inline bool UsbServiceDumpProto::has_port_manager() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UsbServiceDumpProto::clear_port_manager() {
  if (port_manager_ != nullptr) port_manager_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::android::service::usb::UsbPortManagerProto& UsbServiceDumpProto::port_manager() const {
  const ::android::service::usb::UsbPortManagerProto* p = port_manager_;
  // @@protoc_insertion_point(field_get:android.service.usb.UsbServiceDumpProto.port_manager)
  return p != nullptr ? *p : *reinterpret_cast<const ::android::service::usb::UsbPortManagerProto*>(
      &::android::service::usb::_UsbPortManagerProto_default_instance_);
}
inline ::android::service::usb::UsbPortManagerProto* UsbServiceDumpProto::release_port_manager() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbServiceDumpProto.port_manager)
  _has_bits_[0] &= ~0x00000004u;
  ::android::service::usb::UsbPortManagerProto* temp = port_manager_;
  port_manager_ = nullptr;
  return temp;
}
inline ::android::service::usb::UsbPortManagerProto* UsbServiceDumpProto::mutable_port_manager() {
  _has_bits_[0] |= 0x00000004u;
  if (port_manager_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::service::usb::UsbPortManagerProto>(GetArenaNoVirtual());
    port_manager_ = p;
  }
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbServiceDumpProto.port_manager)
  return port_manager_;
}
inline void UsbServiceDumpProto::set_allocated_port_manager(::android::service::usb::UsbPortManagerProto* port_manager) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete port_manager_;
  }
  if (port_manager) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      port_manager = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, port_manager, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  port_manager_ = port_manager;
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbServiceDumpProto.port_manager)
}

// optional .android.service.usb.UsbAlsaManagerProto alsa_manager = 4;
inline bool UsbServiceDumpProto::has_alsa_manager() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UsbServiceDumpProto::clear_alsa_manager() {
  if (alsa_manager_ != nullptr) alsa_manager_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::android::service::usb::UsbAlsaManagerProto& UsbServiceDumpProto::alsa_manager() const {
  const ::android::service::usb::UsbAlsaManagerProto* p = alsa_manager_;
  // @@protoc_insertion_point(field_get:android.service.usb.UsbServiceDumpProto.alsa_manager)
  return p != nullptr ? *p : *reinterpret_cast<const ::android::service::usb::UsbAlsaManagerProto*>(
      &::android::service::usb::_UsbAlsaManagerProto_default_instance_);
}
inline ::android::service::usb::UsbAlsaManagerProto* UsbServiceDumpProto::release_alsa_manager() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbServiceDumpProto.alsa_manager)
  _has_bits_[0] &= ~0x00000008u;
  ::android::service::usb::UsbAlsaManagerProto* temp = alsa_manager_;
  alsa_manager_ = nullptr;
  return temp;
}
inline ::android::service::usb::UsbAlsaManagerProto* UsbServiceDumpProto::mutable_alsa_manager() {
  _has_bits_[0] |= 0x00000008u;
  if (alsa_manager_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::service::usb::UsbAlsaManagerProto>(GetArenaNoVirtual());
    alsa_manager_ = p;
  }
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbServiceDumpProto.alsa_manager)
  return alsa_manager_;
}
inline void UsbServiceDumpProto::set_allocated_alsa_manager(::android::service::usb::UsbAlsaManagerProto* alsa_manager) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete alsa_manager_;
  }
  if (alsa_manager) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      alsa_manager = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, alsa_manager, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  alsa_manager_ = alsa_manager;
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbServiceDumpProto.alsa_manager)
}

// optional .android.service.usb.UsbSettingsManagerProto settings_manager = 5;
inline bool UsbServiceDumpProto::has_settings_manager() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UsbServiceDumpProto::clear_settings_manager() {
  if (settings_manager_ != nullptr) settings_manager_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::android::service::usb::UsbSettingsManagerProto& UsbServiceDumpProto::settings_manager() const {
  const ::android::service::usb::UsbSettingsManagerProto* p = settings_manager_;
  // @@protoc_insertion_point(field_get:android.service.usb.UsbServiceDumpProto.settings_manager)
  return p != nullptr ? *p : *reinterpret_cast<const ::android::service::usb::UsbSettingsManagerProto*>(
      &::android::service::usb::_UsbSettingsManagerProto_default_instance_);
}
inline ::android::service::usb::UsbSettingsManagerProto* UsbServiceDumpProto::release_settings_manager() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbServiceDumpProto.settings_manager)
  _has_bits_[0] &= ~0x00000010u;
  ::android::service::usb::UsbSettingsManagerProto* temp = settings_manager_;
  settings_manager_ = nullptr;
  return temp;
}
inline ::android::service::usb::UsbSettingsManagerProto* UsbServiceDumpProto::mutable_settings_manager() {
  _has_bits_[0] |= 0x00000010u;
  if (settings_manager_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::service::usb::UsbSettingsManagerProto>(GetArenaNoVirtual());
    settings_manager_ = p;
  }
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbServiceDumpProto.settings_manager)
  return settings_manager_;
}
inline void UsbServiceDumpProto::set_allocated_settings_manager(::android::service::usb::UsbSettingsManagerProto* settings_manager) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete settings_manager_;
  }
  if (settings_manager) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      settings_manager = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, settings_manager, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  settings_manager_ = settings_manager;
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbServiceDumpProto.settings_manager)
}

// optional .android.service.usb.UsbPermissionsManagerProto permissions_manager = 6;
inline bool UsbServiceDumpProto::has_permissions_manager() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UsbServiceDumpProto::clear_permissions_manager() {
  if (permissions_manager_ != nullptr) permissions_manager_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::android::service::usb::UsbPermissionsManagerProto& UsbServiceDumpProto::permissions_manager() const {
  const ::android::service::usb::UsbPermissionsManagerProto* p = permissions_manager_;
  // @@protoc_insertion_point(field_get:android.service.usb.UsbServiceDumpProto.permissions_manager)
  return p != nullptr ? *p : *reinterpret_cast<const ::android::service::usb::UsbPermissionsManagerProto*>(
      &::android::service::usb::_UsbPermissionsManagerProto_default_instance_);
}
inline ::android::service::usb::UsbPermissionsManagerProto* UsbServiceDumpProto::release_permissions_manager() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbServiceDumpProto.permissions_manager)
  _has_bits_[0] &= ~0x00000020u;
  ::android::service::usb::UsbPermissionsManagerProto* temp = permissions_manager_;
  permissions_manager_ = nullptr;
  return temp;
}
inline ::android::service::usb::UsbPermissionsManagerProto* UsbServiceDumpProto::mutable_permissions_manager() {
  _has_bits_[0] |= 0x00000020u;
  if (permissions_manager_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::service::usb::UsbPermissionsManagerProto>(GetArenaNoVirtual());
    permissions_manager_ = p;
  }
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbServiceDumpProto.permissions_manager)
  return permissions_manager_;
}
inline void UsbServiceDumpProto::set_allocated_permissions_manager(::android::service::usb::UsbPermissionsManagerProto* permissions_manager) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete permissions_manager_;
  }
  if (permissions_manager) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      permissions_manager = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permissions_manager, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  permissions_manager_ = permissions_manager;
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbServiceDumpProto.permissions_manager)
}

// -------------------------------------------------------------------

// UsbDeviceManagerProto

// optional .android.service.usb.UsbHandlerProto handler = 1;
inline bool UsbDeviceManagerProto::has_handler() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbDeviceManagerProto::clear_handler() {
  if (handler_ != nullptr) handler_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::android::service::usb::UsbHandlerProto& UsbDeviceManagerProto::handler() const {
  const ::android::service::usb::UsbHandlerProto* p = handler_;
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDeviceManagerProto.handler)
  return p != nullptr ? *p : *reinterpret_cast<const ::android::service::usb::UsbHandlerProto*>(
      &::android::service::usb::_UsbHandlerProto_default_instance_);
}
inline ::android::service::usb::UsbHandlerProto* UsbDeviceManagerProto::release_handler() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbDeviceManagerProto.handler)
  _has_bits_[0] &= ~0x00000001u;
  ::android::service::usb::UsbHandlerProto* temp = handler_;
  handler_ = nullptr;
  return temp;
}
inline ::android::service::usb::UsbHandlerProto* UsbDeviceManagerProto::mutable_handler() {
  _has_bits_[0] |= 0x00000001u;
  if (handler_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::service::usb::UsbHandlerProto>(GetArenaNoVirtual());
    handler_ = p;
  }
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbDeviceManagerProto.handler)
  return handler_;
}
inline void UsbDeviceManagerProto::set_allocated_handler(::android::service::usb::UsbHandlerProto* handler) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete handler_;
  }
  if (handler) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      handler = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handler, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  handler_ = handler;
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbDeviceManagerProto.handler)
}

// optional .android.service.usb.UsbDebuggingManagerProto debugging_manager = 2;
inline bool UsbDeviceManagerProto::has_debugging_manager() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsbDeviceManagerProto::clear_debugging_manager() {
  if (debugging_manager_ != nullptr) debugging_manager_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::android::service::usb::UsbDebuggingManagerProto& UsbDeviceManagerProto::debugging_manager() const {
  const ::android::service::usb::UsbDebuggingManagerProto* p = debugging_manager_;
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDeviceManagerProto.debugging_manager)
  return p != nullptr ? *p : *reinterpret_cast<const ::android::service::usb::UsbDebuggingManagerProto*>(
      &::android::service::usb::_UsbDebuggingManagerProto_default_instance_);
}
inline ::android::service::usb::UsbDebuggingManagerProto* UsbDeviceManagerProto::release_debugging_manager() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbDeviceManagerProto.debugging_manager)
  _has_bits_[0] &= ~0x00000002u;
  ::android::service::usb::UsbDebuggingManagerProto* temp = debugging_manager_;
  debugging_manager_ = nullptr;
  return temp;
}
inline ::android::service::usb::UsbDebuggingManagerProto* UsbDeviceManagerProto::mutable_debugging_manager() {
  _has_bits_[0] |= 0x00000002u;
  if (debugging_manager_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::service::usb::UsbDebuggingManagerProto>(GetArenaNoVirtual());
    debugging_manager_ = p;
  }
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbDeviceManagerProto.debugging_manager)
  return debugging_manager_;
}
inline void UsbDeviceManagerProto::set_allocated_debugging_manager(::android::service::usb::UsbDebuggingManagerProto* debugging_manager) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete debugging_manager_;
  }
  if (debugging_manager) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      debugging_manager = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, debugging_manager, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  debugging_manager_ = debugging_manager;
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbDeviceManagerProto.debugging_manager)
}

// -------------------------------------------------------------------

// UsbHandlerProto

// repeated .android.service.usb.UsbHandlerProto.Function current_functions = 1;
inline int UsbHandlerProto::current_functions_size() const {
  return current_functions_.size();
}
inline void UsbHandlerProto::clear_current_functions() {
  current_functions_.Clear();
}
inline ::android::service::usb::UsbHandlerProto_Function UsbHandlerProto::current_functions(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbHandlerProto.current_functions)
  return static_cast< ::android::service::usb::UsbHandlerProto_Function >(current_functions_.Get(index));
}
inline void UsbHandlerProto::set_current_functions(int index, ::android::service::usb::UsbHandlerProto_Function value) {
  assert(::android::service::usb::UsbHandlerProto_Function_IsValid(value));
  current_functions_.Set(index, value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbHandlerProto.current_functions)
}
inline void UsbHandlerProto::add_current_functions(::android::service::usb::UsbHandlerProto_Function value) {
  assert(::android::service::usb::UsbHandlerProto_Function_IsValid(value));
  current_functions_.Add(value);
  // @@protoc_insertion_point(field_add:android.service.usb.UsbHandlerProto.current_functions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
UsbHandlerProto::current_functions() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbHandlerProto.current_functions)
  return current_functions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
UsbHandlerProto::mutable_current_functions() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbHandlerProto.current_functions)
  return &current_functions_;
}

// optional bool current_functions_applied = 2;
inline bool UsbHandlerProto::has_current_functions_applied() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UsbHandlerProto::clear_current_functions_applied() {
  current_functions_applied_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool UsbHandlerProto::current_functions_applied() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbHandlerProto.current_functions_applied)
  return current_functions_applied_;
}
inline void UsbHandlerProto::set_current_functions_applied(bool value) {
  _has_bits_[0] |= 0x00000008u;
  current_functions_applied_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbHandlerProto.current_functions_applied)
}

// repeated .android.service.usb.UsbHandlerProto.Function screen_unlocked_functions = 3;
inline int UsbHandlerProto::screen_unlocked_functions_size() const {
  return screen_unlocked_functions_.size();
}
inline void UsbHandlerProto::clear_screen_unlocked_functions() {
  screen_unlocked_functions_.Clear();
}
inline ::android::service::usb::UsbHandlerProto_Function UsbHandlerProto::screen_unlocked_functions(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbHandlerProto.screen_unlocked_functions)
  return static_cast< ::android::service::usb::UsbHandlerProto_Function >(screen_unlocked_functions_.Get(index));
}
inline void UsbHandlerProto::set_screen_unlocked_functions(int index, ::android::service::usb::UsbHandlerProto_Function value) {
  assert(::android::service::usb::UsbHandlerProto_Function_IsValid(value));
  screen_unlocked_functions_.Set(index, value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbHandlerProto.screen_unlocked_functions)
}
inline void UsbHandlerProto::add_screen_unlocked_functions(::android::service::usb::UsbHandlerProto_Function value) {
  assert(::android::service::usb::UsbHandlerProto_Function_IsValid(value));
  screen_unlocked_functions_.Add(value);
  // @@protoc_insertion_point(field_add:android.service.usb.UsbHandlerProto.screen_unlocked_functions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
UsbHandlerProto::screen_unlocked_functions() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbHandlerProto.screen_unlocked_functions)
  return screen_unlocked_functions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
UsbHandlerProto::mutable_screen_unlocked_functions() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbHandlerProto.screen_unlocked_functions)
  return &screen_unlocked_functions_;
}

// optional bool screen_locked = 4;
inline bool UsbHandlerProto::has_screen_locked() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UsbHandlerProto::clear_screen_locked() {
  screen_locked_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool UsbHandlerProto::screen_locked() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbHandlerProto.screen_locked)
  return screen_locked_;
}
inline void UsbHandlerProto::set_screen_locked(bool value) {
  _has_bits_[0] |= 0x00000010u;
  screen_locked_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbHandlerProto.screen_locked)
}

// optional bool connected = 5;
inline bool UsbHandlerProto::has_connected() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UsbHandlerProto::clear_connected() {
  connected_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool UsbHandlerProto::connected() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbHandlerProto.connected)
  return connected_;
}
inline void UsbHandlerProto::set_connected(bool value) {
  _has_bits_[0] |= 0x00000020u;
  connected_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbHandlerProto.connected)
}

// optional bool configured = 6;
inline bool UsbHandlerProto::has_configured() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UsbHandlerProto::clear_configured() {
  configured_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool UsbHandlerProto::configured() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbHandlerProto.configured)
  return configured_;
}
inline void UsbHandlerProto::set_configured(bool value) {
  _has_bits_[0] |= 0x00000040u;
  configured_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbHandlerProto.configured)
}

// optional .android.service.usb.UsbAccessoryProto current_accessory = 7;
inline bool UsbHandlerProto::has_current_accessory() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UsbHandlerProto::clear_current_accessory() {
  if (current_accessory_ != nullptr) current_accessory_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::android::service::usb::UsbAccessoryProto& UsbHandlerProto::current_accessory() const {
  const ::android::service::usb::UsbAccessoryProto* p = current_accessory_;
  // @@protoc_insertion_point(field_get:android.service.usb.UsbHandlerProto.current_accessory)
  return p != nullptr ? *p : *reinterpret_cast<const ::android::service::usb::UsbAccessoryProto*>(
      &::android::service::usb::_UsbAccessoryProto_default_instance_);
}
inline ::android::service::usb::UsbAccessoryProto* UsbHandlerProto::release_current_accessory() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbHandlerProto.current_accessory)
  _has_bits_[0] &= ~0x00000004u;
  ::android::service::usb::UsbAccessoryProto* temp = current_accessory_;
  current_accessory_ = nullptr;
  return temp;
}
inline ::android::service::usb::UsbAccessoryProto* UsbHandlerProto::mutable_current_accessory() {
  _has_bits_[0] |= 0x00000004u;
  if (current_accessory_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::service::usb::UsbAccessoryProto>(GetArenaNoVirtual());
    current_accessory_ = p;
  }
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbHandlerProto.current_accessory)
  return current_accessory_;
}
inline void UsbHandlerProto::set_allocated_current_accessory(::android::service::usb::UsbAccessoryProto* current_accessory) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete current_accessory_;
  }
  if (current_accessory) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      current_accessory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, current_accessory, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  current_accessory_ = current_accessory;
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbHandlerProto.current_accessory)
}

// optional bool host_connected = 8;
inline bool UsbHandlerProto::has_host_connected() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UsbHandlerProto::clear_host_connected() {
  host_connected_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool UsbHandlerProto::host_connected() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbHandlerProto.host_connected)
  return host_connected_;
}
inline void UsbHandlerProto::set_host_connected(bool value) {
  _has_bits_[0] |= 0x00000080u;
  host_connected_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbHandlerProto.host_connected)
}

// optional bool source_power = 9;
inline bool UsbHandlerProto::has_source_power() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UsbHandlerProto::clear_source_power() {
  source_power_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool UsbHandlerProto::source_power() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbHandlerProto.source_power)
  return source_power_;
}
inline void UsbHandlerProto::set_source_power(bool value) {
  _has_bits_[0] |= 0x00000100u;
  source_power_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbHandlerProto.source_power)
}

// optional bool sink_power = 10;
inline bool UsbHandlerProto::has_sink_power() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UsbHandlerProto::clear_sink_power() {
  sink_power_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool UsbHandlerProto::sink_power() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbHandlerProto.sink_power)
  return sink_power_;
}
inline void UsbHandlerProto::set_sink_power(bool value) {
  _has_bits_[0] |= 0x00000200u;
  sink_power_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbHandlerProto.sink_power)
}

// optional bool usb_charging = 11;
inline bool UsbHandlerProto::has_usb_charging() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UsbHandlerProto::clear_usb_charging() {
  usb_charging_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool UsbHandlerProto::usb_charging() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbHandlerProto.usb_charging)
  return usb_charging_;
}
inline void UsbHandlerProto::set_usb_charging(bool value) {
  _has_bits_[0] |= 0x00000400u;
  usb_charging_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbHandlerProto.usb_charging)
}

// optional bool hide_usb_notification = 12;
inline bool UsbHandlerProto::has_hide_usb_notification() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UsbHandlerProto::clear_hide_usb_notification() {
  hide_usb_notification_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool UsbHandlerProto::hide_usb_notification() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbHandlerProto.hide_usb_notification)
  return hide_usb_notification_;
}
inline void UsbHandlerProto::set_hide_usb_notification(bool value) {
  _has_bits_[0] |= 0x00000800u;
  hide_usb_notification_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbHandlerProto.hide_usb_notification)
}

// optional bool audio_accessory_connected = 13;
inline bool UsbHandlerProto::has_audio_accessory_connected() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UsbHandlerProto::clear_audio_accessory_connected() {
  audio_accessory_connected_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool UsbHandlerProto::audio_accessory_connected() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbHandlerProto.audio_accessory_connected)
  return audio_accessory_connected_;
}
inline void UsbHandlerProto::set_audio_accessory_connected(bool value) {
  _has_bits_[0] |= 0x00001000u;
  audio_accessory_connected_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbHandlerProto.audio_accessory_connected)
}

// optional bool adb_enabled = 14;
inline bool UsbHandlerProto::has_adb_enabled() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UsbHandlerProto::clear_adb_enabled() {
  adb_enabled_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool UsbHandlerProto::adb_enabled() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbHandlerProto.adb_enabled)
  return adb_enabled_;
}
inline void UsbHandlerProto::set_adb_enabled(bool value) {
  _has_bits_[0] |= 0x00002000u;
  adb_enabled_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbHandlerProto.adb_enabled)
}

// optional string kernel_state = 15;
inline bool UsbHandlerProto::has_kernel_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbHandlerProto::clear_kernel_state() {
  kernel_state_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UsbHandlerProto::kernel_state() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbHandlerProto.kernel_state)
  return kernel_state_.GetNoArena();
}
inline void UsbHandlerProto::set_kernel_state(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  kernel_state_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbHandlerProto.kernel_state)
}
inline void UsbHandlerProto::set_kernel_state(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  kernel_state_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbHandlerProto.kernel_state)
}
inline void UsbHandlerProto::set_kernel_state(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  kernel_state_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbHandlerProto.kernel_state)
}
inline void UsbHandlerProto::set_kernel_state(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  kernel_state_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbHandlerProto.kernel_state)
}
inline std::string* UsbHandlerProto::mutable_kernel_state() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbHandlerProto.kernel_state)
  return kernel_state_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbHandlerProto::release_kernel_state() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbHandlerProto.kernel_state)
  if (!has_kernel_state()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return kernel_state_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbHandlerProto::set_allocated_kernel_state(std::string* kernel_state) {
  if (kernel_state != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  kernel_state_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), kernel_state);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbHandlerProto.kernel_state)
}

// optional string kernel_function_list = 16;
inline bool UsbHandlerProto::has_kernel_function_list() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsbHandlerProto::clear_kernel_function_list() {
  kernel_function_list_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UsbHandlerProto::kernel_function_list() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbHandlerProto.kernel_function_list)
  return kernel_function_list_.GetNoArena();
}
inline void UsbHandlerProto::set_kernel_function_list(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  kernel_function_list_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbHandlerProto.kernel_function_list)
}
inline void UsbHandlerProto::set_kernel_function_list(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  kernel_function_list_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbHandlerProto.kernel_function_list)
}
inline void UsbHandlerProto::set_kernel_function_list(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  kernel_function_list_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbHandlerProto.kernel_function_list)
}
inline void UsbHandlerProto::set_kernel_function_list(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  kernel_function_list_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbHandlerProto.kernel_function_list)
}
inline std::string* UsbHandlerProto::mutable_kernel_function_list() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbHandlerProto.kernel_function_list)
  return kernel_function_list_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbHandlerProto::release_kernel_function_list() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbHandlerProto.kernel_function_list)
  if (!has_kernel_function_list()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return kernel_function_list_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbHandlerProto::set_allocated_kernel_function_list(std::string* kernel_function_list) {
  if (kernel_function_list != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  kernel_function_list_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), kernel_function_list);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbHandlerProto.kernel_function_list)
}

// -------------------------------------------------------------------

// UsbAccessoryProto

// optional string manufacturer = 1;
inline bool UsbAccessoryProto::has_manufacturer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbAccessoryProto::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UsbAccessoryProto::manufacturer() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbAccessoryProto.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void UsbAccessoryProto::set_manufacturer(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  manufacturer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbAccessoryProto.manufacturer)
}
inline void UsbAccessoryProto::set_manufacturer(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  manufacturer_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbAccessoryProto.manufacturer)
}
inline void UsbAccessoryProto::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  manufacturer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbAccessoryProto.manufacturer)
}
inline void UsbAccessoryProto::set_manufacturer(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  manufacturer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbAccessoryProto.manufacturer)
}
inline std::string* UsbAccessoryProto::mutable_manufacturer() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbAccessoryProto.manufacturer)
  return manufacturer_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbAccessoryProto::release_manufacturer() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbAccessoryProto.manufacturer)
  if (!has_manufacturer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return manufacturer_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbAccessoryProto::set_allocated_manufacturer(std::string* manufacturer) {
  if (manufacturer != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  manufacturer_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbAccessoryProto.manufacturer)
}

// optional string model = 2;
inline bool UsbAccessoryProto::has_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsbAccessoryProto::clear_model() {
  model_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UsbAccessoryProto::model() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbAccessoryProto.model)
  return model_.GetNoArena();
}
inline void UsbAccessoryProto::set_model(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  model_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbAccessoryProto.model)
}
inline void UsbAccessoryProto::set_model(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  model_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbAccessoryProto.model)
}
inline void UsbAccessoryProto::set_model(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  model_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbAccessoryProto.model)
}
inline void UsbAccessoryProto::set_model(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  model_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbAccessoryProto.model)
}
inline std::string* UsbAccessoryProto::mutable_model() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbAccessoryProto.model)
  return model_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbAccessoryProto::release_model() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbAccessoryProto.model)
  if (!has_model()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return model_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbAccessoryProto::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  model_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbAccessoryProto.model)
}

// optional string description = 3;
inline bool UsbAccessoryProto::has_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UsbAccessoryProto::clear_description() {
  description_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UsbAccessoryProto::description() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbAccessoryProto.description)
  return description_.GetNoArena();
}
inline void UsbAccessoryProto::set_description(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbAccessoryProto.description)
}
inline void UsbAccessoryProto::set_description(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  description_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbAccessoryProto.description)
}
inline void UsbAccessoryProto::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbAccessoryProto.description)
}
inline void UsbAccessoryProto::set_description(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbAccessoryProto.description)
}
inline std::string* UsbAccessoryProto::mutable_description() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbAccessoryProto.description)
  return description_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbAccessoryProto::release_description() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbAccessoryProto.description)
  if (!has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return description_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbAccessoryProto::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  description_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbAccessoryProto.description)
}

// optional string version = 4;
inline bool UsbAccessoryProto::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UsbAccessoryProto::clear_version() {
  version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& UsbAccessoryProto::version() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbAccessoryProto.version)
  return version_.GetNoArena();
}
inline void UsbAccessoryProto::set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbAccessoryProto.version)
}
inline void UsbAccessoryProto::set_version(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbAccessoryProto.version)
}
inline void UsbAccessoryProto::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbAccessoryProto.version)
}
inline void UsbAccessoryProto::set_version(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbAccessoryProto.version)
}
inline std::string* UsbAccessoryProto::mutable_version() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbAccessoryProto.version)
  return version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbAccessoryProto::release_version() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbAccessoryProto.version)
  if (!has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbAccessoryProto::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbAccessoryProto.version)
}

// optional string uri = 5 [(.android.privacy) = {
inline bool UsbAccessoryProto::has_uri() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UsbAccessoryProto::clear_uri() {
  uri_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& UsbAccessoryProto::uri() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbAccessoryProto.uri)
  return uri_.GetNoArena();
}
inline void UsbAccessoryProto::set_uri(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  uri_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbAccessoryProto.uri)
}
inline void UsbAccessoryProto::set_uri(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  uri_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbAccessoryProto.uri)
}
inline void UsbAccessoryProto::set_uri(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  uri_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbAccessoryProto.uri)
}
inline void UsbAccessoryProto::set_uri(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  uri_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbAccessoryProto.uri)
}
inline std::string* UsbAccessoryProto::mutable_uri() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbAccessoryProto.uri)
  return uri_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbAccessoryProto::release_uri() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbAccessoryProto.uri)
  if (!has_uri()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return uri_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbAccessoryProto::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  uri_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbAccessoryProto.uri)
}

// optional string serial = 6 [(.android.privacy) = {
inline bool UsbAccessoryProto::has_serial() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UsbAccessoryProto::clear_serial() {
  serial_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& UsbAccessoryProto::serial() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbAccessoryProto.serial)
  return serial_.GetNoArena();
}
inline void UsbAccessoryProto::set_serial(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  serial_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbAccessoryProto.serial)
}
inline void UsbAccessoryProto::set_serial(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  serial_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbAccessoryProto.serial)
}
inline void UsbAccessoryProto::set_serial(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  serial_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbAccessoryProto.serial)
}
inline void UsbAccessoryProto::set_serial(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000020u;
  serial_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbAccessoryProto.serial)
}
inline std::string* UsbAccessoryProto::mutable_serial() {
  _has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbAccessoryProto.serial)
  return serial_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbAccessoryProto::release_serial() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbAccessoryProto.serial)
  if (!has_serial()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return serial_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbAccessoryProto::set_allocated_serial(std::string* serial) {
  if (serial != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  serial_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbAccessoryProto.serial)
}

// -------------------------------------------------------------------

// UsbDebuggingManagerProto

// optional bool connected_to_adb = 1;
inline bool UsbDebuggingManagerProto::has_connected_to_adb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UsbDebuggingManagerProto::clear_connected_to_adb() {
  connected_to_adb_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool UsbDebuggingManagerProto::connected_to_adb() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDebuggingManagerProto.connected_to_adb)
  return connected_to_adb_;
}
inline void UsbDebuggingManagerProto::set_connected_to_adb(bool value) {
  _has_bits_[0] |= 0x00000008u;
  connected_to_adb_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbDebuggingManagerProto.connected_to_adb)
}

// optional string last_key_received = 2 [(.android.privacy) = {
inline bool UsbDebuggingManagerProto::has_last_key_received() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbDebuggingManagerProto::clear_last_key_received() {
  last_key_received_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UsbDebuggingManagerProto::last_key_received() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDebuggingManagerProto.last_key_received)
  return last_key_received_.GetNoArena();
}
inline void UsbDebuggingManagerProto::set_last_key_received(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  last_key_received_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbDebuggingManagerProto.last_key_received)
}
inline void UsbDebuggingManagerProto::set_last_key_received(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  last_key_received_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbDebuggingManagerProto.last_key_received)
}
inline void UsbDebuggingManagerProto::set_last_key_received(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  last_key_received_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbDebuggingManagerProto.last_key_received)
}
inline void UsbDebuggingManagerProto::set_last_key_received(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  last_key_received_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbDebuggingManagerProto.last_key_received)
}
inline std::string* UsbDebuggingManagerProto::mutable_last_key_received() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbDebuggingManagerProto.last_key_received)
  return last_key_received_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbDebuggingManagerProto::release_last_key_received() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbDebuggingManagerProto.last_key_received)
  if (!has_last_key_received()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return last_key_received_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbDebuggingManagerProto::set_allocated_last_key_received(std::string* last_key_received) {
  if (last_key_received != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  last_key_received_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), last_key_received);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbDebuggingManagerProto.last_key_received)
}

// optional string user_keys = 3 [(.android.privacy) = {
inline bool UsbDebuggingManagerProto::has_user_keys() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsbDebuggingManagerProto::clear_user_keys() {
  user_keys_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UsbDebuggingManagerProto::user_keys() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDebuggingManagerProto.user_keys)
  return user_keys_.GetNoArena();
}
inline void UsbDebuggingManagerProto::set_user_keys(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  user_keys_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbDebuggingManagerProto.user_keys)
}
inline void UsbDebuggingManagerProto::set_user_keys(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  user_keys_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbDebuggingManagerProto.user_keys)
}
inline void UsbDebuggingManagerProto::set_user_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  user_keys_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbDebuggingManagerProto.user_keys)
}
inline void UsbDebuggingManagerProto::set_user_keys(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  user_keys_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbDebuggingManagerProto.user_keys)
}
inline std::string* UsbDebuggingManagerProto::mutable_user_keys() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbDebuggingManagerProto.user_keys)
  return user_keys_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbDebuggingManagerProto::release_user_keys() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbDebuggingManagerProto.user_keys)
  if (!has_user_keys()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return user_keys_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbDebuggingManagerProto::set_allocated_user_keys(std::string* user_keys) {
  if (user_keys != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  user_keys_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_keys);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbDebuggingManagerProto.user_keys)
}

// optional string system_keys = 4 [(.android.privacy) = {
inline bool UsbDebuggingManagerProto::has_system_keys() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UsbDebuggingManagerProto::clear_system_keys() {
  system_keys_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UsbDebuggingManagerProto::system_keys() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDebuggingManagerProto.system_keys)
  return system_keys_.GetNoArena();
}
inline void UsbDebuggingManagerProto::set_system_keys(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  system_keys_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbDebuggingManagerProto.system_keys)
}
inline void UsbDebuggingManagerProto::set_system_keys(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  system_keys_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbDebuggingManagerProto.system_keys)
}
inline void UsbDebuggingManagerProto::set_system_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  system_keys_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbDebuggingManagerProto.system_keys)
}
inline void UsbDebuggingManagerProto::set_system_keys(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  system_keys_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbDebuggingManagerProto.system_keys)
}
inline std::string* UsbDebuggingManagerProto::mutable_system_keys() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbDebuggingManagerProto.system_keys)
  return system_keys_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbDebuggingManagerProto::release_system_keys() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbDebuggingManagerProto.system_keys)
  if (!has_system_keys()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return system_keys_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbDebuggingManagerProto::set_allocated_system_keys(std::string* system_keys) {
  if (system_keys != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  system_keys_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), system_keys);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbDebuggingManagerProto.system_keys)
}

// -------------------------------------------------------------------

// UsbHostManagerProto

// optional .android.content.ComponentNameProto default_usb_host_connection_handler = 1;
inline bool UsbHostManagerProto::has_default_usb_host_connection_handler() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::android::content::ComponentNameProto& UsbHostManagerProto::default_usb_host_connection_handler() const {
  const ::android::content::ComponentNameProto* p = default_usb_host_connection_handler_;
  // @@protoc_insertion_point(field_get:android.service.usb.UsbHostManagerProto.default_usb_host_connection_handler)
  return p != nullptr ? *p : *reinterpret_cast<const ::android::content::ComponentNameProto*>(
      &::android::content::_ComponentNameProto_default_instance_);
}
inline ::android::content::ComponentNameProto* UsbHostManagerProto::release_default_usb_host_connection_handler() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbHostManagerProto.default_usb_host_connection_handler)
  _has_bits_[0] &= ~0x00000001u;
  ::android::content::ComponentNameProto* temp = default_usb_host_connection_handler_;
  default_usb_host_connection_handler_ = nullptr;
  return temp;
}
inline ::android::content::ComponentNameProto* UsbHostManagerProto::mutable_default_usb_host_connection_handler() {
  _has_bits_[0] |= 0x00000001u;
  if (default_usb_host_connection_handler_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::content::ComponentNameProto>(GetArenaNoVirtual());
    default_usb_host_connection_handler_ = p;
  }
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbHostManagerProto.default_usb_host_connection_handler)
  return default_usb_host_connection_handler_;
}
inline void UsbHostManagerProto::set_allocated_default_usb_host_connection_handler(::android::content::ComponentNameProto* default_usb_host_connection_handler) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(default_usb_host_connection_handler_);
  }
  if (default_usb_host_connection_handler) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      default_usb_host_connection_handler = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, default_usb_host_connection_handler, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  default_usb_host_connection_handler_ = default_usb_host_connection_handler;
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbHostManagerProto.default_usb_host_connection_handler)
}

// repeated .android.service.usb.UsbDeviceProto devices = 2;
inline int UsbHostManagerProto::devices_size() const {
  return devices_.size();
}
inline void UsbHostManagerProto::clear_devices() {
  devices_.Clear();
}
inline ::android::service::usb::UsbDeviceProto* UsbHostManagerProto::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbHostManagerProto.devices)
  return devices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbDeviceProto >*
UsbHostManagerProto::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbHostManagerProto.devices)
  return &devices_;
}
inline const ::android::service::usb::UsbDeviceProto& UsbHostManagerProto::devices(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbHostManagerProto.devices)
  return devices_.Get(index);
}
inline ::android::service::usb::UsbDeviceProto* UsbHostManagerProto::add_devices() {
  // @@protoc_insertion_point(field_add:android.service.usb.UsbHostManagerProto.devices)
  return devices_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbDeviceProto >&
UsbHostManagerProto::devices() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbHostManagerProto.devices)
  return devices_;
}

// optional int32 num_connects = 3;
inline bool UsbHostManagerProto::has_num_connects() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsbHostManagerProto::clear_num_connects() {
  num_connects_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbHostManagerProto::num_connects() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbHostManagerProto.num_connects)
  return num_connects_;
}
inline void UsbHostManagerProto::set_num_connects(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  num_connects_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbHostManagerProto.num_connects)
}

// repeated .android.service.usb.UsbConnectionRecordProto connections = 4;
inline int UsbHostManagerProto::connections_size() const {
  return connections_.size();
}
inline void UsbHostManagerProto::clear_connections() {
  connections_.Clear();
}
inline ::android::service::usb::UsbConnectionRecordProto* UsbHostManagerProto::mutable_connections(int index) {
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbHostManagerProto.connections)
  return connections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbConnectionRecordProto >*
UsbHostManagerProto::mutable_connections() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbHostManagerProto.connections)
  return &connections_;
}
inline const ::android::service::usb::UsbConnectionRecordProto& UsbHostManagerProto::connections(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbHostManagerProto.connections)
  return connections_.Get(index);
}
inline ::android::service::usb::UsbConnectionRecordProto* UsbHostManagerProto::add_connections() {
  // @@protoc_insertion_point(field_add:android.service.usb.UsbHostManagerProto.connections)
  return connections_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbConnectionRecordProto >&
UsbHostManagerProto::connections() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbHostManagerProto.connections)
  return connections_;
}

// -------------------------------------------------------------------

// UsbDeviceProto

// optional string name = 1;
inline bool UsbDeviceProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbDeviceProto::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UsbDeviceProto::name() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDeviceProto.name)
  return name_.GetNoArena();
}
inline void UsbDeviceProto::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbDeviceProto.name)
}
inline void UsbDeviceProto::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbDeviceProto.name)
}
inline void UsbDeviceProto::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbDeviceProto.name)
}
inline void UsbDeviceProto::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbDeviceProto.name)
}
inline std::string* UsbDeviceProto::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbDeviceProto.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbDeviceProto::release_name() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbDeviceProto.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbDeviceProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbDeviceProto.name)
}

// optional int32 vendor_id = 2;
inline bool UsbDeviceProto::has_vendor_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UsbDeviceProto::clear_vendor_id() {
  vendor_id_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbDeviceProto::vendor_id() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDeviceProto.vendor_id)
  return vendor_id_;
}
inline void UsbDeviceProto::set_vendor_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  vendor_id_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbDeviceProto.vendor_id)
}

// optional int32 product_id = 3;
inline bool UsbDeviceProto::has_product_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UsbDeviceProto::clear_product_id() {
  product_id_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbDeviceProto::product_id() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDeviceProto.product_id)
  return product_id_;
}
inline void UsbDeviceProto::set_product_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  product_id_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbDeviceProto.product_id)
}

// optional int32 class = 4;
inline bool UsbDeviceProto::has_class_() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UsbDeviceProto::clear_class_() {
  class__ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbDeviceProto::class_() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDeviceProto.class)
  return class__;
}
inline void UsbDeviceProto::set_class_(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  class__ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbDeviceProto.class)
}

// optional int32 subclass = 5;
inline bool UsbDeviceProto::has_subclass() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UsbDeviceProto::clear_subclass() {
  subclass_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbDeviceProto::subclass() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDeviceProto.subclass)
  return subclass_;
}
inline void UsbDeviceProto::set_subclass(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  subclass_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbDeviceProto.subclass)
}

// optional int32 protocol = 6;
inline bool UsbDeviceProto::has_protocol() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UsbDeviceProto::clear_protocol() {
  protocol_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbDeviceProto::protocol() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDeviceProto.protocol)
  return protocol_;
}
inline void UsbDeviceProto::set_protocol(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000200u;
  protocol_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbDeviceProto.protocol)
}

// optional string manufacturer_name = 7;
inline bool UsbDeviceProto::has_manufacturer_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsbDeviceProto::clear_manufacturer_name() {
  manufacturer_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UsbDeviceProto::manufacturer_name() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDeviceProto.manufacturer_name)
  return manufacturer_name_.GetNoArena();
}
inline void UsbDeviceProto::set_manufacturer_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  manufacturer_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbDeviceProto.manufacturer_name)
}
inline void UsbDeviceProto::set_manufacturer_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  manufacturer_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbDeviceProto.manufacturer_name)
}
inline void UsbDeviceProto::set_manufacturer_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  manufacturer_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbDeviceProto.manufacturer_name)
}
inline void UsbDeviceProto::set_manufacturer_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  manufacturer_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbDeviceProto.manufacturer_name)
}
inline std::string* UsbDeviceProto::mutable_manufacturer_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbDeviceProto.manufacturer_name)
  return manufacturer_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbDeviceProto::release_manufacturer_name() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbDeviceProto.manufacturer_name)
  if (!has_manufacturer_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return manufacturer_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbDeviceProto::set_allocated_manufacturer_name(std::string* manufacturer_name) {
  if (manufacturer_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  manufacturer_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), manufacturer_name);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbDeviceProto.manufacturer_name)
}

// optional string product_name = 8;
inline bool UsbDeviceProto::has_product_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UsbDeviceProto::clear_product_name() {
  product_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UsbDeviceProto::product_name() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDeviceProto.product_name)
  return product_name_.GetNoArena();
}
inline void UsbDeviceProto::set_product_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  product_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbDeviceProto.product_name)
}
inline void UsbDeviceProto::set_product_name(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  product_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbDeviceProto.product_name)
}
inline void UsbDeviceProto::set_product_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  product_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbDeviceProto.product_name)
}
inline void UsbDeviceProto::set_product_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  product_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbDeviceProto.product_name)
}
inline std::string* UsbDeviceProto::mutable_product_name() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbDeviceProto.product_name)
  return product_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbDeviceProto::release_product_name() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbDeviceProto.product_name)
  if (!has_product_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return product_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbDeviceProto::set_allocated_product_name(std::string* product_name) {
  if (product_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  product_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), product_name);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbDeviceProto.product_name)
}

// optional string version = 9;
inline bool UsbDeviceProto::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UsbDeviceProto::clear_version() {
  version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& UsbDeviceProto::version() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDeviceProto.version)
  return version_.GetNoArena();
}
inline void UsbDeviceProto::set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbDeviceProto.version)
}
inline void UsbDeviceProto::set_version(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbDeviceProto.version)
}
inline void UsbDeviceProto::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbDeviceProto.version)
}
inline void UsbDeviceProto::set_version(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbDeviceProto.version)
}
inline std::string* UsbDeviceProto::mutable_version() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbDeviceProto.version)
  return version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbDeviceProto::release_version() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbDeviceProto.version)
  if (!has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbDeviceProto::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbDeviceProto.version)
}

// optional string serial_number = 10 [(.android.privacy) = {
inline bool UsbDeviceProto::has_serial_number() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UsbDeviceProto::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& UsbDeviceProto::serial_number() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDeviceProto.serial_number)
  return serial_number_.GetNoArena();
}
inline void UsbDeviceProto::set_serial_number(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  serial_number_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbDeviceProto.serial_number)
}
inline void UsbDeviceProto::set_serial_number(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  serial_number_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbDeviceProto.serial_number)
}
inline void UsbDeviceProto::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  serial_number_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbDeviceProto.serial_number)
}
inline void UsbDeviceProto::set_serial_number(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  serial_number_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbDeviceProto.serial_number)
}
inline std::string* UsbDeviceProto::mutable_serial_number() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbDeviceProto.serial_number)
  return serial_number_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbDeviceProto::release_serial_number() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbDeviceProto.serial_number)
  if (!has_serial_number()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return serial_number_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbDeviceProto::set_allocated_serial_number(std::string* serial_number) {
  if (serial_number != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  serial_number_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbDeviceProto.serial_number)
}

// repeated .android.service.usb.UsbConfigurationProto configurations = 11;
inline int UsbDeviceProto::configurations_size() const {
  return configurations_.size();
}
inline void UsbDeviceProto::clear_configurations() {
  configurations_.Clear();
}
inline ::android::service::usb::UsbConfigurationProto* UsbDeviceProto::mutable_configurations(int index) {
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbDeviceProto.configurations)
  return configurations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbConfigurationProto >*
UsbDeviceProto::mutable_configurations() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbDeviceProto.configurations)
  return &configurations_;
}
inline const ::android::service::usb::UsbConfigurationProto& UsbDeviceProto::configurations(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDeviceProto.configurations)
  return configurations_.Get(index);
}
inline ::android::service::usb::UsbConfigurationProto* UsbDeviceProto::add_configurations() {
  // @@protoc_insertion_point(field_add:android.service.usb.UsbDeviceProto.configurations)
  return configurations_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbConfigurationProto >&
UsbDeviceProto::configurations() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbDeviceProto.configurations)
  return configurations_;
}

// -------------------------------------------------------------------

// UsbConfigurationProto

// optional int32 id = 1;
inline bool UsbConfigurationProto::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsbConfigurationProto::clear_id() {
  id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbConfigurationProto::id() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbConfigurationProto.id)
  return id_;
}
inline void UsbConfigurationProto::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  id_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbConfigurationProto.id)
}

// optional string name = 2;
inline bool UsbConfigurationProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbConfigurationProto::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UsbConfigurationProto::name() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbConfigurationProto.name)
  return name_.GetNoArena();
}
inline void UsbConfigurationProto::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbConfigurationProto.name)
}
inline void UsbConfigurationProto::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbConfigurationProto.name)
}
inline void UsbConfigurationProto::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbConfigurationProto.name)
}
inline void UsbConfigurationProto::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbConfigurationProto.name)
}
inline std::string* UsbConfigurationProto::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbConfigurationProto.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbConfigurationProto::release_name() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbConfigurationProto.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbConfigurationProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbConfigurationProto.name)
}

// optional uint32 attributes = 3;
inline bool UsbConfigurationProto::has_attributes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UsbConfigurationProto::clear_attributes() {
  attributes_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UsbConfigurationProto::attributes() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbConfigurationProto.attributes)
  return attributes_;
}
inline void UsbConfigurationProto::set_attributes(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  attributes_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbConfigurationProto.attributes)
}

// optional int32 max_power = 4;
inline bool UsbConfigurationProto::has_max_power() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UsbConfigurationProto::clear_max_power() {
  max_power_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbConfigurationProto::max_power() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbConfigurationProto.max_power)
  return max_power_;
}
inline void UsbConfigurationProto::set_max_power(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  max_power_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbConfigurationProto.max_power)
}

// repeated .android.service.usb.UsbInterfaceProto interfaces = 5;
inline int UsbConfigurationProto::interfaces_size() const {
  return interfaces_.size();
}
inline void UsbConfigurationProto::clear_interfaces() {
  interfaces_.Clear();
}
inline ::android::service::usb::UsbInterfaceProto* UsbConfigurationProto::mutable_interfaces(int index) {
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbConfigurationProto.interfaces)
  return interfaces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbInterfaceProto >*
UsbConfigurationProto::mutable_interfaces() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbConfigurationProto.interfaces)
  return &interfaces_;
}
inline const ::android::service::usb::UsbInterfaceProto& UsbConfigurationProto::interfaces(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbConfigurationProto.interfaces)
  return interfaces_.Get(index);
}
inline ::android::service::usb::UsbInterfaceProto* UsbConfigurationProto::add_interfaces() {
  // @@protoc_insertion_point(field_add:android.service.usb.UsbConfigurationProto.interfaces)
  return interfaces_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbInterfaceProto >&
UsbConfigurationProto::interfaces() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbConfigurationProto.interfaces)
  return interfaces_;
}

// -------------------------------------------------------------------

// UsbInterfaceProto

// optional int32 id = 1;
inline bool UsbInterfaceProto::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsbInterfaceProto::clear_id() {
  id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbInterfaceProto::id() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbInterfaceProto.id)
  return id_;
}
inline void UsbInterfaceProto::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  id_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbInterfaceProto.id)
}

// optional int32 alternate_settings = 2;
inline bool UsbInterfaceProto::has_alternate_settings() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UsbInterfaceProto::clear_alternate_settings() {
  alternate_settings_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbInterfaceProto::alternate_settings() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbInterfaceProto.alternate_settings)
  return alternate_settings_;
}
inline void UsbInterfaceProto::set_alternate_settings(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  alternate_settings_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbInterfaceProto.alternate_settings)
}

// optional string name = 3;
inline bool UsbInterfaceProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbInterfaceProto::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UsbInterfaceProto::name() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbInterfaceProto.name)
  return name_.GetNoArena();
}
inline void UsbInterfaceProto::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbInterfaceProto.name)
}
inline void UsbInterfaceProto::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbInterfaceProto.name)
}
inline void UsbInterfaceProto::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbInterfaceProto.name)
}
inline void UsbInterfaceProto::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbInterfaceProto.name)
}
inline std::string* UsbInterfaceProto::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbInterfaceProto.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbInterfaceProto::release_name() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbInterfaceProto.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbInterfaceProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbInterfaceProto.name)
}

// optional int32 class = 4;
inline bool UsbInterfaceProto::has_class_() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UsbInterfaceProto::clear_class_() {
  class__ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbInterfaceProto::class_() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbInterfaceProto.class)
  return class__;
}
inline void UsbInterfaceProto::set_class_(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  class__ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbInterfaceProto.class)
}

// optional int32 subclass = 5;
inline bool UsbInterfaceProto::has_subclass() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UsbInterfaceProto::clear_subclass() {
  subclass_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbInterfaceProto::subclass() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbInterfaceProto.subclass)
  return subclass_;
}
inline void UsbInterfaceProto::set_subclass(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  subclass_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbInterfaceProto.subclass)
}

// optional int32 protocol = 6;
inline bool UsbInterfaceProto::has_protocol() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UsbInterfaceProto::clear_protocol() {
  protocol_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbInterfaceProto::protocol() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbInterfaceProto.protocol)
  return protocol_;
}
inline void UsbInterfaceProto::set_protocol(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  protocol_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbInterfaceProto.protocol)
}

// repeated .android.service.usb.UsbEndPointProto endpoints = 7;
inline int UsbInterfaceProto::endpoints_size() const {
  return endpoints_.size();
}
inline void UsbInterfaceProto::clear_endpoints() {
  endpoints_.Clear();
}
inline ::android::service::usb::UsbEndPointProto* UsbInterfaceProto::mutable_endpoints(int index) {
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbInterfaceProto.endpoints)
  return endpoints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbEndPointProto >*
UsbInterfaceProto::mutable_endpoints() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbInterfaceProto.endpoints)
  return &endpoints_;
}
inline const ::android::service::usb::UsbEndPointProto& UsbInterfaceProto::endpoints(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbInterfaceProto.endpoints)
  return endpoints_.Get(index);
}
inline ::android::service::usb::UsbEndPointProto* UsbInterfaceProto::add_endpoints() {
  // @@protoc_insertion_point(field_add:android.service.usb.UsbInterfaceProto.endpoints)
  return endpoints_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbEndPointProto >&
UsbInterfaceProto::endpoints() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbInterfaceProto.endpoints)
  return endpoints_;
}

// -------------------------------------------------------------------

// UsbEndPointProto

// optional int32 endpoint_number = 1;
inline bool UsbEndPointProto::has_endpoint_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbEndPointProto::clear_endpoint_number() {
  endpoint_number_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbEndPointProto::endpoint_number() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbEndPointProto.endpoint_number)
  return endpoint_number_;
}
inline void UsbEndPointProto::set_endpoint_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  endpoint_number_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbEndPointProto.endpoint_number)
}

// optional .android.service.UsbEndPointDirection direction = 2;
inline bool UsbEndPointProto::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsbEndPointProto::clear_direction() {
  direction_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::android::service::UsbEndPointDirection UsbEndPointProto::direction() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbEndPointProto.direction)
  return static_cast< ::android::service::UsbEndPointDirection >(direction_);
}
inline void UsbEndPointProto::set_direction(::android::service::UsbEndPointDirection value) {
  assert(::android::service::UsbEndPointDirection_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  direction_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbEndPointProto.direction)
}

// optional int32 address = 3;
inline bool UsbEndPointProto::has_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UsbEndPointProto::clear_address() {
  address_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbEndPointProto::address() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbEndPointProto.address)
  return address_;
}
inline void UsbEndPointProto::set_address(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  address_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbEndPointProto.address)
}

// optional .android.service.UsbEndPointType type = 4;
inline bool UsbEndPointProto::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UsbEndPointProto::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::android::service::UsbEndPointType UsbEndPointProto::type() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbEndPointProto.type)
  return static_cast< ::android::service::UsbEndPointType >(type_);
}
inline void UsbEndPointProto::set_type(::android::service::UsbEndPointType value) {
  assert(::android::service::UsbEndPointType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  type_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbEndPointProto.type)
}

// optional uint32 attributes = 5;
inline bool UsbEndPointProto::has_attributes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UsbEndPointProto::clear_attributes() {
  attributes_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UsbEndPointProto::attributes() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbEndPointProto.attributes)
  return attributes_;
}
inline void UsbEndPointProto::set_attributes(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  attributes_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbEndPointProto.attributes)
}

// optional int32 max_packet_size = 6;
inline bool UsbEndPointProto::has_max_packet_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UsbEndPointProto::clear_max_packet_size() {
  max_packet_size_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbEndPointProto::max_packet_size() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbEndPointProto.max_packet_size)
  return max_packet_size_;
}
inline void UsbEndPointProto::set_max_packet_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  max_packet_size_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbEndPointProto.max_packet_size)
}

// optional int32 interval = 7;
inline bool UsbEndPointProto::has_interval() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UsbEndPointProto::clear_interval() {
  interval_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbEndPointProto::interval() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbEndPointProto.interval)
  return interval_;
}
inline void UsbEndPointProto::set_interval(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  interval_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbEndPointProto.interval)
}

// -------------------------------------------------------------------

// UsbConnectionRecordProto

// optional string device_address = 1;
inline bool UsbConnectionRecordProto::has_device_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbConnectionRecordProto::clear_device_address() {
  device_address_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UsbConnectionRecordProto::device_address() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbConnectionRecordProto.device_address)
  return device_address_.GetNoArena();
}
inline void UsbConnectionRecordProto::set_device_address(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  device_address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbConnectionRecordProto.device_address)
}
inline void UsbConnectionRecordProto::set_device_address(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  device_address_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbConnectionRecordProto.device_address)
}
inline void UsbConnectionRecordProto::set_device_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  device_address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbConnectionRecordProto.device_address)
}
inline void UsbConnectionRecordProto::set_device_address(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  device_address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbConnectionRecordProto.device_address)
}
inline std::string* UsbConnectionRecordProto::mutable_device_address() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbConnectionRecordProto.device_address)
  return device_address_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbConnectionRecordProto::release_device_address() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbConnectionRecordProto.device_address)
  if (!has_device_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return device_address_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbConnectionRecordProto::set_allocated_device_address(std::string* device_address) {
  if (device_address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  device_address_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_address);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbConnectionRecordProto.device_address)
}

// optional .android.service.UsbConnectionRecordMode mode = 2;
inline bool UsbConnectionRecordProto::has_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UsbConnectionRecordProto::clear_mode() {
  mode_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::android::service::UsbConnectionRecordMode UsbConnectionRecordProto::mode() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbConnectionRecordProto.mode)
  return static_cast< ::android::service::UsbConnectionRecordMode >(mode_);
}
inline void UsbConnectionRecordProto::set_mode(::android::service::UsbConnectionRecordMode value) {
  assert(::android::service::UsbConnectionRecordMode_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  mode_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbConnectionRecordProto.mode)
}

// optional int64 timestamp = 3;
inline bool UsbConnectionRecordProto::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UsbConnectionRecordProto::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UsbConnectionRecordProto::timestamp() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbConnectionRecordProto.timestamp)
  return timestamp_;
}
inline void UsbConnectionRecordProto::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbConnectionRecordProto.timestamp)
}

// optional int32 manufacturer = 4;
inline bool UsbConnectionRecordProto::has_manufacturer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UsbConnectionRecordProto::clear_manufacturer() {
  manufacturer_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbConnectionRecordProto::manufacturer() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbConnectionRecordProto.manufacturer)
  return manufacturer_;
}
inline void UsbConnectionRecordProto::set_manufacturer(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  manufacturer_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbConnectionRecordProto.manufacturer)
}

// optional int32 product = 5;
inline bool UsbConnectionRecordProto::has_product() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UsbConnectionRecordProto::clear_product() {
  product_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbConnectionRecordProto::product() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbConnectionRecordProto.product)
  return product_;
}
inline void UsbConnectionRecordProto::set_product(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  product_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbConnectionRecordProto.product)
}

// optional .android.service.usb.UsbIsHeadsetProto is_headset = 6;
inline bool UsbConnectionRecordProto::has_is_headset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsbConnectionRecordProto::clear_is_headset() {
  if (is_headset_ != nullptr) is_headset_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::android::service::usb::UsbIsHeadsetProto& UsbConnectionRecordProto::is_headset() const {
  const ::android::service::usb::UsbIsHeadsetProto* p = is_headset_;
  // @@protoc_insertion_point(field_get:android.service.usb.UsbConnectionRecordProto.is_headset)
  return p != nullptr ? *p : *reinterpret_cast<const ::android::service::usb::UsbIsHeadsetProto*>(
      &::android::service::usb::_UsbIsHeadsetProto_default_instance_);
}
inline ::android::service::usb::UsbIsHeadsetProto* UsbConnectionRecordProto::release_is_headset() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbConnectionRecordProto.is_headset)
  _has_bits_[0] &= ~0x00000002u;
  ::android::service::usb::UsbIsHeadsetProto* temp = is_headset_;
  is_headset_ = nullptr;
  return temp;
}
inline ::android::service::usb::UsbIsHeadsetProto* UsbConnectionRecordProto::mutable_is_headset() {
  _has_bits_[0] |= 0x00000002u;
  if (is_headset_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::service::usb::UsbIsHeadsetProto>(GetArenaNoVirtual());
    is_headset_ = p;
  }
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbConnectionRecordProto.is_headset)
  return is_headset_;
}
inline void UsbConnectionRecordProto::set_allocated_is_headset(::android::service::usb::UsbIsHeadsetProto* is_headset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete is_headset_;
  }
  if (is_headset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      is_headset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, is_headset, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  is_headset_ = is_headset;
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbConnectionRecordProto.is_headset)
}

// -------------------------------------------------------------------

// UsbIsHeadsetProto

// optional bool in = 1;
inline bool UsbIsHeadsetProto::has_in() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbIsHeadsetProto::clear_in() {
  in_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool UsbIsHeadsetProto::in() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbIsHeadsetProto.in)
  return in_;
}
inline void UsbIsHeadsetProto::set_in(bool value) {
  _has_bits_[0] |= 0x00000001u;
  in_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbIsHeadsetProto.in)
}

// optional bool out = 2;
inline bool UsbIsHeadsetProto::has_out() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsbIsHeadsetProto::clear_out() {
  out_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool UsbIsHeadsetProto::out() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbIsHeadsetProto.out)
  return out_;
}
inline void UsbIsHeadsetProto::set_out(bool value) {
  _has_bits_[0] |= 0x00000002u;
  out_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbIsHeadsetProto.out)
}

// -------------------------------------------------------------------

// UsbPortManagerProto

// optional bool is_simulation_active = 1;
inline bool UsbPortManagerProto::has_is_simulation_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbPortManagerProto::clear_is_simulation_active() {
  is_simulation_active_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool UsbPortManagerProto::is_simulation_active() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbPortManagerProto.is_simulation_active)
  return is_simulation_active_;
}
inline void UsbPortManagerProto::set_is_simulation_active(bool value) {
  _has_bits_[0] |= 0x00000001u;
  is_simulation_active_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbPortManagerProto.is_simulation_active)
}

// repeated .android.service.usb.UsbPortInfoProto usb_ports = 2;
inline int UsbPortManagerProto::usb_ports_size() const {
  return usb_ports_.size();
}
inline void UsbPortManagerProto::clear_usb_ports() {
  usb_ports_.Clear();
}
inline ::android::service::usb::UsbPortInfoProto* UsbPortManagerProto::mutable_usb_ports(int index) {
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbPortManagerProto.usb_ports)
  return usb_ports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbPortInfoProto >*
UsbPortManagerProto::mutable_usb_ports() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbPortManagerProto.usb_ports)
  return &usb_ports_;
}
inline const ::android::service::usb::UsbPortInfoProto& UsbPortManagerProto::usb_ports(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbPortManagerProto.usb_ports)
  return usb_ports_.Get(index);
}
inline ::android::service::usb::UsbPortInfoProto* UsbPortManagerProto::add_usb_ports() {
  // @@protoc_insertion_point(field_add:android.service.usb.UsbPortManagerProto.usb_ports)
  return usb_ports_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbPortInfoProto >&
UsbPortManagerProto::usb_ports() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbPortManagerProto.usb_ports)
  return usb_ports_;
}

// optional bool enable_usb_data_signaling = 3;
inline bool UsbPortManagerProto::has_enable_usb_data_signaling() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsbPortManagerProto::clear_enable_usb_data_signaling() {
  enable_usb_data_signaling_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool UsbPortManagerProto::enable_usb_data_signaling() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbPortManagerProto.enable_usb_data_signaling)
  return enable_usb_data_signaling_;
}
inline void UsbPortManagerProto::set_enable_usb_data_signaling(bool value) {
  _has_bits_[0] |= 0x00000002u;
  enable_usb_data_signaling_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbPortManagerProto.enable_usb_data_signaling)
}

// -------------------------------------------------------------------

// UsbPortInfoProto

// optional .android.service.usb.UsbPortProto port = 1;
inline bool UsbPortInfoProto::has_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbPortInfoProto::clear_port() {
  if (port_ != nullptr) port_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::android::service::usb::UsbPortProto& UsbPortInfoProto::port() const {
  const ::android::service::usb::UsbPortProto* p = port_;
  // @@protoc_insertion_point(field_get:android.service.usb.UsbPortInfoProto.port)
  return p != nullptr ? *p : *reinterpret_cast<const ::android::service::usb::UsbPortProto*>(
      &::android::service::usb::_UsbPortProto_default_instance_);
}
inline ::android::service::usb::UsbPortProto* UsbPortInfoProto::release_port() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbPortInfoProto.port)
  _has_bits_[0] &= ~0x00000001u;
  ::android::service::usb::UsbPortProto* temp = port_;
  port_ = nullptr;
  return temp;
}
inline ::android::service::usb::UsbPortProto* UsbPortInfoProto::mutable_port() {
  _has_bits_[0] |= 0x00000001u;
  if (port_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::service::usb::UsbPortProto>(GetArenaNoVirtual());
    port_ = p;
  }
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbPortInfoProto.port)
  return port_;
}
inline void UsbPortInfoProto::set_allocated_port(::android::service::usb::UsbPortProto* port) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete port_;
  }
  if (port) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      port = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, port, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  port_ = port;
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbPortInfoProto.port)
}

// optional .android.service.usb.UsbPortStatusProto status = 2;
inline bool UsbPortInfoProto::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsbPortInfoProto::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::android::service::usb::UsbPortStatusProto& UsbPortInfoProto::status() const {
  const ::android::service::usb::UsbPortStatusProto* p = status_;
  // @@protoc_insertion_point(field_get:android.service.usb.UsbPortInfoProto.status)
  return p != nullptr ? *p : *reinterpret_cast<const ::android::service::usb::UsbPortStatusProto*>(
      &::android::service::usb::_UsbPortStatusProto_default_instance_);
}
inline ::android::service::usb::UsbPortStatusProto* UsbPortInfoProto::release_status() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbPortInfoProto.status)
  _has_bits_[0] &= ~0x00000002u;
  ::android::service::usb::UsbPortStatusProto* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::android::service::usb::UsbPortStatusProto* UsbPortInfoProto::mutable_status() {
  _has_bits_[0] |= 0x00000002u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::service::usb::UsbPortStatusProto>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbPortInfoProto.status)
  return status_;
}
inline void UsbPortInfoProto::set_allocated_status(::android::service::usb::UsbPortStatusProto* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbPortInfoProto.status)
}

// optional bool can_change_mode = 3;
inline bool UsbPortInfoProto::has_can_change_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UsbPortInfoProto::clear_can_change_mode() {
  can_change_mode_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool UsbPortInfoProto::can_change_mode() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbPortInfoProto.can_change_mode)
  return can_change_mode_;
}
inline void UsbPortInfoProto::set_can_change_mode(bool value) {
  _has_bits_[0] |= 0x00000010u;
  can_change_mode_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbPortInfoProto.can_change_mode)
}

// optional bool can_change_power_role = 4;
inline bool UsbPortInfoProto::has_can_change_power_role() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UsbPortInfoProto::clear_can_change_power_role() {
  can_change_power_role_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool UsbPortInfoProto::can_change_power_role() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbPortInfoProto.can_change_power_role)
  return can_change_power_role_;
}
inline void UsbPortInfoProto::set_can_change_power_role(bool value) {
  _has_bits_[0] |= 0x00000020u;
  can_change_power_role_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbPortInfoProto.can_change_power_role)
}

// optional bool can_change_data_role = 5;
inline bool UsbPortInfoProto::has_can_change_data_role() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UsbPortInfoProto::clear_can_change_data_role() {
  can_change_data_role_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool UsbPortInfoProto::can_change_data_role() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbPortInfoProto.can_change_data_role)
  return can_change_data_role_;
}
inline void UsbPortInfoProto::set_can_change_data_role(bool value) {
  _has_bits_[0] |= 0x00000040u;
  can_change_data_role_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbPortInfoProto.can_change_data_role)
}

// optional int64 connected_at_millis = 6;
inline bool UsbPortInfoProto::has_connected_at_millis() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UsbPortInfoProto::clear_connected_at_millis() {
  connected_at_millis_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UsbPortInfoProto::connected_at_millis() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbPortInfoProto.connected_at_millis)
  return connected_at_millis_;
}
inline void UsbPortInfoProto::set_connected_at_millis(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  connected_at_millis_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbPortInfoProto.connected_at_millis)
}

// optional int64 last_connect_duration_millis = 7;
inline bool UsbPortInfoProto::has_last_connect_duration_millis() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UsbPortInfoProto::clear_last_connect_duration_millis() {
  last_connect_duration_millis_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UsbPortInfoProto::last_connect_duration_millis() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbPortInfoProto.last_connect_duration_millis)
  return last_connect_duration_millis_;
}
inline void UsbPortInfoProto::set_last_connect_duration_millis(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  last_connect_duration_millis_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbPortInfoProto.last_connect_duration_millis)
}

// -------------------------------------------------------------------

// UsbPortProto

// optional string id = 1;
inline bool UsbPortProto::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbPortProto::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UsbPortProto::id() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbPortProto.id)
  return id_.GetNoArena();
}
inline void UsbPortProto::set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbPortProto.id)
}
inline void UsbPortProto::set_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbPortProto.id)
}
inline void UsbPortProto::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbPortProto.id)
}
inline void UsbPortProto::set_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbPortProto.id)
}
inline std::string* UsbPortProto::mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbPortProto.id)
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbPortProto::release_id() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbPortProto.id)
  if (!has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbPortProto::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbPortProto.id)
}

// repeated .android.service.usb.UsbPortProto.Mode supported_modes = 2;
inline int UsbPortProto::supported_modes_size() const {
  return supported_modes_.size();
}
inline void UsbPortProto::clear_supported_modes() {
  supported_modes_.Clear();
}
inline ::android::service::usb::UsbPortProto_Mode UsbPortProto::supported_modes(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbPortProto.supported_modes)
  return static_cast< ::android::service::usb::UsbPortProto_Mode >(supported_modes_.Get(index));
}
inline void UsbPortProto::set_supported_modes(int index, ::android::service::usb::UsbPortProto_Mode value) {
  assert(::android::service::usb::UsbPortProto_Mode_IsValid(value));
  supported_modes_.Set(index, value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbPortProto.supported_modes)
}
inline void UsbPortProto::add_supported_modes(::android::service::usb::UsbPortProto_Mode value) {
  assert(::android::service::usb::UsbPortProto_Mode_IsValid(value));
  supported_modes_.Add(value);
  // @@protoc_insertion_point(field_add:android.service.usb.UsbPortProto.supported_modes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
UsbPortProto::supported_modes() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbPortProto.supported_modes)
  return supported_modes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
UsbPortProto::mutable_supported_modes() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbPortProto.supported_modes)
  return &supported_modes_;
}

// -------------------------------------------------------------------

// UsbPortStatusProto

// optional bool connected = 1;
inline bool UsbPortStatusProto::has_connected() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbPortStatusProto::clear_connected() {
  connected_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool UsbPortStatusProto::connected() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbPortStatusProto.connected)
  return connected_;
}
inline void UsbPortStatusProto::set_connected(bool value) {
  _has_bits_[0] |= 0x00000001u;
  connected_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbPortStatusProto.connected)
}

// optional .android.service.usb.UsbPortProto.Mode current_mode = 2;
inline bool UsbPortStatusProto::has_current_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsbPortStatusProto::clear_current_mode() {
  current_mode_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::android::service::usb::UsbPortProto_Mode UsbPortStatusProto::current_mode() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbPortStatusProto.current_mode)
  return static_cast< ::android::service::usb::UsbPortProto_Mode >(current_mode_);
}
inline void UsbPortStatusProto::set_current_mode(::android::service::usb::UsbPortProto_Mode value) {
  assert(::android::service::usb::UsbPortProto_Mode_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  current_mode_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbPortStatusProto.current_mode)
}

// optional .android.service.usb.UsbPortStatusProto.PowerRole power_role = 3;
inline bool UsbPortStatusProto::has_power_role() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UsbPortStatusProto::clear_power_role() {
  power_role_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::android::service::usb::UsbPortStatusProto_PowerRole UsbPortStatusProto::power_role() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbPortStatusProto.power_role)
  return static_cast< ::android::service::usb::UsbPortStatusProto_PowerRole >(power_role_);
}
inline void UsbPortStatusProto::set_power_role(::android::service::usb::UsbPortStatusProto_PowerRole value) {
  assert(::android::service::usb::UsbPortStatusProto_PowerRole_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  power_role_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbPortStatusProto.power_role)
}

// optional .android.service.usb.UsbPortStatusProto.DataRole data_role = 4;
inline bool UsbPortStatusProto::has_data_role() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UsbPortStatusProto::clear_data_role() {
  data_role_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::android::service::usb::UsbPortStatusProto_DataRole UsbPortStatusProto::data_role() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbPortStatusProto.data_role)
  return static_cast< ::android::service::usb::UsbPortStatusProto_DataRole >(data_role_);
}
inline void UsbPortStatusProto::set_data_role(::android::service::usb::UsbPortStatusProto_DataRole value) {
  assert(::android::service::usb::UsbPortStatusProto_DataRole_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  data_role_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbPortStatusProto.data_role)
}

// repeated .android.service.usb.UsbPortStatusRoleCombinationProto role_combinations = 5;
inline int UsbPortStatusProto::role_combinations_size() const {
  return role_combinations_.size();
}
inline void UsbPortStatusProto::clear_role_combinations() {
  role_combinations_.Clear();
}
inline ::android::service::usb::UsbPortStatusRoleCombinationProto* UsbPortStatusProto::mutable_role_combinations(int index) {
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbPortStatusProto.role_combinations)
  return role_combinations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbPortStatusRoleCombinationProto >*
UsbPortStatusProto::mutable_role_combinations() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbPortStatusProto.role_combinations)
  return &role_combinations_;
}
inline const ::android::service::usb::UsbPortStatusRoleCombinationProto& UsbPortStatusProto::role_combinations(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbPortStatusProto.role_combinations)
  return role_combinations_.Get(index);
}
inline ::android::service::usb::UsbPortStatusRoleCombinationProto* UsbPortStatusProto::add_role_combinations() {
  // @@protoc_insertion_point(field_add:android.service.usb.UsbPortStatusProto.role_combinations)
  return role_combinations_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbPortStatusRoleCombinationProto >&
UsbPortStatusProto::role_combinations() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbPortStatusProto.role_combinations)
  return role_combinations_;
}

// optional .android.service.ContaminantPresenceStatus contaminant_presence_status = 6;
inline bool UsbPortStatusProto::has_contaminant_presence_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UsbPortStatusProto::clear_contaminant_presence_status() {
  contaminant_presence_status_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::android::service::ContaminantPresenceStatus UsbPortStatusProto::contaminant_presence_status() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbPortStatusProto.contaminant_presence_status)
  return static_cast< ::android::service::ContaminantPresenceStatus >(contaminant_presence_status_);
}
inline void UsbPortStatusProto::set_contaminant_presence_status(::android::service::ContaminantPresenceStatus value) {
  assert(::android::service::ContaminantPresenceStatus_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  contaminant_presence_status_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbPortStatusProto.contaminant_presence_status)
}

// -------------------------------------------------------------------

// UsbPortStatusRoleCombinationProto

// optional .android.service.usb.UsbPortStatusProto.PowerRole power_role = 1;
inline bool UsbPortStatusRoleCombinationProto::has_power_role() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbPortStatusRoleCombinationProto::clear_power_role() {
  power_role_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::android::service::usb::UsbPortStatusProto_PowerRole UsbPortStatusRoleCombinationProto::power_role() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbPortStatusRoleCombinationProto.power_role)
  return static_cast< ::android::service::usb::UsbPortStatusProto_PowerRole >(power_role_);
}
inline void UsbPortStatusRoleCombinationProto::set_power_role(::android::service::usb::UsbPortStatusProto_PowerRole value) {
  assert(::android::service::usb::UsbPortStatusProto_PowerRole_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  power_role_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbPortStatusRoleCombinationProto.power_role)
}

// optional .android.service.usb.UsbPortStatusProto.DataRole data_role = 2;
inline bool UsbPortStatusRoleCombinationProto::has_data_role() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsbPortStatusRoleCombinationProto::clear_data_role() {
  data_role_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::android::service::usb::UsbPortStatusProto_DataRole UsbPortStatusRoleCombinationProto::data_role() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbPortStatusRoleCombinationProto.data_role)
  return static_cast< ::android::service::usb::UsbPortStatusProto_DataRole >(data_role_);
}
inline void UsbPortStatusRoleCombinationProto::set_data_role(::android::service::usb::UsbPortStatusProto_DataRole value) {
  assert(::android::service::usb::UsbPortStatusProto_DataRole_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  data_role_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbPortStatusRoleCombinationProto.data_role)
}

// -------------------------------------------------------------------

// UsbAlsaManagerProto

// optional int32 cards_parser = 1;
inline bool UsbAlsaManagerProto::has_cards_parser() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbAlsaManagerProto::clear_cards_parser() {
  cards_parser_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbAlsaManagerProto::cards_parser() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbAlsaManagerProto.cards_parser)
  return cards_parser_;
}
inline void UsbAlsaManagerProto::set_cards_parser(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  cards_parser_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbAlsaManagerProto.cards_parser)
}

// repeated .android.service.usb.UsbAlsaDeviceProto alsa_devices = 2;
inline int UsbAlsaManagerProto::alsa_devices_size() const {
  return alsa_devices_.size();
}
inline void UsbAlsaManagerProto::clear_alsa_devices() {
  alsa_devices_.Clear();
}
inline ::android::service::usb::UsbAlsaDeviceProto* UsbAlsaManagerProto::mutable_alsa_devices(int index) {
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbAlsaManagerProto.alsa_devices)
  return alsa_devices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbAlsaDeviceProto >*
UsbAlsaManagerProto::mutable_alsa_devices() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbAlsaManagerProto.alsa_devices)
  return &alsa_devices_;
}
inline const ::android::service::usb::UsbAlsaDeviceProto& UsbAlsaManagerProto::alsa_devices(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbAlsaManagerProto.alsa_devices)
  return alsa_devices_.Get(index);
}
inline ::android::service::usb::UsbAlsaDeviceProto* UsbAlsaManagerProto::add_alsa_devices() {
  // @@protoc_insertion_point(field_add:android.service.usb.UsbAlsaManagerProto.alsa_devices)
  return alsa_devices_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbAlsaDeviceProto >&
UsbAlsaManagerProto::alsa_devices() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbAlsaManagerProto.alsa_devices)
  return alsa_devices_;
}

// repeated .android.service.usb.UsbMidiDeviceProto midi_devices = 3;
inline int UsbAlsaManagerProto::midi_devices_size() const {
  return midi_devices_.size();
}
inline void UsbAlsaManagerProto::clear_midi_devices() {
  midi_devices_.Clear();
}
inline ::android::service::usb::UsbMidiDeviceProto* UsbAlsaManagerProto::mutable_midi_devices(int index) {
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbAlsaManagerProto.midi_devices)
  return midi_devices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbMidiDeviceProto >*
UsbAlsaManagerProto::mutable_midi_devices() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbAlsaManagerProto.midi_devices)
  return &midi_devices_;
}
inline const ::android::service::usb::UsbMidiDeviceProto& UsbAlsaManagerProto::midi_devices(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbAlsaManagerProto.midi_devices)
  return midi_devices_.Get(index);
}
inline ::android::service::usb::UsbMidiDeviceProto* UsbAlsaManagerProto::add_midi_devices() {
  // @@protoc_insertion_point(field_add:android.service.usb.UsbAlsaManagerProto.midi_devices)
  return midi_devices_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbMidiDeviceProto >&
UsbAlsaManagerProto::midi_devices() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbAlsaManagerProto.midi_devices)
  return midi_devices_;
}

// -------------------------------------------------------------------

// UsbAlsaDeviceProto

// optional int32 card = 1;
inline bool UsbAlsaDeviceProto::has_card() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UsbAlsaDeviceProto::clear_card() {
  card_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbAlsaDeviceProto::card() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbAlsaDeviceProto.card)
  return card_;
}
inline void UsbAlsaDeviceProto::set_card(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  card_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbAlsaDeviceProto.card)
}

// optional int32 device = 2;
inline bool UsbAlsaDeviceProto::has_device() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UsbAlsaDeviceProto::clear_device() {
  device_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbAlsaDeviceProto::device() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbAlsaDeviceProto.device)
  return device_;
}
inline void UsbAlsaDeviceProto::set_device(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  device_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbAlsaDeviceProto.device)
}

// optional string name = 3;
inline bool UsbAlsaDeviceProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbAlsaDeviceProto::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UsbAlsaDeviceProto::name() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbAlsaDeviceProto.name)
  return name_.GetNoArena();
}
inline void UsbAlsaDeviceProto::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbAlsaDeviceProto.name)
}
inline void UsbAlsaDeviceProto::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbAlsaDeviceProto.name)
}
inline void UsbAlsaDeviceProto::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbAlsaDeviceProto.name)
}
inline void UsbAlsaDeviceProto::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbAlsaDeviceProto.name)
}
inline std::string* UsbAlsaDeviceProto::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbAlsaDeviceProto.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbAlsaDeviceProto::release_name() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbAlsaDeviceProto.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbAlsaDeviceProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbAlsaDeviceProto.name)
}

// optional bool has_playback = 4;
inline bool UsbAlsaDeviceProto::has_has_playback() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UsbAlsaDeviceProto::clear_has_playback() {
  has_playback_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool UsbAlsaDeviceProto::has_playback() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbAlsaDeviceProto.has_playback)
  return has_playback_;
}
inline void UsbAlsaDeviceProto::set_has_playback(bool value) {
  _has_bits_[0] |= 0x00000010u;
  has_playback_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbAlsaDeviceProto.has_playback)
}

// optional bool has_capture = 5;
inline bool UsbAlsaDeviceProto::has_has_capture() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UsbAlsaDeviceProto::clear_has_capture() {
  has_capture_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool UsbAlsaDeviceProto::has_capture() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbAlsaDeviceProto.has_capture)
  return has_capture_;
}
inline void UsbAlsaDeviceProto::set_has_capture(bool value) {
  _has_bits_[0] |= 0x00000020u;
  has_capture_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbAlsaDeviceProto.has_capture)
}

// optional string address = 6;
inline bool UsbAlsaDeviceProto::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsbAlsaDeviceProto::clear_address() {
  address_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UsbAlsaDeviceProto::address() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbAlsaDeviceProto.address)
  return address_.GetNoArena();
}
inline void UsbAlsaDeviceProto::set_address(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbAlsaDeviceProto.address)
}
inline void UsbAlsaDeviceProto::set_address(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  address_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbAlsaDeviceProto.address)
}
inline void UsbAlsaDeviceProto::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbAlsaDeviceProto.address)
}
inline void UsbAlsaDeviceProto::set_address(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbAlsaDeviceProto.address)
}
inline std::string* UsbAlsaDeviceProto::mutable_address() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbAlsaDeviceProto.address)
  return address_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbAlsaDeviceProto::release_address() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbAlsaDeviceProto.address)
  if (!has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return address_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbAlsaDeviceProto::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  address_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbAlsaDeviceProto.address)
}

// -------------------------------------------------------------------

// UsbMidiDeviceProto

// optional int32 card = 1;
inline bool UsbMidiDeviceProto::has_card() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsbMidiDeviceProto::clear_card() {
  card_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbMidiDeviceProto::card() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbMidiDeviceProto.card)
  return card_;
}
inline void UsbMidiDeviceProto::set_card(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  card_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbMidiDeviceProto.card)
}

// optional int32 device = 2;
inline bool UsbMidiDeviceProto::has_device() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UsbMidiDeviceProto::clear_device() {
  device_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbMidiDeviceProto::device() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbMidiDeviceProto.device)
  return device_;
}
inline void UsbMidiDeviceProto::set_device(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  device_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbMidiDeviceProto.device)
}

// optional string device_address = 3;
inline bool UsbMidiDeviceProto::has_device_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbMidiDeviceProto::clear_device_address() {
  device_address_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UsbMidiDeviceProto::device_address() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbMidiDeviceProto.device_address)
  return device_address_.GetNoArena();
}
inline void UsbMidiDeviceProto::set_device_address(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  device_address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbMidiDeviceProto.device_address)
}
inline void UsbMidiDeviceProto::set_device_address(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  device_address_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbMidiDeviceProto.device_address)
}
inline void UsbMidiDeviceProto::set_device_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  device_address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbMidiDeviceProto.device_address)
}
inline void UsbMidiDeviceProto::set_device_address(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  device_address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbMidiDeviceProto.device_address)
}
inline std::string* UsbMidiDeviceProto::mutable_device_address() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbMidiDeviceProto.device_address)
  return device_address_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbMidiDeviceProto::release_device_address() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbMidiDeviceProto.device_address)
  if (!has_device_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return device_address_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbMidiDeviceProto::set_allocated_device_address(std::string* device_address) {
  if (device_address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  device_address_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_address);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbMidiDeviceProto.device_address)
}

// -------------------------------------------------------------------

// UsbSettingsManagerProto

// repeated .android.service.usb.UsbUserSettingsManagerProto user_settings = 1;
inline int UsbSettingsManagerProto::user_settings_size() const {
  return user_settings_.size();
}
inline void UsbSettingsManagerProto::clear_user_settings() {
  user_settings_.Clear();
}
inline ::android::service::usb::UsbUserSettingsManagerProto* UsbSettingsManagerProto::mutable_user_settings(int index) {
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbSettingsManagerProto.user_settings)
  return user_settings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbUserSettingsManagerProto >*
UsbSettingsManagerProto::mutable_user_settings() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbSettingsManagerProto.user_settings)
  return &user_settings_;
}
inline const ::android::service::usb::UsbUserSettingsManagerProto& UsbSettingsManagerProto::user_settings(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbSettingsManagerProto.user_settings)
  return user_settings_.Get(index);
}
inline ::android::service::usb::UsbUserSettingsManagerProto* UsbSettingsManagerProto::add_user_settings() {
  // @@protoc_insertion_point(field_add:android.service.usb.UsbSettingsManagerProto.user_settings)
  return user_settings_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbUserSettingsManagerProto >&
UsbSettingsManagerProto::user_settings() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbSettingsManagerProto.user_settings)
  return user_settings_;
}

// repeated .android.service.usb.UsbProfileGroupSettingsManagerProto profile_group_settings = 2;
inline int UsbSettingsManagerProto::profile_group_settings_size() const {
  return profile_group_settings_.size();
}
inline void UsbSettingsManagerProto::clear_profile_group_settings() {
  profile_group_settings_.Clear();
}
inline ::android::service::usb::UsbProfileGroupSettingsManagerProto* UsbSettingsManagerProto::mutable_profile_group_settings(int index) {
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbSettingsManagerProto.profile_group_settings)
  return profile_group_settings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbProfileGroupSettingsManagerProto >*
UsbSettingsManagerProto::mutable_profile_group_settings() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbSettingsManagerProto.profile_group_settings)
  return &profile_group_settings_;
}
inline const ::android::service::usb::UsbProfileGroupSettingsManagerProto& UsbSettingsManagerProto::profile_group_settings(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbSettingsManagerProto.profile_group_settings)
  return profile_group_settings_.Get(index);
}
inline ::android::service::usb::UsbProfileGroupSettingsManagerProto* UsbSettingsManagerProto::add_profile_group_settings() {
  // @@protoc_insertion_point(field_add:android.service.usb.UsbSettingsManagerProto.profile_group_settings)
  return profile_group_settings_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbProfileGroupSettingsManagerProto >&
UsbSettingsManagerProto::profile_group_settings() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbSettingsManagerProto.profile_group_settings)
  return profile_group_settings_;
}

// -------------------------------------------------------------------

// UsbUserSettingsManagerProto

// optional int32 user_id = 1;
inline bool UsbUserSettingsManagerProto::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbUserSettingsManagerProto::clear_user_id() {
  user_id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbUserSettingsManagerProto::user_id() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbUserSettingsManagerProto.user_id)
  return user_id_;
}
inline void UsbUserSettingsManagerProto::set_user_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  user_id_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbUserSettingsManagerProto.user_id)
}

// repeated .android.service.usb.UsbDeviceAttachedActivities device_attached_activities = 4;
inline int UsbUserSettingsManagerProto::device_attached_activities_size() const {
  return device_attached_activities_.size();
}
inline void UsbUserSettingsManagerProto::clear_device_attached_activities() {
  device_attached_activities_.Clear();
}
inline ::android::service::usb::UsbDeviceAttachedActivities* UsbUserSettingsManagerProto::mutable_device_attached_activities(int index) {
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbUserSettingsManagerProto.device_attached_activities)
  return device_attached_activities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbDeviceAttachedActivities >*
UsbUserSettingsManagerProto::mutable_device_attached_activities() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbUserSettingsManagerProto.device_attached_activities)
  return &device_attached_activities_;
}
inline const ::android::service::usb::UsbDeviceAttachedActivities& UsbUserSettingsManagerProto::device_attached_activities(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbUserSettingsManagerProto.device_attached_activities)
  return device_attached_activities_.Get(index);
}
inline ::android::service::usb::UsbDeviceAttachedActivities* UsbUserSettingsManagerProto::add_device_attached_activities() {
  // @@protoc_insertion_point(field_add:android.service.usb.UsbUserSettingsManagerProto.device_attached_activities)
  return device_attached_activities_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbDeviceAttachedActivities >&
UsbUserSettingsManagerProto::device_attached_activities() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbUserSettingsManagerProto.device_attached_activities)
  return device_attached_activities_;
}

// repeated .android.service.usb.UsbAccessoryAttachedActivities accessory_attached_activities = 5;
inline int UsbUserSettingsManagerProto::accessory_attached_activities_size() const {
  return accessory_attached_activities_.size();
}
inline void UsbUserSettingsManagerProto::clear_accessory_attached_activities() {
  accessory_attached_activities_.Clear();
}
inline ::android::service::usb::UsbAccessoryAttachedActivities* UsbUserSettingsManagerProto::mutable_accessory_attached_activities(int index) {
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbUserSettingsManagerProto.accessory_attached_activities)
  return accessory_attached_activities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbAccessoryAttachedActivities >*
UsbUserSettingsManagerProto::mutable_accessory_attached_activities() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbUserSettingsManagerProto.accessory_attached_activities)
  return &accessory_attached_activities_;
}
inline const ::android::service::usb::UsbAccessoryAttachedActivities& UsbUserSettingsManagerProto::accessory_attached_activities(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbUserSettingsManagerProto.accessory_attached_activities)
  return accessory_attached_activities_.Get(index);
}
inline ::android::service::usb::UsbAccessoryAttachedActivities* UsbUserSettingsManagerProto::add_accessory_attached_activities() {
  // @@protoc_insertion_point(field_add:android.service.usb.UsbUserSettingsManagerProto.accessory_attached_activities)
  return accessory_attached_activities_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbAccessoryAttachedActivities >&
UsbUserSettingsManagerProto::accessory_attached_activities() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbUserSettingsManagerProto.accessory_attached_activities)
  return accessory_attached_activities_;
}

// -------------------------------------------------------------------

// UsbProfileGroupSettingsManagerProto

// optional int32 parent_user_id = 1;
inline bool UsbProfileGroupSettingsManagerProto::has_parent_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbProfileGroupSettingsManagerProto::clear_parent_user_id() {
  parent_user_id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbProfileGroupSettingsManagerProto::parent_user_id() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbProfileGroupSettingsManagerProto.parent_user_id)
  return parent_user_id_;
}
inline void UsbProfileGroupSettingsManagerProto::set_parent_user_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  parent_user_id_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbProfileGroupSettingsManagerProto.parent_user_id)
}

// repeated .android.service.usb.UsbSettingsDevicePreferenceProto device_preferences = 2;
inline int UsbProfileGroupSettingsManagerProto::device_preferences_size() const {
  return device_preferences_.size();
}
inline void UsbProfileGroupSettingsManagerProto::clear_device_preferences() {
  device_preferences_.Clear();
}
inline ::android::service::usb::UsbSettingsDevicePreferenceProto* UsbProfileGroupSettingsManagerProto::mutable_device_preferences(int index) {
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbProfileGroupSettingsManagerProto.device_preferences)
  return device_preferences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbSettingsDevicePreferenceProto >*
UsbProfileGroupSettingsManagerProto::mutable_device_preferences() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbProfileGroupSettingsManagerProto.device_preferences)
  return &device_preferences_;
}
inline const ::android::service::usb::UsbSettingsDevicePreferenceProto& UsbProfileGroupSettingsManagerProto::device_preferences(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbProfileGroupSettingsManagerProto.device_preferences)
  return device_preferences_.Get(index);
}
inline ::android::service::usb::UsbSettingsDevicePreferenceProto* UsbProfileGroupSettingsManagerProto::add_device_preferences() {
  // @@protoc_insertion_point(field_add:android.service.usb.UsbProfileGroupSettingsManagerProto.device_preferences)
  return device_preferences_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbSettingsDevicePreferenceProto >&
UsbProfileGroupSettingsManagerProto::device_preferences() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbProfileGroupSettingsManagerProto.device_preferences)
  return device_preferences_;
}

// repeated .android.service.usb.UsbSettingsAccessoryPreferenceProto accessory_preferences = 3;
inline int UsbProfileGroupSettingsManagerProto::accessory_preferences_size() const {
  return accessory_preferences_.size();
}
inline void UsbProfileGroupSettingsManagerProto::clear_accessory_preferences() {
  accessory_preferences_.Clear();
}
inline ::android::service::usb::UsbSettingsAccessoryPreferenceProto* UsbProfileGroupSettingsManagerProto::mutable_accessory_preferences(int index) {
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbProfileGroupSettingsManagerProto.accessory_preferences)
  return accessory_preferences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbSettingsAccessoryPreferenceProto >*
UsbProfileGroupSettingsManagerProto::mutable_accessory_preferences() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbProfileGroupSettingsManagerProto.accessory_preferences)
  return &accessory_preferences_;
}
inline const ::android::service::usb::UsbSettingsAccessoryPreferenceProto& UsbProfileGroupSettingsManagerProto::accessory_preferences(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbProfileGroupSettingsManagerProto.accessory_preferences)
  return accessory_preferences_.Get(index);
}
inline ::android::service::usb::UsbSettingsAccessoryPreferenceProto* UsbProfileGroupSettingsManagerProto::add_accessory_preferences() {
  // @@protoc_insertion_point(field_add:android.service.usb.UsbProfileGroupSettingsManagerProto.accessory_preferences)
  return accessory_preferences_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbSettingsAccessoryPreferenceProto >&
UsbProfileGroupSettingsManagerProto::accessory_preferences() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbProfileGroupSettingsManagerProto.accessory_preferences)
  return accessory_preferences_;
}

// -------------------------------------------------------------------

// UsbSettingsDevicePreferenceProto

// optional .android.service.usb.UsbDeviceFilterProto filter = 1;
inline bool UsbSettingsDevicePreferenceProto::has_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbSettingsDevicePreferenceProto::clear_filter() {
  if (filter_ != nullptr) filter_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::android::service::usb::UsbDeviceFilterProto& UsbSettingsDevicePreferenceProto::filter() const {
  const ::android::service::usb::UsbDeviceFilterProto* p = filter_;
  // @@protoc_insertion_point(field_get:android.service.usb.UsbSettingsDevicePreferenceProto.filter)
  return p != nullptr ? *p : *reinterpret_cast<const ::android::service::usb::UsbDeviceFilterProto*>(
      &::android::service::usb::_UsbDeviceFilterProto_default_instance_);
}
inline ::android::service::usb::UsbDeviceFilterProto* UsbSettingsDevicePreferenceProto::release_filter() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbSettingsDevicePreferenceProto.filter)
  _has_bits_[0] &= ~0x00000001u;
  ::android::service::usb::UsbDeviceFilterProto* temp = filter_;
  filter_ = nullptr;
  return temp;
}
inline ::android::service::usb::UsbDeviceFilterProto* UsbSettingsDevicePreferenceProto::mutable_filter() {
  _has_bits_[0] |= 0x00000001u;
  if (filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::service::usb::UsbDeviceFilterProto>(GetArenaNoVirtual());
    filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbSettingsDevicePreferenceProto.filter)
  return filter_;
}
inline void UsbSettingsDevicePreferenceProto::set_allocated_filter(::android::service::usb::UsbDeviceFilterProto* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbSettingsDevicePreferenceProto.filter)
}

// optional .android.service.usb.UserPackageProto user_package = 2;
inline bool UsbSettingsDevicePreferenceProto::has_user_package() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsbSettingsDevicePreferenceProto::clear_user_package() {
  if (user_package_ != nullptr) user_package_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::android::service::usb::UserPackageProto& UsbSettingsDevicePreferenceProto::user_package() const {
  const ::android::service::usb::UserPackageProto* p = user_package_;
  // @@protoc_insertion_point(field_get:android.service.usb.UsbSettingsDevicePreferenceProto.user_package)
  return p != nullptr ? *p : *reinterpret_cast<const ::android::service::usb::UserPackageProto*>(
      &::android::service::usb::_UserPackageProto_default_instance_);
}
inline ::android::service::usb::UserPackageProto* UsbSettingsDevicePreferenceProto::release_user_package() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbSettingsDevicePreferenceProto.user_package)
  _has_bits_[0] &= ~0x00000002u;
  ::android::service::usb::UserPackageProto* temp = user_package_;
  user_package_ = nullptr;
  return temp;
}
inline ::android::service::usb::UserPackageProto* UsbSettingsDevicePreferenceProto::mutable_user_package() {
  _has_bits_[0] |= 0x00000002u;
  if (user_package_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::service::usb::UserPackageProto>(GetArenaNoVirtual());
    user_package_ = p;
  }
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbSettingsDevicePreferenceProto.user_package)
  return user_package_;
}
inline void UsbSettingsDevicePreferenceProto::set_allocated_user_package(::android::service::usb::UserPackageProto* user_package) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete user_package_;
  }
  if (user_package) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      user_package = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_package, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  user_package_ = user_package;
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbSettingsDevicePreferenceProto.user_package)
}

// -------------------------------------------------------------------

// UsbPermissionsManagerProto

// repeated .android.service.usb.UsbUserPermissionsManagerProto user_permissions = 1;
inline int UsbPermissionsManagerProto::user_permissions_size() const {
  return user_permissions_.size();
}
inline void UsbPermissionsManagerProto::clear_user_permissions() {
  user_permissions_.Clear();
}
inline ::android::service::usb::UsbUserPermissionsManagerProto* UsbPermissionsManagerProto::mutable_user_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbPermissionsManagerProto.user_permissions)
  return user_permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbUserPermissionsManagerProto >*
UsbPermissionsManagerProto::mutable_user_permissions() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbPermissionsManagerProto.user_permissions)
  return &user_permissions_;
}
inline const ::android::service::usb::UsbUserPermissionsManagerProto& UsbPermissionsManagerProto::user_permissions(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbPermissionsManagerProto.user_permissions)
  return user_permissions_.Get(index);
}
inline ::android::service::usb::UsbUserPermissionsManagerProto* UsbPermissionsManagerProto::add_user_permissions() {
  // @@protoc_insertion_point(field_add:android.service.usb.UsbPermissionsManagerProto.user_permissions)
  return user_permissions_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbUserPermissionsManagerProto >&
UsbPermissionsManagerProto::user_permissions() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbPermissionsManagerProto.user_permissions)
  return user_permissions_;
}

// -------------------------------------------------------------------

// UsbUserPermissionsManagerProto

// optional int32 user_id = 1;
inline bool UsbUserPermissionsManagerProto::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbUserPermissionsManagerProto::clear_user_id() {
  user_id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbUserPermissionsManagerProto::user_id() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbUserPermissionsManagerProto.user_id)
  return user_id_;
}
inline void UsbUserPermissionsManagerProto::set_user_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  user_id_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbUserPermissionsManagerProto.user_id)
}

// repeated .android.service.usb.UsbDevicePermissionProto device_permissions = 2;
inline int UsbUserPermissionsManagerProto::device_permissions_size() const {
  return device_permissions_.size();
}
inline void UsbUserPermissionsManagerProto::clear_device_permissions() {
  device_permissions_.Clear();
}
inline ::android::service::usb::UsbDevicePermissionProto* UsbUserPermissionsManagerProto::mutable_device_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbUserPermissionsManagerProto.device_permissions)
  return device_permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbDevicePermissionProto >*
UsbUserPermissionsManagerProto::mutable_device_permissions() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbUserPermissionsManagerProto.device_permissions)
  return &device_permissions_;
}
inline const ::android::service::usb::UsbDevicePermissionProto& UsbUserPermissionsManagerProto::device_permissions(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbUserPermissionsManagerProto.device_permissions)
  return device_permissions_.Get(index);
}
inline ::android::service::usb::UsbDevicePermissionProto* UsbUserPermissionsManagerProto::add_device_permissions() {
  // @@protoc_insertion_point(field_add:android.service.usb.UsbUserPermissionsManagerProto.device_permissions)
  return device_permissions_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbDevicePermissionProto >&
UsbUserPermissionsManagerProto::device_permissions() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbUserPermissionsManagerProto.device_permissions)
  return device_permissions_;
}

// repeated .android.service.usb.UsbAccessoryPermissionProto accessory_permissions = 3;
inline int UsbUserPermissionsManagerProto::accessory_permissions_size() const {
  return accessory_permissions_.size();
}
inline void UsbUserPermissionsManagerProto::clear_accessory_permissions() {
  accessory_permissions_.Clear();
}
inline ::android::service::usb::UsbAccessoryPermissionProto* UsbUserPermissionsManagerProto::mutable_accessory_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbUserPermissionsManagerProto.accessory_permissions)
  return accessory_permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbAccessoryPermissionProto >*
UsbUserPermissionsManagerProto::mutable_accessory_permissions() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbUserPermissionsManagerProto.accessory_permissions)
  return &accessory_permissions_;
}
inline const ::android::service::usb::UsbAccessoryPermissionProto& UsbUserPermissionsManagerProto::accessory_permissions(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbUserPermissionsManagerProto.accessory_permissions)
  return accessory_permissions_.Get(index);
}
inline ::android::service::usb::UsbAccessoryPermissionProto* UsbUserPermissionsManagerProto::add_accessory_permissions() {
  // @@protoc_insertion_point(field_add:android.service.usb.UsbUserPermissionsManagerProto.accessory_permissions)
  return accessory_permissions_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbAccessoryPermissionProto >&
UsbUserPermissionsManagerProto::accessory_permissions() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbUserPermissionsManagerProto.accessory_permissions)
  return accessory_permissions_;
}

// repeated .android.service.usb.UsbDevicePersistentPermissionProto device_persistent_permissions = 4;
inline int UsbUserPermissionsManagerProto::device_persistent_permissions_size() const {
  return device_persistent_permissions_.size();
}
inline void UsbUserPermissionsManagerProto::clear_device_persistent_permissions() {
  device_persistent_permissions_.Clear();
}
inline ::android::service::usb::UsbDevicePersistentPermissionProto* UsbUserPermissionsManagerProto::mutable_device_persistent_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbUserPermissionsManagerProto.device_persistent_permissions)
  return device_persistent_permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbDevicePersistentPermissionProto >*
UsbUserPermissionsManagerProto::mutable_device_persistent_permissions() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbUserPermissionsManagerProto.device_persistent_permissions)
  return &device_persistent_permissions_;
}
inline const ::android::service::usb::UsbDevicePersistentPermissionProto& UsbUserPermissionsManagerProto::device_persistent_permissions(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbUserPermissionsManagerProto.device_persistent_permissions)
  return device_persistent_permissions_.Get(index);
}
inline ::android::service::usb::UsbDevicePersistentPermissionProto* UsbUserPermissionsManagerProto::add_device_persistent_permissions() {
  // @@protoc_insertion_point(field_add:android.service.usb.UsbUserPermissionsManagerProto.device_persistent_permissions)
  return device_persistent_permissions_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbDevicePersistentPermissionProto >&
UsbUserPermissionsManagerProto::device_persistent_permissions() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbUserPermissionsManagerProto.device_persistent_permissions)
  return device_persistent_permissions_;
}

// repeated .android.service.usb.UsbAccessoryPersistentPermissionProto accessory_persistent_permissions = 5;
inline int UsbUserPermissionsManagerProto::accessory_persistent_permissions_size() const {
  return accessory_persistent_permissions_.size();
}
inline void UsbUserPermissionsManagerProto::clear_accessory_persistent_permissions() {
  accessory_persistent_permissions_.Clear();
}
inline ::android::service::usb::UsbAccessoryPersistentPermissionProto* UsbUserPermissionsManagerProto::mutable_accessory_persistent_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbUserPermissionsManagerProto.accessory_persistent_permissions)
  return accessory_persistent_permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbAccessoryPersistentPermissionProto >*
UsbUserPermissionsManagerProto::mutable_accessory_persistent_permissions() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbUserPermissionsManagerProto.accessory_persistent_permissions)
  return &accessory_persistent_permissions_;
}
inline const ::android::service::usb::UsbAccessoryPersistentPermissionProto& UsbUserPermissionsManagerProto::accessory_persistent_permissions(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbUserPermissionsManagerProto.accessory_persistent_permissions)
  return accessory_persistent_permissions_.Get(index);
}
inline ::android::service::usb::UsbAccessoryPersistentPermissionProto* UsbUserPermissionsManagerProto::add_accessory_persistent_permissions() {
  // @@protoc_insertion_point(field_add:android.service.usb.UsbUserPermissionsManagerProto.accessory_persistent_permissions)
  return accessory_persistent_permissions_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbAccessoryPersistentPermissionProto >&
UsbUserPermissionsManagerProto::accessory_persistent_permissions() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbUserPermissionsManagerProto.accessory_persistent_permissions)
  return accessory_persistent_permissions_;
}

// -------------------------------------------------------------------

// UsbDevicePermissionProto

// optional string device_name = 1;
inline bool UsbDevicePermissionProto::has_device_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbDevicePermissionProto::clear_device_name() {
  device_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UsbDevicePermissionProto::device_name() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDevicePermissionProto.device_name)
  return device_name_.GetNoArena();
}
inline void UsbDevicePermissionProto::set_device_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  device_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbDevicePermissionProto.device_name)
}
inline void UsbDevicePermissionProto::set_device_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  device_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbDevicePermissionProto.device_name)
}
inline void UsbDevicePermissionProto::set_device_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  device_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbDevicePermissionProto.device_name)
}
inline void UsbDevicePermissionProto::set_device_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  device_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbDevicePermissionProto.device_name)
}
inline std::string* UsbDevicePermissionProto::mutable_device_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbDevicePermissionProto.device_name)
  return device_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbDevicePermissionProto::release_device_name() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbDevicePermissionProto.device_name)
  if (!has_device_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return device_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbDevicePermissionProto::set_allocated_device_name(std::string* device_name) {
  if (device_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  device_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_name);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbDevicePermissionProto.device_name)
}

// repeated int32 uids = 2;
inline int UsbDevicePermissionProto::uids_size() const {
  return uids_.size();
}
inline void UsbDevicePermissionProto::clear_uids() {
  uids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbDevicePermissionProto::uids(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDevicePermissionProto.uids)
  return uids_.Get(index);
}
inline void UsbDevicePermissionProto::set_uids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  uids_.Set(index, value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbDevicePermissionProto.uids)
}
inline void UsbDevicePermissionProto::add_uids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  uids_.Add(value);
  // @@protoc_insertion_point(field_add:android.service.usb.UsbDevicePermissionProto.uids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
UsbDevicePermissionProto::uids() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbDevicePermissionProto.uids)
  return uids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
UsbDevicePermissionProto::mutable_uids() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbDevicePermissionProto.uids)
  return &uids_;
}

// -------------------------------------------------------------------

// UsbAccessoryPermissionProto

// optional string accessory_description = 1;
inline bool UsbAccessoryPermissionProto::has_accessory_description() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbAccessoryPermissionProto::clear_accessory_description() {
  accessory_description_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UsbAccessoryPermissionProto::accessory_description() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbAccessoryPermissionProto.accessory_description)
  return accessory_description_.GetNoArena();
}
inline void UsbAccessoryPermissionProto::set_accessory_description(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  accessory_description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbAccessoryPermissionProto.accessory_description)
}
inline void UsbAccessoryPermissionProto::set_accessory_description(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  accessory_description_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbAccessoryPermissionProto.accessory_description)
}
inline void UsbAccessoryPermissionProto::set_accessory_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  accessory_description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbAccessoryPermissionProto.accessory_description)
}
inline void UsbAccessoryPermissionProto::set_accessory_description(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  accessory_description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbAccessoryPermissionProto.accessory_description)
}
inline std::string* UsbAccessoryPermissionProto::mutable_accessory_description() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbAccessoryPermissionProto.accessory_description)
  return accessory_description_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbAccessoryPermissionProto::release_accessory_description() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbAccessoryPermissionProto.accessory_description)
  if (!has_accessory_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return accessory_description_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbAccessoryPermissionProto::set_allocated_accessory_description(std::string* accessory_description) {
  if (accessory_description != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  accessory_description_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), accessory_description);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbAccessoryPermissionProto.accessory_description)
}

// repeated int32 uids = 2;
inline int UsbAccessoryPermissionProto::uids_size() const {
  return uids_.size();
}
inline void UsbAccessoryPermissionProto::clear_uids() {
  uids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbAccessoryPermissionProto::uids(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbAccessoryPermissionProto.uids)
  return uids_.Get(index);
}
inline void UsbAccessoryPermissionProto::set_uids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  uids_.Set(index, value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbAccessoryPermissionProto.uids)
}
inline void UsbAccessoryPermissionProto::add_uids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  uids_.Add(value);
  // @@protoc_insertion_point(field_add:android.service.usb.UsbAccessoryPermissionProto.uids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
UsbAccessoryPermissionProto::uids() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbAccessoryPermissionProto.uids)
  return uids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
UsbAccessoryPermissionProto::mutable_uids() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbAccessoryPermissionProto.uids)
  return &uids_;
}

// -------------------------------------------------------------------

// UsbDevicePersistentPermissionProto

// optional .android.service.usb.UsbDeviceFilterProto device_filter = 1;
inline bool UsbDevicePersistentPermissionProto::has_device_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbDevicePersistentPermissionProto::clear_device_filter() {
  if (device_filter_ != nullptr) device_filter_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::android::service::usb::UsbDeviceFilterProto& UsbDevicePersistentPermissionProto::device_filter() const {
  const ::android::service::usb::UsbDeviceFilterProto* p = device_filter_;
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDevicePersistentPermissionProto.device_filter)
  return p != nullptr ? *p : *reinterpret_cast<const ::android::service::usb::UsbDeviceFilterProto*>(
      &::android::service::usb::_UsbDeviceFilterProto_default_instance_);
}
inline ::android::service::usb::UsbDeviceFilterProto* UsbDevicePersistentPermissionProto::release_device_filter() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbDevicePersistentPermissionProto.device_filter)
  _has_bits_[0] &= ~0x00000001u;
  ::android::service::usb::UsbDeviceFilterProto* temp = device_filter_;
  device_filter_ = nullptr;
  return temp;
}
inline ::android::service::usb::UsbDeviceFilterProto* UsbDevicePersistentPermissionProto::mutable_device_filter() {
  _has_bits_[0] |= 0x00000001u;
  if (device_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::service::usb::UsbDeviceFilterProto>(GetArenaNoVirtual());
    device_filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbDevicePersistentPermissionProto.device_filter)
  return device_filter_;
}
inline void UsbDevicePersistentPermissionProto::set_allocated_device_filter(::android::service::usb::UsbDeviceFilterProto* device_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete device_filter_;
  }
  if (device_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      device_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_filter, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  device_filter_ = device_filter;
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbDevicePersistentPermissionProto.device_filter)
}

// repeated .android.service.usb.UsbUidPermissionProto permission_values = 2;
inline int UsbDevicePersistentPermissionProto::permission_values_size() const {
  return permission_values_.size();
}
inline void UsbDevicePersistentPermissionProto::clear_permission_values() {
  permission_values_.Clear();
}
inline ::android::service::usb::UsbUidPermissionProto* UsbDevicePersistentPermissionProto::mutable_permission_values(int index) {
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbDevicePersistentPermissionProto.permission_values)
  return permission_values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbUidPermissionProto >*
UsbDevicePersistentPermissionProto::mutable_permission_values() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbDevicePersistentPermissionProto.permission_values)
  return &permission_values_;
}
inline const ::android::service::usb::UsbUidPermissionProto& UsbDevicePersistentPermissionProto::permission_values(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDevicePersistentPermissionProto.permission_values)
  return permission_values_.Get(index);
}
inline ::android::service::usb::UsbUidPermissionProto* UsbDevicePersistentPermissionProto::add_permission_values() {
  // @@protoc_insertion_point(field_add:android.service.usb.UsbDevicePersistentPermissionProto.permission_values)
  return permission_values_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbUidPermissionProto >&
UsbDevicePersistentPermissionProto::permission_values() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbDevicePersistentPermissionProto.permission_values)
  return permission_values_;
}

// -------------------------------------------------------------------

// UsbAccessoryPersistentPermissionProto

// optional .android.service.usb.UsbAccessoryFilterProto accessory_filter = 1;
inline bool UsbAccessoryPersistentPermissionProto::has_accessory_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbAccessoryPersistentPermissionProto::clear_accessory_filter() {
  if (accessory_filter_ != nullptr) accessory_filter_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::android::service::usb::UsbAccessoryFilterProto& UsbAccessoryPersistentPermissionProto::accessory_filter() const {
  const ::android::service::usb::UsbAccessoryFilterProto* p = accessory_filter_;
  // @@protoc_insertion_point(field_get:android.service.usb.UsbAccessoryPersistentPermissionProto.accessory_filter)
  return p != nullptr ? *p : *reinterpret_cast<const ::android::service::usb::UsbAccessoryFilterProto*>(
      &::android::service::usb::_UsbAccessoryFilterProto_default_instance_);
}
inline ::android::service::usb::UsbAccessoryFilterProto* UsbAccessoryPersistentPermissionProto::release_accessory_filter() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbAccessoryPersistentPermissionProto.accessory_filter)
  _has_bits_[0] &= ~0x00000001u;
  ::android::service::usb::UsbAccessoryFilterProto* temp = accessory_filter_;
  accessory_filter_ = nullptr;
  return temp;
}
inline ::android::service::usb::UsbAccessoryFilterProto* UsbAccessoryPersistentPermissionProto::mutable_accessory_filter() {
  _has_bits_[0] |= 0x00000001u;
  if (accessory_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::service::usb::UsbAccessoryFilterProto>(GetArenaNoVirtual());
    accessory_filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbAccessoryPersistentPermissionProto.accessory_filter)
  return accessory_filter_;
}
inline void UsbAccessoryPersistentPermissionProto::set_allocated_accessory_filter(::android::service::usb::UsbAccessoryFilterProto* accessory_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete accessory_filter_;
  }
  if (accessory_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      accessory_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, accessory_filter, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  accessory_filter_ = accessory_filter;
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbAccessoryPersistentPermissionProto.accessory_filter)
}

// repeated .android.service.usb.UsbUidPermissionProto permission_values = 2;
inline int UsbAccessoryPersistentPermissionProto::permission_values_size() const {
  return permission_values_.size();
}
inline void UsbAccessoryPersistentPermissionProto::clear_permission_values() {
  permission_values_.Clear();
}
inline ::android::service::usb::UsbUidPermissionProto* UsbAccessoryPersistentPermissionProto::mutable_permission_values(int index) {
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbAccessoryPersistentPermissionProto.permission_values)
  return permission_values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbUidPermissionProto >*
UsbAccessoryPersistentPermissionProto::mutable_permission_values() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbAccessoryPersistentPermissionProto.permission_values)
  return &permission_values_;
}
inline const ::android::service::usb::UsbUidPermissionProto& UsbAccessoryPersistentPermissionProto::permission_values(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbAccessoryPersistentPermissionProto.permission_values)
  return permission_values_.Get(index);
}
inline ::android::service::usb::UsbUidPermissionProto* UsbAccessoryPersistentPermissionProto::add_permission_values() {
  // @@protoc_insertion_point(field_add:android.service.usb.UsbAccessoryPersistentPermissionProto.permission_values)
  return permission_values_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbUidPermissionProto >&
UsbAccessoryPersistentPermissionProto::permission_values() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbAccessoryPersistentPermissionProto.permission_values)
  return permission_values_;
}

// -------------------------------------------------------------------

// UsbUidPermissionProto

// optional int32 uid = 1;
inline bool UsbUidPermissionProto::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbUidPermissionProto::clear_uid() {
  uid_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbUidPermissionProto::uid() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbUidPermissionProto.uid)
  return uid_;
}
inline void UsbUidPermissionProto::set_uid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  uid_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbUidPermissionProto.uid)
}

// optional bool is_granted = 2;
inline bool UsbUidPermissionProto::has_is_granted() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsbUidPermissionProto::clear_is_granted() {
  is_granted_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool UsbUidPermissionProto::is_granted() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbUidPermissionProto.is_granted)
  return is_granted_;
}
inline void UsbUidPermissionProto::set_is_granted(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_granted_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbUidPermissionProto.is_granted)
}

// -------------------------------------------------------------------

// UsbDeviceFilterProto

// optional int32 vendor_id = 1;
inline bool UsbDeviceFilterProto::has_vendor_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UsbDeviceFilterProto::clear_vendor_id() {
  vendor_id_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbDeviceFilterProto::vendor_id() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDeviceFilterProto.vendor_id)
  return vendor_id_;
}
inline void UsbDeviceFilterProto::set_vendor_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  vendor_id_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbDeviceFilterProto.vendor_id)
}

// optional int32 product_id = 2;
inline bool UsbDeviceFilterProto::has_product_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UsbDeviceFilterProto::clear_product_id() {
  product_id_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbDeviceFilterProto::product_id() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDeviceFilterProto.product_id)
  return product_id_;
}
inline void UsbDeviceFilterProto::set_product_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  product_id_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbDeviceFilterProto.product_id)
}

// optional int32 class = 3;
inline bool UsbDeviceFilterProto::has_class_() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UsbDeviceFilterProto::clear_class_() {
  class__ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbDeviceFilterProto::class_() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDeviceFilterProto.class)
  return class__;
}
inline void UsbDeviceFilterProto::set_class_(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  class__ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbDeviceFilterProto.class)
}

// optional int32 subclass = 4;
inline bool UsbDeviceFilterProto::has_subclass() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UsbDeviceFilterProto::clear_subclass() {
  subclass_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbDeviceFilterProto::subclass() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDeviceFilterProto.subclass)
  return subclass_;
}
inline void UsbDeviceFilterProto::set_subclass(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  subclass_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbDeviceFilterProto.subclass)
}

// optional int32 protocol = 5;
inline bool UsbDeviceFilterProto::has_protocol() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UsbDeviceFilterProto::clear_protocol() {
  protocol_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UsbDeviceFilterProto::protocol() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDeviceFilterProto.protocol)
  return protocol_;
}
inline void UsbDeviceFilterProto::set_protocol(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  protocol_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UsbDeviceFilterProto.protocol)
}

// optional string manufacturer_name = 6;
inline bool UsbDeviceFilterProto::has_manufacturer_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbDeviceFilterProto::clear_manufacturer_name() {
  manufacturer_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UsbDeviceFilterProto::manufacturer_name() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDeviceFilterProto.manufacturer_name)
  return manufacturer_name_.GetNoArena();
}
inline void UsbDeviceFilterProto::set_manufacturer_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  manufacturer_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbDeviceFilterProto.manufacturer_name)
}
inline void UsbDeviceFilterProto::set_manufacturer_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  manufacturer_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbDeviceFilterProto.manufacturer_name)
}
inline void UsbDeviceFilterProto::set_manufacturer_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  manufacturer_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbDeviceFilterProto.manufacturer_name)
}
inline void UsbDeviceFilterProto::set_manufacturer_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  manufacturer_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbDeviceFilterProto.manufacturer_name)
}
inline std::string* UsbDeviceFilterProto::mutable_manufacturer_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbDeviceFilterProto.manufacturer_name)
  return manufacturer_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbDeviceFilterProto::release_manufacturer_name() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbDeviceFilterProto.manufacturer_name)
  if (!has_manufacturer_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return manufacturer_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbDeviceFilterProto::set_allocated_manufacturer_name(std::string* manufacturer_name) {
  if (manufacturer_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  manufacturer_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), manufacturer_name);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbDeviceFilterProto.manufacturer_name)
}

// optional string product_name = 7;
inline bool UsbDeviceFilterProto::has_product_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsbDeviceFilterProto::clear_product_name() {
  product_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UsbDeviceFilterProto::product_name() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDeviceFilterProto.product_name)
  return product_name_.GetNoArena();
}
inline void UsbDeviceFilterProto::set_product_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  product_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbDeviceFilterProto.product_name)
}
inline void UsbDeviceFilterProto::set_product_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  product_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbDeviceFilterProto.product_name)
}
inline void UsbDeviceFilterProto::set_product_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  product_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbDeviceFilterProto.product_name)
}
inline void UsbDeviceFilterProto::set_product_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  product_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbDeviceFilterProto.product_name)
}
inline std::string* UsbDeviceFilterProto::mutable_product_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbDeviceFilterProto.product_name)
  return product_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbDeviceFilterProto::release_product_name() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbDeviceFilterProto.product_name)
  if (!has_product_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return product_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbDeviceFilterProto::set_allocated_product_name(std::string* product_name) {
  if (product_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  product_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), product_name);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbDeviceFilterProto.product_name)
}

// optional string serial_number = 8 [(.android.privacy) = {
inline bool UsbDeviceFilterProto::has_serial_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UsbDeviceFilterProto::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UsbDeviceFilterProto::serial_number() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDeviceFilterProto.serial_number)
  return serial_number_.GetNoArena();
}
inline void UsbDeviceFilterProto::set_serial_number(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  serial_number_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbDeviceFilterProto.serial_number)
}
inline void UsbDeviceFilterProto::set_serial_number(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  serial_number_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbDeviceFilterProto.serial_number)
}
inline void UsbDeviceFilterProto::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  serial_number_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbDeviceFilterProto.serial_number)
}
inline void UsbDeviceFilterProto::set_serial_number(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  serial_number_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbDeviceFilterProto.serial_number)
}
inline std::string* UsbDeviceFilterProto::mutable_serial_number() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbDeviceFilterProto.serial_number)
  return serial_number_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbDeviceFilterProto::release_serial_number() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbDeviceFilterProto.serial_number)
  if (!has_serial_number()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return serial_number_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbDeviceFilterProto::set_allocated_serial_number(std::string* serial_number) {
  if (serial_number != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  serial_number_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbDeviceFilterProto.serial_number)
}

// -------------------------------------------------------------------

// UserPackageProto

// optional int32 user_id = 1;
inline bool UserPackageProto::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserPackageProto::clear_user_id() {
  user_id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UserPackageProto::user_id() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UserPackageProto.user_id)
  return user_id_;
}
inline void UserPackageProto::set_user_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  user_id_ = value;
  // @@protoc_insertion_point(field_set:android.service.usb.UserPackageProto.user_id)
}

// optional string package_name = 2;
inline bool UserPackageProto::has_package_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserPackageProto::clear_package_name() {
  package_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserPackageProto::package_name() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UserPackageProto.package_name)
  return package_name_.GetNoArena();
}
inline void UserPackageProto::set_package_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  package_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UserPackageProto.package_name)
}
inline void UserPackageProto::set_package_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  package_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UserPackageProto.package_name)
}
inline void UserPackageProto::set_package_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  package_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UserPackageProto.package_name)
}
inline void UserPackageProto::set_package_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  package_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UserPackageProto.package_name)
}
inline std::string* UserPackageProto::mutable_package_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UserPackageProto.package_name)
  return package_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UserPackageProto::release_package_name() {
  // @@protoc_insertion_point(field_release:android.service.usb.UserPackageProto.package_name)
  if (!has_package_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return package_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UserPackageProto::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  package_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), package_name);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UserPackageProto.package_name)
}

// -------------------------------------------------------------------

// UsbSettingsAccessoryPreferenceProto

// optional .android.service.usb.UsbAccessoryFilterProto filter = 1;
inline bool UsbSettingsAccessoryPreferenceProto::has_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbSettingsAccessoryPreferenceProto::clear_filter() {
  if (filter_ != nullptr) filter_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::android::service::usb::UsbAccessoryFilterProto& UsbSettingsAccessoryPreferenceProto::filter() const {
  const ::android::service::usb::UsbAccessoryFilterProto* p = filter_;
  // @@protoc_insertion_point(field_get:android.service.usb.UsbSettingsAccessoryPreferenceProto.filter)
  return p != nullptr ? *p : *reinterpret_cast<const ::android::service::usb::UsbAccessoryFilterProto*>(
      &::android::service::usb::_UsbAccessoryFilterProto_default_instance_);
}
inline ::android::service::usb::UsbAccessoryFilterProto* UsbSettingsAccessoryPreferenceProto::release_filter() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbSettingsAccessoryPreferenceProto.filter)
  _has_bits_[0] &= ~0x00000001u;
  ::android::service::usb::UsbAccessoryFilterProto* temp = filter_;
  filter_ = nullptr;
  return temp;
}
inline ::android::service::usb::UsbAccessoryFilterProto* UsbSettingsAccessoryPreferenceProto::mutable_filter() {
  _has_bits_[0] |= 0x00000001u;
  if (filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::service::usb::UsbAccessoryFilterProto>(GetArenaNoVirtual());
    filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbSettingsAccessoryPreferenceProto.filter)
  return filter_;
}
inline void UsbSettingsAccessoryPreferenceProto::set_allocated_filter(::android::service::usb::UsbAccessoryFilterProto* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbSettingsAccessoryPreferenceProto.filter)
}

// optional .android.service.usb.UserPackageProto user_package = 2;
inline bool UsbSettingsAccessoryPreferenceProto::has_user_package() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsbSettingsAccessoryPreferenceProto::clear_user_package() {
  if (user_package_ != nullptr) user_package_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::android::service::usb::UserPackageProto& UsbSettingsAccessoryPreferenceProto::user_package() const {
  const ::android::service::usb::UserPackageProto* p = user_package_;
  // @@protoc_insertion_point(field_get:android.service.usb.UsbSettingsAccessoryPreferenceProto.user_package)
  return p != nullptr ? *p : *reinterpret_cast<const ::android::service::usb::UserPackageProto*>(
      &::android::service::usb::_UserPackageProto_default_instance_);
}
inline ::android::service::usb::UserPackageProto* UsbSettingsAccessoryPreferenceProto::release_user_package() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbSettingsAccessoryPreferenceProto.user_package)
  _has_bits_[0] &= ~0x00000002u;
  ::android::service::usb::UserPackageProto* temp = user_package_;
  user_package_ = nullptr;
  return temp;
}
inline ::android::service::usb::UserPackageProto* UsbSettingsAccessoryPreferenceProto::mutable_user_package() {
  _has_bits_[0] |= 0x00000002u;
  if (user_package_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::service::usb::UserPackageProto>(GetArenaNoVirtual());
    user_package_ = p;
  }
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbSettingsAccessoryPreferenceProto.user_package)
  return user_package_;
}
inline void UsbSettingsAccessoryPreferenceProto::set_allocated_user_package(::android::service::usb::UserPackageProto* user_package) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete user_package_;
  }
  if (user_package) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      user_package = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_package, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  user_package_ = user_package;
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbSettingsAccessoryPreferenceProto.user_package)
}

// -------------------------------------------------------------------

// UsbAccessoryFilterProto

// optional string manufacturer = 1;
inline bool UsbAccessoryFilterProto::has_manufacturer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsbAccessoryFilterProto::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UsbAccessoryFilterProto::manufacturer() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbAccessoryFilterProto.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void UsbAccessoryFilterProto::set_manufacturer(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  manufacturer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbAccessoryFilterProto.manufacturer)
}
inline void UsbAccessoryFilterProto::set_manufacturer(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  manufacturer_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbAccessoryFilterProto.manufacturer)
}
inline void UsbAccessoryFilterProto::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  manufacturer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbAccessoryFilterProto.manufacturer)
}
inline void UsbAccessoryFilterProto::set_manufacturer(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  manufacturer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbAccessoryFilterProto.manufacturer)
}
inline std::string* UsbAccessoryFilterProto::mutable_manufacturer() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbAccessoryFilterProto.manufacturer)
  return manufacturer_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbAccessoryFilterProto::release_manufacturer() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbAccessoryFilterProto.manufacturer)
  if (!has_manufacturer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return manufacturer_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbAccessoryFilterProto::set_allocated_manufacturer(std::string* manufacturer) {
  if (manufacturer != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  manufacturer_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbAccessoryFilterProto.manufacturer)
}

// optional string model = 2;
inline bool UsbAccessoryFilterProto::has_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsbAccessoryFilterProto::clear_model() {
  model_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UsbAccessoryFilterProto::model() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbAccessoryFilterProto.model)
  return model_.GetNoArena();
}
inline void UsbAccessoryFilterProto::set_model(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  model_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbAccessoryFilterProto.model)
}
inline void UsbAccessoryFilterProto::set_model(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  model_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbAccessoryFilterProto.model)
}
inline void UsbAccessoryFilterProto::set_model(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  model_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbAccessoryFilterProto.model)
}
inline void UsbAccessoryFilterProto::set_model(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  model_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbAccessoryFilterProto.model)
}
inline std::string* UsbAccessoryFilterProto::mutable_model() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbAccessoryFilterProto.model)
  return model_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbAccessoryFilterProto::release_model() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbAccessoryFilterProto.model)
  if (!has_model()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return model_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbAccessoryFilterProto::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  model_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbAccessoryFilterProto.model)
}

// optional string version = 3;
inline bool UsbAccessoryFilterProto::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UsbAccessoryFilterProto::clear_version() {
  version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UsbAccessoryFilterProto::version() const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbAccessoryFilterProto.version)
  return version_.GetNoArena();
}
inline void UsbAccessoryFilterProto::set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:android.service.usb.UsbAccessoryFilterProto.version)
}
inline void UsbAccessoryFilterProto::set_version(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.service.usb.UsbAccessoryFilterProto.version)
}
inline void UsbAccessoryFilterProto::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.service.usb.UsbAccessoryFilterProto.version)
}
inline void UsbAccessoryFilterProto::set_version(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.service.usb.UsbAccessoryFilterProto.version)
}
inline std::string* UsbAccessoryFilterProto::mutable_version() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbAccessoryFilterProto.version)
  return version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsbAccessoryFilterProto::release_version() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbAccessoryFilterProto.version)
  if (!has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsbAccessoryFilterProto::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbAccessoryFilterProto.version)
}

// -------------------------------------------------------------------

// UsbDeviceAttachedActivities

// optional .android.content.ComponentNameProto activity = 1;
inline bool UsbDeviceAttachedActivities::has_activity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::android::content::ComponentNameProto& UsbDeviceAttachedActivities::activity() const {
  const ::android::content::ComponentNameProto* p = activity_;
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDeviceAttachedActivities.activity)
  return p != nullptr ? *p : *reinterpret_cast<const ::android::content::ComponentNameProto*>(
      &::android::content::_ComponentNameProto_default_instance_);
}
inline ::android::content::ComponentNameProto* UsbDeviceAttachedActivities::release_activity() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbDeviceAttachedActivities.activity)
  _has_bits_[0] &= ~0x00000001u;
  ::android::content::ComponentNameProto* temp = activity_;
  activity_ = nullptr;
  return temp;
}
inline ::android::content::ComponentNameProto* UsbDeviceAttachedActivities::mutable_activity() {
  _has_bits_[0] |= 0x00000001u;
  if (activity_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::content::ComponentNameProto>(GetArenaNoVirtual());
    activity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbDeviceAttachedActivities.activity)
  return activity_;
}
inline void UsbDeviceAttachedActivities::set_allocated_activity(::android::content::ComponentNameProto* activity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(activity_);
  }
  if (activity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      activity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, activity, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  activity_ = activity;
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbDeviceAttachedActivities.activity)
}

// repeated .android.service.usb.UsbDeviceFilterProto filters = 2;
inline int UsbDeviceAttachedActivities::filters_size() const {
  return filters_.size();
}
inline void UsbDeviceAttachedActivities::clear_filters() {
  filters_.Clear();
}
inline ::android::service::usb::UsbDeviceFilterProto* UsbDeviceAttachedActivities::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbDeviceAttachedActivities.filters)
  return filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbDeviceFilterProto >*
UsbDeviceAttachedActivities::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbDeviceAttachedActivities.filters)
  return &filters_;
}
inline const ::android::service::usb::UsbDeviceFilterProto& UsbDeviceAttachedActivities::filters(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbDeviceAttachedActivities.filters)
  return filters_.Get(index);
}
inline ::android::service::usb::UsbDeviceFilterProto* UsbDeviceAttachedActivities::add_filters() {
  // @@protoc_insertion_point(field_add:android.service.usb.UsbDeviceAttachedActivities.filters)
  return filters_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbDeviceFilterProto >&
UsbDeviceAttachedActivities::filters() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbDeviceAttachedActivities.filters)
  return filters_;
}

// -------------------------------------------------------------------

// UsbAccessoryAttachedActivities

// optional .android.content.ComponentNameProto activity = 1;
inline bool UsbAccessoryAttachedActivities::has_activity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::android::content::ComponentNameProto& UsbAccessoryAttachedActivities::activity() const {
  const ::android::content::ComponentNameProto* p = activity_;
  // @@protoc_insertion_point(field_get:android.service.usb.UsbAccessoryAttachedActivities.activity)
  return p != nullptr ? *p : *reinterpret_cast<const ::android::content::ComponentNameProto*>(
      &::android::content::_ComponentNameProto_default_instance_);
}
inline ::android::content::ComponentNameProto* UsbAccessoryAttachedActivities::release_activity() {
  // @@protoc_insertion_point(field_release:android.service.usb.UsbAccessoryAttachedActivities.activity)
  _has_bits_[0] &= ~0x00000001u;
  ::android::content::ComponentNameProto* temp = activity_;
  activity_ = nullptr;
  return temp;
}
inline ::android::content::ComponentNameProto* UsbAccessoryAttachedActivities::mutable_activity() {
  _has_bits_[0] |= 0x00000001u;
  if (activity_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::content::ComponentNameProto>(GetArenaNoVirtual());
    activity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbAccessoryAttachedActivities.activity)
  return activity_;
}
inline void UsbAccessoryAttachedActivities::set_allocated_activity(::android::content::ComponentNameProto* activity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(activity_);
  }
  if (activity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      activity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, activity, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  activity_ = activity;
  // @@protoc_insertion_point(field_set_allocated:android.service.usb.UsbAccessoryAttachedActivities.activity)
}

// repeated .android.service.usb.UsbAccessoryFilterProto filters = 2;
inline int UsbAccessoryAttachedActivities::filters_size() const {
  return filters_.size();
}
inline void UsbAccessoryAttachedActivities::clear_filters() {
  filters_.Clear();
}
inline ::android::service::usb::UsbAccessoryFilterProto* UsbAccessoryAttachedActivities::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:android.service.usb.UsbAccessoryAttachedActivities.filters)
  return filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbAccessoryFilterProto >*
UsbAccessoryAttachedActivities::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:android.service.usb.UsbAccessoryAttachedActivities.filters)
  return &filters_;
}
inline const ::android::service::usb::UsbAccessoryFilterProto& UsbAccessoryAttachedActivities::filters(int index) const {
  // @@protoc_insertion_point(field_get:android.service.usb.UsbAccessoryAttachedActivities.filters)
  return filters_.Get(index);
}
inline ::android::service::usb::UsbAccessoryFilterProto* UsbAccessoryAttachedActivities::add_filters() {
  // @@protoc_insertion_point(field_add:android.service.usb.UsbAccessoryAttachedActivities.filters)
  return filters_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::service::usb::UsbAccessoryFilterProto >&
UsbAccessoryAttachedActivities::filters() const {
  // @@protoc_insertion_point(field_list:android.service.usb.UsbAccessoryAttachedActivities.filters)
  return filters_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace usb
}  // namespace service
}  // namespace android

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::android::service::usb::UsbHandlerProto_Function> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::service::usb::UsbHandlerProto_Function>() {
  return ::android::service::usb::UsbHandlerProto_Function_descriptor();
}
template <> struct is_proto_enum< ::android::service::usb::UsbPortProto_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::service::usb::UsbPortProto_Mode>() {
  return ::android::service::usb::UsbPortProto_Mode_descriptor();
}
template <> struct is_proto_enum< ::android::service::usb::UsbPortStatusProto_PowerRole> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::service::usb::UsbPortStatusProto_PowerRole>() {
  return ::android::service::usb::UsbPortStatusProto_PowerRole_descriptor();
}
template <> struct is_proto_enum< ::android::service::usb::UsbPortStatusProto_DataRole> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::service::usb::UsbPortStatusProto_DataRole>() {
  return ::android::service::usb::UsbPortStatusProto_DataRole_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_frameworks_2fbase_2fcore_2fproto_2fandroid_2fservice_2fusb_2eproto
