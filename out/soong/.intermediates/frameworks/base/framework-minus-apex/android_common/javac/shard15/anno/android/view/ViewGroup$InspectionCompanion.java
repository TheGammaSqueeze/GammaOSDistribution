package android.view;

import android.R;
import android.util.SparseArray;
import android.view.inspector.InspectionCompanion;
import android.view.inspector.PropertyMapper;
import android.view.inspector.PropertyReader;
import java.lang.Override;
import java.lang.String;

/**
 * Inspection companion for {@link ViewGroup}.
 *
 * Generated by {@link android.processor.view.inspector.InspectionCompanionGenerator}
 * on behalf of {@link android.processor.view.inspector.PlatformInspectableProcessor}.
 */
public final class ViewGroup$InspectionCompanion implements InspectionCompanion<ViewGroup> {
    /**
     * Guards against reading properties before mapping them.
     */
    private boolean mPropertiesMapped = false;

    /**
     * Property ID of {@code addStatesFromChildren}.
     */
    private int mAddStatesFromChildrenId;

    /**
     * Property ID of {@code alwaysDrawnWithCache}.
     */
    private int mAlwaysDrawnWithCacheId;

    /**
     * Property ID of {@code animationCache}.
     */
    private int mAnimationCacheId;

    /**
     * Property ID of {@code clipChildren}.
     */
    private int mClipChildrenId;

    /**
     * Property ID of {@code clipToPadding}.
     */
    private int mClipToPaddingId;

    /**
     * Property ID of {@code descendantFocusability}.
     */
    private int mDescendantFocusabilityId;

    /**
     * Property ID of {@code layoutAnimation}.
     */
    private int mLayoutAnimationId;

    /**
     * Property ID of {@code layoutMode}.
     */
    private int mLayoutModeId;

    /**
     * Property ID of {@code persistentDrawingCache}.
     */
    private int mPersistentDrawingCacheId;

    /**
     * Property ID of {@code splitMotionEvents}.
     */
    private int mSplitMotionEventsId;

    /**
     * Property ID of {@code touchscreenBlocksFocus}.
     */
    private int mTouchscreenBlocksFocusId;

    /**
     * Property ID of {@code transitionGroup}.
     */
    private int mTransitionGroupId;

    @Override
    public void mapProperties(PropertyMapper propertyMapper) {
        mAddStatesFromChildrenId = propertyMapper.mapBoolean("addStatesFromChildren", R.attr.addStatesFromChildren);
        mAlwaysDrawnWithCacheId = propertyMapper.mapBoolean("alwaysDrawnWithCache", R.attr.alwaysDrawnWithCache);
        mAnimationCacheId = propertyMapper.mapBoolean("animationCache", R.attr.animationCache);
        mClipChildrenId = propertyMapper.mapBoolean("clipChildren", R.attr.clipChildren);
        mClipToPaddingId = propertyMapper.mapBoolean("clipToPadding", R.attr.clipToPadding);
        final SparseArray<String> descendantFocusabilityEnumMapping = new SparseArray<>();
        descendantFocusabilityEnumMapping.put(131072, "beforeDescendants");
        descendantFocusabilityEnumMapping.put(262144, "afterDescendants");
        descendantFocusabilityEnumMapping.put(393216, "blocksDescendants");
        mDescendantFocusabilityId = propertyMapper.mapIntEnum("descendantFocusability", R.attr.descendantFocusability, descendantFocusabilityEnumMapping::get);
        mLayoutAnimationId = propertyMapper.mapObject("layoutAnimation", R.attr.layoutAnimation);
        final SparseArray<String> layoutModeEnumMapping = new SparseArray<>();
        layoutModeEnumMapping.put(0, "clipBounds");
        layoutModeEnumMapping.put(1, "opticalBounds");
        mLayoutModeId = propertyMapper.mapIntEnum("layoutMode", R.attr.layoutMode, layoutModeEnumMapping::get);
        final SparseArray<String> persistentDrawingCacheEnumMapping = new SparseArray<>();
        persistentDrawingCacheEnumMapping.put(0, "none");
        persistentDrawingCacheEnumMapping.put(1, "animation");
        persistentDrawingCacheEnumMapping.put(2, "scrolling");
        persistentDrawingCacheEnumMapping.put(3, "all");
        mPersistentDrawingCacheId = propertyMapper.mapIntEnum("persistentDrawingCache", R.attr.persistentDrawingCache, persistentDrawingCacheEnumMapping::get);
        mSplitMotionEventsId = propertyMapper.mapBoolean("splitMotionEvents", R.attr.splitMotionEvents);
        mTouchscreenBlocksFocusId = propertyMapper.mapBoolean("touchscreenBlocksFocus", R.attr.touchscreenBlocksFocus);
        mTransitionGroupId = propertyMapper.mapBoolean("transitionGroup", R.attr.transitionGroup);
        mPropertiesMapped = true;
    }

    @Override
    public void readProperties(ViewGroup node, PropertyReader propertyReader) {
        if (!mPropertiesMapped) {
            throw new InspectionCompanion.UninitializedPropertyMapException();
        }
        propertyReader.readBoolean(mAddStatesFromChildrenId, node.addStatesFromChildren());
        propertyReader.readBoolean(mAlwaysDrawnWithCacheId, node.isAlwaysDrawnWithCacheEnabled());
        propertyReader.readBoolean(mAnimationCacheId, node.isAnimationCacheEnabled());
        propertyReader.readBoolean(mClipChildrenId, node.getClipChildren());
        propertyReader.readBoolean(mClipToPaddingId, node.getClipToPadding());
        propertyReader.readIntEnum(mDescendantFocusabilityId, node.getDescendantFocusability());
        propertyReader.readObject(mLayoutAnimationId, node.getLayoutAnimation());
        propertyReader.readIntEnum(mLayoutModeId, node.getLayoutMode());
        propertyReader.readIntEnum(mPersistentDrawingCacheId, node.getPersistentDrawingCache());
        propertyReader.readBoolean(mSplitMotionEventsId, node.isMotionEventSplittingEnabled());
        propertyReader.readBoolean(mTouchscreenBlocksFocusId, node.getTouchscreenBlocksFocus());
        propertyReader.readBoolean(mTransitionGroupId, node.isTransitionGroup());
    }
}
