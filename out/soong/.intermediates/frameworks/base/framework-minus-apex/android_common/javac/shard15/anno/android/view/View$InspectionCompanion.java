package android.view;

import android.R;
import android.util.SparseArray;
import android.view.inspector.InspectionCompanion;
import android.view.inspector.IntFlagMapping;
import android.view.inspector.PropertyMapper;
import android.view.inspector.PropertyReader;
import java.lang.Override;
import java.lang.String;

/**
 * Inspection companion for {@link View}.
 *
 * Generated by {@link android.processor.view.inspector.InspectionCompanionGenerator}
 * on behalf of {@link android.processor.view.inspector.PlatformInspectableProcessor}.
 */
public final class View$InspectionCompanion implements InspectionCompanion<View> {
    /**
     * Guards against reading properties before mapping them.
     */
    private boolean mPropertiesMapped = false;

    /**
     * Property ID of {@code accessibilityFocused}.
     */
    private int mAccessibilityFocusedId;

    /**
     * Property ID of {@code accessibilityHeading}.
     */
    private int mAccessibilityHeadingId;

    /**
     * Property ID of {@code accessibilityLiveRegion}.
     */
    private int mAccessibilityLiveRegionId;

    /**
     * Property ID of {@code accessibilityPaneTitle}.
     */
    private int mAccessibilityPaneTitleId;

    /**
     * Property ID of {@code accessibilityTraversalAfter}.
     */
    private int mAccessibilityTraversalAfterId;

    /**
     * Property ID of {@code accessibilityTraversalBefore}.
     */
    private int mAccessibilityTraversalBeforeId;

    /**
     * Property ID of {@code activated}.
     */
    private int mActivatedId;

    /**
     * Property ID of {@code alpha}.
     */
    private int mAlphaId;

    /**
     * Property ID of {@code autofillHints}.
     */
    private int mAutofillHintsId;

    /**
     * Property ID of {@code background}.
     */
    private int mBackgroundId;

    /**
     * Property ID of {@code backgroundTint}.
     */
    private int mBackgroundTintId;

    /**
     * Property ID of {@code backgroundTintMode}.
     */
    private int mBackgroundTintModeId;

    /**
     * Property ID of {@code baseline}.
     */
    private int mBaselineId;

    /**
     * Property ID of {@code clickable}.
     */
    private int mClickableId;

    /**
     * Property ID of {@code contentDescription}.
     */
    private int mContentDescriptionId;

    /**
     * Property ID of {@code contextClickable}.
     */
    private int mContextClickableId;

    /**
     * Property ID of {@code defaultFocusHighlightEnabled}.
     */
    private int mDefaultFocusHighlightEnabledId;

    /**
     * Property ID of {@code drawingCacheQuality}.
     */
    private int mDrawingCacheQualityId;

    /**
     * Property ID of {@code duplicateParentState}.
     */
    private int mDuplicateParentStateId;

    /**
     * Property ID of {@code elevation}.
     */
    private int mElevationId;

    /**
     * Property ID of {@code enabled}.
     */
    private int mEnabledId;

    /**
     * Property ID of {@code fadingEdgeLength}.
     */
    private int mFadingEdgeLengthId;

    /**
     * Property ID of {@code filterTouchesWhenObscured}.
     */
    private int mFilterTouchesWhenObscuredId;

    /**
     * Property ID of {@code fitsSystemWindows}.
     */
    private int mFitsSystemWindowsId;

    /**
     * Property ID of {@code focusable}.
     */
    private int mFocusableId;

    /**
     * Property ID of {@code focusableInTouchMode}.
     */
    private int mFocusableInTouchModeId;

    /**
     * Property ID of {@code focused}.
     */
    private int mFocusedId;

    /**
     * Property ID of {@code focusedByDefault}.
     */
    private int mFocusedByDefaultId;

    /**
     * Property ID of {@code forceDarkAllowed}.
     */
    private int mForceDarkAllowedId;

    /**
     * Property ID of {@code foreground}.
     */
    private int mForegroundId;

    /**
     * Property ID of {@code foregroundGravity}.
     */
    private int mForegroundGravityId;

    /**
     * Property ID of {@code foregroundTint}.
     */
    private int mForegroundTintId;

    /**
     * Property ID of {@code foregroundTintMode}.
     */
    private int mForegroundTintModeId;

    /**
     * Property ID of {@code hapticFeedbackEnabled}.
     */
    private int mHapticFeedbackEnabledId;

    /**
     * Property ID of {@code id}.
     */
    private int mIdId;

    /**
     * Property ID of {@code importantForAccessibility}.
     */
    private int mImportantForAccessibilityId;

    /**
     * Property ID of {@code importantForAutofill}.
     */
    private int mImportantForAutofillId;

    /**
     * Property ID of {@code importantForContentCapture}.
     */
    private int mImportantForContentCaptureId;

    /**
     * Property ID of {@code isScrollContainer}.
     */
    private int mIsScrollContainerId;

    /**
     * Property ID of {@code keepScreenOn}.
     */
    private int mKeepScreenOnId;

    /**
     * Property ID of {@code keyboardNavigationCluster}.
     */
    private int mKeyboardNavigationClusterId;

    /**
     * Property ID of {@code labelFor}.
     */
    private int mLabelForId;

    /**
     * Property ID of {@code layerType}.
     */
    private int mLayerTypeId;

    /**
     * Property ID of {@code layoutDirection}.
     */
    private int mLayoutDirectionId;

    /**
     * Property ID of {@code longClickable}.
     */
    private int mLongClickableId;

    /**
     * Property ID of {@code minHeight}.
     */
    private int mMinHeightId;

    /**
     * Property ID of {@code minWidth}.
     */
    private int mMinWidthId;

    /**
     * Property ID of {@code nestedScrollingEnabled}.
     */
    private int mNestedScrollingEnabledId;

    /**
     * Property ID of {@code nextClusterForward}.
     */
    private int mNextClusterForwardId;

    /**
     * Property ID of {@code nextFocusDown}.
     */
    private int mNextFocusDownId;

    /**
     * Property ID of {@code nextFocusForward}.
     */
    private int mNextFocusForwardId;

    /**
     * Property ID of {@code nextFocusLeft}.
     */
    private int mNextFocusLeftId;

    /**
     * Property ID of {@code nextFocusRight}.
     */
    private int mNextFocusRightId;

    /**
     * Property ID of {@code nextFocusUp}.
     */
    private int mNextFocusUpId;

    /**
     * Property ID of {@code outlineAmbientShadowColor}.
     */
    private int mOutlineAmbientShadowColorId;

    /**
     * Property ID of {@code outlineProvider}.
     */
    private int mOutlineProviderId;

    /**
     * Property ID of {@code outlineSpotShadowColor}.
     */
    private int mOutlineSpotShadowColorId;

    /**
     * Property ID of {@code overScrollMode}.
     */
    private int mOverScrollModeId;

    /**
     * Property ID of {@code paddingBottom}.
     */
    private int mPaddingBottomId;

    /**
     * Property ID of {@code paddingLeft}.
     */
    private int mPaddingLeftId;

    /**
     * Property ID of {@code paddingRight}.
     */
    private int mPaddingRightId;

    /**
     * Property ID of {@code paddingTop}.
     */
    private int mPaddingTopId;

    /**
     * Property ID of {@code pointerIcon}.
     */
    private int mPointerIconId;

    /**
     * Property ID of {@code pressed}.
     */
    private int mPressedId;

    /**
     * Property ID of {@code rawLayoutDirection}.
     */
    private int mRawLayoutDirectionId;

    /**
     * Property ID of {@code rawTextAlignment}.
     */
    private int mRawTextAlignmentId;

    /**
     * Property ID of {@code rawTextDirection}.
     */
    private int mRawTextDirectionId;

    /**
     * Property ID of {@code requiresFadingEdge}.
     */
    private int mRequiresFadingEdgeId;

    /**
     * Property ID of {@code rotation}.
     */
    private int mRotationId;

    /**
     * Property ID of {@code rotationX}.
     */
    private int mRotationXId;

    /**
     * Property ID of {@code rotationY}.
     */
    private int mRotationYId;

    /**
     * Property ID of {@code saveEnabled}.
     */
    private int mSaveEnabledId;

    /**
     * Property ID of {@code scaleX}.
     */
    private int mScaleXId;

    /**
     * Property ID of {@code scaleY}.
     */
    private int mScaleYId;

    /**
     * Property ID of {@code screenReaderFocusable}.
     */
    private int mScreenReaderFocusableId;

    /**
     * Property ID of {@code scrollIndicators}.
     */
    private int mScrollIndicatorsId;

    /**
     * Property ID of {@code scrollX}.
     */
    private int mScrollXId;

    /**
     * Property ID of {@code scrollY}.
     */
    private int mScrollYId;

    /**
     * Property ID of {@code scrollbarDefaultDelayBeforeFade}.
     */
    private int mScrollbarDefaultDelayBeforeFadeId;

    /**
     * Property ID of {@code scrollbarFadeDuration}.
     */
    private int mScrollbarFadeDurationId;

    /**
     * Property ID of {@code scrollbarSize}.
     */
    private int mScrollbarSizeId;

    /**
     * Property ID of {@code scrollbarStyle}.
     */
    private int mScrollbarStyleId;

    /**
     * Property ID of {@code selected}.
     */
    private int mSelectedId;

    /**
     * Property ID of {@code solidColor}.
     */
    private int mSolidColorId;

    /**
     * Property ID of {@code soundEffectsEnabled}.
     */
    private int mSoundEffectsEnabledId;

    /**
     * Property ID of {@code stateListAnimator}.
     */
    private int mStateListAnimatorId;

    /**
     * Property ID of {@code tag}.
     */
    private int mTagId;

    /**
     * Property ID of {@code textAlignment}.
     */
    private int mTextAlignmentId;

    /**
     * Property ID of {@code textDirection}.
     */
    private int mTextDirectionId;

    /**
     * Property ID of {@code tooltipText}.
     */
    private int mTooltipTextId;

    /**
     * Property ID of {@code transformPivotX}.
     */
    private int mTransformPivotXId;

    /**
     * Property ID of {@code transformPivotY}.
     */
    private int mTransformPivotYId;

    /**
     * Property ID of {@code transitionName}.
     */
    private int mTransitionNameId;

    /**
     * Property ID of {@code translationX}.
     */
    private int mTranslationXId;

    /**
     * Property ID of {@code translationY}.
     */
    private int mTranslationYId;

    /**
     * Property ID of {@code translationZ}.
     */
    private int mTranslationZId;

    /**
     * Property ID of {@code visibility}.
     */
    private int mVisibilityId;

    @Override
    public void mapProperties(PropertyMapper propertyMapper) {
        mAccessibilityFocusedId = propertyMapper.mapBoolean("accessibilityFocused", 0);
        mAccessibilityHeadingId = propertyMapper.mapBoolean("accessibilityHeading", R.attr.accessibilityHeading);
        final SparseArray<String> accessibilityLiveRegionEnumMapping = new SparseArray<>();
        accessibilityLiveRegionEnumMapping.put(0, "none");
        accessibilityLiveRegionEnumMapping.put(1, "polite");
        accessibilityLiveRegionEnumMapping.put(2, "assertive");
        mAccessibilityLiveRegionId = propertyMapper.mapIntEnum("accessibilityLiveRegion", R.attr.accessibilityLiveRegion, accessibilityLiveRegionEnumMapping::get);
        mAccessibilityPaneTitleId = propertyMapper.mapObject("accessibilityPaneTitle", R.attr.accessibilityPaneTitle);
        mAccessibilityTraversalAfterId = propertyMapper.mapResourceId("accessibilityTraversalAfter", R.attr.accessibilityTraversalAfter);
        mAccessibilityTraversalBeforeId = propertyMapper.mapResourceId("accessibilityTraversalBefore", R.attr.accessibilityTraversalBefore);
        mActivatedId = propertyMapper.mapBoolean("activated", 0);
        mAlphaId = propertyMapper.mapFloat("alpha", R.attr.alpha);
        mAutofillHintsId = propertyMapper.mapObject("autofillHints", R.attr.autofillHints);
        mBackgroundId = propertyMapper.mapObject("background", R.attr.background);
        mBackgroundTintId = propertyMapper.mapObject("backgroundTint", R.attr.backgroundTint);
        mBackgroundTintModeId = propertyMapper.mapObject("backgroundTintMode", R.attr.backgroundTintMode);
        mBaselineId = propertyMapper.mapInt("baseline", R.attr.baseline);
        mClickableId = propertyMapper.mapBoolean("clickable", R.attr.clickable);
        mContentDescriptionId = propertyMapper.mapObject("contentDescription", R.attr.contentDescription);
        mContextClickableId = propertyMapper.mapBoolean("contextClickable", R.attr.contextClickable);
        mDefaultFocusHighlightEnabledId = propertyMapper.mapBoolean("defaultFocusHighlightEnabled", R.attr.defaultFocusHighlightEnabled);
        final SparseArray<String> drawingCacheQualityEnumMapping = new SparseArray<>();
        drawingCacheQualityEnumMapping.put(0, "auto");
        drawingCacheQualityEnumMapping.put(524288, "low");
        drawingCacheQualityEnumMapping.put(1048576, "high");
        mDrawingCacheQualityId = propertyMapper.mapIntEnum("drawingCacheQuality", R.attr.drawingCacheQuality, drawingCacheQualityEnumMapping::get);
        mDuplicateParentStateId = propertyMapper.mapBoolean("duplicateParentState", R.attr.duplicateParentState);
        mElevationId = propertyMapper.mapFloat("elevation", R.attr.elevation);
        mEnabledId = propertyMapper.mapBoolean("enabled", R.attr.enabled);
        mFadingEdgeLengthId = propertyMapper.mapInt("fadingEdgeLength", R.attr.fadingEdgeLength);
        mFilterTouchesWhenObscuredId = propertyMapper.mapBoolean("filterTouchesWhenObscured", R.attr.filterTouchesWhenObscured);
        mFitsSystemWindowsId = propertyMapper.mapBoolean("fitsSystemWindows", R.attr.fitsSystemWindows);
        final SparseArray<String> focusableEnumMapping = new SparseArray<>();
        focusableEnumMapping.put(0, "false");
        focusableEnumMapping.put(1, "true");
        focusableEnumMapping.put(16, "auto");
        mFocusableId = propertyMapper.mapIntEnum("focusable", R.attr.focusable, focusableEnumMapping::get);
        mFocusableInTouchModeId = propertyMapper.mapBoolean("focusableInTouchMode", R.attr.focusableInTouchMode);
        mFocusedId = propertyMapper.mapBoolean("focused", 0);
        mFocusedByDefaultId = propertyMapper.mapBoolean("focusedByDefault", R.attr.focusedByDefault);
        mForceDarkAllowedId = propertyMapper.mapBoolean("forceDarkAllowed", R.attr.forceDarkAllowed);
        mForegroundId = propertyMapper.mapObject("foreground", R.attr.foreground);
        mForegroundGravityId = propertyMapper.mapGravity("foregroundGravity", R.attr.foregroundGravity);
        mForegroundTintId = propertyMapper.mapObject("foregroundTint", R.attr.foregroundTint);
        mForegroundTintModeId = propertyMapper.mapObject("foregroundTintMode", R.attr.foregroundTintMode);
        mHapticFeedbackEnabledId = propertyMapper.mapBoolean("hapticFeedbackEnabled", R.attr.hapticFeedbackEnabled);
        mIdId = propertyMapper.mapResourceId("id", R.attr.id);
        final SparseArray<String> importantForAccessibilityEnumMapping = new SparseArray<>();
        importantForAccessibilityEnumMapping.put(0, "auto");
        importantForAccessibilityEnumMapping.put(1, "yes");
        importantForAccessibilityEnumMapping.put(2, "no");
        importantForAccessibilityEnumMapping.put(4, "noHideDescendants");
        mImportantForAccessibilityId = propertyMapper.mapIntEnum("importantForAccessibility", R.attr.importantForAccessibility, importantForAccessibilityEnumMapping::get);
        final SparseArray<String> importantForAutofillEnumMapping = new SparseArray<>();
        importantForAutofillEnumMapping.put(0, "auto");
        importantForAutofillEnumMapping.put(1, "yes");
        importantForAutofillEnumMapping.put(2, "no");
        importantForAutofillEnumMapping.put(4, "yesExcludeDescendants");
        importantForAutofillEnumMapping.put(8, "noExcludeDescendants");
        mImportantForAutofillId = propertyMapper.mapIntEnum("importantForAutofill", R.attr.importantForAutofill, importantForAutofillEnumMapping::get);
        final SparseArray<String> importantForContentCaptureEnumMapping = new SparseArray<>();
        importantForContentCaptureEnumMapping.put(0, "auto");
        importantForContentCaptureEnumMapping.put(1, "yes");
        importantForContentCaptureEnumMapping.put(2, "no");
        importantForContentCaptureEnumMapping.put(4, "yesExcludeDescendants");
        importantForContentCaptureEnumMapping.put(8, "noExcludeDescendants");
        mImportantForContentCaptureId = propertyMapper.mapIntEnum("importantForContentCapture", R.attr.importantForContentCapture, importantForContentCaptureEnumMapping::get);
        mIsScrollContainerId = propertyMapper.mapBoolean("isScrollContainer", R.attr.isScrollContainer);
        mKeepScreenOnId = propertyMapper.mapBoolean("keepScreenOn", R.attr.keepScreenOn);
        mKeyboardNavigationClusterId = propertyMapper.mapBoolean("keyboardNavigationCluster", R.attr.keyboardNavigationCluster);
        mLabelForId = propertyMapper.mapResourceId("labelFor", R.attr.labelFor);
        final SparseArray<String> layerTypeEnumMapping = new SparseArray<>();
        layerTypeEnumMapping.put(0, "none");
        layerTypeEnumMapping.put(1, "software");
        layerTypeEnumMapping.put(2, "hardware");
        mLayerTypeId = propertyMapper.mapIntEnum("layerType", R.attr.layerType, layerTypeEnumMapping::get);
        final SparseArray<String> layoutDirectionEnumMapping = new SparseArray<>();
        layoutDirectionEnumMapping.put(0, "ltr");
        layoutDirectionEnumMapping.put(1, "rtl");
        mLayoutDirectionId = propertyMapper.mapIntEnum("layoutDirection", R.attr.layoutDirection, layoutDirectionEnumMapping::get);
        mLongClickableId = propertyMapper.mapBoolean("longClickable", R.attr.longClickable);
        mMinHeightId = propertyMapper.mapInt("minHeight", R.attr.minHeight);
        mMinWidthId = propertyMapper.mapInt("minWidth", R.attr.minWidth);
        mNestedScrollingEnabledId = propertyMapper.mapBoolean("nestedScrollingEnabled", R.attr.nestedScrollingEnabled);
        mNextClusterForwardId = propertyMapper.mapResourceId("nextClusterForward", R.attr.nextClusterForward);
        mNextFocusDownId = propertyMapper.mapResourceId("nextFocusDown", R.attr.nextFocusDown);
        mNextFocusForwardId = propertyMapper.mapResourceId("nextFocusForward", R.attr.nextFocusForward);
        mNextFocusLeftId = propertyMapper.mapResourceId("nextFocusLeft", R.attr.nextFocusLeft);
        mNextFocusRightId = propertyMapper.mapResourceId("nextFocusRight", R.attr.nextFocusRight);
        mNextFocusUpId = propertyMapper.mapResourceId("nextFocusUp", R.attr.nextFocusUp);
        mOutlineAmbientShadowColorId = propertyMapper.mapColor("outlineAmbientShadowColor", R.attr.outlineAmbientShadowColor);
        mOutlineProviderId = propertyMapper.mapObject("outlineProvider", R.attr.outlineProvider);
        mOutlineSpotShadowColorId = propertyMapper.mapColor("outlineSpotShadowColor", R.attr.outlineSpotShadowColor);
        final SparseArray<String> overScrollModeEnumMapping = new SparseArray<>();
        overScrollModeEnumMapping.put(0, "always");
        overScrollModeEnumMapping.put(1, "ifContentScrolls");
        overScrollModeEnumMapping.put(2, "never");
        mOverScrollModeId = propertyMapper.mapIntEnum("overScrollMode", R.attr.overScrollMode, overScrollModeEnumMapping::get);
        mPaddingBottomId = propertyMapper.mapInt("paddingBottom", R.attr.paddingBottom);
        mPaddingLeftId = propertyMapper.mapInt("paddingLeft", R.attr.paddingLeft);
        mPaddingRightId = propertyMapper.mapInt("paddingRight", R.attr.paddingRight);
        mPaddingTopId = propertyMapper.mapInt("paddingTop", R.attr.paddingTop);
        mPointerIconId = propertyMapper.mapObject("pointerIcon", R.attr.pointerIcon);
        mPressedId = propertyMapper.mapBoolean("pressed", 0);
        final SparseArray<String> rawLayoutDirectionEnumMapping = new SparseArray<>();
        rawLayoutDirectionEnumMapping.put(0, "ltr");
        rawLayoutDirectionEnumMapping.put(1, "rtl");
        rawLayoutDirectionEnumMapping.put(2, "inherit");
        rawLayoutDirectionEnumMapping.put(3, "locale");
        mRawLayoutDirectionId = propertyMapper.mapIntEnum("rawLayoutDirection", 0, rawLayoutDirectionEnumMapping::get);
        final SparseArray<String> rawTextAlignmentEnumMapping = new SparseArray<>();
        rawTextAlignmentEnumMapping.put(0, "inherit");
        rawTextAlignmentEnumMapping.put(1, "gravity");
        rawTextAlignmentEnumMapping.put(2, "textStart");
        rawTextAlignmentEnumMapping.put(3, "textEnd");
        rawTextAlignmentEnumMapping.put(4, "center");
        rawTextAlignmentEnumMapping.put(5, "viewStart");
        rawTextAlignmentEnumMapping.put(6, "viewEnd");
        mRawTextAlignmentId = propertyMapper.mapIntEnum("rawTextAlignment", 0, rawTextAlignmentEnumMapping::get);
        final SparseArray<String> rawTextDirectionEnumMapping = new SparseArray<>();
        rawTextDirectionEnumMapping.put(0, "inherit");
        rawTextDirectionEnumMapping.put(1, "firstStrong");
        rawTextDirectionEnumMapping.put(2, "anyRtl");
        rawTextDirectionEnumMapping.put(3, "ltr");
        rawTextDirectionEnumMapping.put(4, "rtl");
        rawTextDirectionEnumMapping.put(5, "locale");
        rawTextDirectionEnumMapping.put(6, "firstStrongLtr");
        rawTextDirectionEnumMapping.put(7, "firstStrongRtl");
        mRawTextDirectionId = propertyMapper.mapIntEnum("rawTextDirection", 0, rawTextDirectionEnumMapping::get);
        final IntFlagMapping requiresFadingEdgeFlagMapping = new IntFlagMapping();
        requiresFadingEdgeFlagMapping.add(0x00001000, 0x00001000, "horizontal");
        requiresFadingEdgeFlagMapping.add(0x00003000, 0x00000000, "none");
        requiresFadingEdgeFlagMapping.add(0x00002000, 0x00002000, "vertical");
        mRequiresFadingEdgeId = propertyMapper.mapIntFlag("requiresFadingEdge", R.attr.requiresFadingEdge, requiresFadingEdgeFlagMapping::get);
        mRotationId = propertyMapper.mapFloat("rotation", R.attr.rotation);
        mRotationXId = propertyMapper.mapFloat("rotationX", R.attr.rotationX);
        mRotationYId = propertyMapper.mapFloat("rotationY", R.attr.rotationY);
        mSaveEnabledId = propertyMapper.mapBoolean("saveEnabled", R.attr.saveEnabled);
        mScaleXId = propertyMapper.mapFloat("scaleX", R.attr.scaleX);
        mScaleYId = propertyMapper.mapFloat("scaleY", R.attr.scaleY);
        mScreenReaderFocusableId = propertyMapper.mapBoolean("screenReaderFocusable", R.attr.screenReaderFocusable);
        final IntFlagMapping scrollIndicatorsFlagMapping = new IntFlagMapping();
        scrollIndicatorsFlagMapping.add(0x00000002, 0x00000002, "bottom");
        scrollIndicatorsFlagMapping.add(0x00000020, 0x00000020, "end");
        scrollIndicatorsFlagMapping.add(0x00000004, 0x00000004, "left");
        scrollIndicatorsFlagMapping.add(0xffffffff, 0x00000000, "none");
        scrollIndicatorsFlagMapping.add(0x00000008, 0x00000008, "right");
        scrollIndicatorsFlagMapping.add(0x00000010, 0x00000010, "start");
        scrollIndicatorsFlagMapping.add(0x00000001, 0x00000001, "top");
        mScrollIndicatorsId = propertyMapper.mapIntFlag("scrollIndicators", R.attr.scrollIndicators, scrollIndicatorsFlagMapping::get);
        mScrollXId = propertyMapper.mapInt("scrollX", R.attr.scrollX);
        mScrollYId = propertyMapper.mapInt("scrollY", R.attr.scrollY);
        mScrollbarDefaultDelayBeforeFadeId = propertyMapper.mapInt("scrollbarDefaultDelayBeforeFade", R.attr.scrollbarDefaultDelayBeforeFade);
        mScrollbarFadeDurationId = propertyMapper.mapInt("scrollbarFadeDuration", R.attr.scrollbarFadeDuration);
        mScrollbarSizeId = propertyMapper.mapInt("scrollbarSize", R.attr.scrollbarSize);
        final SparseArray<String> scrollbarStyleEnumMapping = new SparseArray<>();
        scrollbarStyleEnumMapping.put(0, "insideOverlay");
        scrollbarStyleEnumMapping.put(16777216, "insideInset");
        scrollbarStyleEnumMapping.put(33554432, "outsideOverlay");
        scrollbarStyleEnumMapping.put(50331648, "outsideInset");
        mScrollbarStyleId = propertyMapper.mapIntEnum("scrollbarStyle", R.attr.scrollbarStyle, scrollbarStyleEnumMapping::get);
        mSelectedId = propertyMapper.mapBoolean("selected", 0);
        mSolidColorId = propertyMapper.mapColor("solidColor", R.attr.solidColor);
        mSoundEffectsEnabledId = propertyMapper.mapBoolean("soundEffectsEnabled", R.attr.soundEffectsEnabled);
        mStateListAnimatorId = propertyMapper.mapObject("stateListAnimator", R.attr.stateListAnimator);
        mTagId = propertyMapper.mapObject("tag", R.attr.tag);
        final SparseArray<String> textAlignmentEnumMapping = new SparseArray<>();
        textAlignmentEnumMapping.put(1, "gravity");
        textAlignmentEnumMapping.put(2, "textStart");
        textAlignmentEnumMapping.put(3, "textEnd");
        textAlignmentEnumMapping.put(4, "center");
        textAlignmentEnumMapping.put(5, "viewStart");
        textAlignmentEnumMapping.put(6, "viewEnd");
        mTextAlignmentId = propertyMapper.mapIntEnum("textAlignment", R.attr.textAlignment, textAlignmentEnumMapping::get);
        final SparseArray<String> textDirectionEnumMapping = new SparseArray<>();
        textDirectionEnumMapping.put(1, "firstStrong");
        textDirectionEnumMapping.put(2, "anyRtl");
        textDirectionEnumMapping.put(3, "ltr");
        textDirectionEnumMapping.put(4, "rtl");
        textDirectionEnumMapping.put(5, "locale");
        textDirectionEnumMapping.put(6, "firstStrongLtr");
        textDirectionEnumMapping.put(7, "firstStrongRtl");
        mTextDirectionId = propertyMapper.mapIntEnum("textDirection", 0, textDirectionEnumMapping::get);
        mTooltipTextId = propertyMapper.mapObject("tooltipText", R.attr.tooltipText);
        mTransformPivotXId = propertyMapper.mapFloat("transformPivotX", R.attr.transformPivotX);
        mTransformPivotYId = propertyMapper.mapFloat("transformPivotY", R.attr.transformPivotY);
        mTransitionNameId = propertyMapper.mapObject("transitionName", R.attr.transitionName);
        mTranslationXId = propertyMapper.mapFloat("translationX", R.attr.translationX);
        mTranslationYId = propertyMapper.mapFloat("translationY", R.attr.translationY);
        mTranslationZId = propertyMapper.mapFloat("translationZ", R.attr.translationZ);
        final SparseArray<String> visibilityEnumMapping = new SparseArray<>();
        visibilityEnumMapping.put(0, "visible");
        visibilityEnumMapping.put(4, "invisible");
        visibilityEnumMapping.put(8, "gone");
        mVisibilityId = propertyMapper.mapIntEnum("visibility", R.attr.visibility, visibilityEnumMapping::get);
        mPropertiesMapped = true;
    }

    @Override
    public void readProperties(View node, PropertyReader propertyReader) {
        if (!mPropertiesMapped) {
            throw new InspectionCompanion.UninitializedPropertyMapException();
        }
        propertyReader.readBoolean(mAccessibilityFocusedId, node.isAccessibilityFocused());
        propertyReader.readBoolean(mAccessibilityHeadingId, node.isAccessibilityHeading());
        propertyReader.readIntEnum(mAccessibilityLiveRegionId, node.getAccessibilityLiveRegion());
        propertyReader.readObject(mAccessibilityPaneTitleId, node.getAccessibilityPaneTitle());
        propertyReader.readResourceId(mAccessibilityTraversalAfterId, node.getAccessibilityTraversalAfter());
        propertyReader.readResourceId(mAccessibilityTraversalBeforeId, node.getAccessibilityTraversalBefore());
        propertyReader.readBoolean(mActivatedId, node.isActivated());
        propertyReader.readFloat(mAlphaId, node.getAlpha());
        propertyReader.readObject(mAutofillHintsId, node.getAutofillHints());
        propertyReader.readObject(mBackgroundId, node.getBackground());
        propertyReader.readObject(mBackgroundTintId, node.getBackgroundTintList());
        propertyReader.readObject(mBackgroundTintModeId, node.getBackgroundTintMode());
        propertyReader.readInt(mBaselineId, node.getBaseline());
        propertyReader.readBoolean(mClickableId, node.isClickable());
        propertyReader.readObject(mContentDescriptionId, node.getContentDescription());
        propertyReader.readBoolean(mContextClickableId, node.isContextClickable());
        propertyReader.readBoolean(mDefaultFocusHighlightEnabledId, node.getDefaultFocusHighlightEnabled());
        propertyReader.readIntEnum(mDrawingCacheQualityId, node.getDrawingCacheQuality());
        propertyReader.readBoolean(mDuplicateParentStateId, node.isDuplicateParentStateEnabled());
        propertyReader.readFloat(mElevationId, node.getElevation());
        propertyReader.readBoolean(mEnabledId, node.isEnabled());
        propertyReader.readInt(mFadingEdgeLengthId, node.getFadingEdgeLength());
        propertyReader.readBoolean(mFilterTouchesWhenObscuredId, node.getFilterTouchesWhenObscured());
        propertyReader.readBoolean(mFitsSystemWindowsId, node.getFitsSystemWindows());
        propertyReader.readIntEnum(mFocusableId, node.getFocusable());
        propertyReader.readBoolean(mFocusableInTouchModeId, node.isFocusableInTouchMode());
        propertyReader.readBoolean(mFocusedId, node.isFocused());
        propertyReader.readBoolean(mFocusedByDefaultId, node.isFocusedByDefault());
        propertyReader.readBoolean(mForceDarkAllowedId, node.isForceDarkAllowed());
        propertyReader.readObject(mForegroundId, node.getForeground());
        propertyReader.readGravity(mForegroundGravityId, node.getForegroundGravity());
        propertyReader.readObject(mForegroundTintId, node.getForegroundTintList());
        propertyReader.readObject(mForegroundTintModeId, node.getForegroundTintMode());
        propertyReader.readBoolean(mHapticFeedbackEnabledId, node.isHapticFeedbackEnabled());
        propertyReader.readResourceId(mIdId, node.getId());
        propertyReader.readIntEnum(mImportantForAccessibilityId, node.getImportantForAccessibility());
        propertyReader.readIntEnum(mImportantForAutofillId, node.getImportantForAutofill());
        propertyReader.readIntEnum(mImportantForContentCaptureId, node.getImportantForContentCapture());
        propertyReader.readBoolean(mIsScrollContainerId, node.isScrollContainer());
        propertyReader.readBoolean(mKeepScreenOnId, node.getKeepScreenOn());
        propertyReader.readBoolean(mKeyboardNavigationClusterId, node.isKeyboardNavigationCluster());
        propertyReader.readResourceId(mLabelForId, node.getLabelFor());
        propertyReader.readIntEnum(mLayerTypeId, node.getLayerType());
        propertyReader.readIntEnum(mLayoutDirectionId, node.getLayoutDirection());
        propertyReader.readBoolean(mLongClickableId, node.isLongClickable());
        propertyReader.readInt(mMinHeightId, node.getMinimumHeight());
        propertyReader.readInt(mMinWidthId, node.getMinimumWidth());
        propertyReader.readBoolean(mNestedScrollingEnabledId, node.isNestedScrollingEnabled());
        propertyReader.readResourceId(mNextClusterForwardId, node.getNextClusterForwardId());
        propertyReader.readResourceId(mNextFocusDownId, node.getNextFocusDownId());
        propertyReader.readResourceId(mNextFocusForwardId, node.getNextFocusForwardId());
        propertyReader.readResourceId(mNextFocusLeftId, node.getNextFocusLeftId());
        propertyReader.readResourceId(mNextFocusRightId, node.getNextFocusRightId());
        propertyReader.readResourceId(mNextFocusUpId, node.getNextFocusUpId());
        propertyReader.readColor(mOutlineAmbientShadowColorId, node.getOutlineAmbientShadowColor());
        propertyReader.readObject(mOutlineProviderId, node.getOutlineProvider());
        propertyReader.readColor(mOutlineSpotShadowColorId, node.getOutlineSpotShadowColor());
        propertyReader.readIntEnum(mOverScrollModeId, node.getOverScrollMode());
        propertyReader.readInt(mPaddingBottomId, node.getPaddingBottom());
        propertyReader.readInt(mPaddingLeftId, node.getPaddingLeft());
        propertyReader.readInt(mPaddingRightId, node.getPaddingRight());
        propertyReader.readInt(mPaddingTopId, node.getPaddingTop());
        propertyReader.readObject(mPointerIconId, node.getPointerIcon());
        propertyReader.readBoolean(mPressedId, node.isPressed());
        propertyReader.readIntEnum(mRawLayoutDirectionId, node.getRawLayoutDirection());
        propertyReader.readIntEnum(mRawTextAlignmentId, node.getRawTextAlignment());
        propertyReader.readIntEnum(mRawTextDirectionId, node.getRawTextDirection());
        propertyReader.readIntFlag(mRequiresFadingEdgeId, node.getFadingEdge());
        propertyReader.readFloat(mRotationId, node.getRotation());
        propertyReader.readFloat(mRotationXId, node.getRotationX());
        propertyReader.readFloat(mRotationYId, node.getRotationY());
        propertyReader.readBoolean(mSaveEnabledId, node.isSaveEnabled());
        propertyReader.readFloat(mScaleXId, node.getScaleX());
        propertyReader.readFloat(mScaleYId, node.getScaleY());
        propertyReader.readBoolean(mScreenReaderFocusableId, node.isScreenReaderFocusable());
        propertyReader.readIntFlag(mScrollIndicatorsId, node.getScrollIndicators());
        propertyReader.readInt(mScrollXId, node.getScrollX());
        propertyReader.readInt(mScrollYId, node.getScrollY());
        propertyReader.readInt(mScrollbarDefaultDelayBeforeFadeId, node.getScrollBarDefaultDelayBeforeFade());
        propertyReader.readInt(mScrollbarFadeDurationId, node.getScrollBarFadeDuration());
        propertyReader.readInt(mScrollbarSizeId, node.getScrollBarSize());
        propertyReader.readIntEnum(mScrollbarStyleId, node.getScrollBarStyle());
        propertyReader.readBoolean(mSelectedId, node.isSelected());
        propertyReader.readColor(mSolidColorId, node.getSolidColor());
        propertyReader.readBoolean(mSoundEffectsEnabledId, node.isSoundEffectsEnabled());
        propertyReader.readObject(mStateListAnimatorId, node.getStateListAnimator());
        propertyReader.readObject(mTagId, node.getTag());
        propertyReader.readIntEnum(mTextAlignmentId, node.getTextAlignment());
        propertyReader.readIntEnum(mTextDirectionId, node.getTextDirection());
        propertyReader.readObject(mTooltipTextId, node.getTooltipText());
        propertyReader.readFloat(mTransformPivotXId, node.getPivotX());
        propertyReader.readFloat(mTransformPivotYId, node.getPivotY());
        propertyReader.readObject(mTransitionNameId, node.getTransitionName());
        propertyReader.readFloat(mTranslationXId, node.getTranslationX());
        propertyReader.readFloat(mTranslationYId, node.getTranslationY());
        propertyReader.readFloat(mTranslationZId, node.getTranslationZ());
        propertyReader.readIntEnum(mVisibilityId, node.getVisibility());
    }
}
