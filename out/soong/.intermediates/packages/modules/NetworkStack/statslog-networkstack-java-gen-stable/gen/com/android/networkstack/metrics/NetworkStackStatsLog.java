// This file is autogenerated

package com.android.networkstack.metrics;


import android.os.Build;
import android.os.SystemClock;
import android.util.StatsEvent;
import android.util.StatsLog;


/**
 * Utility class for logging statistics events.
 */
public class NetworkStackStatsLog {
    // Constants for atom codes.

    /**
     * DataStallEvent data_stall_event<br>
     * Usage: StatsLog.write(StatsLog.DATA_STALL_EVENT, int evaluation_type, int validation_result, int network_type, byte[] wifi_info, byte[] cell_info, byte[] dns_event, int tcp_fail_rate, int tcp_sent_since_last_recv);<br>
     */
    public static final int DATA_STALL_EVENT = 121;

    /**
     * NetworkStackReported network_stack_reported<br>
     * Usage: StatsLog.write(StatsLog.NETWORK_STACK_REPORTED, int event_id, byte[] network_stack_event);<br>
     */
    public static final int NETWORK_STACK_REPORTED = 182;

    /**
     * NetworkIpProvisioningReported network_ip_provisioning_reported<br>
     * Usage: StatsLog.write(StatsLog.NETWORK_IP_PROVISIONING_REPORTED, int transport_type, int ipv4_latency_micros, int ipv6_latency_micros, long provisioning_duration_micros, int disconnect_code, byte[] dhcp_session, int random_number);<br>
     */
    public static final int NETWORK_IP_PROVISIONING_REPORTED = 290;

    /**
     * NetworkDhcpRenewReported network_dhcp_renew_reported<br>
     * Usage: StatsLog.write(StatsLog.NETWORK_DHCP_RENEW_REPORTED, int transport_type, int request_count, int latency_micros, int error_code, int renew_result, int random_number);<br>
     */
    public static final int NETWORK_DHCP_RENEW_REPORTED = 291;

    /**
     * NetworkValidationReported network_validation_reported<br>
     * Usage: StatsLog.write(StatsLog.NETWORK_VALIDATION_REPORTED, int transport_type, byte[] probe_events, int validation_result, int latency_micros, int validation_index, int random_number);<br>
     */
    public static final int NETWORK_VALIDATION_REPORTED = 292;

    /**
     * NetworkStackQuirkReported network_stack_quirk_reported<br>
     * Usage: StatsLog.write(StatsLog.NETWORK_STACK_QUIRK_REPORTED, int transport_type, int event);<br>
     */
    public static final int NETWORK_STACK_QUIRK_REPORTED = 293;

    /**
     * NetworkIpReachabilityMonitorReported network_ip_reachability_monitor_reported<br>
     * Usage: StatsLog.write(StatsLog.NETWORK_IP_REACHABILITY_MONITOR_REPORTED, int event_type, int ip_type, int neighbor_type);<br>
     */
    public static final int NETWORK_IP_REACHABILITY_MONITOR_REPORTED = 374;

    // Constants for enum values.

    // Values for DataStallEvent.validation_result
    public static final int DATA_STALL_EVENT__VALIDATION_RESULT__UNKNOWN = 0;
    public static final int DATA_STALL_EVENT__VALIDATION_RESULT__VALID = 1;
    public static final int DATA_STALL_EVENT__VALIDATION_RESULT__INVALID = 2;
    public static final int DATA_STALL_EVENT__VALIDATION_RESULT__PORTAL = 3;
    public static final int DATA_STALL_EVENT__VALIDATION_RESULT__PARTIAL = 4;

    // Values for DataStallEvent.network_type
    public static final int DATA_STALL_EVENT__NETWORK_TYPE__TRANSPORT_CELLULAR = 0;
    public static final int DATA_STALL_EVENT__NETWORK_TYPE__TRANSPORT_WIFI = 1;
    public static final int DATA_STALL_EVENT__NETWORK_TYPE__TRANSPORT_BLUETOOTH = 2;
    public static final int DATA_STALL_EVENT__NETWORK_TYPE__TRANSPORT_ETHERNET = 3;
    public static final int DATA_STALL_EVENT__NETWORK_TYPE__TRANSPORT_VPN = 4;
    public static final int DATA_STALL_EVENT__NETWORK_TYPE__TRANSPORT_WIFI_AWARE = 5;
    public static final int DATA_STALL_EVENT__NETWORK_TYPE__TRANSPORT_LOWPAN = 6;

    // Values for NetworkIpProvisioningReported.transport_type
    public static final int NETWORK_IP_PROVISIONING_REPORTED__TRANSPORT_TYPE__TT_UNKNOWN = 0;
    public static final int NETWORK_IP_PROVISIONING_REPORTED__TRANSPORT_TYPE__TT_CELLULAR = 1;
    public static final int NETWORK_IP_PROVISIONING_REPORTED__TRANSPORT_TYPE__TT_WIFI = 2;
    public static final int NETWORK_IP_PROVISIONING_REPORTED__TRANSPORT_TYPE__TT_BLUETOOTH = 3;
    public static final int NETWORK_IP_PROVISIONING_REPORTED__TRANSPORT_TYPE__TT_ETHERNET = 4;
    public static final int NETWORK_IP_PROVISIONING_REPORTED__TRANSPORT_TYPE__TT_WIFI_AWARE = 5;
    public static final int NETWORK_IP_PROVISIONING_REPORTED__TRANSPORT_TYPE__TT_LOWPAN = 6;
    public static final int NETWORK_IP_PROVISIONING_REPORTED__TRANSPORT_TYPE__TT_CELLULAR_VPN = 7;
    public static final int NETWORK_IP_PROVISIONING_REPORTED__TRANSPORT_TYPE__TT_WIFI_VPN = 8;
    public static final int NETWORK_IP_PROVISIONING_REPORTED__TRANSPORT_TYPE__TT_BLUETOOTH_VPN = 9;
    public static final int NETWORK_IP_PROVISIONING_REPORTED__TRANSPORT_TYPE__TT_ETHERNET_VPN = 10;
    public static final int NETWORK_IP_PROVISIONING_REPORTED__TRANSPORT_TYPE__TT_WIFI_CELLULAR_VPN = 11;
    public static final int NETWORK_IP_PROVISIONING_REPORTED__TRANSPORT_TYPE__TT_TEST = 12;

    // Values for NetworkIpProvisioningReported.disconnect_code
    public static final int NETWORK_IP_PROVISIONING_REPORTED__DISCONNECT_CODE__DC_NONE = 0;
    public static final int NETWORK_IP_PROVISIONING_REPORTED__DISCONNECT_CODE__DC_NORMAL_TERMINATION = 1;
    public static final int NETWORK_IP_PROVISIONING_REPORTED__DISCONNECT_CODE__DC_PROVISIONING_FAIL = 2;
    public static final int NETWORK_IP_PROVISIONING_REPORTED__DISCONNECT_CODE__DC_ERROR_STARTING_IPV4 = 4;
    public static final int NETWORK_IP_PROVISIONING_REPORTED__DISCONNECT_CODE__DC_ERROR_STARTING_IPV6 = 5;
    public static final int NETWORK_IP_PROVISIONING_REPORTED__DISCONNECT_CODE__DC_ERROR_STARTING_IPREACHABILITYMONITOR = 6;
    public static final int NETWORK_IP_PROVISIONING_REPORTED__DISCONNECT_CODE__DC_INVALID_PROVISIONING = 7;
    public static final int NETWORK_IP_PROVISIONING_REPORTED__DISCONNECT_CODE__DC_INTERFACE_NOT_FOUND = 8;
    public static final int NETWORK_IP_PROVISIONING_REPORTED__DISCONNECT_CODE__DC_PROVISIONING_TIMEOUT = 9;

    // Values for NetworkDhcpRenewReported.transport_type
    public static final int NETWORK_DHCP_RENEW_REPORTED__TRANSPORT_TYPE__TT_UNKNOWN = 0;
    public static final int NETWORK_DHCP_RENEW_REPORTED__TRANSPORT_TYPE__TT_CELLULAR = 1;
    public static final int NETWORK_DHCP_RENEW_REPORTED__TRANSPORT_TYPE__TT_WIFI = 2;
    public static final int NETWORK_DHCP_RENEW_REPORTED__TRANSPORT_TYPE__TT_BLUETOOTH = 3;
    public static final int NETWORK_DHCP_RENEW_REPORTED__TRANSPORT_TYPE__TT_ETHERNET = 4;
    public static final int NETWORK_DHCP_RENEW_REPORTED__TRANSPORT_TYPE__TT_WIFI_AWARE = 5;
    public static final int NETWORK_DHCP_RENEW_REPORTED__TRANSPORT_TYPE__TT_LOWPAN = 6;
    public static final int NETWORK_DHCP_RENEW_REPORTED__TRANSPORT_TYPE__TT_CELLULAR_VPN = 7;
    public static final int NETWORK_DHCP_RENEW_REPORTED__TRANSPORT_TYPE__TT_WIFI_VPN = 8;
    public static final int NETWORK_DHCP_RENEW_REPORTED__TRANSPORT_TYPE__TT_BLUETOOTH_VPN = 9;
    public static final int NETWORK_DHCP_RENEW_REPORTED__TRANSPORT_TYPE__TT_ETHERNET_VPN = 10;
    public static final int NETWORK_DHCP_RENEW_REPORTED__TRANSPORT_TYPE__TT_WIFI_CELLULAR_VPN = 11;
    public static final int NETWORK_DHCP_RENEW_REPORTED__TRANSPORT_TYPE__TT_TEST = 12;

    // Values for NetworkDhcpRenewReported.error_code
    public static final int NETWORK_DHCP_RENEW_REPORTED__ERROR_CODE__ET_UNKNOWN = 0;
    public static final int NETWORK_DHCP_RENEW_REPORTED__ERROR_CODE__ET_L2_ERROR = 1;
    public static final int NETWORK_DHCP_RENEW_REPORTED__ERROR_CODE__ET_L3_ERROR = 2;
    public static final int NETWORK_DHCP_RENEW_REPORTED__ERROR_CODE__ET_L4_ERROR = 3;
    public static final int NETWORK_DHCP_RENEW_REPORTED__ERROR_CODE__ET_DHCP_ERROR = 4;
    public static final int NETWORK_DHCP_RENEW_REPORTED__ERROR_CODE__ET_MISC_ERROR = 5;
    public static final int NETWORK_DHCP_RENEW_REPORTED__ERROR_CODE__ET_L2_TOO_SHORT = 16842752;
    public static final int NETWORK_DHCP_RENEW_REPORTED__ERROR_CODE__ET_L2_WRONG_ETH_TYPE = 16908288;
    public static final int NETWORK_DHCP_RENEW_REPORTED__ERROR_CODE__ET_L3_TOO_SHORT = 33619968;
    public static final int NETWORK_DHCP_RENEW_REPORTED__ERROR_CODE__ET_L3_NOT_IPV4 = 33685504;
    public static final int NETWORK_DHCP_RENEW_REPORTED__ERROR_CODE__ET_L3_INVALID_IP = 33751040;
    public static final int NETWORK_DHCP_RENEW_REPORTED__ERROR_CODE__ET_L4_NOT_UDP = 50397184;
    public static final int NETWORK_DHCP_RENEW_REPORTED__ERROR_CODE__ET_L4_WRONG_PORT = 50462720;
    public static final int NETWORK_DHCP_RENEW_REPORTED__ERROR_CODE__ET_BOOTP_TOO_SHORT = 67174400;
    public static final int NETWORK_DHCP_RENEW_REPORTED__ERROR_CODE__ET_DHCP_BAD_MAGIC_COOKIE = 67239936;
    public static final int NETWORK_DHCP_RENEW_REPORTED__ERROR_CODE__ET_DHCP_INVALID_OPTION_LENGTH = 67305472;
    public static final int NETWORK_DHCP_RENEW_REPORTED__ERROR_CODE__ET_DHCP_NO_MSG_TYPE = 67371008;
    public static final int NETWORK_DHCP_RENEW_REPORTED__ERROR_CODE__ET_DHCP_UNKNOWN_MSG_TYPE = 67436544;
    public static final int NETWORK_DHCP_RENEW_REPORTED__ERROR_CODE__ET_DHCP_NO_COOKIE = 67502080;
    public static final int NETWORK_DHCP_RENEW_REPORTED__ERROR_CODE__ET_BUFFER_UNDERFLOW = 83951616;
    public static final int NETWORK_DHCP_RENEW_REPORTED__ERROR_CODE__ET_RECEIVE_ERROR = 84017152;
    public static final int NETWORK_DHCP_RENEW_REPORTED__ERROR_CODE__ET_PARSING_ERROR = 84082688;

    // Values for NetworkDhcpRenewReported.renew_result
    public static final int NETWORK_DHCP_RENEW_REPORTED__RENEW_RESULT__RR_UNKNOWN = 0;
    public static final int NETWORK_DHCP_RENEW_REPORTED__RENEW_RESULT__RR_SUCCESS = 1;
    public static final int NETWORK_DHCP_RENEW_REPORTED__RENEW_RESULT__RR_ERROR_NAK = 2;
    public static final int NETWORK_DHCP_RENEW_REPORTED__RENEW_RESULT__RR_ERROR_IP_MISMATCH = 3;
    public static final int NETWORK_DHCP_RENEW_REPORTED__RENEW_RESULT__RR_ERROR_IP_EXPIRE = 4;

    // Values for NetworkValidationReported.transport_type
    public static final int NETWORK_VALIDATION_REPORTED__TRANSPORT_TYPE__TT_UNKNOWN = 0;
    public static final int NETWORK_VALIDATION_REPORTED__TRANSPORT_TYPE__TT_CELLULAR = 1;
    public static final int NETWORK_VALIDATION_REPORTED__TRANSPORT_TYPE__TT_WIFI = 2;
    public static final int NETWORK_VALIDATION_REPORTED__TRANSPORT_TYPE__TT_BLUETOOTH = 3;
    public static final int NETWORK_VALIDATION_REPORTED__TRANSPORT_TYPE__TT_ETHERNET = 4;
    public static final int NETWORK_VALIDATION_REPORTED__TRANSPORT_TYPE__TT_WIFI_AWARE = 5;
    public static final int NETWORK_VALIDATION_REPORTED__TRANSPORT_TYPE__TT_LOWPAN = 6;
    public static final int NETWORK_VALIDATION_REPORTED__TRANSPORT_TYPE__TT_CELLULAR_VPN = 7;
    public static final int NETWORK_VALIDATION_REPORTED__TRANSPORT_TYPE__TT_WIFI_VPN = 8;
    public static final int NETWORK_VALIDATION_REPORTED__TRANSPORT_TYPE__TT_BLUETOOTH_VPN = 9;
    public static final int NETWORK_VALIDATION_REPORTED__TRANSPORT_TYPE__TT_ETHERNET_VPN = 10;
    public static final int NETWORK_VALIDATION_REPORTED__TRANSPORT_TYPE__TT_WIFI_CELLULAR_VPN = 11;
    public static final int NETWORK_VALIDATION_REPORTED__TRANSPORT_TYPE__TT_TEST = 12;

    // Values for NetworkValidationReported.validation_result
    public static final int NETWORK_VALIDATION_REPORTED__VALIDATION_RESULT__VR_UNKNOWN = 0;
    public static final int NETWORK_VALIDATION_REPORTED__VALIDATION_RESULT__VR_SUCCESS = 1;
    public static final int NETWORK_VALIDATION_REPORTED__VALIDATION_RESULT__VR_FAILURE = 2;
    public static final int NETWORK_VALIDATION_REPORTED__VALIDATION_RESULT__VR_PORTAL = 3;
    public static final int NETWORK_VALIDATION_REPORTED__VALIDATION_RESULT__VR_PARTIAL = 4;

    // Values for NetworkStackQuirkReported.transport_type
    public static final int NETWORK_STACK_QUIRK_REPORTED__TRANSPORT_TYPE__TT_UNKNOWN = 0;
    public static final int NETWORK_STACK_QUIRK_REPORTED__TRANSPORT_TYPE__TT_CELLULAR = 1;
    public static final int NETWORK_STACK_QUIRK_REPORTED__TRANSPORT_TYPE__TT_WIFI = 2;
    public static final int NETWORK_STACK_QUIRK_REPORTED__TRANSPORT_TYPE__TT_BLUETOOTH = 3;
    public static final int NETWORK_STACK_QUIRK_REPORTED__TRANSPORT_TYPE__TT_ETHERNET = 4;
    public static final int NETWORK_STACK_QUIRK_REPORTED__TRANSPORT_TYPE__TT_WIFI_AWARE = 5;
    public static final int NETWORK_STACK_QUIRK_REPORTED__TRANSPORT_TYPE__TT_LOWPAN = 6;
    public static final int NETWORK_STACK_QUIRK_REPORTED__TRANSPORT_TYPE__TT_CELLULAR_VPN = 7;
    public static final int NETWORK_STACK_QUIRK_REPORTED__TRANSPORT_TYPE__TT_WIFI_VPN = 8;
    public static final int NETWORK_STACK_QUIRK_REPORTED__TRANSPORT_TYPE__TT_BLUETOOTH_VPN = 9;
    public static final int NETWORK_STACK_QUIRK_REPORTED__TRANSPORT_TYPE__TT_ETHERNET_VPN = 10;
    public static final int NETWORK_STACK_QUIRK_REPORTED__TRANSPORT_TYPE__TT_WIFI_CELLULAR_VPN = 11;
    public static final int NETWORK_STACK_QUIRK_REPORTED__TRANSPORT_TYPE__TT_TEST = 12;

    // Values for NetworkStackQuirkReported.event
    public static final int NETWORK_STACK_QUIRK_REPORTED__EVENT__QE_UNKNOWN = 0;
    public static final int NETWORK_STACK_QUIRK_REPORTED__EVENT__QE_IPV6_PROVISIONING_ROUTER_LOST = 1;

    // Values for NetworkIpReachabilityMonitorReported.event_type
    public static final int NETWORK_IP_REACHABILITY_MONITOR_REPORTED__EVENT_TYPE__NUD_EVENT_UNKNOWN = 0;
    public static final int NETWORK_IP_REACHABILITY_MONITOR_REPORTED__EVENT_TYPE__NUD_POST_ROAMING_FAILED = 1;
    public static final int NETWORK_IP_REACHABILITY_MONITOR_REPORTED__EVENT_TYPE__NUD_POST_ROAMING_FAILED_CRITICAL = 2;
    public static final int NETWORK_IP_REACHABILITY_MONITOR_REPORTED__EVENT_TYPE__NUD_CONFIRM_FAILED = 3;
    public static final int NETWORK_IP_REACHABILITY_MONITOR_REPORTED__EVENT_TYPE__NUD_CONFIRM_FAILED_CRITICAL = 4;
    public static final int NETWORK_IP_REACHABILITY_MONITOR_REPORTED__EVENT_TYPE__NUD_ORGANIC_FAILED = 5;
    public static final int NETWORK_IP_REACHABILITY_MONITOR_REPORTED__EVENT_TYPE__NUD_ORGANIC_FAILED_CRITICAL = 6;
    public static final int NETWORK_IP_REACHABILITY_MONITOR_REPORTED__EVENT_TYPE__NUD_MAC_ADDRESS_CHANGED = 7;

    // Values for NetworkIpReachabilityMonitorReported.ip_type
    public static final int NETWORK_IP_REACHABILITY_MONITOR_REPORTED__IP_TYPE__UNKNOWN = 0;
    public static final int NETWORK_IP_REACHABILITY_MONITOR_REPORTED__IP_TYPE__IPV4 = 4;
    public static final int NETWORK_IP_REACHABILITY_MONITOR_REPORTED__IP_TYPE__IPV6 = 6;

    // Values for NetworkIpReachabilityMonitorReported.neighbor_type
    public static final int NETWORK_IP_REACHABILITY_MONITOR_REPORTED__NEIGHBOR_TYPE__NUD_NEIGHBOR_UNKNOWN = 0;
    public static final int NETWORK_IP_REACHABILITY_MONITOR_REPORTED__NEIGHBOR_TYPE__NUD_NEIGHBOR_GATEWAY = 1;
    public static final int NETWORK_IP_REACHABILITY_MONITOR_REPORTED__NEIGHBOR_TYPE__NUD_NEIGHBOR_DNS = 2;
    public static final int NETWORK_IP_REACHABILITY_MONITOR_REPORTED__NEIGHBOR_TYPE__NUD_NEIGHBOR_BOTH = 3;

    // Annotation constants.
    public static final byte ANNOTATION_ID_IS_UID = 1;
    public static final byte ANNOTATION_ID_TRUNCATE_TIMESTAMP = 2;
    public static final byte ANNOTATION_ID_PRIMARY_FIELD = 3;
    public static final byte ANNOTATION_ID_EXCLUSIVE_STATE = 4;
    public static final byte ANNOTATION_ID_PRIMARY_FIELD_FIRST_UID = 5;
    public static final byte ANNOTATION_ID_TRIGGER_STATE_RESET = 7;
    public static final byte ANNOTATION_ID_STATE_NESTED = 8;

    // Write methods
    public static void write(int code, int arg1, byte[] arg2) {
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.Q) {
            final StatsEvent.Builder builder = StatsEvent.newBuilder();
            builder.setAtomId(code);
            builder.writeInt(arg1);
            builder.writeByteArray(null == arg2 ? new byte[0] : arg2);

            builder.usePooledBuffer();
            StatsLog.write(builder.build());
        } else {
            QLogger.write(code, arg1, arg2);
        }
    }

    public static void write(int code, int arg1, byte[] arg2, int arg3, int arg4, int arg5, int arg6) {
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.Q) {
            final StatsEvent.Builder builder = StatsEvent.newBuilder();
            builder.setAtomId(code);
            builder.writeInt(arg1);
            builder.writeByteArray(null == arg2 ? new byte[0] : arg2);
            builder.writeInt(arg3);
            builder.writeInt(arg4);
            builder.writeInt(arg5);
            builder.writeInt(arg6);

            builder.usePooledBuffer();
            StatsLog.write(builder.build());
        } else {
            QLogger.write(code, arg1, arg2, arg3, arg4, arg5, arg6);
        }
    }

    public static void write(int code, int arg1, int arg2) {
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.Q) {
            final StatsEvent.Builder builder = StatsEvent.newBuilder();
            builder.setAtomId(code);
            builder.writeInt(arg1);
            builder.writeInt(arg2);

            builder.usePooledBuffer();
            StatsLog.write(builder.build());
        } else {
            QLogger.write(code, arg1, arg2);
        }
    }

    public static void write(int code, int arg1, int arg2, int arg3) {
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.Q) {
            final StatsEvent.Builder builder = StatsEvent.newBuilder();
            builder.setAtomId(code);
            builder.writeInt(arg1);
            builder.writeInt(arg2);
            builder.writeInt(arg3);

            builder.usePooledBuffer();
            StatsLog.write(builder.build());
        } else {
            QLogger.write(code, arg1, arg2, arg3);
        }
    }

    public static void write(int code, int arg1, int arg2, int arg3, byte[] arg4, byte[] arg5, byte[] arg6, int arg7, int arg8) {
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.Q) {
            final StatsEvent.Builder builder = StatsEvent.newBuilder();
            builder.setAtomId(code);
            builder.writeInt(arg1);
            builder.writeInt(arg2);
            builder.writeInt(arg3);
            builder.writeByteArray(null == arg4 ? new byte[0] : arg4);
            builder.writeByteArray(null == arg5 ? new byte[0] : arg5);
            builder.writeByteArray(null == arg6 ? new byte[0] : arg6);
            builder.writeInt(arg7);
            builder.writeInt(arg8);

            builder.usePooledBuffer();
            StatsLog.write(builder.build());
        } else {
            QLogger.write(code, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
        }
    }

    public static void write(int code, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6) {
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.Q) {
            final StatsEvent.Builder builder = StatsEvent.newBuilder();
            builder.setAtomId(code);
            builder.writeInt(arg1);
            builder.writeInt(arg2);
            builder.writeInt(arg3);
            builder.writeInt(arg4);
            builder.writeInt(arg5);
            builder.writeInt(arg6);

            builder.usePooledBuffer();
            StatsLog.write(builder.build());
        } else {
            QLogger.write(code, arg1, arg2, arg3, arg4, arg5, arg6);
        }
    }

    public static void write(int code, int arg1, int arg2, int arg3, long arg4, int arg5, byte[] arg6, int arg7) {
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.Q) {
            final StatsEvent.Builder builder = StatsEvent.newBuilder();
            builder.setAtomId(code);
            builder.writeInt(arg1);
            builder.writeInt(arg2);
            builder.writeInt(arg3);
            builder.writeLong(arg4);
            builder.writeInt(arg5);
            builder.writeByteArray(null == arg6 ? new byte[0] : arg6);
            builder.writeInt(arg7);

            builder.usePooledBuffer();
            StatsLog.write(builder.build());
        } else {
            QLogger.write(code, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
        }
    }


    // Write logging helper methods for statsd in Q and earlier.
    private static class QLogger {
        // Payload limits.
        private static final int LOGGER_ENTRY_MAX_PAYLOAD = 4068;
        private static final int MAX_EVENT_PAYLOAD = LOGGER_ENTRY_MAX_PAYLOAD - 4;

        // Value types.
        private static final byte INT_TYPE = 0;
        private static final byte LONG_TYPE = 1;
        private static final byte STRING_TYPE = 2;
        private static final byte LIST_TYPE = 3;
        private static final byte FLOAT_TYPE = 4;

        // Size of each value type.
        private static final int INT_TYPE_SIZE = 5;
        private static final int FLOAT_TYPE_SIZE = 5;
        private static final int LONG_TYPE_SIZE = 9;
        private static final int STRING_TYPE_OVERHEAD = 5;
        private static final int LIST_TYPE_OVERHEAD = 2;

        // Write methods.
        public static void write(int code, int arg1, byte[] arg2) {
            // Initial overhead of the list, timestamp, and atom tag.
            int needed = LIST_TYPE_OVERHEAD + LONG_TYPE_SIZE + INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            if (arg2 == null) {
                arg2 = new byte[0];
            }
            needed += STRING_TYPE_OVERHEAD + arg2.length;
            if (needed > MAX_EVENT_PAYLOAD) {
                return;
            }
            byte[] buff = new byte[needed];
            int pos = 0;
            buff[pos] = LIST_TYPE;
            buff[pos + 1] = 4;
            pos += LIST_TYPE_OVERHEAD;
            long elapsedRealtime = SystemClock.elapsedRealtimeNanos();
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, elapsedRealtime);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, code);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg1);
            pos += INT_TYPE_SIZE;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg2.length);
            System.arraycopy(arg2, 0, buff, pos + STRING_TYPE_OVERHEAD, arg2.length);
            pos += STRING_TYPE_OVERHEAD + arg2.length;
            StatsLog.writeRaw(buff, pos);
        }

        public static void write(int code, int arg1, byte[] arg2, int arg3, int arg4, int arg5, int arg6) {
            // Initial overhead of the list, timestamp, and atom tag.
            int needed = LIST_TYPE_OVERHEAD + LONG_TYPE_SIZE + INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            if (arg2 == null) {
                arg2 = new byte[0];
            }
            needed += STRING_TYPE_OVERHEAD + arg2.length;
            needed += INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            if (needed > MAX_EVENT_PAYLOAD) {
                return;
            }
            byte[] buff = new byte[needed];
            int pos = 0;
            buff[pos] = LIST_TYPE;
            buff[pos + 1] = 8;
            pos += LIST_TYPE_OVERHEAD;
            long elapsedRealtime = SystemClock.elapsedRealtimeNanos();
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, elapsedRealtime);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, code);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg1);
            pos += INT_TYPE_SIZE;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg2.length);
            System.arraycopy(arg2, 0, buff, pos + STRING_TYPE_OVERHEAD, arg2.length);
            pos += STRING_TYPE_OVERHEAD + arg2.length;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg3);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg4);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg5);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg6);
            pos += INT_TYPE_SIZE;
            StatsLog.writeRaw(buff, pos);
        }

        public static void write(int code, int arg1, int arg2) {
            // Initial overhead of the list, timestamp, and atom tag.
            int needed = LIST_TYPE_OVERHEAD + LONG_TYPE_SIZE + INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            if (needed > MAX_EVENT_PAYLOAD) {
                return;
            }
            byte[] buff = new byte[needed];
            int pos = 0;
            buff[pos] = LIST_TYPE;
            buff[pos + 1] = 4;
            pos += LIST_TYPE_OVERHEAD;
            long elapsedRealtime = SystemClock.elapsedRealtimeNanos();
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, elapsedRealtime);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, code);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg1);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg2);
            pos += INT_TYPE_SIZE;
            StatsLog.writeRaw(buff, pos);
        }

        public static void write(int code, int arg1, int arg2, int arg3) {
            // Initial overhead of the list, timestamp, and atom tag.
            int needed = LIST_TYPE_OVERHEAD + LONG_TYPE_SIZE + INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            if (needed > MAX_EVENT_PAYLOAD) {
                return;
            }
            byte[] buff = new byte[needed];
            int pos = 0;
            buff[pos] = LIST_TYPE;
            buff[pos + 1] = 5;
            pos += LIST_TYPE_OVERHEAD;
            long elapsedRealtime = SystemClock.elapsedRealtimeNanos();
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, elapsedRealtime);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, code);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg1);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg2);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg3);
            pos += INT_TYPE_SIZE;
            StatsLog.writeRaw(buff, pos);
        }

        public static void write(int code, int arg1, int arg2, int arg3, byte[] arg4, byte[] arg5, byte[] arg6, int arg7, int arg8) {
            // Initial overhead of the list, timestamp, and atom tag.
            int needed = LIST_TYPE_OVERHEAD + LONG_TYPE_SIZE + INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            if (arg4 == null) {
                arg4 = new byte[0];
            }
            needed += STRING_TYPE_OVERHEAD + arg4.length;
            if (arg5 == null) {
                arg5 = new byte[0];
            }
            needed += STRING_TYPE_OVERHEAD + arg5.length;
            if (arg6 == null) {
                arg6 = new byte[0];
            }
            needed += STRING_TYPE_OVERHEAD + arg6.length;
            needed += INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            if (needed > MAX_EVENT_PAYLOAD) {
                return;
            }
            byte[] buff = new byte[needed];
            int pos = 0;
            buff[pos] = LIST_TYPE;
            buff[pos + 1] = 10;
            pos += LIST_TYPE_OVERHEAD;
            long elapsedRealtime = SystemClock.elapsedRealtimeNanos();
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, elapsedRealtime);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, code);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg1);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg2);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg3);
            pos += INT_TYPE_SIZE;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg4.length);
            System.arraycopy(arg4, 0, buff, pos + STRING_TYPE_OVERHEAD, arg4.length);
            pos += STRING_TYPE_OVERHEAD + arg4.length;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg5.length);
            System.arraycopy(arg5, 0, buff, pos + STRING_TYPE_OVERHEAD, arg5.length);
            pos += STRING_TYPE_OVERHEAD + arg5.length;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg6.length);
            System.arraycopy(arg6, 0, buff, pos + STRING_TYPE_OVERHEAD, arg6.length);
            pos += STRING_TYPE_OVERHEAD + arg6.length;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg7);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg8);
            pos += INT_TYPE_SIZE;
            StatsLog.writeRaw(buff, pos);
        }

        public static void write(int code, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6) {
            // Initial overhead of the list, timestamp, and atom tag.
            int needed = LIST_TYPE_OVERHEAD + LONG_TYPE_SIZE + INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            if (needed > MAX_EVENT_PAYLOAD) {
                return;
            }
            byte[] buff = new byte[needed];
            int pos = 0;
            buff[pos] = LIST_TYPE;
            buff[pos + 1] = 8;
            pos += LIST_TYPE_OVERHEAD;
            long elapsedRealtime = SystemClock.elapsedRealtimeNanos();
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, elapsedRealtime);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, code);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg1);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg2);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg3);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg4);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg5);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg6);
            pos += INT_TYPE_SIZE;
            StatsLog.writeRaw(buff, pos);
        }

        public static void write(int code, int arg1, int arg2, int arg3, long arg4, int arg5, byte[] arg6, int arg7) {
            // Initial overhead of the list, timestamp, and atom tag.
            int needed = LIST_TYPE_OVERHEAD + LONG_TYPE_SIZE + INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            needed += LONG_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            if (arg6 == null) {
                arg6 = new byte[0];
            }
            needed += STRING_TYPE_OVERHEAD + arg6.length;
            needed += INT_TYPE_SIZE;
            if (needed > MAX_EVENT_PAYLOAD) {
                return;
            }
            byte[] buff = new byte[needed];
            int pos = 0;
            buff[pos] = LIST_TYPE;
            buff[pos + 1] = 9;
            pos += LIST_TYPE_OVERHEAD;
            long elapsedRealtime = SystemClock.elapsedRealtimeNanos();
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, elapsedRealtime);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, code);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg1);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg2);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg3);
            pos += INT_TYPE_SIZE;
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, arg4);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg5);
            pos += INT_TYPE_SIZE;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg6.length);
            System.arraycopy(arg6, 0, buff, pos + STRING_TYPE_OVERHEAD, arg6.length);
            pos += STRING_TYPE_OVERHEAD + arg6.length;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg7);
            pos += INT_TYPE_SIZE;
            StatsLog.writeRaw(buff, pos);
        }


        // Helper methods for copying primitives
        private static void copyInt(byte[] buff, int pos, int val) {
            buff[pos] = (byte) (val);
            buff[pos + 1] = (byte) (val >> 8);
            buff[pos + 2] = (byte) (val >> 16);
            buff[pos + 3] = (byte) (val >> 24);
            return;
        }

        private static void copyLong(byte[] buff, int pos, long val) {
            buff[pos] = (byte) (val);
            buff[pos + 1] = (byte) (val >> 8);
            buff[pos + 2] = (byte) (val >> 16);
            buff[pos + 3] = (byte) (val >> 24);
            buff[pos + 4] = (byte) (val >> 32);
            buff[pos + 5] = (byte) (val >> 40);
            buff[pos + 6] = (byte) (val >> 48);
            buff[pos + 7] = (byte) (val >> 56);
            return;
        }

    }
}
