// This file is autogenerated

package com.android.permissioncontroller;


import android.os.Build;
import android.os.SystemClock;
import android.util.StatsEvent;
import android.util.StatsLog;


/**
 * Utility class for logging statistics events.
 */
public class PermissionControllerStatsLog {
    // Constants for atom codes.

    /**
     * PermissionGrantRequestResultReported permission_grant_request_result_reported<br>
     * Usage: StatsLog.write(StatsLog.PERMISSION_GRANT_REQUEST_RESULT_REPORTED, long request_id, int uid, java.lang.String package_name, java.lang.String permission_name, boolean is_implicit, int result);<br>
     */
    public static final int PERMISSION_GRANT_REQUEST_RESULT_REPORTED = 170;

    /**
     * PrivacyIndicatorsInteracted privacy_indicators_interacted<br>
     * Usage: StatsLog.write(StatsLog.PRIVACY_INDICATORS_INTERACTED, int type);<br>
     */
    public static final int PRIVACY_INDICATORS_INTERACTED = 180;

    /**
     * RoleRequestResultReported role_request_result_reported<br>
     * Usage: StatsLog.write(StatsLog.ROLE_REQUEST_RESULT_REPORTED, int requesting_uid, java.lang.String requesting_package_name, java.lang.String role_name, int qualifying_count, int current_uid, java.lang.String current_package_name, int granted_another_uid, java.lang.String granted_another_package_name, int result);<br>
     */
    public static final int ROLE_REQUEST_RESULT_REPORTED = 190;

    /**
     * ReviewPermissionsFragmentResultReported review_permissions_fragment_result_reported<br>
     * Usage: StatsLog.write(StatsLog.REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED, long change_id, int uid, java.lang.String package_name, java.lang.String permission_name, boolean permission_granted);<br>
     */
    public static final int REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED = 211;

    /**
     * RuntimePermissionsUpgradeResult runtime_permissions_upgrade_result<br>
     * Usage: StatsLog.write(StatsLog.RUNTIME_PERMISSIONS_UPGRADE_RESULT, java.lang.String permission_name, int uid, java.lang.String package_name);<br>
     */
    public static final int RUNTIME_PERMISSIONS_UPGRADE_RESULT = 212;

    /**
     * GrantPermissionsActivityButtonActions grant_permissions_activity_button_actions<br>
     * Usage: StatsLog.write(StatsLog.GRANT_PERMISSIONS_ACTIVITY_BUTTON_ACTIONS, java.lang.String permission_group_name, int uid, java.lang.String package_name, int buttons_presented, int button_clicked, long session_id, int target_sdk, int selected_precision);<br>
     */
    public static final int GRANT_PERMISSIONS_ACTIVITY_BUTTON_ACTIONS = 213;

    /**
     * LocationAccessCheckNotificationAction location_access_check_notification_action<br>
     * Usage: StatsLog.write(StatsLog.LOCATION_ACCESS_CHECK_NOTIFICATION_ACTION, long session_id, int package_uid, java.lang.String package_name, int result);<br>
     */
    public static final int LOCATION_ACCESS_CHECK_NOTIFICATION_ACTION = 214;

    /**
     * AppPermissionFragmentActionReported app_permission_fragment_action_reported<br>
     * Usage: StatsLog.write(StatsLog.APP_PERMISSION_FRAGMENT_ACTION_REPORTED, long session_id, long change_id, int uid, java.lang.String package_name, java.lang.String permission_name, boolean permission_granted, int permission_flags, int button_pressed);<br>
     */
    public static final int APP_PERMISSION_FRAGMENT_ACTION_REPORTED = 215;

    /**
     * AppPermissionFragmentViewed app_permission_fragment_viewed<br>
     * Usage: StatsLog.write(StatsLog.APP_PERMISSION_FRAGMENT_VIEWED, long session_id, int uid, java.lang.String package_name, java.lang.String permission_group_name);<br>
     */
    public static final int APP_PERMISSION_FRAGMENT_VIEWED = 216;

    /**
     * AppPermissionsFragmentViewed app_permissions_fragment_viewed<br>
     * Usage: StatsLog.write(StatsLog.APP_PERMISSIONS_FRAGMENT_VIEWED, long session_id, long view_id, java.lang.String permission_group_name, int uid, java.lang.String package_name, int category);<br>
     */
    public static final int APP_PERMISSIONS_FRAGMENT_VIEWED = 217;

    /**
     * PermissionAppsFragmentViewed permission_apps_fragment_viewed<br>
     * Usage: StatsLog.write(StatsLog.PERMISSION_APPS_FRAGMENT_VIEWED, long session_id, long view_id, java.lang.String permission_group_name, int uid, java.lang.String package_name, int category);<br>
     */
    public static final int PERMISSION_APPS_FRAGMENT_VIEWED = 218;

    /**
     * AutoRevokeNotificationClicked auto_revoke_notification_clicked<br>
     * Usage: StatsLog.write(StatsLog.AUTO_REVOKE_NOTIFICATION_CLICKED, long session_id);<br>
     */
    public static final int AUTO_REVOKE_NOTIFICATION_CLICKED = 270;

    /**
     * AutoRevokeFragmentAppViewed auto_revoke_fragment_app_viewed<br>
     * Usage: StatsLog.write(StatsLog.AUTO_REVOKE_FRAGMENT_APP_VIEWED, long session_id, int uid, java.lang.String package_name, java.lang.String permission_group_name, int age);<br>
     */
    public static final int AUTO_REVOKE_FRAGMENT_APP_VIEWED = 271;

    /**
     * AutoRevokedAppInteraction auto_revoked_app_interaction<br>
     * Usage: StatsLog.write(StatsLog.AUTO_REVOKED_APP_INTERACTION, long session_id, int uid, java.lang.String package_name, int action);<br>
     */
    public static final int AUTO_REVOKED_APP_INTERACTION = 272;

    /**
     * AppPermissionGroupsFragmentAutoRevokeAction app_permission_groups_fragment_auto_revoke_action<br>
     * Usage: StatsLog.write(StatsLog.APP_PERMISSION_GROUPS_FRAGMENT_AUTO_REVOKE_ACTION, long session_id, int uid, java.lang.String package_name, int action);<br>
     */
    public static final int APP_PERMISSION_GROUPS_FRAGMENT_AUTO_REVOKE_ACTION = 273;

    /**
     * PermissionUsageFragmentInteraction permission_usage_fragment_interaction<br>
     * Usage: StatsLog.write(StatsLog.PERMISSION_USAGE_FRAGMENT_INTERACTION, long session_id, int action);<br>
     */
    public static final int PERMISSION_USAGE_FRAGMENT_INTERACTION = 379;

    /**
     * PermissionDetailsInteraction permission_details_interaction<br>
     * Usage: StatsLog.write(StatsLog.PERMISSION_DETAILS_INTERACTION, long session_id, java.lang.String permission_group_name, java.lang.String package_name, int action);<br>
     */
    public static final int PERMISSION_DETAILS_INTERACTION = 380;

    // Constants for enum values.

    // Values for PermissionGrantRequestResultReported.result
    public static final int PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__UNDEFINED = 0;
    public static final int PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__IGNORED = 1;
    public static final int PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__IGNORED_USER_FIXED = 2;
    public static final int PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__IGNORED_POLICY_FIXED = 3;
    public static final int PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__USER_GRANTED = 4;
    public static final int PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__AUTO_GRANTED = 5;
    public static final int PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__USER_DENIED = 6;
    public static final int PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__USER_DENIED_WITH_PREJUDICE = 7;
    public static final int PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__AUTO_DENIED = 8;
    public static final int PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__IGNORED_RESTRICTED_PERMISSION = 9;
    public static final int PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__USER_GRANTED_ONE_TIME = 10;
    public static final int PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__USER_IGNORED = 11;
    public static final int PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__USER_GRANTED_IN_SETTINGS = 12;
    public static final int PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__USER_DENIED_IN_SETTINGS = 13;
    public static final int PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__USER_DENIED_WITH_PREJUDICE_IN_SETTINGS = 14;
    public static final int PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__AUTO_ONE_TIME_PERMISSION_REVOKED = 15;
    public static final int PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__AUTO_UNUSED_APP_PERMISSION_REVOKED = 16;

    // Values for PrivacyIndicatorsInteracted.type
    public static final int PRIVACY_INDICATORS_INTERACTED__TYPE__UNKNOWN = 0;
    public static final int PRIVACY_INDICATORS_INTERACTED__TYPE__CHIP_VIEWED = 1;
    public static final int PRIVACY_INDICATORS_INTERACTED__TYPE__CHIP_CLICKED = 2;
    public static final int PRIVACY_INDICATORS_INTERACTED__TYPE__DIALOG_DISMISS = 4;
    public static final int PRIVACY_INDICATORS_INTERACTED__TYPE__DIALOG_LINE_ITEM = 5;

    // Values for RoleRequestResultReported.result
    public static final int ROLE_REQUEST_RESULT_REPORTED__RESULT__UNDEFINED = 0;
    public static final int ROLE_REQUEST_RESULT_REPORTED__RESULT__IGNORED = 1;
    public static final int ROLE_REQUEST_RESULT_REPORTED__RESULT__IGNORED_ALREADY_GRANTED = 2;
    public static final int ROLE_REQUEST_RESULT_REPORTED__RESULT__IGNORED_NOT_QUALIFIED = 3;
    public static final int ROLE_REQUEST_RESULT_REPORTED__RESULT__IGNORED_USER_ALWAYS_DENIED = 4;
    public static final int ROLE_REQUEST_RESULT_REPORTED__RESULT__USER_GRANTED = 5;
    public static final int ROLE_REQUEST_RESULT_REPORTED__RESULT__USER_DENIED = 6;
    public static final int ROLE_REQUEST_RESULT_REPORTED__RESULT__USER_DENIED_GRANTED_ANOTHER = 7;
    public static final int ROLE_REQUEST_RESULT_REPORTED__RESULT__USER_DENIED_WITH_ALWAYS = 8;

    // Values for LocationAccessCheckNotificationAction.result
    public static final int LOCATION_ACCESS_CHECK_NOTIFICATION_ACTION__RESULT__UNDEFINED = 0;
    public static final int LOCATION_ACCESS_CHECK_NOTIFICATION_ACTION__RESULT__NOTIFICATION_PRESENTED = 1;
    public static final int LOCATION_ACCESS_CHECK_NOTIFICATION_ACTION__RESULT__NOTIFICATION_DECLINED = 2;
    public static final int LOCATION_ACCESS_CHECK_NOTIFICATION_ACTION__RESULT__NOTIFICATION_CLICKED = 3;

    // Values for AppPermissionFragmentActionReported.button_pressed
    public static final int APP_PERMISSION_FRAGMENT_ACTION_REPORTED__BUTTON_PRESSED__UNDEFINED = 0;
    public static final int APP_PERMISSION_FRAGMENT_ACTION_REPORTED__BUTTON_PRESSED__ALLOW = 1;
    public static final int APP_PERMISSION_FRAGMENT_ACTION_REPORTED__BUTTON_PRESSED__DENY = 2;
    public static final int APP_PERMISSION_FRAGMENT_ACTION_REPORTED__BUTTON_PRESSED__ASK_EVERY_TIME = 3;
    public static final int APP_PERMISSION_FRAGMENT_ACTION_REPORTED__BUTTON_PRESSED__ALLOW_ALWAYS = 4;
    public static final int APP_PERMISSION_FRAGMENT_ACTION_REPORTED__BUTTON_PRESSED__ALLOW_FOREGROUND = 5;
    public static final int APP_PERMISSION_FRAGMENT_ACTION_REPORTED__BUTTON_PRESSED__DENY_FOREGROUND = 6;
    public static final int APP_PERMISSION_FRAGMENT_ACTION_REPORTED__BUTTON_PRESSED__GRANT_FINE_LOCATION = 7;
    public static final int APP_PERMISSION_FRAGMENT_ACTION_REPORTED__BUTTON_PRESSED__REVOKE_FINE_LOCATION = 8;

    // Values for AppPermissionsFragmentViewed.category
    public static final int APP_PERMISSIONS_FRAGMENT_VIEWED__CATEGORY__UNDEFINED = 0;
    public static final int APP_PERMISSIONS_FRAGMENT_VIEWED__CATEGORY__ALLOWED = 1;
    public static final int APP_PERMISSIONS_FRAGMENT_VIEWED__CATEGORY__ALLOWED_FOREGROUND = 2;
    public static final int APP_PERMISSIONS_FRAGMENT_VIEWED__CATEGORY__DENIED = 3;

    // Values for PermissionAppsFragmentViewed.category
    public static final int PERMISSION_APPS_FRAGMENT_VIEWED__CATEGORY__UNDEFINED = 0;
    public static final int PERMISSION_APPS_FRAGMENT_VIEWED__CATEGORY__ALLOWED = 1;
    public static final int PERMISSION_APPS_FRAGMENT_VIEWED__CATEGORY__ALLOWED_FOREGROUND = 2;
    public static final int PERMISSION_APPS_FRAGMENT_VIEWED__CATEGORY__DENIED = 3;

    // Values for AutoRevokeFragmentAppViewed.age
    public static final int AUTO_REVOKE_FRAGMENT_APP_VIEWED__AGE__UNDEFINED = 0;
    public static final int AUTO_REVOKE_FRAGMENT_APP_VIEWED__AGE__NEWER_BUCKET = 1;
    public static final int AUTO_REVOKE_FRAGMENT_APP_VIEWED__AGE__OLDER_BUCKET = 2;

    // Values for AutoRevokedAppInteraction.action
    public static final int AUTO_REVOKED_APP_INTERACTION__ACTION__UNDEFINED = 0;
    public static final int AUTO_REVOKED_APP_INTERACTION__ACTION__REMOVE = 1;
    public static final int AUTO_REVOKED_APP_INTERACTION__ACTION__OPEN = 2;
    public static final int AUTO_REVOKED_APP_INTERACTION__ACTION__APP_INFO = 3;
    public static final int AUTO_REVOKED_APP_INTERACTION__ACTION__PERMISSIONS = 4;
    public static final int AUTO_REVOKED_APP_INTERACTION__ACTION__REMOVE_IN_SETTINGS = 5;
    public static final int AUTO_REVOKED_APP_INTERACTION__ACTION__OPEN_IN_SETTINGS = 6;

    // Values for AppPermissionGroupsFragmentAutoRevokeAction.action
    public static final int APP_PERMISSION_GROUPS_FRAGMENT_AUTO_REVOKE_ACTION__ACTION__UNDEFINED = 0;
    public static final int APP_PERMISSION_GROUPS_FRAGMENT_AUTO_REVOKE_ACTION__ACTION__OPENED_FOR_AUTO_REVOKE = 1;
    public static final int APP_PERMISSION_GROUPS_FRAGMENT_AUTO_REVOKE_ACTION__ACTION__OPENED_FROM_INTENT = 2;
    public static final int APP_PERMISSION_GROUPS_FRAGMENT_AUTO_REVOKE_ACTION__ACTION__SWITCH_ENABLED = 3;
    public static final int APP_PERMISSION_GROUPS_FRAGMENT_AUTO_REVOKE_ACTION__ACTION__SWITCH_DISABLED = 4;

    // Values for PermissionUsageFragmentInteraction.action
    public static final int PERMISSION_USAGE_FRAGMENT_INTERACTION__ACTION__UNDEFINED = 0;
    public static final int PERMISSION_USAGE_FRAGMENT_INTERACTION__ACTION__OPEN = 1;
    public static final int PERMISSION_USAGE_FRAGMENT_INTERACTION__ACTION__LOCATION_ACCESS_TIMELINE_VIEWED = 2;
    public static final int PERMISSION_USAGE_FRAGMENT_INTERACTION__ACTION__CAMERA_ACCESS_TIMELINE_VIEWED = 3;
    public static final int PERMISSION_USAGE_FRAGMENT_INTERACTION__ACTION__MICROPHONE_ACCESS_TIMELINE_VIEWED = 4;
    public static final int PERMISSION_USAGE_FRAGMENT_INTERACTION__ACTION__SHOW_SYSTEM_CLICKED = 5;
    public static final int PERMISSION_USAGE_FRAGMENT_INTERACTION__ACTION__SEE_OTHER_PERMISSIONS_CLICKED = 6;

    // Values for PermissionDetailsInteraction.action
    public static final int PERMISSION_DETAILS_INTERACTION__ACTION__UNDEFINED = 0;
    public static final int PERMISSION_DETAILS_INTERACTION__ACTION__SHOW_SYSTEM_CLICKED = 1;
    public static final int PERMISSION_DETAILS_INTERACTION__ACTION__INFO_ICON_CLICKED = 2;

    // Annotation constants.
    public static final byte ANNOTATION_ID_IS_UID =
            Build.VERSION.SDK_INT <= Build.VERSION_CODES.R ?
            1 : StatsLog.ANNOTATION_ID_IS_UID;

    public static final byte ANNOTATION_ID_TRUNCATE_TIMESTAMP =
            Build.VERSION.SDK_INT <= Build.VERSION_CODES.R ?
            2 : StatsLog.ANNOTATION_ID_TRUNCATE_TIMESTAMP;

    public static final byte ANNOTATION_ID_PRIMARY_FIELD =
            Build.VERSION.SDK_INT <= Build.VERSION_CODES.R ?
            3 : StatsLog.ANNOTATION_ID_PRIMARY_FIELD;

    public static final byte ANNOTATION_ID_EXCLUSIVE_STATE =
            Build.VERSION.SDK_INT <= Build.VERSION_CODES.R ?
            4 : StatsLog.ANNOTATION_ID_EXCLUSIVE_STATE;

    public static final byte ANNOTATION_ID_PRIMARY_FIELD_FIRST_UID =
            Build.VERSION.SDK_INT <= Build.VERSION_CODES.R ?
            5 : StatsLog.ANNOTATION_ID_PRIMARY_FIELD_FIRST_UID;

    public static final byte ANNOTATION_ID_TRIGGER_STATE_RESET =
            Build.VERSION.SDK_INT <= Build.VERSION_CODES.R ?
            7 : StatsLog.ANNOTATION_ID_TRIGGER_STATE_RESET;

    public static final byte ANNOTATION_ID_STATE_NESTED =
            Build.VERSION.SDK_INT <= Build.VERSION_CODES.R ?
            8 : StatsLog.ANNOTATION_ID_STATE_NESTED;


    // Write methods
    public static void write(int code, int arg1) {
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.Q) {
            final StatsEvent.Builder builder = StatsEvent.newBuilder();
            builder.setAtomId(code);
            builder.writeInt(arg1);
        if (PRIVACY_INDICATORS_INTERACTED == code) {
            builder.addBooleanAnnotation(ANNOTATION_ID_EXCLUSIVE_STATE, true);
        }

            builder.usePooledBuffer();
            StatsLog.write(builder.build());
        } else {
            QLogger.write(code, arg1);
        }
    }

    public static void write(int code, int arg1, java.lang.String arg2, java.lang.String arg3, int arg4, int arg5, java.lang.String arg6, int arg7, java.lang.String arg8, int arg9) {
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.Q) {
            final StatsEvent.Builder builder = StatsEvent.newBuilder();
            builder.setAtomId(code);
            builder.writeInt(arg1);
            builder.writeString(arg2);
            builder.writeString(arg3);
            builder.writeInt(arg4);
            builder.writeInt(arg5);
            builder.writeString(arg6);
            builder.writeInt(arg7);
            builder.writeString(arg8);
            builder.writeInt(arg9);

            builder.usePooledBuffer();
            StatsLog.write(builder.build());
        } else {
            QLogger.write(code, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
        }
    }

    public static void write(int code, long arg1) {
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.Q) {
            final StatsEvent.Builder builder = StatsEvent.newBuilder();
            builder.setAtomId(code);
            builder.writeLong(arg1);

            builder.usePooledBuffer();
            StatsLog.write(builder.build());
        } else {
            QLogger.write(code, arg1);
        }
    }

    public static void write(int code, long arg1, int arg2) {
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.Q) {
            final StatsEvent.Builder builder = StatsEvent.newBuilder();
            builder.setAtomId(code);
            builder.writeLong(arg1);
            builder.writeInt(arg2);

            builder.usePooledBuffer();
            StatsLog.write(builder.build());
        } else {
            QLogger.write(code, arg1, arg2);
        }
    }

    public static void write(int code, long arg1, int arg2, java.lang.String arg3, int arg4) {
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.Q) {
            final StatsEvent.Builder builder = StatsEvent.newBuilder();
            builder.setAtomId(code);
            builder.writeLong(arg1);
            builder.writeInt(arg2);
        if (AUTO_REVOKED_APP_INTERACTION == code) {
            builder.addBooleanAnnotation(ANNOTATION_ID_IS_UID, true);
        }
        if (APP_PERMISSION_GROUPS_FRAGMENT_AUTO_REVOKE_ACTION == code) {
            builder.addBooleanAnnotation(ANNOTATION_ID_IS_UID, true);
        }
            builder.writeString(arg3);
            builder.writeInt(arg4);

            builder.usePooledBuffer();
            StatsLog.write(builder.build());
        } else {
            QLogger.write(code, arg1, arg2, arg3, arg4);
        }
    }

    public static void write(int code, long arg1, int arg2, java.lang.String arg3, java.lang.String arg4) {
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.Q) {
            final StatsEvent.Builder builder = StatsEvent.newBuilder();
            builder.setAtomId(code);
            builder.writeLong(arg1);
            builder.writeInt(arg2);
        if (APP_PERMISSION_FRAGMENT_VIEWED == code) {
            builder.addBooleanAnnotation(ANNOTATION_ID_IS_UID, true);
        }
            builder.writeString(arg3);
            builder.writeString(arg4);

            builder.usePooledBuffer();
            StatsLog.write(builder.build());
        } else {
            QLogger.write(code, arg1, arg2, arg3, arg4);
        }
    }

    public static void write(int code, long arg1, int arg2, java.lang.String arg3, java.lang.String arg4, boolean arg5) {
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.Q) {
            final StatsEvent.Builder builder = StatsEvent.newBuilder();
            builder.setAtomId(code);
            builder.writeLong(arg1);
            builder.writeInt(arg2);
        if (REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED == code) {
            builder.addBooleanAnnotation(ANNOTATION_ID_IS_UID, true);
        }
            builder.writeString(arg3);
            builder.writeString(arg4);
            builder.writeBoolean(arg5);

            builder.usePooledBuffer();
            StatsLog.write(builder.build());
        } else {
            QLogger.write(code, arg1, arg2, arg3, arg4, arg5);
        }
    }

    public static void write(int code, long arg1, int arg2, java.lang.String arg3, java.lang.String arg4, boolean arg5, int arg6) {
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.Q) {
            final StatsEvent.Builder builder = StatsEvent.newBuilder();
            builder.setAtomId(code);
            builder.writeLong(arg1);
            builder.writeInt(arg2);
        if (PERMISSION_GRANT_REQUEST_RESULT_REPORTED == code) {
            builder.addBooleanAnnotation(ANNOTATION_ID_IS_UID, true);
        }
            builder.writeString(arg3);
            builder.writeString(arg4);
            builder.writeBoolean(arg5);
            builder.writeInt(arg6);

            builder.usePooledBuffer();
            StatsLog.write(builder.build());
        } else {
            QLogger.write(code, arg1, arg2, arg3, arg4, arg5, arg6);
        }
    }

    public static void write(int code, long arg1, int arg2, java.lang.String arg3, java.lang.String arg4, int arg5) {
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.Q) {
            final StatsEvent.Builder builder = StatsEvent.newBuilder();
            builder.setAtomId(code);
            builder.writeLong(arg1);
            builder.writeInt(arg2);
        if (AUTO_REVOKE_FRAGMENT_APP_VIEWED == code) {
            builder.addBooleanAnnotation(ANNOTATION_ID_IS_UID, true);
        }
            builder.writeString(arg3);
            builder.writeString(arg4);
            builder.writeInt(arg5);

            builder.usePooledBuffer();
            StatsLog.write(builder.build());
        } else {
            QLogger.write(code, arg1, arg2, arg3, arg4, arg5);
        }
    }

    public static void write(int code, long arg1, long arg2, int arg3, java.lang.String arg4, java.lang.String arg5, boolean arg6, int arg7, int arg8) {
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.Q) {
            final StatsEvent.Builder builder = StatsEvent.newBuilder();
            builder.setAtomId(code);
            builder.writeLong(arg1);
            builder.writeLong(arg2);
            builder.writeInt(arg3);
        if (APP_PERMISSION_FRAGMENT_ACTION_REPORTED == code) {
            builder.addBooleanAnnotation(ANNOTATION_ID_IS_UID, true);
        }
            builder.writeString(arg4);
            builder.writeString(arg5);
            builder.writeBoolean(arg6);
            builder.writeInt(arg7);
            builder.writeInt(arg8);

            builder.usePooledBuffer();
            StatsLog.write(builder.build());
        } else {
            QLogger.write(code, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
        }
    }

    public static void write(int code, long arg1, long arg2, java.lang.String arg3, int arg4, java.lang.String arg5, int arg6) {
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.Q) {
            final StatsEvent.Builder builder = StatsEvent.newBuilder();
            builder.setAtomId(code);
            builder.writeLong(arg1);
            builder.writeLong(arg2);
            builder.writeString(arg3);
            builder.writeInt(arg4);
        if (APP_PERMISSIONS_FRAGMENT_VIEWED == code) {
            builder.addBooleanAnnotation(ANNOTATION_ID_IS_UID, true);
        }
        if (PERMISSION_APPS_FRAGMENT_VIEWED == code) {
            builder.addBooleanAnnotation(ANNOTATION_ID_IS_UID, true);
        }
            builder.writeString(arg5);
            builder.writeInt(arg6);

            builder.usePooledBuffer();
            StatsLog.write(builder.build());
        } else {
            QLogger.write(code, arg1, arg2, arg3, arg4, arg5, arg6);
        }
    }

    public static void write(int code, long arg1, java.lang.String arg2, java.lang.String arg3, int arg4) {
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.Q) {
            final StatsEvent.Builder builder = StatsEvent.newBuilder();
            builder.setAtomId(code);
            builder.writeLong(arg1);
            builder.writeString(arg2);
            builder.writeString(arg3);
            builder.writeInt(arg4);

            builder.usePooledBuffer();
            StatsLog.write(builder.build());
        } else {
            QLogger.write(code, arg1, arg2, arg3, arg4);
        }
    }

    public static void write(int code, java.lang.String arg1, int arg2, java.lang.String arg3) {
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.Q) {
            final StatsEvent.Builder builder = StatsEvent.newBuilder();
            builder.setAtomId(code);
            builder.writeString(arg1);
            builder.writeInt(arg2);
        if (RUNTIME_PERMISSIONS_UPGRADE_RESULT == code) {
            builder.addBooleanAnnotation(ANNOTATION_ID_IS_UID, true);
        }
            builder.writeString(arg3);

            builder.usePooledBuffer();
            StatsLog.write(builder.build());
        } else {
            QLogger.write(code, arg1, arg2, arg3);
        }
    }

    public static void write(int code, java.lang.String arg1, int arg2, java.lang.String arg3, int arg4, int arg5, long arg6, int arg7, int arg8) {
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.Q) {
            final StatsEvent.Builder builder = StatsEvent.newBuilder();
            builder.setAtomId(code);
            builder.writeString(arg1);
            builder.writeInt(arg2);
        if (GRANT_PERMISSIONS_ACTIVITY_BUTTON_ACTIONS == code) {
            builder.addBooleanAnnotation(ANNOTATION_ID_IS_UID, true);
        }
            builder.writeString(arg3);
            builder.writeInt(arg4);
            builder.writeInt(arg5);
            builder.writeLong(arg6);
            builder.writeInt(arg7);
            builder.writeInt(arg8);

            builder.usePooledBuffer();
            StatsLog.write(builder.build());
        } else {
            QLogger.write(code, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
        }
    }


    // Write logging helper methods for statsd in Q and earlier.
    private static class QLogger {
        // Payload limits.
        private static final int LOGGER_ENTRY_MAX_PAYLOAD = 4068;
        private static final int MAX_EVENT_PAYLOAD = LOGGER_ENTRY_MAX_PAYLOAD - 4;

        // Value types.
        private static final byte INT_TYPE = 0;
        private static final byte LONG_TYPE = 1;
        private static final byte STRING_TYPE = 2;
        private static final byte LIST_TYPE = 3;
        private static final byte FLOAT_TYPE = 4;

        // Size of each value type.
        private static final int INT_TYPE_SIZE = 5;
        private static final int FLOAT_TYPE_SIZE = 5;
        private static final int LONG_TYPE_SIZE = 9;
        private static final int STRING_TYPE_OVERHEAD = 5;
        private static final int LIST_TYPE_OVERHEAD = 2;

        // Write methods.
        public static void write(int code, int arg1) {
            // Initial overhead of the list, timestamp, and atom tag.
            int needed = LIST_TYPE_OVERHEAD + LONG_TYPE_SIZE + INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            if (needed > MAX_EVENT_PAYLOAD) {
                return;
            }
            byte[] buff = new byte[needed];
            int pos = 0;
            buff[pos] = LIST_TYPE;
            buff[pos + 1] = 3;
            pos += LIST_TYPE_OVERHEAD;
            long elapsedRealtime = SystemClock.elapsedRealtimeNanos();
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, elapsedRealtime);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, code);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg1);
            pos += INT_TYPE_SIZE;
            StatsLog.writeRaw(buff, pos);
        }

        public static void write(int code, int arg1, java.lang.String arg2, java.lang.String arg3, int arg4, int arg5, java.lang.String arg6, int arg7, java.lang.String arg8, int arg9) {
            // Initial overhead of the list, timestamp, and atom tag.
            int needed = LIST_TYPE_OVERHEAD + LONG_TYPE_SIZE + INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            if (arg2 == null) {
                arg2 = "";
            }
            byte[] arg2Bytes = arg2.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            needed += STRING_TYPE_OVERHEAD + arg2Bytes.length;
            if (arg3 == null) {
                arg3 = "";
            }
            byte[] arg3Bytes = arg3.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            needed += STRING_TYPE_OVERHEAD + arg3Bytes.length;
            needed += INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            if (arg6 == null) {
                arg6 = "";
            }
            byte[] arg6Bytes = arg6.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            needed += STRING_TYPE_OVERHEAD + arg6Bytes.length;
            needed += INT_TYPE_SIZE;
            if (arg8 == null) {
                arg8 = "";
            }
            byte[] arg8Bytes = arg8.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            needed += STRING_TYPE_OVERHEAD + arg8Bytes.length;
            needed += INT_TYPE_SIZE;
            if (needed > MAX_EVENT_PAYLOAD) {
                return;
            }
            byte[] buff = new byte[needed];
            int pos = 0;
            buff[pos] = LIST_TYPE;
            buff[pos + 1] = 11;
            pos += LIST_TYPE_OVERHEAD;
            long elapsedRealtime = SystemClock.elapsedRealtimeNanos();
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, elapsedRealtime);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, code);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg1);
            pos += INT_TYPE_SIZE;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg2Bytes.length);
            System.arraycopy(arg2Bytes, 0, buff, pos + STRING_TYPE_OVERHEAD, arg2Bytes.length);
            pos += STRING_TYPE_OVERHEAD + arg2Bytes.length;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg3Bytes.length);
            System.arraycopy(arg3Bytes, 0, buff, pos + STRING_TYPE_OVERHEAD, arg3Bytes.length);
            pos += STRING_TYPE_OVERHEAD + arg3Bytes.length;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg4);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg5);
            pos += INT_TYPE_SIZE;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg6Bytes.length);
            System.arraycopy(arg6Bytes, 0, buff, pos + STRING_TYPE_OVERHEAD, arg6Bytes.length);
            pos += STRING_TYPE_OVERHEAD + arg6Bytes.length;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg7);
            pos += INT_TYPE_SIZE;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg8Bytes.length);
            System.arraycopy(arg8Bytes, 0, buff, pos + STRING_TYPE_OVERHEAD, arg8Bytes.length);
            pos += STRING_TYPE_OVERHEAD + arg8Bytes.length;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg9);
            pos += INT_TYPE_SIZE;
            StatsLog.writeRaw(buff, pos);
        }

        public static void write(int code, long arg1) {
            // Initial overhead of the list, timestamp, and atom tag.
            int needed = LIST_TYPE_OVERHEAD + LONG_TYPE_SIZE + INT_TYPE_SIZE;
            needed += LONG_TYPE_SIZE;
            if (needed > MAX_EVENT_PAYLOAD) {
                return;
            }
            byte[] buff = new byte[needed];
            int pos = 0;
            buff[pos] = LIST_TYPE;
            buff[pos + 1] = 3;
            pos += LIST_TYPE_OVERHEAD;
            long elapsedRealtime = SystemClock.elapsedRealtimeNanos();
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, elapsedRealtime);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, code);
            pos += INT_TYPE_SIZE;
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, arg1);
            pos += LONG_TYPE_SIZE;
            StatsLog.writeRaw(buff, pos);
        }

        public static void write(int code, long arg1, int arg2) {
            // Initial overhead of the list, timestamp, and atom tag.
            int needed = LIST_TYPE_OVERHEAD + LONG_TYPE_SIZE + INT_TYPE_SIZE;
            needed += LONG_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            if (needed > MAX_EVENT_PAYLOAD) {
                return;
            }
            byte[] buff = new byte[needed];
            int pos = 0;
            buff[pos] = LIST_TYPE;
            buff[pos + 1] = 4;
            pos += LIST_TYPE_OVERHEAD;
            long elapsedRealtime = SystemClock.elapsedRealtimeNanos();
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, elapsedRealtime);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, code);
            pos += INT_TYPE_SIZE;
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, arg1);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg2);
            pos += INT_TYPE_SIZE;
            StatsLog.writeRaw(buff, pos);
        }

        public static void write(int code, long arg1, int arg2, java.lang.String arg3, int arg4) {
            // Initial overhead of the list, timestamp, and atom tag.
            int needed = LIST_TYPE_OVERHEAD + LONG_TYPE_SIZE + INT_TYPE_SIZE;
            needed += LONG_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            if (arg3 == null) {
                arg3 = "";
            }
            byte[] arg3Bytes = arg3.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            needed += STRING_TYPE_OVERHEAD + arg3Bytes.length;
            needed += INT_TYPE_SIZE;
            if (needed > MAX_EVENT_PAYLOAD) {
                return;
            }
            byte[] buff = new byte[needed];
            int pos = 0;
            buff[pos] = LIST_TYPE;
            buff[pos + 1] = 6;
            pos += LIST_TYPE_OVERHEAD;
            long elapsedRealtime = SystemClock.elapsedRealtimeNanos();
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, elapsedRealtime);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, code);
            pos += INT_TYPE_SIZE;
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, arg1);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg2);
            pos += INT_TYPE_SIZE;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg3Bytes.length);
            System.arraycopy(arg3Bytes, 0, buff, pos + STRING_TYPE_OVERHEAD, arg3Bytes.length);
            pos += STRING_TYPE_OVERHEAD + arg3Bytes.length;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg4);
            pos += INT_TYPE_SIZE;
            StatsLog.writeRaw(buff, pos);
        }

        public static void write(int code, long arg1, int arg2, java.lang.String arg3, java.lang.String arg4) {
            // Initial overhead of the list, timestamp, and atom tag.
            int needed = LIST_TYPE_OVERHEAD + LONG_TYPE_SIZE + INT_TYPE_SIZE;
            needed += LONG_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            if (arg3 == null) {
                arg3 = "";
            }
            byte[] arg3Bytes = arg3.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            needed += STRING_TYPE_OVERHEAD + arg3Bytes.length;
            if (arg4 == null) {
                arg4 = "";
            }
            byte[] arg4Bytes = arg4.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            needed += STRING_TYPE_OVERHEAD + arg4Bytes.length;
            if (needed > MAX_EVENT_PAYLOAD) {
                return;
            }
            byte[] buff = new byte[needed];
            int pos = 0;
            buff[pos] = LIST_TYPE;
            buff[pos + 1] = 6;
            pos += LIST_TYPE_OVERHEAD;
            long elapsedRealtime = SystemClock.elapsedRealtimeNanos();
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, elapsedRealtime);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, code);
            pos += INT_TYPE_SIZE;
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, arg1);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg2);
            pos += INT_TYPE_SIZE;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg3Bytes.length);
            System.arraycopy(arg3Bytes, 0, buff, pos + STRING_TYPE_OVERHEAD, arg3Bytes.length);
            pos += STRING_TYPE_OVERHEAD + arg3Bytes.length;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg4Bytes.length);
            System.arraycopy(arg4Bytes, 0, buff, pos + STRING_TYPE_OVERHEAD, arg4Bytes.length);
            pos += STRING_TYPE_OVERHEAD + arg4Bytes.length;
            StatsLog.writeRaw(buff, pos);
        }

        public static void write(int code, long arg1, int arg2, java.lang.String arg3, java.lang.String arg4, boolean arg5) {
            // Initial overhead of the list, timestamp, and atom tag.
            int needed = LIST_TYPE_OVERHEAD + LONG_TYPE_SIZE + INT_TYPE_SIZE;
            needed += LONG_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            if (arg3 == null) {
                arg3 = "";
            }
            byte[] arg3Bytes = arg3.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            needed += STRING_TYPE_OVERHEAD + arg3Bytes.length;
            if (arg4 == null) {
                arg4 = "";
            }
            byte[] arg4Bytes = arg4.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            needed += STRING_TYPE_OVERHEAD + arg4Bytes.length;
            needed += INT_TYPE_SIZE;
            if (needed > MAX_EVENT_PAYLOAD) {
                return;
            }
            byte[] buff = new byte[needed];
            int pos = 0;
            buff[pos] = LIST_TYPE;
            buff[pos + 1] = 7;
            pos += LIST_TYPE_OVERHEAD;
            long elapsedRealtime = SystemClock.elapsedRealtimeNanos();
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, elapsedRealtime);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, code);
            pos += INT_TYPE_SIZE;
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, arg1);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg2);
            pos += INT_TYPE_SIZE;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg3Bytes.length);
            System.arraycopy(arg3Bytes, 0, buff, pos + STRING_TYPE_OVERHEAD, arg3Bytes.length);
            pos += STRING_TYPE_OVERHEAD + arg3Bytes.length;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg4Bytes.length);
            System.arraycopy(arg4Bytes, 0, buff, pos + STRING_TYPE_OVERHEAD, arg4Bytes.length);
            pos += STRING_TYPE_OVERHEAD + arg4Bytes.length;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg5? 1 : 0);
            pos += INT_TYPE_SIZE;
            StatsLog.writeRaw(buff, pos);
        }

        public static void write(int code, long arg1, int arg2, java.lang.String arg3, java.lang.String arg4, boolean arg5, int arg6) {
            // Initial overhead of the list, timestamp, and atom tag.
            int needed = LIST_TYPE_OVERHEAD + LONG_TYPE_SIZE + INT_TYPE_SIZE;
            needed += LONG_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            if (arg3 == null) {
                arg3 = "";
            }
            byte[] arg3Bytes = arg3.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            needed += STRING_TYPE_OVERHEAD + arg3Bytes.length;
            if (arg4 == null) {
                arg4 = "";
            }
            byte[] arg4Bytes = arg4.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            needed += STRING_TYPE_OVERHEAD + arg4Bytes.length;
            needed += INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            if (needed > MAX_EVENT_PAYLOAD) {
                return;
            }
            byte[] buff = new byte[needed];
            int pos = 0;
            buff[pos] = LIST_TYPE;
            buff[pos + 1] = 8;
            pos += LIST_TYPE_OVERHEAD;
            long elapsedRealtime = SystemClock.elapsedRealtimeNanos();
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, elapsedRealtime);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, code);
            pos += INT_TYPE_SIZE;
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, arg1);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg2);
            pos += INT_TYPE_SIZE;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg3Bytes.length);
            System.arraycopy(arg3Bytes, 0, buff, pos + STRING_TYPE_OVERHEAD, arg3Bytes.length);
            pos += STRING_TYPE_OVERHEAD + arg3Bytes.length;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg4Bytes.length);
            System.arraycopy(arg4Bytes, 0, buff, pos + STRING_TYPE_OVERHEAD, arg4Bytes.length);
            pos += STRING_TYPE_OVERHEAD + arg4Bytes.length;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg5? 1 : 0);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg6);
            pos += INT_TYPE_SIZE;
            StatsLog.writeRaw(buff, pos);
        }

        public static void write(int code, long arg1, int arg2, java.lang.String arg3, java.lang.String arg4, int arg5) {
            // Initial overhead of the list, timestamp, and atom tag.
            int needed = LIST_TYPE_OVERHEAD + LONG_TYPE_SIZE + INT_TYPE_SIZE;
            needed += LONG_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            if (arg3 == null) {
                arg3 = "";
            }
            byte[] arg3Bytes = arg3.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            needed += STRING_TYPE_OVERHEAD + arg3Bytes.length;
            if (arg4 == null) {
                arg4 = "";
            }
            byte[] arg4Bytes = arg4.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            needed += STRING_TYPE_OVERHEAD + arg4Bytes.length;
            needed += INT_TYPE_SIZE;
            if (needed > MAX_EVENT_PAYLOAD) {
                return;
            }
            byte[] buff = new byte[needed];
            int pos = 0;
            buff[pos] = LIST_TYPE;
            buff[pos + 1] = 7;
            pos += LIST_TYPE_OVERHEAD;
            long elapsedRealtime = SystemClock.elapsedRealtimeNanos();
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, elapsedRealtime);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, code);
            pos += INT_TYPE_SIZE;
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, arg1);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg2);
            pos += INT_TYPE_SIZE;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg3Bytes.length);
            System.arraycopy(arg3Bytes, 0, buff, pos + STRING_TYPE_OVERHEAD, arg3Bytes.length);
            pos += STRING_TYPE_OVERHEAD + arg3Bytes.length;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg4Bytes.length);
            System.arraycopy(arg4Bytes, 0, buff, pos + STRING_TYPE_OVERHEAD, arg4Bytes.length);
            pos += STRING_TYPE_OVERHEAD + arg4Bytes.length;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg5);
            pos += INT_TYPE_SIZE;
            StatsLog.writeRaw(buff, pos);
        }

        public static void write(int code, long arg1, long arg2, int arg3, java.lang.String arg4, java.lang.String arg5, boolean arg6, int arg7, int arg8) {
            // Initial overhead of the list, timestamp, and atom tag.
            int needed = LIST_TYPE_OVERHEAD + LONG_TYPE_SIZE + INT_TYPE_SIZE;
            needed += LONG_TYPE_SIZE;
            needed += LONG_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            if (arg4 == null) {
                arg4 = "";
            }
            byte[] arg4Bytes = arg4.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            needed += STRING_TYPE_OVERHEAD + arg4Bytes.length;
            if (arg5 == null) {
                arg5 = "";
            }
            byte[] arg5Bytes = arg5.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            needed += STRING_TYPE_OVERHEAD + arg5Bytes.length;
            needed += INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            if (needed > MAX_EVENT_PAYLOAD) {
                return;
            }
            byte[] buff = new byte[needed];
            int pos = 0;
            buff[pos] = LIST_TYPE;
            buff[pos + 1] = 10;
            pos += LIST_TYPE_OVERHEAD;
            long elapsedRealtime = SystemClock.elapsedRealtimeNanos();
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, elapsedRealtime);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, code);
            pos += INT_TYPE_SIZE;
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, arg1);
            pos += LONG_TYPE_SIZE;
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, arg2);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg3);
            pos += INT_TYPE_SIZE;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg4Bytes.length);
            System.arraycopy(arg4Bytes, 0, buff, pos + STRING_TYPE_OVERHEAD, arg4Bytes.length);
            pos += STRING_TYPE_OVERHEAD + arg4Bytes.length;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg5Bytes.length);
            System.arraycopy(arg5Bytes, 0, buff, pos + STRING_TYPE_OVERHEAD, arg5Bytes.length);
            pos += STRING_TYPE_OVERHEAD + arg5Bytes.length;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg6? 1 : 0);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg7);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg8);
            pos += INT_TYPE_SIZE;
            StatsLog.writeRaw(buff, pos);
        }

        public static void write(int code, long arg1, long arg2, java.lang.String arg3, int arg4, java.lang.String arg5, int arg6) {
            // Initial overhead of the list, timestamp, and atom tag.
            int needed = LIST_TYPE_OVERHEAD + LONG_TYPE_SIZE + INT_TYPE_SIZE;
            needed += LONG_TYPE_SIZE;
            needed += LONG_TYPE_SIZE;
            if (arg3 == null) {
                arg3 = "";
            }
            byte[] arg3Bytes = arg3.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            needed += STRING_TYPE_OVERHEAD + arg3Bytes.length;
            needed += INT_TYPE_SIZE;
            if (arg5 == null) {
                arg5 = "";
            }
            byte[] arg5Bytes = arg5.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            needed += STRING_TYPE_OVERHEAD + arg5Bytes.length;
            needed += INT_TYPE_SIZE;
            if (needed > MAX_EVENT_PAYLOAD) {
                return;
            }
            byte[] buff = new byte[needed];
            int pos = 0;
            buff[pos] = LIST_TYPE;
            buff[pos + 1] = 8;
            pos += LIST_TYPE_OVERHEAD;
            long elapsedRealtime = SystemClock.elapsedRealtimeNanos();
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, elapsedRealtime);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, code);
            pos += INT_TYPE_SIZE;
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, arg1);
            pos += LONG_TYPE_SIZE;
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, arg2);
            pos += LONG_TYPE_SIZE;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg3Bytes.length);
            System.arraycopy(arg3Bytes, 0, buff, pos + STRING_TYPE_OVERHEAD, arg3Bytes.length);
            pos += STRING_TYPE_OVERHEAD + arg3Bytes.length;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg4);
            pos += INT_TYPE_SIZE;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg5Bytes.length);
            System.arraycopy(arg5Bytes, 0, buff, pos + STRING_TYPE_OVERHEAD, arg5Bytes.length);
            pos += STRING_TYPE_OVERHEAD + arg5Bytes.length;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg6);
            pos += INT_TYPE_SIZE;
            StatsLog.writeRaw(buff, pos);
        }

        public static void write(int code, long arg1, java.lang.String arg2, java.lang.String arg3, int arg4) {
            // Initial overhead of the list, timestamp, and atom tag.
            int needed = LIST_TYPE_OVERHEAD + LONG_TYPE_SIZE + INT_TYPE_SIZE;
            needed += LONG_TYPE_SIZE;
            if (arg2 == null) {
                arg2 = "";
            }
            byte[] arg2Bytes = arg2.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            needed += STRING_TYPE_OVERHEAD + arg2Bytes.length;
            if (arg3 == null) {
                arg3 = "";
            }
            byte[] arg3Bytes = arg3.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            needed += STRING_TYPE_OVERHEAD + arg3Bytes.length;
            needed += INT_TYPE_SIZE;
            if (needed > MAX_EVENT_PAYLOAD) {
                return;
            }
            byte[] buff = new byte[needed];
            int pos = 0;
            buff[pos] = LIST_TYPE;
            buff[pos + 1] = 6;
            pos += LIST_TYPE_OVERHEAD;
            long elapsedRealtime = SystemClock.elapsedRealtimeNanos();
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, elapsedRealtime);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, code);
            pos += INT_TYPE_SIZE;
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, arg1);
            pos += LONG_TYPE_SIZE;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg2Bytes.length);
            System.arraycopy(arg2Bytes, 0, buff, pos + STRING_TYPE_OVERHEAD, arg2Bytes.length);
            pos += STRING_TYPE_OVERHEAD + arg2Bytes.length;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg3Bytes.length);
            System.arraycopy(arg3Bytes, 0, buff, pos + STRING_TYPE_OVERHEAD, arg3Bytes.length);
            pos += STRING_TYPE_OVERHEAD + arg3Bytes.length;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg4);
            pos += INT_TYPE_SIZE;
            StatsLog.writeRaw(buff, pos);
        }

        public static void write(int code, java.lang.String arg1, int arg2, java.lang.String arg3) {
            // Initial overhead of the list, timestamp, and atom tag.
            int needed = LIST_TYPE_OVERHEAD + LONG_TYPE_SIZE + INT_TYPE_SIZE;
            if (arg1 == null) {
                arg1 = "";
            }
            byte[] arg1Bytes = arg1.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            needed += STRING_TYPE_OVERHEAD + arg1Bytes.length;
            needed += INT_TYPE_SIZE;
            if (arg3 == null) {
                arg3 = "";
            }
            byte[] arg3Bytes = arg3.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            needed += STRING_TYPE_OVERHEAD + arg3Bytes.length;
            if (needed > MAX_EVENT_PAYLOAD) {
                return;
            }
            byte[] buff = new byte[needed];
            int pos = 0;
            buff[pos] = LIST_TYPE;
            buff[pos + 1] = 5;
            pos += LIST_TYPE_OVERHEAD;
            long elapsedRealtime = SystemClock.elapsedRealtimeNanos();
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, elapsedRealtime);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, code);
            pos += INT_TYPE_SIZE;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg1Bytes.length);
            System.arraycopy(arg1Bytes, 0, buff, pos + STRING_TYPE_OVERHEAD, arg1Bytes.length);
            pos += STRING_TYPE_OVERHEAD + arg1Bytes.length;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg2);
            pos += INT_TYPE_SIZE;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg3Bytes.length);
            System.arraycopy(arg3Bytes, 0, buff, pos + STRING_TYPE_OVERHEAD, arg3Bytes.length);
            pos += STRING_TYPE_OVERHEAD + arg3Bytes.length;
            StatsLog.writeRaw(buff, pos);
        }

        public static void write(int code, java.lang.String arg1, int arg2, java.lang.String arg3, int arg4, int arg5, long arg6, int arg7, int arg8) {
            // Initial overhead of the list, timestamp, and atom tag.
            int needed = LIST_TYPE_OVERHEAD + LONG_TYPE_SIZE + INT_TYPE_SIZE;
            if (arg1 == null) {
                arg1 = "";
            }
            byte[] arg1Bytes = arg1.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            needed += STRING_TYPE_OVERHEAD + arg1Bytes.length;
            needed += INT_TYPE_SIZE;
            if (arg3 == null) {
                arg3 = "";
            }
            byte[] arg3Bytes = arg3.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            needed += STRING_TYPE_OVERHEAD + arg3Bytes.length;
            needed += INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            needed += LONG_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            needed += INT_TYPE_SIZE;
            if (needed > MAX_EVENT_PAYLOAD) {
                return;
            }
            byte[] buff = new byte[needed];
            int pos = 0;
            buff[pos] = LIST_TYPE;
            buff[pos + 1] = 10;
            pos += LIST_TYPE_OVERHEAD;
            long elapsedRealtime = SystemClock.elapsedRealtimeNanos();
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, elapsedRealtime);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, code);
            pos += INT_TYPE_SIZE;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg1Bytes.length);
            System.arraycopy(arg1Bytes, 0, buff, pos + STRING_TYPE_OVERHEAD, arg1Bytes.length);
            pos += STRING_TYPE_OVERHEAD + arg1Bytes.length;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg2);
            pos += INT_TYPE_SIZE;
            buff[pos] = STRING_TYPE;
            copyInt(buff, pos + 1, arg3Bytes.length);
            System.arraycopy(arg3Bytes, 0, buff, pos + STRING_TYPE_OVERHEAD, arg3Bytes.length);
            pos += STRING_TYPE_OVERHEAD + arg3Bytes.length;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg4);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg5);
            pos += INT_TYPE_SIZE;
            buff[pos] = LONG_TYPE;
            copyLong(buff, pos + 1, arg6);
            pos += LONG_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg7);
            pos += INT_TYPE_SIZE;
            buff[pos] = INT_TYPE;
            copyInt(buff, pos + 1, arg8);
            pos += INT_TYPE_SIZE;
            StatsLog.writeRaw(buff, pos);
        }


        // Helper methods for copying primitives
        private static void copyInt(byte[] buff, int pos, int val) {
            buff[pos] = (byte) (val);
            buff[pos + 1] = (byte) (val >> 8);
            buff[pos + 2] = (byte) (val >> 16);
            buff[pos + 3] = (byte) (val >> 24);
            return;
        }

        private static void copyLong(byte[] buff, int pos, long val) {
            buff[pos] = (byte) (val);
            buff[pos + 1] = (byte) (val >> 8);
            buff[pos + 2] = (byte) (val >> 16);
            buff[pos + 3] = (byte) (val >> 24);
            buff[pos + 4] = (byte) (val >> 32);
            buff[pos + 5] = (byte) (val >> 40);
            buff[pos + 6] = (byte) (val >> 48);
            buff[pos + 7] = (byte) (val >> 56);
            return;
        }

    }
}
